[
    {
        "title": "Orderly Queue",
        "question_content": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string.\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.\n&nbsp;\nExample 1:\n\nInput: s = \"cba\", k = 1\nOutput: \"acb\"\nExplanation: \nIn the first move, we move the 1st character 'c' to the end, obtaining the string \"bac\".\nIn the second move, we move the 1st character 'b' to the end, obtaining the final result \"acb\".\n\nExample 2:\n\nInput: s = \"baaca\", k = 3\nOutput: \"aaabc\"\nExplanation: \nIn the first move, we move the 1st character 'b' to the end, obtaining the string \"aacab\".\nIn the second move, we move the 3rd character 'c' to the end, obtaining the final result \"aaabc\".\n\n&nbsp;\nConstraints:\n\n\t1 <= k <= s.length <= 1000\n\ts consist of lowercase English letters.",
        "solutions": [
            {
                "id": 165878,
                "title": "c-java-python-sort-string-or-rotate-string",
                "content": "**Intuition**:\\nFirst, this is string rotation.\\n`12345` -> `23451` -> `34512` -> `45123` -> `51234`\\nI use number instead of letters to make it clear.\\n\\nIf `K == 1`, we can only rotate the whole string.\\nThere are `S.length` different states and\\nwe return the lexicographically smallest string.\\n\\nIf `K > 1`, it means we can:\\n1. rotate the whole string,\\n2. rotate the whole string except the first letter.\\n`012345` -> `023451` -> `034512` -> `045123` -> `051234`\\n\\nWe can rotate `i+1`th big letter to the start (method 1),\\nthen rotate `i`th big letter to the end (method 2).\\n`2XXX01` -> `XXX012`\\n\\nIn this way, we can bubble sort the whole string lexicographically.\\nSo just return sorted string.\\n\\n**C++:**\\n```\\n    string orderlyQueue(string S, int K) {\\n        if (K > 1) {\\n            sort(S.begin(), S.end());\\n            return S;\\n        }\\n        string res = S;\\n        for (int i = 1; i < S.length(); i++)\\n            res = min(res, S.substr(i) + S.substr(0, i));\\n        return res;\\n    }\\n```\\n\\n**Java:**\\n```\\n    public String orderlyQueue(String S, int K) {\\n        if (K > 1) {\\n            char S2[] = S.toCharArray();\\n            Arrays.sort(S2);\\n            return new String(S2);\\n        }\\n        String res = S;\\n        for (int i = 1; i < S.length(); i++) {\\n            String tmp = S.substring(i) + S.substring(0, i);\\n            if (res.compareTo(tmp) > 0) res = tmp;\\n        }\\n        return res;\\n    }\\n```\\n**Python:**\\n```\\n    def orderlyQueue(self, S, K):\\n        return \"\".join(sorted(S)) if K > 1 else min(S[i:] + S[:i] for i in range(len(S)))\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    string orderlyQueue(string S, int K) {\\n        if (K > 1) {\\n            sort(S.begin(), S.end());\\n            return S;\\n        }\\n        string res = S;\\n        for (int i = 1; i < S.length(); i++)\\n            res = min(res, S.substr(i) + S.substr(0, i));\\n        return res;\\n    }\\n```\n```\\n    public String orderlyQueue(String S, int K) {\\n        if (K > 1) {\\n            char S2[] = S.toCharArray();\\n            Arrays.sort(S2);\\n            return new String(S2);\\n        }\\n        String res = S;\\n        for (int i = 1; i < S.length(); i++) {\\n            String tmp = S.substring(i) + S.substring(0, i);\\n            if (res.compareTo(tmp) > 0) res = tmp;\\n        }\\n        return res;\\n    }\\n```\n```\\n    def orderlyQueue(self, S, K):\\n        return \"\".join(sorted(S)) if K > 1 else min(S[i:] + S[:i] for i in range(len(S)))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 165915,
                "title": "when-k-1-you-can-reorder-any-way-you-like-proof",
                "content": "For any String you can move any char to anywhere if you can swap adjacent characters\\n\\nFor any String `abc[XY]def` you can always do following to swap `XY` if k > 1\\n\\n1. `abc[XY]def` original string\\n2. `[XY]defabc` move `a` to the end, `b` to the end, `c` to the end, etc.\\n3. `defabc[YX]` move `Y` to the end, we can do it because k > 1, then move `X` to the end.\\n4. `abc[YX]def` move `d` to the end, `e` to the end, `f` to the end, etc.\\n\\n```\\n    public String orderlyQueue(String s, int k) {\\n        if (k > 1) {\\n            char[] arr = s.toCharArray();\\n            Arrays.sort(arr);\\n            return String.valueOf(arr);\\n        } else {\\n            String min = s;\\n            for (int i = 0; i < s.length(); i++) {\\n                s = s.substring(1) + s.charAt(0);\\n                min = min.compareTo(s) < 0 ? min : s;\\n            }\\n            return min;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String orderlyQueue(String s, int k) {\\n        if (k > 1) {\\n            char[] arr = s.toCharArray();\\n            Arrays.sort(arr);\\n            return String.valueOf(arr);\\n        } else {\\n            String min = s;\\n            for (int i = 0; i < s.length(); i++) {\\n                s = s.substring(1) + s.charAt(0);\\n                min = min.compareTo(s) < 0 ? min : s;\\n            }\\n            return min;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2782787,
                "title": "python3-one-liner-o-n-2-with-intuitive-explanations-and-proof-of-k-2",
                "content": "(1) The constraint said s.length <= 1000, this means a O(n^2) algorithm would work.\\n(2) If k==1, we have no choice but to rotate the string to find the lexicographically smallest s. This can be done in a brute force way in O(n^2), so no big deal.\\n(3) If k==2, this means we can freely sweep any two adjacent elements any number of times, which means we can simply sort ```s``` to get the lexicographically smallest one.\\n>Doing this naively following the problem description, let\\'s say we have an ```s``` = \\'a,b,...\\', let\\'s put \\'a\\' to the end (\\'b,...,a\\'), then keep \\'b\\' in the front and put everything to the end until we see \\'a\\' again, now ```s``` becomes \\'b,a,...\\'. If this example is still not convincing you, let\\'s say ```s``` = \\'...,a,b,...\\', let\\'s put all elements before \\'a\\' to the end, then do the same process as before to get \\'b,a,......\\' (a,b is now swept)\\n\\n(4) If k>2, this means we just have more freedom when sweeping the adjacent elements than k==2...\\nSo for k>1 we just sort s.\\n```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        return \\'\\'.join(sorted(list(s))) if k!=1 else min(s[i:]+s[:i] for i in range(len(s)))\\n```\\n\\nCheck out the Booth\\'s Algorithm for k == 1 case at [\\uD83D\\uDD25 [LeetCode The Hard Way] \\uD83D\\uDD25 Explained Line By Line](https://leetcode.com/problems/orderly-queue/discuss/2782998/LeetCode-The-Hard-Way-Explained-Line-By-Line)\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```s```\n```s```\n```s```\n```s```\n```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        return \\'\\'.join(sorted(list(s))) if k!=1 else min(s[i:]+s[:i] for i in range(len(s)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445733,
                "title": "python-o-n-2-solution-explained",
                "content": "If `K > 1` than we can change any two adjacent elements: first we can rotate our string, such that we have `abX`, where `X` is some string. Then we can put `b` to the end and then `a` to the end, rotate again and we have `baX`. Now we can look at it as an bubble sort: doing these moves we can sort all string. If `K = 1` we allowed only rotate string and goal is to choose smallest one among `n` options.\\n \\n #### Complexity\\nTime complexity is `O(n^2)` for time and `O(n)` for space\\n \\n #### Code\\n ```python\\n class Solution:\\n    def orderlyQueue(self, S, K):\\n        if K > 1: return \"\".join(sorted(S))\\n        return min(S[i:]+S[:i] for i in range(len(S)))\\n ```\\n \\n #### Remark\\n There is also `O(n)` Booth\\'s Algorithm for finding of minimal rotation. Using count sort we can make whole algorithm `O(n)`. However given restrictions it is not needed.\\n \\n If you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```python\\n class Solution:\\n    def orderlyQueue(self, S, K):\\n        if K > 1: return \"\".join(sorted(S))\\n        return min(S[i:]+S[:i] for i in range(len(S)))\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2782761,
                "title": "c-sliding-window-or-sort-fast-0ms",
                "content": "# Approach 1: sliding window or sort\\n\\nDepending on the value of ```k``` we take two different approaches, see inline comments.\\n\\n```cpp\\n    static string orderlyQueue(string s, int k) {\\n        if (k == 1) {\\n            string ans = s;\\n            // Append |s| to itself and look for the smallest string\\n            // that has the same lenght as |s|.\\n            s += s;\\n            for (int i = 1; i < size(ans); ++i)\\n                ans = min(ans, s.substr(i, size(ans)));\\n\\n            return ans;\\n        }\\n        \\n        // With k > 1 we can reorder |s| how we want, so sorting it\\n        // will yield the lexicographically smallest one.\\n        sort(begin(s), end(s));\\n        return s;\\n    }\\n```\\n\\nTo avoid copying the string around for $$k = 1 $$ we use a ```string_view```. For $$k > 1$$ we could use bucket sort, will maybe add this later.\\n\\n```cpp\\n    static string orderlyQueue(string s, int k) {\\n        if (k == 1) {\\n            // TODO(heder): Use Booth Algorithm instead, see\\n            // https://en.wikipedia.org/wiki/Lexicographically_minimal_string_rotation\\n\\n            // Make sure the string doesn\\'t get relocated when doubling\\n            // below, to ensure the string_view is not invalidated.\\n            s.reserve(size(s) * 2);\\n            string_view ans{s};\\n            // Append |s| to itself and look for the smallest string\\n            // that has the same lenght as |s|.\\n            s += s;\\n            string_view sv{s};\\n            for (int i = 1; i < size(ans); ++i)\\n                ans = min(ans, sv.substr(i, size(ans)));\\n\\n            return string{ans};\\n        }\\n        \\n        // With k > 1 we can reorder |s| how we want, so sorting it\\n        // will yield the lexicographically smallest one.\\n        // TODO(heder): Use bucket sort.\\n        sort(begin(s), end(s));\\n        return s;\\n    }\\n```\\n\\nTurns out there is soc. [Booth Algorithm](https://en.wikipedia.org/wiki/Lexicographically_minimal_string_rotation) to efficiently compute the solution for the case of $$k = 1$$. Time permitting, I\\'ll add that too.\\n\\n\\n**Complexity Analysis**\\n  * Time Complexity: For $$k = 1$$ it\\'s $$O(n^2)$$ as we are comparing each substring to the best so far, and for $$k > 1$$ its $$O(n \\\\log n)$$ because we are sorting.\\n  * Space Complexity: For $$k = 1$$ it\\'s $$O(n)$$ for the ```ans``` and as we are doubling the string, and for $$k > 1$$ its $$O(1)$$ as we are sorting the input inplace and returning it.\\n\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```k```\n```cpp\\n    static string orderlyQueue(string s, int k) {\\n        if (k == 1) {\\n            string ans = s;\\n            // Append |s| to itself and look for the smallest string\\n            // that has the same lenght as |s|.\\n            s += s;\\n            for (int i = 1; i < size(ans); ++i)\\n                ans = min(ans, s.substr(i, size(ans)));\\n\\n            return ans;\\n        }\\n        \\n        // With k > 1 we can reorder |s| how we want, so sorting it\\n        // will yield the lexicographically smallest one.\\n        sort(begin(s), end(s));\\n        return s;\\n    }\\n```\n```string_view```\n```cpp\\n    static string orderlyQueue(string s, int k) {\\n        if (k == 1) {\\n            // TODO(heder): Use Booth Algorithm instead, see\\n            // https://en.wikipedia.org/wiki/Lexicographically_minimal_string_rotation\\n\\n            // Make sure the string doesn\\'t get relocated when doubling\\n            // below, to ensure the string_view is not invalidated.\\n            s.reserve(size(s) * 2);\\n            string_view ans{s};\\n            // Append |s| to itself and look for the smallest string\\n            // that has the same lenght as |s|.\\n            s += s;\\n            string_view sv{s};\\n            for (int i = 1; i < size(ans); ++i)\\n                ans = min(ans, sv.substr(i, size(ans)));\\n\\n            return string{ans};\\n        }\\n        \\n        // With k > 1 we can reorder |s| how we want, so sorting it\\n        // will yield the lexicographically smallest one.\\n        // TODO(heder): Use bucket sort.\\n        sort(begin(s), end(s));\\n        return s;\\n    }\\n```\n```ans```",
                "codeTag": "Unknown"
            },
            {
                "id": 2782998,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/DeMWxKNt/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>\\n\\n**Bonus: Booth\\'s Algorithm for k == 1 case.**\\n\\n<iframe src=\"https://leetcode.com/playground/8ehWqJPV/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Go"
                ],
                "code": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/DeMWxKNt/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>\\n\\n**Bonus: Booth\\'s Algorithm for k == 1 case.**\\n\\n<iframe src=\"https://leetcode.com/playground/8ehWqJPV/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 165907,
                "title": "c-solution-sort-rotate",
                "content": "The main idea is the following:\\nif `K == 1`, then we can only rotate the string. Hence we can just rotate it at every position and get the lexicographically smallest string from that.\\nif `K > 1`, we can achieve swap of adjacent characters using the following steps:\\nAssume the string has the following characters: c[0], c[1], c[2],...,c[n-1] and we want to swap some position i (i >= 0 && i < n - 1) with position i+1, or swap c[i] and c[i+1]. We can start by pushing the first character at the end until c[i-1], after that we can push c[i+1] to the back and then push c[i] to the back and then can again keep pushing first characters to the end till we see rotate the string completely. After we do one full rotation we would have effectively swapped c[i] & c[i+1]. \\nFor example:\\nsay n = 5, k = 2 and we want to swap c[2], c[3]\\nInitial state: `c[0], c[1], c[2], c[3], c[4]`\\n`c[1], c[2], c[3], c[4], c[0]`\\n`c[2], c[3], c[4], c[0], c[1]`\\n`c[2], c[4], c[0], c[1], c[3]`\\n`c[4], c[0], c[1], c[3], c[2]`\\n`c[0], c[1], c[3], c[2], c[4]`\\n\\nThus we have achieved swapping of chars c[2] and c[3] without disturbing ordering of other characters (similarly this can be done for any pair of adjacent indices). Swapping adjacent characters is enough to sort the whole string (using bubble sort). Hence we can just sort the input and return the smallest string.\\n\\n```\\n    string orderlyQueue(string S, int K) {\\n        if(K > 1) {\\n            sort(S.begin(), S.end());\\n            return S;\\n        }\\n        \\n        int n = S.size();\\n        string res = S;\\n        S += S;\\n        for(int i=0;i<n;i++) {\\n            if(S.substr(i, n) < res) res = S.substr(i, n);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    string orderlyQueue(string S, int K) {\\n        if(K > 1) {\\n            sort(S.begin(), S.end());\\n            return S;\\n        }\\n        \\n        int n = S.size();\\n        string res = S;\\n        S += S;\\n        for(int i=0;i<n;i++) {\\n            if(S.substr(i, n) < res) res = S.substr(i, n);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 165862,
                "title": "k-1-is-bubblesort",
                "content": "Remind what bubble sort eventually is: **swap pairs**\\n\\nSo, you have a buffer of at least 2 when K>1\\nyou can put them back into the queue in different order: swap!\\n\\nSo, K>1 equals bubble sort\\n\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string S, int K) {\\n        if (K>1){\\n            sort(S.begin(),S.end());\\n            return S;\\n        }\\n        string minS=S;\\n        for (int i=0;i<S.size();++i){\\n            S=S.substr(1)+S.substr(0,1);\\n            minS=min(S,minS);\\n        }\\n        return minS;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string S, int K) {\\n        if (K>1){\\n            sort(S.begin(),S.end());\\n            return S;\\n        }\\n        string minS=S;\\n        for (int i=0;i<S.size();++i){\\n            S=S.substr(1)+S.substr(0,1);\\n            minS=min(S,minS);\\n        }\\n        return minS;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782871,
                "title": "python-c-java-rotate-or-not-rotate-that-is-the-question-proof-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs string rearrangements (rotations) to find lexicographicall minimum string. Time complexity is quadratic: **O(N\\\\*N)**. Space complexity is linear: **O(N)**.\\n\\n**Comment.** The proof of the algorithm consists in 3 steps.\\n1. For `k>1` (we just check for `k=2`), any two adjacent characters can be swapped: `abXYZ -> abXYZ -> aXYZb -> XYZba -> YZbaX -> ZbaXY -> baXYZ`. If `ab` are not in the beginning of the string, i.e., `DEabF`, we first rotate the string `DEabF -> EabFD -> abFDE`, then apply the swap algorithm.\\n2. If we can swap adjacent characters then we can swap any characters in the string, thus, completely sorting the string.\\n3. For `k=1`, the best we can do is rotate the sting character by character and search for the lexicographically minimal one.\\n\\n**Python.**\\n```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k > 1 : return \"\".join(sorted(s))\\n        return min(s[i:]+s[:i] for i in range(len(s)))\\n```\\n\\n**C++.**\\n```\\nclass Solution \\n{\\npublic:\\n    string orderlyQueue(string s, int k) \\n    {\\n        if (k > 1) { sort(s.begin(), s.end()); return s; }\\n        string ss = s;\\n        for (int i = 1; i < s.length(); ++i)\\n            ss = min(ss, s.substr(i) + s.substr(0,i));\\n        return ss;\\n    }\\n};\\n```\\n\\n**Java.** Ugly... but that\\'s Java.\\n```\\nclass Solution \\n{\\n    public String orderlyQueue(String s, int k) \\n    {\\n        if (k > 1)\\n        {\\n            char[] chars = s.toCharArray();\\n            Arrays.sort(chars);\\n            return new String(chars);\\n        }\\n        \\n        String ss = s;\\n        for (int i = 1; i < s.length(); i++) \\n        {\\n            String rot = s.substring(i) + s.substring(0, i);\\n            if (ss.compareTo(rot) > 0) ss = rot;\\n        }\\n        return ss;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k > 1 : return \"\".join(sorted(s))\\n        return min(s[i:]+s[:i] for i in range(len(s)))\\n```\n```\\nclass Solution \\n{\\npublic:\\n    string orderlyQueue(string s, int k) \\n    {\\n        if (k > 1) { sort(s.begin(), s.end()); return s; }\\n        string ss = s;\\n        for (int i = 1; i < s.length(); ++i)\\n            ss = min(ss, s.substr(i) + s.substr(0,i));\\n        return ss;\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\n    public String orderlyQueue(String s, int k) \\n    {\\n        if (k > 1)\\n        {\\n            char[] chars = s.toCharArray();\\n            Arrays.sort(chars);\\n            return new String(chars);\\n        }\\n        \\n        String ss = s;\\n        for (int i = 1; i < s.length(); i++) \\n        {\\n            String rot = s.substring(i) + s.substring(0, i);\\n            if (ss.compareTo(rot) > 0) ss = rot;\\n        }\\n        return ss;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 541497,
                "title": "real-o-n-solution-for-java",
                "content": "When K>=2, any permutation is possible. So I used counting sort.\\nWhen K==1, find the lexicographically smallest rotated sequence. And I found an O(n) solution for this case. Quite similar to the KMP method.\\nAny comment or counter-example is welcome.\\n```\\nclass Solution {\\n    \\n    public String orderlyQueue(String S, int K) {\\n        \\n        int len=S.length();\\n        \\n        if(len==0)return S;\\n        \\n        // Double S\\n        S=S+S;\\n        char[]cs=S.toCharArray();\\n        \\n        if(K>=2){\\n            int[]cnt=new int[26];\\n            for(int i=0;i<len;i++)cnt[cs[i]-\\'a\\']++;\\n            StringBuilder str=new StringBuilder(len);\\n            for(int i=0;i<26;i++){\\n                int n=cnt[i];\\n                for(int j=0;j<n;j++)str.append((char)(i+\\'a\\'));\\n            }\\n            return str.toString();\\n        }\\n        \\n        \\n        // Now K==1\\n        char[] res=new char[len*2];\\n        res[0]=cs[0];\\n        int[] arr=new int[len*2];//prefix function\\n        arr[0]=-1;\\n        \\n        int x=0;\\n        \\n        for(int i=1;i<len*2;i++){\\n            while(x>=0&&res[arr[x]+1]>cs[i])x=arr[x];\\n            res[x+1]=cs[i];\\n            \\n            //update arr\\n            if(x>=0){\\n                int k=arr[x];\\n                while(k>=0&&res[k+1]!=cs[i])k=arr[k];\\n                if(res[k+1]==cs[i])k++;\\n                arr[x+1]=k;\\n            }\\n            \\n            x++;\\n        }\\n        \\n        return new String(res,0,len);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public String orderlyQueue(String S, int K) {\\n        \\n        int len=S.length();\\n        \\n        if(len==0)return S;\\n        \\n        // Double S\\n        S=S+S;\\n        char[]cs=S.toCharArray();\\n        \\n        if(K>=2){\\n            int[]cnt=new int[26];\\n            for(int i=0;i<len;i++)cnt[cs[i]-\\'a\\']++;\\n            StringBuilder str=new StringBuilder(len);\\n            for(int i=0;i<26;i++){\\n                int n=cnt[i];\\n                for(int j=0;j<n;j++)str.append((char)(i+\\'a\\'));\\n            }\\n            return str.toString();\\n        }\\n        \\n        \\n        // Now K==1\\n        char[] res=new char[len*2];\\n        res[0]=cs[0];\\n        int[] arr=new int[len*2];//prefix function\\n        arr[0]=-1;\\n        \\n        int x=0;\\n        \\n        for(int i=1;i<len*2;i++){\\n            while(x>=0&&res[arr[x]+1]>cs[i])x=arr[x];\\n            res[x+1]=cs[i];\\n            \\n            //update arr\\n            if(x>=0){\\n                int k=arr[x];\\n                while(k>=0&&res[k+1]!=cs[i])k=arr[k];\\n                if(res[k+1]==cs[i])k++;\\n                arr[x+1]=k;\\n            }\\n            \\n            x++;\\n        }\\n        \\n        return new String(res,0,len);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782816,
                "title": "java-faster-simple-and-easy",
                "content": "**Please upvote if you like this solution**\\n```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k>1){\\n            char tempArray[] = s.toCharArray();\\n            Arrays.sort(tempArray);\\n            return new String(tempArray);\\n        } else {\\n            String ans  = s;\\n            for(int i=0;i< s.length(); i++){\\n                s = s.substring(1) + s.substring(0,1);\\n                if(ans.compareTo(s) >0){\\n                    ans = s;\\n                }\\n            }\\n            return ans;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k>1){\\n            char tempArray[] = s.toCharArray();\\n            Arrays.sort(tempArray);\\n            return new String(tempArray);\\n        } else {\\n            String ans  = s;\\n            for(int i=0;i< s.length(); i++){\\n                s = s.substring(1) + s.substring(0,1);\\n                if(ans.compareTo(s) >0){\\n                    ans = s;\\n                }\\n            }\\n            return ans;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783233,
                "title": "python-simple-and-easy-way-to-solve-with-explanation-99-faster",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k > 1:\\n            return \"\".join(sorted(s))\\n        \\n        res = s\\n        for i in range(0,len(s)):\\n            s = s[1:] + s[0]\\n            res = min(res,s)\\n                \\n        return res\\n```\\n\\n**For Detail Explaination Refer this Blog:\\nhttps://www.python-techs.com/2022/11/orderly-queue.html**\\n\\nThank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k > 1:\\n            return \"\".join(sorted(s))\\n        \\n        res = s\\n        for i in range(0,len(s)):\\n            s = s[1:] + s[0]\\n            res = min(res,s)\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784359,
                "title": "short-c-explained-solution-beginner-friendly-by-mr-coder",
                "content": "**C++**\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string S, int K) {\\n       // for k>1 we can make it fully sorted string after roation because here we are not bound to the roatate first char only.\\n        if (K > 1) {\\n            sort(S.begin(), S.end());\\n            return S;\\n        }\\n        // for k==1 we can rotate whole string any times like-  S=\"cba\" we can get cba, bac,acb so in S+S =\"cbacba\" we need to find only lexicographically smallest string  of size n in S+S.\\n            string tempr=S;\\n            S= S+ S;\\n            for(int i=1;i<tempr.size();i++){\\n                tempr=min(tempr,S.substr(i,tempr.size()));\\n            }\\n            return tempr;\\n    }\\n};\\n```\\n**If you find my solution helpful please upvote it.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string S, int K) {\\n       // for k>1 we can make it fully sorted string after roation because here we are not bound to the roatate first char only.\\n        if (K > 1) {\\n            sort(S.begin(), S.end());\\n            return S;\\n        }\\n        // for k==1 we can rotate whole string any times like-  S=\"cba\" we can get cba, bac,acb so in S+S =\"cbacba\" we need to find only lexicographically smallest string  of size n in S+S.\\n            string tempr=S;\\n            S= S+ S;\\n            for(int i=1;i<tempr.size();i++){\\n                tempr=min(tempr,S.substr(i,tempr.size()));\\n            }\\n            return tempr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108744,
                "title": "bubble-sort",
                "content": "1. Basic idea is bubble sort\\n **CASE 1: if K>=2**\\n2. if we can swap any two consecutive character i.e we can do a sort then.\\n  eg: aa**db**ac lets try to swap d and b  k=2\\n      step1 : adbaca\\n      step2:  dbacaa\\n     step 3: dacaab\\n     step 4: acaabd\\n     step5 : caabda\\n     step6 : aa**bd**ac  \\n   if K is greater than equal to 2 we can swap any 2 consecutive character. so we can use sorting then.\\n\\n**CASE2: if K ==1**\\n  now we cannot swap any 2 consecutive characters so we have to check for all combinations and check which is lexographically smallest.\\n  \\n\\n```\\nclass Solution {\\n    public String orderlyQueue(String S, int K) {\\n        if(K>=2){\\n            char[] ch=S.toCharArray();\\n            Arrays.sort(ch);\\n            return new String(ch);\\n        }else{\\n            String s2=S + S;\\n            for(int i=0;i<S.length();i++){\\n                String temp=s2.substring(i,i+S.length());\\n                S=(S.compareTo(temp)>0)?temp:S;\\n            }\\n        }\\n        return S;\\n    }\\n}\\n```\\n\\n**TIME COMPLEXITY : \\nif K>=2 O(NLogN)**\\n**if K==1 O(N^2) (bcz compareTO O(N))   for every possible combination we are doing  a O(N) operation so time complexity is O(N^2)**\\n\\nSPACE COMPLEXITY : O(1)\\n  \\n\\n  \\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String orderlyQueue(String S, int K) {\\n        if(K>=2){\\n            char[] ch=S.toCharArray();\\n            Arrays.sort(ch);\\n            return new String(ch);\\n        }else{\\n            String s2=S + S;\\n            for(int i=0;i<S.length();i++){\\n                String temp=s2.substring(i,i+S.length());\\n                S=(S.compareTo(temp)>0)?temp:S;\\n            }\\n        }\\n        return S;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782748,
                "title": "daily-leetcoding-challenge-november-day-6",
                "content": "This problem is the Daily LeetCoding Challenge for November, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/orderly-queue/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Mathematical\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/orderly-queue/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1446662,
                "title": "c-simple-and-short-solution-0ms-faster-than-100",
                "content": "**Idea:**\\nIf `k==1`, then we can only choose the first letter and append it to the end. This is basically rotating the string. So we can just try rotating and see the smallest result.\\nIf `k>1`, then we can do some amount of moves to always get the string sorted.\\nWe can keep 1 or more numbers in the beginning of the string and take care only of the rest.\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if (k > 1) {\\n            sort(s.begin(), s.end());\\n            return s;\\n        }\\n        \\n        string res = s;\\n        for (int i = 0; i < s.size(); i++)\\n            res = min(res, s.substr(i)+s.substr(0, i));\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if (k > 1) {\\n            sort(s.begin(), s.end());\\n            return s;\\n        }\\n        \\n        string res = s;\\n        for (int i = 0; i < s.size(); i++)\\n            res = min(res, s.substr(i)+s.substr(0, i));\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785103,
                "title": "97-faster-short-python-solution-explained-with-proof",
                "content": "This is my longest post. Plese up-vote if you like it.\\n\\nIf k==1, then we are able to produce every possible rotation and nothing else.\\nHowever if k==2 or more, then we can actually generate every permutation, so the answer is actually the sorted text.\\n\\nLets call:\\n  - allowed operation: `op(i)` where `i<=k`, and\\n  - `op(0)` **shifting**, and\\n  - `n := len(text)` \\n  - `swap(i,j)` operation of swapping `text[i]` and `text[j]` \\n\\nIf `k==1` then we can only do shifting. So we only need to find the minimum of `n` options.\\nSmall optimization is to construct once `text+text` and operate on n-long window.\\n\\nFor `k>1` it is more interesting. We can generate every permutation. Why? Because we can generate every possible swap(i, j). Why? Because we can generate `swap(i, i+1)` for every possible `i`. Here is how:\\n1. op(1), folowed by `shift` and followed by `shift` several times we can generate swap(0,1).\\n2.  by sequence of `shift`, then `swap(0,1)` and sequence of `shift` we can generate `swap(i,i+1)` for any `i`.\\n3.  by two sequences of `swap(i,i+1)` we can generate `swap(i,j)` for any `i<j`\\n4.  finally by sequence of `swap(i,j)` we can generate any permutation.\\nSince we know that every possible permutaion can be generated, we do not need to construct them. We can simply sort the input text to pick the best permutation. \\n\\n```python\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k == 1:\\n            s2 = s+s\\n            n = len(s)\\n            return min(s2[i:i+n] for i in range(n))            \\n        else:\\n            return \"\".join(sorted(s))\\n ```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k == 1:\\n            s2 = s+s\\n            n = len(s)\\n            return min(s2[i:i+n] for i in range(n))            \\n        else:\\n            return \"\".join(sorted(s))\\n ```",
                "codeTag": "Python3"
            },
            {
                "id": 2784607,
                "title": "easy-python-solution-using-queue-tc-o-k-2-nlog-n-sc-o-n",
                "content": "```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        st=\"\"\\n        lst=list(s)\\n        lst.sort()\\n        queue=list(s)\\n        flg=defaultdict(lambda :0)\\n        if k==1:\\n            pt=[z for z in range(len(lst)) if s[z]==lst[0]]\\n            mn=s[pt[0]:]+s[:pt[0]]\\n            for p in range(len(pt)):\\n                mn=min(mn,s[pt[p]:]+s[:pt[p]])\\n            return mn\\n        ct=k\\n        if k==len(s):\\n            return \"\".join(lst)\\n        while k>0:\\n            if queue[0][0]==lst[0]:\\n                st+=queue.pop(0)[0]\\n                lst.pop(0)\\n                k-=1\\n                for nm in flg:\\n                    flg[nm]=0\\n            else:\\n                mn=queue[0]\\n                ind=0\\n                for i in range(1,min(ct,len(queue)-1)):\\n                    if queue[i]<mn and queue[i]!=lst[0] and flg[queue[i]]!=1:\\n                        ind=i\\n                x=queue.pop(ind)\\n                queue.append(x)\\n                flg[x]=1\\n        if ct>1:\\n            queue.sort()\\n        return st+\"\".join(queue)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        st=\"\"\\n        lst=list(s)\\n        lst.sort()\\n        queue=list(s)\\n        flg=defaultdict(lambda :0)\\n        if k==1:\\n            pt=[z for z in range(len(lst)) if s[z]==lst[0]]\\n            mn=s[pt[0]:]+s[:pt[0]]\\n            for p in range(len(pt)):\\n                mn=min(mn,s[pt[p]:]+s[:pt[p]])\\n            return mn\\n        ct=k\\n        if k==len(s):\\n            return \"\".join(lst)\\n        while k>0:\\n            if queue[0][0]==lst[0]:\\n                st+=queue.pop(0)[0]\\n                lst.pop(0)\\n                k-=1\\n                for nm in flg:\\n                    flg[nm]=0\\n            else:\\n                mn=queue[0]\\n                ind=0\\n                for i in range(1,min(ct,len(queue)-1)):\\n                    if queue[i]<mn and queue[i]!=lst[0] and flg[queue[i]]!=1:\\n                        ind=i\\n                x=queue.pop(ind)\\n                queue.append(x)\\n                flg[x]=1\\n        if ct>1:\\n            queue.sort()\\n        return st+\"\".join(queue)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782862,
                "title": "js-beats-100",
                "content": "# Intuition\\nCan I return just smallest string?\\n-> No, when the k is 1, it is limited but it is easy to get smallest one.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWhen the k is 2 or greater, we can get all permutations of s. So, we can return smallest string.\\nWhen the k is 1 and s.length is 3, for example,\\nwe can consider all possible permutation \\nabc, bca, cab\\nNumber of possible permutation is same as s.length.\\nI prefer bruteforce search\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {string}\\n */\\nvar orderlyQueue = function(s, k) {\\n \\tlet res = s;\\n\\n\\tif (k === 1) {\\n\\t\\tlet l = s.length;\\n\\t\\tfor (let i=0; i<l; i++) {\\n\\t\\t\\tlet c = s[0];\\n\\t\\t\\ts = s.substring(1, l) + c;\\n\\t\\t\\tif (s < res)\\n\\t\\t\\t\\tres = s; \\n\\t\\t}\\n\\n\\t\\treturn res;\\n\\t}\\n\\n\\treturn [...s].sort().join(\\'\\');\\n   \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {string}\\n */\\nvar orderlyQueue = function(s, k) {\\n \\tlet res = s;\\n\\n\\tif (k === 1) {\\n\\t\\tlet l = s.length;\\n\\t\\tfor (let i=0; i<l; i++) {\\n\\t\\t\\tlet c = s[0];\\n\\t\\t\\ts = s.substring(1, l) + c;\\n\\t\\t\\tif (s < res)\\n\\t\\t\\t\\tres = s; \\n\\t\\t}\\n\\n\\t\\treturn res;\\n\\t}\\n\\n\\treturn [...s].sort().join(\\'\\');\\n   \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2782767,
                "title": "daily-leetcode-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k>1)\\n        {\\n            sort(s.begin(),s.end());\\n            return s;\\n        }\\n        else\\n        {\\n            string ans=s;\\n            for(int i=1;i<s.size();i++)\\n            {\\n                ans=min(ans,s.substr(i,s.size()-1)+s.substr(0,i));\\n            }\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k>1)\\n        {\\n            sort(s.begin(),s.end());\\n            return s;\\n        }\\n        else\\n        {\\n            string ans=s;\\n            for(int i=1;i<s.size();i++)\\n            {\\n                ans=min(ans,s.substr(i,s.size()-1)+s.substr(0,i));\\n            }\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446689,
                "title": "orderly-queue-w-approach-c-python-java",
                "content": "We can divide the question in two parts \\n* When `k = 1` \\n* When `k > 1`, where we can prove that after some number of moves, the string can always be sorted\\n\\n\\n*Example of String Rotation*\\n`12345 -> 23451 -> 34512 -> 45123 -> 51234`\\n\\n* If `k = 1`, we can only rotate the whole string. There are `s.length()` different states and we return the **lexicographically smallest string**.\\n\\n* If `k > 1`, we have two possible operations-\\n\\t1. Rotate the whole string.\\n\\t2. Rotate the whole string except the first letter.\\n\\t* We can rotate `i+1`th big letter to the start (1), then rotate `i`th big letter to the end (2).\\n* We can look at it as an **bubble sort**: doing these moves we can sort all string, so directly return that.\\n\\n**Time complexity** is `O(n^2)` for `k = 1`, else for `k > 1` it is `O(NlogN)` \\n**Space complexity** is `O(n)`\\n\\n**SOLUTION**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k == 1)\\n\\t\\t{\\n            string ans = s ;\\n            for(int i = 0 ; i < s.length() ; i++)\\n\\t\\t\\t{\\n                ans = min(ans,s.substr(i)+s.substr(0,i)) ;\\n            }\\n            return ans ;\\n        }\\n\\t\\t// k > 1\\n        sort(s.begin(),s.end()) ;\\n        return s ;\\n    }\\n};\\n```\\n`In Python`\\n```\\nclass Solution(object):\\n    def orderlyQueue(self, s, k):\\n        \"\"\"\\n        :type s: str\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        if k > 1:\\n            return \"\".join(sorted(s))\\n        return min(s[i:]+s[:i] for i in range(len(s)))\\n```\\n`In JAVA`\\n```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k == 1)\\n        {\\n            String ans = s ;\\n            for(int i = 0 ; i < s.length() ; i++)\\n            {\\n                ans = min(ans , s.substring(i) + s.substring(0, i)) ;\\n            }\\n            return ans ;\\n        }\\n        char[] chars = s.toCharArray() ;\\n        Arrays.sort(chars) ;\\n        return new String(chars) ;\\n    }\\n}\\n```\\n\\n`Python One-Liner just for fun :)`\\n```\\nclass Solution(object):\\n    def orderlyQueue(self, s, k):\\n        \"\"\"\\n        :type s: str\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        return \"\".join(sorted(s)) if k > 1 else min(s[i:] + s[:i] for i in range(len(s)))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k == 1)\\n\\t\\t{\\n            string ans = s ;\\n            for(int i = 0 ; i < s.length() ; i++)\\n\\t\\t\\t{\\n                ans = min(ans,s.substr(i)+s.substr(0,i)) ;\\n            }\\n            return ans ;\\n        }\\n\\t\\t// k > 1\\n        sort(s.begin(),s.end()) ;\\n        return s ;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def orderlyQueue(self, s, k):\\n        \"\"\"\\n        :type s: str\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        if k > 1:\\n            return \"\".join(sorted(s))\\n        return min(s[i:]+s[:i] for i in range(len(s)))\\n```\n```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k == 1)\\n        {\\n            String ans = s ;\\n            for(int i = 0 ; i < s.length() ; i++)\\n            {\\n                ans = min(ans , s.substring(i) + s.substring(0, i)) ;\\n            }\\n            return ans ;\\n        }\\n        char[] chars = s.toCharArray() ;\\n        Arrays.sort(chars) ;\\n        return new String(chars) ;\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def orderlyQueue(self, s, k):\\n        \"\"\"\\n        :type s: str\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        return \"\".join(sorted(s)) if k > 1 else min(s[i:] + s[:i] for i in range(len(s)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784761,
                "title": "java-easy-solution-fast-explained-code",
                "content": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k > 1){\\n            /*if k > 1 then the returned string will be sorted*/\\n            char charArr[] = s.toCharArray();\\n            Arrays.sort(charArr);\\n            return String.valueOf(charArr);\\n        }else{\\n            /* smalled string will be returned starting with char than have smallest value in case of k == 1 as the string wont be sorted...bcoz we can rotate only one char that will result to getting same array after rotation*/\\n            String newStr = s;\\n            for(int i = 0; i < s.length() ; i++){\\n                s = s.substring(1) + s.substring(0,1);\\n                if(newStr.compareTo(s) > 0){\\n                    newStr = s; \\n                }\\n            }\\n            return newStr;\\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k > 1){\\n            /*if k > 1 then the returned string will be sorted*/\\n            char charArr[] = s.toCharArray();\\n            Arrays.sort(charArr);\\n            return String.valueOf(charArr);\\n        }else{\\n            /* smalled string will be returned starting with char than have smallest value in case of k == 1 as the string wont be sorted...bcoz we can rotate only one char that will result to getting same array after rotation*/\\n            String newStr = s;\\n            for(int i = 0; i < s.length() ; i++){\\n                s = s.substring(1) + s.substring(0,1);\\n                if(newStr.compareTo(s) > 0){\\n                    newStr = s; \\n                }\\n            }\\n            return newStr;\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1572587,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k > 1:\\n            return \"\".join(sorted(s))\\n        else:\\n            res = s\\n            for i in range(0,len(s)):\\n                s = s[1:] + s[0]\\n                res = min(res,s)\\n                \\n            return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k > 1:\\n            return \"\".join(sorted(s))\\n        else:\\n            res = s\\n            for i in range(0,len(s)):\\n                s = s[1:] + s[0]\\n                res = min(res,s)\\n                \\n            return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445967,
                "title": "orderly-queue-explanation-with-examlpe",
                "content": "For this problem we have two situations:\\n1. k = 1. It means that we can only delete first symbol and append it to the end of the string. We may simulate this process and find answer. For example, we may concatenate s with s and find smallest lexicographically substring with size equals s.size().\\n2. k > 1. Answer will be just sorted string. We may use the next algorithm to prove it:\\n* \\tLet\\'s suppouse that we have several symbols, that sorted lexicographically. For example smallest symbol in string.\\n* \\tFind next smallest symbol and move this symbol on first position in string (just move all symbols before it into the end). \\n* \\tMove second symbol into the end while this symbol is not from our lexicographically sorted string. \\n* \\tMove second symbol into the end while this symbol from our lexicographically sorted string.\\n* \\tMove next smallest symbol (first symbol in string) in the end of the string.\\n* \\tAfter this we increase our lexicographically sorted substring by one symbol. \\n* \\tRepeat this procedure until we get all sybmols in our lexicographically sorted substring.\\n\\tLet\\'s look at the example:\\n\\tabbabcba, k = 2 \\n\\t\\n\\t1. abb**a**bcba - initial state of our string. Let\\'s our smallest substring will be **a**. Next smallest lexicographically symbol is on the first position. \\n\\t2. a**a**bcbabb - move all second symbols into the end while second symbol doesn\\'t equal first symbol from  smallest substring.\\n\\t3. bcbabb**aa** - move smallest substring and first symbol in end of the string.\\n\\t4. abb**aa**bcb - place next smallest symbol in the begining of the string.\\n\\t5. a**aa**bcbbb - move all second symbols in the end while second symbol doesn\\'t equal first symbol from smallest substring. \\n\\t6. bcbbb**aaa** - move smallest substring and first symbol in end of the string.\\n\\t7. b**aaa**cbbb - repeat procedure.\\n\\t8. cbbb**aaab**\\n\\t9. b**aaab**cbb\\n\\t10. cbb**aaabb**\\n\\t11. b**aaabb**cb\\n\\t12. cb**aaabbb**\\n\\t13. b**aaabbb**c\\n\\t14. c**aaabbbb**\\n\\t15. **aaabbbbc**\\nIf we can do it with k = 2, it means, that we can do it with k > 2\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        string ans = s;\\n        if (k > 1){\\n            sort(ans.begin(), ans.end());\\n        } else {\\n            const string ss = s + s;\\n            for (int i = 0; i < s.size(); ++i){\\n                string tmp = ss.substr(i, s.size());\\n                if (tmp < ans) ans = tmp;\\n            }    \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Time complexity**: O(n^2)\\n**Space complexity**: O(n)\\n\\nIf you find this post useful upvote it.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        string ans = s;\\n        if (k > 1){\\n            sort(ans.begin(), ans.end());\\n        } else {\\n            const string ss = s + s;\\n            for (int i = 0; i < s.size(); ++i){\\n                string tmp = ss.substr(i, s.size());\\n                if (tmp < ans) ans = tmp;\\n            }    \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2802903,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if (k == 1) {\\n            String result = s;\\n            StringBuilder sb = new StringBuilder(s);\\n            for (int i = 0; i < s.length() - 1; ++i) {\\n                sb.append(sb.charAt(0)).deleteCharAt(0);\\n                if (sb.toString().compareTo(result) < 0) {\\n                    result = sb.toString();\\n                }\\n            }\\n            return result;\\n        }\\n        char[] x = s.toCharArray();\\n        Arrays.sort(x);\\n        return String.valueOf(x);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if (k == 1) {\\n            String result = s;\\n            StringBuilder sb = new StringBuilder(s);\\n            for (int i = 0; i < s.length() - 1; ++i) {\\n                sb.append(sb.charAt(0)).deleteCharAt(0);\\n                if (sb.toString().compareTo(result) < 0) {\\n                    result = sb.toString();\\n                }\\n            }\\n            return result;\\n        }\\n        char[] x = s.toCharArray();\\n        Arrays.sort(x);\\n        return String.valueOf(x);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2786411,
                "title": "python-simple-python-9-line-solution",
                "content": "```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k==1:\\n            ans=s\\n            for i in range(len(s)):\\n                if ((s+s)[i:i+len(s)])<ans: ans=((s+s)[i:i+len(s)])\\n            return ans\\n        else:\\n            return \"\".join(sorted(s))\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k==1:\\n            ans=s\\n            for i in range(len(s)):\\n                if ((s+s)[i:i+len(s)])<ans: ans=((s+s)[i:i+len(s)])\\n            return ans\\n        else:\\n            return \"\".join(sorted(s))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784715,
                "title": "concise-and-simple-solution-with-an-explanation",
                "content": "```csharp\\npublic class Solution\\n{\\n    public string OrderlyQueue(string s, int k)\\n    {\\n        if (k > 1) return string.Concat(s.OrderBy(x => x));\\n\\n        string res = s;\\n\\n        foreach (char c in s)\\n        {\\n            s = s[1..] + s[0];\\n            if (s.CompareTo(res) < 0) res = s;\\n        }\\n\\n        return res;\\n    }\\n}\\n```\\n\\nThe solution is based on the following observations:\\n\\nIf `k > 1`, we are able to put the characters in any order. In this case, we just sort them in ascending order and return the resulting string right away.\\n\\nIf `k = 1`, we cannot change the order of the characters in the string. We can only move them to the end of the string, one by one. In this case, we return the \"minimum\" string out of all possible `s.Length` candidates.\\n\\nAlso:\\n1. It\\'s not nice to change the object that you are looping over (string `s`) but it does not matter here.\\n2. Btw, we do make one string comparison more that we need here, but I like `foreach (char c in s)` better than `for (int i = 1; i < s.Length; i++)`.",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic class Solution\\n{\\n    public string OrderlyQueue(string s, int k)\\n    {\\n        if (k > 1) return string.Concat(s.OrderBy(x => x));\\n\\n        string res = s;\\n\\n        foreach (char c in s)\\n        {\\n            s = s[1..] + s[0];\\n            if (s.CompareTo(res) < 0) res = s;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782830,
                "title": "swift-one-liner",
                "content": "**One-Liner, terse (accepted answer)**\\n```\\nclass Solution {\\n  func orderlyQueue(_ s: String, _ k: Int) -> String {\\n    k==1 && s.count>1 ? (1..<s.count).reduce((\"{\", Array(s))) { d,i in (min(d.0, String(d.1[i...]+d.1[0..<i])), d.1)}.0 : String(s.sorted())\\n  }\\n}\\n```\\n**NOTE:** This technically qualifies as a one-liner, since `return` keyword was omitted.\\n\\n---\\n\\n**One-Liner, expanded and annotated (accepted answer)**\\n```\\nclass Solution {\\n    func orderlyQueue(_ s: String, _ k: Int) -> String {\\n        guard s.count > 1 else { return s }\\n        if k == 1 { // when `k` is one, return minimal rotation\\n            return (1..<s.count).reduce((\\n                minString: \"{\",  // brace-character has higher ASCII value than all letters\\n                s: Array(s)  // converts String `s` into array of characters for substring\\n            )) { data,i in \\n                (\\n                    minString: min(data.minString, String(data.s[i...] + data.s[0..<i])), \\n                    s: data.s\\n                )\\n            }.minString \\n        } else {\\n            return String(s.sorted()) // when k>1, then minimal value will always be lexicographical sort\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  func orderlyQueue(_ s: String, _ k: Int) -> String {\\n    k==1 && s.count>1 ? (1..<s.count).reduce((\"{\", Array(s))) { d,i in (min(d.0, String(d.1[i...]+d.1[0..<i])), d.1)}.0 : String(s.sorted())\\n  }\\n}\\n```\n```\\nclass Solution {\\n    func orderlyQueue(_ s: String, _ k: Int) -> String {\\n        guard s.count > 1 else { return s }\\n        if k == 1 { // when `k` is one, return minimal rotation\\n            return (1..<s.count).reduce((\\n                minString: \"{\",  // brace-character has higher ASCII value than all letters\\n                s: Array(s)  // converts String `s` into array of characters for substring\\n            )) { data,i in \\n                (\\n                    minString: min(data.minString, String(data.s[i...] + data.s[0..<i])), \\n                    s: data.s\\n                )\\n            }.minString \\n        } else {\\n            return String(s.sorted()) // when k>1, then minimal value will always be lexicographical sort\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782764,
                "title": "ruby-1-liner",
                "content": "```\\ndef orderly_queue(s, k)\\n  k>1 ? s.chars.sort.join : s.size.times.map{s[_1..]+s[..._1]}.min\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef orderly_queue(s, k)\\n  k>1 ? s.chars.sort.join : s.size.times.map{s[_1..]+s[..._1]}.min\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2778309,
                "title": "faster-than-100-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere is one catch in this problem.\\nIf k>1 then the answer always sorted order, So\\njust sort the string and return that string\\nIf K==1 then you have to traverse string and find lexicographically smallest string, it\\'s not defficult.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n if K==0 then simply return that string.\\n if K>1 sort the string and return that string.\\n if K==1 finds all such combinations and return lexicographically the smallest string.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity O(n^2) if k==1\\nand O(nlogn) if k>1\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) \\n    {\\n        if(k==0)\\n        {\\n            return s;\\n        }\\n        if(k>1)\\n        {\\n            sort(s.begin(),s.end());\\n            return s;\\n        }\\n        if(k==1)\\n        {\\n            string st=s;\\n            for (int i=0;i<s.length()-1;i++)\\n            {\\n                string p=s.substr(i+1,s.length())+s.substr(0,i+1);\\n                if(st>p){\\n                    st=p;\\n                }\\n            }\\n            return st;\\n        }\\n        return s;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) \\n    {\\n        if(k==0)\\n        {\\n            return s;\\n        }\\n        if(k>1)\\n        {\\n            sort(s.begin(),s.end());\\n            return s;\\n        }\\n        if(k==1)\\n        {\\n            string st=s;\\n            for (int i=0;i<s.length()-1;i++)\\n            {\\n                string p=s.substr(i+1,s.length())+s.substr(0,i+1);\\n                if(st>p){\\n                    st=p;\\n                }\\n            }\\n            return st;\\n        }\\n        return s;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446910,
                "title": "easy-af-c-java-golang-solution-explained",
                "content": "Please upvote if you like the solution.\\n\\nThe question is pretty simple. We have two conditions:\\n1. If K>1,that means we can bubble sort the whole string to get the lexicographically smallest string, since bubble sort at a time requires only two indices while comparing.\\n2. If we have k==1, then we just have to find the lexicographically smallest string beginning at any index \\'i\\'. We just compare every substring so formed and keep track of the minimum one. At last we return the minimum string.\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k>1){\\n            sort(begin(s),end(s));\\n            return s;\\n        }\\n        string mins=s;\\n        for(int i=1;i<s.size();i++){\\n            mins=min(mins,s.substr(i)+s.substr(0,i));\\n        }\\n        return mins;\\n    }\\n};\\n```\\n**Java**\\n```\\npublic String orderlyQueue(String S, int K) {\\n        if (K > 1) {\\n            char S2[] = S.toCharArray();\\n            Arrays.sort(S2);\\n            return new String(S2);\\n        }\\n        String res = S;\\n        for (int i = 1; i < S.length(); i++) {\\n            String tmp = S.substring(i) + S.substring(0, i);\\n            if (res.compareTo(tmp) > 0) res = tmp;\\n        }\\n        return res;\\n    }\\n```\\n**Golang**\\n```\\nfunc orderlyQueue(s string, k int) string {\\n\\tb := []byte(s)\\n\\tif k > 1 {\\n\\t\\tsort.Slice(b, func(i, j int) bool {\\n\\t\\t\\treturn b[i] < b[j]\\n\\t\\t})\\n\\t\\treturn string(b)\\n\\t} else {\\n\\t\\tmin := []byte(s)\\n\\t\\tfor i := 0; i < len(s)-1; i++ {\\n\\t\\t\\tb = append(b[1:], b[0])\\n\\t\\t\\tif bytes.Compare(b, min) < 0 {\\n\\t\\t\\t\\tcopy(min, b)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn string(min)\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k>1){\\n            sort(begin(s),end(s));\\n            return s;\\n        }\\n        string mins=s;\\n        for(int i=1;i<s.size();i++){\\n            mins=min(mins,s.substr(i)+s.substr(0,i));\\n        }\\n        return mins;\\n    }\\n};\\n```\n```\\npublic String orderlyQueue(String S, int K) {\\n        if (K > 1) {\\n            char S2[] = S.toCharArray();\\n            Arrays.sort(S2);\\n            return new String(S2);\\n        }\\n        String res = S;\\n        for (int i = 1; i < S.length(); i++) {\\n            String tmp = S.substring(i) + S.substring(0, i);\\n            if (res.compareTo(tmp) > 0) res = tmp;\\n        }\\n        return res;\\n    }\\n```\n```\\nfunc orderlyQueue(s string, k int) string {\\n\\tb := []byte(s)\\n\\tif k > 1 {\\n\\t\\tsort.Slice(b, func(i, j int) bool {\\n\\t\\t\\treturn b[i] < b[j]\\n\\t\\t})\\n\\t\\treturn string(b)\\n\\t} else {\\n\\t\\tmin := []byte(s)\\n\\t\\tfor i := 0; i < len(s)-1; i++ {\\n\\t\\t\\tb = append(b[1:], b[0])\\n\\t\\t\\tif bytes.Compare(b, min) < 0 {\\n\\t\\t\\t\\tcopy(min, b)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn string(min)\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446687,
                "title": "c-python-java-with-explanation-string-sort-or-rotate",
                "content": "We can divide the question in two parts \\n* When `k = 1` \\n* When `k > 1`, where we can prove that after some number of moves, the string can always be sorted\\n\\n\\n*Example of String Rotation*\\n`12345 -> 23451 -> 34512 -> 45123 -> 51234`\\n\\n* If `k = 1`, we can only rotate the whole string. There are `s.length()` different states and we return the **lexicographically smallest string**.\\n\\n* If `k > 1`, we have two possible operations-\\n\\t1. Rotate the whole string.\\n\\t2. Rotate the whole string except the first letter.\\n\\t* We can rotate `i+1`th big letter to the start (1), then rotate `i`th big letter to the end (2).\\n* We can look at it as an **bubble sort**: doing these moves we can sort all string, so directly return that.\\n\\n**Time complexity** is `O(n^2)` for `k = 1`, else for `k > 1` it is `O(NlogN)` \\n**Space complexity** is `O(n)`\\n\\n**SOLUTION**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k == 1)\\n\\t\\t{\\n            string ans = s ;\\n            for(int i = 0 ; i < s.length() ; i++)\\n\\t\\t\\t{\\n                ans = min(ans,s.substr(i)+s.substr(0,i)) ;\\n            }\\n            return ans ;\\n        }\\n\\t\\t// k > 1\\n        sort(s.begin(),s.end()) ;\\n        return s ;\\n    }\\n};\\n```\\n`In Python`\\n```\\nclass Solution(object):\\n    def orderlyQueue(self, s, k):\\n        \"\"\"\\n        :type s: str\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        if k > 1:\\n            return \"\".join(sorted(s))\\n        return min(s[i:]+s[:i] for i in range(len(s)))\\n```\\n`In JAVA`\\n```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k == 1)\\n        {\\n            String ans = s ;\\n            for(int i = 0 ; i < s.length() ; i++)\\n            {\\n                ans = min(ans , s.substring(i) + s.substring(0, i)) ;\\n            }\\n            return ans ;\\n        }\\n        char[] chars = s.toCharArray() ;\\n        Arrays.sort(chars) ;\\n        return new String(chars) ;\\n    }\\n}\\n```\\n\\n`Python One-Liner just for fun :)`\\n```\\nclass Solution(object):\\n    def orderlyQueue(self, s, k):\\n        \"\"\"\\n        :type s: str\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        return \"\".join(sorted(s)) if k > 1 else min(s[i:] + s[:i] for i in range(len(s)))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k == 1)\\n\\t\\t{\\n            string ans = s ;\\n            for(int i = 0 ; i < s.length() ; i++)\\n\\t\\t\\t{\\n                ans = min(ans,s.substr(i)+s.substr(0,i)) ;\\n            }\\n            return ans ;\\n        }\\n\\t\\t// k > 1\\n        sort(s.begin(),s.end()) ;\\n        return s ;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def orderlyQueue(self, s, k):\\n        \"\"\"\\n        :type s: str\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        if k > 1:\\n            return \"\".join(sorted(s))\\n        return min(s[i:]+s[:i] for i in range(len(s)))\\n```\n```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k == 1)\\n        {\\n            String ans = s ;\\n            for(int i = 0 ; i < s.length() ; i++)\\n            {\\n                ans = min(ans , s.substring(i) + s.substring(0, i)) ;\\n            }\\n            return ans ;\\n        }\\n        char[] chars = s.toCharArray() ;\\n        Arrays.sort(chars) ;\\n        return new String(chars) ;\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def orderlyQueue(self, s, k):\\n        \"\"\"\\n        :type s: str\\n        :type k: int\\n        :rtype: str\\n        \"\"\"\\n        return \"\".join(sorted(s)) if k > 1 else min(s[i:] + s[:i] for i in range(len(s)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 165857,
                "title": "java-simple-solution-12-ms",
                "content": "When K >= 2, you can swap any two character in the string.\\n```\\n    public String orderlyQueue(String S, int K) {\\n        if(K == 1) return slideString(S);\\n        char[] arr = S.toCharArray();\\n        Arrays.sort(arr);\\n        return new String(arr);\\n    }\\n    \\n    public String slideString(String S) {\\n        String res = S, cur = S;\\n        for(int i = 0; i < S.length(); i ++) {\\n            cur = cur.substring(1) + cur.charAt(0);\\n            if(cur.compareTo(res) < 0) \\n                res = cur;\\n        }\\n        return res;\\n    }\\n",
                "solutionTags": [],
                "code": "When K >= 2, you can swap any two character in the string.\\n```\\n    public String orderlyQueue(String S, int K) {\\n        if(K == 1) return slideString(S);\\n        char[] arr = S.toCharArray();\\n        Arrays.sort(arr);\\n        return new String(arr);\\n    }\\n    \\n    public String slideString(String S) {\\n        String res = S, cur = S;\\n        for(int i = 0; i < S.length(); i ++) {\\n            cur = cur.substring(1) + cur.charAt(0);\\n            if(cur.compareTo(res) < 0) \\n                res = cur;\\n        }\\n        return res;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2784333,
                "title": "solution-cpp-o-nlogn",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor k=1, rotate the string clockwise n times and return the smallest string lexographically.\\nFor k>1, sorted string will be the ans. \\nGot intuition while playing with some test cases and the conclusion is we can swap any two elements if k>1, coz number of moves are infinite (as said in the question), so we can also get sorted string accordingly.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        int n=s.length();\\n        string t=s;\\n\\n        if(k==1){\\n            while(n--){\\n                char c=s[0];\\n                s.erase(s.begin());\\n                s.push_back(c);\\n                if(s<t)t=s;\\n            }\\n            return t;\\n        }\\n\\n        sort(t.begin(),t.end());\\n        return t;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        int n=s.length();\\n        string t=s;\\n\\n        if(k==1){\\n            while(n--){\\n                char c=s[0];\\n                s.erase(s.begin());\\n                s.push_back(c);\\n                if(s<t)t=s;\\n            }\\n            return t;\\n        }\\n\\n        sort(t.begin(),t.end());\\n        return t;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784330,
                "title": "solution-cpp-o-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor k=1, rotate the string clockwise n times and return the smallest string lexographically.\\nFor k>1, sorted string will be the ans. \\nGot intuition while playing with some test cases and the conclusion is we can swap any two elements if k>1, coz number of moves are infinite (as said in the question), so we can also get sorted string accordingly.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        int n=s.length();\\n        string t=s;\\n\\n        if(k==1){\\n            while(n--){\\n                char c=s[0];\\n                s.erase(s.begin());\\n                s.push_back(c);\\n                if(s<t)t=s;\\n            }\\n            return t;\\n        }\\n\\n        sort(t.begin(),t.end());\\n        return t;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        int n=s.length();\\n        string t=s;\\n\\n        if(k==1){\\n            while(n--){\\n                char c=s[0];\\n                s.erase(s.begin());\\n                s.push_back(c);\\n                if(s<t)t=s;\\n            }\\n            return t;\\n        }\\n\\n        sort(t.begin(),t.end());\\n        return t;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784054,
                "title": "c-easy-beginner-friendly-with-explanation-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        // if k == 1 then we rotate the string and find the lexicographically minimum string\\n        if(k == 1)\\n        {\\n            string ans = s;\\n            int n = s.length();\\n            for(int i = 0 ; i < n;i++)\\n            {\\n                // extracting end char and adding it to the front\\n                char c = s[n - 1];\\n                s.pop_back();\\n                s = c + s;\\n                // minimum of existing string and new string formed\\n                ans = min(s, ans);   \\n            }\\n            return ans;\\n        }\\n        // if k > 1 then we can rearrange the string anyway we like\\n        // so return the sorted string.\\n        sort(s.begin(), s.end());\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        // if k == 1 then we rotate the string and find the lexicographically minimum string\\n        if(k == 1)\\n        {\\n            string ans = s;\\n            int n = s.length();\\n            for(int i = 0 ; i < n;i++)\\n            {\\n                // extracting end char and adding it to the front\\n                char c = s[n - 1];\\n                s.pop_back();\\n                s = c + s;\\n                // minimum of existing string and new string formed\\n                ans = min(s, ans);   \\n            }\\n            return ans;\\n        }\\n        // if k > 1 then we can rearrange the string anyway we like\\n        // so return the sorted string.\\n        sort(s.begin(), s.end());\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783767,
                "title": "java-easy-to-understand-sort-or-rotate",
                "content": "https://github.com/Freeze777/SDE-Interviewer-Notes/blob/main/LeetCodeJava/src/main/java/leetcode/hard/arrays/OrderlyQueue.java",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1755675,
                "title": "c-o-n-log-n-simple-solution-for-beginners",
                "content": "There are 2 cases in this question :-\\n1. When k=1 : We have to run a loop and store all strings in a vector after sending first character to last. Then simply sort the vector to get lexographically smallest string obtained in the process.\\n2. k>1 : In this case, the answer will always be a sorted string.\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k>1){\\n            sort(s.begin(),s.end());\\n            return s;\\n        }\\n        string s1=s;\\n        int n=s.length();\\n        sort(s1.begin(),s1.end());\\n        char c=s1[0];\\n        vector<string>v;\\n        \\n        for(int i=0; i<n; i++){\\n            if(s[0]==c) v.push_back(s);\\n            char c1=s[0];\\n            s.erase(s.begin());\\n            s.push_back(c1);\\n        }\\n        sort(v.begin(),v.end());\\n        return v[0];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k>1){\\n            sort(s.begin(),s.end());\\n            return s;\\n        }\\n        string s1=s;\\n        int n=s.length();\\n        sort(s1.begin(),s1.end());\\n        char c=s1[0];\\n        vector<string>v;\\n        \\n        for(int i=0; i<n; i++){\\n            if(s[0]==c) v.push_back(s);\\n            char c1=s[0];\\n            s.erase(s.begin());\\n            s.push_back(c1);\\n        }\\n        sort(v.begin(),v.end());\\n        return v[0];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1456121,
                "title": "c-simple-solution",
                "content": "```\\nstring orderlyQueue(string s, int k) {\\n        \\n        if(k == 1){\\n            string ans = s;\\n            for(int i=0;i<s.length();i++){\\n                ans = min(ans, s.substr(i)+s.substr(0,i));\\n            }\\n            return ans;\\n        }else{\\n            sort(s.begin(),s.end());\\n            return s;\\n        }\\n        \\n    }\\n\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring orderlyQueue(string s, int k) {\\n        \\n        if(k == 1){\\n            string ans = s;\\n            for(int i=0;i<s.length();i++){\\n                ans = min(ans, s.substr(i)+s.substr(0,i));\\n            }\\n            return ans;\\n        }else{\\n            sort(s.begin(),s.end());\\n            return s;\\n        }\\n        \\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1446335,
                "title": "javascript-easy-solution",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {string}\\n */\\nvar orderlyQueue = function(s, k) {\\n  // rotate the string one by one, and check which is lexographically smaller\\n  if (k === 1) {\\n    let temp = `${s}`;\\n    let smallest = `${s}`;\\n    let count = 0;\\n    while (count < s.length) {\\n      temp = temp.substring(1, s.length) + temp.charAt(0);\\n      if (temp < smallest) {\\n        smallest = temp;\\n      }\\n      count++;\\n    }\\n    return smallest;\\n  }\\n  \\n  // if k is greater than 1, any permutation is possilbe\\n  // so we simply return the sorted string (convert to array -> sort -> back to string)\\n  if (k > 1) {\\n    return [...s].sort().join(\\'\\');\\n  }\\n  \\n  return s;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {string}\\n */\\nvar orderlyQueue = function(s, k) {\\n  // rotate the string one by one, and check which is lexographically smaller\\n  if (k === 1) {\\n    let temp = `${s}`;\\n    let smallest = `${s}`;\\n    let count = 0;\\n    while (count < s.length) {\\n      temp = temp.substring(1, s.length) + temp.charAt(0);\\n      if (temp < smallest) {\\n        smallest = temp;\\n      }\\n      count++;\\n    }\\n    return smallest;\\n  }\\n  \\n  // if k is greater than 1, any permutation is possilbe\\n  // so we simply return the sorted string (convert to array -> sort -> back to string)\\n  if (k > 1) {\\n    return [...s].sort().join(\\'\\');\\n  }\\n  \\n  return s;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1445749,
                "title": "go-simple-code-with-comments",
                "content": "```\\nfunc orderlyQueue(s string, k int) string {\\n    \\n    // Rotate the string if k == 1.\\n    // Record all rotations of s in temp.\\n    // Keep record of the lexicographically smallest rotation (temp) while iterating.\\n    if k == 1 {\\n        answer := s\\n        double := s + s\\n        \\n        for i, _ := range s {\\n            temp := double[i : i + len(s)]\\n            \\n            if temp < answer {\\n                answer = temp\\n            }\\n        }\\n        \\n        return answer\\n    }\\n    \\n    // Sort the string if k > 1.\\n    w := strings.Split(s, \"\")\\n    sort.Strings(w)\\n    return strings.Join(w, \"\")\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc orderlyQueue(s string, k int) string {\\n    \\n    // Rotate the string if k == 1.\\n    // Record all rotations of s in temp.\\n    // Keep record of the lexicographically smallest rotation (temp) while iterating.\\n    if k == 1 {\\n        answer := s\\n        double := s + s\\n        \\n        for i, _ := range s {\\n            temp := double[i : i + len(s)]\\n            \\n            if temp < answer {\\n                answer = temp\\n            }\\n        }\\n        \\n        return answer\\n    }\\n    \\n    // Sort the string if k > 1.\\n    w := strings.Split(s, \"\")\\n    sort.Strings(w)\\n    return strings.Join(w, \"\")\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 759358,
                "title": "javascript-72-speed-100-memory",
                "content": "Intuitions:\\n- if K === 0, no moves can be made\\n- if K >= 2, any permutation of characters is possible with enough steps\\n\\t- The JS Array.sort() method already sorts lexically\\n- If K === 1 then the answer will be a rotation of the string\\n\\t- You can build these strings from splitting and concatenating S, but that would be wasteful when all we are about is the character code values\\n\\nMethod:\\n- if K === 0, return S\\n- if K >= 2, \\n\\t- .split(\\'\\') the string into its characters\\n\\t- .sort() the resulting array (defaults to ascending order anyway)\\n\\t- .join(\\'\\') the characters\\n\\t- return the concatenated string\\n- If K === 1\\n\\t- iterate over all possible rotations of the string, compared to the rotation at 0 (the original string)\\n\\t\\t- iterate over and compare all characters in those strings, once 2 different characters are found: \\n\\t\\t\\t- if the new string character is \"smaller\", update the result to the new starting index\\n\\t\\t\\t- move on to the next rotation\\n\\nInstead of building these rotations for comparison, it is much easier on the memory to store the starting indices and add integers from [0, string.length) when comparing characters.\\n> (Base Index + Number of Same Characters) % String Length = The Index in the \"Rotated\" String\\n\\n```\\nvar orderlyQueue = function(S, K) {\\n\\tif (K === 0) return S;\\n    else if (K > 1) return S.split(\\'\\').sort().join(\\'\\');\\n\\n\\tlet result = 0, L = S.length;\\n\\n\\tfor (let i = 1; i < L; i++) {\\n        for (let j = 0; j < L; j++) {\\n\\t\\t\\tlet d = S.charCodeAt((result + j) % L) - S.charCodeAt((i + j) % L);\\n\\t\\t\\tif (d !== 0)  {\\n\\t\\t\\t\\tif (d > 0) result = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn S.slice(result) + S.slice(0, result);\\n\\n};\\n\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar orderlyQueue = function(S, K) {\\n\\tif (K === 0) return S;\\n    else if (K > 1) return S.split(\\'\\').sort().join(\\'\\');\\n\\n\\tlet result = 0, L = S.length;\\n\\n\\tfor (let i = 1; i < L; i++) {\\n        for (let j = 0; j < L; j++) {\\n\\t\\t\\tlet d = S.charCodeAt((result + j) % L) - S.charCodeAt((i + j) % L);\\n\\t\\t\\tif (d !== 0)  {\\n\\t\\t\\t\\tif (d > 0) result = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn S.slice(result) + S.slice(0, result);\\n\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2786171,
                "title": "c-explained-100-fast",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k)\\n    {\\n            string ans;\\n            ans = s;\\n        // when n > 1 then we can have the string sorted , took the example of S = \"aacb\" and k = 2, we can get aabc after some rotations\\n        if (k > 1)\\n        {\\n            sort(s.begin(), s.end());\\n            return (s);\\n        }\\n        else\\n        {\\n            // when k ==1 then we have to see the lexicographically smallest string of size of s in the string s+s\\n            // like if we have s= \"cba\" and k ==1 then s+s = \"cbacba\" then we have the answer acb, this is because we can have only 1 rotation at a time and that too of the first element and we can sent it back only which we can find using s+s \\n            // the relative order of other elements would remain the same, so we can use a string s+s to find the substring with lexicographically smalles first character\\n            string temp = \"\";\\n            temp = s + s;\\n            for (int i = 0; i + s.length() <= temp.length(); i++)\\n            {\\n                ans = min(ans, temp.substr(i, s.length()));\\n            }\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k)\\n    {\\n            string ans;\\n            ans = s;\\n        // when n > 1 then we can have the string sorted , took the example of S = \"aacb\" and k = 2, we can get aabc after some rotations\\n        if (k > 1)\\n        {\\n            sort(s.begin(), s.end());\\n            return (s);\\n        }\\n        else\\n        {\\n            // when k ==1 then we have to see the lexicographically smallest string of size of s in the string s+s\\n            // like if we have s= \"cba\" and k ==1 then s+s = \"cbacba\" then we have the answer acb, this is because we can have only 1 rotation at a time and that too of the first element and we can sent it back only which we can find using s+s \\n            // the relative order of other elements would remain the same, so we can use a string s+s to find the substring with lexicographically smalles first character\\n            string temp = \"\";\\n            temp = s + s;\\n            for (int i = 0; i + s.length() <= temp.length(); i++)\\n            {\\n                ans = min(ans, temp.substr(i, s.length()));\\n            }\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2786062,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        string ans=\"\";\\n        if(k==1){\\n       \\n        int n=s.size();\\n        string ans=s;\\n        string dou=s+s;\\n        for(int i=1;i<n;i++){\\n            string str=dou.substr(i,n);\\n            if(str<ans)ans=str;\\n        }\\n        return ans;\\n        }\\n        sort(s.begin(),s.end());\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        string ans=\"\";\\n        if(k==1){\\n       \\n        int n=s.size();\\n        string ans=s;\\n        string dou=s+s;\\n        for(int i=1;i<n;i++){\\n            string str=dou.substr(i,n);\\n            if(str<ans)ans=str;\\n        }\\n        return ans;\\n        }\\n        sort(s.begin(),s.end());\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785561,
                "title": "very-simple-approach-beginner-friendly",
                "content": "# Intuition\\nThe questions seems to be very tricky at first but its all about recognizing the pattern. My initial thoughts were to sort the string for k > 1 and think of a way to write a solution for k == 1.\\n\\n# Approach\\n1. for k == 1 we can try generating all the variations and store it in a set until the strings being generated starts repeating. Once you encounter such situation simply return the min from set. That will be our answer.\\n2. For k > 1, we can simply sort the string and return our answer\\n\\n# Complexity\\n- Time complexity:\\nO(N ^ 2) # NOT SURE\\n\\n- Space complexity:\\nO(len(visited))\\n\\n# Code\\n```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        visited = set()\\n        if k == 1:\\n            arr = list(s)\\n\\n            while \"\".join(arr) not in visited:\\n                visited.add(\"\".join(arr))\\n                ele = arr.pop(0)\\n                arr.append(ele)\\n                \\n            \\n\\n            return min(visited)\\n\\n        ans = sorted(s)\\n        return \"\".join(ans)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        visited = set()\\n        if k == 1:\\n            arr = list(s)\\n\\n            while \"\".join(arr) not in visited:\\n                visited.add(\"\".join(arr))\\n                ele = arr.pop(0)\\n                arr.append(ele)\\n                \\n            \\n\\n            return min(visited)\\n\\n        ans = sorted(s)\\n        return \"\".join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784929,
                "title": "smallest-and-easiest-java-soln-with-comments",
                "content": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k>1){                        //whenver we k>1 we can make the most smallest lexographic combo\\n            char ch[]=s.toCharArray();  \\n            Arrays.sort(ch);\\n            return String.valueOf(ch);\\n        }\\n        else{   //when k=1 we have restriction to move only ine so will see from what index smallest lexo start\\n             String str2=new String(s);\\n             for(int i=0;i<s.length();i++){\\n                s=s.substring(1)+s.charAt(0); // first element is being shifted to last\\n                if(str2.compareTo(s)>0){        //if this lexo combo is smaller than previous\\n                    str2=s;                     //store smaller lexo combo\\n                } \\n             }\\n             return str2;\\n        }     \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k>1){                        //whenver we k>1 we can make the most smallest lexographic combo\\n            char ch[]=s.toCharArray();  \\n            Arrays.sort(ch);\\n            return String.valueOf(ch);\\n        }\\n        else{   //when k=1 we have restriction to move only ine so will see from what index smallest lexo start\\n             String str2=new String(s);\\n             for(int i=0;i<s.length();i++){\\n                s=s.substring(1)+s.charAt(0); // first element is being shifted to last\\n                if(str2.compareTo(s)>0){        //if this lexo combo is smaller than previous\\n                    str2=s;                     //store smaller lexo combo\\n                } \\n             }\\n             return str2;\\n        }     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784504,
                "title": "c-beginner-friendly-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if (k == 1) {\\n            string ans = s;\\n            s += s;\\n            for (int i=1;i<ans.size();i++) {\\n                ans = min(ans, s.substr(i, ans.size()));\\n            }\\n            return ans;\\n        }\\n        \\n        sort(s.begin(), s.end());\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if (k == 1) {\\n            string ans = s;\\n            s += s;\\n            for (int i=1;i<ans.size();i++) {\\n                ans = min(ans, s.substr(i, ans.size()));\\n            }\\n            return ans;\\n        }\\n        \\n        sort(s.begin(), s.end());\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784079,
                "title": "golang-solution",
                "content": "If k = 1, only rotations of s are possible, and the answer is the lexicographically smallest rotation.\\n\\nIf k > 1, any permutation of s is possible, and the answer is the letters of s written in lexicographic order.\\n\\n```\\nfunc orderlyQueue(S string, K int) string {\\n\\ts := []byte(S)\\n\\tif K>1 {\\n\\t\\tsort.Slice(s, func(i int, j int) bool { return s[i] < s[j] })\\n\\t\\treturn string(s)\\n\\t} else {\\n\\t\\treturn findSmallest(s)\\n\\t}\\n}\\nfunc findSmallest(s []byte) string {\\n\\tres := s\\n\\tfor i:=1; i<len(s); i++ {\\n\\t\\ttmp := append(s[i:],s[:i]...)\\n\\t\\tif strings.Compare(string(res), string(tmp)) > 0 {\\n\\t\\t\\tres = tmp\\n\\t\\t}\\n\\t}\\n\\treturn string(res)\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Sorting"
                ],
                "code": "```\\nfunc orderlyQueue(S string, K int) string {\\n\\ts := []byte(S)\\n\\tif K>1 {\\n\\t\\tsort.Slice(s, func(i int, j int) bool { return s[i] < s[j] })\\n\\t\\treturn string(s)\\n\\t} else {\\n\\t\\treturn findSmallest(s)\\n\\t}\\n}\\nfunc findSmallest(s []byte) string {\\n\\tres := s\\n\\tfor i:=1; i<len(s); i++ {\\n\\t\\ttmp := append(s[i:],s[:i]...)\\n\\t\\tif strings.Compare(string(res), string(tmp)) > 0 {\\n\\t\\t\\tres = tmp\\n\\t\\t}\\n\\t}\\n\\treturn string(res)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2783940,
                "title": "i-wouldn-t-say-it-s-hard-it-s-eeaassyy",
                "content": "Hello folks!... So, today\\'s question is **Orderly Queue**\\n\\nSo, first of all let\\'s see what will happen if our k value is greater than 1, \\nTry to take as much examples as you can and think, is there any chance by taking k value greater than 1 and we don\\'t get sorted string (i.e. lexographically smallest string).\\n\\nYeah, you found it correct, if we have a value of k greater than 1, then we are definitely going to end up on sorted string.\\n\\nNow, the question is just a small trickier here, what if k value is equal to 1???\\n\\nSo, if you\\'ve done questions based on string where you have to take substring of string, then I guess you\\'ll get it what I meant to say.\\n\\nYeah, all you have to do is take the original string, append it to itself and then check for each string (of original size) that whether is this the smallest lexographically string or not. And, then at the end, you will have your solution.\\n\\nApproach:\\n\\n1. For value of k == 1, take size of string **s** in some variable (say **n**) and store it. And then append string **s** to itself.\\n2. Now, run a loop till size of **s** (size after appending itself) - **n**. Because, you have to check every string of actual size to be lexographically small or not.\\n3. Keep checking those string if they are smallest lexographically string or not, and at the end you\\'ll have your desired string.\\n4. Now, for k\\'s value greater than 1, just simply find the sorted string and return it. (Why so? Explanation is above).\\n\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k == 1)\\n        {\\n            string sol = s;\\n            int n = s.size();\\n            s += s;\\n            for(int i=0; i<s.size()-n; i++)\\n            {\\n                string lexo = s.substr(i, n);\\n                sol = min(sol, lexo);\\n            }\\n            \\n            return sol;\\n        }\\n        \\n        sort(s.begin(), s.end());\\n        return s;\\n    }\\n};\\n```\\n\\nI hope you found this approach and solution helpful. If yes, then why not UPVOTE it. Do it :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k == 1)\\n        {\\n            string sol = s;\\n            int n = s.size();\\n            s += s;\\n            for(int i=0; i<s.size()-n; i++)\\n            {\\n                string lexo = s.substr(i, n);\\n                sol = min(sol, lexo);\\n            }\\n            \\n            return sol;\\n        }\\n        \\n        sort(s.begin(), s.end());\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783678,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are required to keep pushing the first element of the string to its last and popping the very first element untill we are with the lexicographically smallest string.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhile going with intution of the problem there would be three cases:\\n\\n- k=0 : In this case, return the string as it is.\\n- k=1 : In this case, first of all get the smallest letter in the given string. After this, for all the occurences of smallest letter in the string partition the string starting from that letter(suppose in first partition there are all the elements that come before the smallest letter in that string and in second partition there are all the elements that come after the smallest letter, including itself). Form a string combining partition 2 + partition 1. Get all such strings possible from the given string and return the lexicographically smallest string.\\n- k>1 : In this case, just sort the given array and return it \\n\\nAttached code will make it more clear.\\n\\n# Complexity\\n- Time complexity:$$O(n*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:$$O(n*n)$$\\n        \\n    $${n=Given-string-size}$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n       string res;\\n       if(k==0)\\n        return s;\\n       if(k>1){\\n           res=s;\\n           sort(s.begin(),s.end());\\n       }\\n       else{\\n           char ch=\\'z\\';\\n\\n           for(int i=0;i<s.size();i++)\\n                ch=(ch<s[i])?ch:s[i];\\n            vector<string> str;\\n            for(int i=0;i<s.size();i++){\\n                if(s[i]==ch){\\n                    string temp;\\n                    \\n                    temp=(s.substr(i,s.size()));\\n                    temp=temp+s.substr(0,i);\\n                    str.push_back(temp);\\n                }\\n            }\\n            sort(str.begin(),str.end());\\n            s=str[0];\\n       }\\n            \\n\\n       \\n       return s; \\n    }\\n};\\n```\\n**If you like it then please upvote it \\uD83D\\uDD3C**\\n**Happy Coding \\uD83D\\uDCBB**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n       string res;\\n       if(k==0)\\n        return s;\\n       if(k>1){\\n           res=s;\\n           sort(s.begin(),s.end());\\n       }\\n       else{\\n           char ch=\\'z\\';\\n\\n           for(int i=0;i<s.size();i++)\\n                ch=(ch<s[i])?ch:s[i];\\n            vector<string> str;\\n            for(int i=0;i<s.size();i++){\\n                if(s[i]==ch){\\n                    string temp;\\n                    \\n                    temp=(s.substr(i,s.size()));\\n                    temp=temp+s.substr(0,i);\\n                    str.push_back(temp);\\n                }\\n            }\\n            sort(str.begin(),str.end());\\n            s=str[0];\\n       }\\n            \\n\\n       \\n       return s; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783600,
                "title": "java-easy-96-string",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if (k > 1){\\n            char[] chars = s.toCharArray();\\n            Arrays.sort(chars);\\n            return new String(chars);\\n        }\\n        String ss = s;\\n        for (int i = 1; i < s.length(); i++) {\\n            String rot = s.substring(i) + s.substring(0, i);\\n            if (ss.compareTo(rot) > 0) \\n                ss = rot;\\n        }\\n        return ss;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if (k > 1){\\n            char[] chars = s.toCharArray();\\n            Arrays.sort(chars);\\n            return new String(chars);\\n        }\\n        String ss = s;\\n        for (int i = 1; i < s.length(); i++) {\\n            String rot = s.substring(i) + s.substring(0, i);\\n            if (ss.compareTo(rot) > 0) \\n                ss = rot;\\n        }\\n        return ss;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782758,
                "title": "python-one-line",
                "content": "```python []\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        return (\\n            \"\".join(sorted(s)) if k > 1 else min(s[i:] + s[:i] for i in range(len(s)))\\n        )\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python []\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        return (\\n            \"\".join(sorted(s)) if k > 1 else min(s[i:] + s[:i] for i in range(len(s)))\\n        )\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2161822,
                "title": "java-very-easy-beginner-level-solution-o-nlogn-98-faster",
                "content": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k==1){\\n            String t=s;\\n            for(int i=0,n=s.length();i<n;i++){\\n                String a=s.substring(i)+s.substring(0,i);\\n                if(a.compareTo(t)<0)\\n                    t=a;\\n            }\\n            return t;\\n        }else{\\n            char[] ch=s.toCharArray();\\n            Arrays.sort(ch);\\n            return new String(ch);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k==1){\\n            String t=s;\\n            for(int i=0,n=s.length();i<n;i++){\\n                String a=s.substring(i)+s.substring(0,i);\\n                if(a.compareTo(t)<0)\\n                    t=a;\\n            }\\n            return t;\\n        }else{\\n            char[] ch=s.toCharArray();\\n            Arrays.sort(ch);\\n            return new String(ch);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1557469,
                "title": "java-short-and-simple-solution",
                "content": "\\nIf you observe the different test cases then you will see **If k > 1,** any permutation of s is possible, and the answer is the letters of s written in lexicographic order.\\nSo in this we have to just sort the string \\n\\n\\nIf k = 1, only rotations of s are possible, and the answer is the lexicographically smallest rotation.\\n\\nSo just find the minimum character from the string and find out the indexes at which this min character exists\\n\\nNow iterate the string again check whether swapping around the min character and find the lexicographically smallest string.\\n```\\npublic String orderlyQueue(String s, int k) {\\n        if(k>1){\\n            char[] ans = s.toCharArray();\\n            Arrays.sort(ans);\\n            return String.valueOf(ans);\\n        }\\n        \\n        char min = \\'z\\';\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i=0;i<s.length();i++){\\n            char cc = s.charAt(i);\\n            if(cc<min){\\n                min=cc;\\n            }\\n        }\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==min)\\n                list.add(i);\\n        }\\n        \\n        String ans =s;\\n        for(int i=0;i<list.size();i++){\\n            String after = s.substring(0,list.get(i));\\n            String before = s.substring(list.get(i));\\n            String f = before+after;\\n            \\n            if(f.compareTo(ans)<0){\\n                ans=f;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String orderlyQueue(String s, int k) {\\n        if(k>1){\\n            char[] ans = s.toCharArray();\\n            Arrays.sort(ans);\\n            return String.valueOf(ans);\\n        }\\n        \\n        char min = \\'z\\';\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i=0;i<s.length();i++){\\n            char cc = s.charAt(i);\\n            if(cc<min){\\n                min=cc;\\n            }\\n        }\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==min)\\n                list.add(i);\\n        }\\n        \\n        String ans =s;\\n        for(int i=0;i<list.size();i++){\\n            String after = s.substring(0,list.get(i));\\n            String before = s.substring(list.get(i));\\n            String f = before+after;\\n            \\n            if(f.compareTo(ans)<0){\\n                ans=f;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1447886,
                "title": "best-1ms-java-solution-tc-o-n-sc-o-1-time-and-space-better-than-100-with-detailed-explanation",
                "content": "**Given a string xbqca and k =1.**\\nthe choices we have are xbqca,  bqcax, qcaxb, caxbq, axbqc\\nthe only option we have is to take the first char and append it to last because k is 1 so we are only allowed to chose form the first 1 characters of the string, so we are not having much choice there other that taking the first char.\\n\\nOne way to find the lexographically smallest is by finding all the rotations of string xbqca and and comparing with each other this would take TC O(n^2)  because of n strings and n-1 comparisons resulting in\\n n*(n-1) => O(n)\\n\\nCan we do the same in a better way?\\nFor the given string xbqca the lexographically smallest rotation is axbqc \\nFor cba it is acb\\n\\nnotice the ans starts with the  smallest character \\nSo if we find the smallest character in string then we can find the ans.\\ngiven string \"bcaqd\" with length n smallest char is a at index 2 now, \\nsubstring(2, n)+ substring(0, 2) gives \"aqdbc\" which is the answer.\\nthis can be done in O(n)\\n\\nwhat if there is character repetition? we need to account for that\\nGiven string \"bdatuaz\" of length 7, smallest char a is at index 2 and 5, \\nIn this case we have to finalize on an index by checking the character next to index\\nIn this case we check  the character at index 3 \\'t\\' and index 6 \\'z\\' , as char \\'t\\' at index 2+1 is less than char \\'z\\' at index 5+1 we take the smallest index as 2 and ignore 5.\\nnow answer would be  substring(2, n)+ substring(0, 2)\\n                                         \"atuaz\"       +  \"bd\"     = \"atuazbd\"\\n\\n**For the case k> 1.**\\nLet \"xbqca\" be the given string and k = 2\\n\"xbqca\"  we take \\'b\\' from first 2 characters and append to end =>    \"xqcab\"\\n\"xqcab\"   take q                                                                         =>    \"xcabq\"\\n\"xcabq\"   take c                                                                         =>     \"xabqc\"\\n\"xabqc\"   take x                                                                         =>     \"abqcx\"\\n \"abqcx\"  take a                                                                        =>       \"bqcxa\"\\n \"bqcxa\"   take b                                                                         =>     \"qcxab\"\\n \"qcxab\"  take c                                                                        =>       \"qxabc\"\\n  \"qxabc\"  take q                                                                        =>       \"xabcq\"\\n   \"xabcq\"  take x                                                                        =>       \"abcqx\"\\n\\nfinally we end up with a string sorted by its characters. which is the lexographically smallest possible.\\nNow consider same string \"xbqca\" with k = 3\\n\"xbqca\"  we take \\'b\\' from first 3 characters and append to end =>    \"xqcab\"\\n\"xqcab\"   take c                                                                         =>    \"xqabc\"\\n\"xqabc\"   take q                                                                         =>    \"xabcq\"\\n\"xabcq\"   take x                                                                         =>    \"abcqx\"\\n\\nagain we end up with a string sorted by its chars which is the lexographically smallest.\\n\\nso fro any k>1 we can reach the lexographically smallest string possible (sorted string).\\nThis is possible because we are allowed to make the append operation any number of times.\\n\\nSo for inputs with k>1 ans is simply the sorted string.\\nnow the TC of sorting normally is O(nlogn) but here it given characters can only be lower case letters \\nwhich is total 26.\\n\\nto sort string \"debbc\" we create an  array arr of size 26 \\nitereate the string for each char ch  arr[ch]++;\\nafter first iteration we get a frequency arr   a b c d e f -  - - z\\n                                                                    0 2 1 1 10        0\\nnow we create ans =\"\" and iterrate arr form i =0 to 26\\nwe append each char \\'a\\'+i  arr[i] number of times\\n\\nans would be \"\"+b+b+c+d+e = \"bbcde\"\\nSorting also done in O(n) and constant space\\n\\n```\\nclass Solution {  //O(n) time and O(1) space\\n    public String orderlyQueue(String s, int k) {\\n        int n = s.length();\\n        if(k ==1)\\n            return smallestRotated(s);\\n        return sorted(s);\\n    }\\n    \\n    //O(n) time, O(1) space\\n    public String smallestRotated(String s){\\n        char smallest = s.charAt(0);\\n        int smallIndex = 0;\\n        int n = s.length();\\n        for(int i =0; i<s.length(); i++){\\n            if(s.charAt(i)< smallest){         // new smallest found\\n                smallest = s.charAt(i);\\n                smallIndex = i;\\n            }else if(s.charAt(i) == smallest){   // already existing smallest with a different index (repetition)\\n                int j = 0;\\n                for(j =1; j<s.length(); j++){\\n                    char next1 = s.charAt((i+j)%n);                              // trying to compare next chars \\n                    char next2 = s.charAt((smallIndex+j)%n);\\n                    if(next1< smallest){                                            // the next char happens to be the smaller than\\n                        smallest = s.charAt(i+j);                                // current smallest then updating it as smallest\\n                        smallIndex = i+j;\\n                        break;\\n                    }\\n                    if(next1< next2){                                               // comparing next chars of two index\\n                        smallIndex = i;                                              \\n                        break;\\n                    }else if(next2< next1)\\n                        break;\\n                }\\n                i = i+j;  \\n            }\\n        }\\n        return s.substring(smallIndex, n)+s.substring(0, smallIndex);\\n    }\\n    \\n    //O(n) time, O(1) space only constant space used\\n    public String sorted(String s){\\n        int[] arr = new int[26];\\n        for(char ch: s.toCharArray()){                                                   // creating char freq table\\n            arr[ch-\\'a\\']++;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        char ch = \\'a\\';\\n        for(int val: arr){                                                                       // using char freq table to get the sorted array\\n            while(val-- >0)\\n                sb.append(ch);\\n            ch++;\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {  //O(n) time and O(1) space\\n    public String orderlyQueue(String s, int k) {\\n        int n = s.length();\\n        if(k ==1)\\n            return smallestRotated(s);\\n        return sorted(s);\\n    }\\n    \\n    //O(n) time, O(1) space\\n    public String smallestRotated(String s){\\n        char smallest = s.charAt(0);\\n        int smallIndex = 0;\\n        int n = s.length();\\n        for(int i =0; i<s.length(); i++){\\n            if(s.charAt(i)< smallest){         // new smallest found\\n                smallest = s.charAt(i);\\n                smallIndex = i;\\n            }else if(s.charAt(i) == smallest){   // already existing smallest with a different index (repetition)\\n                int j = 0;\\n                for(j =1; j<s.length(); j++){\\n                    char next1 = s.charAt((i+j)%n);                              // trying to compare next chars \\n                    char next2 = s.charAt((smallIndex+j)%n);\\n                    if(next1< smallest){                                            // the next char happens to be the smaller than\\n                        smallest = s.charAt(i+j);                                // current smallest then updating it as smallest\\n                        smallIndex = i+j;\\n                        break;\\n                    }\\n                    if(next1< next2){                                               // comparing next chars of two index\\n                        smallIndex = i;                                              \\n                        break;\\n                    }else if(next2< next1)\\n                        break;\\n                }\\n                i = i+j;  \\n            }\\n        }\\n        return s.substring(smallIndex, n)+s.substring(0, smallIndex);\\n    }\\n    \\n    //O(n) time, O(1) space only constant space used\\n    public String sorted(String s){\\n        int[] arr = new int[26];\\n        for(char ch: s.toCharArray()){                                                   // creating char freq table\\n            arr[ch-\\'a\\']++;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        char ch = \\'a\\';\\n        for(int val: arr){                                                                       // using char freq table to get the sorted array\\n            while(val-- >0)\\n                sb.append(ch);\\n            ch++;\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1447710,
                "title": "c-solution",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    string orderlyQueue(string s, int k) \\n    {\\n        string ans = s; \\n        if (k == 1) \\n            for (int i = 1; i < s.size(); ++i) \\n                ans = min(ans, s.substr(i) + s.substr(0, i)); \\n        else \\n            sort(ans.begin(), ans.end()); \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    string orderlyQueue(string s, int k) \\n    {\\n        string ans = s; \\n        if (k == 1) \\n            for (int i = 1; i < s.size(); ++i) \\n                ans = min(ans, s.substr(i) + s.substr(0, i)); \\n        else \\n            sort(ans.begin(), ans.end()); \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1447560,
                "title": "c-solution",
                "content": "**Intuition**\\nwhen ```k >= 2```, when can swap any two adjancent letters. For example, we want to swap ```C``` and ```D```in string ```ABCDEDF```. then we can do:  ```ABCDEDF``` => ```CDEDFAB``` =>  ```CEDFABD``` => =>  ```EDFABDC``` => ```ABDCEDF```\\n\\nwhen ```k = 1```, when can only append the first letter to the end every time.\\n**Implementation**\\n```\\npublic class Solution {\\n    public string OrderlyQueue(string s, int k) {\\n        \\n        if(k >= 2)\\n        {\\n            char[] arr = s.ToCharArray();\\n            Array.Sort(arr);\\n            return new string(arr);\\n        }\\n        else\\n        {\\n            string min = s;\\n            for(int i = 0; i < s.Length; i++)\\n            {\\n                s = s.Substring(1, s.Length - 1) + s[0];\\n                if(s.CompareTo(min) < 0)\\n                    min = s;\\n            }\\n            return min;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```k >= 2```\n```C```\n```D```\n```ABCDEDF```\n```ABCDEDF```\n```CDEDFAB```\n```CEDFABD```\n```EDFABDC```\n```ABDCEDF```\n```k = 1```\n```\\npublic class Solution {\\n    public string OrderlyQueue(string s, int k) {\\n        \\n        if(k >= 2)\\n        {\\n            char[] arr = s.ToCharArray();\\n            Array.Sort(arr);\\n            return new string(arr);\\n        }\\n        else\\n        {\\n            string min = s;\\n            for(int i = 0; i < s.Length; i++)\\n            {\\n                s = s.Substring(1, s.Length - 1) + s[0];\\n                if(s.CompareTo(min) < 0)\\n                    min = s;\\n            }\\n            return min;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446403,
                "title": "c-linq-one-liner",
                "content": "```csharp\\npublic string OrderlyQueue(string s, int k) => k == 1\\n    ? Enumerable.Range(0, s.Length).Min(i => s[i..] + s[..i])\\n    : string.Concat(s.OrderBy(c => c));\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic string OrderlyQueue(string s, int k) => k == 1\\n    ? Enumerable.Range(0, s.Length).Min(i => s[i..] + s[..i])\\n    : string.Concat(s.OrderBy(c => c));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1446243,
                "title": "c-linear-solution-explained-100-time-90-space",
                "content": "This problem is really interesting and might seem overwhelmingly complicated, but if you run a few tests (or just notice things), you will notice that for `k > 1` each possible permutation can be (eventually) obtained, thus the smaller one is the right one and that is easy to sort.\\n\\nCuriously in this problem the \"base\" case is then for almost every possible variable, if you wish, while the edge case comes with a rather different logic, since with `k == 1`, no matter how many times we can try, we can only get rotations of the original string, so we have to go and find the smaller one.\\n\\nSo, first of all let\\'s get the easier case done; for `k > 1` we will just:\\n* `sort` `s`;\\n* `return` `s`.\\n\\nThe case of `k == 1` is actually a much funnier challenge and while we might be tempted to just generate and compare a bunch of substrings, we can definitely do better.\\n\\nAssuming initially our input string might be the smallest, we will set `pivot` to be `0`, then we will iterate with `i` from `1` to the size of `s` and using also `j` and the pointers `s1` and `s2` we will:\\n* initialise the variables for the next inner loop, with `j` = `lmt`, `s1` getting the value of our `pivot` and `s2` matching initially `i`;\\n* we will then loop `j` times and have three cases:\\n\\t* our pivot is still matching the smallest rotation (`s[s1] < s[s2]`), so no point in continuing and we can `break`;\\n\\t* specularly, our pivot is no longer matching the smallest rotation (`s[s1] > s[s2]`), so no point in continuing again, we update the value of `pivot` with `i` and we can `break`;\\n\\t* if both `s1` and `s2` point to the same character, we will then just have to:\\n\\t* increase both of them;\\n\\t* check if they overflow and in case reset them to `0` for the next loop.\\n\\nOnce done, if we discovered that the best rotation was with `pivot == 0` (ie: no rotation needed), we can just `return` `s`.\\n\\nAlternatively, in most case, we can save maybe a bit of memory and:\\n* create `res` as `s.substr(pivot)`;\\n* resize `s` to be only `pivot` characters (which might or might not cause a reallocation, I guess);\\n* `return` `res + s` and be done :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        // general case: k > 1 so that we can get any possibly permutation\\n        if (k > 1) {\\n            sort(begin(s), end(s));\\n            return s;\\n        }\\n        // edge case: k == 1\\n        int pivot = 0;\\n        for (int i = 1, lmt = s.size(), j, s1, s2; i < lmt; i++) {\\n            // comparing character by character\\n            j = lmt, s1 = pivot, s2 = i;\\n            while (j--) {\\n                // first case: current pivot is still smaller\\n                if (s[s1] < s[s2]) break;\\n                // second case: i is smaller\\n                else if (s[s1] > s[s2]) {\\n                    pivot = i;\\n                    break;\\n                }\\n                // third case: we advance the pointers\\n                else {\\n                    s1++, s2++;\\n                    if (s2 == lmt) s2 = 0;\\n                    else if (s1 == lmt) s1 = 0;\\n                }\\n            }\\n        }\\n        // edge case: no rotation needed\\n        if (!pivot) return s;\\n        // computing the rotated string\\n        string res = s.substr(pivot);\\n        s.resize(pivot);\\n        return res + s;\\n    }\\n};\\n```\\n\\nBut, wait a moment: did I title this discussion as a linear solution, then I go and non-chalantly `sort` my string in linearithmic time?\\n\\nNot cool, not cool at all!\\n\\nLuckily, we can come up with a kind of bucket sorting and go actually with a linear approach, changing the base case code to this, ending up even saving a bit of memory (and probably doing much better with longer strings overall):\\n\\n```cpp\\n        if (k > 1) {\\n            // support variables\\n            char chars[123];\\n            // getting the frequency of each letter\\n            for (int i = \\'a\\'; i <= \\'z\\'; i++) chars[i] = 0;\\n            for (char c: s) chars[c]++;\\n            // replacing the content of s with the information stored in chars\\n            for (int i = \\'a\\', j, pos = 0; i <=\\'z\\'; i++) {\\n                if (chars[i]) {\\n                    j = chars[i];\\n                    while (j--) s[pos++] = i;\\n                }\\n            }\\n            return s;\\n        }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Combinatorics"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        // general case: k > 1 so that we can get any possibly permutation\\n        if (k > 1) {\\n            sort(begin(s), end(s));\\n            return s;\\n        }\\n        // edge case: k == 1\\n        int pivot = 0;\\n        for (int i = 1, lmt = s.size(), j, s1, s2; i < lmt; i++) {\\n            // comparing character by character\\n            j = lmt, s1 = pivot, s2 = i;\\n            while (j--) {\\n                // first case: current pivot is still smaller\\n                if (s[s1] < s[s2]) break;\\n                // second case: i is smaller\\n                else if (s[s1] > s[s2]) {\\n                    pivot = i;\\n                    break;\\n                }\\n                // third case: we advance the pointers\\n                else {\\n                    s1++, s2++;\\n                    if (s2 == lmt) s2 = 0;\\n                    else if (s1 == lmt) s1 = 0;\\n                }\\n            }\\n        }\\n        // edge case: no rotation needed\\n        if (!pivot) return s;\\n        // computing the rotated string\\n        string res = s.substr(pivot);\\n        s.resize(pivot);\\n        return res + s;\\n    }\\n};\\n```\n```cpp\\n        if (k > 1) {\\n            // support variables\\n            char chars[123];\\n            // getting the frequency of each letter\\n            for (int i = \\'a\\'; i <= \\'z\\'; i++) chars[i] = 0;\\n            for (char c: s) chars[c]++;\\n            // replacing the content of s with the information stored in chars\\n            for (int i = \\'a\\', j, pos = 0; i <=\\'z\\'; i++) {\\n                if (chars[i]) {\\n                    j = chars[i];\\n                    while (j--) s[pos++] = i;\\n                }\\n            }\\n            return s;\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446177,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        \\n        if(k==1){\\n            String res = s;\\n            \\n            for(int i=0;i<s.length();++i){\\n                String temp = s.substring(i) + s.substring(0, i);\\n                \\n                if(temp.compareTo(res)<0){\\n                    res = temp;\\n                }\\n            }\\n            return res;\\n        }\\n        else{\\n            char[] chars = s.toCharArray();\\n            Arrays.sort(chars);\\n            return new String(chars);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        \\n        if(k==1){\\n            String res = s;\\n            \\n            for(int i=0;i<s.length();++i){\\n                String temp = s.substring(i) + s.substring(0, i);\\n                \\n                if(temp.compareTo(res)<0){\\n                    res = temp;\\n                }\\n            }\\n            return res;\\n        }\\n        else{\\n            char[] chars = s.toCharArray();\\n            Arrays.sort(chars);\\n            return new String(chars);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446055,
                "title": "c-sorting-rotating",
                "content": "Let us keep the explanation simple.\\n\\n**If k == 1** then we can only **remove the first character** from the string and **append it to the string** i.e **Rotating the string** .  While rotating **compare all the combinations** and **find** the **smallest Lexicographic String**.\\n\\n**if  k > 1**  then we can **swap the adjacent characters** and that is the requirement for **sorting**. So just simply sort the string.\\n\\n\\tstring orderlyQueue(string s, int k) \\n\\t{        \\n\\t\\tif (k > 1)  sort(s.begin(), s.end());\\n\\t\\t\\telse \\n\\t\\t\\t{\\n\\t\\t\\t\\tstring result = s;\\n\\t\\t\\t\\tfor (int i=0; i<s.length(); i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ts = s.substr(1) + s[0];\\n\\t\\t\\t\\t\\tresult = min(result, s);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t}\\n\\t\\t\\treturn s;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "Let us keep the explanation simple.\\n\\n**If k == 1** then we can only **remove the first character** from the string and **append it to the string** i.e **Rotating the string** .  While rotating **compare all the combinations** and **find** the **smallest Lexicographic String**.\\n\\n**if  k > 1**  then we can **swap the adjacent characters** and that is the requirement for **sorting**. So just simply sort the string.\\n\\n\\tstring orderlyQueue(string s, int k) \\n\\t{        \\n\\t\\tif (k > 1)  sort(s.begin(), s.end());\\n\\t\\t\\telse \\n\\t\\t\\t{\\n\\t\\t\\t\\tstring result = s;\\n\\t\\t\\t\\tfor (int i=0; i<s.length(); i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\ts = s.substr(1) + s[0];\\n\\t\\t\\t\\t\\tresult = min(result, s);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t}\\n\\t\\t\\treturn s;\\n\\t\\t}\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 1445680,
                "title": "c-100-easy-to-understand-with-proper-explanation",
                "content": "/*\\n\\nBefore Jump to the problem let\\'s discuss some cases which may tell us how to proceed to this problem.\\n\\nEXAMPLE->1: s=\"bcabc\"  k=1\\n-----------\\n now pick index 0 character \\'b\\' and append at the end of the string. s=\"cabcb\"\\n \\n again pick index 0 character \\'c\\' and append it then s=\"abcbc\".\\n \\n This modified string is the lexicographically smallest among all the permutations possible by k-moves any number of times.\\n \\n So,when k is given k=1  , Then we observe that \\n \\n we are allowed to rotate the string any number of time by 1 character [Left Rotation]\\n \\n So just apply brute force method to check which rotated string gives us the desired output.\\n \\n \\n EXAMPLE->2: s=\"bcaaaaa\"  k=2\\n ----------\\n \\n When we are given k==2 in other word it gives us the freedom to swap any two adjacent characters . And obvoiusly for our sake we sort two characters lexicographically at each move . As a result, second smallest character comes after smallest character and the third one comes after second smallest character. \\n \\n So required transformation looks like---->\\n \\n \"bcaaaaa\" ---  \"caaaaab\"  ---  \"aaaaabc\".\\n \\n So as a whole Just we can sort the string and return it.\\n \\n In a same manner for k>2 alse we can do the above mentioned steps (because the steps we follow for k==2 , we can repeat the same for k>2 also).\\n \\n \\n*/\\n\\n\\n\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        \\n        \\n        if(k==1){\\n            \\n            string temp=s;\\n            \\n            for(int i=0;i<s.length();i++){\\n                \\n                string sub=s.substr(i)+s.substr(0,i);\\n                \\n                if(min(temp,sub)==sub){\\n                    temp=sub;\\n                }\\n                \\n            }\\n            \\n            return temp;\\n        }\\n        \\n        else{\\n            \\n            sort(s.begin(),s.end());\\n            \\n            return s;\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        \\n        \\n        if(k==1){\\n            \\n            string temp=s;\\n            \\n            for(int i=0;i<s.length();i++){\\n                \\n                string sub=s.substr(i)+s.substr(0,i);\\n                \\n                if(min(temp,sub)==sub){\\n                    temp=sub;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1445678,
                "title": "python-simple-solution",
                "content": "For the fact that we can change the order of any 2 characters in the string if k >= 2, \\n\\ne.g. a, b are chars, A, B are substrings\\naAbB -> abBA -> BAab or BAba\\nWe can put ab together with either order. \\n\\nThe answer is pretty simple as sorting just works. \\n\\n```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k == 1:\\n            return min([s[i:] + s[:i] for i in range(len(s))])\\n        return \\'\\'.join(sorted(s))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k == 1:\\n            return min([s[i:] + s[:i] for i in range(len(s))])\\n        return \\'\\'.join(sorted(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1350877,
                "title": "c-899-orderly-queue",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        string ans = s; \\n        if (k == 1) \\n            for (int i = 1; i < s.size(); ++i) \\n                ans = min(ans, s.substr(i) + s.substr(0, i)); \\n        else \\n            sort(ans.begin(), ans.end()); \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        string ans = s; \\n        if (k == 1) \\n            for (int i = 1; i < s.size(); ++i) \\n                ans = min(ans, s.substr(i) + s.substr(0, i)); \\n        else \\n            sort(ans.begin(), ans.end()); \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1350871,
                "title": "python3-rotation-or-sorting",
                "content": "\\n```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k == 1: return min(s[i:] + s[:i] for i in range(len(s)))\\n        return \"\".join(sorted(s))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k == 1: return min(s[i:] + s[:i] for i in range(len(s)))\\n        return \"\".join(sorted(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1193649,
                "title": "c-easiest-solution-with-detailed-explanation-beats-100-time-complexity",
                "content": "# Explanation\\n ***This question is similar to array rotation***\\n1.  (k==1), we can rotate the array everytime and get the lexicographically Smallest string\\n2.  k>1), this means that we can swap any adjacent two characters in the string\\n\\t*     Actually, when K>=2, we can prove that we can use the first 2 elements as a buffer to swap any two adjacent    characters. \\n\\t*     Assume that we want to swap S[i] and S[i+1], we can first pop first i-1 characters to the end, then pop i+1              and i, finally pop i+2~end.\\n3. Since we can reach any permutation by swapping adjacent characters (like bubble sort), in this case the minimal reachable permutation is the sorted String. So when k>1 , solution is sorted string\\n\\n```\\nstring orderlyQueue(string S, int K) {\\n        if(K==1){ //rotate string to get all permutations and take lexographically smallest string\\n            int n=S.size();\\n            string smallest=S;\\n            for(int i=1;i<n;i++){\\n                char ch=S[0];\\n                S.erase(S.begin());\\n                S.push_back(ch);\\n                \\n                if(S<smallest)\\n                    smallest=S;\\n                               \\n            }\\n            return smallest;\\n        }\\n        //else\\n        //k>1 means we can swap any two adjacent characters(as mentioned in step 2). \\n        //We can sort the entire string (as we have infinite moves ),similar to what we do in BUBBLE SORT\\n        //So final answer will be sortedString\\n            \\n        sort(S.begin(),S.end());\\n        return S;\\n        \\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\nstring orderlyQueue(string S, int K) {\\n        if(K==1){ //rotate string to get all permutations and take lexographically smallest string\\n            int n=S.size();\\n            string smallest=S;\\n            for(int i=1;i<n;i++){\\n                char ch=S[0];\\n                S.erase(S.begin());\\n                S.push_back(ch);\\n                \\n                if(S<smallest)\\n                    smallest=S;\\n                               \\n            }\\n            return smallest;\\n        }\\n        //else\\n        //k>1 means we can swap any two adjacent characters(as mentioned in step 2). \\n        //We can sort the entire string (as we have infinite moves ),similar to what we do in BUBBLE SORT\\n        //So final answer will be sortedString\\n            \\n        sort(S.begin(),S.end());\\n        return S;\\n        \\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 615325,
                "title": "c-complete-code-with-explanation-4-ms-reason-of-sort-and-rotate",
                "content": "***INTUITION:-***\\nWe should think this question considering k = 1 first.\\nSo given a string with k = 1, then by removing first k characters and putting them at string end, you are effectively rotating the string. Here in different moves you will be generating the rotated string.\\n\\nThus for k = 1, we rotate the given string character by character until we got original string back. At every move we put the rotated string into a vector of string. After getting all rotated string into vector of string, we sort the vector and the string at index 0 will be our required string.\\n\\nNow the second case to be considered is that if K is greater than 1.\\nIf you take any string with k greater than 1, you will find that you are able to generate all the permutation of the string. Among all the permutaion we will return the smallest string.\\nNo need to generate all the permutation just sort the given string and return it.\\n\\n***Example for k > 1***\\nlet string s = \"rao\", and k = 2\\nthe possible string that can be obtained using the given rule are, rao->aor->oar->ora->aro->roa\\nwhich all are permutaion of the given string.\\n\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string S, int K) {\\n        int n = S.length();\\n        \\n        if(n == 0){\\n            return \"\";\\n        }\\n        \\n        if(K > 1){\\n            sort(S.begin(),S.end());\\n            return S;\\n        }\\n        \\n        vector<string> v;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            char curr = S[0];\\n            S.erase(S.begin());\\n            S += curr;\\n            v.push_back(S);\\n            \\n        }\\n        \\n        sort(v.begin(),v.end());\\n        \\n        return v[0];\\n    }\\n};\\n```\\n\\nhope it helps!!!\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string S, int K) {\\n        int n = S.length();\\n        \\n        if(n == 0){\\n            return \"\";\\n        }\\n        \\n        if(K > 1){\\n            sort(S.begin(),S.end());\\n            return S;\\n        }\\n        \\n        vector<string> v;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            char curr = S[0];\\n            S.erase(S.begin());\\n            S += curr;\\n            v.push_back(S);\\n            \\n        }\\n        \\n        sort(v.begin(),v.end());\\n        \\n        return v[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 566310,
                "title": "golang-solution-sort-rotate-string-100-time-space-with-explanation",
                "content": "Explaination:\\nCase 1( k==1):\\nwe can just rotate the string by one position every time, hence find the lexicographically smallest of all possible rotations and return it. This can be done by finding the lexicographically smallest character in the string and moving all the characters before it to the last.\\n\\nCase 2(k>1):\\nAll the cases where k>1 are equivalent. This is because, if say k=4, we can even rotate the characters only from a window of 3 characters, or 2 charaters. Hence, case k=4 is same as k=2 or k=3. But do we get the same lexicographically smallest string from all values of k>. Let\\'s check.\\n```\\ns: ebdacbg, k=2\\nsince \"a\" is the smallest character, let\\'s try bringing it to front. \\nTo get the lexicographically smallest permutation, we\\'ll move the smallest character from window to the last.\\n[]-> current window\\ns: [eb]dacbg\\ns: [ed]acbgb\\ns: [ea]cbgbd\\ns1: [ac]bgbde\\n```\\nIf you see now, all charaters before the smallest character( \"a\") got to the last in sorted order (\"bde\"). Let\\'s run another iteration and try to bring back (\"a\") to the front: \\n```\\ns: [cb]gbdea\\ns: [cg]bdeab\\ns: [gb]deabc\\ns: [gd]eabcb\\ns: [ge]abcbd\\ns: [ga]bcbde\\ns2: [ab]cbdeg\\n```\\nSo we see we got a smaller string( lexicographically) than what we got after first iteration(`s1`). How?\\nThis is because what we are essentially doing here is bubble sort, we are comparing the elements in the window and removing the smaller element and moving forward with the larger element. Like this, the largest element would stay in the window till the very last and will finally get placed in the last position.\\n\\nHence, if you see, with every `ith` iteration, last `i` elements of the string will be in sorted order.\\n\\nAnd since we know, bubble sort eventually leads to a sorted array, the solution will be the sorted array, `sort(s)`.\\n\\nCode: \\n```\\nimport (\\n    \"sort\"\\n)\\nfunc orderlyQueue(S string, K int) string {\\n    s := []byte(S)\\n    if K>1 {\\n        sort.Slice(s, func(i int, j int) bool { return s[i] < s[j] })\\n        return string(s)        \\n    } else {\\n        i:=findSmallest(s)\\n        return string(append(s[i:],s[:i]...))\\n    }\\n}\\nfunc findSmallest(s []byte) int {\\n    smallest:=0\\n    for i:=1; i<len(s); i++ {\\n        if s[i]<s[smallest] {\\n            smallest=i\\n        } else if s[i]==s[smallest] {\\n            j, k:= smallest+1, i+1\\n            for k<len(s) {\\n                if s[j]<s[k] {\\n                    break\\n                } else if s[j]==s[k] {\\n                    j++; k++\\n                } else {\\n                    smallest=i\\n                    break\\n                }\\n            }\\n            if k==len(s) {\\n                smallest=i\\n            }\\n        }\\n    }\\n    return smallest\\n}\\n```\\nComplexity: \\nTime: O(n^2) -> due to `findSmallest()` which is n^2 in worst case\\nSpace: O(n) -> for auxiliary byte slice for the string",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ns: ebdacbg, k=2\\nsince \"a\" is the smallest character, let\\'s try bringing it to front. \\nTo get the lexicographically smallest permutation, we\\'ll move the smallest character from window to the last.\\n[]-> current window\\ns: [eb]dacbg\\ns: [ed]acbgb\\ns: [ea]cbgbd\\ns1: [ac]bgbde\\n```\n```\\ns: [cb]gbdea\\ns: [cg]bdeab\\ns: [gb]deabc\\ns: [gd]eabcb\\ns: [ge]abcbd\\ns: [ga]bcbde\\ns2: [ab]cbdeg\\n```\n```\\nimport (\\n    \"sort\"\\n)\\nfunc orderlyQueue(S string, K int) string {\\n    s := []byte(S)\\n    if K>1 {\\n        sort.Slice(s, func(i int, j int) bool { return s[i] < s[j] })\\n        return string(s)        \\n    } else {\\n        i:=findSmallest(s)\\n        return string(append(s[i:],s[:i]...))\\n    }\\n}\\nfunc findSmallest(s []byte) int {\\n    smallest:=0\\n    for i:=1; i<len(s); i++ {\\n        if s[i]<s[smallest] {\\n            smallest=i\\n        } else if s[i]==s[smallest] {\\n            j, k:= smallest+1, i+1\\n            for k<len(s) {\\n                if s[j]<s[k] {\\n                    break\\n                } else if s[j]==s[k] {\\n                    j++; k++\\n                } else {\\n                    smallest=i\\n                    break\\n                }\\n            }\\n            if k==len(s) {\\n                smallest=i\\n            }\\n        }\\n    }\\n    return smallest\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 220864,
                "title": "java-super-easy-and-fast-10ms-9-line-solution-beats-95",
                "content": "```\\n    public String orderlyQueue(String S, int K) {\\n        if(K>1) {\\n            char[] temp=S.toCharArray();\\n            Arrays.sort(temp);\\n            return new String(temp);\\n        }\\n        String res=S;\\n        for(int i=1;i<S.length();i++) {\\n            String temp=S.substring(i)+S.substring(0, i);\\n            if(temp.compareTo(res)<0) res=temp;\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\n    public String orderlyQueue(String S, int K) {\\n        if(K>1) {\\n            char[] temp=S.toCharArray();\\n            Arrays.sort(temp);\\n            return new String(temp);\\n        }\\n        String res=S;\\n        for(int i=1;i<S.length();i++) {\\n            String temp=S.substring(i)+S.substring(0, i);\\n            if(temp.compareTo(res)<0) res=temp;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 165871,
                "title": "javascript-a-trap-question",
                "content": "In fact when `K>1`, we can totally sort the string.\\n\\nBy swapping two neighbors, we can sort a string -- this is the way how **bubble sorting** works.\\nAnd by choosing one of two neighbors and place it at the end, we can rearrange/swap these two elements -- therefore we can sort the string when `K>=2`.\\n\\nSo the only part we need to deal with is when `K===1`.\\n```\\nvar orderlyQueue = function(S, K) {\\n    if(K>1) return S.split(\\'\\').sort().join(\\'\\');\\n    else{\\n    \\tlet small = S.split(\\'\\').sort()[0];\\n    \\tlet ops = [];\\n    \\tfor(let i=0; i<S.length; i++){\\n    \\t\\tif(S[i]===small) ops.push(S.slice(i)+S.slice(0,i));\\n    \\t}\\n    \\treturn ops.sort()[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar orderlyQueue = function(S, K) {\\n    if(K>1) return S.split(\\'\\').sort().join(\\'\\');\\n    else{\\n    \\tlet small = S.split(\\'\\').sort()[0];\\n    \\tlet ops = [];\\n    \\tfor(let i=0; i<S.length; i++){\\n    \\t\\tif(S[i]===small) ops.push(S.slice(i)+S.slice(0,i));\\n    \\t}\\n    \\treturn ops.sort()[0];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3922725,
                "title": "c-javascript-easy-solution",
                "content": "# Complexity\\n- Time complexity:  O(n log n) when k > 1, O(n^2) when k = 1\\n\\n- Space complexity: : O(1)\\n\\n# Code\\n# C++\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if (k>1) {\\n            sort(s.begin(), s.end());\\n            return s;\\n        }\\n        string res = s;\\n        for (int i = 1; i < s.size(); i++)\\n            res = min(res, s.substr(i) + s.substr(0, i));\\n        return res;\\n    }\\n};\\n```\\n\\n# JavaScript\\n```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {string}\\n */\\nvar orderlyQueue = function(s, k) {\\n    if (k > 1) {\\n        return s.split(\"\").sort().join(\"\");\\n    }\\n\\n    let res = s;\\n    for (let i = 1; i < s.length; i++) {\\n            const newStr = s.substr(i) + s.substr(0, i);\\n            if (newStr < res) {\\n            res = newStr;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "JavaScript",
                    "Math",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if (k>1) {\\n            sort(s.begin(), s.end());\\n            return s;\\n        }\\n        string res = s;\\n        for (int i = 1; i < s.size(); i++)\\n            res = min(res, s.substr(i) + s.substr(0, i));\\n        return res;\\n    }\\n};\\n```\n```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {string}\\n */\\nvar orderlyQueue = function(s, k) {\\n    if (k > 1) {\\n        return s.split(\"\").sort().join(\"\");\\n    }\\n\\n    let res = s;\\n    for (let i = 1; i < s.length; i++) {\\n            const newStr = s.substr(i) + s.substr(0, i);\\n            if (newStr < res) {\\n            res = newStr;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861988,
                "title": "0ms-easy-approch-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k==0) return s;\\n        if(k>1){\\n            sort(s.begin(),s.end());\\n            return s;\\n        }\\n        if(k==1){\\n            string new_var=s;\\n            for(int i=0;i<s.length();i++){\\n                s=s.substr(1)+s[0];\\n                if(new_var>s)new_var=s;\\n            }\\n            return new_var;\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k==0) return s;\\n        if(k>1){\\n            sort(s.begin(),s.end());\\n            return s;\\n        }\\n        if(k==1){\\n            string new_var=s;\\n            for(int i=0;i<s.length();i++){\\n                s=s.substr(1)+s[0];\\n                if(new_var>s)new_var=s;\\n            }\\n            return new_var;\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513911,
                "title": "solution",
                "content": "```C++ []\\n#pragma once\\n#include <algorithm>\\n#include <string>\\n\\nclass Solution {\\nprivate:\\n  static bool less(const std::string &s, size_t l, size_t r) {\\n    for (size_t i = 0; i < s.size(); ++i) {\\n      const auto s1 = s[(l + i) % s.size()];\\n      const auto s2 = s[(r + i) % s.size()];\\n      if (s1 != s2) {\\n        return s1 < s2;\\n      }\\n    }\\n    return true;\\n  }\\n  static size_t min_position(const std::string &s) {\\n    size_t i = 0;\\n    for (size_t j = 1; j < s.size(); ++j) {\\n      if (less(s, j, i)) {\\n        i = j;\\n      }\\n    }\\n    return i;\\n  }\\npublic:\\n  static std::string orderlyQueue(std::string s, int k) {\\n    if (k == 1) {\\n      std::rotate(s.begin(), s.begin() + min_position(s), s.end());\\n    } else {\\n      std::sort(s.begin(), s.end());\\n    }\\n    return s;\\n  }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k == 1:\\n            return min(s[i:]+s[:i] for i in range(len(s)))\\n\\n        else :\\n            return \\'\\'.join(sorted(s))\\n```\\n\\n```Java []\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        int[] countChar = new int[26];\\n        int length = s.length();\\n        for(int i = 0 ; i < length ; ++i) {\\n            countChar[s.charAt(i) - \\'a\\']++;\\n        }\\n        if(k > 1) {\\n            StringBuilder sb = new StringBuilder();\\n            for(int i = 0 ; i < 26 ; ++i) {\\n                int appearance = countChar[i];\\n                char c = (char)(\\'a\\' + i);\\n                for(int r = 0 ; r < appearance ; ++r) {\\n                    sb.append(c);\\n                }\\n            }\\n            return sb.toString();\\n        }\\n        char startChar = \\'a\\';\\n        for(int i = 0 ; i < 26 ; ++i) {\\n            if(countChar[i] > 0) {\\n                startChar = (char)(\\'a\\' + i);\\n                break;\\n            }\\n        }\\n        List<String> beginWithStartChar = new ArrayList<>();\\n        for(int i = 0 ; i < length ; ++i) {\\n            if(s.charAt(i) == startChar) {\\n                beginWithStartChar.add(s.substring(i) + s.substring(0, i));\\n            }\\n        }\\n        String min = beginWithStartChar.get(0);\\n        for(String strBeginWithStartChar : beginWithStartChar) {\\n            if(strBeginWithStartChar.compareTo(min) < 0) min = strBeginWithStartChar;\\n        }\\n        return min;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\n#pragma once\\n#include <algorithm>\\n#include <string>\\n\\nclass Solution {\\nprivate:\\n  static bool less(const std::string &s, size_t l, size_t r) {\\n    for (size_t i = 0; i < s.size(); ++i) {\\n      const auto s1 = s[(l + i) % s.size()];\\n      const auto s2 = s[(r + i) % s.size()];\\n      if (s1 != s2) {\\n        return s1 < s2;\\n      }\\n    }\\n    return true;\\n  }\\n  static size_t min_position(const std::string &s) {\\n    size_t i = 0;\\n    for (size_t j = 1; j < s.size(); ++j) {\\n      if (less(s, j, i)) {\\n        i = j;\\n      }\\n    }\\n    return i;\\n  }\\npublic:\\n  static std::string orderlyQueue(std::string s, int k) {\\n    if (k == 1) {\\n      std::rotate(s.begin(), s.begin() + min_position(s), s.end());\\n    } else {\\n      std::sort(s.begin(), s.end());\\n    }\\n    return s;\\n  }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k == 1:\\n            return min(s[i:]+s[:i] for i in range(len(s)))\\n\\n        else :\\n            return \\'\\'.join(sorted(s))\\n```\n```Java []\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        int[] countChar = new int[26];\\n        int length = s.length();\\n        for(int i = 0 ; i < length ; ++i) {\\n            countChar[s.charAt(i) - \\'a\\']++;\\n        }\\n        if(k > 1) {\\n            StringBuilder sb = new StringBuilder();\\n            for(int i = 0 ; i < 26 ; ++i) {\\n                int appearance = countChar[i];\\n                char c = (char)(\\'a\\' + i);\\n                for(int r = 0 ; r < appearance ; ++r) {\\n                    sb.append(c);\\n                }\\n            }\\n            return sb.toString();\\n        }\\n        char startChar = \\'a\\';\\n        for(int i = 0 ; i < 26 ; ++i) {\\n            if(countChar[i] > 0) {\\n                startChar = (char)(\\'a\\' + i);\\n                break;\\n            }\\n        }\\n        List<String> beginWithStartChar = new ArrayList<>();\\n        for(int i = 0 ; i < length ; ++i) {\\n            if(s.charAt(i) == startChar) {\\n                beginWithStartChar.add(s.substring(i) + s.substring(0, i));\\n            }\\n        }\\n        String min = beginWithStartChar.get(0);\\n        for(String strBeginWithStartChar : beginWithStartChar) {\\n            if(strBeginWithStartChar.compareTo(min) < 0) min = strBeginWithStartChar;\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3420578,
                "title": "java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k>1){  \\n            char ch[]=s.toCharArray();  \\n            Arrays.sort(ch);\\n            return String.valueOf(ch);\\n        }\\n        else{ \\n            String str2=new String(s);\\n            for(int i=0;i<s.length();i++){\\n                s=s.substring(1)+s.charAt(0); \\n                if(str2.compareTo(s)>0){        \\n                    str2=s;                     \\n                } \\n            }\\n            return str2;\\n        }     \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k>1){  \\n            char ch[]=s.toCharArray();  \\n            Arrays.sort(ch);\\n            return String.valueOf(ch);\\n        }\\n        else{ \\n            String str2=new String(s);\\n            for(int i=0;i<s.length();i++){\\n                s=s.substring(1)+s.charAt(0); \\n                if(str2.compareTo(s)>0){        \\n                    str2=s;                     \\n                } \\n            }\\n            return str2;\\n        }     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3307594,
                "title": "easy-solution-explanation-c-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst thought that comes in mind is that you should append letters such that we attain string closest to sorted string.\\nAnd if we see that for k = 1 we can only rotate whole string but for k > 1 we can do other things and change its order of letters.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n### Case 1 --> k = 1\\n-> we will rotate string and find the smallest string.\\n##### Execution\\n=> append the whole string s, so that it is easy to access rotated elements.\\n=> check for each substring of size n in s for smallest sub string.\\n```\\neg) cbaad -> 0 - index\\n=> cbaadcbaad.\\n=> for i = 2 we have substring aadcb which is smalles substring.\\n=> it can be obtained by appending b and then c.\\n```\\n\\n### Case 2 --> k > 1\\n-> we can change order of adjacent letters by using first 2 letters as a buffer.\\n-> fix the first letter\\n-> rotate string from i = 1. (0 - index string s)\\n-> rotate till adjacent letter is not at the last position.\\n-> when adjacent letter is at the last position we have order of adjacent letters reversed.\\n-> similarly we can just sort the string.\\n##### Execution\\n=> sort the string\\n```\\neg) cbaad\\n=> fix c and rotate from b.\\n=> finally obtain => cdaab.\\n=> rotate => bcdaa. (order changed => cb -> bc)\\n```\\n# Complexity\\n- Time complexity:- O(n log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        int n = s.size();\\n        string sorted = s;\\n        sort(sorted.begin(), sorted.end());\\n        if(k > 1)\\n        {\\n            return sorted;\\n        }\\n        string ans = s;\\n        s += s;\\n        for(int i = 0; i < n; i ++)\\n        {\\n            ans = min(ans, s.substr(i, n));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\neg) cbaad -> 0 - index\\n=> cbaadcbaad.\\n=> for i = 2 we have substring aadcb which is smalles substring.\\n=> it can be obtained by appending b and then c.\\n```\n```\\neg) cbaad\\n=> fix c and rotate from b.\\n=> finally obtain => cdaab.\\n=> rotate => bcdaa. (order changed => cb -> bc)\\n```\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        int n = s.size();\\n        string sorted = s;\\n        sort(sorted.begin(), sorted.end());\\n        if(k > 1)\\n        {\\n            return sorted;\\n        }\\n        string ans = s;\\n        s += s;\\n        for(int i = 0; i < n; i ++)\\n        {\\n            ans = min(ans, s.substr(i, n));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2987218,
                "title": "easy-c-solution-beats-92-online-submissions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMath Problem\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSorting\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*log(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k > 1){\\n            sort(s.begin(),s.end());\\n            return s;\\n        }\\n\\n        string ans = s;\\n\\n        for(int i = 0;i < s.length();i++){\\n            s = s.substr(1,s.length()-1) + s.substr(0,1);\\n            cout<<s<<endl;\\n            ans = min(ans,s);\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "String",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k > 1){\\n            sort(s.begin(),s.end());\\n            return s;\\n        }\\n\\n        string ans = s;\\n\\n        for(int i = 0;i < s.length();i++){\\n            s = s.substr(1,s.length()-1) + s.substr(0,1);\\n            cout<<s<<endl;\\n            ans = min(ans,s);\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2812777,
                "title": "python-easy-solution-expalined",
                "content": "```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k>1:\\n            return \\'\\'.join(sorted(s))\\n        n=len(s)\\n        t=s*2 # t=cbacba\\n        ans=s # ans=cba\\n        for i in range(1,n):\\n            s1=t[i:i+n]          # 1st move : s1=t[1:1+3] = bac\\n            ans=min(ans,s1)      # 2nd move : s1=t[2:2+3] = acb\\n        return ans\\n```\\n\\n**Upvote if you like the solution or ask if there is any query**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k>1:\\n            return \\'\\'.join(sorted(s))\\n        n=len(s)\\n        t=s*2 # t=cbacba\\n        ans=s # ans=cba\\n        for i in range(1,n):\\n            s1=t[i:i+n]          # 1st move : s1=t[1:1+3] = bac\\n            ans=min(ans,s1)      # 2nd move : s1=t[2:2+3] = acb\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793378,
                "title": "java-easiest-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String orderlyQueue(String S, int K) {\\n        if (K > 1) {\\n            char S2[] = S.toCharArray();\\n            Arrays.sort(S2);\\n            return new String(S2);\\n        }\\n        String res = S;\\n        for (int i = 1; i < S.length(); i++) {\\n            String tmp = S.substring(i) + S.substring(0, i);\\n            if (res.compareTo(tmp) > 0) res = tmp;\\n        }\\n        return res; \\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String orderlyQueue(String S, int K) {\\n        if (K > 1) {\\n            char S2[] = S.toCharArray();\\n            Arrays.sort(S2);\\n            return new String(S2);\\n        }\\n        String res = S;\\n        for (int i = 1; i < S.length(); i++) {\\n            String tmp = S.substring(i) + S.substring(0, i);\\n            if (res.compareTo(tmp) > 0) res = tmp;\\n        }\\n        return res; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788451,
                "title": "cpp-solution-o-n-2-simple-approach",
                "content": "Well if you observe carefully if k > 1 let\\'s say 2\\nIt\\'s somthing like selection sort let\\'s see one example\\n\\nwe will compare first n-i elements and find minimum element and at last append it at the end rest of the string will remain same!\\nand do same for i 0 to n - 1\\n\\nlet\\'s try one example\\n\\ns = \"fedcba\" \\ni = 0 : s =  \"fedcba\" : found a as minimum from f to a or index 0 to 5 stored it at first pos and append it at the end\\ni = 1 : s = \"fedcab\"  : found b as minimum from f to b or index 0 to 4 \\ni = 2 : s = \"fedabc\"  : found c as minimum from f to a or index 0 to 3\\ni = 3 : s = \"feabcd\"  : found d as minimum from f to a or index 0 to 2 \\ni = 4 : s = \"fabcde\"  : found e as minimum from f to a or index 0 to 1 \\ni = 5 : s = \"abcdef\"  : found f as minimum from f to a or index 0 to 0 \\n\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k > 1) {\\n            sort(s.begin(), s.end());\\n            return s;\\n        }\\n        \\n        s += s;\\n        string res = s;\\n        for(int i = 0; i < (int)s.size()/2; i++) {\\n            string t = s.substr(i, (int)s.size()/2);\\n            if(t < res) res = t;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k > 1) {\\n            sort(s.begin(), s.end());\\n            return s;\\n        }\\n        \\n        s += s;\\n        string res = s;\\n        for(int i = 0; i < (int)s.size()/2; i++) {\\n            string t = s.substr(i, (int)s.size()/2);\\n            if(t < res) res = t;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2786295,
                "title": "java-clean-and-simple",
                "content": "### **Please Upvote** :D\\n```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if (k == 1) {\\n            String ans = s;\\n\\n            for (int i = 0; i < s.length(); i++) {\\n                String reordered = s.substring(i) + s.substring(0, i);\\n                if (ans.compareTo(reordered) > 0) {\\n                    ans = reordered;\\n                }\\n            }\\n\\n            return ans;\\n        }\\n\\n        char[] arr = s.toCharArray();\\n        Arrays.sort(arr);\\n        return new String(arr);\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if (k == 1) {\\n            String ans = s;\\n\\n            for (int i = 0; i < s.length(); i++) {\\n                String reordered = s.substring(i) + s.substring(0, i);\\n                if (ans.compareTo(reordered) > 0) {\\n                    ans = reordered;\\n                }\\n            }\\n\\n            return ans;\\n        }\\n\\n        char[] arr = s.toCharArray();\\n        Arrays.sort(arr);\\n        return new String(arr);\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2786172,
                "title": "sorting-c",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        string ans;\\n        if(k>1){ \\n            sort(s.begin(),s.end());\\n            ans = s;\\n        }else{\\n            int n = s.size();\\n            ans = s;\\n            s+=s;\\n            for(int i=1; i<n;i++){\\n                ans = min(ans,s.substr(i, n));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        string ans;\\n        if(k>1){ \\n            sort(s.begin(),s.end());\\n            ans = s;\\n        }else{\\n            int n = s.size();\\n            ans = s;\\n            s+=s;\\n            for(int i=1; i<n;i++){\\n                ans = min(ans,s.substr(i, n));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2786003,
                "title": "hard-easy-solution-c",
                "content": "# Intuition\\nif value of k>1, we can always find the sorted string.\\n\\n# Approach\\nif k>1, we can just sort the string and return it.\\notherwise, we can append every ith char of s to end and find smallest string.\\n\\n# Complexity\\n- Time complexity:\\n- O(nlogn)\\n\\n- Space complexity:\\n- O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        //if k>1 , sort the string \\n        if(k>1){\\n            sort(s.begin(),s.end()); \\n            return s;\\n        }\\n        string ans=s;\\n        int len=s.length();\\n        for(int i=0;i<len;i++)\\n        {\\n            s+=s[i]; //append char to the end\\n            string str=s.substr(i+1);\\n            if(str<ans) ans=str;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        //if k>1 , sort the string \\n        if(k>1){\\n            sort(s.begin(),s.end()); \\n            return s;\\n        }\\n        string ans=s;\\n        int len=s.length();\\n        for(int i=0;i<len;i++)\\n        {\\n            s+=s[i]; //append char to the end\\n            string str=s.substr(i+1);\\n            if(str<ans) ans=str;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785682,
                "title": "python-easy-solution",
                "content": "Please star and upvote if you liked the solution\\n```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k>1:\\n            return \"\".join(sorted(s))\\n        ans,l=s,len(s)\\n        for i in range(l):\\n            s=s[1:]+s[0]\\n            ans=min(ans,s)\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k>1:\\n            return \"\".join(sorted(s))\\n        ans,l=s,len(s)\\n        for i in range(l):\\n            s=s[1:]+s[0]\\n            ans=min(ans,s)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785600,
                "title": "c-doubly-linked-list",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if (k == 1)\\n        {\\n            deque<char> smallest(s.begin(), s.end());\\n            deque<char> rotate = smallest;\\n\\n            int n = s.size();\\n            while (n > 0)\\n            {\\n                rotate.push_back(rotate.front());\\n                rotate.pop_front();\\n                if (rotate < smallest)\\n                {\\n                    smallest = rotate;\\n                }\\n                n --;\\n            }\\n            return string(smallest.begin(), smallest.end());\\n        }\\n        else\\n        {\\n            sort(s.begin(), s.end());\\n            return s;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if (k == 1)\\n        {\\n            deque<char> smallest(s.begin(), s.end());\\n            deque<char> rotate = smallest;\\n\\n            int n = s.size();\\n            while (n > 0)\\n            {\\n                rotate.push_back(rotate.front());\\n                rotate.pop_front();\\n                if (rotate < smallest)\\n                {\\n                    smallest = rotate;\\n                }\\n                n --;\\n            }\\n            return string(smallest.begin(), smallest.end());\\n        }\\n        else\\n        {\\n            sort(s.begin(), s.end());\\n            return s;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785498,
                "title": "java-solution-3ms-runtime-faster-than-96",
                "content": "```java \\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        String res;\\n        if(k==1){\\n            res=s;\\n            for(int i=0;i<s.length();i++)\\n            {\\n                String temp = s.substring(i,s.length())+s.substring(0,i);\\n                if(temp.compareTo(res)<0)\\n                    res=temp;\\n            }\\n        }\\n        else{\\n            int[] a = new int[26];\\n            \\n            for(int i=0;i<s.length();i++)\\n            {\\n                a[s.charAt(i)-\\'a\\']++;\\n            }\\n            \\n            res=\"\";\\n            for(int i=0;i<a.length;i++)\\n            {\\n                res+=((char)(i+\\'a\\')+\"\").repeat(a[i]);\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "class Solution {\\n    public String orderlyQueue(String s, int k) {\\n        String res;\\n        if(k==1){\\n            res=s;\\n            for(int i=0;i<s.length();i++)\\n            {\\n                String temp = s.substring(i,s.length())+s.substring(0,i);\\n                if(temp.compareTo(res)<0)\\n                    res=temp;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2785302,
                "title": "intuitive-apporach",
                "content": "//here we will be finding the pattern for which we can swap the two character present anywhere \\n if we are ablle to do it then ok simpy sort the array and return \\nif not then we have to apply the greedy way to find the lowest or ascending order arrr\\njust observe the pattern  \\npublic String orderlyQueue(String s, int k) {\\n        char arr[]=s.toCharArray();\\n\\t\\t\\n        if(k>1)\\n        { Arrays.sort(arr);\\n        return String.valueOf(arr);\\n        }\\n        String ans=s;\\n        for(int i=0;i<s.length();i++){\\n            rotate(arr);\\n            int dif=ans.compareTo(String.valueOf(arr));\\n            if(dif>0)\\n                ans=String.valueOf(arr);\\n        }\\n        return ans;\\n    }\\n    public void  rotate(char arr[]){\\n        char temp=arr[0];\\n        for(int i=0;i<arr.length-1;i++){\\n            arr[i]=arr[i+1];\\n        }\\n        arr[arr.length-1]=temp;\\n    }\\n\\t\\n\\t\\n\\tAll thanks to summit sir\\nhttps://www.youtube.com/watch?v=6cODUSGmYD4",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "//here we will be finding the pattern for which we can swap the two character present anywhere \\n if we are ablle to do it then ok simpy sort the array and return \\nif not then we have to apply the greedy way to find the lowest or ascending order arrr\\njust observe the pattern  \\npublic String orderlyQueue(String s, int k) {\\n        char arr[]=s.toCharArray();\\n\\t\\t\\n        if(k>1)\\n        { Arrays.sort(arr);\\n        return String.valueOf(arr);\\n        }\\n        String ans=s;\\n        for(int i=0;i<s.length();i++){\\n            rotate(arr);\\n            int dif=ans.compareTo(String.valueOf(arr));\\n            if(dif>0)\\n                ans=String.valueOf(arr);\\n        }\\n        return ans;\\n    }\\n    public void  rotate(char arr[]){\\n        char temp=arr[0];\\n        for(int i=0;i<arr.length-1;i++){\\n            arr[i]=arr[i+1];\\n        }\\n        arr[arr.length-1]=temp;\\n    }\\n\\t\\n\\t\\n\\tAll thanks to summit sir\\nhttps://www.youtube.com/watch?v=6cODUSGmYD4",
                "codeTag": "Unknown"
            },
            {
                "id": 2785198,
                "title": "cp-c-small-and-consize-solution",
                "content": "\\t\\tstring orderlyQueue(string s, int k) {\\n\\t\\t\\tif (k == 1) {\\n            string ans = s;\\n            s += s;\\n            for (int i = 1; i < size(ans); ++i)\\n                ans = min(ans, s.substr(i, size(ans)));\\n            return ans;\\n\\t\\t\\t}\\n\\t\\t\\tsort(begin(s), end(s));\\n\\t\\t\\treturn s;\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Orderly Queue.\\nMemory Usage: 8.3 MB, less than 74.71% of C++ online submissions for Orderly Queue.",
                "solutionTags": [
                    "C"
                ],
                "code": "\\t\\tstring orderlyQueue(string s, int k) {\\n\\t\\t\\tif (k == 1) {\\n            string ans = s;\\n            s += s;\\n            for (int i = 1; i < size(ans); ++i)\\n                ans = min(ans, s.substr(i, size(ans)));\\n            return ans;\\n\\t\\t\\t}\\n\\t\\t\\tsort(begin(s), end(s));\\n\\t\\t\\treturn s;\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Orderly Queue.\\nMemory Usage: 8.3 MB, less than 74.71% of C++ online submissions for Orderly Queue.",
                "codeTag": "Unknown"
            },
            {
                "id": 2785194,
                "title": "c-sort",
                "content": "string orderlyQueue(string s, int k) {\\n\\n\\n         if (k == 1) {\\n            string ans = s;\\n            s += s;\\n            for (int i = 1; i < size(ans); ++i)\\n                ans = min(ans, s.substr(i, size(ans)));return ans;\\n        }\\n        sort(begin(s), end(s));\\n        return s;\\n    }\\n};",
                "solutionTags": [],
                "code": "string orderlyQueue(string s, int k) {\\n\\n\\n         if (k == 1) {\\n            string ans = s;\\n            s += s;\\n            for (int i = 1; i < size(ans); ++i)\\n                ans = min(ans, s.substr(i, size(ans)));return ans;\\n        }\\n        sort(begin(s), end(s));\\n        return s;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2785042,
                "title": "c-sorting-faster-easy-to-understand",
                "content": "* ***Using Sorting***\\n\\n* ***Time Complexity :- O(N * N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string str, int k) {\\n\\n        int n = str.size();\\n\\n        // if k == 1, then check for lexicographically smallest str, after appending starting character to the end\\n\\n        if(k == 1)\\n        {\\n            string ans = str;\\n\\n            for(int i = 0; i < n; i++)\\n            {\\n                string temp = str.substr(i) + str.substr(0, i);\\n\\n                // update ans\\n\\n                if(temp < ans)\\n                {\\n                    ans = temp;\\n                }\\n            }\\n\\n            return ans;\\n        }\\n\\n        // if k > 1, then simply sort the str\\n\\n        sort(str.begin(), str.end());\\n\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string str, int k) {\\n\\n        int n = str.size();\\n\\n        // if k == 1, then check for lexicographically smallest str, after appending starting character to the end\\n\\n        if(k == 1)\\n        {\\n            string ans = str;\\n\\n            for(int i = 0; i < n; i++)\\n            {\\n                string temp = str.substr(i) + str.substr(0, i);\\n\\n                // update ans\\n\\n                if(temp < ans)\\n                {\\n                    ans = temp;\\n                }\\n            }\\n\\n            return ans;\\n        }\\n\\n        // if k > 1, then simply sort the str\\n\\n        sort(str.begin(), str.end());\\n\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784943,
                "title": "a-short-rust-solution-with-100-less-memory-100-less-time",
                "content": "```rust\\nuse std::str::from_utf8_unchecked;\\n\\nimpl Solution {\\n    pub fn orderly_queue(s: String, k: i32) -> String {\\n        let mut s = s.into_bytes();\\n        if k == 1 {\\n            let mut r = s.clone();\\n            for _ in 1..s.len() {\\n                r.rotate_left(1);\\n                if r < s {\\n                    s = r.clone();\\n                }\\n            }\\n        } else {\\n            s.sort_unstable();\\n        }\\n        unsafe { from_utf8_unchecked(&s).to_owned() }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::str::from_utf8_unchecked;\\n\\nimpl Solution {\\n    pub fn orderly_queue(s: String, k: i32) -> String {\\n        let mut s = s.into_bytes();\\n        if k == 1 {\\n            let mut r = s.clone();\\n            for _ in 1..s.len() {\\n                r.rotate_left(1);\\n                if r < s {\\n                    s = r.clone();\\n                }\\n            }\\n        } else {\\n            s.sort_unstable();\\n        }\\n        unsafe { from_utf8_unchecked(&s).to_owned() }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2784616,
                "title": "simple-solution-beats-97",
                "content": "# Code\\n```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k > 1: return \\'\\'.join(sorted(s))\\n        m = s\\n        for i in range(1, len(s)):\\n            # print(s[i: ]+s[: i])\\n            m = min(m, s[i: ]+s[: i])\\n        return m\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k > 1: return \\'\\'.join(sorted(s))\\n        m = s\\n        for i in range(1, len(s)):\\n            # print(s[i: ]+s[: i])\\n            m = min(m, s[i: ]+s[: i])\\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784578,
                "title": "c-when-k-1-sort-else-check-by-reordering-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n       if(k == 1)\\n       {\\n           int n = s.size();\\n           string doublestring = s+s;\\n           string ans = s;\\n           for(int i=1;i<n;i++){\\n               string str = doublestring.substr(i,n);\\n               if(str < ans)\\n               {\\n                   ans = str;\\n               }\\n           }\\n           return ans;\\n       }\\n        sort(s.begin(),s.end());\\n        return s;\\n    }\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n       if(k == 1)\\n       {\\n           int n = s.size();\\n           string doublestring = s+s;\\n           string ans = s;\\n           for(int i=1;i<n;i++){\\n               string str = doublestring.substr(i,n);\\n               if(str < ans)\\n               {\\n                   ans = str;\\n               }\\n           }\\n           return ans;\\n       }\\n        sort(s.begin(),s.end());\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784536,
                "title": "simple-8ms-c-solution-clean-code",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        string orderlyQueue(string s, int k)\\n        {\\n            string ans = \"\";\\n            if (k > 1)\\n            {\\n                sort(s.begin(), s.end());\\n                return s;\\n            }\\n            int n = s.size();\\n            ans = s;\\n            s += s;\\n            cout << s << endl;\\n            for (int i = 0; i < n; i++)\\n            {\\n                if (s.substr(i, n) < ans)\\n                {\\n                    ans = s.substr(i, n);\\n                    cout << ans << endl;\\n                }\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        string orderlyQueue(string s, int k)\\n        {\\n            string ans = \"\";\\n            if (k > 1)\\n            {\\n                sort(s.begin(), s.end());\\n                return s;\\n            }\\n            int n = s.size();\\n            ans = s;\\n            s += s;\\n            cout << s << endl;\\n            for (int i = 0; i < n; i++)\\n            {\\n                if (s.substr(i, n) < ans)\\n                {\\n                    ans = s.substr(i, n);\\n                    cout << ans << endl;\\n                }\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2784492,
                "title": "python-concise-two-cases-only",
                "content": "```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k == 1:\\n            n = len(s)\\n            ss = s + s\\n            lex_min_str = s\\n            for i in range(n):\\n                lex_min_str = min(lex_min_str, ss[i:i + n])\\n            return lex_min_str\\n        \\n        return \"\".join(sorted(s))\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k == 1:\\n            n = len(s)\\n            ss = s + s\\n            lex_min_str = s\\n            for i in range(n):\\n                lex_min_str = min(lex_min_str, ss[i:i + n])\\n            return lex_min_str\\n        \\n        return \"\".join(sorted(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784425,
                "title": "c-most-easy-solution-using-simple-sorting",
                "content": "if k=1 then only we have to check otherwise for values of k>1 simple soting the string would do this can be checked by taking examples for different values of k for k=1 we have to check and find which resulting string would give us the lexiographically smaleest string.\\n```\\nclass Solution {\\npublic:\\n     string orderlyQueue(string s, int k) {\\n        if(k==1)\\n        {\\n            string prev=s;\\n            string ans=s;\\n            for(int i=0;i<s.size();i++)\\n            {\\n               string temp=s.substr(i,s.size()-i)+s.substr(0,i);\\n                if(temp<prev)// we check by putting every character in front and therby\\n\\t\\t\\t\\t//seeing that which resuting string gives us the lexicographically most smallest string\\n                {\\n                    ans=temp;\\n                    prev=temp;\\n                }\\n            }\\n            return ans;\\n        }\\n       sort(s.begin(),s.end());\\n         return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     string orderlyQueue(string s, int k) {\\n        if(k==1)\\n        {\\n            string prev=s;\\n            string ans=s;\\n            for(int i=0;i<s.size();i++)\\n            {\\n               string temp=s.substr(i,s.size()-i)+s.substr(0,i);\\n                if(temp<prev)// we check by putting every character in front and therby\\n\\t\\t\\t\\t//seeing that which resuting string gives us the lexicographically most smallest string\\n                {\\n                    ans=temp;\\n                    prev=temp;\\n                }\\n            }\\n            return ans;\\n        }\\n       sort(s.begin(),s.end());\\n         return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784289,
                "title": "c-easy-approach-fast-solution-0ms",
                "content": "Approach\\nif K==0 then simply return that string.\\nif K>1 sort the string and return that string.\\nif K==1 finds all such combinations and return lexicographically the smallest string.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k==0)return s;  // for  k==0 simply return the string back.\\n        if(k>1)           //  for  k>1 sort the string and return ans\\n        {\\n            sort(s.begin(),s.end());\\n            return s;\\n        }\\n        if(k == 1){    // for(k==1)  find all the smallest string \\n            string ans = s;\\n            for(int i=0;i<s.length();i++){\\n                s = s.substr(1) + s[0];\\n                ans = min(s,ans);\\n            }\\n            return ans;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k==0)return s;  // for  k==0 simply return the string back.\\n        if(k>1)           //  for  k>1 sort the string and return ans\\n        {\\n            sort(s.begin(),s.end());\\n            return s;\\n        }\\n        if(k == 1){    // for(k==1)  find all the smallest string \\n            string ans = s;\\n            for(int i=0;i<s.length();i++){\\n                s = s.substr(1) + s[0];\\n                ans = min(s,ans);\\n            }\\n            return ans;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784145,
                "title": "javascript-solution-easy-approach",
                "content": "# Code\\n```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {string}\\n */\\nvar orderlyQueue = function(S, K) {\\n    if( K > 1) {\\n        return S.split(\\'\\').sort().join(\\'\\');\\n    } else {\\n    \\tlet small = S.split(\\'\\').sort()[0];\\n    \\tlet newQueue = [];\\n    \\tfor(let i=0; i<S.length; i++){\\n    \\t\\tif(S[i]===small) {\\n                newQueue.push(S.slice(i)+S.slice(0,i));\\n            }\\n    \\t}\\n    \\treturn newQueue.sort()[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {string}\\n */\\nvar orderlyQueue = function(S, K) {\\n    if( K > 1) {\\n        return S.split(\\'\\').sort().join(\\'\\');\\n    } else {\\n    \\tlet small = S.split(\\'\\').sort()[0];\\n    \\tlet newQueue = [];\\n    \\tfor(let i=0; i<S.length; i++){\\n    \\t\\tif(S[i]===small) {\\n                newQueue.push(S.slice(i)+S.slice(0,i));\\n            }\\n    \\t}\\n    \\treturn newQueue.sort()[0];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2784103,
                "title": "most-easy-c-solution-beginner-friendly-very-easy-to-understand",
                "content": "**Please Upvote if you find the solution helpful**\\n\\nclass Solution {\\npublic:\\n\\n    string orderlyQueue(string s, int k) {\\n        if(k == 1) {                            // for k == 1 we have to check \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// for each and every possible rotation.\\n            string str = s;\\n            for(int i = 0 ; i  <s.size() ;++i){\\n                char t = s[0];\\n                for(int j = 0  ; j <s.size()-1 ;++j){\\n                    s[j] = s[j+1];\\n                }\\n                s[s.size()-1] = t;\\n                str = min(str,s);\\n            }\\n            return str;\\n        } \\n        sort(s.begin(),s.end());            // For k > 1 we can simply sort the array as we will be able to get \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//  most smalllest Lexicographically smallest string.\\n        return s;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n\\n    string orderlyQueue(string s, int k) {\\n        if(k == 1) {                            // for k == 1 we have to check \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// for each and every possible rotation.\\n            string str = s;\\n            for(int i = 0 ; i  <s.size() ;++i){\\n                char t = s[0];\\n                for(int j = 0  ; j <s.size()-1 ;++j){\\n                    s[j] = s[j+1];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2783754,
                "title": "python-simple-python-solution-using-sorting",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 61 ms, faster than 53.57% of Python3 online submissions for Orderly Queue.\\n# Memory Usage: 14 MB, less than 14.29% of Python3 online submissions for Orderly Queue.\\n\\tclass Solution:\\n\\t\\tdef orderlyQueue(self, s: str, k: int) -> str:\\n\\n\\t\\t\\tnew_s = s\\n\\n\\t\\t\\tif k == 1:\\n\\t\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\t\\ts = s[1:]+s[0]\\n\\t\\t\\t\\t\\tnew_s = min(new_s, s) \\n\\t\\t\\telse:\\n\\t\\t\\t\\tnew_s = sorted(list(s))\\n\\n\\t\\t\\tresult = \\'\\'.join(new_s)\\n\\n\\t\\t\\treturn result\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 61 ms, faster than 53.57% of Python3 online submissions for Orderly Queue.\\n# Memory Usage: 14 MB, less than 14.29% of Python3 online submissions for Orderly Queue.\\n\\tclass Solution:\\n\\t\\tdef orderlyQueue(self, s: str, k: int) -> str:\\n\\n\\t\\t\\tnew_s = s\\n\\n\\t\\t\\tif k == 1:\\n\\t\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\t\\ts = s[1:]+s[0]\\n\\t\\t\\t\\t\\tnew_s = min(new_s, s) \\n\\t\\t\\telse:\\n\\t\\t\\t\\tnew_s = sorted(list(s))\\n\\n\\t\\t\\tresult = \\'\\'.join(new_s)\\n\\n\\t\\t\\treturn result\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 2783633,
                "title": "rust-0ms-solution",
                "content": "Rust [0ms](https://leetcode.com/submissions/detail/837833448/) Solution:\\n```rust\\nimpl Solution {\\n    pub fn orderly_queue(s: String, k: i32) -> String {\\n        let mut s: Vec<char> = s.chars().collect();\\n        if k > 1 {\\n            s.sort_unstable();\\n            return s.iter().collect::<String>();\\n        }\\n        let mut min = s.clone();\\n        for _ in 0..s.len() {\\n            s.rotate_left(1);\\n            if s < min {\\n                min = s.clone();\\n            }\\n        }\\n        min.iter().collect::<String>()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Sorting"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn orderly_queue(s: String, k: i32) -> String {\\n        let mut s: Vec<char> = s.chars().collect();\\n        if k > 1 {\\n            s.sort_unstable();\\n            return s.iter().collect::<String>();\\n        }\\n        let mut min = s.clone();\\n        for _ in 0..s.len() {\\n            s.rotate_left(1);\\n            if s < min {\\n                min = s.clone();\\n            }\\n        }\\n        min.iter().collect::<String>()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2783577,
                "title": "c-short-clean-code-with-detailed-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf the value of k>1, no matter what the string is, it is possible to sort the entire string and return it.\\nLet\\'s say, for eg:\\n```\\nString: baaca k=2\\n```\\nWe can make the following transitions:\\n```\\nbacaa\\nbcaaa\\ncaaab\\naaabc\\n```\\nThus if k>1, just sort the string and return it.\\nOtherwise, if k=1, send each character one by one, at the end of the string and check if the resultant string formed is lexicographically smallest string or not.\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k>1)\\n        {\\n            sort(s.begin(), s.end());\\n            return s;\\n        }\\n        string str=s;\\n        for(int i=0;i<s.length();i++)\\n            str=min(str, s.substr(i)+s.substr(0,i));\\n        return str;\\n    }\\n};\\n```\\n**PLEASE UPVOTE IF IT HELPS!!!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nString: baaca k=2\\n```\n```\\nbacaa\\nbcaaa\\ncaaab\\naaabc\\n```\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k>1)\\n        {\\n            sort(s.begin(), s.end());\\n            return s;\\n        }\\n        string str=s;\\n        for(int i=0;i<s.length();i++)\\n            str=min(str, s.substr(i)+s.substr(0,i));\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783456,
                "title": "c-clean-code-easiest-to-understand",
                "content": "The only caviat is when k==1,else we can simply sort the string and return the particular string.\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n       if(k==1){\\n           string ok=s;\\n           for(int i=0;i<s.length();i++){\\n               string temp=s.substr(i)+s.substr(0,i);\\n               if(temp.compare(ok)<0){\\n                   ok=temp;\\n               }\\n           }\\n           return ok;\\n       }\\n        else{\\n            sort(s.begin(),s.end());\\n            return s;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n       if(k==1){\\n           string ok=s;\\n           for(int i=0;i<s.length();i++){\\n               string temp=s.substr(i)+s.substr(0,i);\\n               if(temp.compare(ok)<0){\\n                   ok=temp;\\n               }\\n           }\\n           return ok;\\n       }\\n        else{\\n            sort(s.begin(),s.end());\\n            return s;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783436,
                "title": "c-sorting-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k==1)\\n        {\\n            string res=s;\\n            for(int i=0;i<s.length();i++)\\n            {\\n               string t=\"\";\\n               t+=s[s.length()-1];\\n               s.pop_back();\\n               t+=s;\\n               if(t<res)\\n                   res=t;\\n               s=t;\\n            }\\n            return res;\\n        }\\n        sort(s.begin(),s.end());\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k==1)\\n        {\\n            string res=s;\\n            for(int i=0;i<s.length();i++)\\n            {\\n               string t=\"\";\\n               t+=s[s.length()-1];\\n               s.pop_back();\\n               t+=s;\\n               if(t<res)\\n                   res=t;\\n               s=t;\\n            }\\n            return res;\\n        }\\n        sort(s.begin(),s.end());\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782906,
                "title": "c-simple-solution-efficient-string-handling-reduced-rotations",
                "content": "When k>1 we can just completely sort the string since we can effectively swap any two characters. \\xA0 By choosing other characters until both characters to be swapped are at the top.  Then we choose the second and then the first which will put them at the bottom but swapped in order. If you can swap any two characters, then you can sort. \\xA0Here is a sequence to swap two arbitrary characters in a string X and Y in the K=2 When i state \\'move abcd\\' it means move a then b then c then d from the front 2 to back\\n\\n1) move the characters abcd to the end to bring Y to the start.\\n2) move efg to bring X to second position.\\n3) move Y\\n4) move abcd\\n5) move X\\n6) move efgY\\n\\nabcdYefgX -> YefgXabcd -> YXabcdefg -> XabcdefgY -> XefgYabcd -> efgYabcdX -> abcdXefgY\\n\\nFor k==1, we ned to find the the lowest string we can get from rotation.  Rather than rotating though every combination, we can concentrate on strings that begin with the lowest char avalable in the string using min_element and find_if.  We should consider a string when the lowest character found is the same or less than the first character of the current string.\\n\\nWe can use string_view to avoid actually forming these strings to compare the current to the propsoed string.  If the new prefix is lower, it is a lower string, If it is the same, we need to compare the new proposed suffix to the beginning of the current string, since that will be the suffix of the new string.\\n\\nFor instance, consider:  `\"abcdefabc\"`\\nThe only character we need to consider is the second \\'a\\'.  However, the prefix will be `\"abc\"` for both the original string and proposed string.  But we can compare `\"defabc\"` to `\"abcdef\"` to see that we should choose the proposed string. ` \"abcdefabc\" > \"abcabcdef\"`\\n\\nWhen a new string is accepted as lower, we calculate a new value for en so that we don\\'t go past the end of the original string when comparing.\\n\\n    string orderlyQueue(string s, int k) {\\n        int N = s.size();\\n        if(k!=1) {\\n            sort(begin(s),end(s));\\n        } else\\n        {\\n            auto it = begin(s);\\n            auto en = end(s);\\n            auto it2 = min_element(it+1,en);            \\n            while(it2!=en && *it2<=*it)\\n            {\\n                int len = N- (it2 - begin(s));\\n                // &*it2 is a hack since the iterator version of the \\n                // C++20 string_view constructor is not supported on this platform\\n                string_view curprefix(&*it, len), cursuffix(&*(it+len),N-len),\\n                            newprefix(&*it2,len), newsuffix(&*it, N-len);\\n                //cout << curprefix << cursuffix << endl;\\n                //cout << newprefix << newsuffix << endl;\\n                if(tie(newprefix,newsuffix) < tie(curprefix,cursuffix))\\n                {\\n                    rotate(begin(s),it2,end(s));\\n                    it = begin(s);\\n                    it2 = it+1;\\n                    en = it+len;\\n                } else it2++;\\n                it2 = find_if(it2,en,[it](char a){return a<=*it;});\\n            } \\n        }\\n        return s;\\n    }\\n\\t\\nAs others have pointed out, there is an O(N) solution to solving the k==1 part of the problem.  It is called [Booth\\'s Algorithm](https://en.wikipedia.org/wiki/Lexicographically_minimal_string_rotation).\\n\\nHere is an implementation if you want to try it.  It runs in O(N) time but requires O(N) space for the failure function results to be stored.\\n\\n            vector<int> f(N*2,-1);\\n            int k=0;\\n            for(int j=1;j<N*2;j++) {\\n                char sj = s[j%N];\\n                int i = f[j-k-1];\\n                while(i!=-1 && sj != s[(k+i+1)%N]) {\\n                    if(sj < s[(k+i+1)%N]) k = j-i-1;\\n                    i = f[i];\\n                }\\n                if(i==-1 && sj != s[(k+i+1)%N])\\n                {\\n                    if(sj < s[(k+i+1)%N]) k = j;\\n                    f[j-k] = -1;\\n                } else {\\n                    f[j-k] = i+1;\\n                }\\n            }\\n            rotate(begin(s),begin(s)+k,end(s));",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "When k>1 we can just completely sort the string since we can effectively swap any two characters. \\xA0 By choosing other characters until both characters to be swapped are at the top.  Then we choose the second and then the first which will put them at the bottom but swapped in order. If you can swap any two characters, then you can sort. \\xA0Here is a sequence to swap two arbitrary characters in a string X and Y in the K=2 When i state \\'move abcd\\' it means move a then b then c then d from the front 2 to back\\n\\n1) move the characters abcd to the end to bring Y to the start.\\n2) move efg to bring X to second position.\\n3) move Y\\n4) move abcd\\n5) move X\\n6) move efgY\\n\\nabcdYefgX -> YefgXabcd -> YXabcdefg -> XabcdefgY -> XefgYabcd -> efgYabcdX -> abcdXefgY\\n\\nFor k==1, we ned to find the the lowest string we can get from rotation.  Rather than rotating though every combination, we can concentrate on strings that begin with the lowest char avalable in the string using min_element and find_if.  We should consider a string when the lowest character found is the same or less than the first character of the current string.\\n\\nWe can use string_view to avoid actually forming these strings to compare the current to the propsoed string.  If the new prefix is lower, it is a lower string, If it is the same, we need to compare the new proposed suffix to the beginning of the current string, since that will be the suffix of the new string.\\n\\nFor instance, consider:  `\"abcdefabc\"`\\nThe only character we need to consider is the second \\'a\\'.  However, the prefix will be `\"abc\"` for both the original string and proposed string.  But we can compare `\"defabc\"` to `\"abcdef\"` to see that we should choose the proposed string. ` \"abcdefabc\" > \"abcabcdef\"`\\n\\nWhen a new string is accepted as lower, we calculate a new value for en so that we don\\'t go past the end of the original string when comparing.\\n\\n    string orderlyQueue(string s, int k) {\\n        int N = s.size();\\n        if(k!=1) {\\n            sort(begin(s),end(s));\\n        } else\\n        {\\n            auto it = begin(s);\\n            auto en = end(s);\\n            auto it2 = min_element(it+1,en);            \\n            while(it2!=en && *it2<=*it)\\n            {\\n                int len = N- (it2 - begin(s));\\n                // &*it2 is a hack since the iterator version of the \\n                // C++20 string_view constructor is not supported on this platform\\n                string_view curprefix(&*it, len), cursuffix(&*(it+len),N-len),\\n                            newprefix(&*it2,len), newsuffix(&*it, N-len);\\n                //cout << curprefix << cursuffix << endl;\\n                //cout << newprefix << newsuffix << endl;\\n                if(tie(newprefix,newsuffix) < tie(curprefix,cursuffix))\\n                {\\n                    rotate(begin(s),it2,end(s));\\n                    it = begin(s);\\n                    it2 = it+1;\\n                    en = it+len;\\n                } else it2++;\\n                it2 = find_if(it2,en,[it](char a){return a<=*it;});\\n            } \\n        }\\n        return s;\\n    }\\n\\t\\nAs others have pointed out, there is an O(N) solution to solving the k==1 part of the problem.  It is called [Booth\\'s Algorithm](https://en.wikipedia.org/wiki/Lexicographically_minimal_string_rotation).\\n\\nHere is an implementation if you want to try it.  It runs in O(N) time but requires O(N) space for the failure function results to be stored.\\n\\n            vector<int> f(N*2,-1);\\n            int k=0;\\n            for(int j=1;j<N*2;j++) {\\n                char sj = s[j%N];\\n                int i = f[j-k-1];\\n                while(i!=-1 && sj != s[(k+i+1)%N]) {\\n                    if(sj < s[(k+i+1)%N]) k = j-i-1;\\n                    i = f[i];\\n                }\\n                if(i==-1 && sj != s[(k+i+1)%N])\\n                {\\n                    if(sj < s[(k+i+1)%N]) k = j;\\n                    f[j-k] = -1;\\n                } else {\\n                    f[j-k] = i+1;\\n                }\\n            }\\n            rotate(begin(s),begin(s)+k,end(s));",
                "codeTag": "C++"
            },
            {
                "id": 2782878,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n * n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the string `s`\\n */\\nclass Solution {\\n public:\\n  string orderlyQueue(string &s, const int k) {\\n    if (k > 1) {\\n      sort(s.begin(), s.end());\\n      return s;\\n    }\\n\\n    const int n = static_cast<int>(s.size());\\n    char min_letter = numeric_limits<char>::max();\\n    vector<int> min_letter_indices;\\n    for (int i = 0; i < n; ++i) {\\n      if (s[i] < min_letter) {\\n        min_letter = s[i];\\n        min_letter_indices.clear();\\n      }\\n      if (s[i] <= min_letter) {\\n        min_letter_indices.emplace_back(i);\\n      }\\n    }\\n\\n    string ret;\\n    for (const int separator_index : min_letter_indices) {\\n      const string candidate = s.substr(separator_index) + s.substr(0, separator_index);\\n      if (ret.empty() || candidate < ret) {\\n        ret = move(candidate);\\n      }\\n    }\\n    return ret;\\n  }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Time Complexity: O(n * n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the string `s`\\n */\\nclass Solution {\\n public:\\n  string orderlyQueue(string &s, const int k) {\\n    if (k > 1) {\\n      sort(s.begin(), s.end());\\n      return s;\\n    }\\n\\n    const int n = static_cast<int>(s.size());\\n    char min_letter = numeric_limits<char>::max();\\n    vector<int> min_letter_indices;\\n    for (int i = 0; i < n; ++i) {\\n      if (s[i] < min_letter) {\\n        min_letter = s[i];\\n        min_letter_indices.clear();\\n      }\\n      if (s[i] <= min_letter) {\\n        min_letter_indices.emplace_back(i);\\n      }\\n    }\\n\\n    string ret;\\n    for (const int separator_index : min_letter_indices) {\\n      const string candidate = s.substr(separator_index) + s.substr(0, separator_index);\\n      if (ret.empty() || candidate < ret) {\\n        ret = move(candidate);\\n      }\\n    }\\n    return ret;\\n  }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782847,
                "title": "this-is-not-a-hard-problem-no-ds-or-algorithm-applied",
                "content": "# Intuition\\nI posted this so that you don\\'t waste time, as I did behind this problem using heapq or any fancy algorithm.\\n\\n# Approach\\nJust return sorted string if k > 1: yes, they should remove \"hard\" badge!\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k == 1:\\n            ans = s\\n            for _ in range(len(s)):\\n                s = s[1:] + s[0]\\n                ans = min(ans, s)\\n            return ans\\n        else:\\n            return \\'\\'.join(sorted(s))\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k == 1:\\n            ans = s\\n            for _ in range(len(s)):\\n                s = s[1:] + s[0]\\n                ans = min(ans, s)\\n            return ans\\n        else:\\n            return \\'\\'.join(sorted(s))\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782838,
                "title": "javascript-solution-easiest-o-n-2-time-o-n-space",
                "content": "```\\nconst orderlyQueue = function(s, k) {\\n    if(k > 1) return s.split(\"\").sort().join(\"\");\\n    let res = s;\\n    const n = s.length;\\n    \\n    for(let i = 0; i < n; i++) {\\n        s = s.slice(1) + s[0];\\n        res = res.localeCompare(s) < 0? res:s;\\n    }\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Queue"
                ],
                "code": "```\\nconst orderlyQueue = function(s, k) {\\n    if(k > 1) return s.split(\"\").sort().join(\"\");\\n    let res = s;\\n    const n = s.length;\\n    \\n    for(let i = 0; i < n; i++) {\\n        s = s.slice(1) + s[0];\\n        res = res.localeCompare(s) < 0? res:s;\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2782831,
                "title": "c-simple-solution",
                "content": "It can be observed that for k > 1, we can always sort s such that it\\'s the lexographically smallest string. All that\\'s left to do is to consider k == 1 where we just rotate string and find the smallest one. \\n\\n\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if (k == 1) {\\n            string best = s;\\n            for (int i = 0; i < s.size(); i++) {\\n                s = s.substr(1, s.size() - 1) + s[0];\\n                best = min(s, best);\\n            }\\n            return best;\\n        }\\n        sort(s.begin(), s.end());\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if (k == 1) {\\n            string best = s;\\n            for (int i = 0; i < s.size(); i++) {\\n                s = s.substr(1, s.size() - 1) + s[0];\\n                best = min(s, best);\\n            }\\n            return best;\\n        }\\n        sort(s.begin(), s.end());\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782819,
                "title": "o-nlogn-with-buble-sorting-style-examples",
                "content": "**Main Idea**:\\n+ k=1: there is only a rotation:\\n  [1] rotate the whole string:\\n```\\n1|2345 -> 2345|1  -> 345|12 -> 45|123 -> 5|1234\\n```\\n+ k>1: there are two string rotations:\\n   [1] rotate the whole string\\n   [2] rotate the whole string except the first letter\\n\\nWe can move the next min value a[k] to first place and keep the minimum interval (a[0], a[1], ..., a[k-1]) using the rotation [1]\\n```\\n......a[k].....(a[0],a[1],...,a[k-1]) -> rotation [1] -> a[k]....(a[0],a[1],...,a[k-1])...\\n```\\nAfter that, we can apply the roration [2] to move the minimum interval (a[0], a[1], ..., a[k-1]) to last place.\\n```\\na[k]....(a[0],a[1],...,a[k-1])... -> rotation [2] -> a[k]....(a[0],a[1],...,a[k-1])\\n```\\nFinally, we move a[k] to last place.\\n```\\na[k]....(a[0],a[1],...,a[k-1]) -> rotation [1] -> ....(a[0],a[1],...,a[k-1], a[k])\\n```\\nFrom there, we receive a sorted string from the original string using bubble sort technique as above explaination.\\n\\n**Examples**:\\n```\\nExample 1: s=\"361524\", k=1\\nans = 152436\\n\\nExample 2: s=\"361524\", k>1\\n[1]52436\\n52436<1>\\n\\n[2]436<1>5\\n[2]5436<1>\\n5436<12>\\n\\n[3]6<12>54\\n[3]546<12>\\n546<123>\\n\\n[4]6<123>5\\n[4]56<123>\\n56<1234>\\n\\n[5]6<1234>\\n6<12345>\\n\\n[6]<12345>\\n<123456>\\nans = \"123456\"\\n```\\n\\n**Code**:\\n+ C++\\n```C++\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        string ans = s;\\n        if(k>1)\\n            std::sort(ans.begin(), ans.end());\\n        else {\\n            for(int i=0; i<s.size(); i++){\\n                ans = min(ans, s.substr(i) + s.substr(0, i));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n+ Python:\\n```python\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k>1:\\n            ans = \"\".join(sorted(s))\\n        else:\\n            ans = s\\n            for i in range(1, len(s)):\\n                ans = min(ans, s[i:] + s[:i])\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Sorting"
                ],
                "code": "```\\n1|2345 -> 2345|1  -> 345|12 -> 45|123 -> 5|1234\\n```\n```\\n......a[k].....(a[0],a[1],...,a[k-1]) -> rotation [1] -> a[k]....(a[0],a[1],...,a[k-1])...\\n```\n```\\na[k]....(a[0],a[1],...,a[k-1])... -> rotation [2] -> a[k]....(a[0],a[1],...,a[k-1])\\n```\n```\\na[k]....(a[0],a[1],...,a[k-1]) -> rotation [1] -> ....(a[0],a[1],...,a[k-1], a[k])\\n```\n```\\nExample 1: s=\"361524\", k=1\\nans = 152436\\n\\nExample 2: s=\"361524\", k>1\\n[1]52436\\n52436<1>\\n\\n[2]436<1>5\\n[2]5436<1>\\n5436<12>\\n\\n[3]6<12>54\\n[3]546<12>\\n546<123>\\n\\n[4]6<123>5\\n[4]56<123>\\n56<1234>\\n\\n[5]6<1234>\\n6<12345>\\n\\n[6]<12345>\\n<123456>\\nans = \"123456\"\\n```\n```C++\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        string ans = s;\\n        if(k>1)\\n            std::sort(ans.begin(), ans.end());\\n        else {\\n            for(int i=0; i<s.size(); i++){\\n                ans = min(ans, s.substr(i) + s.substr(0, i));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k>1:\\n            ans = \"\".join(sorted(s))\\n        else:\\n            ans = s\\n            for i in range(1, len(s)):\\n                ans = min(ans, s[i:] + s[:i])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782799,
                "title": "java-solution-faster-than-100-of-java-submissions",
                "content": "```\\nclass Solution {\\n    private static String sortString (String s){\\n        char tempArray[] = s.toCharArray();\\n        Arrays.sort(tempArray);\\n        return new String(tempArray);\\n    }\\n    \\n    public String orderlyQueue(String s, int k) {\\n        if (k > 1){\\n            return this.sortString(s);\\n        } \\n        \\n        String minString = s;\\n        String sTwoTimes = s + s;\\n        int len = s.length();\\n        for (int index = 1; index < len; index++){\\n            String temp = sTwoTimes.substring(index, index + len);\\n            if (temp.compareTo(minString) < 0)\\n                minString = temp;\\n        }\\n        return minString;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    private static String sortString (String s){\\n        char tempArray[] = s.toCharArray();\\n        Arrays.sort(tempArray);\\n        return new String(tempArray);\\n    }\\n    \\n    public String orderlyQueue(String s, int k) {\\n        if (k > 1){\\n            return this.sortString(s);\\n        } \\n        \\n        String minString = s;\\n        String sTwoTimes = s + s;\\n        int len = s.length();\\n        for (int index = 1; index < len; index++){\\n            String temp = sTwoTimes.substring(index, index + len);\\n            if (temp.compareTo(minString) < 0)\\n                minString = temp;\\n        }\\n        return minString;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782788,
                "title": "c-tc-o-nlogn-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        int n=s.size();\\n       if(k>1){\\n            string ns;\\n            ns=s;\\n            sort(ns.begin(),ns.end());\\n\\n            return ns;\\n       }\\n        \\n        string ns=s+s;\\n        string temp=s;\\n        for(int i=0;i<n;i++){\\n            string ss=ns.substr(i,n);\\n            if(ss<temp){\\n                temp=ss;\\n            }\\n        }\\n        return temp;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        int n=s.size();\\n       if(k>1){\\n            string ns;\\n            ns=s;\\n            sort(ns.begin(),ns.end());\\n\\n            return ns;\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 2768559,
                "title": "readable-and-fast-scala-single-if-else",
                "content": "```\\n  def orderlyQueue(s: String, k: Int): String = {\\n    if (k == 1) \\n\\t\\t// from all the possible rotations, getting the lexicographical minimum\\n\\t\\t//Example: s+s = cbacba\\n\\t\\t//Sliding collection:\\n\\t\\t//#1 cba\\n\\t\\t//#2 bac \\n\\t\\t//#3 acb //Smallest sliding window string, min will return this\\n\\t\\t//#4 cba //.drop(1) if you wanna save some computation\\n\\t\\t(s + s).sliding(s.length).min \\n\\telse \\n\\t\\ts.sorted\\n  }",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\n  def orderlyQueue(s: String, k: Int): String = {\\n    if (k == 1) \\n\\t\\t// from all the possible rotations, getting the lexicographical minimum\\n\\t\\t//Example: s+s = cbacba\\n\\t\\t//Sliding collection:\\n\\t\\t//#1 cba\\n\\t\\t//#2 bac \\n\\t\\t//#3 acb //Smallest sliding window string, min will return this\\n\\t\\t//#4 cba //.drop(1) if you wanna save some computation\\n\\t\\t(s + s).sliding(s.length).min \\n\\telse \\n\\t\\ts.sorted\\n  }",
                "codeTag": "Python3"
            },
            {
                "id": 2603624,
                "title": "c-using-substr-90-faster-than-all",
                "content": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k>1){\\n            sort(s.begin(), s.end());\\n            return s;\\n        }\\n        else{\\n            int len = s.size();\\n            s = s + s;\\n            int index = 0;\\n            for(int i=0; i<len; i++){\\n                if(s.substr(index, len) > s.substr(i, len)) index = i;\\n            }\\n            return s.substr(index, len);\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k>1){\\n            sort(s.begin(), s.end());\\n            return s;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2596218,
                "title": "python3-sorting-queue-approach-explained-with-example",
                "content": "When k >=2 , then we have the option to stock the smallest character in frontand send the largest character to the end continuosly.\\nThis alows us to create a sorted string after certain number of operations\\nEg: \\n```\\n(az)zzaza and k=2\\n(az)zaza|z\\n(az)aza|zz\\n(aa)za|zzz\\n```\\n\\nWhen k=1, we got option to either send the top of q to the back or stop and no option to stock lexicographically smaller character.\\nHence we need to do brute force and find the smallest character\\n\\n```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        \\n        #is new str smaller than old\\n        def compare(a,b):\\n            for i in range(len(a)):\\n                if a[i]<b[i]:\\n                    return True\\n                elif a[i]>b[i]:\\n                    return False\\n            return False\\n        \\n        if k == 1:\\n            smallest = s\\n            s = deque(s)\\n            \\n            for _ in range(len(s)-1):\\n                s.append(s.popleft())\\n                \\n                if compare(s,smallest):\\n                    smallest = \\'\\'.join(s)\\n                \\n            return smallest\\n        \\n        else:\\n            return \"\".join(sorted(s))\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Sorting"
                ],
                "code": "```\\n(az)zzaza and k=2\\n(az)zaza|z\\n(az)aza|zz\\n(aa)za|zzz\\n```\n```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        \\n        #is new str smaller than old\\n        def compare(a,b):\\n            for i in range(len(a)):\\n                if a[i]<b[i]:\\n                    return True\\n                elif a[i]>b[i]:\\n                    return False\\n            return False\\n        \\n        if k == 1:\\n            smallest = s\\n            s = deque(s)\\n            \\n            for _ in range(len(s)-1):\\n                s.append(s.popleft())\\n                \\n                if compare(s,smallest):\\n                    smallest = \\'\\'.join(s)\\n                \\n            return smallest\\n        \\n        else:\\n            return \"\".join(sorted(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485077,
                "title": "hard-question-with-easy-approach-c-intuition-explained",
                "content": "```\\n  string orderlyQueue(string s, int k) {\\n        \\n        int n=s.size();\\n        \\n        //for k=1 hume har case check krna pdega har kisi ko piche dalke dekho kaunsi sbse choti string bnri\\n        if(k==1)  \\n        {\\n            string ans=\"zzzzzzzzzzzzzzzz\";\\n            for(int idx=0;idx<n;idx++)\\n            {\\n                int i=(idx+1)%n;\\n                string str=\"\";\\n                \\n                while(i!=idx)\\n                {\\n                    str+=s[i];\\n                    i=(i+1)%n;\\n                }\\n                str+=s[i];\\n                ans=min(ans,str);               \\n            }\\n            return ans;\\n        }\\n        \\n//agar ek se zda hai k to hmesha sorted string hi answer hoga INSERTION sort me hum kya krte the 2 adjacent cahracter ko swap krte the . yaha hum 2 adjacent char swap kr skte through some n moves so it is possible to do so.\\n        \\n        sort(s.begin(),s.end());\\n        return s;        \\n    }",
                "solutionTags": [],
                "code": "```\\n  string orderlyQueue(string s, int k) {\\n        \\n        int n=s.size();\\n        \\n        //for k=1 hume har case check krna pdega har kisi ko piche dalke dekho kaunsi sbse choti string bnri\\n        if(k==1)  \\n        {\\n            string ans=\"zzzzzzzzzzzzzzzz\";\\n            for(int idx=0;idx<n;idx++)\\n            {\\n                int i=(idx+1)%n;\\n                string str=\"\";\\n                \\n                while(i!=idx)\\n                {\\n                    str+=s[i];\\n                    i=(i+1)%n;\\n                }\\n                str+=s[i];\\n                ans=min(ans,str);               \\n            }\\n            return ans;\\n        }\\n        \\n//agar ek se zda hai k to hmesha sorted string hi answer hoga INSERTION sort me hum kya krte the 2 adjacent cahracter ko swap krte the . yaha hum 2 adjacent char swap kr skte through some n moves so it is possible to do so.\\n        \\n        sort(s.begin(),s.end());\\n        return s;        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2224276,
                "title": "orderly-queue-string-builder-trick-o-nlogn",
                "content": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k>1){ //for k>1, the result string will always be sorted, it works like adjacent swapping in insertion sort\\n            char []ch=s.toCharArray();\\n            Arrays.sort(ch);\\n            String snew=new String(ch);\\n            return snew;\\n        }\\n        \\n        String ans=s;\\n        StringBuilder sb=new StringBuilder(s);\\n        \\n        for(int i=0;i<s.length();i++){\\n            char ch=sb.charAt(0);\\n            sb.deleteCharAt(0);\\n            sb.append(ch);\\n            String snew=sb.toString();\\n            \\n            if(ans.compareTo(snew)>0){\\n                ans=snew;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k>1){ //for k>1, the result string will always be sorted, it works like adjacent swapping in insertion sort\\n            char []ch=s.toCharArray();\\n            Arrays.sort(ch);\\n            String snew=new String(ch);\\n            return snew;\\n        }\\n        \\n        String ans=s;\\n        StringBuilder sb=new StringBuilder(s);\\n        \\n        for(int i=0;i<s.length();i++){\\n            char ch=sb.charAt(0);\\n            sb.deleteCharAt(0);\\n            sb.append(ch);\\n            String snew=sb.toString();\\n            \\n            if(ans.compareTo(snew)>0){\\n                ans=snew;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446934,
                "title": "php-solution",
                "content": "```\\nclass Solution\\n{\\n\\n    /**\\n     * @param String  $s\\n     * @param Integer $k\\n     *\\n     * @return String\\n     */\\n    function orderlyQueue($s, $k)\\n    {\\n        if ($k > 1) {\\n            $s = str_split($s);\\n            sort($s);\\n\\n            return join($s);\\n        }\\n        \\n        $strlen = strlen($s);\\n        for ($min = $s[0], $i = 1; $i < $strlen; $i++) {\\n            $min = min($min, $s[$i]);\\n        }\\n\\n        for ($curLen = 0, $i = $strlen - 1; $i >= 0 && $min === $s[$i]; $i--, $curLen++) {\\n        }\\n\\n        if ($curLen === $strlen) {\\n            return $s;\\n        }\\n        if ($curLen) {\\n            for ($i = 0; $min === $s[$i]; $i++, $curLen++) {\\n            }\\n            $ans = str_repeat($min, $curLen).substr($s, $i, $strlen - $curLen);\\n            $maxLen = $curLen;\\n        } else {\\n            $ans = $s;\\n            $maxLen = 0;\\n        }\\n\\n        for ($curLen = $i = 0; $i < $strlen; $i++) {\\n            if ($min === $s[$i]) {\\n                $curLen++;\\n            } else {\\n                if ($curLen > $maxLen) {\\n                    $maxLen = $curLen;\\n                    $ans = str_repeat($min, $curLen).substr($s, $i).substr($s, 0, $i - $curLen);\\n                } elseif ($curLen === $maxLen) {\\n                    $ans = min($ans, str_repeat($min, $curLen).substr($s, $i).substr($s, 0, $i - $curLen));\\n                }\\n\\n                $curLen = 0;\\n            }\\n        }\\n\\n        return $ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution\\n{\\n\\n    /**\\n     * @param String  $s\\n     * @param Integer $k\\n     *\\n     * @return String\\n     */\\n    function orderlyQueue($s, $k)\\n    {\\n        if ($k > 1) {\\n            $s = str_split($s);\\n            sort($s);\\n\\n            return join($s);\\n        }\\n        \\n        $strlen = strlen($s);\\n        for ($min = $s[0], $i = 1; $i < $strlen; $i++) {\\n            $min = min($min, $s[$i]);\\n        }\\n\\n        for ($curLen = 0, $i = $strlen - 1; $i >= 0 && $min === $s[$i]; $i--, $curLen++) {\\n        }\\n\\n        if ($curLen === $strlen) {\\n            return $s;\\n        }\\n        if ($curLen) {\\n            for ($i = 0; $min === $s[$i]; $i++, $curLen++) {\\n            }\\n            $ans = str_repeat($min, $curLen).substr($s, $i, $strlen - $curLen);\\n            $maxLen = $curLen;\\n        } else {\\n            $ans = $s;\\n            $maxLen = 0;\\n        }\\n\\n        for ($curLen = $i = 0; $i < $strlen; $i++) {\\n            if ($min === $s[$i]) {\\n                $curLen++;\\n            } else {\\n                if ($curLen > $maxLen) {\\n                    $maxLen = $curLen;\\n                    $ans = str_repeat($min, $curLen).substr($s, $i).substr($s, 0, $i - $curLen);\\n                } elseif ($curLen === $maxLen) {\\n                    $ans = min($ans, str_repeat($min, $curLen).substr($s, $i).substr($s, 0, $i - $curLen));\\n                }\\n\\n                $curLen = 0;\\n            }\\n        }\\n\\n        return $ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446796,
                "title": "go-solution-beats-100",
                "content": "```\\nfunc orderlyQueue(s string, k int) string {\\n\\tb := []byte(s)\\n\\tif k == 1 {\\n\\t\\tmin := []byte(s)\\n\\t\\tfor i := 0; i < len(s)-1; i++ {\\n\\t\\t\\tb = append(b[1:], b[0])\\n\\t\\t\\tif bytes.Compare(b, min) < 0 {\\n\\t\\t\\t\\tcopy(min, b)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn string(min)\\n\\t} else {\\n\\t\\tsort.Slice(b, func(i, j int) bool {\\n\\t\\t\\treturn b[i] < b[j]\\n\\t\\t})\\n\\t\\treturn string(b)\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc orderlyQueue(s string, k int) string {\\n\\tb := []byte(s)\\n\\tif k == 1 {\\n\\t\\tmin := []byte(s)\\n\\t\\tfor i := 0; i < len(s)-1; i++ {\\n\\t\\t\\tb = append(b[1:], b[0])\\n\\t\\t\\tif bytes.Compare(b, min) < 0 {\\n\\t\\t\\t\\tcopy(min, b)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn string(min)\\n\\t} else {\\n\\t\\tsort.Slice(b, func(i, j int) bool {\\n\\t\\t\\treturn b[i] < b[j]\\n\\t\\t})\\n\\t\\treturn string(b)\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1446763,
                "title": "c-sort-when-k-1-or-using-suffix-array-to-find-smallest-cyclic-shift-k-1",
                "content": "Suffix Array based smallest cyclic shift taken from https://cp-algorithms.com/string/suffix-array.html#toc-tgt-5\\n\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if (k >= 2) {\\n            std::sort(s.begin(), s.end());\\n            return s;\\n        }\\n        const int idx = sort_cyclic_shifts(s).front();\\n        return s.substr(idx) + s.substr(0, idx);\\n    }\\nprivate:\\n    std::vector<int> sort_cyclic_shifts(std::string const& s) {\\n        const int n = s.size();\\n        constexpr int ALPHABET = 256;\\n        \\n        vector<int> p(n), c(n), cnt(max(ALPHABET, n), 0);\\n        for (int i = 0; i < n; ++i) {\\n            cnt[s[i]]++;\\n        }\\n        for (int i = 1; i < ALPHABET; ++i) {\\n            cnt[i] += cnt[i-1];\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            p[--cnt[s[i]]] = i;\\n        }\\n        \\n        c[p[0]] = 0;\\n        int classes = 1;\\n        for (int i = 1; i < n; i++) {\\n            if (s[p[i]] != s[p[i-1]]) {\\n                classes++;\\n            }\\n            c[p[i]] = classes - 1;\\n        }\\n        \\n        std::vector<int> pn(n), cn(n);\\n        for (int h = 0; (1 << h) < n; ++h) {\\n            for (int i = 0; i < n; i++) {\\n                pn[i] = p[i] - (1 << h);\\n                if (pn[i] < 0)\\n                    pn[i] += n;\\n            }\\n            std::fill(cnt.begin(), cnt.begin() + classes, 0);\\n            for (int i = 0; i < n; i++) {\\n                cnt[c[pn[i]]]++;\\n            }\\n            for (int i = 1; i < classes; i++) {\\n                cnt[i] += cnt[i-1];\\n            }\\n            for (int i = n-1; i >= 0; i--) {\\n                p[--cnt[c[pn[i]]]] = pn[i];\\n            }\\n            cn[p[0]] = 0;\\n            classes = 1;\\n            for (int i = 1; i < n; i++) {\\n                std::pair<int, int> curr = {\\n                    c[p[i]], c[(p[i] + (1 << h)) % n]\\n                };\\n                std::pair<int, int> prev = {\\n                    c[p[i-1]], c[(p[i-1] + (1 << h)) % n]\\n                };\\n                if (curr != prev) {\\n                    ++classes;\\n                }\\n                cn[p[i]] = classes - 1;\\n            }\\n            c.swap(cn);\\n        }\\n        return p;        \\n    }    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if (k >= 2) {\\n            std::sort(s.begin(), s.end());\\n            return s;\\n        }\\n        const int idx = sort_cyclic_shifts(s).front();\\n        return s.substr(idx) + s.substr(0, idx);\\n    }\\nprivate:\\n    std::vector<int> sort_cyclic_shifts(std::string const& s) {\\n        const int n = s.size();\\n        constexpr int ALPHABET = 256;\\n        \\n        vector<int> p(n), c(n), cnt(max(ALPHABET, n), 0);\\n        for (int i = 0; i < n; ++i) {\\n            cnt[s[i]]++;\\n        }\\n        for (int i = 1; i < ALPHABET; ++i) {\\n            cnt[i] += cnt[i-1];\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            p[--cnt[s[i]]] = i;\\n        }\\n        \\n        c[p[0]] = 0;\\n        int classes = 1;\\n        for (int i = 1; i < n; i++) {\\n            if (s[p[i]] != s[p[i-1]]) {\\n                classes++;\\n            }\\n            c[p[i]] = classes - 1;\\n        }\\n        \\n        std::vector<int> pn(n), cn(n);\\n        for (int h = 0; (1 << h) < n; ++h) {\\n            for (int i = 0; i < n; i++) {\\n                pn[i] = p[i] - (1 << h);\\n                if (pn[i] < 0)\\n                    pn[i] += n;\\n            }\\n            std::fill(cnt.begin(), cnt.begin() + classes, 0);\\n            for (int i = 0; i < n; i++) {\\n                cnt[c[pn[i]]]++;\\n            }\\n            for (int i = 1; i < classes; i++) {\\n                cnt[i] += cnt[i-1];\\n            }\\n            for (int i = n-1; i >= 0; i--) {\\n                p[--cnt[c[pn[i]]]] = pn[i];\\n            }\\n            cn[p[0]] = 0;\\n            classes = 1;\\n            for (int i = 1; i < n; i++) {\\n                std::pair<int, int> curr = {\\n                    c[p[i]], c[(p[i] + (1 << h)) % n]\\n                };\\n                std::pair<int, int> prev = {\\n                    c[p[i-1]], c[(p[i-1] + (1 << h)) % n]\\n                };\\n                if (curr != prev) {\\n                    ++classes;\\n                }\\n                cn[p[i]] = classes - 1;\\n            }\\n            c.swap(cn);\\n        }\\n        return p;        \\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446576,
                "title": "c-orderly-queue-simple-solution-with-explanation-for-k-1",
                "content": "We can divide the question in two parts - one when `k = 1` and second otherwise ( `k>1`).\\nFor the second case, we can prove that after some number of moves, the string can always be sorted. \\n\\n**1. K > 1**\\nWe can sort the string by following a greedy approach: \\nTake the minimum character in Si to Si+k. Then in the next move, we perform the comparison with larger character of first step with the next character. In this step either the character from first step will be larger and stay here or will go to the end of string. \\n\\nWe can think of this like bubble sort. Instead of swapping two elements, we are moving the element to the end if it is smaller. \\n\\nLet\\'s take an example to show this is true:\\nLet `S = kghda`\\n```\\nkhdag -> kdagh -> kaghd -> aghdk\\naghdk -> ghdka -> hdkag -> hkagd -> kagdh ->kgdha -> gdhak -> ghakd ->hakdg -> akdgh\\nakdgh -> kdgha -> kghad -> khadg -> kadgh -> adghk\\nadghk    // In the last step we move largest element to the end\\n```\\n\\n**2. K=1**\\nWhen K=1, we need to find the smallest lexographic suffix. We can the append the prefix at the end of the suffix. \\nThe minimum of all such strings will be the answer. \\n\\n\\nFor eg,  Let `S = \"cbabaab\"`\\nWe can find the minimum lexographic character and find all suffix starting with it, then the smallest string formed by appending the suffix and prefix will be the answer. \\nHere, `S1 = abaabcb` and `S2 = aabcbab`, out of these S2 is smaller. So we return it. \\n\\n```c++\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if (k==1){\\n                auto minchar = min_element(s.begin(), s.end());\\n                string ans = s;\\n                for (int i=0; i<s.size(); i++){\\n                    if (s[i]==*minchar){\\n                        auto suffix = string(s.begin()+i, s.end());\\n                        auto temp = suffix + string(s.begin(), s.begin()+i);\\n                        ans = min(temp, ans);\\n                    }\\n                }\\n\\n                return ans;\\n        }\\n        sort(s.begin(), s.end());\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nkhdag -> kdagh -> kaghd -> aghdk\\naghdk -> ghdka -> hdkag -> hkagd -> kagdh ->kgdha -> gdhak -> ghakd ->hakdg -> akdgh\\nakdgh -> kdgha -> kghad -> khadg -> kadgh -> adghk\\nadghk    // In the last step we move largest element to the end\\n```\n```c++\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if (k==1){\\n                auto minchar = min_element(s.begin(), s.end());\\n                string ans = s;\\n                for (int i=0; i<s.size(); i++){\\n                    if (s[i]==*minchar){\\n                        auto suffix = string(s.begin()+i, s.end());\\n                        auto temp = suffix + string(s.begin(), s.begin()+i);\\n                        ans = min(temp, ans);\\n                    }\\n                }\\n\\n                return ans;\\n        }\\n        sort(s.begin(), s.end());\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446452,
                "title": "rust-o-n-0ms-suffix-array-solution",
                "content": "I googled a suffix array crate and copied and pasted.\\n\\nmy idea is that if the string is:\\ns = part1-part2,\\nwe can join the string to itself to get\\npart1-part2-part1-part2\\nand lets say the solution is part2-part1-part2. (we don\\'t know what the parts are yet).\\nMy intuition is that if we find the smallest suffix that starts in the first half of this combined string, then that suffix must be part2-part1-part2, so the solution is part2-part1.\\n```\\nimpl Solution {\\n    // @robertkingnz\\n    pub fn orderly_queue(s: String, k: i32) -> String {\\n        if k >= 2 {\\n            let mut v: Vec<char> = s.chars().collect();\\n            v.sort();\\n            return v.iter().map(|x| *x).collect();\\n        }\\n        let sa = SuffixTable::new(format!(\"{}{}\",s,s)); // O(N)\\n        let t = sa.table(); \\n\\t\\t// table[i] gives the suffix in order, like in https://en.wikipedia.org/wiki/Suffix_array so we just want the first suffix we find that\\'s in the first half.\\n        for j in 0..t.len() {\\n            let i = t[j] as usize;\\n            if i < s.len() {\\n                let mut it = sa.suffix(j).chars();\\n                return (0..s.len()).map(|_| it.next().unwrap()).collect();\\n            }\\n        }\\n        unreachable!();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    // @robertkingnz\\n    pub fn orderly_queue(s: String, k: i32) -> String {\\n        if k >= 2 {\\n            let mut v: Vec<char> = s.chars().collect();\\n            v.sort();\\n            return v.iter().map(|x| *x).collect();\\n        }\\n        let sa = SuffixTable::new(format!(\"{}{}\",s,s)); // O(N)\\n        let t = sa.table(); \\n\\t\\t// table[i] gives the suffix in order, like in https://en.wikipedia.org/wiki/Suffix_array so we just want the first suffix we find that\\'s in the first half.\\n        for j in 0..t.len() {\\n            let i = t[j] as usize;\\n            if i < s.len() {\\n                let mut it = sa.suffix(j).chars();\\n                return (0..s.len()).map(|_| it.next().unwrap()).collect();\\n            }\\n        }\\n        unreachable!();\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1446287,
                "title": "rust-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn orderly_queue(s: String, k: i32) -> String {\\n        if k == 1 {\\n            let ss = s.chars().chain(s.chars()).collect::<Vec<_>>();\\n            let mut v = ss.windows(s.len()).collect::<Vec<_>>();\\n            v.sort();\\n            v[0].iter().copied().collect()\\n        } else {\\n            let mut v = s.chars().collect::<Vec<_>>();\\n            v.sort();\\n            v.iter().collect()\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn orderly_queue(s: String, k: i32) -> String {\\n        if k == 1 {\\n            let ss = s.chars().chain(s.chars()).collect::<Vec<_>>();\\n            let mut v = ss.windows(s.len()).collect::<Vec<_>>();\\n            v.sort();\\n            v[0].iter().copied().collect()\\n        } else {\\n            let mut v = s.chars().collect::<Vec<_>>();\\n            v.sort();\\n            v.iter().collect()\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1446225,
                "title": "kotlin-clean-short-solution",
                "content": "```\\nclass Solution {\\n    fun orderlyQueue(s: String, k: Int): String {\\n        return when {\\n            k > 1 -> String(s.toCharArray().apply { sort() })\\n            else -> {\\n                val ss = s + s\\n                var res = ss.substring(0, s.length)\\n                for (start in 1 until s.length) {\\n                    res = minOf(res, ss.substring(start, start + s.length))\\n                }\\n                res\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun orderlyQueue(s: String, k: Int): String {\\n        return when {\\n            k > 1 -> String(s.toCharArray().apply { sort() })\\n            else -> {\\n                val ss = s + s\\n                var res = ss.substring(0, s.length)\\n                for (start in 1 until s.length) {\\n                    res = minOf(res, ss.substring(start, start + s.length))\\n                }\\n                res\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446133,
                "title": "kotlin-easy-solution",
                "content": "```\\nclass Solution {\\n    fun orderlyQueue(s: String, k: Int): String {\\n        var arr=s.toCharArray()\\n        if(k!=1){\\n            arr.sort()\\n            return String(arr)\\n        }\\n         var temp=s\\n        for(i in 1.. s.length){\\n        val curr=s.substring(i)+s.substring(0,i)\\n        \\n        if(temp.compareTo(curr)>0){\\n            temp=curr\\n        }\\n    }\\n        \\n        return temp\\n    }\\n}",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "class Solution {\\n    fun orderlyQueue(s: String, k: Int): String {\\n        var arr=s.toCharArray()\\n        if(k!=1){\\n            arr.sort()\\n            return String(arr)\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1446122,
                "title": "c-simple-solution-explanation",
                "content": "**Idea:**  \\n**For K>1 :** If we try with few numbers of strings we can easily see for K>1 we can always get the sorted substring as anwer.(lexicographically smallest substring).\\n**For K==1 :** We can not get the smallest possible substring as the relative position of character matter and we can not change that(1st test case:In case of \"cba\" it is not possible to get \"bc\" as substring by any number of operations).\\n\\n**Solution:**\\n**For K>1 :** Simply sort the string.\\n**For K==1 :** We know for sure the we can always get smallest character at the front then( s[smallest....]+s[....smallest] will be answer), but if we have more than occurance of smallest character then we need to check for all possible string which will start with smallest charcter.\\n\\n**Code :**\\n```\\nstring orderlyQueue(string s, int k)\\n    {\\n        if (k > 1)\\n        {\\n            sort(s.begin(), s.end());\\n            return s;\\n        }\\n        else\\n        {\\n            string ans = s;\\n            // Get the smallest character\\n            char ch = *min_element(s.begin(), s.end());\\n            for (int i = 0; i < s.size(); i++)\\n            {\\n                // Checking for each possible string which can start with current smallest element\\n                if (s[i] == ch)\\n                {\\n                    string st = s.substr(i);\\n                    string en = s.substr(0, i);\\n                    if (st + en < ans)\\n                        ans = st + en;\\n                }\\n            }\\n\\n            return ans;\\n        }\\n    }\\n\\t",
                "solutionTags": [],
                "code": "**Idea:**  \\n**For K>1 :** If we try with few numbers of strings we can easily see for K>1 we can always get the sorted substring as anwer.(lexicographically smallest substring).\\n**For K==1 :** We can not get the smallest possible substring as the relative position of character matter and we can not change that(1st test case:In case of \"cba\" it is not possible to get \"bc\" as substring by any number of operations).\\n\\n**Solution:**\\n**For K>1 :** Simply sort the string.\\n**For K==1 :** We know for sure the we can always get smallest character at the front then( s[smallest....]+s[....smallest] will be answer), but if we have more than occurance of smallest character then we need to check for all possible string which will start with smallest charcter.\\n\\n**Code :**\\n```\\nstring orderlyQueue(string s, int k)\\n    {\\n        if (k > 1)\\n        {\\n            sort(s.begin(), s.end());\\n            return s;\\n        }\\n        else\\n        {\\n            string ans = s;\\n            // Get the smallest character\\n            char ch = *min_element(s.begin(), s.end());\\n            for (int i = 0; i < s.size(); i++)\\n            {\\n                // Checking for each possible string which can start with current smallest element\\n                if (s[i] == ch)\\n                {\\n                    string st = s.substr(i);\\n                    string en = s.substr(0, i);\\n                    if (st + en < ans)\\n                        ans = st + en;\\n                }\\n            }\\n\\n            return ans;\\n        }\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1446052,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        return min(s[i:]+s[:i] for i in range(len(s))) if k==1 else \\'\\'.join(sorted(s))\\n```",
                "solutionTags": [
                    "Math",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        return min(s[i:]+s[:i] for i in range(len(s))) if k==1 else \\'\\'.join(sorted(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446018,
                "title": "my-java-solution-using-concept-of-whether-k-1-or-k-1",
                "content": "If K == 1, then rotate until we get the best result\\nelse, just sort the string and return the result\\n```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if (s == null || s.length() == 0) {\\n            return \"\";\\n        }\\n        int length = s.length();\\n        if (k == 1) {\\n            String answer = s;\\n            for (int i=0; i<length; i++) {\\n                String rotatedOneCharacter = s.substring(i) + s.substring(0, i);\\n                if (rotatedOneCharacter.compareTo(answer) < 0) {\\n                    answer = rotatedOneCharacter;\\n                }\\n            }\\n            return answer;\\n        }\\n        else {\\n            char [] convertedToArray = s.toCharArray();\\n            Arrays.sort(convertedToArray);\\n            return new String(convertedToArray);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if (s == null || s.length() == 0) {\\n            return \"\";\\n        }\\n        int length = s.length();\\n        if (k == 1) {\\n            String answer = s;\\n            for (int i=0; i<length; i++) {\\n                String rotatedOneCharacter = s.substring(i) + s.substring(0, i);\\n                if (rotatedOneCharacter.compareTo(answer) < 0) {\\n                    answer = rotatedOneCharacter;\\n                }\\n            }\\n            return answer;\\n        }\\n        else {\\n            char [] convertedToArray = s.toCharArray();\\n            Arrays.sort(convertedToArray);\\n            return new String(convertedToArray);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445958,
                "title": "java-easy-1-ms",
                "content": "The Simple idea is that if k = 1, then you can only rotate the string. But when k > 1, You can create any permutation of the string. So you can just sort the string.\\n```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k == 1) {\\n            StringBuilder sb = new StringBuilder(s), ans = new StringBuilder(sb);\\n            for(int i = 0; i < s.length(); i++) {\\n                char ch = sb.charAt(0);\\n                sb = sb.deleteCharAt(0);\\n                sb.append(ch);\\n                if(ans.compareTo(sb) > 1)\\n                    ans = new StringBuilder(sb);\\n            }\\n            return new String(ans);\\n        }\\n        else {\\n            char[] arr = s.toCharArray();\\n            Arrays.sort(arr);\\n            return new String(arr);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k == 1) {\\n            StringBuilder sb = new StringBuilder(s), ans = new StringBuilder(sb);\\n            for(int i = 0; i < s.length(); i++) {\\n                char ch = sb.charAt(0);\\n                sb = sb.deleteCharAt(0);\\n                sb.append(ch);\\n                if(ans.compareTo(sb) > 1)\\n                    ans = new StringBuilder(sb);\\n            }\\n            return new String(ans);\\n        }\\n        else {\\n            char[] arr = s.toCharArray();\\n            Arrays.sort(arr);\\n            return new String(arr);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445919,
                "title": "a-little-better-version-of-the-o-n-2-approach-100-time-and-space",
                "content": "**In case of K>=2** the answer is obvious , Sort the String . \\n**In case of K=1;**\\n* if (k == 1) {\\n\\xA0\\xA0String ans = s;\\n           \\xA0\\xA0 for (int i = 0; i < s.length(); ++i) {\\n               \\xA0\\xA0\\xA0\\xA0\\xA0 String temp = s.substring(i) + s.substring(0, i);\\n               \\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if (temp.compareTo(ans) < 0) {\\n               \\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0   \\xA0\\xA0\\xA0\\xA0\\xA0  ans = temp;\\n               \\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n            }\\n            return ans;\\n        }\\n\\t\\t\\n**i did this**\\n**better solution is** \\n* if (k == 1) {\\n           \\xA0\\xA0 **String ans = s;\\n           \\xA0\\xA0 char ch=s.charAt(0);\\n           \\xA0\\xA0 for (int i = 1; i < s.length(); ++i) {\\n               \\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0if(s.charAt(i)<ch){\\n                   \\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0ch=s.charAt(i);\\n              \\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0}\\n           \\xA0\\xA0\\xA0 }\\n           \\xA0\\xA0\\xA0\\xA0ArrayList<Integer> al=new ArrayList<>();\\n           \\xA0\\xA0\\xA0\\xA0for(int i=0;i<s.length();i++){\\n           \\xA0\\xA0\\xA0\\xA0   \\xA0\\xA0\\xA0\\xA0 if(s.charAt(i)==ch){\\n           \\xA0\\xA0\\xA0\\xA0        \\xA0\\xA0\\xA0   \\xA0\\xA0\\xA0\\xA0al.add(i);\\n           \\xA0\\xA0\\xA0\\xA0   \\xA0\\xA0\\xA0\\xA0 }\\n           \\xA0\\xA0\\xA0\\xA0}**\\n           \\xA0\\xA0\\xA0 **for (int i :al) {**\\n               \\xA0\\xA0\\xA0\\xA0\\xA0String temp = s.substring(i) + s.substring(0, i);\\n               \\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0if (temp.compareTo(ans) < 0) {\\n               \\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0   \\xA0\\xA0\\xA0\\xA0 ans = temp;\\n               \\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0}\\n           \\xA0\\xA0\\xA0 }\\n            return ans;\\n        }\\n\\t\\t\\nInstead of seaching through all elements , we know for lexicographically smallest we need the smallest character, at the front of our new String.\\n\\t\\tso just find all occurences of the smallest character and compare (each one assumed as front). \\n\\t\\t**Eg:      \"bbcdaac\"**\\n\\t\\twe know that the  answer will only include **a** in the front  ---  **aacbbcd     or    acbbcda** are the only 2 possiblity for the best answer.   So we just compare them.\\n\\t\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "**In case of K>=2** the answer is obvious , Sort the String . \\n**In case of K=1;**\\n* if (k == 1) {\\n\\xA0\\xA0String ans = s;\\n           \\xA0\\xA0 for (int i = 0; i < s.length(); ++i) {\\n               \\xA0\\xA0\\xA0\\xA0\\xA0 String temp = s.substring(i) + s.substring(0, i);\\n               \\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if (temp.compareTo(ans) < 0) {\\n               \\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0   \\xA0\\xA0\\xA0\\xA0\\xA0  ans = temp;\\n               \\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n            }\\n            return ans;\\n        }\\n\\t\\t\\n**i did this**\\n**better solution is** \\n* if (k == 1) {\\n           \\xA0\\xA0 **String ans = s;\\n           \\xA0\\xA0 char ch=s.charAt(0);\\n           \\xA0\\xA0 for (int i = 1; i < s.length(); ++i) {\\n               \\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0if(s.charAt(i)<ch){\\n                   \\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0ch=s.charAt(i);\\n              \\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0}\\n           \\xA0\\xA0\\xA0 }\\n           \\xA0\\xA0\\xA0\\xA0ArrayList<Integer> al=new ArrayList<>();\\n           \\xA0\\xA0\\xA0\\xA0for(int i=0;i<s.length();i++){\\n           \\xA0\\xA0\\xA0\\xA0   \\xA0\\xA0\\xA0\\xA0 if(s.charAt(i)==ch){\\n           \\xA0\\xA0\\xA0\\xA0        \\xA0\\xA0\\xA0   \\xA0\\xA0\\xA0\\xA0al.add(i);\\n           \\xA0\\xA0\\xA0\\xA0   \\xA0\\xA0\\xA0\\xA0 }\\n           \\xA0\\xA0\\xA0\\xA0}**\\n           \\xA0\\xA0\\xA0 **for (int i :al) {**\\n               \\xA0\\xA0\\xA0\\xA0\\xA0String temp = s.substring(i) + s.substring(0, i);\\n               \\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0if (temp.compareTo(ans) < 0) {\\n               \\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0   \\xA0\\xA0\\xA0\\xA0 ans = temp;\\n               \\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0}\\n           \\xA0\\xA0\\xA0 }\\n            return ans;\\n        }\\n\\t\\t\\nInstead of seaching through all elements , we know for lexicographically smallest we need the smallest character, at the front of our new String.\\n\\t\\tso just find all occurences of the smallest character and compare (each one assumed as front). \\n\\t\\t**Eg:      \"bbcdaac\"**\\n\\t\\twe know that the  answer will only include **a** in the front  ---  **aacbbcd     or    acbbcda** are the only 2 possiblity for the best answer.   So we just compare them.\\n\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1445861,
                "title": "python-3-clean-concise-solution-with-detail-explanation",
                "content": "The main intuition of this problem is finding that we can achieve the sorted form of the string if value of k is greater than 2\\n\\n![image](https://assets.leetcode.com/users/images/64ab1e04-296a-4e65-8768-056f6e7cb451_1630834404.4791017.png)\\n\\nTherefore, for every string s , if **k >= 2** . The final answer will be the sorted order of that string\\n\\nFor **k == 1**, we can consider every possible ways and find the solution \\n\\n![image](https://assets.leetcode.com/users/images/107307f7-b999-4fd3-988f-1ea8fa617fee_1630834518.059623.png)\\n\\n***Time complexity :*** O(n + n log n)\\n***Space complexity :*** O(1)\\n\\n```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k==1:\\n            best = s\\n            for i in range(len(s)):\\n                cur = s[i:]+s[:i] \\n                if cur<best : best = cur\\n            return best\\n                        \\n        return \"\".join(sorted(s))\\n```\\n\\n**One liner :**\\n```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n            return min(s[i:]+s[:i] for i in range(len(s))) if k==1 else \"\".join(sorted(s))\\n                        \\n\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k==1:\\n            best = s\\n            for i in range(len(s)):\\n                cur = s[i:]+s[:i] \\n                if cur<best : best = cur\\n            return best\\n                        \\n        return \"\".join(sorted(s))\\n```\n```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n            return min(s[i:]+s[:i] for i in range(len(s))) if k==1 else \"\".join(sorted(s))\\n                        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445795,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public String orderlyQueue(String S, int K) {\\n        // if the window(k) size is greater than 1 then just sort the string and return \\n        if(K>=2){\\n            char[] ch=S.toCharArray();\\n            Arrays.sort(ch);\\n            return new String(ch);\\n        }else{\\n            // else form a secondary string and run a loop for the length of the original string\\n            // if the new formed string is less then update the output string\\n            String s2=S + S;\\n            for(int i=0;i<S.length();i++){\\n                String temp=s2.substring(i,i+S.length());\\n                if(S.compareTo(temp)>0)\\n                    S = temp;\\n            }\\n        }\\n        return S;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String orderlyQueue(String S, int K) {\\n        // if the window(k) size is greater than 1 then just sort the string and return \\n        if(K>=2){\\n            char[] ch=S.toCharArray();\\n            Arrays.sort(ch);\\n            return new String(ch);\\n        }else{\\n            // else form a secondary string and run a loop for the length of the original string\\n            // if the new formed string is less then update the output string\\n            String s2=S + S;\\n            for(int i=0;i<S.length();i++){\\n                String temp=s2.substring(i,i+S.length());\\n                if(S.compareTo(temp)>0)\\n                    S = temp;\\n            }\\n        }\\n        return S;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445646,
                "title": "python-brute-force",
                "content": "```\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k > 1:\\n            return \\'\\'.join(sorted(s))\\n        else:\\n            seen = set()\\n            while(s not in seen):\\n                seen.add(s)\\n                s = s[k:] + s[:k]\\n                \\n            return min(seen)\\n```",
                "solutionTags": [],
                "code": "```\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        if k > 1:\\n            return \\'\\'.join(sorted(s))\\n        else:\\n            seen = set()\\n            while(s not in seen):\\n                seen.add(s)\\n                s = s[k:] + s[:k]\\n                \\n            return min(seen)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1159319,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string S, int K) {\\n        string ans=S;\\n        int n=S.size()-1;\\n        if(K>1)\\n        {\\n            sort(S.begin(),S.end());\\n            return S;\\n        }\\n        else\\n        {\\n            for(int i=0;i<S.size();i++)\\n            {\\n                ans = min(ans , S.substr(i+1)+S.substr(0,i+1));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string S, int K) {\\n        string ans=S;\\n        int n=S.size()-1;\\n        if(K>1)\\n        {\\n            sort(S.begin(),S.end());\\n            return S;\\n        }\\n        else\\n        {\\n            for(int i=0;i<S.size();i++)\\n            {\\n                ans = min(ans , S.substr(i+1)+S.substr(0,i+1));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1094402,
                "title": "python-o-n",
                "content": "Reverse of https://leetcode.com/problems/last-substring-in-lexicographical-order/ for K == 1\\n```\\nclass Solution:\\n    def least_rotation(self, S: str) -> int:\\n        i = 0\\n        j = 1\\n        n = len(S)\\n        S += S # avoid mod\\n        k = 0\\n        while k < n and j < n:\\n            if S[i+k] == S[j+k]:\\n                k += 1\\n                continue\\n            elif S[i+k] < S[j+k]:\\n                j = j+k+1\\n            else:\\n                i = max(j, i+k+1)\\n                j = j+1\\n            k = 0\\n        return S[i:i+n]\\n    \\n    def orderlyQueue(self, S: str, K: int) -> str:\\n        if K == 1:\\n            return self.least_rotation(S)\\n        count = Counter(S) # only english alphabets\\n        res = []\\n        for c in sorted(count):\\n            res.extend(c * count[c])\\n        return \\'\\'.join(res)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def least_rotation(self, S: str) -> int:\\n        i = 0\\n        j = 1\\n        n = len(S)\\n        S += S # avoid mod\\n        k = 0\\n        while k < n and j < n:\\n            if S[i+k] == S[j+k]:\\n                k += 1\\n                continue\\n            elif S[i+k] < S[j+k]:\\n                j = j+k+1\\n            else:\\n                i = max(j, i+k+1)\\n                j = j+1\\n            k = 0\\n        return S[i:i+n]\\n    \\n    def orderlyQueue(self, S: str, K: int) -> str:\\n        if K == 1:\\n            return self.least_rotation(S)\\n        count = Counter(S) # only english alphabets\\n        res = []\\n        for c in sorted(count):\\n            res.extend(c * count[c])\\n        return \\'\\'.join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 801049,
                "title": "4-ms-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string S, int K) {\\n        if(K>=2){\\n            sort(S.begin(),S.end());\\n            return S;\\n        }\\n        string ans = S.substr(1) + S.substr(0,1);\\n        string mini = S;\\n        while(ans!=S){\\n            cout<<ans<<endl;\\n            mini = min(ans,mini);\\n            ans = ans.substr(1) + ans.substr(0,1);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string S, int K) {\\n        if(K>=2){\\n            sort(S.begin(),S.end());\\n            return S;\\n        }\\n        string ans = S.substr(1) + S.substr(0,1);\\n        string mini = S;\\n        while(ans!=S){\\n            cout<<ans<<endl;\\n            mini = min(ans,mini);\\n            ans = ans.substr(1) + ans.substr(0,1);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 645124,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string S, int K) {\\n        int n = S.length();\\n        \\n        if(n == 0){\\n            return \"\";\\n        }else if(K > 1){\\n            sort(S.begin(),S.end());\\n            return S;\\n        }\\n        \\n        vector<string> v;\\n        for(int i=0;i<n;i++){\\n            char curr = S[0];\\n            S.erase(S.begin());\\n            S += curr;\\n            v.push_back(S);\\n        }\\n        \\n        sort(v.begin(),v.end());\\n        return v[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string S, int K) {\\n        int n = S.length();\\n        \\n        if(n == 0){\\n            return \"\";\\n        }else if(K > 1){\\n            sort(S.begin(),S.end());\\n            return S;\\n        }\\n        \\n        vector<string> v;\\n        for(int i=0;i<n;i++){\\n            char curr = S[0];\\n            S.erase(S.begin());\\n            S += curr;\\n            v.push_back(S);\\n        }\\n        \\n        sort(v.begin(),v.end());\\n        return v[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 601207,
                "title": "ultra-ez-c-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k, string res = \"\") {\\n        if(s.size() == 1 || k == 0) return s;\\n        if(k > 1){\\n            vector<int> l(26);\\n            for(auto i : s) l[i - \\'a\\']++;\\n            for(int i = 0;i < 26;i++)\\n                for(int j = 0;j < l[i];j++)\\n                    res += i + \\'a\\';\\n            return res;\\n        }\\n        res = s;\\n        for(int i = 0;i < s.size();i++){\\n            std::rotate(s.begin(), s.begin() + 1, s.end());\\n            res = min(res, s);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k, string res = \"\") {\\n        if(s.size() == 1 || k == 0) return s;\\n        if(k > 1){\\n            vector<int> l(26);\\n            for(auto i : s) l[i - \\'a\\']++;\\n            for(int i = 0;i < 26;i++)\\n                for(int j = 0;j < l[i];j++)\\n                    res += i + \\'a\\';\\n            return res;\\n        }\\n        res = s;\\n        for(int i = 0;i < s.size();i++){\\n            std::rotate(s.begin(), s.begin() + 1, s.end());\\n            res = min(res, s);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 475735,
                "title": "c-with-actual-string-rotations-for-k-1-and-explanation",
                "content": "/***********\\n    For any String you can move any char to anywhere if you can swap adjacent characters\\nFor any String xxx[ab]xxx you can always do\\n\\nxxx[ab]xxx\\n[ab]xxxxxx\\nxxxxxx[ba]\\nxxx[ba]xxx\\n\\nSo when we have K which is more than 1, we can possibly swap any adjacent pair of character in the string.\\nif that is possible then ascending ordered string will always be lexographically shortest string.\\nAs bubble sort relies of swapping of adjacent characters.\\n\\nTechincally we can just write function which can take any 2 adjacent character and using some kind of roatation swap them,  Thus using swap we can bubble out the largest one to the end, which is nothing but 1 step of bubble sort. Doing n square iteration we can sort them all so technically we can get the sorted string at the end\\n*****************/\\n\\n\\n\\n```\\n//Implemented using rotation of string for swapping and bubble sort\\n    void swapStr(string &S, int i) {\\n        int limit = S.length()-1;\\n        if (i-1 >= 0) {\\n            rotate(S.begin(), S.begin()+i, S.end());\\n        }\\n        rotate(S.begin()+1,S.begin()+2, S.end());\\n        rotate(S.begin(), S.begin()+1, S.end());\\n        rotate(S.begin(), S.begin()+(limit-(i+1)), S.end());\\n    }\\n    string orderlyQueue(string S, int K) {\\n         if(K > 1) {\\n            //sort(S.begin(), S.end());\\n             \\n            // Swap using bubble sort\\n            for (int i = 0; i < S.length(); i++) {\\n                bool swapDone = false;\\n                for (int j = 1; j < S.length()-i; j++) {\\n                    if (S[j-1] > S[j]) {\\n                        //swap(S[j-1],S[j]);\\n                        swapStr(S, j-1);\\n                        swapDone = true;\\n                    }\\n                }\\n                if (!swapDone) break;\\n            }\\n        } else {\\n             // rotate for all combination and pick the smallest one.\\n             // abcd will become abcdabcd , by shifting the window from b to d of size 4 \\n             // we will get all rotated variants of abcd.\\n             string allCombo = S+S;\\n             string ans = S;\\n             for (int i = 1; i < S.length(); i++) {\\n                 string rotStr = allCombo.substr(i,S.length());\\n                 if (rotStr.compare(ans) < 0) {\\n                     ans = rotStr;\\n                 }\\n             }\\n             S = ans;\\n         }\\n        return S;\\n    }",
                "solutionTags": [],
                "code": "/***********\\n    For any String you can move any char to anywhere if you can swap adjacent characters\\nFor any String xxx[ab]xxx you can always do\\n\\nxxx[ab]xxx\\n[ab]xxxxxx\\nxxxxxx[ba]\\nxxx[ba]xxx\\n\\nSo when we have K which is more than 1, we can possibly swap any adjacent pair of character in the string.\\nif that is possible then ascending ordered string will always be lexographically shortest string.\\nAs bubble sort relies of swapping of adjacent characters.\\n\\nTechincally we can just write function which can take any 2 adjacent character and using some kind of roatation swap them,  Thus using swap we can bubble out the largest one to the end, which is nothing but 1 step of bubble sort. Doing n square iteration we can sort them all so technically we can get the sorted string at the end\\n*****************/\\n\\n\\n\\n```\\n//Implemented using rotation of string for swapping and bubble sort\\n    void swapStr(string &S, int i) {\\n        int limit = S.length()-1;\\n        if (i-1 >= 0) {\\n            rotate(S.begin(), S.begin()+i, S.end());\\n        }\\n        rotate(S.begin()+1,S.begin()+2, S.end());\\n        rotate(S.begin(), S.begin()+1, S.end());\\n        rotate(S.begin(), S.begin()+(limit-(i+1)), S.end());\\n    }\\n    string orderlyQueue(string S, int K) {\\n         if(K > 1) {\\n            //sort(S.begin(), S.end());\\n             \\n            // Swap using bubble sort\\n            for (int i = 0; i < S.length(); i++) {\\n                bool swapDone = false;\\n                for (int j = 1; j < S.length()-i; j++) {\\n                    if (S[j-1] > S[j]) {\\n                        //swap(S[j-1],S[j]);\\n                        swapStr(S, j-1);\\n                        swapDone = true;\\n                    }\\n                }\\n                if (!swapDone) break;\\n            }\\n        } else {\\n             // rotate for all combination and pick the smallest one.\\n             // abcd will become abcdabcd , by shifting the window from b to d of size 4 \\n             // we will get all rotated variants of abcd.\\n             string allCombo = S+S;\\n             string ans = S;\\n             for (int i = 1; i < S.length(); i++) {\\n                 string rotStr = allCombo.substr(i,S.length());\\n                 if (rotStr.compare(ans) < 0) {\\n                     ans = rotStr;\\n                 }\\n             }\\n             S = ans;\\n         }\\n        return S;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 474642,
                "title": "c-solution",
                "content": "```\\npublic class Solution\\n{\\n    public string OrderlyQueue(string S, int K) \\n    {\\n        if(K > 1)\\n        {\\n            var charArray = S.ToCharArray();\\n            Array.Sort(charArray);\\n            return new string(charArray);\\n        }\\n        \\n        var result = S;\\n        for(int i = 0; i < S.Length; i++)\\n        {\\n            var newString = S.Substring(i) + S.Substring(0, i);\\n            if(newString.CompareTo(result) < 0)\\n                result = newString;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public string OrderlyQueue(string S, int K) \\n    {\\n        if(K > 1)\\n        {\\n            var charArray = S.ToCharArray();\\n            Array.Sort(charArray);\\n            return new string(charArray);\\n        }\\n        \\n        var result = S;\\n        for(int i = 0; i < S.Length; i++)\\n        {\\n            var newString = S.Substring(i) + S.Substring(0, i);\\n            if(newString.CompareTo(result) < 0)\\n                result = newString;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328417,
                "title": "better-explanation-java-beat-100-from-every-aspects",
                "content": "Please follow the code for explanation \\n\\n```\\n  public String orderlyQueue(String S, int K) {\\n        return beat100Percent(S, K);\\n\\n    }\\n\\n\\n    private String bitSlow(String S, int K) {\\n        if (K == 1) {\\n            String res = S;\\n            for (int i = 0; i < S.length(); ++i) {\\n                String t = S.substring(i) + S.substring(0, i);\\n                if (t.compareTo(res) < 0) res = t;\\n            }\\n            return res;\\n        } else {\\n            char[] ca = S.toCharArray();\\n            Arrays.sort(ca);\\n            return new String(ca);\\n        }\\n    }\\n\\n    private String beat100Percent(String S, int K) {\\n        if (S == null || S.isEmpty())\\n            return S;\\n\\n        if (K == 1)\\n            //This is nothing but finding the string after each rotation and comparing it with best so far\\n            return lexicographicallySmallestRotatedSequence(S);\\n        else {\\n            /**\\n             Lets understand this case when we can choose any of the first k letter;\\n             lets take a example to understand:\\n             bdac ; k=2\\n             bdac, select d (second letter)\\n             bacd, select a (second letter)\\n             bcda, select b (first letter)\\n             cdab, select c (first letter)\\n             dabc, select d (first letter)\\n             abcd\\n\\n             So what we were essentially doing above? can you notice any pattern?\\n             Yes, we are somewhat sorting the letters, why? because we have capbability to push any\\n             first k character to end of the string.\\n             This makes generating all the combination/permutation of given string by choosing any of the                 first k letters.\\n             To understand better, please try k=3 in above example; you\\'ll notice in somewhat it won\\'t matter\\n             because at the end you\\'ll reach sorted order of chars to make smallest string\\n             **/\\n            char c[] = S.toCharArray();\\n            Arrays.sort(c);\\n            return new String(c);\\n        }\\n    }\\n\\n    /**\\n     * O(n^2 )\\n     *\\n     * @param str\\n     * @return\\n     */\\n    private String lexicographicallySmallestRotatedSequence(String str) {\\n        if (str == null || str.isEmpty())\\n            return str;\\n\\n        int smallestStringIndex = 0;\\n\\n        for (int i = 0; i < str.length(); i++) {\\n\\n            if (isSmallest(str, smallestStringIndex, i)) smallestStringIndex = i;\\n\\n        }\\n        if (smallestStringIndex == 0)\\n            return str;\\n\\n        return str.substring(smallestStringIndex) + str.substring(0, smallestStringIndex);\\n    }\\n\\n    /**\\n     * This guy makes things faster, notice it\\n     * if we use inbuilt string comparision, then it will iterate whole string regardless, but this will\\n     * throw answer as quick as possible\\n     * check string start from x and string start from y; find the smallest between them\\n     *\\n     * @param str\\n     * @param x\\n     * @param y\\n     * @return\\n     */\\n    private boolean isSmallest(String str, int x, int y) {\\n\\n        for (int i = 0; i < str.length(); i++) {\\n\\n            if (str.charAt(x) < str.charAt(y))\\n                return false;\\n\\n            if (str.charAt(x) > str.charAt(y))\\n                return true;\\n\\n            x = (x + 1) % str.length();\\n            y = (y + 1) % str.length();\\n\\n\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  public String orderlyQueue(String S, int K) {\\n        return beat100Percent(S, K);\\n\\n    }\\n\\n\\n    private String bitSlow(String S, int K) {\\n        if (K == 1) {\\n            String res = S;\\n            for (int i = 0; i < S.length(); ++i) {\\n                String t = S.substring(i) + S.substring(0, i);\\n                if (t.compareTo(res) < 0) res = t;\\n            }\\n            return res;\\n        } else {\\n            char[] ca = S.toCharArray();\\n            Arrays.sort(ca);\\n            return new String(ca);\\n        }\\n    }\\n\\n    private String beat100Percent(String S, int K) {\\n        if (S == null || S.isEmpty())\\n            return S;\\n\\n        if (K == 1)\\n            //This is nothing but finding the string after each rotation and comparing it with best so far\\n            return lexicographicallySmallestRotatedSequence(S);\\n        else {\\n            /**\\n             Lets understand this case when we can choose any of the first k letter;\\n             lets take a example to understand:\\n             bdac ; k=2\\n             bdac, select d (second letter)\\n             bacd, select a (second letter)\\n             bcda, select b (first letter)\\n             cdab, select c (first letter)\\n             dabc, select d (first letter)\\n             abcd\\n\\n             So what we were essentially doing above? can you notice any pattern?\\n             Yes, we are somewhat sorting the letters, why? because we have capbability to push any\\n             first k character to end of the string.\\n             This makes generating all the combination/permutation of given string by choosing any of the                 first k letters.\\n             To understand better, please try k=3 in above example; you\\'ll notice in somewhat it won\\'t matter\\n             because at the end you\\'ll reach sorted order of chars to make smallest string\\n             **/\\n            char c[] = S.toCharArray();\\n            Arrays.sort(c);\\n            return new String(c);\\n        }\\n    }\\n\\n    /**\\n     * O(n^2 )\\n     *\\n     * @param str\\n     * @return\\n     */\\n    private String lexicographicallySmallestRotatedSequence(String str) {\\n        if (str == null || str.isEmpty())\\n            return str;\\n\\n        int smallestStringIndex = 0;\\n\\n        for (int i = 0; i < str.length(); i++) {\\n\\n            if (isSmallest(str, smallestStringIndex, i)) smallestStringIndex = i;\\n\\n        }\\n        if (smallestStringIndex == 0)\\n            return str;\\n\\n        return str.substring(smallestStringIndex) + str.substring(0, smallestStringIndex);\\n    }\\n\\n    /**\\n     * This guy makes things faster, notice it\\n     * if we use inbuilt string comparision, then it will iterate whole string regardless, but this will\\n     * throw answer as quick as possible\\n     * check string start from x and string start from y; find the smallest between them\\n     *\\n     * @param str\\n     * @param x\\n     * @param y\\n     * @return\\n     */\\n    private boolean isSmallest(String str, int x, int y) {\\n\\n        for (int i = 0; i < str.length(); i++) {\\n\\n            if (str.charAt(x) < str.charAt(y))\\n                return false;\\n\\n            if (str.charAt(x) > str.charAt(y))\\n                return true;\\n\\n            x = (x + 1) % str.length();\\n            y = (y + 1) % str.length();\\n\\n\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 167251,
                "title": "2-lines-python-solution",
                "content": "```\\nclass Solution:\\n    def orderlyQueue(self, S, K):\\n        if K > 1: return \\'\\'.join(sorted(S))\\n        else: return \\'\\'.join(min([S[i:] + S[:i] for i in range(len(S))]))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def orderlyQueue(self, S, K):\\n        if K > 1: return \\'\\'.join(sorted(S))\\n        else: return \\'\\'.join(min([S[i:] + S[:i] for i in range(len(S))]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 165938,
                "title": "really-tricky",
                "content": "When `K > 1`, we can always get the maximum lexicographically order.\\n\\n```\\nclass Solution {\\n    public String orderlyQueue(String S, int K) {\\n        if (K == 1) {\\n            String result = S;\\n            for (int i = 1; i < S.length(); i++) {\\n                String temp = S.substring(i) + S.substring(0, i);\\n                if (temp.compareTo(result) < 0) {\\n                    result = temp;\\n                }\\n            }\\n            return result;\\n        } else {\\n            char[] cs = S.toCharArray();\\n            Arrays.sort(cs);\\n            return new String(cs);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String orderlyQueue(String S, int K) {\\n        if (K == 1) {\\n            String result = S;\\n            for (int i = 1; i < S.length(); i++) {\\n                String temp = S.substring(i) + S.substring(0, i);\\n                if (temp.compareTo(result) < 0) {\\n                    result = temp;\\n                }\\n            }\\n            return result;\\n        } else {\\n            char[] cs = S.toCharArray();\\n            Arrays.sort(cs);\\n            return new String(cs);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081230,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if (k == 1) {\\n            String result = s;\\n            StringBuilder sb = new StringBuilder(s);\\n            for (int i = 0; i < s.length() - 1; ++i) {\\n                sb.append(sb.charAt(0)).deleteCharAt(0);\\n                if (sb.toString().compareTo(result) < 0) {\\n                    result = sb.toString();\\n                }\\n            }\\n            return result;\\n        }\\n        char[] x = s.toCharArray();\\n        Arrays.sort(x);\\n        return String.valueOf(x);\\n    }\\n}\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        //if k>1 , sort the string \\n        if(k>1){\\n            sort(s.begin(),s.end()); \\n            return s;\\n        }\\n        string ans=s;\\n        int len=s.length();\\n        for(int i=0;i<len;i++)\\n        {\\n            s+=s[i]; //append char to the end\\n            string str=s.substr(i+1);\\n            if(str<ans) ans=str;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if (k == 1) {\\n            String result = s;\\n            StringBuilder sb = new StringBuilder(s);\\n            for (int i = 0; i < s.length() - 1; ++i) {\\n                sb.append(sb.charAt(0)).deleteCharAt(0);\\n                if (sb.toString().compareTo(result) < 0) {\\n                    result = sb.toString();\\n                }\\n            }\\n            return result;\\n        }\\n        char[] x = s.toCharArray();\\n        Arrays.sort(x);\\n        return String.valueOf(x);\\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        //if k>1 , sort the string \\n        if(k>1){\\n            sort(s.begin(),s.end()); \\n            return s;\\n        }\\n        string ans=s;\\n        int len=s.length();\\n        for(int i=0;i<len;i++)\\n        {\\n            s+=s[i]; //append char to the end\\n            string str=s.substr(i+1);\\n            if(str<ans) ans=str;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060643,
                "title": "easy-javascript-solution-with-line-by-line-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {string}\\n */\\nvar orderlyQueue = function (s, k) {\\n    // initialize string s to str\\n    let str = s;\\n\\n    // if k is equal to 1\\n    if (k === 1) {\\n\\n        // initialize length len to length of string s\\n        let len = s.length;\\n\\n        // loop through the 0 to length len\\n        for (let i = 0; i < len; i++) {\\n\\n            // initialize firstChar to the first character of string s\\n            let firstChar = s[0];\\n\\n            // copy all character of string s except first character using subString() and add first character at last and assign the string to s\\n            s = s.substring(1, len) + firstChar;\\n\\n            // if string s is less than string str then assign string s to string str\\n            if (s < str) {\\n                str = s;\\n            }\\n\\n        }\\n\\n        // return string str\\n        return str;\\n    }\\n\\n    // return sort value of string s by using split(), sort() and join()\\n    return s.split(\\'\\').sort().join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {string}\\n */\\nvar orderlyQueue = function (s, k) {\\n    // initialize string s to str\\n    let str = s;\\n\\n    // if k is equal to 1\\n    if (k === 1) {\\n\\n        // initialize length len to length of string s\\n        let len = s.length;\\n\\n        // loop through the 0 to length len\\n        for (let i = 0; i < len; i++) {\\n\\n            // initialize firstChar to the first character of string s\\n            let firstChar = s[0];\\n\\n            // copy all character of string s except first character using subString() and add first character at last and assign the string to s\\n            s = s.substring(1, len) + firstChar;\\n\\n            // if string s is less than string str then assign string s to string str\\n            if (s < str) {\\n                str = s;\\n            }\\n\\n        }\\n\\n        // return string str\\n        return str;\\n    }\\n\\n    // return sort value of string s by using split(), sort() and join()\\n    return s.split(\\'\\').sort().join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4016739,
                "title": "beats-100-easy-to-understand-c",
                "content": "This question can be solved by bifurcating it in 2 cases:\\n* When K = 1, then traverse the whole string removing the 1st element and appending it to the last. After each iteration compare the strings, the smallest lexicographically string would be our answer. \\n* For K > 1, You can always arrive at the sorted string. Think of it using an example. We can choose one of the first **k** letters of **s** and append it at the end of the string. We will always choose the smallest letter and append it to the end so that after the rotation it would become the first element. The string might take more than one pass to get sorted.\\n\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        int n = s.size();\\n        if(k > 1){\\n            sort(s.begin(), s.end());\\n            return s;\\n        }\\n        string ans = s;\\n        for(int i = 0; i < n; i++){\\n            char a = s[0];\\n            s.erase(s.begin());\\n            s += a;\\n            ans = min(ans, s);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nThanks for reading and Happy Coding!!!",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        int n = s.size();\\n        if(k > 1){\\n            sort(s.begin(), s.end());\\n            return s;\\n        }\\n        string ans = s;\\n        for(int i = 0; i < n; i++){\\n            char a = s[0];\\n            s.erase(s.begin());\\n            s += a;\\n            ans = min(ans, s);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929732,
                "title": "easy-to-get-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k>1){\\n        char []arr = s.toCharArray();\\n        Arrays.sort(arr);\\n        return String.valueOf(arr);\\n        }\\n            String str=s;\\n            for(int i=0;i<s.length();i++){\\n                String st=s.substring(i)+s.substring(0,i);\\n                if(str.compareTo(st)>0){\\n                    str=st;\\n                }\\n            }\\n        \\n\\n        return str;\\n    }\\n    \\n  \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k>1){\\n        char []arr = s.toCharArray();\\n        Arrays.sort(arr);\\n        return String.valueOf(arr);\\n        }\\n            String str=s;\\n            for(int i=0;i<s.length();i++){\\n                String st=s.substring(i)+s.substring(0,i);\\n                if(str.compareTo(st)>0){\\n                    str=st;\\n                }\\n            }\\n        \\n\\n        return str;\\n    }\\n    \\n  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866577,
                "title": "python-easy-solution",
                "content": "# Intuition\\nThink like selecting any two elements and sorting\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        # basically if we have k > 1 it means we have to sort the sting as final result after all\\n        # moveement will be same as sorting.\\n        # question can be also treated as swap any two elements\\n        s_list = list(s)\\n        if k > 1:\\n            s_list.sort()\\n            return \"\".join(s_list)\\n\\n        result = s\\n        if k == 1: # we have to move all the elements ony by one and return min of all\\n            for i in range(1,len(s)+1):\\n                temp_str = s[i:] + s[0:i]\\n                print(temp_str)\\n                result = min(result,temp_str)\\n                print\\n        return result\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def orderlyQueue(self, s: str, k: int) -> str:\\n        # basically if we have k > 1 it means we have to sort the sting as final result after all\\n        # moveement will be same as sorting.\\n        # question can be also treated as swap any two elements\\n        s_list = list(s)\\n        if k > 1:\\n            s_list.sort()\\n            return \"\".join(s_list)\\n\\n        result = s\\n        if k == 1: # we have to move all the elements ony by one and return min of all\\n            for i in range(1,len(s)+1):\\n                temp_str = s[i:] + s[0:i]\\n                print(temp_str)\\n                result = min(result,temp_str)\\n                print\\n        return result\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832074,
                "title": "java-easy-solution-beat-99",
                "content": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k>1)\\n        {\\n            char []dee = s.toCharArray();\\n            Arrays.sort(dee);\\n            return new String(dee);\\n        }\\n        String ans = s ;\\n        for(int i=0;i<s.length();i++)\\n        {\\n             s=s.substring(1)+s.substring(0,1);\\n            if(ans.compareTo(s)>0)\\n            {\\n                ans=s;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k>1)\\n        {\\n            char []dee = s.toCharArray();\\n            Arrays.sort(dee);\\n            return new String(dee);\\n        }\\n        String ans = s ;\\n        for(int i=0;i<s.length();i++)\\n        {\\n             s=s.substring(1)+s.substring(0,1);\\n            if(ans.compareTo(s)>0)\\n            {\\n                ans=s;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767461,
                "title": "ez-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k>1) {\\n            sort(s.begin(),s.end());\\n            return s;\\n        }\\n        string s_min = s;\\n        for(int i = 0 ;i<s.length();i++){\\n            s =  s.substr(1) + s[0];\\n            s_min = min(s_min,s);\\n        }\\n        return s_min;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string orderlyQueue(string s, int k) {\\n        if(k>1) {\\n            sort(s.begin(),s.end());\\n            return s;\\n        }\\n        string s_min = s;\\n        for(int i = 0 ;i<s.length();i++){\\n            s =  s.substr(1) + s[0];\\n            s_min = min(s_min,s);\\n        }\\n        return s_min;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764557,
                "title": "easy-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        \\n        if(k>1){\\n            char chararr[] = s.toCharArray();\\n            Arrays.sort(chararr);\\n            return new String(chararr);\\n        }\\n\\n        else{\\n            String str = s;\\n\\n            for(int i=0; i<s.length(); i++){\\n                s = s.substring(1) + s.substring(0,1);\\n                if(str.compareTo(s)>0){\\n                    str = s;\\n                }\\n            }\\n\\n            return str;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        \\n        if(k>1){\\n            char chararr[] = s.toCharArray();\\n            Arrays.sort(chararr);\\n            return new String(chararr);\\n        }\\n\\n        else{\\n            String str = s;\\n\\n            for(int i=0; i<s.length(); i++){\\n                s = s.substring(1) + s.substring(0,1);\\n                if(str.compareTo(s)>0){\\n                    str = s;\\n                }\\n            }\\n\\n            return str;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1673166,
                "content": [
                    {
                        "username": "cortexauth",
                        "content": "This had strong Codeforces vibe to it"
                    },
                    {
                        "username": "Ct-nep",
                        "content": "Is there any mathematical proof that the answer would always be lexicographically smallest (sorted) string if k > 1?"
                    },
                    {
                        "username": "JJATIN",
                        "content": "for k >1 its simply bubble sort"
                    },
                    {
                        "username": "supertaiyaki",
                        "content": "Hardly a proper proof but note that you can swap the two elements at the head of the string if k >= 2 (2nd element, 1st element, then take them in order until you get back to the start). You can also swap any arbitrary elements by rotating the string to the position you need, swapping, then rotating the rest of the way around. With those operations you can execute a bubble sort. It\\'s not too hard to verify the correctness of bubble sort if you want to go that far."
                    },
                    {
                        "username": "shabes",
                        "content": "It is relatively straightforward (no need for group theory :-)). We build the sorted string iteratively. At each iteration we start with smallest m characters sorted as a substring somewhere in our string (at the very first iteration we have m = 1 and it is a single smallest character somewhere). We will use position 0 as our \"storage\" for the next smallest character like this: cycle through the string by appending character from position 1 to the end (observe that this will not disturb our already sorted chain) until we see our target character (next smallest). Then we append character from position 0 to the end pushing our target into \"storage\". Now we cycle again by appending position 1 to the end until we line up our chain at the end of the string. Finally, we append character from storage to the end. Now we have m+1 sorted chain. Repeat until all characters are sorted."
                    },
                    {
                        "username": "narayan1281",
                        "content": "Yes!\\nSuppose s = \"zyxwonmab\" and k >1 (say k = 2)\\n// I would explain it using a priority_queue --> in fact a min heap priority_queue of size atmost k\\n// first push first k letters in priority_queue \\n// assume s1 = \"\"; --> temporary string to store result of first rotation\\n// take out the top of priority_queue (pq)\\ns1 = \"y\" and push next character in priority_queue --> pq = \"xz\"\\n// next-step\\ns1 = \"yx\" and pq = \"wz\"\\n// next step\\ns1 =\"yxw\" and pq = \"oz\"\\n// next\\ns1=\"yxwo\" and pq =\"nz\"\\n.\\n.\\n.\\ns1 =\"yxwonmab\" and pq=\"z\"\\n// next step\\ns1 =\"yxwonmabz\" and pq=\"\"--> empty as we have reached the end of first loop\\n\\n// From the above what we observe, in every full iteration of loop we put a \"largest value character\" at the end of the string\\n// so in we carry on the same looping process for n-1 number of times then what we would get is the \"sorted\" string and\\n// sorted string is indeed the lexicographically smallest permutation of s.\\n\\nI hope it helps. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I got to know about it when I was playing with the test cases. But if you really think if you have k>=2 then you can compare 2 elements and do work accordingly. And since there is no restriction on number of moves you will get to the sorted string eventually."
                    },
                    {
                        "username": "cortexauth",
                        "content": "Group theory talks about such permutations. We talk about cycles in this context, for example, a cycle (123..n) means send 1st element to nth position, send 2nd to 1st, 3rd to 2nd, and so on, in short, a left rotation. Moreover, we have a special cases such as transpositions , ex (12), which is basically a swap\\n\\nThese two are enough to generate any permutations for sequence of size 3\\n\\nI think there must be a more general proof as such.\\n\\nOnce done, we can argue that such moves can lead to any possible permutation of the elements, and even the sorted one, and hence the correctness proved"
                    },
                    {
                        "username": "votrubac",
                        "content": "I bet many people got a gist that you either sort or rotate. However, I did not expect a \"hard\" problem on LC to have a BF solution.\\n\\nSeeing this problme as \"hard\" sent me to a wrong direction. Was assigning \"hard\" intentional for these reasons? Or was it just a srew up on the admins\\' side?\\n\\nMy weakness is that I overcomplicate problems way too often, and I appreciate this learning  :) I think a better contents strategy would be to try a simple solution first. You can get in on luck, or you will get a good test case. The penalty for a wrong submission is 5 minutes, not 10 as it used to be :)"
                    },
                    {
                        "username": "Hrabesim",
                        "content": "It literary took me 2-3 minutes to code. :/"
                    },
                    {
                        "username": "AaveshK",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Could\\'ve been limited to premium users post the contest. "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I agree! I think this problem is a newly added problem in LC (looking at the solutions tab which has 513 solutions as of now - seasoned problems show 999+). \\n\\nSimilarly if we look at LeetCode 1128 (https://leetcode.com/problems/number-of-equivalent-domino-pairs/description/), it is categorized as Easy however it gives TLE on brute force solution and has a slightly trickier hashing logic to come up with for an easy problem. "
                    },
                    {
                        "username": "doggg2",
                        "content": "The key as discussed, is to observe that **when k = 2, it is possible to swap any two adjacent characters in the string**. To see why this is the case, consider any string s and any index i:\\n```s == s[0:i] + s[i] + s[i+1] + s[i + 2:]```\\n\\nThen we can swap i, i + 1 by doing these steps:\\n1. Keep putting the first character to the end until s[i] becomes the first character. Now we have a string ```s[i] + s[i+1] + s[i + 2:] + s[0:i]```\\n2. Put s[i] to the back. Now we have ```s[i + 1] + s[i+2:] + s[0:i] +s[i]```\\n3. Keep putting the second character to the end until s[i] becomes the second character. Now we have ```s[i+1] + s[i] + s[i + 2:] + s[0:i]```\\n4. Steps 2 and 3 have swapped i and i + 1. Now keep putting the first character to the back until we have ```s[0:i] + s[i + 1] + s[i] + s[i+2:]```\\n\\nIf you find this useful give an upvote."
                    },
                    {
                        "username": "happyleetcode",
                        "content": "Assume l is String length and  the target 2 chars\\' index is i and j. it should have 0<=i<j<l\\nso the structrue is that\\n[L] I [M] J [R]\\n[L] means the chars left to the I, the size of L shoule >=0\\n[M] means the chars between I and J, the size of M shoule >=0\\n[R] means the chars right to the J,the size of R shoule >=0\\nMOVE 1 means always move first char to the end\\nMOVE 2 means always move second char to the end.\\nthe target string should be  [L] J [M] I [R]\\n\\n\\tStep1. MOVE 1 until the string become      ** I  [M]  J  [R] [L]**\\n\\tStep2. MOVE 2 until the string become      ** I   J  [R] [L] [M]**\\n\\tStep3. MOVE 1 until the string become      ** J  [R] [L] [M]  I **\\n\\tStep4. MOVE 2 until the string become      ** J  [M]  I  [R] [L]**\\n\\tStep5. MOVE 1 until the string become      **[L]  J  [M]  I  [R]**"
                    },
                    {
                        "username": "Depender",
                        "content": "Initially I thought for some sorted rotatory arrangements but just realized it as a variation of bubble sort for k > 1. Hmm..! This was quite interesting and a bit confusing as well \\uD83D\\uDE05"
                    },
                    {
                        "username": "cpollock",
                        "content": "For test case 38, would not \"hntq\" be considered smaller than expected result \"htqn\"? My understanding of \"lexicographically smaller\" is the same as: https://en.wikipedia.org/wiki/Lexicographical_order\\n\\n![image](https://assets.leetcode.com/users/cpollock/image_1563820655.png)\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "with k==1 all you can do is rotate the string, so hntq is not possible"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "No matter how many times you rotate, you cannot change the order of h and n in this string with k=1. "
                    },
                    {
                        "username": "code_report",
                        "content": "Contest wouldn\\'t let me submit my solution for this problem."
                    },
                    {
                        "username": "khubaibalam2000",
                        "content": "Can someone tell me what is the time complexity of this solution?\n\n`class Solution:\n    def orderlyQueue(self, s: str, k: int) -> str:\n\n        queue = list(s)\n        if k > 1: \n            queue.sort()\n            return \"\".join((queue))\n        else:\n            uni = set()\n            uni.add(s)\n            for i in range(len(s)):\n                big = ''\n                big = max(big, s[0])\n                queue.remove(big)\n                queue.append(big)\n                temp = \"\".join(queue)\n                if temp not in uni:\n                    uni.add(temp)\n                    s = \"\".join(queue)\n                else: break\n        \n        words = list(uni)\n        words.sort()\n        return words[0]`\n"
                    },
                    {
                        "username": "bharatchauhan340",
                        "content": "How to solve ? if Any integer m is given denoting the maximum times this operation can be performed."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "if that is the case, then I think either the greedy way (which will not work) or just the recursion tbh exploring all ways"
                    }
                ]
            },
            {
                "id": 1673181,
                "content": [
                    {
                        "username": "cortexauth",
                        "content": "This had strong Codeforces vibe to it"
                    },
                    {
                        "username": "Ct-nep",
                        "content": "Is there any mathematical proof that the answer would always be lexicographically smallest (sorted) string if k > 1?"
                    },
                    {
                        "username": "JJATIN",
                        "content": "for k >1 its simply bubble sort"
                    },
                    {
                        "username": "supertaiyaki",
                        "content": "Hardly a proper proof but note that you can swap the two elements at the head of the string if k >= 2 (2nd element, 1st element, then take them in order until you get back to the start). You can also swap any arbitrary elements by rotating the string to the position you need, swapping, then rotating the rest of the way around. With those operations you can execute a bubble sort. It\\'s not too hard to verify the correctness of bubble sort if you want to go that far."
                    },
                    {
                        "username": "shabes",
                        "content": "It is relatively straightforward (no need for group theory :-)). We build the sorted string iteratively. At each iteration we start with smallest m characters sorted as a substring somewhere in our string (at the very first iteration we have m = 1 and it is a single smallest character somewhere). We will use position 0 as our \"storage\" for the next smallest character like this: cycle through the string by appending character from position 1 to the end (observe that this will not disturb our already sorted chain) until we see our target character (next smallest). Then we append character from position 0 to the end pushing our target into \"storage\". Now we cycle again by appending position 1 to the end until we line up our chain at the end of the string. Finally, we append character from storage to the end. Now we have m+1 sorted chain. Repeat until all characters are sorted."
                    },
                    {
                        "username": "narayan1281",
                        "content": "Yes!\\nSuppose s = \"zyxwonmab\" and k >1 (say k = 2)\\n// I would explain it using a priority_queue --> in fact a min heap priority_queue of size atmost k\\n// first push first k letters in priority_queue \\n// assume s1 = \"\"; --> temporary string to store result of first rotation\\n// take out the top of priority_queue (pq)\\ns1 = \"y\" and push next character in priority_queue --> pq = \"xz\"\\n// next-step\\ns1 = \"yx\" and pq = \"wz\"\\n// next step\\ns1 =\"yxw\" and pq = \"oz\"\\n// next\\ns1=\"yxwo\" and pq =\"nz\"\\n.\\n.\\n.\\ns1 =\"yxwonmab\" and pq=\"z\"\\n// next step\\ns1 =\"yxwonmabz\" and pq=\"\"--> empty as we have reached the end of first loop\\n\\n// From the above what we observe, in every full iteration of loop we put a \"largest value character\" at the end of the string\\n// so in we carry on the same looping process for n-1 number of times then what we would get is the \"sorted\" string and\\n// sorted string is indeed the lexicographically smallest permutation of s.\\n\\nI hope it helps. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I got to know about it when I was playing with the test cases. But if you really think if you have k>=2 then you can compare 2 elements and do work accordingly. And since there is no restriction on number of moves you will get to the sorted string eventually."
                    },
                    {
                        "username": "cortexauth",
                        "content": "Group theory talks about such permutations. We talk about cycles in this context, for example, a cycle (123..n) means send 1st element to nth position, send 2nd to 1st, 3rd to 2nd, and so on, in short, a left rotation. Moreover, we have a special cases such as transpositions , ex (12), which is basically a swap\\n\\nThese two are enough to generate any permutations for sequence of size 3\\n\\nI think there must be a more general proof as such.\\n\\nOnce done, we can argue that such moves can lead to any possible permutation of the elements, and even the sorted one, and hence the correctness proved"
                    },
                    {
                        "username": "votrubac",
                        "content": "I bet many people got a gist that you either sort or rotate. However, I did not expect a \"hard\" problem on LC to have a BF solution.\\n\\nSeeing this problme as \"hard\" sent me to a wrong direction. Was assigning \"hard\" intentional for these reasons? Or was it just a srew up on the admins\\' side?\\n\\nMy weakness is that I overcomplicate problems way too often, and I appreciate this learning  :) I think a better contents strategy would be to try a simple solution first. You can get in on luck, or you will get a good test case. The penalty for a wrong submission is 5 minutes, not 10 as it used to be :)"
                    },
                    {
                        "username": "Hrabesim",
                        "content": "It literary took me 2-3 minutes to code. :/"
                    },
                    {
                        "username": "AaveshK",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Could\\'ve been limited to premium users post the contest. "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I agree! I think this problem is a newly added problem in LC (looking at the solutions tab which has 513 solutions as of now - seasoned problems show 999+). \\n\\nSimilarly if we look at LeetCode 1128 (https://leetcode.com/problems/number-of-equivalent-domino-pairs/description/), it is categorized as Easy however it gives TLE on brute force solution and has a slightly trickier hashing logic to come up with for an easy problem. "
                    },
                    {
                        "username": "doggg2",
                        "content": "The key as discussed, is to observe that **when k = 2, it is possible to swap any two adjacent characters in the string**. To see why this is the case, consider any string s and any index i:\\n```s == s[0:i] + s[i] + s[i+1] + s[i + 2:]```\\n\\nThen we can swap i, i + 1 by doing these steps:\\n1. Keep putting the first character to the end until s[i] becomes the first character. Now we have a string ```s[i] + s[i+1] + s[i + 2:] + s[0:i]```\\n2. Put s[i] to the back. Now we have ```s[i + 1] + s[i+2:] + s[0:i] +s[i]```\\n3. Keep putting the second character to the end until s[i] becomes the second character. Now we have ```s[i+1] + s[i] + s[i + 2:] + s[0:i]```\\n4. Steps 2 and 3 have swapped i and i + 1. Now keep putting the first character to the back until we have ```s[0:i] + s[i + 1] + s[i] + s[i+2:]```\\n\\nIf you find this useful give an upvote."
                    },
                    {
                        "username": "happyleetcode",
                        "content": "Assume l is String length and  the target 2 chars\\' index is i and j. it should have 0<=i<j<l\\nso the structrue is that\\n[L] I [M] J [R]\\n[L] means the chars left to the I, the size of L shoule >=0\\n[M] means the chars between I and J, the size of M shoule >=0\\n[R] means the chars right to the J,the size of R shoule >=0\\nMOVE 1 means always move first char to the end\\nMOVE 2 means always move second char to the end.\\nthe target string should be  [L] J [M] I [R]\\n\\n\\tStep1. MOVE 1 until the string become      ** I  [M]  J  [R] [L]**\\n\\tStep2. MOVE 2 until the string become      ** I   J  [R] [L] [M]**\\n\\tStep3. MOVE 1 until the string become      ** J  [R] [L] [M]  I **\\n\\tStep4. MOVE 2 until the string become      ** J  [M]  I  [R] [L]**\\n\\tStep5. MOVE 1 until the string become      **[L]  J  [M]  I  [R]**"
                    },
                    {
                        "username": "Depender",
                        "content": "Initially I thought for some sorted rotatory arrangements but just realized it as a variation of bubble sort for k > 1. Hmm..! This was quite interesting and a bit confusing as well \\uD83D\\uDE05"
                    },
                    {
                        "username": "cpollock",
                        "content": "For test case 38, would not \"hntq\" be considered smaller than expected result \"htqn\"? My understanding of \"lexicographically smaller\" is the same as: https://en.wikipedia.org/wiki/Lexicographical_order\\n\\n![image](https://assets.leetcode.com/users/cpollock/image_1563820655.png)\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "with k==1 all you can do is rotate the string, so hntq is not possible"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "No matter how many times you rotate, you cannot change the order of h and n in this string with k=1. "
                    },
                    {
                        "username": "code_report",
                        "content": "Contest wouldn\\'t let me submit my solution for this problem."
                    },
                    {
                        "username": "khubaibalam2000",
                        "content": "Can someone tell me what is the time complexity of this solution?\n\n`class Solution:\n    def orderlyQueue(self, s: str, k: int) -> str:\n\n        queue = list(s)\n        if k > 1: \n            queue.sort()\n            return \"\".join((queue))\n        else:\n            uni = set()\n            uni.add(s)\n            for i in range(len(s)):\n                big = ''\n                big = max(big, s[0])\n                queue.remove(big)\n                queue.append(big)\n                temp = \"\".join(queue)\n                if temp not in uni:\n                    uni.add(temp)\n                    s = \"\".join(queue)\n                else: break\n        \n        words = list(uni)\n        words.sort()\n        return words[0]`\n"
                    },
                    {
                        "username": "bharatchauhan340",
                        "content": "How to solve ? if Any integer m is given denoting the maximum times this operation can be performed."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "if that is the case, then I think either the greedy way (which will not work) or just the recursion tbh exploring all ways"
                    }
                ]
            },
            {
                "id": 1572119,
                "content": [
                    {
                        "username": "cortexauth",
                        "content": "This had strong Codeforces vibe to it"
                    },
                    {
                        "username": "Ct-nep",
                        "content": "Is there any mathematical proof that the answer would always be lexicographically smallest (sorted) string if k > 1?"
                    },
                    {
                        "username": "JJATIN",
                        "content": "for k >1 its simply bubble sort"
                    },
                    {
                        "username": "supertaiyaki",
                        "content": "Hardly a proper proof but note that you can swap the two elements at the head of the string if k >= 2 (2nd element, 1st element, then take them in order until you get back to the start). You can also swap any arbitrary elements by rotating the string to the position you need, swapping, then rotating the rest of the way around. With those operations you can execute a bubble sort. It\\'s not too hard to verify the correctness of bubble sort if you want to go that far."
                    },
                    {
                        "username": "shabes",
                        "content": "It is relatively straightforward (no need for group theory :-)). We build the sorted string iteratively. At each iteration we start with smallest m characters sorted as a substring somewhere in our string (at the very first iteration we have m = 1 and it is a single smallest character somewhere). We will use position 0 as our \"storage\" for the next smallest character like this: cycle through the string by appending character from position 1 to the end (observe that this will not disturb our already sorted chain) until we see our target character (next smallest). Then we append character from position 0 to the end pushing our target into \"storage\". Now we cycle again by appending position 1 to the end until we line up our chain at the end of the string. Finally, we append character from storage to the end. Now we have m+1 sorted chain. Repeat until all characters are sorted."
                    },
                    {
                        "username": "narayan1281",
                        "content": "Yes!\\nSuppose s = \"zyxwonmab\" and k >1 (say k = 2)\\n// I would explain it using a priority_queue --> in fact a min heap priority_queue of size atmost k\\n// first push first k letters in priority_queue \\n// assume s1 = \"\"; --> temporary string to store result of first rotation\\n// take out the top of priority_queue (pq)\\ns1 = \"y\" and push next character in priority_queue --> pq = \"xz\"\\n// next-step\\ns1 = \"yx\" and pq = \"wz\"\\n// next step\\ns1 =\"yxw\" and pq = \"oz\"\\n// next\\ns1=\"yxwo\" and pq =\"nz\"\\n.\\n.\\n.\\ns1 =\"yxwonmab\" and pq=\"z\"\\n// next step\\ns1 =\"yxwonmabz\" and pq=\"\"--> empty as we have reached the end of first loop\\n\\n// From the above what we observe, in every full iteration of loop we put a \"largest value character\" at the end of the string\\n// so in we carry on the same looping process for n-1 number of times then what we would get is the \"sorted\" string and\\n// sorted string is indeed the lexicographically smallest permutation of s.\\n\\nI hope it helps. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I got to know about it when I was playing with the test cases. But if you really think if you have k>=2 then you can compare 2 elements and do work accordingly. And since there is no restriction on number of moves you will get to the sorted string eventually."
                    },
                    {
                        "username": "cortexauth",
                        "content": "Group theory talks about such permutations. We talk about cycles in this context, for example, a cycle (123..n) means send 1st element to nth position, send 2nd to 1st, 3rd to 2nd, and so on, in short, a left rotation. Moreover, we have a special cases such as transpositions , ex (12), which is basically a swap\\n\\nThese two are enough to generate any permutations for sequence of size 3\\n\\nI think there must be a more general proof as such.\\n\\nOnce done, we can argue that such moves can lead to any possible permutation of the elements, and even the sorted one, and hence the correctness proved"
                    },
                    {
                        "username": "votrubac",
                        "content": "I bet many people got a gist that you either sort or rotate. However, I did not expect a \"hard\" problem on LC to have a BF solution.\\n\\nSeeing this problme as \"hard\" sent me to a wrong direction. Was assigning \"hard\" intentional for these reasons? Or was it just a srew up on the admins\\' side?\\n\\nMy weakness is that I overcomplicate problems way too often, and I appreciate this learning  :) I think a better contents strategy would be to try a simple solution first. You can get in on luck, or you will get a good test case. The penalty for a wrong submission is 5 minutes, not 10 as it used to be :)"
                    },
                    {
                        "username": "Hrabesim",
                        "content": "It literary took me 2-3 minutes to code. :/"
                    },
                    {
                        "username": "AaveshK",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Could\\'ve been limited to premium users post the contest. "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I agree! I think this problem is a newly added problem in LC (looking at the solutions tab which has 513 solutions as of now - seasoned problems show 999+). \\n\\nSimilarly if we look at LeetCode 1128 (https://leetcode.com/problems/number-of-equivalent-domino-pairs/description/), it is categorized as Easy however it gives TLE on brute force solution and has a slightly trickier hashing logic to come up with for an easy problem. "
                    },
                    {
                        "username": "doggg2",
                        "content": "The key as discussed, is to observe that **when k = 2, it is possible to swap any two adjacent characters in the string**. To see why this is the case, consider any string s and any index i:\\n```s == s[0:i] + s[i] + s[i+1] + s[i + 2:]```\\n\\nThen we can swap i, i + 1 by doing these steps:\\n1. Keep putting the first character to the end until s[i] becomes the first character. Now we have a string ```s[i] + s[i+1] + s[i + 2:] + s[0:i]```\\n2. Put s[i] to the back. Now we have ```s[i + 1] + s[i+2:] + s[0:i] +s[i]```\\n3. Keep putting the second character to the end until s[i] becomes the second character. Now we have ```s[i+1] + s[i] + s[i + 2:] + s[0:i]```\\n4. Steps 2 and 3 have swapped i and i + 1. Now keep putting the first character to the back until we have ```s[0:i] + s[i + 1] + s[i] + s[i+2:]```\\n\\nIf you find this useful give an upvote."
                    },
                    {
                        "username": "happyleetcode",
                        "content": "Assume l is String length and  the target 2 chars\\' index is i and j. it should have 0<=i<j<l\\nso the structrue is that\\n[L] I [M] J [R]\\n[L] means the chars left to the I, the size of L shoule >=0\\n[M] means the chars between I and J, the size of M shoule >=0\\n[R] means the chars right to the J,the size of R shoule >=0\\nMOVE 1 means always move first char to the end\\nMOVE 2 means always move second char to the end.\\nthe target string should be  [L] J [M] I [R]\\n\\n\\tStep1. MOVE 1 until the string become      ** I  [M]  J  [R] [L]**\\n\\tStep2. MOVE 2 until the string become      ** I   J  [R] [L] [M]**\\n\\tStep3. MOVE 1 until the string become      ** J  [R] [L] [M]  I **\\n\\tStep4. MOVE 2 until the string become      ** J  [M]  I  [R] [L]**\\n\\tStep5. MOVE 1 until the string become      **[L]  J  [M]  I  [R]**"
                    },
                    {
                        "username": "Depender",
                        "content": "Initially I thought for some sorted rotatory arrangements but just realized it as a variation of bubble sort for k > 1. Hmm..! This was quite interesting and a bit confusing as well \\uD83D\\uDE05"
                    },
                    {
                        "username": "cpollock",
                        "content": "For test case 38, would not \"hntq\" be considered smaller than expected result \"htqn\"? My understanding of \"lexicographically smaller\" is the same as: https://en.wikipedia.org/wiki/Lexicographical_order\\n\\n![image](https://assets.leetcode.com/users/cpollock/image_1563820655.png)\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "with k==1 all you can do is rotate the string, so hntq is not possible"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "No matter how many times you rotate, you cannot change the order of h and n in this string with k=1. "
                    },
                    {
                        "username": "code_report",
                        "content": "Contest wouldn\\'t let me submit my solution for this problem."
                    },
                    {
                        "username": "khubaibalam2000",
                        "content": "Can someone tell me what is the time complexity of this solution?\n\n`class Solution:\n    def orderlyQueue(self, s: str, k: int) -> str:\n\n        queue = list(s)\n        if k > 1: \n            queue.sort()\n            return \"\".join((queue))\n        else:\n            uni = set()\n            uni.add(s)\n            for i in range(len(s)):\n                big = ''\n                big = max(big, s[0])\n                queue.remove(big)\n                queue.append(big)\n                temp = \"\".join(queue)\n                if temp not in uni:\n                    uni.add(temp)\n                    s = \"\".join(queue)\n                else: break\n        \n        words = list(uni)\n        words.sort()\n        return words[0]`\n"
                    },
                    {
                        "username": "bharatchauhan340",
                        "content": "How to solve ? if Any integer m is given denoting the maximum times this operation can be performed."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "if that is the case, then I think either the greedy way (which will not work) or just the recursion tbh exploring all ways"
                    }
                ]
            },
            {
                "id": 1674194,
                "content": [
                    {
                        "username": "cortexauth",
                        "content": "This had strong Codeforces vibe to it"
                    },
                    {
                        "username": "Ct-nep",
                        "content": "Is there any mathematical proof that the answer would always be lexicographically smallest (sorted) string if k > 1?"
                    },
                    {
                        "username": "JJATIN",
                        "content": "for k >1 its simply bubble sort"
                    },
                    {
                        "username": "supertaiyaki",
                        "content": "Hardly a proper proof but note that you can swap the two elements at the head of the string if k >= 2 (2nd element, 1st element, then take them in order until you get back to the start). You can also swap any arbitrary elements by rotating the string to the position you need, swapping, then rotating the rest of the way around. With those operations you can execute a bubble sort. It\\'s not too hard to verify the correctness of bubble sort if you want to go that far."
                    },
                    {
                        "username": "shabes",
                        "content": "It is relatively straightforward (no need for group theory :-)). We build the sorted string iteratively. At each iteration we start with smallest m characters sorted as a substring somewhere in our string (at the very first iteration we have m = 1 and it is a single smallest character somewhere). We will use position 0 as our \"storage\" for the next smallest character like this: cycle through the string by appending character from position 1 to the end (observe that this will not disturb our already sorted chain) until we see our target character (next smallest). Then we append character from position 0 to the end pushing our target into \"storage\". Now we cycle again by appending position 1 to the end until we line up our chain at the end of the string. Finally, we append character from storage to the end. Now we have m+1 sorted chain. Repeat until all characters are sorted."
                    },
                    {
                        "username": "narayan1281",
                        "content": "Yes!\\nSuppose s = \"zyxwonmab\" and k >1 (say k = 2)\\n// I would explain it using a priority_queue --> in fact a min heap priority_queue of size atmost k\\n// first push first k letters in priority_queue \\n// assume s1 = \"\"; --> temporary string to store result of first rotation\\n// take out the top of priority_queue (pq)\\ns1 = \"y\" and push next character in priority_queue --> pq = \"xz\"\\n// next-step\\ns1 = \"yx\" and pq = \"wz\"\\n// next step\\ns1 =\"yxw\" and pq = \"oz\"\\n// next\\ns1=\"yxwo\" and pq =\"nz\"\\n.\\n.\\n.\\ns1 =\"yxwonmab\" and pq=\"z\"\\n// next step\\ns1 =\"yxwonmabz\" and pq=\"\"--> empty as we have reached the end of first loop\\n\\n// From the above what we observe, in every full iteration of loop we put a \"largest value character\" at the end of the string\\n// so in we carry on the same looping process for n-1 number of times then what we would get is the \"sorted\" string and\\n// sorted string is indeed the lexicographically smallest permutation of s.\\n\\nI hope it helps. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I got to know about it when I was playing with the test cases. But if you really think if you have k>=2 then you can compare 2 elements and do work accordingly. And since there is no restriction on number of moves you will get to the sorted string eventually."
                    },
                    {
                        "username": "cortexauth",
                        "content": "Group theory talks about such permutations. We talk about cycles in this context, for example, a cycle (123..n) means send 1st element to nth position, send 2nd to 1st, 3rd to 2nd, and so on, in short, a left rotation. Moreover, we have a special cases such as transpositions , ex (12), which is basically a swap\\n\\nThese two are enough to generate any permutations for sequence of size 3\\n\\nI think there must be a more general proof as such.\\n\\nOnce done, we can argue that such moves can lead to any possible permutation of the elements, and even the sorted one, and hence the correctness proved"
                    },
                    {
                        "username": "votrubac",
                        "content": "I bet many people got a gist that you either sort or rotate. However, I did not expect a \"hard\" problem on LC to have a BF solution.\\n\\nSeeing this problme as \"hard\" sent me to a wrong direction. Was assigning \"hard\" intentional for these reasons? Or was it just a srew up on the admins\\' side?\\n\\nMy weakness is that I overcomplicate problems way too often, and I appreciate this learning  :) I think a better contents strategy would be to try a simple solution first. You can get in on luck, or you will get a good test case. The penalty for a wrong submission is 5 minutes, not 10 as it used to be :)"
                    },
                    {
                        "username": "Hrabesim",
                        "content": "It literary took me 2-3 minutes to code. :/"
                    },
                    {
                        "username": "AaveshK",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Could\\'ve been limited to premium users post the contest. "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I agree! I think this problem is a newly added problem in LC (looking at the solutions tab which has 513 solutions as of now - seasoned problems show 999+). \\n\\nSimilarly if we look at LeetCode 1128 (https://leetcode.com/problems/number-of-equivalent-domino-pairs/description/), it is categorized as Easy however it gives TLE on brute force solution and has a slightly trickier hashing logic to come up with for an easy problem. "
                    },
                    {
                        "username": "doggg2",
                        "content": "The key as discussed, is to observe that **when k = 2, it is possible to swap any two adjacent characters in the string**. To see why this is the case, consider any string s and any index i:\\n```s == s[0:i] + s[i] + s[i+1] + s[i + 2:]```\\n\\nThen we can swap i, i + 1 by doing these steps:\\n1. Keep putting the first character to the end until s[i] becomes the first character. Now we have a string ```s[i] + s[i+1] + s[i + 2:] + s[0:i]```\\n2. Put s[i] to the back. Now we have ```s[i + 1] + s[i+2:] + s[0:i] +s[i]```\\n3. Keep putting the second character to the end until s[i] becomes the second character. Now we have ```s[i+1] + s[i] + s[i + 2:] + s[0:i]```\\n4. Steps 2 and 3 have swapped i and i + 1. Now keep putting the first character to the back until we have ```s[0:i] + s[i + 1] + s[i] + s[i+2:]```\\n\\nIf you find this useful give an upvote."
                    },
                    {
                        "username": "happyleetcode",
                        "content": "Assume l is String length and  the target 2 chars\\' index is i and j. it should have 0<=i<j<l\\nso the structrue is that\\n[L] I [M] J [R]\\n[L] means the chars left to the I, the size of L shoule >=0\\n[M] means the chars between I and J, the size of M shoule >=0\\n[R] means the chars right to the J,the size of R shoule >=0\\nMOVE 1 means always move first char to the end\\nMOVE 2 means always move second char to the end.\\nthe target string should be  [L] J [M] I [R]\\n\\n\\tStep1. MOVE 1 until the string become      ** I  [M]  J  [R] [L]**\\n\\tStep2. MOVE 2 until the string become      ** I   J  [R] [L] [M]**\\n\\tStep3. MOVE 1 until the string become      ** J  [R] [L] [M]  I **\\n\\tStep4. MOVE 2 until the string become      ** J  [M]  I  [R] [L]**\\n\\tStep5. MOVE 1 until the string become      **[L]  J  [M]  I  [R]**"
                    },
                    {
                        "username": "Depender",
                        "content": "Initially I thought for some sorted rotatory arrangements but just realized it as a variation of bubble sort for k > 1. Hmm..! This was quite interesting and a bit confusing as well \\uD83D\\uDE05"
                    },
                    {
                        "username": "cpollock",
                        "content": "For test case 38, would not \"hntq\" be considered smaller than expected result \"htqn\"? My understanding of \"lexicographically smaller\" is the same as: https://en.wikipedia.org/wiki/Lexicographical_order\\n\\n![image](https://assets.leetcode.com/users/cpollock/image_1563820655.png)\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "with k==1 all you can do is rotate the string, so hntq is not possible"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "No matter how many times you rotate, you cannot change the order of h and n in this string with k=1. "
                    },
                    {
                        "username": "code_report",
                        "content": "Contest wouldn\\'t let me submit my solution for this problem."
                    },
                    {
                        "username": "khubaibalam2000",
                        "content": "Can someone tell me what is the time complexity of this solution?\n\n`class Solution:\n    def orderlyQueue(self, s: str, k: int) -> str:\n\n        queue = list(s)\n        if k > 1: \n            queue.sort()\n            return \"\".join((queue))\n        else:\n            uni = set()\n            uni.add(s)\n            for i in range(len(s)):\n                big = ''\n                big = max(big, s[0])\n                queue.remove(big)\n                queue.append(big)\n                temp = \"\".join(queue)\n                if temp not in uni:\n                    uni.add(temp)\n                    s = \"\".join(queue)\n                else: break\n        \n        words = list(uni)\n        words.sort()\n        return words[0]`\n"
                    },
                    {
                        "username": "bharatchauhan340",
                        "content": "How to solve ? if Any integer m is given denoting the maximum times this operation can be performed."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "if that is the case, then I think either the greedy way (which will not work) or just the recursion tbh exploring all ways"
                    }
                ]
            },
            {
                "id": 1569287,
                "content": [
                    {
                        "username": "cortexauth",
                        "content": "This had strong Codeforces vibe to it"
                    },
                    {
                        "username": "Ct-nep",
                        "content": "Is there any mathematical proof that the answer would always be lexicographically smallest (sorted) string if k > 1?"
                    },
                    {
                        "username": "JJATIN",
                        "content": "for k >1 its simply bubble sort"
                    },
                    {
                        "username": "supertaiyaki",
                        "content": "Hardly a proper proof but note that you can swap the two elements at the head of the string if k >= 2 (2nd element, 1st element, then take them in order until you get back to the start). You can also swap any arbitrary elements by rotating the string to the position you need, swapping, then rotating the rest of the way around. With those operations you can execute a bubble sort. It\\'s not too hard to verify the correctness of bubble sort if you want to go that far."
                    },
                    {
                        "username": "shabes",
                        "content": "It is relatively straightforward (no need for group theory :-)). We build the sorted string iteratively. At each iteration we start with smallest m characters sorted as a substring somewhere in our string (at the very first iteration we have m = 1 and it is a single smallest character somewhere). We will use position 0 as our \"storage\" for the next smallest character like this: cycle through the string by appending character from position 1 to the end (observe that this will not disturb our already sorted chain) until we see our target character (next smallest). Then we append character from position 0 to the end pushing our target into \"storage\". Now we cycle again by appending position 1 to the end until we line up our chain at the end of the string. Finally, we append character from storage to the end. Now we have m+1 sorted chain. Repeat until all characters are sorted."
                    },
                    {
                        "username": "narayan1281",
                        "content": "Yes!\\nSuppose s = \"zyxwonmab\" and k >1 (say k = 2)\\n// I would explain it using a priority_queue --> in fact a min heap priority_queue of size atmost k\\n// first push first k letters in priority_queue \\n// assume s1 = \"\"; --> temporary string to store result of first rotation\\n// take out the top of priority_queue (pq)\\ns1 = \"y\" and push next character in priority_queue --> pq = \"xz\"\\n// next-step\\ns1 = \"yx\" and pq = \"wz\"\\n// next step\\ns1 =\"yxw\" and pq = \"oz\"\\n// next\\ns1=\"yxwo\" and pq =\"nz\"\\n.\\n.\\n.\\ns1 =\"yxwonmab\" and pq=\"z\"\\n// next step\\ns1 =\"yxwonmabz\" and pq=\"\"--> empty as we have reached the end of first loop\\n\\n// From the above what we observe, in every full iteration of loop we put a \"largest value character\" at the end of the string\\n// so in we carry on the same looping process for n-1 number of times then what we would get is the \"sorted\" string and\\n// sorted string is indeed the lexicographically smallest permutation of s.\\n\\nI hope it helps. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I got to know about it when I was playing with the test cases. But if you really think if you have k>=2 then you can compare 2 elements and do work accordingly. And since there is no restriction on number of moves you will get to the sorted string eventually."
                    },
                    {
                        "username": "cortexauth",
                        "content": "Group theory talks about such permutations. We talk about cycles in this context, for example, a cycle (123..n) means send 1st element to nth position, send 2nd to 1st, 3rd to 2nd, and so on, in short, a left rotation. Moreover, we have a special cases such as transpositions , ex (12), which is basically a swap\\n\\nThese two are enough to generate any permutations for sequence of size 3\\n\\nI think there must be a more general proof as such.\\n\\nOnce done, we can argue that such moves can lead to any possible permutation of the elements, and even the sorted one, and hence the correctness proved"
                    },
                    {
                        "username": "votrubac",
                        "content": "I bet many people got a gist that you either sort or rotate. However, I did not expect a \"hard\" problem on LC to have a BF solution.\\n\\nSeeing this problme as \"hard\" sent me to a wrong direction. Was assigning \"hard\" intentional for these reasons? Or was it just a srew up on the admins\\' side?\\n\\nMy weakness is that I overcomplicate problems way too often, and I appreciate this learning  :) I think a better contents strategy would be to try a simple solution first. You can get in on luck, or you will get a good test case. The penalty for a wrong submission is 5 minutes, not 10 as it used to be :)"
                    },
                    {
                        "username": "Hrabesim",
                        "content": "It literary took me 2-3 minutes to code. :/"
                    },
                    {
                        "username": "AaveshK",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Could\\'ve been limited to premium users post the contest. "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I agree! I think this problem is a newly added problem in LC (looking at the solutions tab which has 513 solutions as of now - seasoned problems show 999+). \\n\\nSimilarly if we look at LeetCode 1128 (https://leetcode.com/problems/number-of-equivalent-domino-pairs/description/), it is categorized as Easy however it gives TLE on brute force solution and has a slightly trickier hashing logic to come up with for an easy problem. "
                    },
                    {
                        "username": "doggg2",
                        "content": "The key as discussed, is to observe that **when k = 2, it is possible to swap any two adjacent characters in the string**. To see why this is the case, consider any string s and any index i:\\n```s == s[0:i] + s[i] + s[i+1] + s[i + 2:]```\\n\\nThen we can swap i, i + 1 by doing these steps:\\n1. Keep putting the first character to the end until s[i] becomes the first character. Now we have a string ```s[i] + s[i+1] + s[i + 2:] + s[0:i]```\\n2. Put s[i] to the back. Now we have ```s[i + 1] + s[i+2:] + s[0:i] +s[i]```\\n3. Keep putting the second character to the end until s[i] becomes the second character. Now we have ```s[i+1] + s[i] + s[i + 2:] + s[0:i]```\\n4. Steps 2 and 3 have swapped i and i + 1. Now keep putting the first character to the back until we have ```s[0:i] + s[i + 1] + s[i] + s[i+2:]```\\n\\nIf you find this useful give an upvote."
                    },
                    {
                        "username": "happyleetcode",
                        "content": "Assume l is String length and  the target 2 chars\\' index is i and j. it should have 0<=i<j<l\\nso the structrue is that\\n[L] I [M] J [R]\\n[L] means the chars left to the I, the size of L shoule >=0\\n[M] means the chars between I and J, the size of M shoule >=0\\n[R] means the chars right to the J,the size of R shoule >=0\\nMOVE 1 means always move first char to the end\\nMOVE 2 means always move second char to the end.\\nthe target string should be  [L] J [M] I [R]\\n\\n\\tStep1. MOVE 1 until the string become      ** I  [M]  J  [R] [L]**\\n\\tStep2. MOVE 2 until the string become      ** I   J  [R] [L] [M]**\\n\\tStep3. MOVE 1 until the string become      ** J  [R] [L] [M]  I **\\n\\tStep4. MOVE 2 until the string become      ** J  [M]  I  [R] [L]**\\n\\tStep5. MOVE 1 until the string become      **[L]  J  [M]  I  [R]**"
                    },
                    {
                        "username": "Depender",
                        "content": "Initially I thought for some sorted rotatory arrangements but just realized it as a variation of bubble sort for k > 1. Hmm..! This was quite interesting and a bit confusing as well \\uD83D\\uDE05"
                    },
                    {
                        "username": "cpollock",
                        "content": "For test case 38, would not \"hntq\" be considered smaller than expected result \"htqn\"? My understanding of \"lexicographically smaller\" is the same as: https://en.wikipedia.org/wiki/Lexicographical_order\\n\\n![image](https://assets.leetcode.com/users/cpollock/image_1563820655.png)\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "with k==1 all you can do is rotate the string, so hntq is not possible"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "No matter how many times you rotate, you cannot change the order of h and n in this string with k=1. "
                    },
                    {
                        "username": "code_report",
                        "content": "Contest wouldn\\'t let me submit my solution for this problem."
                    },
                    {
                        "username": "khubaibalam2000",
                        "content": "Can someone tell me what is the time complexity of this solution?\n\n`class Solution:\n    def orderlyQueue(self, s: str, k: int) -> str:\n\n        queue = list(s)\n        if k > 1: \n            queue.sort()\n            return \"\".join((queue))\n        else:\n            uni = set()\n            uni.add(s)\n            for i in range(len(s)):\n                big = ''\n                big = max(big, s[0])\n                queue.remove(big)\n                queue.append(big)\n                temp = \"\".join(queue)\n                if temp not in uni:\n                    uni.add(temp)\n                    s = \"\".join(queue)\n                else: break\n        \n        words = list(uni)\n        words.sort()\n        return words[0]`\n"
                    },
                    {
                        "username": "bharatchauhan340",
                        "content": "How to solve ? if Any integer m is given denoting the maximum times this operation can be performed."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "if that is the case, then I think either the greedy way (which will not work) or just the recursion tbh exploring all ways"
                    }
                ]
            },
            {
                "id": 1673742,
                "content": [
                    {
                        "username": "cortexauth",
                        "content": "This had strong Codeforces vibe to it"
                    },
                    {
                        "username": "Ct-nep",
                        "content": "Is there any mathematical proof that the answer would always be lexicographically smallest (sorted) string if k > 1?"
                    },
                    {
                        "username": "JJATIN",
                        "content": "for k >1 its simply bubble sort"
                    },
                    {
                        "username": "supertaiyaki",
                        "content": "Hardly a proper proof but note that you can swap the two elements at the head of the string if k >= 2 (2nd element, 1st element, then take them in order until you get back to the start). You can also swap any arbitrary elements by rotating the string to the position you need, swapping, then rotating the rest of the way around. With those operations you can execute a bubble sort. It\\'s not too hard to verify the correctness of bubble sort if you want to go that far."
                    },
                    {
                        "username": "shabes",
                        "content": "It is relatively straightforward (no need for group theory :-)). We build the sorted string iteratively. At each iteration we start with smallest m characters sorted as a substring somewhere in our string (at the very first iteration we have m = 1 and it is a single smallest character somewhere). We will use position 0 as our \"storage\" for the next smallest character like this: cycle through the string by appending character from position 1 to the end (observe that this will not disturb our already sorted chain) until we see our target character (next smallest). Then we append character from position 0 to the end pushing our target into \"storage\". Now we cycle again by appending position 1 to the end until we line up our chain at the end of the string. Finally, we append character from storage to the end. Now we have m+1 sorted chain. Repeat until all characters are sorted."
                    },
                    {
                        "username": "narayan1281",
                        "content": "Yes!\\nSuppose s = \"zyxwonmab\" and k >1 (say k = 2)\\n// I would explain it using a priority_queue --> in fact a min heap priority_queue of size atmost k\\n// first push first k letters in priority_queue \\n// assume s1 = \"\"; --> temporary string to store result of first rotation\\n// take out the top of priority_queue (pq)\\ns1 = \"y\" and push next character in priority_queue --> pq = \"xz\"\\n// next-step\\ns1 = \"yx\" and pq = \"wz\"\\n// next step\\ns1 =\"yxw\" and pq = \"oz\"\\n// next\\ns1=\"yxwo\" and pq =\"nz\"\\n.\\n.\\n.\\ns1 =\"yxwonmab\" and pq=\"z\"\\n// next step\\ns1 =\"yxwonmabz\" and pq=\"\"--> empty as we have reached the end of first loop\\n\\n// From the above what we observe, in every full iteration of loop we put a \"largest value character\" at the end of the string\\n// so in we carry on the same looping process for n-1 number of times then what we would get is the \"sorted\" string and\\n// sorted string is indeed the lexicographically smallest permutation of s.\\n\\nI hope it helps. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I got to know about it when I was playing with the test cases. But if you really think if you have k>=2 then you can compare 2 elements and do work accordingly. And since there is no restriction on number of moves you will get to the sorted string eventually."
                    },
                    {
                        "username": "cortexauth",
                        "content": "Group theory talks about such permutations. We talk about cycles in this context, for example, a cycle (123..n) means send 1st element to nth position, send 2nd to 1st, 3rd to 2nd, and so on, in short, a left rotation. Moreover, we have a special cases such as transpositions , ex (12), which is basically a swap\\n\\nThese two are enough to generate any permutations for sequence of size 3\\n\\nI think there must be a more general proof as such.\\n\\nOnce done, we can argue that such moves can lead to any possible permutation of the elements, and even the sorted one, and hence the correctness proved"
                    },
                    {
                        "username": "votrubac",
                        "content": "I bet many people got a gist that you either sort or rotate. However, I did not expect a \"hard\" problem on LC to have a BF solution.\\n\\nSeeing this problme as \"hard\" sent me to a wrong direction. Was assigning \"hard\" intentional for these reasons? Or was it just a srew up on the admins\\' side?\\n\\nMy weakness is that I overcomplicate problems way too often, and I appreciate this learning  :) I think a better contents strategy would be to try a simple solution first. You can get in on luck, or you will get a good test case. The penalty for a wrong submission is 5 minutes, not 10 as it used to be :)"
                    },
                    {
                        "username": "Hrabesim",
                        "content": "It literary took me 2-3 minutes to code. :/"
                    },
                    {
                        "username": "AaveshK",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Could\\'ve been limited to premium users post the contest. "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I agree! I think this problem is a newly added problem in LC (looking at the solutions tab which has 513 solutions as of now - seasoned problems show 999+). \\n\\nSimilarly if we look at LeetCode 1128 (https://leetcode.com/problems/number-of-equivalent-domino-pairs/description/), it is categorized as Easy however it gives TLE on brute force solution and has a slightly trickier hashing logic to come up with for an easy problem. "
                    },
                    {
                        "username": "doggg2",
                        "content": "The key as discussed, is to observe that **when k = 2, it is possible to swap any two adjacent characters in the string**. To see why this is the case, consider any string s and any index i:\\n```s == s[0:i] + s[i] + s[i+1] + s[i + 2:]```\\n\\nThen we can swap i, i + 1 by doing these steps:\\n1. Keep putting the first character to the end until s[i] becomes the first character. Now we have a string ```s[i] + s[i+1] + s[i + 2:] + s[0:i]```\\n2. Put s[i] to the back. Now we have ```s[i + 1] + s[i+2:] + s[0:i] +s[i]```\\n3. Keep putting the second character to the end until s[i] becomes the second character. Now we have ```s[i+1] + s[i] + s[i + 2:] + s[0:i]```\\n4. Steps 2 and 3 have swapped i and i + 1. Now keep putting the first character to the back until we have ```s[0:i] + s[i + 1] + s[i] + s[i+2:]```\\n\\nIf you find this useful give an upvote."
                    },
                    {
                        "username": "happyleetcode",
                        "content": "Assume l is String length and  the target 2 chars\\' index is i and j. it should have 0<=i<j<l\\nso the structrue is that\\n[L] I [M] J [R]\\n[L] means the chars left to the I, the size of L shoule >=0\\n[M] means the chars between I and J, the size of M shoule >=0\\n[R] means the chars right to the J,the size of R shoule >=0\\nMOVE 1 means always move first char to the end\\nMOVE 2 means always move second char to the end.\\nthe target string should be  [L] J [M] I [R]\\n\\n\\tStep1. MOVE 1 until the string become      ** I  [M]  J  [R] [L]**\\n\\tStep2. MOVE 2 until the string become      ** I   J  [R] [L] [M]**\\n\\tStep3. MOVE 1 until the string become      ** J  [R] [L] [M]  I **\\n\\tStep4. MOVE 2 until the string become      ** J  [M]  I  [R] [L]**\\n\\tStep5. MOVE 1 until the string become      **[L]  J  [M]  I  [R]**"
                    },
                    {
                        "username": "Depender",
                        "content": "Initially I thought for some sorted rotatory arrangements but just realized it as a variation of bubble sort for k > 1. Hmm..! This was quite interesting and a bit confusing as well \\uD83D\\uDE05"
                    },
                    {
                        "username": "cpollock",
                        "content": "For test case 38, would not \"hntq\" be considered smaller than expected result \"htqn\"? My understanding of \"lexicographically smaller\" is the same as: https://en.wikipedia.org/wiki/Lexicographical_order\\n\\n![image](https://assets.leetcode.com/users/cpollock/image_1563820655.png)\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "with k==1 all you can do is rotate the string, so hntq is not possible"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "No matter how many times you rotate, you cannot change the order of h and n in this string with k=1. "
                    },
                    {
                        "username": "code_report",
                        "content": "Contest wouldn\\'t let me submit my solution for this problem."
                    },
                    {
                        "username": "khubaibalam2000",
                        "content": "Can someone tell me what is the time complexity of this solution?\n\n`class Solution:\n    def orderlyQueue(self, s: str, k: int) -> str:\n\n        queue = list(s)\n        if k > 1: \n            queue.sort()\n            return \"\".join((queue))\n        else:\n            uni = set()\n            uni.add(s)\n            for i in range(len(s)):\n                big = ''\n                big = max(big, s[0])\n                queue.remove(big)\n                queue.append(big)\n                temp = \"\".join(queue)\n                if temp not in uni:\n                    uni.add(temp)\n                    s = \"\".join(queue)\n                else: break\n        \n        words = list(uni)\n        words.sort()\n        return words[0]`\n"
                    },
                    {
                        "username": "bharatchauhan340",
                        "content": "How to solve ? if Any integer m is given denoting the maximum times this operation can be performed."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "if that is the case, then I think either the greedy way (which will not work) or just the recursion tbh exploring all ways"
                    }
                ]
            },
            {
                "id": 1572854,
                "content": [
                    {
                        "username": "cortexauth",
                        "content": "This had strong Codeforces vibe to it"
                    },
                    {
                        "username": "Ct-nep",
                        "content": "Is there any mathematical proof that the answer would always be lexicographically smallest (sorted) string if k > 1?"
                    },
                    {
                        "username": "JJATIN",
                        "content": "for k >1 its simply bubble sort"
                    },
                    {
                        "username": "supertaiyaki",
                        "content": "Hardly a proper proof but note that you can swap the two elements at the head of the string if k >= 2 (2nd element, 1st element, then take them in order until you get back to the start). You can also swap any arbitrary elements by rotating the string to the position you need, swapping, then rotating the rest of the way around. With those operations you can execute a bubble sort. It\\'s not too hard to verify the correctness of bubble sort if you want to go that far."
                    },
                    {
                        "username": "shabes",
                        "content": "It is relatively straightforward (no need for group theory :-)). We build the sorted string iteratively. At each iteration we start with smallest m characters sorted as a substring somewhere in our string (at the very first iteration we have m = 1 and it is a single smallest character somewhere). We will use position 0 as our \"storage\" for the next smallest character like this: cycle through the string by appending character from position 1 to the end (observe that this will not disturb our already sorted chain) until we see our target character (next smallest). Then we append character from position 0 to the end pushing our target into \"storage\". Now we cycle again by appending position 1 to the end until we line up our chain at the end of the string. Finally, we append character from storage to the end. Now we have m+1 sorted chain. Repeat until all characters are sorted."
                    },
                    {
                        "username": "narayan1281",
                        "content": "Yes!\\nSuppose s = \"zyxwonmab\" and k >1 (say k = 2)\\n// I would explain it using a priority_queue --> in fact a min heap priority_queue of size atmost k\\n// first push first k letters in priority_queue \\n// assume s1 = \"\"; --> temporary string to store result of first rotation\\n// take out the top of priority_queue (pq)\\ns1 = \"y\" and push next character in priority_queue --> pq = \"xz\"\\n// next-step\\ns1 = \"yx\" and pq = \"wz\"\\n// next step\\ns1 =\"yxw\" and pq = \"oz\"\\n// next\\ns1=\"yxwo\" and pq =\"nz\"\\n.\\n.\\n.\\ns1 =\"yxwonmab\" and pq=\"z\"\\n// next step\\ns1 =\"yxwonmabz\" and pq=\"\"--> empty as we have reached the end of first loop\\n\\n// From the above what we observe, in every full iteration of loop we put a \"largest value character\" at the end of the string\\n// so in we carry on the same looping process for n-1 number of times then what we would get is the \"sorted\" string and\\n// sorted string is indeed the lexicographically smallest permutation of s.\\n\\nI hope it helps. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I got to know about it when I was playing with the test cases. But if you really think if you have k>=2 then you can compare 2 elements and do work accordingly. And since there is no restriction on number of moves you will get to the sorted string eventually."
                    },
                    {
                        "username": "cortexauth",
                        "content": "Group theory talks about such permutations. We talk about cycles in this context, for example, a cycle (123..n) means send 1st element to nth position, send 2nd to 1st, 3rd to 2nd, and so on, in short, a left rotation. Moreover, we have a special cases such as transpositions , ex (12), which is basically a swap\\n\\nThese two are enough to generate any permutations for sequence of size 3\\n\\nI think there must be a more general proof as such.\\n\\nOnce done, we can argue that such moves can lead to any possible permutation of the elements, and even the sorted one, and hence the correctness proved"
                    },
                    {
                        "username": "votrubac",
                        "content": "I bet many people got a gist that you either sort or rotate. However, I did not expect a \"hard\" problem on LC to have a BF solution.\\n\\nSeeing this problme as \"hard\" sent me to a wrong direction. Was assigning \"hard\" intentional for these reasons? Or was it just a srew up on the admins\\' side?\\n\\nMy weakness is that I overcomplicate problems way too often, and I appreciate this learning  :) I think a better contents strategy would be to try a simple solution first. You can get in on luck, or you will get a good test case. The penalty for a wrong submission is 5 minutes, not 10 as it used to be :)"
                    },
                    {
                        "username": "Hrabesim",
                        "content": "It literary took me 2-3 minutes to code. :/"
                    },
                    {
                        "username": "AaveshK",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Could\\'ve been limited to premium users post the contest. "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I agree! I think this problem is a newly added problem in LC (looking at the solutions tab which has 513 solutions as of now - seasoned problems show 999+). \\n\\nSimilarly if we look at LeetCode 1128 (https://leetcode.com/problems/number-of-equivalent-domino-pairs/description/), it is categorized as Easy however it gives TLE on brute force solution and has a slightly trickier hashing logic to come up with for an easy problem. "
                    },
                    {
                        "username": "doggg2",
                        "content": "The key as discussed, is to observe that **when k = 2, it is possible to swap any two adjacent characters in the string**. To see why this is the case, consider any string s and any index i:\\n```s == s[0:i] + s[i] + s[i+1] + s[i + 2:]```\\n\\nThen we can swap i, i + 1 by doing these steps:\\n1. Keep putting the first character to the end until s[i] becomes the first character. Now we have a string ```s[i] + s[i+1] + s[i + 2:] + s[0:i]```\\n2. Put s[i] to the back. Now we have ```s[i + 1] + s[i+2:] + s[0:i] +s[i]```\\n3. Keep putting the second character to the end until s[i] becomes the second character. Now we have ```s[i+1] + s[i] + s[i + 2:] + s[0:i]```\\n4. Steps 2 and 3 have swapped i and i + 1. Now keep putting the first character to the back until we have ```s[0:i] + s[i + 1] + s[i] + s[i+2:]```\\n\\nIf you find this useful give an upvote."
                    },
                    {
                        "username": "happyleetcode",
                        "content": "Assume l is String length and  the target 2 chars\\' index is i and j. it should have 0<=i<j<l\\nso the structrue is that\\n[L] I [M] J [R]\\n[L] means the chars left to the I, the size of L shoule >=0\\n[M] means the chars between I and J, the size of M shoule >=0\\n[R] means the chars right to the J,the size of R shoule >=0\\nMOVE 1 means always move first char to the end\\nMOVE 2 means always move second char to the end.\\nthe target string should be  [L] J [M] I [R]\\n\\n\\tStep1. MOVE 1 until the string become      ** I  [M]  J  [R] [L]**\\n\\tStep2. MOVE 2 until the string become      ** I   J  [R] [L] [M]**\\n\\tStep3. MOVE 1 until the string become      ** J  [R] [L] [M]  I **\\n\\tStep4. MOVE 2 until the string become      ** J  [M]  I  [R] [L]**\\n\\tStep5. MOVE 1 until the string become      **[L]  J  [M]  I  [R]**"
                    },
                    {
                        "username": "Depender",
                        "content": "Initially I thought for some sorted rotatory arrangements but just realized it as a variation of bubble sort for k > 1. Hmm..! This was quite interesting and a bit confusing as well \\uD83D\\uDE05"
                    },
                    {
                        "username": "cpollock",
                        "content": "For test case 38, would not \"hntq\" be considered smaller than expected result \"htqn\"? My understanding of \"lexicographically smaller\" is the same as: https://en.wikipedia.org/wiki/Lexicographical_order\\n\\n![image](https://assets.leetcode.com/users/cpollock/image_1563820655.png)\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "with k==1 all you can do is rotate the string, so hntq is not possible"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "No matter how many times you rotate, you cannot change the order of h and n in this string with k=1. "
                    },
                    {
                        "username": "code_report",
                        "content": "Contest wouldn\\'t let me submit my solution for this problem."
                    },
                    {
                        "username": "khubaibalam2000",
                        "content": "Can someone tell me what is the time complexity of this solution?\n\n`class Solution:\n    def orderlyQueue(self, s: str, k: int) -> str:\n\n        queue = list(s)\n        if k > 1: \n            queue.sort()\n            return \"\".join((queue))\n        else:\n            uni = set()\n            uni.add(s)\n            for i in range(len(s)):\n                big = ''\n                big = max(big, s[0])\n                queue.remove(big)\n                queue.append(big)\n                temp = \"\".join(queue)\n                if temp not in uni:\n                    uni.add(temp)\n                    s = \"\".join(queue)\n                else: break\n        \n        words = list(uni)\n        words.sort()\n        return words[0]`\n"
                    },
                    {
                        "username": "bharatchauhan340",
                        "content": "How to solve ? if Any integer m is given denoting the maximum times this operation can be performed."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "if that is the case, then I think either the greedy way (which will not work) or just the recursion tbh exploring all ways"
                    }
                ]
            },
            {
                "id": 1569286,
                "content": [
                    {
                        "username": "cortexauth",
                        "content": "This had strong Codeforces vibe to it"
                    },
                    {
                        "username": "Ct-nep",
                        "content": "Is there any mathematical proof that the answer would always be lexicographically smallest (sorted) string if k > 1?"
                    },
                    {
                        "username": "JJATIN",
                        "content": "for k >1 its simply bubble sort"
                    },
                    {
                        "username": "supertaiyaki",
                        "content": "Hardly a proper proof but note that you can swap the two elements at the head of the string if k >= 2 (2nd element, 1st element, then take them in order until you get back to the start). You can also swap any arbitrary elements by rotating the string to the position you need, swapping, then rotating the rest of the way around. With those operations you can execute a bubble sort. It\\'s not too hard to verify the correctness of bubble sort if you want to go that far."
                    },
                    {
                        "username": "shabes",
                        "content": "It is relatively straightforward (no need for group theory :-)). We build the sorted string iteratively. At each iteration we start with smallest m characters sorted as a substring somewhere in our string (at the very first iteration we have m = 1 and it is a single smallest character somewhere). We will use position 0 as our \"storage\" for the next smallest character like this: cycle through the string by appending character from position 1 to the end (observe that this will not disturb our already sorted chain) until we see our target character (next smallest). Then we append character from position 0 to the end pushing our target into \"storage\". Now we cycle again by appending position 1 to the end until we line up our chain at the end of the string. Finally, we append character from storage to the end. Now we have m+1 sorted chain. Repeat until all characters are sorted."
                    },
                    {
                        "username": "narayan1281",
                        "content": "Yes!\\nSuppose s = \"zyxwonmab\" and k >1 (say k = 2)\\n// I would explain it using a priority_queue --> in fact a min heap priority_queue of size atmost k\\n// first push first k letters in priority_queue \\n// assume s1 = \"\"; --> temporary string to store result of first rotation\\n// take out the top of priority_queue (pq)\\ns1 = \"y\" and push next character in priority_queue --> pq = \"xz\"\\n// next-step\\ns1 = \"yx\" and pq = \"wz\"\\n// next step\\ns1 =\"yxw\" and pq = \"oz\"\\n// next\\ns1=\"yxwo\" and pq =\"nz\"\\n.\\n.\\n.\\ns1 =\"yxwonmab\" and pq=\"z\"\\n// next step\\ns1 =\"yxwonmabz\" and pq=\"\"--> empty as we have reached the end of first loop\\n\\n// From the above what we observe, in every full iteration of loop we put a \"largest value character\" at the end of the string\\n// so in we carry on the same looping process for n-1 number of times then what we would get is the \"sorted\" string and\\n// sorted string is indeed the lexicographically smallest permutation of s.\\n\\nI hope it helps. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I got to know about it when I was playing with the test cases. But if you really think if you have k>=2 then you can compare 2 elements and do work accordingly. And since there is no restriction on number of moves you will get to the sorted string eventually."
                    },
                    {
                        "username": "cortexauth",
                        "content": "Group theory talks about such permutations. We talk about cycles in this context, for example, a cycle (123..n) means send 1st element to nth position, send 2nd to 1st, 3rd to 2nd, and so on, in short, a left rotation. Moreover, we have a special cases such as transpositions , ex (12), which is basically a swap\\n\\nThese two are enough to generate any permutations for sequence of size 3\\n\\nI think there must be a more general proof as such.\\n\\nOnce done, we can argue that such moves can lead to any possible permutation of the elements, and even the sorted one, and hence the correctness proved"
                    },
                    {
                        "username": "votrubac",
                        "content": "I bet many people got a gist that you either sort or rotate. However, I did not expect a \"hard\" problem on LC to have a BF solution.\\n\\nSeeing this problme as \"hard\" sent me to a wrong direction. Was assigning \"hard\" intentional for these reasons? Or was it just a srew up on the admins\\' side?\\n\\nMy weakness is that I overcomplicate problems way too often, and I appreciate this learning  :) I think a better contents strategy would be to try a simple solution first. You can get in on luck, or you will get a good test case. The penalty for a wrong submission is 5 minutes, not 10 as it used to be :)"
                    },
                    {
                        "username": "Hrabesim",
                        "content": "It literary took me 2-3 minutes to code. :/"
                    },
                    {
                        "username": "AaveshK",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Could\\'ve been limited to premium users post the contest. "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I agree! I think this problem is a newly added problem in LC (looking at the solutions tab which has 513 solutions as of now - seasoned problems show 999+). \\n\\nSimilarly if we look at LeetCode 1128 (https://leetcode.com/problems/number-of-equivalent-domino-pairs/description/), it is categorized as Easy however it gives TLE on brute force solution and has a slightly trickier hashing logic to come up with for an easy problem. "
                    },
                    {
                        "username": "doggg2",
                        "content": "The key as discussed, is to observe that **when k = 2, it is possible to swap any two adjacent characters in the string**. To see why this is the case, consider any string s and any index i:\\n```s == s[0:i] + s[i] + s[i+1] + s[i + 2:]```\\n\\nThen we can swap i, i + 1 by doing these steps:\\n1. Keep putting the first character to the end until s[i] becomes the first character. Now we have a string ```s[i] + s[i+1] + s[i + 2:] + s[0:i]```\\n2. Put s[i] to the back. Now we have ```s[i + 1] + s[i+2:] + s[0:i] +s[i]```\\n3. Keep putting the second character to the end until s[i] becomes the second character. Now we have ```s[i+1] + s[i] + s[i + 2:] + s[0:i]```\\n4. Steps 2 and 3 have swapped i and i + 1. Now keep putting the first character to the back until we have ```s[0:i] + s[i + 1] + s[i] + s[i+2:]```\\n\\nIf you find this useful give an upvote."
                    },
                    {
                        "username": "happyleetcode",
                        "content": "Assume l is String length and  the target 2 chars\\' index is i and j. it should have 0<=i<j<l\\nso the structrue is that\\n[L] I [M] J [R]\\n[L] means the chars left to the I, the size of L shoule >=0\\n[M] means the chars between I and J, the size of M shoule >=0\\n[R] means the chars right to the J,the size of R shoule >=0\\nMOVE 1 means always move first char to the end\\nMOVE 2 means always move second char to the end.\\nthe target string should be  [L] J [M] I [R]\\n\\n\\tStep1. MOVE 1 until the string become      ** I  [M]  J  [R] [L]**\\n\\tStep2. MOVE 2 until the string become      ** I   J  [R] [L] [M]**\\n\\tStep3. MOVE 1 until the string become      ** J  [R] [L] [M]  I **\\n\\tStep4. MOVE 2 until the string become      ** J  [M]  I  [R] [L]**\\n\\tStep5. MOVE 1 until the string become      **[L]  J  [M]  I  [R]**"
                    },
                    {
                        "username": "Depender",
                        "content": "Initially I thought for some sorted rotatory arrangements but just realized it as a variation of bubble sort for k > 1. Hmm..! This was quite interesting and a bit confusing as well \\uD83D\\uDE05"
                    },
                    {
                        "username": "cpollock",
                        "content": "For test case 38, would not \"hntq\" be considered smaller than expected result \"htqn\"? My understanding of \"lexicographically smaller\" is the same as: https://en.wikipedia.org/wiki/Lexicographical_order\\n\\n![image](https://assets.leetcode.com/users/cpollock/image_1563820655.png)\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "with k==1 all you can do is rotate the string, so hntq is not possible"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "No matter how many times you rotate, you cannot change the order of h and n in this string with k=1. "
                    },
                    {
                        "username": "code_report",
                        "content": "Contest wouldn\\'t let me submit my solution for this problem."
                    },
                    {
                        "username": "khubaibalam2000",
                        "content": "Can someone tell me what is the time complexity of this solution?\n\n`class Solution:\n    def orderlyQueue(self, s: str, k: int) -> str:\n\n        queue = list(s)\n        if k > 1: \n            queue.sort()\n            return \"\".join((queue))\n        else:\n            uni = set()\n            uni.add(s)\n            for i in range(len(s)):\n                big = ''\n                big = max(big, s[0])\n                queue.remove(big)\n                queue.append(big)\n                temp = \"\".join(queue)\n                if temp not in uni:\n                    uni.add(temp)\n                    s = \"\".join(queue)\n                else: break\n        \n        words = list(uni)\n        words.sort()\n        return words[0]`\n"
                    },
                    {
                        "username": "bharatchauhan340",
                        "content": "How to solve ? if Any integer m is given denoting the maximum times this operation can be performed."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "if that is the case, then I think either the greedy way (which will not work) or just the recursion tbh exploring all ways"
                    }
                ]
            },
            {
                "id": 1867848,
                "content": [
                    {
                        "username": "cortexauth",
                        "content": "This had strong Codeforces vibe to it"
                    },
                    {
                        "username": "Ct-nep",
                        "content": "Is there any mathematical proof that the answer would always be lexicographically smallest (sorted) string if k > 1?"
                    },
                    {
                        "username": "JJATIN",
                        "content": "for k >1 its simply bubble sort"
                    },
                    {
                        "username": "supertaiyaki",
                        "content": "Hardly a proper proof but note that you can swap the two elements at the head of the string if k >= 2 (2nd element, 1st element, then take them in order until you get back to the start). You can also swap any arbitrary elements by rotating the string to the position you need, swapping, then rotating the rest of the way around. With those operations you can execute a bubble sort. It\\'s not too hard to verify the correctness of bubble sort if you want to go that far."
                    },
                    {
                        "username": "shabes",
                        "content": "It is relatively straightforward (no need for group theory :-)). We build the sorted string iteratively. At each iteration we start with smallest m characters sorted as a substring somewhere in our string (at the very first iteration we have m = 1 and it is a single smallest character somewhere). We will use position 0 as our \"storage\" for the next smallest character like this: cycle through the string by appending character from position 1 to the end (observe that this will not disturb our already sorted chain) until we see our target character (next smallest). Then we append character from position 0 to the end pushing our target into \"storage\". Now we cycle again by appending position 1 to the end until we line up our chain at the end of the string. Finally, we append character from storage to the end. Now we have m+1 sorted chain. Repeat until all characters are sorted."
                    },
                    {
                        "username": "narayan1281",
                        "content": "Yes!\\nSuppose s = \"zyxwonmab\" and k >1 (say k = 2)\\n// I would explain it using a priority_queue --> in fact a min heap priority_queue of size atmost k\\n// first push first k letters in priority_queue \\n// assume s1 = \"\"; --> temporary string to store result of first rotation\\n// take out the top of priority_queue (pq)\\ns1 = \"y\" and push next character in priority_queue --> pq = \"xz\"\\n// next-step\\ns1 = \"yx\" and pq = \"wz\"\\n// next step\\ns1 =\"yxw\" and pq = \"oz\"\\n// next\\ns1=\"yxwo\" and pq =\"nz\"\\n.\\n.\\n.\\ns1 =\"yxwonmab\" and pq=\"z\"\\n// next step\\ns1 =\"yxwonmabz\" and pq=\"\"--> empty as we have reached the end of first loop\\n\\n// From the above what we observe, in every full iteration of loop we put a \"largest value character\" at the end of the string\\n// so in we carry on the same looping process for n-1 number of times then what we would get is the \"sorted\" string and\\n// sorted string is indeed the lexicographically smallest permutation of s.\\n\\nI hope it helps. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I got to know about it when I was playing with the test cases. But if you really think if you have k>=2 then you can compare 2 elements and do work accordingly. And since there is no restriction on number of moves you will get to the sorted string eventually."
                    },
                    {
                        "username": "cortexauth",
                        "content": "Group theory talks about such permutations. We talk about cycles in this context, for example, a cycle (123..n) means send 1st element to nth position, send 2nd to 1st, 3rd to 2nd, and so on, in short, a left rotation. Moreover, we have a special cases such as transpositions , ex (12), which is basically a swap\\n\\nThese two are enough to generate any permutations for sequence of size 3\\n\\nI think there must be a more general proof as such.\\n\\nOnce done, we can argue that such moves can lead to any possible permutation of the elements, and even the sorted one, and hence the correctness proved"
                    },
                    {
                        "username": "votrubac",
                        "content": "I bet many people got a gist that you either sort or rotate. However, I did not expect a \"hard\" problem on LC to have a BF solution.\\n\\nSeeing this problme as \"hard\" sent me to a wrong direction. Was assigning \"hard\" intentional for these reasons? Or was it just a srew up on the admins\\' side?\\n\\nMy weakness is that I overcomplicate problems way too often, and I appreciate this learning  :) I think a better contents strategy would be to try a simple solution first. You can get in on luck, or you will get a good test case. The penalty for a wrong submission is 5 minutes, not 10 as it used to be :)"
                    },
                    {
                        "username": "Hrabesim",
                        "content": "It literary took me 2-3 minutes to code. :/"
                    },
                    {
                        "username": "AaveshK",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Could\\'ve been limited to premium users post the contest. "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I agree! I think this problem is a newly added problem in LC (looking at the solutions tab which has 513 solutions as of now - seasoned problems show 999+). \\n\\nSimilarly if we look at LeetCode 1128 (https://leetcode.com/problems/number-of-equivalent-domino-pairs/description/), it is categorized as Easy however it gives TLE on brute force solution and has a slightly trickier hashing logic to come up with for an easy problem. "
                    },
                    {
                        "username": "doggg2",
                        "content": "The key as discussed, is to observe that **when k = 2, it is possible to swap any two adjacent characters in the string**. To see why this is the case, consider any string s and any index i:\\n```s == s[0:i] + s[i] + s[i+1] + s[i + 2:]```\\n\\nThen we can swap i, i + 1 by doing these steps:\\n1. Keep putting the first character to the end until s[i] becomes the first character. Now we have a string ```s[i] + s[i+1] + s[i + 2:] + s[0:i]```\\n2. Put s[i] to the back. Now we have ```s[i + 1] + s[i+2:] + s[0:i] +s[i]```\\n3. Keep putting the second character to the end until s[i] becomes the second character. Now we have ```s[i+1] + s[i] + s[i + 2:] + s[0:i]```\\n4. Steps 2 and 3 have swapped i and i + 1. Now keep putting the first character to the back until we have ```s[0:i] + s[i + 1] + s[i] + s[i+2:]```\\n\\nIf you find this useful give an upvote."
                    },
                    {
                        "username": "happyleetcode",
                        "content": "Assume l is String length and  the target 2 chars\\' index is i and j. it should have 0<=i<j<l\\nso the structrue is that\\n[L] I [M] J [R]\\n[L] means the chars left to the I, the size of L shoule >=0\\n[M] means the chars between I and J, the size of M shoule >=0\\n[R] means the chars right to the J,the size of R shoule >=0\\nMOVE 1 means always move first char to the end\\nMOVE 2 means always move second char to the end.\\nthe target string should be  [L] J [M] I [R]\\n\\n\\tStep1. MOVE 1 until the string become      ** I  [M]  J  [R] [L]**\\n\\tStep2. MOVE 2 until the string become      ** I   J  [R] [L] [M]**\\n\\tStep3. MOVE 1 until the string become      ** J  [R] [L] [M]  I **\\n\\tStep4. MOVE 2 until the string become      ** J  [M]  I  [R] [L]**\\n\\tStep5. MOVE 1 until the string become      **[L]  J  [M]  I  [R]**"
                    },
                    {
                        "username": "Depender",
                        "content": "Initially I thought for some sorted rotatory arrangements but just realized it as a variation of bubble sort for k > 1. Hmm..! This was quite interesting and a bit confusing as well \\uD83D\\uDE05"
                    },
                    {
                        "username": "cpollock",
                        "content": "For test case 38, would not \"hntq\" be considered smaller than expected result \"htqn\"? My understanding of \"lexicographically smaller\" is the same as: https://en.wikipedia.org/wiki/Lexicographical_order\\n\\n![image](https://assets.leetcode.com/users/cpollock/image_1563820655.png)\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "with k==1 all you can do is rotate the string, so hntq is not possible"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "No matter how many times you rotate, you cannot change the order of h and n in this string with k=1. "
                    },
                    {
                        "username": "code_report",
                        "content": "Contest wouldn\\'t let me submit my solution for this problem."
                    },
                    {
                        "username": "khubaibalam2000",
                        "content": "Can someone tell me what is the time complexity of this solution?\n\n`class Solution:\n    def orderlyQueue(self, s: str, k: int) -> str:\n\n        queue = list(s)\n        if k > 1: \n            queue.sort()\n            return \"\".join((queue))\n        else:\n            uni = set()\n            uni.add(s)\n            for i in range(len(s)):\n                big = ''\n                big = max(big, s[0])\n                queue.remove(big)\n                queue.append(big)\n                temp = \"\".join(queue)\n                if temp not in uni:\n                    uni.add(temp)\n                    s = \"\".join(queue)\n                else: break\n        \n        words = list(uni)\n        words.sort()\n        return words[0]`\n"
                    },
                    {
                        "username": "bharatchauhan340",
                        "content": "How to solve ? if Any integer m is given denoting the maximum times this operation can be performed."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "if that is the case, then I think either the greedy way (which will not work) or just the recursion tbh exploring all ways"
                    }
                ]
            },
            {
                "id": 1675184,
                "content": [
                    {
                        "username": "cortexauth",
                        "content": "This had strong Codeforces vibe to it"
                    },
                    {
                        "username": "Ct-nep",
                        "content": "Is there any mathematical proof that the answer would always be lexicographically smallest (sorted) string if k > 1?"
                    },
                    {
                        "username": "JJATIN",
                        "content": "for k >1 its simply bubble sort"
                    },
                    {
                        "username": "supertaiyaki",
                        "content": "Hardly a proper proof but note that you can swap the two elements at the head of the string if k >= 2 (2nd element, 1st element, then take them in order until you get back to the start). You can also swap any arbitrary elements by rotating the string to the position you need, swapping, then rotating the rest of the way around. With those operations you can execute a bubble sort. It\\'s not too hard to verify the correctness of bubble sort if you want to go that far."
                    },
                    {
                        "username": "shabes",
                        "content": "It is relatively straightforward (no need for group theory :-)). We build the sorted string iteratively. At each iteration we start with smallest m characters sorted as a substring somewhere in our string (at the very first iteration we have m = 1 and it is a single smallest character somewhere). We will use position 0 as our \"storage\" for the next smallest character like this: cycle through the string by appending character from position 1 to the end (observe that this will not disturb our already sorted chain) until we see our target character (next smallest). Then we append character from position 0 to the end pushing our target into \"storage\". Now we cycle again by appending position 1 to the end until we line up our chain at the end of the string. Finally, we append character from storage to the end. Now we have m+1 sorted chain. Repeat until all characters are sorted."
                    },
                    {
                        "username": "narayan1281",
                        "content": "Yes!\\nSuppose s = \"zyxwonmab\" and k >1 (say k = 2)\\n// I would explain it using a priority_queue --> in fact a min heap priority_queue of size atmost k\\n// first push first k letters in priority_queue \\n// assume s1 = \"\"; --> temporary string to store result of first rotation\\n// take out the top of priority_queue (pq)\\ns1 = \"y\" and push next character in priority_queue --> pq = \"xz\"\\n// next-step\\ns1 = \"yx\" and pq = \"wz\"\\n// next step\\ns1 =\"yxw\" and pq = \"oz\"\\n// next\\ns1=\"yxwo\" and pq =\"nz\"\\n.\\n.\\n.\\ns1 =\"yxwonmab\" and pq=\"z\"\\n// next step\\ns1 =\"yxwonmabz\" and pq=\"\"--> empty as we have reached the end of first loop\\n\\n// From the above what we observe, in every full iteration of loop we put a \"largest value character\" at the end of the string\\n// so in we carry on the same looping process for n-1 number of times then what we would get is the \"sorted\" string and\\n// sorted string is indeed the lexicographically smallest permutation of s.\\n\\nI hope it helps. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I got to know about it when I was playing with the test cases. But if you really think if you have k>=2 then you can compare 2 elements and do work accordingly. And since there is no restriction on number of moves you will get to the sorted string eventually."
                    },
                    {
                        "username": "cortexauth",
                        "content": "Group theory talks about such permutations. We talk about cycles in this context, for example, a cycle (123..n) means send 1st element to nth position, send 2nd to 1st, 3rd to 2nd, and so on, in short, a left rotation. Moreover, we have a special cases such as transpositions , ex (12), which is basically a swap\\n\\nThese two are enough to generate any permutations for sequence of size 3\\n\\nI think there must be a more general proof as such.\\n\\nOnce done, we can argue that such moves can lead to any possible permutation of the elements, and even the sorted one, and hence the correctness proved"
                    },
                    {
                        "username": "votrubac",
                        "content": "I bet many people got a gist that you either sort or rotate. However, I did not expect a \"hard\" problem on LC to have a BF solution.\\n\\nSeeing this problme as \"hard\" sent me to a wrong direction. Was assigning \"hard\" intentional for these reasons? Or was it just a srew up on the admins\\' side?\\n\\nMy weakness is that I overcomplicate problems way too often, and I appreciate this learning  :) I think a better contents strategy would be to try a simple solution first. You can get in on luck, or you will get a good test case. The penalty for a wrong submission is 5 minutes, not 10 as it used to be :)"
                    },
                    {
                        "username": "Hrabesim",
                        "content": "It literary took me 2-3 minutes to code. :/"
                    },
                    {
                        "username": "AaveshK",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Could\\'ve been limited to premium users post the contest. "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I agree! I think this problem is a newly added problem in LC (looking at the solutions tab which has 513 solutions as of now - seasoned problems show 999+). \\n\\nSimilarly if we look at LeetCode 1128 (https://leetcode.com/problems/number-of-equivalent-domino-pairs/description/), it is categorized as Easy however it gives TLE on brute force solution and has a slightly trickier hashing logic to come up with for an easy problem. "
                    },
                    {
                        "username": "doggg2",
                        "content": "The key as discussed, is to observe that **when k = 2, it is possible to swap any two adjacent characters in the string**. To see why this is the case, consider any string s and any index i:\\n```s == s[0:i] + s[i] + s[i+1] + s[i + 2:]```\\n\\nThen we can swap i, i + 1 by doing these steps:\\n1. Keep putting the first character to the end until s[i] becomes the first character. Now we have a string ```s[i] + s[i+1] + s[i + 2:] + s[0:i]```\\n2. Put s[i] to the back. Now we have ```s[i + 1] + s[i+2:] + s[0:i] +s[i]```\\n3. Keep putting the second character to the end until s[i] becomes the second character. Now we have ```s[i+1] + s[i] + s[i + 2:] + s[0:i]```\\n4. Steps 2 and 3 have swapped i and i + 1. Now keep putting the first character to the back until we have ```s[0:i] + s[i + 1] + s[i] + s[i+2:]```\\n\\nIf you find this useful give an upvote."
                    },
                    {
                        "username": "happyleetcode",
                        "content": "Assume l is String length and  the target 2 chars\\' index is i and j. it should have 0<=i<j<l\\nso the structrue is that\\n[L] I [M] J [R]\\n[L] means the chars left to the I, the size of L shoule >=0\\n[M] means the chars between I and J, the size of M shoule >=0\\n[R] means the chars right to the J,the size of R shoule >=0\\nMOVE 1 means always move first char to the end\\nMOVE 2 means always move second char to the end.\\nthe target string should be  [L] J [M] I [R]\\n\\n\\tStep1. MOVE 1 until the string become      ** I  [M]  J  [R] [L]**\\n\\tStep2. MOVE 2 until the string become      ** I   J  [R] [L] [M]**\\n\\tStep3. MOVE 1 until the string become      ** J  [R] [L] [M]  I **\\n\\tStep4. MOVE 2 until the string become      ** J  [M]  I  [R] [L]**\\n\\tStep5. MOVE 1 until the string become      **[L]  J  [M]  I  [R]**"
                    },
                    {
                        "username": "Depender",
                        "content": "Initially I thought for some sorted rotatory arrangements but just realized it as a variation of bubble sort for k > 1. Hmm..! This was quite interesting and a bit confusing as well \\uD83D\\uDE05"
                    },
                    {
                        "username": "cpollock",
                        "content": "For test case 38, would not \"hntq\" be considered smaller than expected result \"htqn\"? My understanding of \"lexicographically smaller\" is the same as: https://en.wikipedia.org/wiki/Lexicographical_order\\n\\n![image](https://assets.leetcode.com/users/cpollock/image_1563820655.png)\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "with k==1 all you can do is rotate the string, so hntq is not possible"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "No matter how many times you rotate, you cannot change the order of h and n in this string with k=1. "
                    },
                    {
                        "username": "code_report",
                        "content": "Contest wouldn\\'t let me submit my solution for this problem."
                    },
                    {
                        "username": "khubaibalam2000",
                        "content": "Can someone tell me what is the time complexity of this solution?\n\n`class Solution:\n    def orderlyQueue(self, s: str, k: int) -> str:\n\n        queue = list(s)\n        if k > 1: \n            queue.sort()\n            return \"\".join((queue))\n        else:\n            uni = set()\n            uni.add(s)\n            for i in range(len(s)):\n                big = ''\n                big = max(big, s[0])\n                queue.remove(big)\n                queue.append(big)\n                temp = \"\".join(queue)\n                if temp not in uni:\n                    uni.add(temp)\n                    s = \"\".join(queue)\n                else: break\n        \n        words = list(uni)\n        words.sort()\n        return words[0]`\n"
                    },
                    {
                        "username": "bharatchauhan340",
                        "content": "How to solve ? if Any integer m is given denoting the maximum times this operation can be performed."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "if that is the case, then I think either the greedy way (which will not work) or just the recursion tbh exploring all ways"
                    }
                ]
            },
            {
                "id": 1673166,
                "content": [
                    {
                        "username": "cortexauth",
                        "content": "This had strong Codeforces vibe to it"
                    },
                    {
                        "username": "Ct-nep",
                        "content": "Is there any mathematical proof that the answer would always be lexicographically smallest (sorted) string if k > 1?"
                    },
                    {
                        "username": "JJATIN",
                        "content": "for k >1 its simply bubble sort"
                    },
                    {
                        "username": "supertaiyaki",
                        "content": "Hardly a proper proof but note that you can swap the two elements at the head of the string if k >= 2 (2nd element, 1st element, then take them in order until you get back to the start). You can also swap any arbitrary elements by rotating the string to the position you need, swapping, then rotating the rest of the way around. With those operations you can execute a bubble sort. It\\'s not too hard to verify the correctness of bubble sort if you want to go that far."
                    },
                    {
                        "username": "shabes",
                        "content": "It is relatively straightforward (no need for group theory :-)). We build the sorted string iteratively. At each iteration we start with smallest m characters sorted as a substring somewhere in our string (at the very first iteration we have m = 1 and it is a single smallest character somewhere). We will use position 0 as our \"storage\" for the next smallest character like this: cycle through the string by appending character from position 1 to the end (observe that this will not disturb our already sorted chain) until we see our target character (next smallest). Then we append character from position 0 to the end pushing our target into \"storage\". Now we cycle again by appending position 1 to the end until we line up our chain at the end of the string. Finally, we append character from storage to the end. Now we have m+1 sorted chain. Repeat until all characters are sorted."
                    },
                    {
                        "username": "narayan1281",
                        "content": "Yes!\\nSuppose s = \"zyxwonmab\" and k >1 (say k = 2)\\n// I would explain it using a priority_queue --> in fact a min heap priority_queue of size atmost k\\n// first push first k letters in priority_queue \\n// assume s1 = \"\"; --> temporary string to store result of first rotation\\n// take out the top of priority_queue (pq)\\ns1 = \"y\" and push next character in priority_queue --> pq = \"xz\"\\n// next-step\\ns1 = \"yx\" and pq = \"wz\"\\n// next step\\ns1 =\"yxw\" and pq = \"oz\"\\n// next\\ns1=\"yxwo\" and pq =\"nz\"\\n.\\n.\\n.\\ns1 =\"yxwonmab\" and pq=\"z\"\\n// next step\\ns1 =\"yxwonmabz\" and pq=\"\"--> empty as we have reached the end of first loop\\n\\n// From the above what we observe, in every full iteration of loop we put a \"largest value character\" at the end of the string\\n// so in we carry on the same looping process for n-1 number of times then what we would get is the \"sorted\" string and\\n// sorted string is indeed the lexicographically smallest permutation of s.\\n\\nI hope it helps. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I got to know about it when I was playing with the test cases. But if you really think if you have k>=2 then you can compare 2 elements and do work accordingly. And since there is no restriction on number of moves you will get to the sorted string eventually."
                    },
                    {
                        "username": "cortexauth",
                        "content": "Group theory talks about such permutations. We talk about cycles in this context, for example, a cycle (123..n) means send 1st element to nth position, send 2nd to 1st, 3rd to 2nd, and so on, in short, a left rotation. Moreover, we have a special cases such as transpositions , ex (12), which is basically a swap\\n\\nThese two are enough to generate any permutations for sequence of size 3\\n\\nI think there must be a more general proof as such.\\n\\nOnce done, we can argue that such moves can lead to any possible permutation of the elements, and even the sorted one, and hence the correctness proved"
                    },
                    {
                        "username": "votrubac",
                        "content": "I bet many people got a gist that you either sort or rotate. However, I did not expect a \"hard\" problem on LC to have a BF solution.\\n\\nSeeing this problme as \"hard\" sent me to a wrong direction. Was assigning \"hard\" intentional for these reasons? Or was it just a srew up on the admins\\' side?\\n\\nMy weakness is that I overcomplicate problems way too often, and I appreciate this learning  :) I think a better contents strategy would be to try a simple solution first. You can get in on luck, or you will get a good test case. The penalty for a wrong submission is 5 minutes, not 10 as it used to be :)"
                    },
                    {
                        "username": "Hrabesim",
                        "content": "It literary took me 2-3 minutes to code. :/"
                    },
                    {
                        "username": "AaveshK",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Could\\'ve been limited to premium users post the contest. "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I agree! I think this problem is a newly added problem in LC (looking at the solutions tab which has 513 solutions as of now - seasoned problems show 999+). \\n\\nSimilarly if we look at LeetCode 1128 (https://leetcode.com/problems/number-of-equivalent-domino-pairs/description/), it is categorized as Easy however it gives TLE on brute force solution and has a slightly trickier hashing logic to come up with for an easy problem. "
                    },
                    {
                        "username": "doggg2",
                        "content": "The key as discussed, is to observe that **when k = 2, it is possible to swap any two adjacent characters in the string**. To see why this is the case, consider any string s and any index i:\\n```s == s[0:i] + s[i] + s[i+1] + s[i + 2:]```\\n\\nThen we can swap i, i + 1 by doing these steps:\\n1. Keep putting the first character to the end until s[i] becomes the first character. Now we have a string ```s[i] + s[i+1] + s[i + 2:] + s[0:i]```\\n2. Put s[i] to the back. Now we have ```s[i + 1] + s[i+2:] + s[0:i] +s[i]```\\n3. Keep putting the second character to the end until s[i] becomes the second character. Now we have ```s[i+1] + s[i] + s[i + 2:] + s[0:i]```\\n4. Steps 2 and 3 have swapped i and i + 1. Now keep putting the first character to the back until we have ```s[0:i] + s[i + 1] + s[i] + s[i+2:]```\\n\\nIf you find this useful give an upvote."
                    },
                    {
                        "username": "happyleetcode",
                        "content": "Assume l is String length and  the target 2 chars\\' index is i and j. it should have 0<=i<j<l\\nso the structrue is that\\n[L] I [M] J [R]\\n[L] means the chars left to the I, the size of L shoule >=0\\n[M] means the chars between I and J, the size of M shoule >=0\\n[R] means the chars right to the J,the size of R shoule >=0\\nMOVE 1 means always move first char to the end\\nMOVE 2 means always move second char to the end.\\nthe target string should be  [L] J [M] I [R]\\n\\n\\tStep1. MOVE 1 until the string become      ** I  [M]  J  [R] [L]**\\n\\tStep2. MOVE 2 until the string become      ** I   J  [R] [L] [M]**\\n\\tStep3. MOVE 1 until the string become      ** J  [R] [L] [M]  I **\\n\\tStep4. MOVE 2 until the string become      ** J  [M]  I  [R] [L]**\\n\\tStep5. MOVE 1 until the string become      **[L]  J  [M]  I  [R]**"
                    },
                    {
                        "username": "Depender",
                        "content": "Initially I thought for some sorted rotatory arrangements but just realized it as a variation of bubble sort for k > 1. Hmm..! This was quite interesting and a bit confusing as well \\uD83D\\uDE05"
                    },
                    {
                        "username": "cpollock",
                        "content": "For test case 38, would not \"hntq\" be considered smaller than expected result \"htqn\"? My understanding of \"lexicographically smaller\" is the same as: https://en.wikipedia.org/wiki/Lexicographical_order\\n\\n![image](https://assets.leetcode.com/users/cpollock/image_1563820655.png)\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "with k==1 all you can do is rotate the string, so hntq is not possible"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "No matter how many times you rotate, you cannot change the order of h and n in this string with k=1. "
                    },
                    {
                        "username": "code_report",
                        "content": "Contest wouldn\\'t let me submit my solution for this problem."
                    },
                    {
                        "username": "khubaibalam2000",
                        "content": "Can someone tell me what is the time complexity of this solution?\n\n`class Solution:\n    def orderlyQueue(self, s: str, k: int) -> str:\n\n        queue = list(s)\n        if k > 1: \n            queue.sort()\n            return \"\".join((queue))\n        else:\n            uni = set()\n            uni.add(s)\n            for i in range(len(s)):\n                big = ''\n                big = max(big, s[0])\n                queue.remove(big)\n                queue.append(big)\n                temp = \"\".join(queue)\n                if temp not in uni:\n                    uni.add(temp)\n                    s = \"\".join(queue)\n                else: break\n        \n        words = list(uni)\n        words.sort()\n        return words[0]`\n"
                    },
                    {
                        "username": "bharatchauhan340",
                        "content": "How to solve ? if Any integer m is given denoting the maximum times this operation can be performed."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "if that is the case, then I think either the greedy way (which will not work) or just the recursion tbh exploring all ways"
                    }
                ]
            },
            {
                "id": 1673181,
                "content": [
                    {
                        "username": "cortexauth",
                        "content": "This had strong Codeforces vibe to it"
                    },
                    {
                        "username": "Ct-nep",
                        "content": "Is there any mathematical proof that the answer would always be lexicographically smallest (sorted) string if k > 1?"
                    },
                    {
                        "username": "JJATIN",
                        "content": "for k >1 its simply bubble sort"
                    },
                    {
                        "username": "supertaiyaki",
                        "content": "Hardly a proper proof but note that you can swap the two elements at the head of the string if k >= 2 (2nd element, 1st element, then take them in order until you get back to the start). You can also swap any arbitrary elements by rotating the string to the position you need, swapping, then rotating the rest of the way around. With those operations you can execute a bubble sort. It\\'s not too hard to verify the correctness of bubble sort if you want to go that far."
                    },
                    {
                        "username": "shabes",
                        "content": "It is relatively straightforward (no need for group theory :-)). We build the sorted string iteratively. At each iteration we start with smallest m characters sorted as a substring somewhere in our string (at the very first iteration we have m = 1 and it is a single smallest character somewhere). We will use position 0 as our \"storage\" for the next smallest character like this: cycle through the string by appending character from position 1 to the end (observe that this will not disturb our already sorted chain) until we see our target character (next smallest). Then we append character from position 0 to the end pushing our target into \"storage\". Now we cycle again by appending position 1 to the end until we line up our chain at the end of the string. Finally, we append character from storage to the end. Now we have m+1 sorted chain. Repeat until all characters are sorted."
                    },
                    {
                        "username": "narayan1281",
                        "content": "Yes!\\nSuppose s = \"zyxwonmab\" and k >1 (say k = 2)\\n// I would explain it using a priority_queue --> in fact a min heap priority_queue of size atmost k\\n// first push first k letters in priority_queue \\n// assume s1 = \"\"; --> temporary string to store result of first rotation\\n// take out the top of priority_queue (pq)\\ns1 = \"y\" and push next character in priority_queue --> pq = \"xz\"\\n// next-step\\ns1 = \"yx\" and pq = \"wz\"\\n// next step\\ns1 =\"yxw\" and pq = \"oz\"\\n// next\\ns1=\"yxwo\" and pq =\"nz\"\\n.\\n.\\n.\\ns1 =\"yxwonmab\" and pq=\"z\"\\n// next step\\ns1 =\"yxwonmabz\" and pq=\"\"--> empty as we have reached the end of first loop\\n\\n// From the above what we observe, in every full iteration of loop we put a \"largest value character\" at the end of the string\\n// so in we carry on the same looping process for n-1 number of times then what we would get is the \"sorted\" string and\\n// sorted string is indeed the lexicographically smallest permutation of s.\\n\\nI hope it helps. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I got to know about it when I was playing with the test cases. But if you really think if you have k>=2 then you can compare 2 elements and do work accordingly. And since there is no restriction on number of moves you will get to the sorted string eventually."
                    },
                    {
                        "username": "cortexauth",
                        "content": "Group theory talks about such permutations. We talk about cycles in this context, for example, a cycle (123..n) means send 1st element to nth position, send 2nd to 1st, 3rd to 2nd, and so on, in short, a left rotation. Moreover, we have a special cases such as transpositions , ex (12), which is basically a swap\\n\\nThese two are enough to generate any permutations for sequence of size 3\\n\\nI think there must be a more general proof as such.\\n\\nOnce done, we can argue that such moves can lead to any possible permutation of the elements, and even the sorted one, and hence the correctness proved"
                    },
                    {
                        "username": "votrubac",
                        "content": "I bet many people got a gist that you either sort or rotate. However, I did not expect a \"hard\" problem on LC to have a BF solution.\\n\\nSeeing this problme as \"hard\" sent me to a wrong direction. Was assigning \"hard\" intentional for these reasons? Or was it just a srew up on the admins\\' side?\\n\\nMy weakness is that I overcomplicate problems way too often, and I appreciate this learning  :) I think a better contents strategy would be to try a simple solution first. You can get in on luck, or you will get a good test case. The penalty for a wrong submission is 5 minutes, not 10 as it used to be :)"
                    },
                    {
                        "username": "Hrabesim",
                        "content": "It literary took me 2-3 minutes to code. :/"
                    },
                    {
                        "username": "AaveshK",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Could\\'ve been limited to premium users post the contest. "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I agree! I think this problem is a newly added problem in LC (looking at the solutions tab which has 513 solutions as of now - seasoned problems show 999+). \\n\\nSimilarly if we look at LeetCode 1128 (https://leetcode.com/problems/number-of-equivalent-domino-pairs/description/), it is categorized as Easy however it gives TLE on brute force solution and has a slightly trickier hashing logic to come up with for an easy problem. "
                    },
                    {
                        "username": "doggg2",
                        "content": "The key as discussed, is to observe that **when k = 2, it is possible to swap any two adjacent characters in the string**. To see why this is the case, consider any string s and any index i:\\n```s == s[0:i] + s[i] + s[i+1] + s[i + 2:]```\\n\\nThen we can swap i, i + 1 by doing these steps:\\n1. Keep putting the first character to the end until s[i] becomes the first character. Now we have a string ```s[i] + s[i+1] + s[i + 2:] + s[0:i]```\\n2. Put s[i] to the back. Now we have ```s[i + 1] + s[i+2:] + s[0:i] +s[i]```\\n3. Keep putting the second character to the end until s[i] becomes the second character. Now we have ```s[i+1] + s[i] + s[i + 2:] + s[0:i]```\\n4. Steps 2 and 3 have swapped i and i + 1. Now keep putting the first character to the back until we have ```s[0:i] + s[i + 1] + s[i] + s[i+2:]```\\n\\nIf you find this useful give an upvote."
                    },
                    {
                        "username": "happyleetcode",
                        "content": "Assume l is String length and  the target 2 chars\\' index is i and j. it should have 0<=i<j<l\\nso the structrue is that\\n[L] I [M] J [R]\\n[L] means the chars left to the I, the size of L shoule >=0\\n[M] means the chars between I and J, the size of M shoule >=0\\n[R] means the chars right to the J,the size of R shoule >=0\\nMOVE 1 means always move first char to the end\\nMOVE 2 means always move second char to the end.\\nthe target string should be  [L] J [M] I [R]\\n\\n\\tStep1. MOVE 1 until the string become      ** I  [M]  J  [R] [L]**\\n\\tStep2. MOVE 2 until the string become      ** I   J  [R] [L] [M]**\\n\\tStep3. MOVE 1 until the string become      ** J  [R] [L] [M]  I **\\n\\tStep4. MOVE 2 until the string become      ** J  [M]  I  [R] [L]**\\n\\tStep5. MOVE 1 until the string become      **[L]  J  [M]  I  [R]**"
                    },
                    {
                        "username": "Depender",
                        "content": "Initially I thought for some sorted rotatory arrangements but just realized it as a variation of bubble sort for k > 1. Hmm..! This was quite interesting and a bit confusing as well \\uD83D\\uDE05"
                    },
                    {
                        "username": "cpollock",
                        "content": "For test case 38, would not \"hntq\" be considered smaller than expected result \"htqn\"? My understanding of \"lexicographically smaller\" is the same as: https://en.wikipedia.org/wiki/Lexicographical_order\\n\\n![image](https://assets.leetcode.com/users/cpollock/image_1563820655.png)\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "with k==1 all you can do is rotate the string, so hntq is not possible"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "No matter how many times you rotate, you cannot change the order of h and n in this string with k=1. "
                    },
                    {
                        "username": "code_report",
                        "content": "Contest wouldn\\'t let me submit my solution for this problem."
                    },
                    {
                        "username": "khubaibalam2000",
                        "content": "Can someone tell me what is the time complexity of this solution?\n\n`class Solution:\n    def orderlyQueue(self, s: str, k: int) -> str:\n\n        queue = list(s)\n        if k > 1: \n            queue.sort()\n            return \"\".join((queue))\n        else:\n            uni = set()\n            uni.add(s)\n            for i in range(len(s)):\n                big = ''\n                big = max(big, s[0])\n                queue.remove(big)\n                queue.append(big)\n                temp = \"\".join(queue)\n                if temp not in uni:\n                    uni.add(temp)\n                    s = \"\".join(queue)\n                else: break\n        \n        words = list(uni)\n        words.sort()\n        return words[0]`\n"
                    },
                    {
                        "username": "bharatchauhan340",
                        "content": "How to solve ? if Any integer m is given denoting the maximum times this operation can be performed."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "if that is the case, then I think either the greedy way (which will not work) or just the recursion tbh exploring all ways"
                    }
                ]
            },
            {
                "id": 1572119,
                "content": [
                    {
                        "username": "cortexauth",
                        "content": "This had strong Codeforces vibe to it"
                    },
                    {
                        "username": "Ct-nep",
                        "content": "Is there any mathematical proof that the answer would always be lexicographically smallest (sorted) string if k > 1?"
                    },
                    {
                        "username": "JJATIN",
                        "content": "for k >1 its simply bubble sort"
                    },
                    {
                        "username": "supertaiyaki",
                        "content": "Hardly a proper proof but note that you can swap the two elements at the head of the string if k >= 2 (2nd element, 1st element, then take them in order until you get back to the start). You can also swap any arbitrary elements by rotating the string to the position you need, swapping, then rotating the rest of the way around. With those operations you can execute a bubble sort. It\\'s not too hard to verify the correctness of bubble sort if you want to go that far."
                    },
                    {
                        "username": "shabes",
                        "content": "It is relatively straightforward (no need for group theory :-)). We build the sorted string iteratively. At each iteration we start with smallest m characters sorted as a substring somewhere in our string (at the very first iteration we have m = 1 and it is a single smallest character somewhere). We will use position 0 as our \"storage\" for the next smallest character like this: cycle through the string by appending character from position 1 to the end (observe that this will not disturb our already sorted chain) until we see our target character (next smallest). Then we append character from position 0 to the end pushing our target into \"storage\". Now we cycle again by appending position 1 to the end until we line up our chain at the end of the string. Finally, we append character from storage to the end. Now we have m+1 sorted chain. Repeat until all characters are sorted."
                    },
                    {
                        "username": "narayan1281",
                        "content": "Yes!\\nSuppose s = \"zyxwonmab\" and k >1 (say k = 2)\\n// I would explain it using a priority_queue --> in fact a min heap priority_queue of size atmost k\\n// first push first k letters in priority_queue \\n// assume s1 = \"\"; --> temporary string to store result of first rotation\\n// take out the top of priority_queue (pq)\\ns1 = \"y\" and push next character in priority_queue --> pq = \"xz\"\\n// next-step\\ns1 = \"yx\" and pq = \"wz\"\\n// next step\\ns1 =\"yxw\" and pq = \"oz\"\\n// next\\ns1=\"yxwo\" and pq =\"nz\"\\n.\\n.\\n.\\ns1 =\"yxwonmab\" and pq=\"z\"\\n// next step\\ns1 =\"yxwonmabz\" and pq=\"\"--> empty as we have reached the end of first loop\\n\\n// From the above what we observe, in every full iteration of loop we put a \"largest value character\" at the end of the string\\n// so in we carry on the same looping process for n-1 number of times then what we would get is the \"sorted\" string and\\n// sorted string is indeed the lexicographically smallest permutation of s.\\n\\nI hope it helps. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I got to know about it when I was playing with the test cases. But if you really think if you have k>=2 then you can compare 2 elements and do work accordingly. And since there is no restriction on number of moves you will get to the sorted string eventually."
                    },
                    {
                        "username": "cortexauth",
                        "content": "Group theory talks about such permutations. We talk about cycles in this context, for example, a cycle (123..n) means send 1st element to nth position, send 2nd to 1st, 3rd to 2nd, and so on, in short, a left rotation. Moreover, we have a special cases such as transpositions , ex (12), which is basically a swap\\n\\nThese two are enough to generate any permutations for sequence of size 3\\n\\nI think there must be a more general proof as such.\\n\\nOnce done, we can argue that such moves can lead to any possible permutation of the elements, and even the sorted one, and hence the correctness proved"
                    },
                    {
                        "username": "votrubac",
                        "content": "I bet many people got a gist that you either sort or rotate. However, I did not expect a \"hard\" problem on LC to have a BF solution.\\n\\nSeeing this problme as \"hard\" sent me to a wrong direction. Was assigning \"hard\" intentional for these reasons? Or was it just a srew up on the admins\\' side?\\n\\nMy weakness is that I overcomplicate problems way too often, and I appreciate this learning  :) I think a better contents strategy would be to try a simple solution first. You can get in on luck, or you will get a good test case. The penalty for a wrong submission is 5 minutes, not 10 as it used to be :)"
                    },
                    {
                        "username": "Hrabesim",
                        "content": "It literary took me 2-3 minutes to code. :/"
                    },
                    {
                        "username": "AaveshK",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Could\\'ve been limited to premium users post the contest. "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I agree! I think this problem is a newly added problem in LC (looking at the solutions tab which has 513 solutions as of now - seasoned problems show 999+). \\n\\nSimilarly if we look at LeetCode 1128 (https://leetcode.com/problems/number-of-equivalent-domino-pairs/description/), it is categorized as Easy however it gives TLE on brute force solution and has a slightly trickier hashing logic to come up with for an easy problem. "
                    },
                    {
                        "username": "doggg2",
                        "content": "The key as discussed, is to observe that **when k = 2, it is possible to swap any two adjacent characters in the string**. To see why this is the case, consider any string s and any index i:\\n```s == s[0:i] + s[i] + s[i+1] + s[i + 2:]```\\n\\nThen we can swap i, i + 1 by doing these steps:\\n1. Keep putting the first character to the end until s[i] becomes the first character. Now we have a string ```s[i] + s[i+1] + s[i + 2:] + s[0:i]```\\n2. Put s[i] to the back. Now we have ```s[i + 1] + s[i+2:] + s[0:i] +s[i]```\\n3. Keep putting the second character to the end until s[i] becomes the second character. Now we have ```s[i+1] + s[i] + s[i + 2:] + s[0:i]```\\n4. Steps 2 and 3 have swapped i and i + 1. Now keep putting the first character to the back until we have ```s[0:i] + s[i + 1] + s[i] + s[i+2:]```\\n\\nIf you find this useful give an upvote."
                    },
                    {
                        "username": "happyleetcode",
                        "content": "Assume l is String length and  the target 2 chars\\' index is i and j. it should have 0<=i<j<l\\nso the structrue is that\\n[L] I [M] J [R]\\n[L] means the chars left to the I, the size of L shoule >=0\\n[M] means the chars between I and J, the size of M shoule >=0\\n[R] means the chars right to the J,the size of R shoule >=0\\nMOVE 1 means always move first char to the end\\nMOVE 2 means always move second char to the end.\\nthe target string should be  [L] J [M] I [R]\\n\\n\\tStep1. MOVE 1 until the string become      ** I  [M]  J  [R] [L]**\\n\\tStep2. MOVE 2 until the string become      ** I   J  [R] [L] [M]**\\n\\tStep3. MOVE 1 until the string become      ** J  [R] [L] [M]  I **\\n\\tStep4. MOVE 2 until the string become      ** J  [M]  I  [R] [L]**\\n\\tStep5. MOVE 1 until the string become      **[L]  J  [M]  I  [R]**"
                    },
                    {
                        "username": "Depender",
                        "content": "Initially I thought for some sorted rotatory arrangements but just realized it as a variation of bubble sort for k > 1. Hmm..! This was quite interesting and a bit confusing as well \\uD83D\\uDE05"
                    },
                    {
                        "username": "cpollock",
                        "content": "For test case 38, would not \"hntq\" be considered smaller than expected result \"htqn\"? My understanding of \"lexicographically smaller\" is the same as: https://en.wikipedia.org/wiki/Lexicographical_order\\n\\n![image](https://assets.leetcode.com/users/cpollock/image_1563820655.png)\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "with k==1 all you can do is rotate the string, so hntq is not possible"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "No matter how many times you rotate, you cannot change the order of h and n in this string with k=1. "
                    },
                    {
                        "username": "code_report",
                        "content": "Contest wouldn\\'t let me submit my solution for this problem."
                    },
                    {
                        "username": "khubaibalam2000",
                        "content": "Can someone tell me what is the time complexity of this solution?\n\n`class Solution:\n    def orderlyQueue(self, s: str, k: int) -> str:\n\n        queue = list(s)\n        if k > 1: \n            queue.sort()\n            return \"\".join((queue))\n        else:\n            uni = set()\n            uni.add(s)\n            for i in range(len(s)):\n                big = ''\n                big = max(big, s[0])\n                queue.remove(big)\n                queue.append(big)\n                temp = \"\".join(queue)\n                if temp not in uni:\n                    uni.add(temp)\n                    s = \"\".join(queue)\n                else: break\n        \n        words = list(uni)\n        words.sort()\n        return words[0]`\n"
                    },
                    {
                        "username": "bharatchauhan340",
                        "content": "How to solve ? if Any integer m is given denoting the maximum times this operation can be performed."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "if that is the case, then I think either the greedy way (which will not work) or just the recursion tbh exploring all ways"
                    }
                ]
            },
            {
                "id": 1674194,
                "content": [
                    {
                        "username": "cortexauth",
                        "content": "This had strong Codeforces vibe to it"
                    },
                    {
                        "username": "Ct-nep",
                        "content": "Is there any mathematical proof that the answer would always be lexicographically smallest (sorted) string if k > 1?"
                    },
                    {
                        "username": "JJATIN",
                        "content": "for k >1 its simply bubble sort"
                    },
                    {
                        "username": "supertaiyaki",
                        "content": "Hardly a proper proof but note that you can swap the two elements at the head of the string if k >= 2 (2nd element, 1st element, then take them in order until you get back to the start). You can also swap any arbitrary elements by rotating the string to the position you need, swapping, then rotating the rest of the way around. With those operations you can execute a bubble sort. It\\'s not too hard to verify the correctness of bubble sort if you want to go that far."
                    },
                    {
                        "username": "shabes",
                        "content": "It is relatively straightforward (no need for group theory :-)). We build the sorted string iteratively. At each iteration we start with smallest m characters sorted as a substring somewhere in our string (at the very first iteration we have m = 1 and it is a single smallest character somewhere). We will use position 0 as our \"storage\" for the next smallest character like this: cycle through the string by appending character from position 1 to the end (observe that this will not disturb our already sorted chain) until we see our target character (next smallest). Then we append character from position 0 to the end pushing our target into \"storage\". Now we cycle again by appending position 1 to the end until we line up our chain at the end of the string. Finally, we append character from storage to the end. Now we have m+1 sorted chain. Repeat until all characters are sorted."
                    },
                    {
                        "username": "narayan1281",
                        "content": "Yes!\\nSuppose s = \"zyxwonmab\" and k >1 (say k = 2)\\n// I would explain it using a priority_queue --> in fact a min heap priority_queue of size atmost k\\n// first push first k letters in priority_queue \\n// assume s1 = \"\"; --> temporary string to store result of first rotation\\n// take out the top of priority_queue (pq)\\ns1 = \"y\" and push next character in priority_queue --> pq = \"xz\"\\n// next-step\\ns1 = \"yx\" and pq = \"wz\"\\n// next step\\ns1 =\"yxw\" and pq = \"oz\"\\n// next\\ns1=\"yxwo\" and pq =\"nz\"\\n.\\n.\\n.\\ns1 =\"yxwonmab\" and pq=\"z\"\\n// next step\\ns1 =\"yxwonmabz\" and pq=\"\"--> empty as we have reached the end of first loop\\n\\n// From the above what we observe, in every full iteration of loop we put a \"largest value character\" at the end of the string\\n// so in we carry on the same looping process for n-1 number of times then what we would get is the \"sorted\" string and\\n// sorted string is indeed the lexicographically smallest permutation of s.\\n\\nI hope it helps. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I got to know about it when I was playing with the test cases. But if you really think if you have k>=2 then you can compare 2 elements and do work accordingly. And since there is no restriction on number of moves you will get to the sorted string eventually."
                    },
                    {
                        "username": "cortexauth",
                        "content": "Group theory talks about such permutations. We talk about cycles in this context, for example, a cycle (123..n) means send 1st element to nth position, send 2nd to 1st, 3rd to 2nd, and so on, in short, a left rotation. Moreover, we have a special cases such as transpositions , ex (12), which is basically a swap\\n\\nThese two are enough to generate any permutations for sequence of size 3\\n\\nI think there must be a more general proof as such.\\n\\nOnce done, we can argue that such moves can lead to any possible permutation of the elements, and even the sorted one, and hence the correctness proved"
                    },
                    {
                        "username": "votrubac",
                        "content": "I bet many people got a gist that you either sort or rotate. However, I did not expect a \"hard\" problem on LC to have a BF solution.\\n\\nSeeing this problme as \"hard\" sent me to a wrong direction. Was assigning \"hard\" intentional for these reasons? Or was it just a srew up on the admins\\' side?\\n\\nMy weakness is that I overcomplicate problems way too often, and I appreciate this learning  :) I think a better contents strategy would be to try a simple solution first. You can get in on luck, or you will get a good test case. The penalty for a wrong submission is 5 minutes, not 10 as it used to be :)"
                    },
                    {
                        "username": "Hrabesim",
                        "content": "It literary took me 2-3 minutes to code. :/"
                    },
                    {
                        "username": "AaveshK",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Could\\'ve been limited to premium users post the contest. "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I agree! I think this problem is a newly added problem in LC (looking at the solutions tab which has 513 solutions as of now - seasoned problems show 999+). \\n\\nSimilarly if we look at LeetCode 1128 (https://leetcode.com/problems/number-of-equivalent-domino-pairs/description/), it is categorized as Easy however it gives TLE on brute force solution and has a slightly trickier hashing logic to come up with for an easy problem. "
                    },
                    {
                        "username": "doggg2",
                        "content": "The key as discussed, is to observe that **when k = 2, it is possible to swap any two adjacent characters in the string**. To see why this is the case, consider any string s and any index i:\\n```s == s[0:i] + s[i] + s[i+1] + s[i + 2:]```\\n\\nThen we can swap i, i + 1 by doing these steps:\\n1. Keep putting the first character to the end until s[i] becomes the first character. Now we have a string ```s[i] + s[i+1] + s[i + 2:] + s[0:i]```\\n2. Put s[i] to the back. Now we have ```s[i + 1] + s[i+2:] + s[0:i] +s[i]```\\n3. Keep putting the second character to the end until s[i] becomes the second character. Now we have ```s[i+1] + s[i] + s[i + 2:] + s[0:i]```\\n4. Steps 2 and 3 have swapped i and i + 1. Now keep putting the first character to the back until we have ```s[0:i] + s[i + 1] + s[i] + s[i+2:]```\\n\\nIf you find this useful give an upvote."
                    },
                    {
                        "username": "happyleetcode",
                        "content": "Assume l is String length and  the target 2 chars\\' index is i and j. it should have 0<=i<j<l\\nso the structrue is that\\n[L] I [M] J [R]\\n[L] means the chars left to the I, the size of L shoule >=0\\n[M] means the chars between I and J, the size of M shoule >=0\\n[R] means the chars right to the J,the size of R shoule >=0\\nMOVE 1 means always move first char to the end\\nMOVE 2 means always move second char to the end.\\nthe target string should be  [L] J [M] I [R]\\n\\n\\tStep1. MOVE 1 until the string become      ** I  [M]  J  [R] [L]**\\n\\tStep2. MOVE 2 until the string become      ** I   J  [R] [L] [M]**\\n\\tStep3. MOVE 1 until the string become      ** J  [R] [L] [M]  I **\\n\\tStep4. MOVE 2 until the string become      ** J  [M]  I  [R] [L]**\\n\\tStep5. MOVE 1 until the string become      **[L]  J  [M]  I  [R]**"
                    },
                    {
                        "username": "Depender",
                        "content": "Initially I thought for some sorted rotatory arrangements but just realized it as a variation of bubble sort for k > 1. Hmm..! This was quite interesting and a bit confusing as well \\uD83D\\uDE05"
                    },
                    {
                        "username": "cpollock",
                        "content": "For test case 38, would not \"hntq\" be considered smaller than expected result \"htqn\"? My understanding of \"lexicographically smaller\" is the same as: https://en.wikipedia.org/wiki/Lexicographical_order\\n\\n![image](https://assets.leetcode.com/users/cpollock/image_1563820655.png)\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "with k==1 all you can do is rotate the string, so hntq is not possible"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "No matter how many times you rotate, you cannot change the order of h and n in this string with k=1. "
                    },
                    {
                        "username": "code_report",
                        "content": "Contest wouldn\\'t let me submit my solution for this problem."
                    },
                    {
                        "username": "khubaibalam2000",
                        "content": "Can someone tell me what is the time complexity of this solution?\n\n`class Solution:\n    def orderlyQueue(self, s: str, k: int) -> str:\n\n        queue = list(s)\n        if k > 1: \n            queue.sort()\n            return \"\".join((queue))\n        else:\n            uni = set()\n            uni.add(s)\n            for i in range(len(s)):\n                big = ''\n                big = max(big, s[0])\n                queue.remove(big)\n                queue.append(big)\n                temp = \"\".join(queue)\n                if temp not in uni:\n                    uni.add(temp)\n                    s = \"\".join(queue)\n                else: break\n        \n        words = list(uni)\n        words.sort()\n        return words[0]`\n"
                    },
                    {
                        "username": "bharatchauhan340",
                        "content": "How to solve ? if Any integer m is given denoting the maximum times this operation can be performed."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "if that is the case, then I think either the greedy way (which will not work) or just the recursion tbh exploring all ways"
                    }
                ]
            },
            {
                "id": 1569287,
                "content": [
                    {
                        "username": "cortexauth",
                        "content": "This had strong Codeforces vibe to it"
                    },
                    {
                        "username": "Ct-nep",
                        "content": "Is there any mathematical proof that the answer would always be lexicographically smallest (sorted) string if k > 1?"
                    },
                    {
                        "username": "JJATIN",
                        "content": "for k >1 its simply bubble sort"
                    },
                    {
                        "username": "supertaiyaki",
                        "content": "Hardly a proper proof but note that you can swap the two elements at the head of the string if k >= 2 (2nd element, 1st element, then take them in order until you get back to the start). You can also swap any arbitrary elements by rotating the string to the position you need, swapping, then rotating the rest of the way around. With those operations you can execute a bubble sort. It\\'s not too hard to verify the correctness of bubble sort if you want to go that far."
                    },
                    {
                        "username": "shabes",
                        "content": "It is relatively straightforward (no need for group theory :-)). We build the sorted string iteratively. At each iteration we start with smallest m characters sorted as a substring somewhere in our string (at the very first iteration we have m = 1 and it is a single smallest character somewhere). We will use position 0 as our \"storage\" for the next smallest character like this: cycle through the string by appending character from position 1 to the end (observe that this will not disturb our already sorted chain) until we see our target character (next smallest). Then we append character from position 0 to the end pushing our target into \"storage\". Now we cycle again by appending position 1 to the end until we line up our chain at the end of the string. Finally, we append character from storage to the end. Now we have m+1 sorted chain. Repeat until all characters are sorted."
                    },
                    {
                        "username": "narayan1281",
                        "content": "Yes!\\nSuppose s = \"zyxwonmab\" and k >1 (say k = 2)\\n// I would explain it using a priority_queue --> in fact a min heap priority_queue of size atmost k\\n// first push first k letters in priority_queue \\n// assume s1 = \"\"; --> temporary string to store result of first rotation\\n// take out the top of priority_queue (pq)\\ns1 = \"y\" and push next character in priority_queue --> pq = \"xz\"\\n// next-step\\ns1 = \"yx\" and pq = \"wz\"\\n// next step\\ns1 =\"yxw\" and pq = \"oz\"\\n// next\\ns1=\"yxwo\" and pq =\"nz\"\\n.\\n.\\n.\\ns1 =\"yxwonmab\" and pq=\"z\"\\n// next step\\ns1 =\"yxwonmabz\" and pq=\"\"--> empty as we have reached the end of first loop\\n\\n// From the above what we observe, in every full iteration of loop we put a \"largest value character\" at the end of the string\\n// so in we carry on the same looping process for n-1 number of times then what we would get is the \"sorted\" string and\\n// sorted string is indeed the lexicographically smallest permutation of s.\\n\\nI hope it helps. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I got to know about it when I was playing with the test cases. But if you really think if you have k>=2 then you can compare 2 elements and do work accordingly. And since there is no restriction on number of moves you will get to the sorted string eventually."
                    },
                    {
                        "username": "cortexauth",
                        "content": "Group theory talks about such permutations. We talk about cycles in this context, for example, a cycle (123..n) means send 1st element to nth position, send 2nd to 1st, 3rd to 2nd, and so on, in short, a left rotation. Moreover, we have a special cases such as transpositions , ex (12), which is basically a swap\\n\\nThese two are enough to generate any permutations for sequence of size 3\\n\\nI think there must be a more general proof as such.\\n\\nOnce done, we can argue that such moves can lead to any possible permutation of the elements, and even the sorted one, and hence the correctness proved"
                    },
                    {
                        "username": "votrubac",
                        "content": "I bet many people got a gist that you either sort or rotate. However, I did not expect a \"hard\" problem on LC to have a BF solution.\\n\\nSeeing this problme as \"hard\" sent me to a wrong direction. Was assigning \"hard\" intentional for these reasons? Or was it just a srew up on the admins\\' side?\\n\\nMy weakness is that I overcomplicate problems way too often, and I appreciate this learning  :) I think a better contents strategy would be to try a simple solution first. You can get in on luck, or you will get a good test case. The penalty for a wrong submission is 5 minutes, not 10 as it used to be :)"
                    },
                    {
                        "username": "Hrabesim",
                        "content": "It literary took me 2-3 minutes to code. :/"
                    },
                    {
                        "username": "AaveshK",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Could\\'ve been limited to premium users post the contest. "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I agree! I think this problem is a newly added problem in LC (looking at the solutions tab which has 513 solutions as of now - seasoned problems show 999+). \\n\\nSimilarly if we look at LeetCode 1128 (https://leetcode.com/problems/number-of-equivalent-domino-pairs/description/), it is categorized as Easy however it gives TLE on brute force solution and has a slightly trickier hashing logic to come up with for an easy problem. "
                    },
                    {
                        "username": "doggg2",
                        "content": "The key as discussed, is to observe that **when k = 2, it is possible to swap any two adjacent characters in the string**. To see why this is the case, consider any string s and any index i:\\n```s == s[0:i] + s[i] + s[i+1] + s[i + 2:]```\\n\\nThen we can swap i, i + 1 by doing these steps:\\n1. Keep putting the first character to the end until s[i] becomes the first character. Now we have a string ```s[i] + s[i+1] + s[i + 2:] + s[0:i]```\\n2. Put s[i] to the back. Now we have ```s[i + 1] + s[i+2:] + s[0:i] +s[i]```\\n3. Keep putting the second character to the end until s[i] becomes the second character. Now we have ```s[i+1] + s[i] + s[i + 2:] + s[0:i]```\\n4. Steps 2 and 3 have swapped i and i + 1. Now keep putting the first character to the back until we have ```s[0:i] + s[i + 1] + s[i] + s[i+2:]```\\n\\nIf you find this useful give an upvote."
                    },
                    {
                        "username": "happyleetcode",
                        "content": "Assume l is String length and  the target 2 chars\\' index is i and j. it should have 0<=i<j<l\\nso the structrue is that\\n[L] I [M] J [R]\\n[L] means the chars left to the I, the size of L shoule >=0\\n[M] means the chars between I and J, the size of M shoule >=0\\n[R] means the chars right to the J,the size of R shoule >=0\\nMOVE 1 means always move first char to the end\\nMOVE 2 means always move second char to the end.\\nthe target string should be  [L] J [M] I [R]\\n\\n\\tStep1. MOVE 1 until the string become      ** I  [M]  J  [R] [L]**\\n\\tStep2. MOVE 2 until the string become      ** I   J  [R] [L] [M]**\\n\\tStep3. MOVE 1 until the string become      ** J  [R] [L] [M]  I **\\n\\tStep4. MOVE 2 until the string become      ** J  [M]  I  [R] [L]**\\n\\tStep5. MOVE 1 until the string become      **[L]  J  [M]  I  [R]**"
                    },
                    {
                        "username": "Depender",
                        "content": "Initially I thought for some sorted rotatory arrangements but just realized it as a variation of bubble sort for k > 1. Hmm..! This was quite interesting and a bit confusing as well \\uD83D\\uDE05"
                    },
                    {
                        "username": "cpollock",
                        "content": "For test case 38, would not \"hntq\" be considered smaller than expected result \"htqn\"? My understanding of \"lexicographically smaller\" is the same as: https://en.wikipedia.org/wiki/Lexicographical_order\\n\\n![image](https://assets.leetcode.com/users/cpollock/image_1563820655.png)\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "with k==1 all you can do is rotate the string, so hntq is not possible"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "No matter how many times you rotate, you cannot change the order of h and n in this string with k=1. "
                    },
                    {
                        "username": "code_report",
                        "content": "Contest wouldn\\'t let me submit my solution for this problem."
                    },
                    {
                        "username": "khubaibalam2000",
                        "content": "Can someone tell me what is the time complexity of this solution?\n\n`class Solution:\n    def orderlyQueue(self, s: str, k: int) -> str:\n\n        queue = list(s)\n        if k > 1: \n            queue.sort()\n            return \"\".join((queue))\n        else:\n            uni = set()\n            uni.add(s)\n            for i in range(len(s)):\n                big = ''\n                big = max(big, s[0])\n                queue.remove(big)\n                queue.append(big)\n                temp = \"\".join(queue)\n                if temp not in uni:\n                    uni.add(temp)\n                    s = \"\".join(queue)\n                else: break\n        \n        words = list(uni)\n        words.sort()\n        return words[0]`\n"
                    },
                    {
                        "username": "bharatchauhan340",
                        "content": "How to solve ? if Any integer m is given denoting the maximum times this operation can be performed."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "if that is the case, then I think either the greedy way (which will not work) or just the recursion tbh exploring all ways"
                    }
                ]
            },
            {
                "id": 1673742,
                "content": [
                    {
                        "username": "cortexauth",
                        "content": "This had strong Codeforces vibe to it"
                    },
                    {
                        "username": "Ct-nep",
                        "content": "Is there any mathematical proof that the answer would always be lexicographically smallest (sorted) string if k > 1?"
                    },
                    {
                        "username": "JJATIN",
                        "content": "for k >1 its simply bubble sort"
                    },
                    {
                        "username": "supertaiyaki",
                        "content": "Hardly a proper proof but note that you can swap the two elements at the head of the string if k >= 2 (2nd element, 1st element, then take them in order until you get back to the start). You can also swap any arbitrary elements by rotating the string to the position you need, swapping, then rotating the rest of the way around. With those operations you can execute a bubble sort. It\\'s not too hard to verify the correctness of bubble sort if you want to go that far."
                    },
                    {
                        "username": "shabes",
                        "content": "It is relatively straightforward (no need for group theory :-)). We build the sorted string iteratively. At each iteration we start with smallest m characters sorted as a substring somewhere in our string (at the very first iteration we have m = 1 and it is a single smallest character somewhere). We will use position 0 as our \"storage\" for the next smallest character like this: cycle through the string by appending character from position 1 to the end (observe that this will not disturb our already sorted chain) until we see our target character (next smallest). Then we append character from position 0 to the end pushing our target into \"storage\". Now we cycle again by appending position 1 to the end until we line up our chain at the end of the string. Finally, we append character from storage to the end. Now we have m+1 sorted chain. Repeat until all characters are sorted."
                    },
                    {
                        "username": "narayan1281",
                        "content": "Yes!\\nSuppose s = \"zyxwonmab\" and k >1 (say k = 2)\\n// I would explain it using a priority_queue --> in fact a min heap priority_queue of size atmost k\\n// first push first k letters in priority_queue \\n// assume s1 = \"\"; --> temporary string to store result of first rotation\\n// take out the top of priority_queue (pq)\\ns1 = \"y\" and push next character in priority_queue --> pq = \"xz\"\\n// next-step\\ns1 = \"yx\" and pq = \"wz\"\\n// next step\\ns1 =\"yxw\" and pq = \"oz\"\\n// next\\ns1=\"yxwo\" and pq =\"nz\"\\n.\\n.\\n.\\ns1 =\"yxwonmab\" and pq=\"z\"\\n// next step\\ns1 =\"yxwonmabz\" and pq=\"\"--> empty as we have reached the end of first loop\\n\\n// From the above what we observe, in every full iteration of loop we put a \"largest value character\" at the end of the string\\n// so in we carry on the same looping process for n-1 number of times then what we would get is the \"sorted\" string and\\n// sorted string is indeed the lexicographically smallest permutation of s.\\n\\nI hope it helps. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I got to know about it when I was playing with the test cases. But if you really think if you have k>=2 then you can compare 2 elements and do work accordingly. And since there is no restriction on number of moves you will get to the sorted string eventually."
                    },
                    {
                        "username": "cortexauth",
                        "content": "Group theory talks about such permutations. We talk about cycles in this context, for example, a cycle (123..n) means send 1st element to nth position, send 2nd to 1st, 3rd to 2nd, and so on, in short, a left rotation. Moreover, we have a special cases such as transpositions , ex (12), which is basically a swap\\n\\nThese two are enough to generate any permutations for sequence of size 3\\n\\nI think there must be a more general proof as such.\\n\\nOnce done, we can argue that such moves can lead to any possible permutation of the elements, and even the sorted one, and hence the correctness proved"
                    },
                    {
                        "username": "votrubac",
                        "content": "I bet many people got a gist that you either sort or rotate. However, I did not expect a \"hard\" problem on LC to have a BF solution.\\n\\nSeeing this problme as \"hard\" sent me to a wrong direction. Was assigning \"hard\" intentional for these reasons? Or was it just a srew up on the admins\\' side?\\n\\nMy weakness is that I overcomplicate problems way too often, and I appreciate this learning  :) I think a better contents strategy would be to try a simple solution first. You can get in on luck, or you will get a good test case. The penalty for a wrong submission is 5 minutes, not 10 as it used to be :)"
                    },
                    {
                        "username": "Hrabesim",
                        "content": "It literary took me 2-3 minutes to code. :/"
                    },
                    {
                        "username": "AaveshK",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Could\\'ve been limited to premium users post the contest. "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I agree! I think this problem is a newly added problem in LC (looking at the solutions tab which has 513 solutions as of now - seasoned problems show 999+). \\n\\nSimilarly if we look at LeetCode 1128 (https://leetcode.com/problems/number-of-equivalent-domino-pairs/description/), it is categorized as Easy however it gives TLE on brute force solution and has a slightly trickier hashing logic to come up with for an easy problem. "
                    },
                    {
                        "username": "doggg2",
                        "content": "The key as discussed, is to observe that **when k = 2, it is possible to swap any two adjacent characters in the string**. To see why this is the case, consider any string s and any index i:\\n```s == s[0:i] + s[i] + s[i+1] + s[i + 2:]```\\n\\nThen we can swap i, i + 1 by doing these steps:\\n1. Keep putting the first character to the end until s[i] becomes the first character. Now we have a string ```s[i] + s[i+1] + s[i + 2:] + s[0:i]```\\n2. Put s[i] to the back. Now we have ```s[i + 1] + s[i+2:] + s[0:i] +s[i]```\\n3. Keep putting the second character to the end until s[i] becomes the second character. Now we have ```s[i+1] + s[i] + s[i + 2:] + s[0:i]```\\n4. Steps 2 and 3 have swapped i and i + 1. Now keep putting the first character to the back until we have ```s[0:i] + s[i + 1] + s[i] + s[i+2:]```\\n\\nIf you find this useful give an upvote."
                    },
                    {
                        "username": "happyleetcode",
                        "content": "Assume l is String length and  the target 2 chars\\' index is i and j. it should have 0<=i<j<l\\nso the structrue is that\\n[L] I [M] J [R]\\n[L] means the chars left to the I, the size of L shoule >=0\\n[M] means the chars between I and J, the size of M shoule >=0\\n[R] means the chars right to the J,the size of R shoule >=0\\nMOVE 1 means always move first char to the end\\nMOVE 2 means always move second char to the end.\\nthe target string should be  [L] J [M] I [R]\\n\\n\\tStep1. MOVE 1 until the string become      ** I  [M]  J  [R] [L]**\\n\\tStep2. MOVE 2 until the string become      ** I   J  [R] [L] [M]**\\n\\tStep3. MOVE 1 until the string become      ** J  [R] [L] [M]  I **\\n\\tStep4. MOVE 2 until the string become      ** J  [M]  I  [R] [L]**\\n\\tStep5. MOVE 1 until the string become      **[L]  J  [M]  I  [R]**"
                    },
                    {
                        "username": "Depender",
                        "content": "Initially I thought for some sorted rotatory arrangements but just realized it as a variation of bubble sort for k > 1. Hmm..! This was quite interesting and a bit confusing as well \\uD83D\\uDE05"
                    },
                    {
                        "username": "cpollock",
                        "content": "For test case 38, would not \"hntq\" be considered smaller than expected result \"htqn\"? My understanding of \"lexicographically smaller\" is the same as: https://en.wikipedia.org/wiki/Lexicographical_order\\n\\n![image](https://assets.leetcode.com/users/cpollock/image_1563820655.png)\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "with k==1 all you can do is rotate the string, so hntq is not possible"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "No matter how many times you rotate, you cannot change the order of h and n in this string with k=1. "
                    },
                    {
                        "username": "code_report",
                        "content": "Contest wouldn\\'t let me submit my solution for this problem."
                    },
                    {
                        "username": "khubaibalam2000",
                        "content": "Can someone tell me what is the time complexity of this solution?\n\n`class Solution:\n    def orderlyQueue(self, s: str, k: int) -> str:\n\n        queue = list(s)\n        if k > 1: \n            queue.sort()\n            return \"\".join((queue))\n        else:\n            uni = set()\n            uni.add(s)\n            for i in range(len(s)):\n                big = ''\n                big = max(big, s[0])\n                queue.remove(big)\n                queue.append(big)\n                temp = \"\".join(queue)\n                if temp not in uni:\n                    uni.add(temp)\n                    s = \"\".join(queue)\n                else: break\n        \n        words = list(uni)\n        words.sort()\n        return words[0]`\n"
                    },
                    {
                        "username": "bharatchauhan340",
                        "content": "How to solve ? if Any integer m is given denoting the maximum times this operation can be performed."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "if that is the case, then I think either the greedy way (which will not work) or just the recursion tbh exploring all ways"
                    }
                ]
            },
            {
                "id": 1572854,
                "content": [
                    {
                        "username": "cortexauth",
                        "content": "This had strong Codeforces vibe to it"
                    },
                    {
                        "username": "Ct-nep",
                        "content": "Is there any mathematical proof that the answer would always be lexicographically smallest (sorted) string if k > 1?"
                    },
                    {
                        "username": "JJATIN",
                        "content": "for k >1 its simply bubble sort"
                    },
                    {
                        "username": "supertaiyaki",
                        "content": "Hardly a proper proof but note that you can swap the two elements at the head of the string if k >= 2 (2nd element, 1st element, then take them in order until you get back to the start). You can also swap any arbitrary elements by rotating the string to the position you need, swapping, then rotating the rest of the way around. With those operations you can execute a bubble sort. It\\'s not too hard to verify the correctness of bubble sort if you want to go that far."
                    },
                    {
                        "username": "shabes",
                        "content": "It is relatively straightforward (no need for group theory :-)). We build the sorted string iteratively. At each iteration we start with smallest m characters sorted as a substring somewhere in our string (at the very first iteration we have m = 1 and it is a single smallest character somewhere). We will use position 0 as our \"storage\" for the next smallest character like this: cycle through the string by appending character from position 1 to the end (observe that this will not disturb our already sorted chain) until we see our target character (next smallest). Then we append character from position 0 to the end pushing our target into \"storage\". Now we cycle again by appending position 1 to the end until we line up our chain at the end of the string. Finally, we append character from storage to the end. Now we have m+1 sorted chain. Repeat until all characters are sorted."
                    },
                    {
                        "username": "narayan1281",
                        "content": "Yes!\\nSuppose s = \"zyxwonmab\" and k >1 (say k = 2)\\n// I would explain it using a priority_queue --> in fact a min heap priority_queue of size atmost k\\n// first push first k letters in priority_queue \\n// assume s1 = \"\"; --> temporary string to store result of first rotation\\n// take out the top of priority_queue (pq)\\ns1 = \"y\" and push next character in priority_queue --> pq = \"xz\"\\n// next-step\\ns1 = \"yx\" and pq = \"wz\"\\n// next step\\ns1 =\"yxw\" and pq = \"oz\"\\n// next\\ns1=\"yxwo\" and pq =\"nz\"\\n.\\n.\\n.\\ns1 =\"yxwonmab\" and pq=\"z\"\\n// next step\\ns1 =\"yxwonmabz\" and pq=\"\"--> empty as we have reached the end of first loop\\n\\n// From the above what we observe, in every full iteration of loop we put a \"largest value character\" at the end of the string\\n// so in we carry on the same looping process for n-1 number of times then what we would get is the \"sorted\" string and\\n// sorted string is indeed the lexicographically smallest permutation of s.\\n\\nI hope it helps. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I got to know about it when I was playing with the test cases. But if you really think if you have k>=2 then you can compare 2 elements and do work accordingly. And since there is no restriction on number of moves you will get to the sorted string eventually."
                    },
                    {
                        "username": "cortexauth",
                        "content": "Group theory talks about such permutations. We talk about cycles in this context, for example, a cycle (123..n) means send 1st element to nth position, send 2nd to 1st, 3rd to 2nd, and so on, in short, a left rotation. Moreover, we have a special cases such as transpositions , ex (12), which is basically a swap\\n\\nThese two are enough to generate any permutations for sequence of size 3\\n\\nI think there must be a more general proof as such.\\n\\nOnce done, we can argue that such moves can lead to any possible permutation of the elements, and even the sorted one, and hence the correctness proved"
                    },
                    {
                        "username": "votrubac",
                        "content": "I bet many people got a gist that you either sort or rotate. However, I did not expect a \"hard\" problem on LC to have a BF solution.\\n\\nSeeing this problme as \"hard\" sent me to a wrong direction. Was assigning \"hard\" intentional for these reasons? Or was it just a srew up on the admins\\' side?\\n\\nMy weakness is that I overcomplicate problems way too often, and I appreciate this learning  :) I think a better contents strategy would be to try a simple solution first. You can get in on luck, or you will get a good test case. The penalty for a wrong submission is 5 minutes, not 10 as it used to be :)"
                    },
                    {
                        "username": "Hrabesim",
                        "content": "It literary took me 2-3 minutes to code. :/"
                    },
                    {
                        "username": "AaveshK",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Could\\'ve been limited to premium users post the contest. "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I agree! I think this problem is a newly added problem in LC (looking at the solutions tab which has 513 solutions as of now - seasoned problems show 999+). \\n\\nSimilarly if we look at LeetCode 1128 (https://leetcode.com/problems/number-of-equivalent-domino-pairs/description/), it is categorized as Easy however it gives TLE on brute force solution and has a slightly trickier hashing logic to come up with for an easy problem. "
                    },
                    {
                        "username": "doggg2",
                        "content": "The key as discussed, is to observe that **when k = 2, it is possible to swap any two adjacent characters in the string**. To see why this is the case, consider any string s and any index i:\\n```s == s[0:i] + s[i] + s[i+1] + s[i + 2:]```\\n\\nThen we can swap i, i + 1 by doing these steps:\\n1. Keep putting the first character to the end until s[i] becomes the first character. Now we have a string ```s[i] + s[i+1] + s[i + 2:] + s[0:i]```\\n2. Put s[i] to the back. Now we have ```s[i + 1] + s[i+2:] + s[0:i] +s[i]```\\n3. Keep putting the second character to the end until s[i] becomes the second character. Now we have ```s[i+1] + s[i] + s[i + 2:] + s[0:i]```\\n4. Steps 2 and 3 have swapped i and i + 1. Now keep putting the first character to the back until we have ```s[0:i] + s[i + 1] + s[i] + s[i+2:]```\\n\\nIf you find this useful give an upvote."
                    },
                    {
                        "username": "happyleetcode",
                        "content": "Assume l is String length and  the target 2 chars\\' index is i and j. it should have 0<=i<j<l\\nso the structrue is that\\n[L] I [M] J [R]\\n[L] means the chars left to the I, the size of L shoule >=0\\n[M] means the chars between I and J, the size of M shoule >=0\\n[R] means the chars right to the J,the size of R shoule >=0\\nMOVE 1 means always move first char to the end\\nMOVE 2 means always move second char to the end.\\nthe target string should be  [L] J [M] I [R]\\n\\n\\tStep1. MOVE 1 until the string become      ** I  [M]  J  [R] [L]**\\n\\tStep2. MOVE 2 until the string become      ** I   J  [R] [L] [M]**\\n\\tStep3. MOVE 1 until the string become      ** J  [R] [L] [M]  I **\\n\\tStep4. MOVE 2 until the string become      ** J  [M]  I  [R] [L]**\\n\\tStep5. MOVE 1 until the string become      **[L]  J  [M]  I  [R]**"
                    },
                    {
                        "username": "Depender",
                        "content": "Initially I thought for some sorted rotatory arrangements but just realized it as a variation of bubble sort for k > 1. Hmm..! This was quite interesting and a bit confusing as well \\uD83D\\uDE05"
                    },
                    {
                        "username": "cpollock",
                        "content": "For test case 38, would not \"hntq\" be considered smaller than expected result \"htqn\"? My understanding of \"lexicographically smaller\" is the same as: https://en.wikipedia.org/wiki/Lexicographical_order\\n\\n![image](https://assets.leetcode.com/users/cpollock/image_1563820655.png)\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "with k==1 all you can do is rotate the string, so hntq is not possible"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "No matter how many times you rotate, you cannot change the order of h and n in this string with k=1. "
                    },
                    {
                        "username": "code_report",
                        "content": "Contest wouldn\\'t let me submit my solution for this problem."
                    },
                    {
                        "username": "khubaibalam2000",
                        "content": "Can someone tell me what is the time complexity of this solution?\n\n`class Solution:\n    def orderlyQueue(self, s: str, k: int) -> str:\n\n        queue = list(s)\n        if k > 1: \n            queue.sort()\n            return \"\".join((queue))\n        else:\n            uni = set()\n            uni.add(s)\n            for i in range(len(s)):\n                big = ''\n                big = max(big, s[0])\n                queue.remove(big)\n                queue.append(big)\n                temp = \"\".join(queue)\n                if temp not in uni:\n                    uni.add(temp)\n                    s = \"\".join(queue)\n                else: break\n        \n        words = list(uni)\n        words.sort()\n        return words[0]`\n"
                    },
                    {
                        "username": "bharatchauhan340",
                        "content": "How to solve ? if Any integer m is given denoting the maximum times this operation can be performed."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "if that is the case, then I think either the greedy way (which will not work) or just the recursion tbh exploring all ways"
                    }
                ]
            },
            {
                "id": 1569286,
                "content": [
                    {
                        "username": "cortexauth",
                        "content": "This had strong Codeforces vibe to it"
                    },
                    {
                        "username": "Ct-nep",
                        "content": "Is there any mathematical proof that the answer would always be lexicographically smallest (sorted) string if k > 1?"
                    },
                    {
                        "username": "JJATIN",
                        "content": "for k >1 its simply bubble sort"
                    },
                    {
                        "username": "supertaiyaki",
                        "content": "Hardly a proper proof but note that you can swap the two elements at the head of the string if k >= 2 (2nd element, 1st element, then take them in order until you get back to the start). You can also swap any arbitrary elements by rotating the string to the position you need, swapping, then rotating the rest of the way around. With those operations you can execute a bubble sort. It\\'s not too hard to verify the correctness of bubble sort if you want to go that far."
                    },
                    {
                        "username": "shabes",
                        "content": "It is relatively straightforward (no need for group theory :-)). We build the sorted string iteratively. At each iteration we start with smallest m characters sorted as a substring somewhere in our string (at the very first iteration we have m = 1 and it is a single smallest character somewhere). We will use position 0 as our \"storage\" for the next smallest character like this: cycle through the string by appending character from position 1 to the end (observe that this will not disturb our already sorted chain) until we see our target character (next smallest). Then we append character from position 0 to the end pushing our target into \"storage\". Now we cycle again by appending position 1 to the end until we line up our chain at the end of the string. Finally, we append character from storage to the end. Now we have m+1 sorted chain. Repeat until all characters are sorted."
                    },
                    {
                        "username": "narayan1281",
                        "content": "Yes!\\nSuppose s = \"zyxwonmab\" and k >1 (say k = 2)\\n// I would explain it using a priority_queue --> in fact a min heap priority_queue of size atmost k\\n// first push first k letters in priority_queue \\n// assume s1 = \"\"; --> temporary string to store result of first rotation\\n// take out the top of priority_queue (pq)\\ns1 = \"y\" and push next character in priority_queue --> pq = \"xz\"\\n// next-step\\ns1 = \"yx\" and pq = \"wz\"\\n// next step\\ns1 =\"yxw\" and pq = \"oz\"\\n// next\\ns1=\"yxwo\" and pq =\"nz\"\\n.\\n.\\n.\\ns1 =\"yxwonmab\" and pq=\"z\"\\n// next step\\ns1 =\"yxwonmabz\" and pq=\"\"--> empty as we have reached the end of first loop\\n\\n// From the above what we observe, in every full iteration of loop we put a \"largest value character\" at the end of the string\\n// so in we carry on the same looping process for n-1 number of times then what we would get is the \"sorted\" string and\\n// sorted string is indeed the lexicographically smallest permutation of s.\\n\\nI hope it helps. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I got to know about it when I was playing with the test cases. But if you really think if you have k>=2 then you can compare 2 elements and do work accordingly. And since there is no restriction on number of moves you will get to the sorted string eventually."
                    },
                    {
                        "username": "cortexauth",
                        "content": "Group theory talks about such permutations. We talk about cycles in this context, for example, a cycle (123..n) means send 1st element to nth position, send 2nd to 1st, 3rd to 2nd, and so on, in short, a left rotation. Moreover, we have a special cases such as transpositions , ex (12), which is basically a swap\\n\\nThese two are enough to generate any permutations for sequence of size 3\\n\\nI think there must be a more general proof as such.\\n\\nOnce done, we can argue that such moves can lead to any possible permutation of the elements, and even the sorted one, and hence the correctness proved"
                    },
                    {
                        "username": "votrubac",
                        "content": "I bet many people got a gist that you either sort or rotate. However, I did not expect a \"hard\" problem on LC to have a BF solution.\\n\\nSeeing this problme as \"hard\" sent me to a wrong direction. Was assigning \"hard\" intentional for these reasons? Or was it just a srew up on the admins\\' side?\\n\\nMy weakness is that I overcomplicate problems way too often, and I appreciate this learning  :) I think a better contents strategy would be to try a simple solution first. You can get in on luck, or you will get a good test case. The penalty for a wrong submission is 5 minutes, not 10 as it used to be :)"
                    },
                    {
                        "username": "Hrabesim",
                        "content": "It literary took me 2-3 minutes to code. :/"
                    },
                    {
                        "username": "AaveshK",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Could\\'ve been limited to premium users post the contest. "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I agree! I think this problem is a newly added problem in LC (looking at the solutions tab which has 513 solutions as of now - seasoned problems show 999+). \\n\\nSimilarly if we look at LeetCode 1128 (https://leetcode.com/problems/number-of-equivalent-domino-pairs/description/), it is categorized as Easy however it gives TLE on brute force solution and has a slightly trickier hashing logic to come up with for an easy problem. "
                    },
                    {
                        "username": "doggg2",
                        "content": "The key as discussed, is to observe that **when k = 2, it is possible to swap any two adjacent characters in the string**. To see why this is the case, consider any string s and any index i:\\n```s == s[0:i] + s[i] + s[i+1] + s[i + 2:]```\\n\\nThen we can swap i, i + 1 by doing these steps:\\n1. Keep putting the first character to the end until s[i] becomes the first character. Now we have a string ```s[i] + s[i+1] + s[i + 2:] + s[0:i]```\\n2. Put s[i] to the back. Now we have ```s[i + 1] + s[i+2:] + s[0:i] +s[i]```\\n3. Keep putting the second character to the end until s[i] becomes the second character. Now we have ```s[i+1] + s[i] + s[i + 2:] + s[0:i]```\\n4. Steps 2 and 3 have swapped i and i + 1. Now keep putting the first character to the back until we have ```s[0:i] + s[i + 1] + s[i] + s[i+2:]```\\n\\nIf you find this useful give an upvote."
                    },
                    {
                        "username": "happyleetcode",
                        "content": "Assume l is String length and  the target 2 chars\\' index is i and j. it should have 0<=i<j<l\\nso the structrue is that\\n[L] I [M] J [R]\\n[L] means the chars left to the I, the size of L shoule >=0\\n[M] means the chars between I and J, the size of M shoule >=0\\n[R] means the chars right to the J,the size of R shoule >=0\\nMOVE 1 means always move first char to the end\\nMOVE 2 means always move second char to the end.\\nthe target string should be  [L] J [M] I [R]\\n\\n\\tStep1. MOVE 1 until the string become      ** I  [M]  J  [R] [L]**\\n\\tStep2. MOVE 2 until the string become      ** I   J  [R] [L] [M]**\\n\\tStep3. MOVE 1 until the string become      ** J  [R] [L] [M]  I **\\n\\tStep4. MOVE 2 until the string become      ** J  [M]  I  [R] [L]**\\n\\tStep5. MOVE 1 until the string become      **[L]  J  [M]  I  [R]**"
                    },
                    {
                        "username": "Depender",
                        "content": "Initially I thought for some sorted rotatory arrangements but just realized it as a variation of bubble sort for k > 1. Hmm..! This was quite interesting and a bit confusing as well \\uD83D\\uDE05"
                    },
                    {
                        "username": "cpollock",
                        "content": "For test case 38, would not \"hntq\" be considered smaller than expected result \"htqn\"? My understanding of \"lexicographically smaller\" is the same as: https://en.wikipedia.org/wiki/Lexicographical_order\\n\\n![image](https://assets.leetcode.com/users/cpollock/image_1563820655.png)\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "with k==1 all you can do is rotate the string, so hntq is not possible"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "No matter how many times you rotate, you cannot change the order of h and n in this string with k=1. "
                    },
                    {
                        "username": "code_report",
                        "content": "Contest wouldn\\'t let me submit my solution for this problem."
                    },
                    {
                        "username": "khubaibalam2000",
                        "content": "Can someone tell me what is the time complexity of this solution?\n\n`class Solution:\n    def orderlyQueue(self, s: str, k: int) -> str:\n\n        queue = list(s)\n        if k > 1: \n            queue.sort()\n            return \"\".join((queue))\n        else:\n            uni = set()\n            uni.add(s)\n            for i in range(len(s)):\n                big = ''\n                big = max(big, s[0])\n                queue.remove(big)\n                queue.append(big)\n                temp = \"\".join(queue)\n                if temp not in uni:\n                    uni.add(temp)\n                    s = \"\".join(queue)\n                else: break\n        \n        words = list(uni)\n        words.sort()\n        return words[0]`\n"
                    },
                    {
                        "username": "bharatchauhan340",
                        "content": "How to solve ? if Any integer m is given denoting the maximum times this operation can be performed."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "if that is the case, then I think either the greedy way (which will not work) or just the recursion tbh exploring all ways"
                    }
                ]
            },
            {
                "id": 1867848,
                "content": [
                    {
                        "username": "cortexauth",
                        "content": "This had strong Codeforces vibe to it"
                    },
                    {
                        "username": "Ct-nep",
                        "content": "Is there any mathematical proof that the answer would always be lexicographically smallest (sorted) string if k > 1?"
                    },
                    {
                        "username": "JJATIN",
                        "content": "for k >1 its simply bubble sort"
                    },
                    {
                        "username": "supertaiyaki",
                        "content": "Hardly a proper proof but note that you can swap the two elements at the head of the string if k >= 2 (2nd element, 1st element, then take them in order until you get back to the start). You can also swap any arbitrary elements by rotating the string to the position you need, swapping, then rotating the rest of the way around. With those operations you can execute a bubble sort. It\\'s not too hard to verify the correctness of bubble sort if you want to go that far."
                    },
                    {
                        "username": "shabes",
                        "content": "It is relatively straightforward (no need for group theory :-)). We build the sorted string iteratively. At each iteration we start with smallest m characters sorted as a substring somewhere in our string (at the very first iteration we have m = 1 and it is a single smallest character somewhere). We will use position 0 as our \"storage\" for the next smallest character like this: cycle through the string by appending character from position 1 to the end (observe that this will not disturb our already sorted chain) until we see our target character (next smallest). Then we append character from position 0 to the end pushing our target into \"storage\". Now we cycle again by appending position 1 to the end until we line up our chain at the end of the string. Finally, we append character from storage to the end. Now we have m+1 sorted chain. Repeat until all characters are sorted."
                    },
                    {
                        "username": "narayan1281",
                        "content": "Yes!\\nSuppose s = \"zyxwonmab\" and k >1 (say k = 2)\\n// I would explain it using a priority_queue --> in fact a min heap priority_queue of size atmost k\\n// first push first k letters in priority_queue \\n// assume s1 = \"\"; --> temporary string to store result of first rotation\\n// take out the top of priority_queue (pq)\\ns1 = \"y\" and push next character in priority_queue --> pq = \"xz\"\\n// next-step\\ns1 = \"yx\" and pq = \"wz\"\\n// next step\\ns1 =\"yxw\" and pq = \"oz\"\\n// next\\ns1=\"yxwo\" and pq =\"nz\"\\n.\\n.\\n.\\ns1 =\"yxwonmab\" and pq=\"z\"\\n// next step\\ns1 =\"yxwonmabz\" and pq=\"\"--> empty as we have reached the end of first loop\\n\\n// From the above what we observe, in every full iteration of loop we put a \"largest value character\" at the end of the string\\n// so in we carry on the same looping process for n-1 number of times then what we would get is the \"sorted\" string and\\n// sorted string is indeed the lexicographically smallest permutation of s.\\n\\nI hope it helps. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I got to know about it when I was playing with the test cases. But if you really think if you have k>=2 then you can compare 2 elements and do work accordingly. And since there is no restriction on number of moves you will get to the sorted string eventually."
                    },
                    {
                        "username": "cortexauth",
                        "content": "Group theory talks about such permutations. We talk about cycles in this context, for example, a cycle (123..n) means send 1st element to nth position, send 2nd to 1st, 3rd to 2nd, and so on, in short, a left rotation. Moreover, we have a special cases such as transpositions , ex (12), which is basically a swap\\n\\nThese two are enough to generate any permutations for sequence of size 3\\n\\nI think there must be a more general proof as such.\\n\\nOnce done, we can argue that such moves can lead to any possible permutation of the elements, and even the sorted one, and hence the correctness proved"
                    },
                    {
                        "username": "votrubac",
                        "content": "I bet many people got a gist that you either sort or rotate. However, I did not expect a \"hard\" problem on LC to have a BF solution.\\n\\nSeeing this problme as \"hard\" sent me to a wrong direction. Was assigning \"hard\" intentional for these reasons? Or was it just a srew up on the admins\\' side?\\n\\nMy weakness is that I overcomplicate problems way too often, and I appreciate this learning  :) I think a better contents strategy would be to try a simple solution first. You can get in on luck, or you will get a good test case. The penalty for a wrong submission is 5 minutes, not 10 as it used to be :)"
                    },
                    {
                        "username": "Hrabesim",
                        "content": "It literary took me 2-3 minutes to code. :/"
                    },
                    {
                        "username": "AaveshK",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Could\\'ve been limited to premium users post the contest. "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I agree! I think this problem is a newly added problem in LC (looking at the solutions tab which has 513 solutions as of now - seasoned problems show 999+). \\n\\nSimilarly if we look at LeetCode 1128 (https://leetcode.com/problems/number-of-equivalent-domino-pairs/description/), it is categorized as Easy however it gives TLE on brute force solution and has a slightly trickier hashing logic to come up with for an easy problem. "
                    },
                    {
                        "username": "doggg2",
                        "content": "The key as discussed, is to observe that **when k = 2, it is possible to swap any two adjacent characters in the string**. To see why this is the case, consider any string s and any index i:\\n```s == s[0:i] + s[i] + s[i+1] + s[i + 2:]```\\n\\nThen we can swap i, i + 1 by doing these steps:\\n1. Keep putting the first character to the end until s[i] becomes the first character. Now we have a string ```s[i] + s[i+1] + s[i + 2:] + s[0:i]```\\n2. Put s[i] to the back. Now we have ```s[i + 1] + s[i+2:] + s[0:i] +s[i]```\\n3. Keep putting the second character to the end until s[i] becomes the second character. Now we have ```s[i+1] + s[i] + s[i + 2:] + s[0:i]```\\n4. Steps 2 and 3 have swapped i and i + 1. Now keep putting the first character to the back until we have ```s[0:i] + s[i + 1] + s[i] + s[i+2:]```\\n\\nIf you find this useful give an upvote."
                    },
                    {
                        "username": "happyleetcode",
                        "content": "Assume l is String length and  the target 2 chars\\' index is i and j. it should have 0<=i<j<l\\nso the structrue is that\\n[L] I [M] J [R]\\n[L] means the chars left to the I, the size of L shoule >=0\\n[M] means the chars between I and J, the size of M shoule >=0\\n[R] means the chars right to the J,the size of R shoule >=0\\nMOVE 1 means always move first char to the end\\nMOVE 2 means always move second char to the end.\\nthe target string should be  [L] J [M] I [R]\\n\\n\\tStep1. MOVE 1 until the string become      ** I  [M]  J  [R] [L]**\\n\\tStep2. MOVE 2 until the string become      ** I   J  [R] [L] [M]**\\n\\tStep3. MOVE 1 until the string become      ** J  [R] [L] [M]  I **\\n\\tStep4. MOVE 2 until the string become      ** J  [M]  I  [R] [L]**\\n\\tStep5. MOVE 1 until the string become      **[L]  J  [M]  I  [R]**"
                    },
                    {
                        "username": "Depender",
                        "content": "Initially I thought for some sorted rotatory arrangements but just realized it as a variation of bubble sort for k > 1. Hmm..! This was quite interesting and a bit confusing as well \\uD83D\\uDE05"
                    },
                    {
                        "username": "cpollock",
                        "content": "For test case 38, would not \"hntq\" be considered smaller than expected result \"htqn\"? My understanding of \"lexicographically smaller\" is the same as: https://en.wikipedia.org/wiki/Lexicographical_order\\n\\n![image](https://assets.leetcode.com/users/cpollock/image_1563820655.png)\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "with k==1 all you can do is rotate the string, so hntq is not possible"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "No matter how many times you rotate, you cannot change the order of h and n in this string with k=1. "
                    },
                    {
                        "username": "code_report",
                        "content": "Contest wouldn\\'t let me submit my solution for this problem."
                    },
                    {
                        "username": "khubaibalam2000",
                        "content": "Can someone tell me what is the time complexity of this solution?\n\n`class Solution:\n    def orderlyQueue(self, s: str, k: int) -> str:\n\n        queue = list(s)\n        if k > 1: \n            queue.sort()\n            return \"\".join((queue))\n        else:\n            uni = set()\n            uni.add(s)\n            for i in range(len(s)):\n                big = ''\n                big = max(big, s[0])\n                queue.remove(big)\n                queue.append(big)\n                temp = \"\".join(queue)\n                if temp not in uni:\n                    uni.add(temp)\n                    s = \"\".join(queue)\n                else: break\n        \n        words = list(uni)\n        words.sort()\n        return words[0]`\n"
                    },
                    {
                        "username": "bharatchauhan340",
                        "content": "How to solve ? if Any integer m is given denoting the maximum times this operation can be performed."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "if that is the case, then I think either the greedy way (which will not work) or just the recursion tbh exploring all ways"
                    }
                ]
            },
            {
                "id": 1675184,
                "content": [
                    {
                        "username": "cortexauth",
                        "content": "This had strong Codeforces vibe to it"
                    },
                    {
                        "username": "Ct-nep",
                        "content": "Is there any mathematical proof that the answer would always be lexicographically smallest (sorted) string if k > 1?"
                    },
                    {
                        "username": "JJATIN",
                        "content": "for k >1 its simply bubble sort"
                    },
                    {
                        "username": "supertaiyaki",
                        "content": "Hardly a proper proof but note that you can swap the two elements at the head of the string if k >= 2 (2nd element, 1st element, then take them in order until you get back to the start). You can also swap any arbitrary elements by rotating the string to the position you need, swapping, then rotating the rest of the way around. With those operations you can execute a bubble sort. It\\'s not too hard to verify the correctness of bubble sort if you want to go that far."
                    },
                    {
                        "username": "shabes",
                        "content": "It is relatively straightforward (no need for group theory :-)). We build the sorted string iteratively. At each iteration we start with smallest m characters sorted as a substring somewhere in our string (at the very first iteration we have m = 1 and it is a single smallest character somewhere). We will use position 0 as our \"storage\" for the next smallest character like this: cycle through the string by appending character from position 1 to the end (observe that this will not disturb our already sorted chain) until we see our target character (next smallest). Then we append character from position 0 to the end pushing our target into \"storage\". Now we cycle again by appending position 1 to the end until we line up our chain at the end of the string. Finally, we append character from storage to the end. Now we have m+1 sorted chain. Repeat until all characters are sorted."
                    },
                    {
                        "username": "narayan1281",
                        "content": "Yes!\\nSuppose s = \"zyxwonmab\" and k >1 (say k = 2)\\n// I would explain it using a priority_queue --> in fact a min heap priority_queue of size atmost k\\n// first push first k letters in priority_queue \\n// assume s1 = \"\"; --> temporary string to store result of first rotation\\n// take out the top of priority_queue (pq)\\ns1 = \"y\" and push next character in priority_queue --> pq = \"xz\"\\n// next-step\\ns1 = \"yx\" and pq = \"wz\"\\n// next step\\ns1 =\"yxw\" and pq = \"oz\"\\n// next\\ns1=\"yxwo\" and pq =\"nz\"\\n.\\n.\\n.\\ns1 =\"yxwonmab\" and pq=\"z\"\\n// next step\\ns1 =\"yxwonmabz\" and pq=\"\"--> empty as we have reached the end of first loop\\n\\n// From the above what we observe, in every full iteration of loop we put a \"largest value character\" at the end of the string\\n// so in we carry on the same looping process for n-1 number of times then what we would get is the \"sorted\" string and\\n// sorted string is indeed the lexicographically smallest permutation of s.\\n\\nI hope it helps. \\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "I got to know about it when I was playing with the test cases. But if you really think if you have k>=2 then you can compare 2 elements and do work accordingly. And since there is no restriction on number of moves you will get to the sorted string eventually."
                    },
                    {
                        "username": "cortexauth",
                        "content": "Group theory talks about such permutations. We talk about cycles in this context, for example, a cycle (123..n) means send 1st element to nth position, send 2nd to 1st, 3rd to 2nd, and so on, in short, a left rotation. Moreover, we have a special cases such as transpositions , ex (12), which is basically a swap\\n\\nThese two are enough to generate any permutations for sequence of size 3\\n\\nI think there must be a more general proof as such.\\n\\nOnce done, we can argue that such moves can lead to any possible permutation of the elements, and even the sorted one, and hence the correctness proved"
                    },
                    {
                        "username": "votrubac",
                        "content": "I bet many people got a gist that you either sort or rotate. However, I did not expect a \"hard\" problem on LC to have a BF solution.\\n\\nSeeing this problme as \"hard\" sent me to a wrong direction. Was assigning \"hard\" intentional for these reasons? Or was it just a srew up on the admins\\' side?\\n\\nMy weakness is that I overcomplicate problems way too often, and I appreciate this learning  :) I think a better contents strategy would be to try a simple solution first. You can get in on luck, or you will get a good test case. The penalty for a wrong submission is 5 minutes, not 10 as it used to be :)"
                    },
                    {
                        "username": "Hrabesim",
                        "content": "It literary took me 2-3 minutes to code. :/"
                    },
                    {
                        "username": "AaveshK",
                        "content": "[@disturbedbrown1](/disturbedbrown1) Could\\'ve been limited to premium users post the contest. "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I agree! I think this problem is a newly added problem in LC (looking at the solutions tab which has 513 solutions as of now - seasoned problems show 999+). \\n\\nSimilarly if we look at LeetCode 1128 (https://leetcode.com/problems/number-of-equivalent-domino-pairs/description/), it is categorized as Easy however it gives TLE on brute force solution and has a slightly trickier hashing logic to come up with for an easy problem. "
                    },
                    {
                        "username": "doggg2",
                        "content": "The key as discussed, is to observe that **when k = 2, it is possible to swap any two adjacent characters in the string**. To see why this is the case, consider any string s and any index i:\\n```s == s[0:i] + s[i] + s[i+1] + s[i + 2:]```\\n\\nThen we can swap i, i + 1 by doing these steps:\\n1. Keep putting the first character to the end until s[i] becomes the first character. Now we have a string ```s[i] + s[i+1] + s[i + 2:] + s[0:i]```\\n2. Put s[i] to the back. Now we have ```s[i + 1] + s[i+2:] + s[0:i] +s[i]```\\n3. Keep putting the second character to the end until s[i] becomes the second character. Now we have ```s[i+1] + s[i] + s[i + 2:] + s[0:i]```\\n4. Steps 2 and 3 have swapped i and i + 1. Now keep putting the first character to the back until we have ```s[0:i] + s[i + 1] + s[i] + s[i+2:]```\\n\\nIf you find this useful give an upvote."
                    },
                    {
                        "username": "happyleetcode",
                        "content": "Assume l is String length and  the target 2 chars\\' index is i and j. it should have 0<=i<j<l\\nso the structrue is that\\n[L] I [M] J [R]\\n[L] means the chars left to the I, the size of L shoule >=0\\n[M] means the chars between I and J, the size of M shoule >=0\\n[R] means the chars right to the J,the size of R shoule >=0\\nMOVE 1 means always move first char to the end\\nMOVE 2 means always move second char to the end.\\nthe target string should be  [L] J [M] I [R]\\n\\n\\tStep1. MOVE 1 until the string become      ** I  [M]  J  [R] [L]**\\n\\tStep2. MOVE 2 until the string become      ** I   J  [R] [L] [M]**\\n\\tStep3. MOVE 1 until the string become      ** J  [R] [L] [M]  I **\\n\\tStep4. MOVE 2 until the string become      ** J  [M]  I  [R] [L]**\\n\\tStep5. MOVE 1 until the string become      **[L]  J  [M]  I  [R]**"
                    },
                    {
                        "username": "Depender",
                        "content": "Initially I thought for some sorted rotatory arrangements but just realized it as a variation of bubble sort for k > 1. Hmm..! This was quite interesting and a bit confusing as well \\uD83D\\uDE05"
                    },
                    {
                        "username": "cpollock",
                        "content": "For test case 38, would not \"hntq\" be considered smaller than expected result \"htqn\"? My understanding of \"lexicographically smaller\" is the same as: https://en.wikipedia.org/wiki/Lexicographical_order\\n\\n![image](https://assets.leetcode.com/users/cpollock/image_1563820655.png)\\n"
                    },
                    {
                        "username": "jotho_",
                        "content": "with k==1 all you can do is rotate the string, so hntq is not possible"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "No matter how many times you rotate, you cannot change the order of h and n in this string with k=1. "
                    },
                    {
                        "username": "code_report",
                        "content": "Contest wouldn\\'t let me submit my solution for this problem."
                    },
                    {
                        "username": "khubaibalam2000",
                        "content": "Can someone tell me what is the time complexity of this solution?\n\n`class Solution:\n    def orderlyQueue(self, s: str, k: int) -> str:\n\n        queue = list(s)\n        if k > 1: \n            queue.sort()\n            return \"\".join((queue))\n        else:\n            uni = set()\n            uni.add(s)\n            for i in range(len(s)):\n                big = ''\n                big = max(big, s[0])\n                queue.remove(big)\n                queue.append(big)\n                temp = \"\".join(queue)\n                if temp not in uni:\n                    uni.add(temp)\n                    s = \"\".join(queue)\n                else: break\n        \n        words = list(uni)\n        words.sort()\n        return words[0]`\n"
                    },
                    {
                        "username": "bharatchauhan340",
                        "content": "How to solve ? if Any integer m is given denoting the maximum times this operation can be performed."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "if that is the case, then I think either the greedy way (which will not work) or just the recursion tbh exploring all ways"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Insertion Steps to Make a String Palindrome",
        "question_content": "<p>Given a string <code>s</code>. In one step you can insert any character at any index of the string.</p>\n\n<p>Return <em>the minimum number of steps</em> to make <code>s</code>&nbsp;palindrome.</p>\n\n<p>A&nbsp;<b>Palindrome String</b>&nbsp;is one that reads the same backward as well as forward.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;zzazz&quot;\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The string &quot;zzazz&quot; is already palindrome we do not need any insertions.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;mbadm&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> String can be &quot;mbdadbm&quot; or &quot;mdbabdm&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;leetcode&quot;\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> Inserting 5 characters the string becomes &quot;leetcodocteel&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 500</code></li>\n\t<li><code>s</code> consists of lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 470706,
                "title": "java-c-python-longest-common-sequence",
                "content": "## **Intuition**\\nSplit the string `s` into to two parts,\\nand we try to make them symmetrical by adding letters.\\n\\nThe more common symmetrical subsequence they have,\\nthe less letters we need to add.\\n\\nNow we change the problem to find the length of longest common sequence.\\nThis is a typical dynamic problem.\\n<br>\\n\\n## **Explanation**\\n**Step1.**\\nInitialize `dp[n+1][n+1]`,\\nwhere`dp[i][j]` means the length of longest common sequence between\\n`i` first letters in `s1` and `j` first letters in `s2`.\\n\\n**Step2.**\\nFind the the longest common sequence between `s1` and `s2`,\\nwhere `s1 = s` and `s2 = reversed(s)`\\n\\n**Step3.**\\n`return n - dp[n][n]`\\n<br>\\n\\n## **Complexity**\\nTime `O(N^2)`\\nSpace `O(N^2)`\\n<br>\\n\\n**Java:**\\n```java\\n    public int minInsertions(String s) {\\n        int n = s.length();\\n        int[][] dp = new int[n+1][n+1];\\n        for (int i = 0; i < n; ++i)\\n            for (int j = 0; j < n; ++j)\\n                dp[i + 1][j + 1] = s.charAt(i) == s.charAt(n - 1 - j) ? dp[i][j] + 1 : Math.max(dp[i][j + 1], dp[i + 1][j]);\\n        return n - dp[n][n];\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    int minInsertions(string s) {\\n        int n = s.length();\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1));\\n        for (int i = 0; i < n; ++i)\\n            for (int j = 0; j < n; ++j)\\n                dp[i + 1][j + 1] = s[i] == s[n - 1 - j] ? dp[i][j] + 1 : max(dp[i][j + 1], dp[i + 1][j]);\\n        return n - dp[n][n];\\n    }\\n```\\n\\n**Python:**\\nNote that `~j = -j - 1`\\n```python\\n    def minInsertions(self, s):\\n        n = len(s)\\n        dp = [[0] * (n + 1) for i in xrange(n + 1)]\\n        for i in xrange(n):\\n            for j in xrange(n):\\n                dp[i + 1][j + 1] = dp[i][j] + 1 if s[i] == s[~j] else max(dp[i][j + 1], dp[i + 1][j])\\n        return n - dp[n][n]\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int minInsertions(String s) {\\n        int n = s.length();\\n        int[][] dp = new int[n+1][n+1];\\n        for (int i = 0; i < n; ++i)\\n            for (int j = 0; j < n; ++j)\\n                dp[i + 1][j + 1] = s.charAt(i) == s.charAt(n - 1 - j) ? dp[i][j] + 1 : Math.max(dp[i][j + 1], dp[i + 1][j]);\\n        return n - dp[n][n];\\n    }\\n```\n```cpp\\n    int minInsertions(string s) {\\n        int n = s.length();\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1));\\n        for (int i = 0; i < n; ++i)\\n            for (int j = 0; j < n; ++j)\\n                dp[i + 1][j + 1] = s[i] == s[n - 1 - j] ? dp[i][j] + 1 : max(dp[i][j + 1], dp[i + 1][j]);\\n        return n - dp[n][n];\\n    }\\n```\n```python\\n    def minInsertions(self, s):\\n        n = len(s)\\n        dp = [[0] * (n + 1) for i in xrange(n + 1)]\\n        for i in xrange(n):\\n            for j in xrange(n):\\n                dp[i + 1][j + 1] = dp[i][j] + 1 if s[i] == s[~j] else max(dp[i][j + 1], dp[i + 1][j])\\n        return n - dp[n][n]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 470684,
                "title": "c-simple-dp-memoization-and-bottom-up-with-o-n-space",
                "content": "**Observation**\\nLet\\'s imagine matching the characters of the string like a palindrome, from the begining and the end with 2 pointers `i` and `j`.\\nWe may encounter 2 scenarios:\\n1) The character at `i` matches character at `j`.\\n2) The characters don\\'t match each other\\n\\nIn case of 1 we just increase the pointer `i` and decrease the pointer `j`, `i++` and `j--` respectively.\\n\\nIn the second case we have 2 options:\\n1) Insert one character at `j` to match the character at `i`.\\n\\nOr\\n\\n2) Insert one character at `i` to match the character at `j`.\\n\\nSince we are not actually adding the characters in the string but just calculating the cost,\\nIn case 1 we increase the pointer `i` by `1` and `j` stays as it is, as we still need a character to match at `j`\\nand in case 2 we decrease the pointer `j` by `1` and `i` stays as it is, as we still need a character to match at `i`.\\nboth the cases adds cost `1` since we are inserting a letter.\\n\\nWe can then use these two different pairs of new `i` and `j` values (`i+1, j` and `i, j-1`) to again repeat the process and use the **minimum** result of these as our result for current pair of `i, j`.\\nWe can see that this is recursive and thus we can use recursion with caching to store the repeated values.\\n\\n**Solution (Memoization)**\\n```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> memo;\\n    int dp(string &s,int i,int j)\\n    {\\n        if(i>=j)\\t\\t\\t\\t\\t\\t\\t//Base case.\\n            return 0;\\n        if(memo[i][j]!=-1)\\t\\t\\t\\t\\t//Check if we have already calculated the value for the pair `i` and `j`.\\n            return memo[i][j];\\n        return memo[i][j]=s[i]==s[j]?dp(s,i+1,j-1):1+min(dp(s,i+1,j),dp(s,i,j-1));\\t\\t//Recursion as mentioned above.\\n    }\\n    int minInsertions(string s) \\n    {\\n        memo.resize(s.length(),vector<int>(s.length(),-1));\\n        return dp(s,0,s.length()-1);\\n    }\\n};\\n```\\n**Complexity**\\nSpace: `O(n^2)` as we can store at max all possible pairs of `i` and `j`.\\nTime: `O(n^2)` as we calculate all pairs of possible `i` and `j`.\\n\\n**Note:** Space complexity can be reduced to `O(n)` by using bottom-up DP and storing only the previous state. (As we can see from the recursion, we only need `i-1` or `j-1` at any given point.)\\n\\n**Solution (Bottom-up)** \\nAs I mentioned in the **Note** earlier, that we can reduce the space complexity as we only need the previous `i+1` or `j-1` states, I thought why not just add the solution as well. So here goes.\\n\\nWe can be cognizant of how we fill the `memo` table to optimize the space complexity when we have such scenarios. The code is pretty self explanatory with the added comments.\\n```c++\\nclass Solution {\\npublic:\\n    int minInsertions(string s) \\n    {\\n        vector<int> memo(s.length(),0);\\n        int prev,temp;\\n        for(int i=s.length()-2;i>=0;i--)\\n        {\\n            prev=0;                                          //This stores the value at memo[i+1][j-1];\\n            for(int j=i;j<s.length();j++)\\n            {\\n                temp=memo[j];                               //Get the value of memo[i+1][j].\\n                memo[j]=s[i]==s[j]?prev:1+min(memo[j],memo[j-1]);     //memo[j]=memo[i+1][j], memo[j-1]=memo[i][j-1], prev=memo[i+1][j-1].\\n                prev=temp;                        //Store the value of memo[i+1][j] to use it as memo[i+1][j-1] in the next iteration.\\n            }\\n        }\\n        return memo[s.length()-1];\\n    }\\n};\\n```\\n**Complexity**\\nSpace: `O(n)` as we reuse the previously stored value from previous state from the `memo` or `prev` variable.\\nTime: `O(n^2)` as we calculate all pairs of possible `i` and `j`.",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> memo;\\n    int dp(string &s,int i,int j)\\n    {\\n        if(i>=j)\\t\\t\\t\\t\\t\\t\\t//Base case.\\n            return 0;\\n        if(memo[i][j]!=-1)\\t\\t\\t\\t\\t//Check if we have already calculated the value for the pair `i` and `j`.\\n            return memo[i][j];\\n        return memo[i][j]=s[i]==s[j]?dp(s,i+1,j-1):1+min(dp(s,i+1,j),dp(s,i,j-1));\\t\\t//Recursion as mentioned above.\\n    }\\n    int minInsertions(string s) \\n    {\\n        memo.resize(s.length(),vector<int>(s.length(),-1));\\n        return dp(s,0,s.length()-1);\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    int minInsertions(string s) \\n    {\\n        vector<int> memo(s.length(),0);\\n        int prev,temp;\\n        for(int i=s.length()-2;i>=0;i--)\\n        {\\n            prev=0;                                          //This stores the value at memo[i+1][j-1];\\n            for(int j=i;j<s.length();j++)\\n            {\\n                temp=memo[j];                               //Get the value of memo[i+1][j].\\n                memo[j]=s[i]==s[j]?prev:1+min(memo[j],memo[j-1]);     //memo[j]=memo[i+1][j], memo[j-1]=memo[i][j-1], prev=memo[i+1][j-1].\\n                prev=temp;                        //Store the value of memo[i+1][j] to use it as memo[i+1][j-1] in the next iteration.\\n            }\\n        }\\n        return memo[s.length()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 470740,
                "title": "516-longest-palindromic-subsequence",
                "content": "If we figure out the longest palindromic subsequence, then we can tell the miminum number of characters to add or remove to make the string a palindrome. \\n\\nSo, we can simply reuse [516. Longest Palindromic Subsequence](https://leetcode.com/problems/longest-palindromic-subsequence/).\\n```CPP\\nint minInsertions(string s) {\\n  return s.size() - longestPalindromeSubseq(s);\\n}\\nint dp[501][501] = {};\\nint longestPalindromeSubseq(string &s) {\\n  for (int len = 1; len <= s.size(); ++len)\\n    for (int i = 0; i + len <= s.size(); ++i) \\n      dp[i][i + len] = s[i] == s[i + len - 1] ? dp[i + 1][i + len - 1] + (len == 1 ? 1 : 2) \\n        : max(dp[i][i + len - 1], dp[i + 1][i + len]);\\n  return dp[0][s.size()];\\n}\\n```",
                "solutionTags": [],
                "code": "```CPP\\nint minInsertions(string s) {\\n  return s.size() - longestPalindromeSubseq(s);\\n}\\nint dp[501][501] = {};\\nint longestPalindromeSubseq(string &s) {\\n  for (int len = 1; len <= s.size(); ++len)\\n    for (int i = 0; i + len <= s.size(); ++i) \\n      dp[i][i + len] = s[i] == s[i + len - 1] ? dp[i + 1][i + len - 1] + (len == 1 ? 1 : 2) \\n        : max(dp[i][i + len - 1], dp[i + 1][i + len]);\\n  return dp[0][s.size()];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3442303,
                "title": "python-java-c-simple-solution-easy-to-understand",
                "content": "# Please UPVOTE \\uD83D\\uDC4D\\n\\n**!! BIG ANNOUNCEMENT !!**\\nI am Giving away my premium content videos related to computer science and data science and also will be sharing well-structured assignments and study materials to clear interviews at top companies to my first 10,000 Subscribers. So, **DON\\'T FORGET** to Subscribe\\n\\n# **Search \\uD83D\\uDC49`Tech Wired leetcode`**\\n\\n# Video Solution\\n\\n# **Search \\uD83D\\uDC49`Minimum Insertion Steps to Make a String Palindrome by Tech Wired`**\\n\\n# OR \\n# **Click the Link in my Leetcode Profile**\\n\\n![Yellow & Black Earn Money YouTube Thumbnail (19).png](https://assets.leetcode.com/users/images/fb32a329-d572-4f87-bc55-3b1147e81722_1682127595.149926.png)\\n\\n\\n# Approach:\\n\\nThe problem can be solved using dynamic programming. We can create a 2D table dp, where dp[i][j] represents the minimum number of insertions required to make the substring s[i:j+1] a palindrome. The base case is when i=j, where the substring is already a palindrome and no insertions are needed. If s[i] == s[j], then the substring is already a palindrome and we can use the result of dp[i+1][j-1]. Otherwise, we need to insert either a character at index i or j to make them equal, so we take the minimum of dp[i+1][j] and dp[i][j-1] and add 1 to it.\\n\\nWe can fill the table dp using a bottom-up approach. We start with the smallest substrings (length 1) and work up to the entire string. The final answer is stored in dp[0][n-1], where n is the length of the input string s.\\n\\nHowever, we can further optimize the space complexity of the solution by using only one row of the 2D table dp at a time. We can iterate over the columns of the table in reverse order and update the row accordingly. By updating the row in reverse order and using a variable to store the previous value of dp[j], we avoid overwriting the values in the row before they are used in the current iteration.\\n\\n# Intuition:\\n\\nThe problem requires us to find the minimum number of insertions needed to make a string palindrome. We can approach this by breaking down the string into smaller substrings and computing the minimum number of insertions needed for each substring.\\n\\nIf we consider a substring s[i:j+1], we can make it a palindrome by inserting characters at the beginning or end of the substring. We can use dynamic programming to solve the problem by breaking down the string into smaller substrings and computing the minimum number of insertions needed for each substring. By computing the minimum number of insertions needed for each substring, we can find the minimum number of insertions needed to make the entire string palindrome.\\n\\nThe dynamic programming solution uses a 2D table to store the minimum number of insertions needed for each substring. By breaking down the string into smaller substrings and using the results of the smaller substrings to compute the results of the larger substrings, we can find the minimum number of insertions needed to make the entire string palindrome.\\n\\n```Python []\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        n = len(s)\\n        dp = [0] * n\\n        for i in range(n - 2, -1, -1):\\n            prev = 0\\n            for j in range(i + 1, n):\\n                temp = dp[j]\\n                if s[i] == s[j]:\\n                    dp[j] = prev\\n                else:\\n                    dp[j] = min(dp[j], dp[j-1]) + 1\\n                prev = temp\\n        return dp[n-1]\\n```\\n```Java []\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int n = s.length();\\n        int[] dp = new int[n];\\n        for (int i = n - 2; i >= 0; i--) {\\n            int prev = 0;\\n            for (int j = i + 1; j < n; j++) {\\n                int temp = dp[j];\\n                if (s.charAt(i) == s.charAt(j)) {\\n                    dp[j] = prev;\\n                } else {\\n                    dp[j] = Math.min(dp[j], dp[j-1]) + 1;\\n                }\\n                prev = temp;\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n}\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.length();\\n        vector<int> dp(n);\\n        for (int i = n - 2; i >= 0; i--) {\\n            int prev = 0;\\n            for (int j = i + 1; j < n; j++) {\\n                int temp = dp[j];\\n                if (s[i] == s[j]) {\\n                    dp[j] = prev;\\n                } else {\\n                    dp[j] = min(dp[j], dp[j-1]) + 1;\\n                }\\n                prev = temp;\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```Python []\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        n = len(s)\\n        dp = [0] * n\\n        for i in range(n - 2, -1, -1):\\n            prev = 0\\n            for j in range(i + 1, n):\\n                temp = dp[j]\\n                if s[i] == s[j]:\\n                    dp[j] = prev\\n                else:\\n                    dp[j] = min(dp[j], dp[j-1]) + 1\\n                prev = temp\\n        return dp[n-1]\\n```\n```Java []\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int n = s.length();\\n        int[] dp = new int[n];\\n        for (int i = n - 2; i >= 0; i--) {\\n            int prev = 0;\\n            for (int j = i + 1; j < n; j++) {\\n                int temp = dp[j];\\n                if (s.charAt(i) == s.charAt(j)) {\\n                    dp[j] = prev;\\n                } else {\\n                    dp[j] = Math.min(dp[j], dp[j-1]) + 1;\\n                }\\n                prev = temp;\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n}\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.length();\\n        vector<int> dp(n);\\n        for (int i = n - 2; i >= 0; i--) {\\n            int prev = 0;\\n            for (int j = i + 1; j < n; j++) {\\n                int temp = dp[j];\\n                if (s[i] == s[j]) {\\n                    dp[j] = prev;\\n                } else {\\n                    dp[j] = min(dp[j], dp[j-1]) + 1;\\n                }\\n                prev = temp;\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442325,
                "title": "using-lcs-c-simple-explanation-easy-approach",
                "content": "# **PLEASE UPVOTE \\uD83D\\uDC4D**\\n# Approach\\n- ##### To make a string s palindrome, we need to add characters to the string such that it becomes the same when read from both sides. \\n- ##### The idea is to find the LCS between the original string s and its reverse string s\\'. The length of LCS will give us the number of characters that are already palindrome in s. We can subtract this length from the length of s to get the number of characters we need to add to make s palindrome.\\n- ##### Let dp[i][j] be the length of the longest common subsequence between the first i characters of string A and the first j characters of string B. We can fill up the table using the following recurrence relation:\\n    1. ##### If A[i-1] == B[j-1], then dp[i][j] = dp[i-1][j-1] + 1, because the ith and jth characters match and contribute to the LCS.\\n    2. ##### If A[i-1] != B[j-1], then dp[i][j] = max(dp[i-1][j], dp[i][j-1]), because the ith and jth characters do not match and we have two options: either skip the ith character of A or skip the jth character of B.\\n- ##### The final answer will be stored in dp[m][n], where m and n are the lengths of the input strings A and B, respectively.\\n\\n# Intuition\\n- ##### The intuition behind using the LCS algorithm to find the minimum number of steps to make a string palindrome is based on the fact that a palindrome string is symmetric around its center.\\n\\n- ##### Let\\'s consider an example string \"abcd\". To make it a palindrome, we can add characters \"d\", \"c\", \"b\" to the beginning of the string to get \"dcbaabcd\", which is a palindrome. Alternatively, we can add characters \"a\", \"b\", \"c\" to the end of the string to get \"abcddcba\", which is also a palindrome.\\n\\n- ##### In general, to make a string palindrome, we need to add characters to either the beginning or the end of the string to make it symmetric around its center. The center of the string is the middle character(s) if the length of the string is odd, or the two middle characters if the length of the string is even.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# **PLEASE UPVOTE \\uD83D\\uDC4D**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lcs(string t, string s, vector<vector<int>>&dp){\\n        int n = s.size();\\n        for(int i = 0; i <= n; i++){\\n            for(int j = 0; j <= n; j++){\\n                if(i == 0 || j == 0)\\n                dp[i][j] = 0;\\n            }\\n        }\\n\\n        for(int i = 1; i <= n; i++){\\n            for(int j = 1; j <= n; j++){\\n                if(s[i-1] == t[j-1]){\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                } else{\\n                    dp[i][j] = max(dp[i-1][j],dp[i][j-1]);\\n                }\\n            }\\n        }\\n        return dp[n][n];\\n    }\\n    \\n    int minInsertions(string s) {\\n        string t = s;\\n        reverse(t.begin(),t.end());\\n        int n = s.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,0));\\n        return n - lcs(s,t,dp);\\n    }\\n};\\n```\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/13c32ead-4eb5-472d-8301-8e78d3bcc3c5_1682123350.7417476.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lcs(string t, string s, vector<vector<int>>&dp){\\n        int n = s.size();\\n        for(int i = 0; i <= n; i++){\\n            for(int j = 0; j <= n; j++){\\n                if(i == 0 || j == 0)\\n                dp[i][j] = 0;\\n            }\\n        }\\n\\n        for(int i = 1; i <= n; i++){\\n            for(int j = 1; j <= n; j++){\\n                if(s[i-1] == t[j-1]){\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                } else{\\n                    dp[i][j] = max(dp[i-1][j],dp[i][j-1]);\\n                }\\n            }\\n        }\\n        return dp[n][n];\\n    }\\n    \\n    int minInsertions(string s) {\\n        string t = s;\\n        reverse(t.begin(),t.end());\\n        int n = s.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,0));\\n        return n - lcs(s,t,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 470709,
                "title": "java-python-3-dp-longest-common-subsequence-w-brief-explanation-and-analysis",
                "content": "**Q & A:**\\n\\nQ: Can you please explain more how exactly lcs with its reverse helps?\\nA: An example could be illustrative. e.g., \"mbadm\". Let\\'s mark the characters not in LCS:\\n\"m`b`a`d`m\"\\nReverse:\\n\"m`d`a`b`m\"\\nWe need at least 2 insertions - `b` and `d` - to make them palindromes:\\n\"m`bd`a`db`m\" or\\n\"m`db`a`bd`m\"\\n\\n**End of Q & A**\\n\\n----\\n\\nPlease refer to my solution [Java/Python 3 2 Clean DP codes of O(m * n) & O(min(m, n)) space w/ breif explanation and analysis](https://leetcode.com/problems/max-dot-product-of-two-subsequences/discuss/649858/JavaPython-3-2-Clean-DP-codes-of-O(mn)-and-O(min(m-n))-space-w-breif-explanation-and-analysis.) of a similar problem: [1458. Max Dot Product of Two Subsequences](https://leetcode.com/problems/max-dot-product-of-two-subsequences/description/)\\n\\nMore similar LCS problems:\\n[1092. Shortest Common Supersequence](https://leetcode.com/problems/shortest-common-supersequence/) and [Solution](https://leetcode.com/problems/shortest-common-supersequence/discuss/312757/JavaPython-3-O(mn)-clean-DP-code-w-picture-comments-and-analysis.)\\n[1062. Longest Repeating Substring](https://leetcode.com/problems/longest-repeating-substring/) (Premium).\\n[516. Longest Palindromic  Subsequence](https://leetcode.com/problems/longest-palindromic-subsequence/)\\n[1312. Minimum Insertion Steps to Make a String Palindrome](https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/discuss/470709/JavaPython-3-DP-longest-common-subsequence-w-brief-explanation-and-analysis)\\n\\n----\\nFind the size of the longest common subsequence between the original string and its reverse, deduct it from the size of the original string, that is the solution.\\n```java\\n    public int minInsertions(String s) {\\n        String r = new StringBuilder(s).reverse().toString();\\n        return s.length() - lcs(s, r);\\n    }\\n    private int lcs(String s, String r) {\\n        int n = s.length();\\n        int[][] dp = new int[n + 1][n + 1];\\n        for (int i = 0; i < n; ++i)\\n            for (int j = 0; j < n; ++j)\\n                dp[i + 1][j + 1] = s.charAt(i) == r.charAt(j) ? dp[i][j] + 1 : Math.max(dp[i + 1][j], dp[i][j + 1]);\\n        return dp[n][n];        \\n    }\\n\\n```\\n\\n```python\\n    def minInsertions(self, s: str) -> int:\\n        def lcs(s: str, r: str) -> int:\\n            n = len(r)\\n            dp = [[0] * (n + 1) for _ in range(n + 1)]\\n            for i, a in enumerate(s):\\n                for j, b in enumerate(r):\\n                    dp[i + 1][j + 1] = dp[i][j] + 1 if a == b else max(dp[i][j + 1], dp[i + 1][j])\\n            return dp[n][n]\\n        return len(s) - lcs(s, s[::-1])\\n```\\n**Analysis:**\\nTime & space: `O(n ^ 2)`, where n = `s.length()`.\\n\\n----\\n\\nSpace optimization:\\n\\n```java\\n    public int minInsertions(String s) {\\n        return s.length() - lcs(s, new StringBuilder(s).reverse().toString());\\n    }\\n    private int lcs(String s, String r) {\\n        int n = s.length();\\n        int[][] dp = new int[2][n + 1];\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                dp[1 - i % 2][j + 1] = s.charAt(i) == r.charAt(j) ? 1 + dp[i % 2][j] : Math.max(dp[1 - i % 2][j], dp[i % 2][j + 1]);\\n            }\\n        }\\n        return dp[n % 2][n];        \\n    }\\n```\\n```python\\n    def minInsertions(self, s: str) -> int:\\n        \\n        def lcs(s: str, r: str) -> int:\\n            n = len(s)\\n            dp = [[0] * (n + 1) for _ in range(2)]\\n            for i, c in enumerate(s):\\n                for j, d in enumerate(r):\\n                    dp[1 - i % 2][j + 1] = 1 + dp[i % 2][j] if c == d else max(dp[i % 2][j + 1], dp[1 - i % 2][j])\\n            return dp[n % 2][n]\\n        \\n        return len(s) - lcs(s, s[:: -1])\\n```\\n**Analysis:**\\nTime: `O(n ^ 2)`,  space: `O(n)`, where `n = s.length()`.\\n",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```java\\n    public int minInsertions(String s) {\\n        String r = new StringBuilder(s).reverse().toString();\\n        return s.length() - lcs(s, r);\\n    }\\n    private int lcs(String s, String r) {\\n        int n = s.length();\\n        int[][] dp = new int[n + 1][n + 1];\\n        for (int i = 0; i < n; ++i)\\n            for (int j = 0; j < n; ++j)\\n                dp[i + 1][j + 1] = s.charAt(i) == r.charAt(j) ? dp[i][j] + 1 : Math.max(dp[i + 1][j], dp[i][j + 1]);\\n        return dp[n][n];        \\n    }\\n\\n```\n```python\\n    def minInsertions(self, s: str) -> int:\\n        def lcs(s: str, r: str) -> int:\\n            n = len(r)\\n            dp = [[0] * (n + 1) for _ in range(n + 1)]\\n            for i, a in enumerate(s):\\n                for j, b in enumerate(r):\\n                    dp[i + 1][j + 1] = dp[i][j] + 1 if a == b else max(dp[i][j + 1], dp[i + 1][j])\\n            return dp[n][n]\\n        return len(s) - lcs(s, s[::-1])\\n```\n```java\\n    public int minInsertions(String s) {\\n        return s.length() - lcs(s, new StringBuilder(s).reverse().toString());\\n    }\\n    private int lcs(String s, String r) {\\n        int n = s.length();\\n        int[][] dp = new int[2][n + 1];\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                dp[1 - i % 2][j + 1] = s.charAt(i) == r.charAt(j) ? 1 + dp[i % 2][j] : Math.max(dp[1 - i % 2][j], dp[i % 2][j + 1]);\\n            }\\n        }\\n        return dp[n % 2][n];        \\n    }\\n```\n```python\\n    def minInsertions(self, s: str) -> int:\\n        \\n        def lcs(s: str, r: str) -> int:\\n            n = len(s)\\n            dp = [[0] * (n + 1) for _ in range(2)]\\n            for i, c in enumerate(s):\\n                for j, d in enumerate(r):\\n                    dp[1 - i % 2][j + 1] = 1 + dp[i % 2][j] if c == d else max(dp[i % 2][j + 1], dp[1 - i % 2][j])\\n            return dp[n % 2][n]\\n        \\n        return len(s) - lcs(s, s[:: -1])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 470806,
                "title": "c-intuition-explanation-recursion-to-iteration-with-codes",
                "content": "# INTUITION\\n* Rather than thinking of it from some other problem(LCS, which most have done), I feel that it is better to visualize it as a new problem. \\n* When trying to check if palindrome or building a palindrome, we start from start and end chars of string\\n* If chars are same, we could change it to a subproblem from both sides.\\n\\t**f(i, j) = f(i + 1, j - 1)**\\n* On the other hand, if they are different characters, we have 2 options. Either to **add a character at ith index = s[j] or add a character at jth index = s[i]**. The minimum of these two would give our required answer.\\n\\n\\n```\\n\\t// Recursive Approach\\n\\tint f(string s, int i, int j, vector<vector<int>>& dp) {\\n        if(i >= j)\\n            return 0;\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        if(s[i] == s[j])\\n            return dp[i][j] = f(s, i + 1, j - 1, dp);\\n        int op1 = 1 + f(s, i + 1, j, dp);\\n        int op2 = 1 + f(s, i, j - 1, dp);\\n        return dp[i][j] = min(op1, op2); \\n    }\\n```\\t\\n\\t\\n# \\tRecursion To Iteration\\n* Since, i is dependent on i + 1 (next value) and j on j - 1(previous value), then how can we write an iterative dp code?\\n* We can see that we need to calculate our answer for smaller lengths first. We can precompute for len = 0 and then while increasing length, we will have our answer for all smaller length. Assume an index i, then j = i + len.\\n\\t\\n  ``` \\n    int minInsertions(string s) {\\n        vector<vector<int>> dp(s.size(), vector<int>(s.size(), 1e6));\\n        int n = s.size();\\n        for(int i = 0; i < n; i++)\\n            dp[i][i] = 0;\\n        for(int len = 1; len <= n; len++) {\\n            for(int i = 0; i + len < n; i++) {\\n                dp[i][i] = 0;\\n                int j = i + len;\\n                if(s[i] == s[j]) {\\n                    if(len == 1)\\n                        dp[i][j] = 0;\\n                    else\\n                        dp[i][j] = dp[i + 1][j - 1];\\n                }\\n                else {\\n                    dp[i][j] = min(1 + dp[i + 1][j], 1 + dp[i][j - 1]);\\n                }\\n            }\\n        }\\n        return dp[0][n - 1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\t// Recursive Approach\\n\\tint f(string s, int i, int j, vector<vector<int>>& dp) {\\n        if(i >= j)\\n            return 0;\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        if(s[i] == s[j])\\n            return dp[i][j] = f(s, i + 1, j - 1, dp);\\n        int op1 = 1 + f(s, i + 1, j, dp);\\n        int op2 = 1 + f(s, i, j - 1, dp);\\n        return dp[i][j] = min(op1, op2); \\n    }\\n```\n``` \\n    int minInsertions(string s) {\\n        vector<vector<int>> dp(s.size(), vector<int>(s.size(), 1e6));\\n        int n = s.size();\\n        for(int i = 0; i < n; i++)\\n            dp[i][i] = 0;\\n        for(int len = 1; len <= n; len++) {\\n            for(int i = 0; i + len < n; i++) {\\n                dp[i][i] = 0;\\n                int j = i + len;\\n                if(s[i] == s[j]) {\\n                    if(len == 1)\\n                        dp[i][j] = 0;\\n                    else\\n                        dp[i][j] = dp[i + 1][j - 1];\\n                }\\n                else {\\n                    dp[i][j] = min(1 + dp[i + 1][j], 1 + dp[i][j - 1]);\\n                }\\n            }\\n        }\\n        return dp[0][n - 1];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3442382,
                "title": "image-explanation-recursion-top-down-bottom-up-bottom-up-o-n-c-java-python",
                "content": "# Video Solution (`Aryan Mittal`) - Link in LeetCode Profile\\n`Minimum Insertion Steps to Make a String Palindrome` by `Aryan Mittal`\\n![lc.png](https://assets.leetcode.com/users/images/049c3374-1bdd-4426-b961-2f988c034e8e_1682126946.7610044.png)\\n\\n\\n# [Longest Palindromic Subsequence - LPS](https://leetcode.com/problems/longest-palindromic-subsequence/solutions/3415577/image-explanation-recursion-top-down-bottom-up-bottom-up-o-n/)\\n![image.png](https://assets.leetcode.com/users/images/c4ca7c90-2cf9-4ed0-b9c9-5e1650e106d0_1682126076.4728723.png)\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/abe9efcd-bf18-4e39-ab1c-42c1c0cd68f7_1682126023.898669.png)\\n![image.png](https://assets.leetcode.com/users/images/77262344-befb-4376-9907-8912d8707c03_1682126031.0959742.png)\\n![image.png](https://assets.leetcode.com/users/images/65d0e4d0-d127-414f-aa4b-7e68db4cfbd6_1682126039.6311653.png)\\n![image.png](https://assets.leetcode.com/users/images/98102f07-0275-45fa-a970-990cf93d4e14_1682126064.7054062.png)\\n\\n\\n\\n# Most Optimized DP Code:\\n```C++ []\\nclass Solution {\\npublic:\\n    int longestPalindromeSubseq(string& s) {\\n        int n = s.size();\\n        vector<int> dp(n), dpPrev(n);\\n\\n        for (int start = n - 1; start >= 0; --start) {\\n            dp[start] = 1;\\n            for (int end = start + 1; end < n; ++end) {\\n                if (s[start] == s[end]) {\\n                    dp[end] = dpPrev[end - 1] + 2;\\n                } else {\\n                    dp[end] = max(dpPrev[end], dp[end - 1]);\\n                }\\n            }\\n            dpPrev = dp;\\n        }\\n\\n        return dp[n - 1];\\n    }\\n\\n    int minInsertions(string s) {\\n        return s.length() - longestPalindromeSubseq(s);\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int longestPalindromeSubseq(String s) {\\n        int n = s.length();\\n        int[] dp = new int[n];\\n        int[] dpPrev = new int[n];\\n\\n        for (int start = n - 1; start >= 0; --start) {\\n            dp[start] = 1;\\n            for (int end = start + 1; end < n; ++end) {\\n                if (s.charAt(start) == s.charAt(end)) {\\n                    dp[end] = dpPrev[end - 1] + 2;\\n                } else {\\n                    dp[end] = Math.max(dpPrev[end], dp[end - 1]);\\n                }\\n            }\\n            dpPrev = dp.clone();\\n        }\\n\\n        return dp[n - 1];\\n    }\\n\\n    public int minInsertions(String s) {\\n        return s.length() - longestPalindromeSubseq(s);\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        def longestPalindromeSubseq(self, s: str) -> int:\\n            n = len(s)\\n            dp = [0] * n\\n            dpPrev = [0] * n\\n\\n            for start in range(n - 1, -1, -1):\\n                dp[start] = 1\\n                for end in range(start + 1, n):\\n                    if s[start] == s[end]:\\n                        dp[end] = dpPrev[end - 1] + 2\\n                    else:\\n                        dp[end] = max(dpPrev[end], dp[end - 1])\\n                dpPrev = dp[:]\\n\\n            return dp[n - 1]\\n\\n        return len(s) - longestPalindromeSubseq(self, s)\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int longestPalindromeSubseq(string& s) {\\n        int n = s.size();\\n        vector<int> dp(n), dpPrev(n);\\n\\n        for (int start = n - 1; start >= 0; --start) {\\n            dp[start] = 1;\\n            for (int end = start + 1; end < n; ++end) {\\n                if (s[start] == s[end]) {\\n                    dp[end] = dpPrev[end - 1] + 2;\\n                } else {\\n                    dp[end] = max(dpPrev[end], dp[end - 1]);\\n                }\\n            }\\n            dpPrev = dp;\\n        }\\n\\n        return dp[n - 1];\\n    }\\n\\n    int minInsertions(string s) {\\n        return s.length() - longestPalindromeSubseq(s);\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int longestPalindromeSubseq(String s) {\\n        int n = s.length();\\n        int[] dp = new int[n];\\n        int[] dpPrev = new int[n];\\n\\n        for (int start = n - 1; start >= 0; --start) {\\n            dp[start] = 1;\\n            for (int end = start + 1; end < n; ++end) {\\n                if (s.charAt(start) == s.charAt(end)) {\\n                    dp[end] = dpPrev[end - 1] + 2;\\n                } else {\\n                    dp[end] = Math.max(dpPrev[end], dp[end - 1]);\\n                }\\n            }\\n            dpPrev = dp.clone();\\n        }\\n\\n        return dp[n - 1];\\n    }\\n\\n    public int minInsertions(String s) {\\n        return s.length() - longestPalindromeSubseq(s);\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        def longestPalindromeSubseq(self, s: str) -> int:\\n            n = len(s)\\n            dp = [0] * n\\n            dpPrev = [0] * n\\n\\n            for start in range(n - 1, -1, -1):\\n                dp[start] = 1\\n                for end in range(start + 1, n):\\n                    if s[start] == s[end]:\\n                        dp[end] = dpPrev[end - 1] + 2\\n                    else:\\n                        dp[end] = max(dpPrev[end], dp[end - 1])\\n                dpPrev = dp[:]\\n\\n            return dp[n - 1]\\n\\n        return len(s) - longestPalindromeSubseq(self, s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 470687,
                "title": "java-longest-common-subsequence-solution-clean-code",
                "content": "**Idea**\\n- If we know the longest palindromic sub-sequence is `x` and the length of the string is `n` then, what is the answer to this problem? It is `n - x` as we need `n - x` insertions to make the remaining characters also palindrome.\\n\\n```java\\nclass Solution {\\n    public int minInsertions(String s) {\\n        String sReverse = new StringBuilder(s).reverse().toString();\\n        int lcs = longestCommonSubsequence(s.toCharArray(), sReverse.toCharArray());\\n        return s.length() - lcs;\\n    }\\n\\n    private int longestCommonSubsequence(char[] arr1, char[] arr2) {\\n        int n1 = arr1.length, n2 = arr2.length;\\n        int[][] dp = new int[n1 + 1][n2 + 1];\\n        for (int i = 1; i <= n1; i++) {\\n            for (int j = 1; j <= n2; j++) {\\n                if (arr1[i - 1] == arr2[j - 1]) {\\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\\n                } else {\\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\\n                }\\n            }\\n        }\\n        return dp[n1][n2];\\n    }\\n}\\n```\\nComplexity:\\n- Time: `O(n^2)`, `n` is the length of string `s`\\n- Space: `O(n^2)`",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int minInsertions(String s) {\\n        String sReverse = new StringBuilder(s).reverse().toString();\\n        int lcs = longestCommonSubsequence(s.toCharArray(), sReverse.toCharArray());\\n        return s.length() - lcs;\\n    }\\n\\n    private int longestCommonSubsequence(char[] arr1, char[] arr2) {\\n        int n1 = arr1.length, n2 = arr2.length;\\n        int[][] dp = new int[n1 + 1][n2 + 1];\\n        for (int i = 1; i <= n1; i++) {\\n            for (int j = 1; j <= n2; j++) {\\n                if (arr1[i - 1] == arr2[j - 1]) {\\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\\n                } else {\\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\\n                }\\n            }\\n        }\\n        return dp[n1][n2];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443028,
                "title": "easy-solutions-in-java-python-and-c-look-at-once-with-exaplanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n>To make a given string `s` a palindrome, we need to insert characters at some positions in the string. If we can find the longest common subsequence (LCS) between the given string `s` and its reverse, we can find the characters that are already part of the palindrome. Then, we can insert the remaining characters (which are not part of the LCS) at their appropriate positions in the string to make it a palindrome.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Reverse the input string to get a new string `reversed_s`.\\n2. Initialize a 2D array `dp` of size `(n+1)x(n+1)` with 0s, where `n` is the length of the input string `s`.\\n3. Iterate through all pairs of indices `(i,j)` of the array `dp`, where `1<=i,j<=n`.\\n4. If the characters at indices `i-1` in string `s` and `j-1` in `reversed_s` are equal, set `dp[i][j] = dp[i-1][j-1] + 1`.\\n5. Otherwise, set `dp[i][j]` to the maximum of `dp[i-1][j]` and `dp[i][j-1]`.\\n6. The length of the LCS between `s` and `reversed_s` is `dp[n][n]`.\\n7. The minimum number of insertions required to make `s` a palindrome is `n - dp[n][n]`\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n>O(n^2), where `n` is the length of the input string `s`. This is because we are filling up a 2D array of size `(n+1)x(n+1)` using dynamic programming approach.\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n>O(n^2), where `n` is the length of the input string `s`. This is because we are using a 2D array of size `(n+1)x(n+1)` to store the LCS of substrings.\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int minInsertions(String s) {\\n        // reverse the input string\\n        String reversed = new StringBuilder(s).reverse().toString();\\n        // get the length of the input string\\n        int n = s.length();\\n        // create a 2D array to store the LCS of substrings\\n        int[][] dp = new int[n+1][n+1];\\n        \\n        // fill up the dp array using dynamic programming approach\\n        for(int i=1; i<=n; i++) {\\n            for(int j=1; j<=n; j++) {\\n                if(s.charAt(i-1) == reversed.charAt(j-1)) {\\n                    // if characters match, add 1 to LCS\\n                    dp[i][j] = dp[i-1][j-1] + 1;\\n                } else {\\n                    // otherwise, take maximum LCS of two substrings\\n                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\\n                }\\n            }\\n        }\\n        \\n        // return the minimum number of insertions required to make s a palindrome\\n        // this is the difference between the length of s and the length of its LCS\\n        return n - dp[n][n];\\n    }\\n}\\n\\n```\\n```python []\\nclass Solution(object):\\n    def minInsertions(self, s):\\n        # reverse the input string\\n        reversed_s = s[::-1]\\n        # get the length of the input string\\n        n = len(s)\\n        # create a 2D array to store the LCS of substrings\\n        dp = [[0 for j in range(n+1)] for i in range(n+1)]\\n        \\n        # fill up the dp array using dynamic programming approach\\n        for i in range(1, n+1):\\n            for j in range(1, n+1):\\n                if s[i-1] == reversed_s[j-1]:\\n                    # if characters match, add 1 to LCS\\n                    dp[i][j] = dp[i-1][j-1] + 1\\n                else:\\n                    # otherwise, take maximum LCS of two substrings\\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\\n        \\n        # return the minimum number of insertions required to make s a palindrome\\n        # this is the difference between the length of s and the length of its LCS\\n        return n - dp[n][n]\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        // reverse the input string\\n        string reversed_s = string(s.rbegin(), s.rend());\\n        // get the length of the input string\\n        int n = s.length();\\n        // create a 2D vector to store the LCS of substrings\\n        vector<vector<int>> dp(n+1, vector<int>(n+1, 0));\\n        \\n        // fill up the dp vector using dynamic programming approach\\n        for(int i=1; i<=n; i++) {\\n            for(int j=1; j<=n; j++) {\\n                if(s[i-1] == reversed_s[j-1]) {\\n                    // if characters match, add 1 to LCS\\n                    dp[i][j] = dp[i-1][j-1] + 1;\\n                } else {\\n                    // otherwise, take maximum LCS of two substrings\\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\\n                }\\n            }\\n        }\\n        \\n        // return the minimum number of insertions required to make s a palindrome\\n        // this is the difference between the length of s and the length of its LCS\\n        return n - dp[n][n];\\n    }\\n};\\n```\\n\\n``` javascript []\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minInsertions = function(s) {\\n    // reverse the input string\\n    const reversedS = s.split(\\'\\').reverse().join(\\'\\');\\n    // get the length of the input string\\n    const n = s.length;\\n    // create a 2D array to store the LCS of substrings\\n    const dp = Array.from({ length: n + 1 }, () => new Array(n + 1).fill(0));\\n    \\n    // fill up the dp array using dynamic programming approach\\n    for(let i = 1; i <= n; i++) {\\n        for(let j = 1; j <= n; j++) {\\n            if(s[i-1] === reversedS[j-1]) {\\n                // if characters match, add 1 to LCS\\n                dp[i][j] = dp[i-1][j-1] + 1;\\n            } else {\\n                // otherwise, take maximum LCS of two substrings\\n                dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\\n            }\\n        }\\n    }\\n    \\n    // return the minimum number of insertions required to make s a palindrome\\n    // this is the difference between the length of s and the length of its LCS\\n    return n - dp[n][n];\\n};\\n\\n```\\n```\\nLCS stands for Longest Common Subsequence\\n```\\n\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n```java []\\nclass Solution {\\n    public int minInsertions(String s) {\\n        // reverse the input string\\n        String reversed = new StringBuilder(s).reverse().toString();\\n        // get the length of the input string\\n        int n = s.length();\\n        // create a 2D array to store the LCS of substrings\\n        int[][] dp = new int[n+1][n+1];\\n        \\n        // fill up the dp array using dynamic programming approach\\n        for(int i=1; i<=n; i++) {\\n            for(int j=1; j<=n; j++) {\\n                if(s.charAt(i-1) == reversed.charAt(j-1)) {\\n                    // if characters match, add 1 to LCS\\n                    dp[i][j] = dp[i-1][j-1] + 1;\\n                } else {\\n                    // otherwise, take maximum LCS of two substrings\\n                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\\n                }\\n            }\\n        }\\n        \\n        // return the minimum number of insertions required to make s a palindrome\\n        // this is the difference between the length of s and the length of its LCS\\n        return n - dp[n][n];\\n    }\\n}\\n\\n```\n```python []\\nclass Solution(object):\\n    def minInsertions(self, s):\\n        # reverse the input string\\n        reversed_s = s[::-1]\\n        # get the length of the input string\\n        n = len(s)\\n        # create a 2D array to store the LCS of substrings\\n        dp = [[0 for j in range(n+1)] for i in range(n+1)]\\n        \\n        # fill up the dp array using dynamic programming approach\\n        for i in range(1, n+1):\\n            for j in range(1, n+1):\\n                if s[i-1] == reversed_s[j-1]:\\n                    # if characters match, add 1 to LCS\\n                    dp[i][j] = dp[i-1][j-1] + 1\\n                else:\\n                    # otherwise, take maximum LCS of two substrings\\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\\n        \\n        # return the minimum number of insertions required to make s a palindrome\\n        # this is the difference between the length of s and the length of its LCS\\n        return n - dp[n][n]\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        // reverse the input string\\n        string reversed_s = string(s.rbegin(), s.rend());\\n        // get the length of the input string\\n        int n = s.length();\\n        // create a 2D vector to store the LCS of substrings\\n        vector<vector<int>> dp(n+1, vector<int>(n+1, 0));\\n        \\n        // fill up the dp vector using dynamic programming approach\\n        for(int i=1; i<=n; i++) {\\n            for(int j=1; j<=n; j++) {\\n                if(s[i-1] == reversed_s[j-1]) {\\n                    // if characters match, add 1 to LCS\\n                    dp[i][j] = dp[i-1][j-1] + 1;\\n                } else {\\n                    // otherwise, take maximum LCS of two substrings\\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\\n                }\\n            }\\n        }\\n        \\n        // return the minimum number of insertions required to make s a palindrome\\n        // this is the difference between the length of s and the length of its LCS\\n        return n - dp[n][n];\\n    }\\n};\\n```\n``` javascript []\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minInsertions = function(s) {\\n    // reverse the input string\\n    const reversedS = s.split(\\'\\').reverse().join(\\'\\');\\n    // get the length of the input string\\n    const n = s.length;\\n    // create a 2D array to store the LCS of substrings\\n    const dp = Array.from({ length: n + 1 }, () => new Array(n + 1).fill(0));\\n    \\n    // fill up the dp array using dynamic programming approach\\n    for(let i = 1; i <= n; i++) {\\n        for(let j = 1; j <= n; j++) {\\n            if(s[i-1] === reversedS[j-1]) {\\n                // if characters match, add 1 to LCS\\n                dp[i][j] = dp[i-1][j-1] + 1;\\n            } else {\\n                // otherwise, take maximum LCS of two substrings\\n                dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\\n            }\\n        }\\n    }\\n    \\n    // return the minimum number of insertions required to make s a palindrome\\n    // this is the difference between the length of s and the length of its LCS\\n    return n - dp[n][n];\\n};\\n\\n```\n```\\nLCS stands for Longest Common Subsequence\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 633595,
                "title": "100-memory-efficient-and-98-faster-solution-easy-c-dp-lcs",
                "content": "**TOP-DOWN DYNAMIC PROGRAMING**\\nWe need to find if there exist any subsequence of string **S1** which is palindrome. \\nIf there is such a subsequence **sub**, then we need minimum ***len(S1)-len(sub)***\\nElse, we need atleast ***len(S1)*** number of insertions to make it palindrome.\\n\\nTo find the len of subsequence of S1 which is palindrome, we can use [Longest Common Subsequence](https://en.wikipedia.org/wiki/Longest_common_subsequence_problem). \\n```\\nint minInsertions(string s1) {\\n        int n = s1.size();\\n        int DP[n+1][n+1];\\n        string s2  =s1;\\n        reverse(s1.begin(),s1.end());\\n        \\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=n;j++){\\n                if(i==0 || j==0){\\n                    DP[i][j] = 0;\\n                }\\n                else if(s1[i-1]==s2[j-1]){\\n                    DP[i][j] = DP[i-1][j-1]+1;\\n                }\\n                else{\\n                    DP[i][j] = max(DP[i-1][j],DP[i][j-1]);\\n                }\\n            }\\n        }\\n    \\n        return n-DP[n][n];\\n    }\\n```\\n\\nPlease upvote if you liked the post.\\nYou can refer to the [this](https://www.youtube.com/watch?v=AEcRW4ylm_c&list=PL_z_8CaSLPWekqhdCPmFohncHwz8TY2Go&index=33&t=0s) link if you want detail explanation.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint minInsertions(string s1) {\\n        int n = s1.size();\\n        int DP[n+1][n+1];\\n        string s2  =s1;\\n        reverse(s1.begin(),s1.end());\\n        \\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=n;j++){\\n                if(i==0 || j==0){\\n                    DP[i][j] = 0;\\n                }\\n                else if(s1[i-1]==s2[j-1]){\\n                    DP[i][j] = DP[i-1][j-1]+1;\\n                }\\n                else{\\n                    DP[i][j] = max(DP[i-1][j],DP[i][j-1]);\\n                }\\n            }\\n        }\\n    \\n        return n-DP[n][n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 476662,
                "title": "python-clean-dp",
                "content": "`dp[i,j]` stands for the minimum insertion steps to make `s[i:j+1]` palindrome.\\nIf `s[i] == s[j]` then `dp[i,j]` should be equal to `dp[i+1,j-1]` as no extra cost needed for a palidrome string to include `s[i]` on the left and `s[j]` on the right. \\nOtherwise, `dp[i,j]` take an extra 1 cost from the smaller cost between `dp[i+1,j]` and `dp[i,j-1]`.\\nThen the recurrence equation would be: \\n`dp[i][j] = dp[i+1][j-1] if s[i] == s[j] else min(dp[i+1][j], dp[i][j-1]) + 1`\\n\\nTo build a bottom-up iteration, we need to iterate all the combination of `(i, j)` where `i < j`. \\nThere is no need to check `dp[i,i]` which is `0`. \\nAnother base case is `dp[i,i-1]`. This happens only when we are checking a `dp[i,i+1]` and `s[i] == s[i+1]`. This can also be set as `0` so `dp[i,i+1]` will be `0` correctly.\\nSo we can savely initialized the entire `dp` array to be filled with `0`.\\n```\\ndef minInsertions(self, s):\\n\\tn = len(s)\\n\\tdp = [[0] * n for _ in range(n)]\\n\\tfor j in range(n):\\n\\t\\tfor i in range(j-1,-1,-1):\\n\\t\\t\\tdp[i][j] = dp[i+1][j-1] if s[i] == s[j] else min(dp[i+1][j], dp[i][j-1]) + 1\\n\\treturn dp[0][n-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef minInsertions(self, s):\\n\\tn = len(s)\\n\\tdp = [[0] * n for _ in range(n)]\\n\\tfor j in range(n):\\n\\t\\tfor i in range(j-1,-1,-1):\\n\\t\\t\\tdp[i][j] = dp[i+1][j-1] if s[i] == s[j] else min(dp[i+1][j], dp[i][j-1]) + 1\\n\\treturn dp[0][n-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3314578,
                "title": "dp-simple-java-solution-longest-palindromic-subsequence",
                "content": "# Intuition\\nIf we know the **longest palindromic sub-sequence** is x and the length of the string is n then, what is the answer to this problem? It is n - x as we need n - x insertions to make the remaining characters also palindrome.\\n\\n# Approach\\nWe just need to find the length of **longest common subsequence** of the given string and the string obtained by reversing the original string.\\n\\n# Complexity\\n- Time complexity: O(N^2) \\n\\n- Space complexity: O(N^2)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String a) {\\n        StringBuilder s = new StringBuilder(a);\\n        s.reverse();\\n        // Obtaining the reverse of original string\\n        String b = s.toString();\\n        \\n        int n = a.length();\\n        int t[][] = new int[n+1][n+1];\\n        \\n        // Top-down DP\\n        for(int i=1; i<=n; i++) \\n            for(int j=1; j<=n; j++)\\n                if(a.charAt(i-1)==b.charAt(j-1)) t[i][j] = 1 + t[i-1][j-1];\\n                else t[i][j] = Math.max(t[i-1][j], t[i][j-1]);\\n        // Desired answer\\n        return n-t[n][n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String a) {\\n        StringBuilder s = new StringBuilder(a);\\n        s.reverse();\\n        // Obtaining the reverse of original string\\n        String b = s.toString();\\n        \\n        int n = a.length();\\n        int t[][] = new int[n+1][n+1];\\n        \\n        // Top-down DP\\n        for(int i=1; i<=n; i++) \\n            for(int j=1; j<=n; j++)\\n                if(a.charAt(i-1)==b.charAt(j-1)) t[i][j] = 1 + t[i-1][j-1];\\n                else t[i][j] = Math.max(t[i-1][j], t[i][j-1]);\\n        // Desired answer\\n        return n-t[n][n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1440673,
                "title": "javascript-dynamic-programming-easy-and-explained",
                "content": "**Explanation** : This is the direct implementation of Longest Palindromic Subsequence. \\n\\nPS: Feel free to ask your questions in comments and do upvote if you liked my solution.\\n\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minInsertions = function(s) {\\n    \\n    let dp = []\\n    \\n    for(let row = 0 ; row <= s.length ; row ++){\\n        let arr = []\\n        \\n        for(let col = 0 ; col <= s.length ; col ++) arr.push(0)\\n        \\n        dp.push(arr)\\n    }\\n    \\n    let rev = s.split(\"\")\\n    \\n    rev = rev.reverse();\\n    \\n    rev = rev.join(\"\");\\n    \\n    for(let row = 1 ; row <= s.length ; row ++ )\\n        for(let col = 1 ; col <= s.length ; col ++) {\\n            \\n            if(s[row-1] === rev[col-1])\\n                dp[row][col] = 1 + dp[row-1][col-1]\\n            else\\n                dp[row][col] = Math.max(dp[row-1][col],dp[row][col-1])\\n        }\\n    \\n    return s.length - dp[s.length][s.length];\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minInsertions = function(s) {\\n    \\n    let dp = []\\n    \\n    for(let row = 0 ; row <= s.length ; row ++){\\n        let arr = []\\n        \\n        for(let col = 0 ; col <= s.length ; col ++) arr.push(0)\\n        \\n        dp.push(arr)\\n    }\\n    \\n    let rev = s.split(\"\")\\n    \\n    rev = rev.reverse();\\n    \\n    rev = rev.join(\"\");\\n    \\n    for(let row = 1 ; row <= s.length ; row ++ )\\n        for(let col = 1 ; col <= s.length ; col ++) {\\n            \\n            if(s[row-1] === rev[col-1])\\n                dp[row][col] = 1 + dp[row-1][col-1]\\n            else\\n                dp[row][col] = Math.max(dp[row-1][col],dp[row][col-1])\\n        }\\n    \\n    return s.length - dp[s.length][s.length];\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 474000,
                "title": "longest-palindrome-subsequence",
                "content": "I know there are a lot of BIG GOD\\'s discussions to show how to solve this. \\nBut for easy understanding, this problem could be transformed to:\\n**Finding \"longest palindrome subsequence\", **\\nthen transformed to:\\n**Finding \"longest common subsequence to his reversed string \".**\\n```\\ninInsertions(String s) \\n= n - longthPalSubSeq(s)\\n= n - longthCommonSubSeq(s, reversed(s)) \\n```\\n\\n\\n```\\nclass Solution {\\n    //same as find the longest sub palindrome subsequence\\n    public int minInsertions(String s) {\\n        int n = s.length();\\n        int[][] dp = new int[n+1][n+1];\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if (s.charAt(i) == s.charAt(n - 1 - j)){\\n                    dp[i+1][j+1] = dp[i][j] + 1;\\n                } else {\\n                    dp[i+1][j+1] = Math.max(dp[i+1][j], dp[i][j+1]);\\n                }\\n            }\\n        }\\n        return n - dp[n][n];\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\ninInsertions(String s) \\n= n - longthPalSubSeq(s)\\n= n - longthCommonSubSeq(s, reversed(s)) \\n```\n```\\nclass Solution {\\n    //same as find the longest sub palindrome subsequence\\n    public int minInsertions(String s) {\\n        int n = s.length();\\n        int[][] dp = new int[n+1][n+1];\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if (s.charAt(i) == s.charAt(n - 1 - j)){\\n                    dp[i+1][j+1] = dp[i][j] + 1;\\n                } else {\\n                    dp[i+1][j+1] = Math.max(dp[i+1][j], dp[i][j+1]);\\n                }\\n            }\\n        }\\n        return n - dp[n][n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442819,
                "title": "java-dp-1d-and-2d-beats-70-time-100-space-explanation-space-optimization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo make a given string palindrome, we need to insert some characters at some positions. If we can find out the longest common subsequence between the given string and its reverse, we can find out the characters that don\\'t need to be inserted to make the string a palindrome. The number of insertions needed will be equal to the length of the given string minus the length of the longest common subsequence.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use dynamic programming to find the longest common subsequence between the given string `s` and its reverse. We can define a 2D array `dp` of size `(n+1)x(n+1)`, where `n` is the length of the string `s`. We can then populate the `dp` array using the following recurrence relation:\\n\\n```\\nif s[i-1] == s_reverse[j-1]:\\n    dp[i][j] = dp[i-1][j-1] + 1\\nelse:\\n    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\\n```\\nOnce we have filled the `dp` array, we can return the difference between the length of `s` and the length of its longest common subsequence, which will give us the minimum number of insertions required to make `s` a palindrome.\\n\\nHowever, we can optimize the space complexity of our solution by using only a 1D array instead of a 2D array. We can define a 1D array `dp` of size `(n+1)`, where `n` is the length of the string `s`. We can then populate the `dp` array using the following recurrence relation:\\n\\n```\\nif s[i-1] == s_reverse[j-1]:\\n    dp[j] = prev + 1\\nelse:\\n    dp[j] = max(dp[j], dp[j-1])\\n```\\nHere, `prev` represents the value of `dp[j-1]` from the previous iteration of the inner loop.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**O(n^2)** , where `n` is the length of the string `s`. This is because we need to fill the entire `dp` array, which has a size of `(n+1)x(n+1)`.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**O(n)**, where `n` is the length of the string `s`. This is because we only need to use a 1D array of size `(n+1)` to store our dynamic programming table.\\n\\n# Code\\n```\\nclass Solution {\\n    // Space optimized logic for the below code\\n    public int minInsertions(String s) {\\n        int n = s.length();\\n        int[] dp = new int[n + 1];\\n        int prev = 0;\\n        for (int i = 1; i <= n; i++) {\\n            prev = 0;\\n            for (int j = 1; j <= n; j++) {\\n                int temp = dp[j];\\n                if (s.charAt(i - 1) == s.charAt(n - j)) {\\n                    dp[j] = prev + 1;\\n                } else {\\n                    dp[j] = Math.max(dp[j], dp[j - 1]);\\n                }\\n                prev = temp;\\n            }\\n        }\\n        return n - dp[n];\\n    }\\n    /*\\n    2D array\\n    public int minInsertions(String s) {\\n        return s.length()-helper(s,reverse(s));        \\n    }\\n    private String reverse(String s)\\n    {\\n        String str = new StringBuilder(s).reverse().toString();\\n        return str;\\n    }\\n    private int helper(String seedha, String ulta)\\n    {\\n        // Is function me hum longest common subsequence ka length nikalne wale hai\\n        int n = seedha.length();\\n        int[][] dp = new int[n+1][n+1];\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(seedha.charAt(i) == ulta.charAt(j))\\n                {\\n                    dp[i+1][j+1]= dp[i][j]+1;\\n                }\\n                else\\n                {\\n                    dp[i+1][j+1]= Math.max(dp[i+1][j],dp[i][j+1]);\\n                }\\n            }\\n        }\\n        return dp[n][n];\\n\\n    }\\n\\n    */\\n}\\n```\\n## If you found this helpful, please don\\'t forget to upvote!\\n",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nif s[i-1] == s_reverse[j-1]:\\n    dp[i][j] = dp[i-1][j-1] + 1\\nelse:\\n    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\\n```\n```\\nif s[i-1] == s_reverse[j-1]:\\n    dp[j] = prev + 1\\nelse:\\n    dp[j] = max(dp[j], dp[j-1])\\n```\n```\\nclass Solution {\\n    // Space optimized logic for the below code\\n    public int minInsertions(String s) {\\n        int n = s.length();\\n        int[] dp = new int[n + 1];\\n        int prev = 0;\\n        for (int i = 1; i <= n; i++) {\\n            prev = 0;\\n            for (int j = 1; j <= n; j++) {\\n                int temp = dp[j];\\n                if (s.charAt(i - 1) == s.charAt(n - j)) {\\n                    dp[j] = prev + 1;\\n                } else {\\n                    dp[j] = Math.max(dp[j], dp[j - 1]);\\n                }\\n                prev = temp;\\n            }\\n        }\\n        return n - dp[n];\\n    }\\n    /*\\n    2D array\\n    public int minInsertions(String s) {\\n        return s.length()-helper(s,reverse(s));        \\n    }\\n    private String reverse(String s)\\n    {\\n        String str = new StringBuilder(s).reverse().toString();\\n        return str;\\n    }\\n    private int helper(String seedha, String ulta)\\n    {\\n        // Is function me hum longest common subsequence ka length nikalne wale hai\\n        int n = seedha.length();\\n        int[][] dp = new int[n+1][n+1];\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(seedha.charAt(i) == ulta.charAt(j))\\n                {\\n                    dp[i+1][j+1]= dp[i][j]+1;\\n                }\\n                else\\n                {\\n                    dp[i+1][j+1]= Math.max(dp[i+1][j],dp[i][j+1]);\\n                }\\n            }\\n        }\\n        return dp[n][n];\\n\\n    }\\n\\n    */\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442337,
                "title": "how-len-lps-explained-with-images-recursion-to-bottom-up",
                "content": "![image](https://assets.leetcode.com/users/images/84f65bac-e8cd-4634-bf72-0b7685762631_1682124024.6771638.jpeg)\\n![image](https://assets.leetcode.com/users/images/ad5faf88-fff6-4085-93a8-82ee9b1e28d6_1682124031.7868736.jpeg)\\n\\n\\n## RECURSION\\n```\\nclass Solution {\\npublic:\\n    int lps(string& s, int start, int end)\\n    {\\n        if (start == end) return 1;\\n        if (start > end) return 0;\\n        \\n        if (s[start] == s[end]) return (2 + lps(s, start + 1, end - 1));\\n        int leaveLeft = lps(s, start + 1, end);\\n        int leaveRight = lps(s, start, end - 1);\\n        return max(leaveLeft, leaveRight);\\n    }\\n    int minInsertions(string s) \\n    {\\n        int lpsLen = lps(s, 0, s.size() - 1);\\n        return (s.size() - lpsLen);\\n    }\\n\\n};\\n```\\n//=======================================================================================================================\\n## TOP-DOWN\\n```\\nclass Solution {\\npublic:\\n    int lps(string& s, vector<vector<int>>&dp, int start, int end)\\n    {\\n        if (start == end) return 1;\\n        if (start > end) return 0;\\n        if (dp[start][end] != -1) return dp[start][end];\\n        \\n        if (s[start] == s[end]) return (2 + lps(s, dp, start + 1, end - 1)); //directly return \\n        \\n        int leaveLeft = lps(s, dp, start + 1, end);\\n        int leaveRight = lps(s, dp, start, end - 1);\\n        return dp[start][end] = max(leaveLeft, leaveRight); //store the ans\\n    }\\n    int minInsertions(string s) \\n    {\\n        int n = s.size();\\n        vector<vector<int>>dp(n, vector<int>(n, -1));\\n        int lpsLen = lps(s, dp, 0, n - 1);\\n        return (n - lpsLen);\\n    }\\n\\n};\\n```\\n//=======================================================================================================================\\n## BOTTOM-UP\\n```\\nclass Solution {\\npublic:\\n    int lps(string& s)\\n    {\\n       int n = s.size();\\n        vector<vector<int>>dp(n, vector<int>(n, 0));\\n        //for n length string we need LPS for string with length (n - 1) or (n - 2)\\n        //We need to already have LPS for smaller lengths before moving to greater lengths\\n        //so we need to go bottom up \\n        //Calculating LPS for all strings of length = 1 to length = n\\n        //================================================================================\\n        for (int len = 1; len <= n; len++)\\n        {\\n            for (int start = 0; start <= (n - len); start++)\\n            {\\n                int end = start + len - 1; //[start, end] denotes the string under consideration\\n                if (len == 1) { dp[start][end] = 1; continue; }\\n                \\n                if (s[start] == s[end]) dp[start][end] = 2 + dp[start + 1][end - 1];\\n                else dp[start][end] = max(dp[start + 1][end], dp[start][end - 1]); \\n            }\\n        }\\n        //=====================================================================================\\n        return dp[0][n - 1];\\n    }\\n    int minInsertions(string s) \\n    {\\n        int n = s.size();\\n        int lpsLen = lps(s);\\n        return (n - lpsLen);\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lps(string& s, int start, int end)\\n    {\\n        if (start == end) return 1;\\n        if (start > end) return 0;\\n        \\n        if (s[start] == s[end]) return (2 + lps(s, start + 1, end - 1));\\n        int leaveLeft = lps(s, start + 1, end);\\n        int leaveRight = lps(s, start, end - 1);\\n        return max(leaveLeft, leaveRight);\\n    }\\n    int minInsertions(string s) \\n    {\\n        int lpsLen = lps(s, 0, s.size() - 1);\\n        return (s.size() - lpsLen);\\n    }\\n\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int lps(string& s, vector<vector<int>>&dp, int start, int end)\\n    {\\n        if (start == end) return 1;\\n        if (start > end) return 0;\\n        if (dp[start][end] != -1) return dp[start][end];\\n        \\n        if (s[start] == s[end]) return (2 + lps(s, dp, start + 1, end - 1)); //directly return \\n        \\n        int leaveLeft = lps(s, dp, start + 1, end);\\n        int leaveRight = lps(s, dp, start, end - 1);\\n        return dp[start][end] = max(leaveLeft, leaveRight); //store the ans\\n    }\\n    int minInsertions(string s) \\n    {\\n        int n = s.size();\\n        vector<vector<int>>dp(n, vector<int>(n, -1));\\n        int lpsLen = lps(s, dp, 0, n - 1);\\n        return (n - lpsLen);\\n    }\\n\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int lps(string& s)\\n    {\\n       int n = s.size();\\n        vector<vector<int>>dp(n, vector<int>(n, 0));\\n        //for n length string we need LPS for string with length (n - 1) or (n - 2)\\n        //We need to already have LPS for smaller lengths before moving to greater lengths\\n        //so we need to go bottom up \\n        //Calculating LPS for all strings of length = 1 to length = n\\n        //================================================================================\\n        for (int len = 1; len <= n; len++)\\n        {\\n            for (int start = 0; start <= (n - len); start++)\\n            {\\n                int end = start + len - 1; //[start, end] denotes the string under consideration\\n                if (len == 1) { dp[start][end] = 1; continue; }\\n                \\n                if (s[start] == s[end]) dp[start][end] = 2 + dp[start + 1][end - 1];\\n                else dp[start][end] = max(dp[start + 1][end], dp[start][end - 1]); \\n            }\\n        }\\n        //=====================================================================================\\n        return dp[0][n - 1];\\n    }\\n    int minInsertions(string s) \\n    {\\n        int n = s.size();\\n        int lpsLen = lps(s);\\n        return (n - lpsLen);\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442336,
                "title": "day-112-recursion-memoization-easiest-beginner-friendly-sol",
                "content": "**NOTE - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Intuition of this Problem :\\n**If you know how to solve Longest palindromic Subsequence then this problem is easy for you. For example s = \"acdsddca\" then longest palondromic subsequence is \"acddca\" i.e. of length 6. It means if we insert n - 6 = 8 - 6 = 2 character in this given string then this string is palindromic string. How?\\n Earlier we have earlier string s = \"acdsddca\" now we need to add two more charater to amke this string palindromic i.e. new string s = \"acdsddsdca\"**\\n\\n516. Longest Palindromic Subsequence - https://leetcode.com/problems/longest-palindromic-subsequence/\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Code :\\n```C++ []\\n// Recursive approach - TLE\\n//The time complexity of the longestPalindromeSubstring function is O(2^n) where n is the length of the input string s. This is because in the worst case, the function will make two recursive calls at each step, effectively creating a binary tree with 2^n nodes.\\n//The space complexity of the algorithm is O(n) due to the recursive calls on the call stack. In the worst case, the call stack can grow to a depth of n, corresponding to the length of the input string s.\\nclass Solution {\\npublic:\\n    int longestPalindromeSubstring(string& s, int i, int j) {\\n        if (i > j)\\n            return 0;\\n        else if (i == j)\\n            return 1;\\n        else if (s[i] == s[j])\\n            return 2 + longestPalindromeSubstring(s, i+1, j-1);\\n        else\\n            return max(longestPalindromeSubstring(s, i+1, j), longestPalindromeSubstring(s, i, j-1));\\n    }\\n    int minInsertions(string s) {\\n        int n = s.length();\\n        int minNumSteps = n - longestPalindromeSubstring(s, 0, n-1);\\n        return minNumSteps;\\n    }\\n};\\n```\\n```C++ []\\n// Memoization (top-down DP) - Accepted\\n//The time complexity of the longestPalindromeSubstring function with memoization is O(n^2), where n is the length of the input string s. This is because the function can be visualized as filling in a diagonal strip in a 2D matrix of size n x n, and each entry is computed only once and stored in the memo table.\\n//The space complexity of the algorithm is O(n^2) due to the memoization table. It requires a 2D array of size n x n to store the computed results.\\nclass Solution {\\npublic:\\n    int longestPalindromeSubstring(string& s, int i, int j, vector<vector<int>>& memo) {\\n        if (i > j)\\n            return 0;\\n        else if (i == j)\\n            return 1;\\n        else if (memo[i][j] != -1)\\n            return memo[i][j];\\n        else if (s[i] == s[j])\\n            return memo[i][j] = 2 + longestPalindromeSubstring(s, i+1, j-1, memo);\\n        else\\n            return memo[i][j] = max(longestPalindromeSubstring(s, i+1, j, memo), longestPalindromeSubstring(s, i, j-1, memo));\\n    }\\n    int minInsertions(string s) {\\n        int n = s.length();\\n        vector<vector<int>> memo(n, vector<int>(n, -1));\\n        int minNumSteps = n - longestPalindromeSubstring(s, 0, n-1, memo);\\n        return minNumSteps;\\n    }\\n};\\n```\\n```C++ []\\n// Tabulation (bottm-up DP) - coming soon\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```C++ []\\n// Recursive approach - TLE\\n//The time complexity of the longestPalindromeSubstring function is O(2^n) where n is the length of the input string s. This is because in the worst case, the function will make two recursive calls at each step, effectively creating a binary tree with 2^n nodes.\\n//The space complexity of the algorithm is O(n) due to the recursive calls on the call stack. In the worst case, the call stack can grow to a depth of n, corresponding to the length of the input string s.\\nclass Solution {\\npublic:\\n    int longestPalindromeSubstring(string& s, int i, int j) {\\n        if (i > j)\\n            return 0;\\n        else if (i == j)\\n            return 1;\\n        else if (s[i] == s[j])\\n            return 2 + longestPalindromeSubstring(s, i+1, j-1);\\n        else\\n            return max(longestPalindromeSubstring(s, i+1, j), longestPalindromeSubstring(s, i, j-1));\\n    }\\n    int minInsertions(string s) {\\n        int n = s.length();\\n        int minNumSteps = n - longestPalindromeSubstring(s, 0, n-1);\\n        return minNumSteps;\\n    }\\n};\\n```\n```C++ []\\n// Memoization (top-down DP) - Accepted\\n//The time complexity of the longestPalindromeSubstring function with memoization is O(n^2), where n is the length of the input string s. This is because the function can be visualized as filling in a diagonal strip in a 2D matrix of size n x n, and each entry is computed only once and stored in the memo table.\\n//The space complexity of the algorithm is O(n^2) due to the memoization table. It requires a 2D array of size n x n to store the computed results.\\nclass Solution {\\npublic:\\n    int longestPalindromeSubstring(string& s, int i, int j, vector<vector<int>>& memo) {\\n        if (i > j)\\n            return 0;\\n        else if (i == j)\\n            return 1;\\n        else if (memo[i][j] != -1)\\n            return memo[i][j];\\n        else if (s[i] == s[j])\\n            return memo[i][j] = 2 + longestPalindromeSubstring(s, i+1, j-1, memo);\\n        else\\n            return memo[i][j] = max(longestPalindromeSubstring(s, i+1, j, memo), longestPalindromeSubstring(s, i, j-1, memo));\\n    }\\n    int minInsertions(string s) {\\n        int n = s.length();\\n        vector<vector<int>> memo(n, vector<int>(n, -1));\\n        int minNumSteps = n - longestPalindromeSubstring(s, 0, n-1, memo);\\n        return minNumSteps;\\n    }\\n};\\n```\n```C++ []\\n// Tabulation (bottm-up DP) - coming soon\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1304221,
                "title": "longest-palindromic-subsequence-aditya-verma-s-approach",
                "content": "Just find the length of Longest Palindromic Subsequence and subtract it from the string size (in the same way we can calculate \"minimum number of deletions to make a string palindrome\").\\n```\\nclass Solution {\\npublic:\\n    int lcs(int x, int y, string s1, string s2)\\n    {\\n        int dp[x+1][y+1];\\n        \\n        for(int i = 0; i <= x; i++)\\n        {\\n            dp[i][0] = 0;\\n        }\\n        \\n        for(int j = 0; j <= y; j++)\\n        {\\n            dp[0][j] = 0;\\n        }\\n        \\n        for(int i = 1; i <= x; i++)\\n        {\\n            for(int j = 1; j <= y; j++)\\n            {\\n                if(s1[i-1] == s2[j-1])\\n                {\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                }\\n                else\\n                {\\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[x][y];\\n    }\\n    int minInsertions(string A) {\\n        int n = A.size();\\n        string B = A;\\n        reverse(B.begin(),B.end());\\n        return n - lcs(n,n,A,B);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lcs(int x, int y, string s1, string s2)\\n    {\\n        int dp[x+1][y+1];\\n        \\n        for(int i = 0; i <= x; i++)\\n        {\\n            dp[i][0] = 0;\\n        }\\n        \\n        for(int j = 0; j <= y; j++)\\n        {\\n            dp[0][j] = 0;\\n        }\\n        \\n        for(int i = 1; i <= x; i++)\\n        {\\n            for(int j = 1; j <= y; j++)\\n            {\\n                if(s1[i-1] == s2[j-1])\\n                {\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                }\\n                else\\n                {\\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[x][y];\\n    }\\n    int minInsertions(string A) {\\n        int n = A.size();\\n        string B = A;\\n        reverse(B.begin(),B.end());\\n        return n - lcs(n,n,A,B);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 772001,
                "title": "simple-python-dp-solution-longest-common-subsequence-variation",
                "content": "Let the first string be a. then take a new string b which is reversed of a.\\napply longest common subsequnce on both the strings and subtract the answer from the length of the string.\\nit works for minimum number of deletion as well as minimum number of insertion to make a string palindrome.\\n\\n\\tclass Solution:\\n\\t\\tdef minInsertions(self, a: str) -> int:\\n\\t\\t\\tb = a[::-1]\\n\\t\\t\\tn = len(a)\\n\\n\\t\\t\\tdp = [[0 for x in range(n + 1)] for y in range(n + 1)]\\n\\n\\t\\t\\tfor i in range(1, n + 1):\\n\\t\\t\\t\\tfor j in range(1, n + 1):\\n\\t\\t\\t\\t\\tif a[i - 1] == b[j - 1]:\\n\\t\\t\\t\\t\\t\\tdp[i][j] = 1 + dp[i - 1][j - 1]\\n\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\\n\\n\\t\\t\\treturn n - dp[-1][-1]",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "Let the first string be a. then take a new string b which is reversed of a.\\napply longest common subsequnce on both the strings and subtract the answer from the length of the string.\\nit works for minimum number of deletion as well as minimum number of insertion to make a string palindrome.\\n\\n\\tclass Solution:\\n\\t\\tdef minInsertions(self, a: str) -> int:\\n\\t\\t\\tb = a[::-1]\\n\\t\\t\\tn = len(a)\\n\\n\\t\\t\\tdp = [[0 for x in range(n + 1)] for y in range(n + 1)]\\n\\n\\t\\t\\tfor i in range(1, n + 1):\\n\\t\\t\\t\\tfor j in range(1, n + 1):\\n\\t\\t\\t\\t\\tif a[i - 1] == b[j - 1]:\\n\\t\\t\\t\\t\\t\\tdp[i][j] = 1 + dp[i - 1][j - 1]\\n\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\\n\\n\\t\\t\\treturn n - dp[-1][-1]",
                "codeTag": "Java"
            },
            {
                "id": 3442377,
                "title": "c-clean-code-25-lines-easy-to-understand-well-explained",
                "content": "\\n## **Pls upvote the thread if you found it helpful.**\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem.l --> \\nIn order to minimize the insertions, we need to find the **difference** of length of the longest palindromic subsequence and string length. \\n\\n`Minimum Insertion required = len(string) \\u2013 length(lps)`\\n\\n**This question has a pre req : [Longest Palindromic Subsequence](https://leetcode.com/problems/longest-palindromic-subsequence/)**\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We are given a string, store its length as n.\\n- Find the length of the longest palindromic subsequence (say l) \\n- Return n-l as answer.\\n\\n# Complexity\\n- Time complexity: O(N*M) two nested loops\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(M) external array of size \\u2018M+1\\u2019 to store only two rows\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int lcs(string s1, string s2) {\\n    int n = s1.size();\\n    int m = s2.size();\\n    vector<int> prev(m + 1,0), cur(m + 1,0);\\n    for(int ind1 = 1;ind1 <= n; ind1++){\\n        for(int ind2 = 1;ind2 <= m;ind2++){\\n            if(s1[ind1 - 1] == s2[ind2 - 1])\\n                cur[ind2] = 1 + prev[ind2 - 1];\\n            else\\n                cur[ind2] = 0 + max(prev[ind2],cur[ind2 - 1]);\\n        }\\n        prev = cur;\\n    }\\n    return prev[m];\\n}\\n        int longestPalindromeSubsequence(string s){\\n        string t = s;\\n        reverse(s.begin(),s.end());\\n        return lcs(s,t);\\n    }\\npublic:   \\n    int minInsertions(string s) {\\n        int n = s.size();\\n        int k = longestPalindromeSubsequence(s);\\n        return n-k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int lcs(string s1, string s2) {\\n    int n = s1.size();\\n    int m = s2.size();\\n    vector<int> prev(m + 1,0), cur(m + 1,0);\\n    for(int ind1 = 1;ind1 <= n; ind1++){\\n        for(int ind2 = 1;ind2 <= m;ind2++){\\n            if(s1[ind1 - 1] == s2[ind2 - 1])\\n                cur[ind2] = 1 + prev[ind2 - 1];\\n            else\\n                cur[ind2] = 0 + max(prev[ind2],cur[ind2 - 1]);\\n        }\\n        prev = cur;\\n    }\\n    return prev[m];\\n}\\n        int longestPalindromeSubsequence(string s){\\n        string t = s;\\n        reverse(s.begin(),s.end());\\n        return lcs(s,t);\\n    }\\npublic:   \\n    int minInsertions(string s) {\\n        int n = s.size();\\n        int k = longestPalindromeSubsequence(s);\\n        return n-k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 473382,
                "title": "java-simple-dp-with-explanation-and-very-small-code",
                "content": "1. The initution is two pointers (at the beginning and at the end end).\\n2. Match the the pointer if the match move the pointers(begin+1 and end-1)\\n3. If they dont match either you add character at the end or character at the begin. \\n4. Since we have a choice here if have to make the min of the two cases. Thus forming a recursive problem.\\n5. Since we will be coming across same begin,end pointer pairs we apply DP.\\nThis guarantee min solution as we try to explore all the possible cases\\n6. O(n^2 \\n\\n```\\nclass Solution {\\n    \\n    Integer[][] dp;\\n    \\n    public int helper(int i, int j, String s){\\n        \\n        if(i>j)\\n            return 0;\\n        \\n        if(dp[i][j] != null)\\n            return dp[i][j];\\n        int val;\\n        \\n        if(s.charAt(i) == s.charAt(j))\\n            val = helper(i+1,j-1,s);\\n        else\\n            val = Math.min(helper(i+1,j,s),helper(i,j-1,s)) + 1;\\n        \\n        dp[i][j] = val;\\n        \\n        return dp[i][j];\\n    }\\n    public int minInsertions(String s) {\\n        dp = new Integer[s.length()][s.length()];\\n        return helper(0,s.length()-1,s);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    Integer[][] dp;\\n    \\n    public int helper(int i, int j, String s){\\n        \\n        if(i>j)\\n            return 0;\\n        \\n        if(dp[i][j] != null)\\n            return dp[i][j];\\n        int val;\\n        \\n        if(s.charAt(i) == s.charAt(j))\\n            val = helper(i+1,j-1,s);\\n        else\\n            val = Math.min(helper(i+1,j,s),helper(i,j-1,s)) + 1;\\n        \\n        dp[i][j] = val;\\n        \\n        return dp[i][j];\\n    }\\n    public int minInsertions(String s) {\\n        dp = new Integer[s.length()][s.length()];\\n        return helper(0,s.length()-1,s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 470790,
                "title": "python3-short-straight-forward-dp",
                "content": "```\\nimport functools\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        @functools.lru_cache(None)\\n        def dp(i, j):\\n            if j - i <= 1: return 0\\n            return dp(i + 1, j - 1) if s[i] == s[j - 1] else min(dp(i + 1, j), dp(i, j - 1)) + 1\\n        return dp(0, len(s))\\n```",
                "solutionTags": [],
                "code": "```\\nimport functools\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        @functools.lru_cache(None)\\n        def dp(i, j):\\n            if j - i <= 1: return 0\\n            return dp(i + 1, j - 1) if s[i] == s[j - 1] else min(dp(i + 1, j), dp(i, j - 1)) + 1\\n        return dp(0, len(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442360,
                "title": "easy-solution-of-java-c-dp-beginner-friendly",
                "content": "\\n\\n# Code\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n        public int minInsertions(String s) {\\n        StringBuilder sb = new StringBuilder(s);\\n        sb.reverse();\\n        String rev = sb.toString();\\n        int n = s.length();\\n        int[][] dp = new int[n+1][n+1];\\n        for(int i=1;i<=n;i++) {\\n            for(int j=1;j<=n;j++) {\\n                int val = -1;\\n                if(s.charAt(i-1) == rev.charAt(j-1)) {\\n                    val = 1 + dp[i-1][j-1];\\n                }\\n                else {\\n                    val =  Math.max(dp[i-1][j], dp[i][j-1]);\\n                }\\n                dp[i][j] = val;\\n            }\\n        }\\n        int lcsCount = dp[n][n];\\n       \\n        int minInsertion = n - lcsCount; \\n        return minInsertion;\\n    }\\n}\\n```\\nC++\\n```\\nclass Solution {\\npublic:\\n\\tint lcs(string s1, string s2) {\\n\\t\\tint n=s1.size(),m=s2.size();\\n\\t\\tvector<vector<int>> dp(n,vector<int>(m,0));\\n\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\tfor(int j=0;j<m;j++){\\n\\t\\t\\t\\tif(!i  || !j){\\n\\t\\t\\t\\t\\tif(s1[i]==s2[j]) dp[i][j]=1;\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tif(!i && !j) dp[0][0]=0;\\n\\t\\t\\t\\t\\t\\telse if(!i && j) dp[0][j]=dp[0][j-1];\\n\\t\\t\\t\\t\\t\\telse if(i && !j) dp[i][0]=dp[i-1][0];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tif(s1[i]==s2[j]) dp[i][j]=1+dp[i-1][j-1];\\n\\t\\t\\t\\t\\telse dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[n-1][m-1];  \\n\\t}\\n\\n\\tint minInsertions(string s) {\\n\\t\\treturn s.size()-lcs(s,string(s.rbegin(),s.rend()));\\n\\t}\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n        public int minInsertions(String s) {\\n        StringBuilder sb = new StringBuilder(s);\\n        sb.reverse();\\n        String rev = sb.toString();\\n        int n = s.length();\\n        int[][] dp = new int[n+1][n+1];\\n        for(int i=1;i<=n;i++) {\\n            for(int j=1;j<=n;j++) {\\n                int val = -1;\\n                if(s.charAt(i-1) == rev.charAt(j-1)) {\\n                    val = 1 + dp[i-1][j-1];\\n                }\\n                else {\\n                    val =  Math.max(dp[i-1][j], dp[i][j-1]);\\n                }\\n                dp[i][j] = val;\\n            }\\n        }\\n        int lcsCount = dp[n][n];\\n       \\n        int minInsertion = n - lcsCount; \\n        return minInsertion;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n\\tint lcs(string s1, string s2) {\\n\\t\\tint n=s1.size(),m=s2.size();\\n\\t\\tvector<vector<int>> dp(n,vector<int>(m,0));\\n\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\tfor(int j=0;j<m;j++){\\n\\t\\t\\t\\tif(!i  || !j){\\n\\t\\t\\t\\t\\tif(s1[i]==s2[j]) dp[i][j]=1;\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tif(!i && !j) dp[0][0]=0;\\n\\t\\t\\t\\t\\t\\telse if(!i && j) dp[0][j]=dp[0][j-1];\\n\\t\\t\\t\\t\\t\\telse if(i && !j) dp[i][0]=dp[i-1][0];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tif(s1[i]==s2[j]) dp[i][j]=1+dp[i-1][j-1];\\n\\t\\t\\t\\t\\telse dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[n-1][m-1];  \\n\\t}\\n\\n\\tint minInsertions(string s) {\\n\\t\\treturn s.size()-lcs(s,string(s.rbegin(),s.rend()));\\n\\t}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453286,
                "title": "striver-bhaiya-chad-approach-woh-bhi-space-optimized",
                "content": "```\\nclass Solution {\\n    public int minInsertions(String s1) {\\n\\t    int n =s1.length();\\n        String s2 =\"\";\\n        for(int i=n-1; i>=0; i--) s2 += s1.charAt(i); // S2 = rev(S1) for L.P.S computation\\n        \\n        int dp[] = new int[n+1];\\n        for(int i=1; i<=n; i++){ // Generating L.C.S ~ Space Optimized!\\n            int cur[] = new int[n+1];\\n            for(int j=1; j<=n; j++){\\n                if(s1.charAt(i-1) == s2.charAt(j-1)) cur[j] = 1 + dp[j-1];\\n                else cur[j] = Math.max(dp[j], cur[j-1]);\\n            }\\n            dp = cur;\\n        } // Got our L.P.S\\n        \\n        // Now, min_operation = n - lps \\n        return (n - dp[n]); // a c p c a \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s1) {\\n\\t    int n =s1.length();\\n        String s2 =\"\";\\n        for(int i=n-1; i>=0; i--) s2 += s1.charAt(i); // S2 = rev(S1) for L.P.S computation\\n        \\n        int dp[] = new int[n+1];\\n        for(int i=1; i<=n; i++){ // Generating L.C.S ~ Space Optimized!\\n            int cur[] = new int[n+1];\\n            for(int j=1; j<=n; j++){\\n                if(s1.charAt(i-1) == s2.charAt(j-1)) cur[j] = 1 + dp[j-1];\\n                else cur[j] = Math.max(dp[j], cur[j-1]);\\n            }\\n            dp = cur;\\n        } // Got our L.P.S\\n        \\n        // Now, min_operation = n - lps \\n        return (n - dp[n]); // a c p c a \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444829,
                "title": "c-extra-small-dynamic-programming-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDynamic programming\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n   size of string - the Longest Palindromic Subsequence\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n       O(n*m)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n       O(n*m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        vector<vector<int>> dp(s.size(),vector<int>(s.size(),0));\\n        string t=s;\\n        reverse(t.begin(),t.end());\\n        for(int i=0;i<s.size();i++)for(int j=0;j<t.size();j++)\\n            (s[i]==t[j])?(dp[i][j]= 1+((i-1>=0 && j-1>=0)?dp[i-1][j-1]:0)):( dp[i][j]=max(((i>0)?dp[i-1][j]:0),((j>0)?dp[i][j-1]:0)));\\n        return s.size()-dp[s.size()-1][t.size()-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        vector<vector<int>> dp(s.size(),vector<int>(s.size(),0));\\n        string t=s;\\n        reverse(t.begin(),t.end());\\n        for(int i=0;i<s.size();i++)for(int j=0;j<t.size();j++)\\n            (s[i]==t[j])?(dp[i][j]= 1+((i-1>=0 && j-1>=0)?dp[i-1][j-1]:0)):( dp[i][j]=max(((i>0)?dp[i-1][j]:0),((j>0)?dp[i][j-1]:0)));\\n        return s.size()-dp[s.size()-1][t.size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2355772,
                "title": "simple-dp-solution-based-on-longest-common-subsequence-lcs-pattern",
                "content": "In lcs code we require 2 string inputs, here we have only 1 string input so we reverse it to get other string. After that we simply write our lcs code.\\nFor better understanding of patterns in DP you can refer to **Aditya Verma\\'s Playlist**:- \\nhttps://www.youtube.com/playlist?list=PL_z_8CaSLPWekqhdCPmFohncHwz8TY2Go\\n```\\n    int minInsertions(string s) {\\n        int n = s.size();\\n        string b = s;\\n        reverse(b.begin() , b.end());\\n        \\n        vector<vector<int>> dp(n+1 , vector<int>(n+1 , 0));\\n        \\n        for(int i = 1 ; i<=n ; i++){\\n            for(int j = 1 ; j<= n ; j++){\\n                if(s[i-1]==b[j-1])\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                else\\n                    dp[i][j] = max(dp[i-1][j] , dp[i][j-1]);\\n            }\\n        }\\n        return n - dp[n][n];\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int minInsertions(string s) {\\n        int n = s.size();\\n        string b = s;\\n        reverse(b.begin() , b.end());\\n        \\n        vector<vector<int>> dp(n+1 , vector<int>(n+1 , 0));\\n        \\n        for(int i = 1 ; i<=n ; i++){\\n            for(int j = 1 ; j<= n ; j++){\\n                if(s[i-1]==b[j-1])\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                else\\n                    dp[i][j] = max(dp[i-1][j] , dp[i][j-1]);\\n            }\\n        }\\n        return n - dp[n][n];\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1440675,
                "title": "java-c-concise-solution",
                "content": "This is a direct implementation of longest palindromic subsequence. \\n\\n```\\nclass Solution {\\n    public String reverseIt(String str)\\n     {\\n          int i, len = str.length();\\n         \\n          StringBuilder dest = new StringBuilder(len);\\n\\n          for (i = (len - 1); i >= 0; i--)\\n              dest.append(str.charAt(i));\\n         \\n           return dest.toString();\\n    }\\n    \\n    public int minInsertions(String s) \\n    {\\n           String s1 = reverseIt(s);\\n\\n           int dp[][] = new int[s1.length() + 1][s1.length() + 1];\\n\\n           for(int idx = 0; idx < s1.length() + 1; idx++)\\n               dp[0][idx] = 0;\\n\\n           for(int idx = 0; idx < s.length() + 1; idx++)\\n               dp[idx][0] = 0;\\n\\n           for(int row = 1; row < s.length() + 1; row++)\\n           {\\n               for(int col = 1; col < s1.length() + 1; col++)\\n               {\\n                   if(s.charAt(row - 1) == s1.charAt(col - 1))\\n                       dp[row][col] = 1 + dp[row - 1][col - 1];\\n\\n                   else\\n                       dp[row][col] = Math.max(dp[row - 1][col], dp[row][col - 1]);\\n               }\\n           }\\n\\n           return s.length() - dp[s.length()][s1.length()];\\n    }\\n}\\n```\\n\\nSame implementation in Cpp\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s)\\n    {\\n       string s1 = s;\\n       \\n       reverse(s1.begin(), s1.end());\\n        \\n       int dp[s1.size() + 1][s.size() + 1];\\n        \\n       for(int idx = 0; idx < s1.size() + 1; idx++)\\n           dp[0][idx] = 0;\\n        \\n       for(int idx = 0; idx < s.size() + 1; idx++)\\n           dp[idx][0] = 0;\\n        \\n       for(int row = 1; row < s.size() + 1; row++)\\n       {\\n           for(int col = 1; col < s1.size() + 1; col++)\\n           {\\n               if(s[row - 1] == s1[col - 1])\\n                   dp[row][col] = 1 + dp[row - 1][col - 1];\\n               \\n               else\\n                   dp[row][col] = max(dp[row - 1][col], dp[row][col - 1]);\\n           }\\n       }\\n        \\n       return s.size() - dp[s.size()][s1.size()];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String reverseIt(String str)\\n     {\\n          int i, len = str.length();\\n         \\n          StringBuilder dest = new StringBuilder(len);\\n\\n          for (i = (len - 1); i >= 0; i--)\\n              dest.append(str.charAt(i));\\n         \\n           return dest.toString();\\n    }\\n    \\n    public int minInsertions(String s) \\n    {\\n           String s1 = reverseIt(s);\\n\\n           int dp[][] = new int[s1.length() + 1][s1.length() + 1];\\n\\n           for(int idx = 0; idx < s1.length() + 1; idx++)\\n               dp[0][idx] = 0;\\n\\n           for(int idx = 0; idx < s.length() + 1; idx++)\\n               dp[idx][0] = 0;\\n\\n           for(int row = 1; row < s.length() + 1; row++)\\n           {\\n               for(int col = 1; col < s1.length() + 1; col++)\\n               {\\n                   if(s.charAt(row - 1) == s1.charAt(col - 1))\\n                       dp[row][col] = 1 + dp[row - 1][col - 1];\\n\\n                   else\\n                       dp[row][col] = Math.max(dp[row - 1][col], dp[row][col - 1]);\\n               }\\n           }\\n\\n           return s.length() - dp[s.length()][s1.length()];\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s)\\n    {\\n       string s1 = s;\\n       \\n       reverse(s1.begin(), s1.end());\\n        \\n       int dp[s1.size() + 1][s.size() + 1];\\n        \\n       for(int idx = 0; idx < s1.size() + 1; idx++)\\n           dp[0][idx] = 0;\\n        \\n       for(int idx = 0; idx < s.size() + 1; idx++)\\n           dp[idx][0] = 0;\\n        \\n       for(int row = 1; row < s.size() + 1; row++)\\n       {\\n           for(int col = 1; col < s1.size() + 1; col++)\\n           {\\n               if(s[row - 1] == s1[col - 1])\\n                   dp[row][col] = 1 + dp[row - 1][col - 1];\\n               \\n               else\\n                   dp[row][col] = max(dp[row - 1][col], dp[row][col - 1]);\\n           }\\n       }\\n        \\n       return s.size() - dp[s.size()][s1.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 828314,
                "title": "dyanmic-programming-beats-90-solution-with-detailed-explanation",
                "content": "The question requires us to breakdown the problem in terms of smaller sub-problem\\n\\nLet dp be a matrix where dp[i][j] stores the minimum number of insertions required to make subtring [i...j] palindromic \\n  Case -1 s[i] != s[j]\\n              in this case we have two choices, add a character equal to s[i] at the position of jth index and now the i and j be will equal ,which will cost us 1  move, the rest can be calculated for smaller subproblem [i+1, ...,j] .\\n\\t\\t\\t  similarly we can do by adding a character equal to s[j] at the position of ith index and calculate [i,j-1]\\n\\t\\t\\t  Recurrence Relation -dp[i][j] =min(dp[i+1][j],dp[i][j-1]) +1\\n\\tCase-2 s[i] ==s[j]\\n\\t  In this case apart from from the above ways we can derive answer, our answer can also be gained by finding out moves to make [i+1,...,j-1] palindromic\\n\\t   Recurrence Relation dp[i][j]=min(dp[i+1][j-1],min(dp[i+1][j],dp[i][j-1])+1)\\n\\t   \\n\\t   \\n\\t   Code ->\\n\\t    int minInsertions(string s) {\\n     \\n        int n=s.size();\\n        int dp[n][n];\\n        memset(dp,0,sizeof dp);\\n        \\n        for(int l=2;l<=n;l++)\\n        {\\n            for(int i=0;i<n-l+1;i++)\\n            {\\n                int j=i+l-1;\\n                if(j==(i+1))\\n                {\\n                    if(s[j]==s[i])\\n                        dp[i][j]=0;\\n                    else\\n                        dp[i][j]=1;\\n                }\\n                else\\n                {\\n                    dp[i][j]=INT_MAX;\\n                    if(s[i]==s[j])\\n                        dp[i][j]=dp[i+1][j-1];\\n                    \\n                    dp[i][j]=min(dp[i][j],min(dp[i+1][j],dp[i][j-1])+1);\\n                }\\n            }\\n        }\\n        return dp[0][n-1];\\n        \\n    }",
                "solutionTags": [],
                "code": "The question requires us to breakdown the problem in terms of smaller sub-problem\\n\\nLet dp be a matrix where dp[i][j] stores the minimum number of insertions required to make subtring [i...j] palindromic \\n  Case -1 s[i] != s[j]\\n              in this case we have two choices, add a character equal to s[i] at the position of jth index and now the i and j be will equal ,which will cost us 1  move, the rest can be calculated for smaller subproblem [i+1, ...,j] .\\n\\t\\t\\t  similarly we can do by adding a character equal to s[j] at the position of ith index and calculate [i,j-1]\\n\\t\\t\\t  Recurrence Relation -dp[i][j] =min(dp[i+1][j],dp[i][j-1]) +1\\n\\tCase-2 s[i] ==s[j]\\n\\t  In this case apart from from the above ways we can derive answer, our answer can also be gained by finding out moves to make [i+1,...,j-1] palindromic\\n\\t   Recurrence Relation dp[i][j]=min(dp[i+1][j-1],min(dp[i+1][j],dp[i][j-1])+1)\\n\\t   \\n\\t   \\n\\t   Code ->\\n\\t    int minInsertions(string s) {\\n     \\n        int n=s.size();\\n        int dp[n][n];\\n        memset(dp,0,sizeof dp);\\n        \\n        for(int l=2;l<=n;l++)\\n        {\\n            for(int i=0;i<n-l+1;i++)\\n            {\\n                int j=i+l-1;\\n                if(j==(i+1))\\n                {\\n                    if(s[j]==s[i])\\n                        dp[i][j]=0;\\n                    else\\n                        dp[i][j]=1;\\n                }\\n                else\\n                {\\n                    dp[i][j]=INT_MAX;\\n                    if(s[i]==s[j])\\n                        dp[i][j]=dp[i+1][j-1];\\n                    \\n                    dp[i][j]=min(dp[i][j],min(dp[i+1][j],dp[i][j-1])+1);\\n                }\\n            }\\n        }\\n        return dp[0][n-1];\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3442414,
                "title": "c-picture-explanation-recursion-memoization-with-recursion-tree",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n![image.png](https://assets.leetcode.com/users/images/50813e57-3459-4f29-bf89-329fe7ac3052_1682127238.8847425.png)\\n![image.png](https://assets.leetcode.com/users/images/86dae25f-8ad9-4864-9952-32908c088811_1682127258.409485.png)\\n![image.png](https://assets.leetcode.com/users/images/90bb7033-267e-419e-b8f5-d6d45cb09a89_1682127283.5393384.png)\\n![image.png](https://assets.leetcode.com/users/images/c657ad82-d3af-41fc-9090-d6478c115089_1682127360.4488578.png)\\n![image.png](https://assets.leetcode.com/users/images/a1c0ef10-631c-46b9-963e-09936a95d850_1682127396.9829204.png)\\n![image.png](https://assets.leetcode.com/users/images/21ab37ce-405d-4a27-9494-e78ff6dcb5b6_1682127416.34991.png)\\n![image.png](https://assets.leetcode.com/users/images/44af89b1-f288-4584-a77b-1eccd76d104b_1682127463.1750078.png)\\n![image.png](https://assets.leetcode.com/users/images/4bfde9fd-ab36-451b-bb6e-85db6b4b4dce_1682127485.4674213.png)\\n![image.png](https://assets.leetcode.com/users/images/aa4158f3-775c-45b9-aa99-87a001a491b1_1682127508.6822114.png)\\n![image.png](https://assets.leetcode.com/users/images/7e8df1ee-f397-4d07-89da-a40f1bd3497f_1682127529.1466532.png)\\n![image.png](https://assets.leetcode.com/users/images/b8568aa7-594b-4b45-9b74-4066831d8f2b_1682127549.7029772.png)\\n![image.png](https://assets.leetcode.com/users/images/4b06186f-2a25-4ab3-878c-20426fff9895_1682127775.0427327.png)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nPlease UPVOTE if you liked the explanation.\\n\\n# BRUTE FORCE Code:\\n```\\nclass Solution {\\npublic:\\n    //BRUTE FORCE= RECURSION\\n    int makePalindrome(int i, int j, string &s){\\n        if(i>=j) return 0;\\n        else if(s[i]==s[j]) return makePalindrome(i+1, j-1, s);\\n        else{\\n            int possibility1= makePalindrome(i+1, j, s);\\n            int possibility2= makePalindrome(i, j-1, s);\\n\\n            return min(possibility1, possibility2)+1;\\n        }\\n    }\\n    int minInsertions(string s) {\\n        int n= s.size();\\n        return makePalindrome(0, n-1, s);\\n    }\\n};\\n```\\n# Memoization Code:\\n```\\nclass Solution {\\npublic:\\n    int makePalindrome(int i, int j, string &s, vector<vector<int>>&dp){\\n        if(i>=j) return 0;\\n        else if(dp[i][j]!=-1) return dp[i][j];\\n        else if(s[i]==s[j]) return makePalindrome(i+1, j-1, s, dp);\\n        else{\\n            int possibility1= makePalindrome(i+1, j, s, dp);\\n            int possibility2= makePalindrome(i, j-1, s, dp);\\n\\n            dp[i][j]= min(possibility1, possibility2)+1;\\n            return dp[i][j];\\n        }\\n    }\\n    int minInsertions(string s) {\\n        int n= s.size();\\n        vector<vector<int>> dp(n, vector<int>(n,-1));\\n        return makePalindrome(0, n-1, s, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //BRUTE FORCE= RECURSION\\n    int makePalindrome(int i, int j, string &s){\\n        if(i>=j) return 0;\\n        else if(s[i]==s[j]) return makePalindrome(i+1, j-1, s);\\n        else{\\n            int possibility1= makePalindrome(i+1, j, s);\\n            int possibility2= makePalindrome(i, j-1, s);\\n\\n            return min(possibility1, possibility2)+1;\\n        }\\n    }\\n    int minInsertions(string s) {\\n        int n= s.size();\\n        return makePalindrome(0, n-1, s);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int makePalindrome(int i, int j, string &s, vector<vector<int>>&dp){\\n        if(i>=j) return 0;\\n        else if(dp[i][j]!=-1) return dp[i][j];\\n        else if(s[i]==s[j]) return makePalindrome(i+1, j-1, s, dp);\\n        else{\\n            int possibility1= makePalindrome(i+1, j, s, dp);\\n            int possibility2= makePalindrome(i, j-1, s, dp);\\n\\n            dp[i][j]= min(possibility1, possibility2)+1;\\n            return dp[i][j];\\n        }\\n    }\\n    int minInsertions(string s) {\\n        int n= s.size();\\n        vector<vector<int>> dp(n, vector<int>(n,-1));\\n        return makePalindrome(0, n-1, s, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415593,
                "title": "c-dp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        string p=s;\\n        reverse(s.begin(),s.end());\\n        int n=s.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,0));\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=n;j++){\\n                if(s[j-1]==p[i-1])dp[i][j]=max(dp[i-1][j],max(1+dp[i-1][j-1],dp[i][j-1]));\\n                else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        return n-dp[n][n];\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/32930f00-185e-4785-b9d1-4b1ecb5cb473_1681459833.037058.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        string p=s;\\n        reverse(s.begin(),s.end());\\n        int n=s.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,0));\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=n;j++){\\n                if(s[j-1]==p[i-1])dp[i][j]=max(dp[i-1][j],max(1+dp[i-1][j-1],dp[i][j-1]));\\n                else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        return n-dp[n][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362063,
                "title": "best-o-n-m-solution",
                "content": "# Approach\\nDP (Bottom Up Approach)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * m)$$\\n\\n- Space complexity:\\n$$O(n * m)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int longestPalindromeSubseq(string s, string t) { \\n        int n = s.length(); \\n        vector<vector<int>> dp(n+1, vector<int>(n+1, 0));\\n        for (int i = 0; i <= n; i++) {\\n            dp[i][0] = 0;\\n            dp[0][i] = 0;\\n        } \\n        for (int idx1 = 1; idx1 <= n; idx1++) {\\n            for (int idx2 = 1; idx2 <= n; idx2++) {\\n                if (s[idx1-1] == t[idx2-1])\\n                    dp[idx1][idx2] = 1 + dp[idx1-1][idx2-1];\\n                else\\n                    dp[idx1][idx2] = max (dp[idx1-1][idx2], dp[idx1][idx2-1]);\\n            }\\n        }      \\n        return dp[n][n];\\n    }    \\npublic:\\n    int minInsertions(string s) {\\n        int n = s.length();\\n        string t = s;\\n        reverse(t.begin(), t.end());\\n        int lpsLen = longestPalindromeSubseq(s, t);\\n        return n - lpsLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int longestPalindromeSubseq(string s, string t) { \\n        int n = s.length(); \\n        vector<vector<int>> dp(n+1, vector<int>(n+1, 0));\\n        for (int i = 0; i <= n; i++) {\\n            dp[i][0] = 0;\\n            dp[0][i] = 0;\\n        } \\n        for (int idx1 = 1; idx1 <= n; idx1++) {\\n            for (int idx2 = 1; idx2 <= n; idx2++) {\\n                if (s[idx1-1] == t[idx2-1])\\n                    dp[idx1][idx2] = 1 + dp[idx1-1][idx2-1];\\n                else\\n                    dp[idx1][idx2] = max (dp[idx1-1][idx2], dp[idx1][idx2-1]);\\n            }\\n        }      \\n        return dp[n][n];\\n    }    \\npublic:\\n    int minInsertions(string s) {\\n        int n = s.length();\\n        string t = s;\\n        reverse(t.begin(), t.end());\\n        int lpsLen = longestPalindromeSubseq(s, t);\\n        return n - lpsLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1308808,
                "title": "3-steps-dp-sol-asked-by-amazon-google-uber-explanation-complexities",
                "content": "* ## EXPLANATION :-\\n1. **`THIS PROBLEM IS MAINLY EXTENSION OF LPS(Longest Palindromic Subsequence).`**\\n2. **`MOREOVER, THIS IS A DITTO COPY OF A CLASSICAL QUESTION OF DP KNOWN AS MINIMUM NUMBER OF DELETION TO MAKE A STRING PALINDROME.`**\\n3. **`IDEA : In this problem we just have to find LPS of the given string and subtract the LPS length from given string len !!`\\n    `BECAUSE, MINIMUM NUMBER OF INSERTIONS IS EQUAL TO MINIMUM NUMBER OF DELETION IN A STRING TO MAKE IT PALINDROME..`\\n    `ATLAST, HOW THIS QUESTION IS A EXTENSION OF LPS (Longest Palindromic Subsequence). SO, THE BASIC IDEA IS, IF WE FIND OUT LPS OF THE TWO SAME STRING`.\\n    `AND IF THE LONGEST COMMON(SIMILAR) CHARACTERS ARE MORE \\u2B06, THAT MEANS THERE WILL BE LEAST DISIMILAR CHARACTERS \\u2B07. HENCE, WE HAVE TO DELETE OR INSERT LEAST`\\n    `CHARACTERS IN A STRING TO MAKE A STRING PALINDROME!`**\\n4. **`IN A SIMPLE WORDS : LONGEST PALINDROMIC SUBSEQUENCE(LPS) IS INVERSELY PROPORTIONAL TO NUMBER OF DELETIONS(OR NUMBER OF INSERTIONS)`**\\n```\\n\\t\\t\\t\\t\\t\\t  1   \\n    LPS \\u2B06  \\u221D      -------------------\\n\\t\\t\\t\\t   NO. OF DELETIONS \\u2B07\\t\\n```\\t\\t\\t\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s1) {\\n        int n = s1.size();\\n        string s2 = s1;\\n        reverse(s2.begin(), s2.end());\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\\n        for(int i = 1; i <= n; ++i){\\n            for(int j = 1; j <= n; ++j){\\n                if(s1[i - 1] == s2[j - 1])\\n                    dp[i][j] = 1 + dp[i - 1][j - 1];                    // FIRST STEP\\n                else\\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);         // SECOND STEP\\n            }\\n        }\\n        int lenLPS = dp[n][n];\\n        return n - lenLPS;                                              // THIRD STEP\\n    }\\n};\\n```\\n**TIME COMPLEXITY : `O(n^2) == O(n * n)`, Where, n = size of str1 & str2** \\n**SPACE COMPLEXITY : `O(n * n)`, For using 2D array Aux space**\\n\\nif you find any mistakes pls, drop a comment\\nif it makes any sense don\\'t forget to **Upvote**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n\\t\\t\\t\\t\\t\\t  1   \\n    LPS \\u2B06  \\u221D      -------------------\\n\\t\\t\\t\\t   NO. OF DELETIONS \\u2B07\\t\\n```\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s1) {\\n        int n = s1.size();\\n        string s2 = s1;\\n        reverse(s2.begin(), s2.end());\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\\n        for(int i = 1; i <= n; ++i){\\n            for(int j = 1; j <= n; ++j){\\n                if(s1[i - 1] == s2[j - 1])\\n                    dp[i][j] = 1 + dp[i - 1][j - 1];                    // FIRST STEP\\n                else\\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);         // SECOND STEP\\n            }\\n        }\\n        int lenLPS = dp[n][n];\\n        return n - lenLPS;                                              // THIRD STEP\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 476731,
                "title": "c-simple-easy-solution",
                "content": "```\\nvector<vector<int>> memo;\\n    //code explained below ...\\n    int dp(string &s,int i,int j)\\n    {\\n        if(i>=j)\\t\\t//Base case.\\n            return 0;\\n        if(memo[i][j]!=-1) //Check if already calculated the value for the pair `i` and `j`.\\n            return memo[i][j];\\n        return memo[i][j]=s[i]==s[j]?dp(s,i+1,j-1):1+min(dp(s,i+1,j),dp(s,i,j-1));\\t\\t//Recursion \\n    }\\n    int minInsertions(string s) \\n    {\\n        memo.resize(s.length(),vector<int>(s.length(),-1));\\n        return dp(s,0,s.length()-1);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<vector<int>> memo;\\n    //code explained below ...\\n    int dp(string &s,int i,int j)\\n    {\\n        if(i>=j)\\t\\t//Base case.\\n            return 0;\\n        if(memo[i][j]!=-1) //Check if already calculated the value for the pair `i` and `j`.\\n            return memo[i][j];\\n        return memo[i][j]=s[i]==s[j]?dp(s,i+1,j-1):1+min(dp(s,i+1,j),dp(s,i,j-1));\\t\\t//Recursion \\n    }\\n    int minInsertions(string s) \\n    {\\n        memo.resize(s.length(),vector<int>(s.length(),-1));\\n        return dp(s,0,s.length()-1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3543842,
                "title": "1312-minimum-insertion-steps-to-make-a-string-palindrome",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo make a string palindrome, we need to insert characters in such a way that the resulting string reads the same backward as well as forward. We can approach this problem using dynamic programming. The intuition is to determine the minimum number of insertions required to make substrings of the given string palindrome.\\nIf we go for recursion, the Prgram will end in a **Memory Limit Exceeded** issue, which is due to the high no. of recursive calls. So, it is better to use DP.\\n\\nRecursive Solution: (MEMORY LIMIT EXCEEDED)\\n```C++ []\\nclass Solution {\\npublic:\\n    int minInsertionsRecursive(string s, int start, int end) {\\n        // Base cases\\n        if (start >= end) {\\n            return 0;\\n        }\\n        if (s[start] == s[end]) {\\n            return minInsertionsRecursive(s, start + 1, end - 1);\\n        }\\n        \\n        // Recursive cases\\n        int option1 = minInsertionsRecursive(s, start + 1, end) + 1;\\n        int option2 = minInsertionsRecursive(s, start, end - 1) + 1;\\n        \\n        return min(option1, option2);\\n    }\\n\\n    int minInsertions(string s) {\\n        return minInsertionsRecursive(s, 0, s.length() - 1);\\n    }\\n};\\n```\\nTime Complexity of Recurive Approach is exponential -> O(2^n).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. **Initialize the dp vector**: Create a vector dp of size n (length of the input string). This vector will store the minimum number of insertions required to make the substring from index i to index j a palindrome.\\n2. **Iterate through the string**: Start iterating through the string from the second last character to the first character (in reverse order). For each character at index i, iterate through all the characters at indices j greater than i.\\n3. **Check if characters at indices i and j are equal**: If the characters at indices i and j are equal, it means that they can form a palindrome without any additional insertions. In this case, set dp[j] to the value of dp[j-1] (which is the value of dp[j] in the previous iteration).\\n4. **If characters at indices i and j are not equal**: If the characters at indices i and j are not equal, it means that at least one insertion is required to make the substring from index i to index j a palindrome. In this case, set dp[j] to the minimum of dp[j] and dp[j-1] plus 1.\\n5. **Store the previous value of dp[j]**: To use the value of dp[j] in the previous iteration, store it in a variable prev before updating dp[j].\\n6. **Return the minimum number of insertions**: After iterating through the entire string, the value of dp[n-1] will store the minimum number of insertions required to make the entire string a palindrome. Return this value as the final result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n    O(n^2), where n is the length of the string.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n), because we use an additional array dp of size n.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.length();\\n        vector<int> dp(n);\\n        for (int i = n - 2; i >= 0; i--) {\\n            int prev = 0;\\n            for (int j = i + 1; j < n; j++) {\\n                int temp = dp[j];\\n                if (s[i] == s[j]) {\\n                    dp[j] = prev;\\n                } else {\\n                    dp[j] = min(dp[j], dp[j-1]) + 1;\\n                }\\n                prev = temp;\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int minInsertionsRecursive(string s, int start, int end) {\\n        // Base cases\\n        if (start >= end) {\\n            return 0;\\n        }\\n        if (s[start] == s[end]) {\\n            return minInsertionsRecursive(s, start + 1, end - 1);\\n        }\\n        \\n        // Recursive cases\\n        int option1 = minInsertionsRecursive(s, start + 1, end) + 1;\\n        int option2 = minInsertionsRecursive(s, start, end - 1) + 1;\\n        \\n        return min(option1, option2);\\n    }\\n\\n    int minInsertions(string s) {\\n        return minInsertionsRecursive(s, 0, s.length() - 1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.length();\\n        vector<int> dp(n);\\n        for (int i = n - 2; i >= 0; i--) {\\n            int prev = 0;\\n            for (int j = i + 1; j < n; j++) {\\n                int temp = dp[j];\\n                if (s[i] == s[j]) {\\n                    dp[j] = prev;\\n                } else {\\n                    dp[j] = min(dp[j], dp[j-1]) + 1;\\n                }\\n                prev = temp;\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444594,
                "title": "java-minimum-insertion-steps-to-make-a-string-palindrome",
                "content": "\\n```\\nclass Solution {\\n    public int longestPalindromeSubseq(String s) {\\n        char []str = s.toCharArray();\\n        int [][] answ = new int[s.length() + 1][s.length() + 1];\\n        int n = s.length();\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            for (int j = n - 1; j > -1; j--)\\n            {\\n                if (str[i] == str[j]) answ[i + 1][n - j] = answ[i - 1 + 1][n - j - 1 ] + 1;\\n                else answ[i + 1][n - j ] = Math.max(answ[i - 1 + 1][n - j ], answ[i + 1][n - j - 1]);\\n            }\\n        }\\n        return answ[n][n];\\n    }\\n    public int minInsertions(String s) {\\n        return s.length() - longestPalindromeSubseq(s);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestPalindromeSubseq(String s) {\\n        char []str = s.toCharArray();\\n        int [][] answ = new int[s.length() + 1][s.length() + 1];\\n        int n = s.length();\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            for (int j = n - 1; j > -1; j--)\\n            {\\n                if (str[i] == str[j]) answ[i + 1][n - j] = answ[i - 1 + 1][n - j - 1 ] + 1;\\n                else answ[i + 1][n - j ] = Math.max(answ[i - 1 + 1][n - j ], answ[i + 1][n - j - 1]);\\n            }\\n        }\\n        return answ[n][n];\\n    }\\n    public int minInsertions(String s) {\\n        return s.length() - longestPalindromeSubseq(s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443249,
                "title": "lps-c-recursion-memo-tabulation-space-optimization",
                "content": "# Approach\\nUsing the variant of Longest Common Subsequence, i,e Longest Pallindromic Subsequence find the length of LPS \\n\\nLPS as the name determine longest subsequence in the string which is a pallindrome, so for the answer we just have to add the elements which are not included in the subsequence.\\n\\nBefore going to Solutions Please Solve these Questions: \\n\\n## Longest Common Subsequence :-\\n  https://leetcode.com/problems/longest-common-subsequence/\\n## Longest Pallindromic Subsequence :-\\n https://leetcode.com/problems/longest-palindromic-subsequence/\\n\\n# Recursion +MEMO\\n```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int lps(string& s, string& t, int i, int j) {\\n        if(i >= s.size() || j >= t.size())\\n            return 0;\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        if(s[i] == t[j])\\n            dp[i][j] = 1 + lps(s, t, i+1, j+1);\\n        else\\n            dp[i][j] = max(lps(s, t, i+1, j), lps(s, t, i, j+1));\\n        return dp[i][j];\\n    }\\n    \\n    int minInsertions(string s) {\\n        memset(dp, -1, sizeof(dp));\\n        string t = s;\\n        reverse(t.begin(), t.end());\\n        int l = lps(s, t, 0, 0);\\n        return s.size() - l;\\n    }\\n};\\n\\n```\\n# Tabulation\\n```\\nclass Solution {\\npublic:\\n    int lps(string s, string t){\\n        int n = s.size();\\n        int dp[n+1][n+1];\\n        for(int i = 0 ;i<=n ; i++){\\n            dp[0][i] = 0;\\n        }\\n          for(int j = 0 ;j<=n ; j++){\\n            dp[j][0] = 0;\\n        }\\n        for(int i = 1;i<=n; i++){\\n            for(int j = 1; j<=n; j++){\\n                if(s[i-1] == t[j-1]){\\n                    dp[i][j] = 1+dp[i-1][j-1];\\n                }\\n                else{\\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\\n                }\\n            }\\n        }\\n        return dp[n][n];\\n    }\\n    int minInsertions(string s) {\\n        string t = s;\\n        reverse(t.begin(), t.end());\\n        int l = lps(s,t);\\n        cout << l << endl;\\n        return s.size() - l;  \\n    }\\n};\\n```\\n\\n# Space Optimization\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.size();\\n        string t = s;\\n        reverse(t.begin(), t.end());\\n        int dp[n+1];\\n        memset(dp, 0, sizeof(dp));\\n        int prev = 0;\\n        for(int i = 1; i <= n; i++) {\\n            prev = dp[0];\\n            for(int j = 1; j <= n; j++) {\\n                int temp = dp[j];\\n                if(s[i-1] == t[j-1])\\n                    dp[j] = 1 + prev;\\n                else\\n                    dp[j] = max(dp[j-1], dp[j]);\\n                prev = temp;\\n            }\\n        }\\n        return n - dp[n];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int lps(string& s, string& t, int i, int j) {\\n        if(i >= s.size() || j >= t.size())\\n            return 0;\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        if(s[i] == t[j])\\n            dp[i][j] = 1 + lps(s, t, i+1, j+1);\\n        else\\n            dp[i][j] = max(lps(s, t, i+1, j), lps(s, t, i, j+1));\\n        return dp[i][j];\\n    }\\n    \\n    int minInsertions(string s) {\\n        memset(dp, -1, sizeof(dp));\\n        string t = s;\\n        reverse(t.begin(), t.end());\\n        int l = lps(s, t, 0, 0);\\n        return s.size() - l;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int lps(string s, string t){\\n        int n = s.size();\\n        int dp[n+1][n+1];\\n        for(int i = 0 ;i<=n ; i++){\\n            dp[0][i] = 0;\\n        }\\n          for(int j = 0 ;j<=n ; j++){\\n            dp[j][0] = 0;\\n        }\\n        for(int i = 1;i<=n; i++){\\n            for(int j = 1; j<=n; j++){\\n                if(s[i-1] == t[j-1]){\\n                    dp[i][j] = 1+dp[i-1][j-1];\\n                }\\n                else{\\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\\n                }\\n            }\\n        }\\n        return dp[n][n];\\n    }\\n    int minInsertions(string s) {\\n        string t = s;\\n        reverse(t.begin(), t.end());\\n        int l = lps(s,t);\\n        cout << l << endl;\\n        return s.size() - l;  \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.size();\\n        string t = s;\\n        reverse(t.begin(), t.end());\\n        int dp[n+1];\\n        memset(dp, 0, sizeof(dp));\\n        int prev = 0;\\n        for(int i = 1; i <= n; i++) {\\n            prev = dp[0];\\n            for(int j = 1; j <= n; j++) {\\n                int temp = dp[j];\\n                if(s[i-1] == t[j-1])\\n                    dp[j] = 1 + prev;\\n                else\\n                    dp[j] = max(dp[j-1], dp[j]);\\n                prev = temp;\\n            }\\n        }\\n        return n - dp[n];\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3105819,
                "title": "longest-common-subsequence-extension-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI literally donnot have any idea then i came up with brute force and it didnt worked\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis is just a longest common subsequence question just reverse the given string and then return the lenght minus the common subsequence length\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        r=s[::-1]\\n        n=len(r)\\n        dp=[[0 for i in range(n+1)]for j in range(n+1)]\\n        for i in range(1,len(dp)):\\n            for j in range(1,len(dp[0])):\\n                if(s[i-1]==r[j-1]):\\n                    dp[i][j]=1+dp[i-1][j-1]\\n                else:\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1])\\n        return n-dp[n][n]\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        r=s[::-1]\\n        n=len(r)\\n        dp=[[0 for i in range(n+1)]for j in range(n+1)]\\n        for i in range(1,len(dp)):\\n            for j in range(1,len(dp[0])):\\n                if(s[i-1]==r[j-1]):\\n                    dp[i][j]=1+dp[i-1][j-1]\\n                else:\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1])\\n        return n-dp[n][n]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2066644,
                "title": "short-and-easy-to-understand",
                "content": "lps(a) = longest common subsequence (a,reverse(a))\\nmin no. of deletion = len(a) - lps(a)\\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        rs= s[::-1]\\n        n,m = len(s),len(rs)\\n        t = [[0 for j in range(m+1)]for i in range(n+1)]\\n        for i in range(1,n+1):\\n            for j in range(1,m+1):\\n                if s[i-1] == rs[j-1]:\\n                    t[i][j] = 1+t[i-1][j-1]\\n                else:\\n                    t[i][j] = max(t[i-1][j],t[i][j-1])      \\n        return n-t[i][j]            \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        rs= s[::-1]\\n        n,m = len(s),len(rs)\\n        t = [[0 for j in range(m+1)]for i in range(n+1)]\\n        for i in range(1,n+1):\\n            for j in range(1,m+1):\\n                if s[i-1] == rs[j-1]:\\n                    t[i][j] = 1+t[i-1][j-1]\\n                else:\\n                    t[i][j] = max(t[i-1][j],t[i][j-1])      \\n        return n-t[i][j]            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 472599,
                "title": "javascript-and-c-solutions",
                "content": "**Synopsis:**\\n\\n* **Recursive Top-Down solutions:** let `i` and `j` be the indexes corresponding to the substring of `s` from `i` to `j` inclusive (ie. `s[i..j]`)\\n\\t* Base case: if `i >= j` then return `0`\\n\\t* Recursive cases:\\n\\t\\t* if `s[i] == s[j]` then return the solution for the sub-problem *without* the characters at `i` and `j` (since there\\'s a match, there is no \"penalty\")\\n\\t\\t* if `s[i] != s[j]` then return `1` plus the minimum solution of (the sub-problem *without* the character at `i`) or (the sub-problem *without* the character at `j`)\\n\\n* **DP Bottom-Up solutions:** Same idea as above, but finding solutions for each substring from right-to-left.  Let `dp[i][j]` denote the optimal solution for a substring from `i` to `j` non-inclusive (ie. `s[i..j)`).  The bottom-up solution starts with a substring of length `1` (ie. the right-most character) and builds upon itself till length `N`.  The answer is `dp[0][N]` (ie. the optimal solution for `s[0..N)`).\\n\\n**Javascript Solutions: Recursive Top-Down**\\n\\n*Javascript: TLE without memo*\\n```\\nlet minInsertions = s => {\\n    let go = (s, i, j) => {\\n        if (i >= j)\\n            return 0;\\n        if (s[i] == s[j])\\n            return go(s, i + 1, j - 1);\\n        return 1 + Math.min(go(s, i + 1, j), go(s, i, j - 1));\\n    };\\n    return go(s, 0, s.length - 1);\\n};\\n```\\n\\n*Javascript: with memo*\\n```\\nlet minInsertions = (s, memo = [...Array(501)].map(x => Array(501).fill(-1))) => {\\n    let go = (s, i, j) => {\\n        if (memo[i][j] > -1)\\n            return memo[i][j];\\n        if (i >= j)\\n            return memo[i][j] = 0;\\n        if (s[i] == s[j])\\n            return memo[i][j] = go(s, i + 1, j - 1);\\n        return memo[i][j] = 1 + Math.min(go(s, i + 1, j), go(s, i, j - 1));\\n    };\\n    return go(s, 0, s.length - 1);\\n};\\n```\\n\\n*Javascript: with memo (refactored with a few less lines of code)*\\n```\\nlet minInsertions = (s, m = [...Array(501)].map(x => Array(501).fill(-1))) => {\\n    let go = (s, i, j) => {\\n        return m[i][j] =\\n            m[i][j] > -1 ? m[i][j] :\\n            i >= j ? 0 :\\n            s[i] == s[j] ? go(s, i + 1, j - 1) :\\n            1 + Math.min(go(s, i + 1, j), go(s, i, j - 1));\\n    };\\n    return go(s, 0, s.length - 1);\\n};\\n```\\n\\n**Javascript Solutions: DP Bottom-Up**\\n\\n*Javascript: full DP matrix (non-optimized for memory)*\\n```\\nlet minInsertions = (s, dp = [...Array(501)].map(x => Array(501).fill(0))) => {\\n    let N = s.length;\\n    for (let i = N - 1; i >= 0; --i)\\n        for (let j = i + 1; j <= N; ++j)\\n            if (s[i] == s[j - 1])\\n                dp[i][j] = dp[i + 1][j - 1];\\n            else\\n                dp[i][j] = 1 + Math.min(dp[i + 1][j], dp[i][j - 1]);\\n    return dp[0][N];\\n};\\n```\\n\\n*Javascript: pre/cur row (optimized for memory)*\\n```\\nlet minInsertions = (s, pre = [...Array(501)].fill(0), cur = [...Array(501)].fill(0)) => {\\n    let N = s.length;\\n    for (let i = N - 1; i >= 0; --i, [pre, cur] = [cur, pre])\\n        for (let j = i + 1; j <= N; ++j)\\n            if (s[i] == s[j - 1])\\n                cur[j] = pre[j - 1];\\n            else\\n                cur[j] = 1 + Math.min(pre[j], cur[j - 1]);\\n    return pre[N];\\n};\\n```\\n\\n*Javascript: pre/cur row (optimized for memory + more concise code)*\\n```\\nlet minInsertions = (s, pre = [...Array(501)].fill(0), cur = [...Array(501)].fill(0)) => {\\n    let N = s.length;\\n    for (let i = N - 1; i >= 0; --i, [pre, cur] = [cur, pre])\\n        for (let j = i + 1; j <= N; ++j)\\n                cur[j] = s[i] == s[j - 1] ? pre[j - 1] : 1 + Math.min(pre[j], cur[j - 1]);\\n    return pre[N];\\n};\\n```\\n\\n**C++ Solutions: Recursive Top-Down**\\n\\n*C++: TLE without memo*\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.size();\\n        return go(s, 0, n - 1);\\n    }\\nprivate:\\n    int go(const string& s, int i, int j) {\\n        if (i >= j)\\n            return 0;\\n        if (s[i] == s[j])\\n            return go(s, i + 1, j - 1);\\n        return 1 + min(go(s, i + 1, j), go(s, i, j - 1));\\n    }\\n};\\n```\\n\\n*C++: with memo*\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.size();\\n        return go(s, 0, n - 1);\\n    }\\nprivate:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    VVI memo = VVI(501, VI(501, -1));\\n    int go(const string& s, int i, int j) {\\n        if (memo[i][j] > -1)\\n            return memo[i][j];\\n        if (i >= j)\\n            return memo[i][j] = 0;\\n        if (s[i] == s[j])\\n            return memo[i][j] = go(s, i + 1, j - 1);\\n        return memo[i][j] = 1 + min(go(s, i + 1, j), go(s, i, j - 1));\\n    }\\n};\\n```\\n\\n*C++: with memo (refactored with a few less lines of code)*\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.size();\\n        return go(s, 0, n - 1);\\n    }\\nprivate:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    VVI m = VVI(501, VI(501, -1));\\n    int go(const string& s, int i, int j) {\\n        return m[i][j] =\\n            m[i][j] > -1 ? m[i][j] :\\n            i >= j ? 0 :\\n            s[i] == s[j] ? go(s, i + 1, j - 1) :\\n            1 + min(go(s, i + 1, j), go(s, i, j - 1));\\n    }\\n};\\n```\\n\\n**C++ Solutions: DP Bottom-Up**\\n\\n*C++: full DP matrix (non-optimized for memory)*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int minInsertions(string s, VVI dp = VVI(501, VI(501))) {\\n        int N = s.size();\\n        for (auto i = N - 1; i >= 0; --i)\\n            for (auto j = i + 1; j <= N; ++j)\\n                if (s[i] == s[j - 1])\\n                    dp[i][j] = dp[i + 1][j - 1];\\n                else\\n                    dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j - 1]);\\n        return dp[0][N];\\n    }\\n};\\n```\\n\\n*C++: pre/cur row (optimized for memory)*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int minInsertions(string s, VI pre = VI(501), VI cur = VI(501)) {\\n        int N = s.size();\\n        for (auto i = N - 1; i >= 0; --i, swap(pre, cur))\\n            for (auto j = i + 1; j <= N; ++j)\\n                if (s[i] == s[j - 1])\\n                    cur[j] = pre[j - 1];\\n                else\\n                    cur[j] = 1 + min(pre[j], cur[j - 1]);\\n        return pre[N];\\n    }\\n};\\n```\\n\\n*C++: pre/cur row (optimized for memory + more concise code)*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int minInsertions(string s, VI pre = VI(501), VI cur = VI(501)) {\\n        int N = s.size();\\n        for (auto i = N - 1; i >= 0; --i, swap(pre, cur))\\n            for (auto j = i + 1; j <= N; ++j)\\n                cur[j] = s[i] == s[j - 1] ? pre[j - 1] : 1 + min(pre[j], cur[j - 1]);\\n        return pre[N];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet minInsertions = s => {\\n    let go = (s, i, j) => {\\n        if (i >= j)\\n            return 0;\\n        if (s[i] == s[j])\\n            return go(s, i + 1, j - 1);\\n        return 1 + Math.min(go(s, i + 1, j), go(s, i, j - 1));\\n    };\\n    return go(s, 0, s.length - 1);\\n};\\n```\n```\\nlet minInsertions = (s, memo = [...Array(501)].map(x => Array(501).fill(-1))) => {\\n    let go = (s, i, j) => {\\n        if (memo[i][j] > -1)\\n            return memo[i][j];\\n        if (i >= j)\\n            return memo[i][j] = 0;\\n        if (s[i] == s[j])\\n            return memo[i][j] = go(s, i + 1, j - 1);\\n        return memo[i][j] = 1 + Math.min(go(s, i + 1, j), go(s, i, j - 1));\\n    };\\n    return go(s, 0, s.length - 1);\\n};\\n```\n```\\nlet minInsertions = (s, m = [...Array(501)].map(x => Array(501).fill(-1))) => {\\n    let go = (s, i, j) => {\\n        return m[i][j] =\\n            m[i][j] > -1 ? m[i][j] :\\n            i >= j ? 0 :\\n            s[i] == s[j] ? go(s, i + 1, j - 1) :\\n            1 + Math.min(go(s, i + 1, j), go(s, i, j - 1));\\n    };\\n    return go(s, 0, s.length - 1);\\n};\\n```\n```\\nlet minInsertions = (s, dp = [...Array(501)].map(x => Array(501).fill(0))) => {\\n    let N = s.length;\\n    for (let i = N - 1; i >= 0; --i)\\n        for (let j = i + 1; j <= N; ++j)\\n            if (s[i] == s[j - 1])\\n                dp[i][j] = dp[i + 1][j - 1];\\n            else\\n                dp[i][j] = 1 + Math.min(dp[i + 1][j], dp[i][j - 1]);\\n    return dp[0][N];\\n};\\n```\n```\\nlet minInsertions = (s, pre = [...Array(501)].fill(0), cur = [...Array(501)].fill(0)) => {\\n    let N = s.length;\\n    for (let i = N - 1; i >= 0; --i, [pre, cur] = [cur, pre])\\n        for (let j = i + 1; j <= N; ++j)\\n            if (s[i] == s[j - 1])\\n                cur[j] = pre[j - 1];\\n            else\\n                cur[j] = 1 + Math.min(pre[j], cur[j - 1]);\\n    return pre[N];\\n};\\n```\n```\\nlet minInsertions = (s, pre = [...Array(501)].fill(0), cur = [...Array(501)].fill(0)) => {\\n    let N = s.length;\\n    for (let i = N - 1; i >= 0; --i, [pre, cur] = [cur, pre])\\n        for (let j = i + 1; j <= N; ++j)\\n                cur[j] = s[i] == s[j - 1] ? pre[j - 1] : 1 + Math.min(pre[j], cur[j - 1]);\\n    return pre[N];\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.size();\\n        return go(s, 0, n - 1);\\n    }\\nprivate:\\n    int go(const string& s, int i, int j) {\\n        if (i >= j)\\n            return 0;\\n        if (s[i] == s[j])\\n            return go(s, i + 1, j - 1);\\n        return 1 + min(go(s, i + 1, j), go(s, i, j - 1));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.size();\\n        return go(s, 0, n - 1);\\n    }\\nprivate:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    VVI memo = VVI(501, VI(501, -1));\\n    int go(const string& s, int i, int j) {\\n        if (memo[i][j] > -1)\\n            return memo[i][j];\\n        if (i >= j)\\n            return memo[i][j] = 0;\\n        if (s[i] == s[j])\\n            return memo[i][j] = go(s, i + 1, j - 1);\\n        return memo[i][j] = 1 + min(go(s, i + 1, j), go(s, i, j - 1));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.size();\\n        return go(s, 0, n - 1);\\n    }\\nprivate:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    VVI m = VVI(501, VI(501, -1));\\n    int go(const string& s, int i, int j) {\\n        return m[i][j] =\\n            m[i][j] > -1 ? m[i][j] :\\n            i >= j ? 0 :\\n            s[i] == s[j] ? go(s, i + 1, j - 1) :\\n            1 + min(go(s, i + 1, j), go(s, i, j - 1));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int minInsertions(string s, VVI dp = VVI(501, VI(501))) {\\n        int N = s.size();\\n        for (auto i = N - 1; i >= 0; --i)\\n            for (auto j = i + 1; j <= N; ++j)\\n                if (s[i] == s[j - 1])\\n                    dp[i][j] = dp[i + 1][j - 1];\\n                else\\n                    dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j - 1]);\\n        return dp[0][N];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int minInsertions(string s, VI pre = VI(501), VI cur = VI(501)) {\\n        int N = s.size();\\n        for (auto i = N - 1; i >= 0; --i, swap(pre, cur))\\n            for (auto j = i + 1; j <= N; ++j)\\n                if (s[i] == s[j - 1])\\n                    cur[j] = pre[j - 1];\\n                else\\n                    cur[j] = 1 + min(pre[j], cur[j - 1]);\\n        return pre[N];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int minInsertions(string s, VI pre = VI(501), VI cur = VI(501)) {\\n        int N = s.size();\\n        for (auto i = N - 1; i >= 0; --i, swap(pre, cur))\\n            for (auto j = i + 1; j <= N; ++j)\\n                cur[j] = s[i] == s[j - 1] ? pre[j - 1] : 1 + min(pre[j], cur[j - 1]);\\n        return pre[N];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 471387,
                "title": "one-liner",
                "content": "```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    @lru_cache(None)\\n    def minInsertions(self, s):\\n        return(n:=len(s))and 1-(e:=s[0]==s[-1])+min(map(self.minInsertions,(s[e:-1],s[1:n-e])))\\n```",
                "solutionTags": [],
                "code": "```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    @lru_cache(None)\\n    def minInsertions(self, s):\\n        return(n:=len(s))and 1-(e:=s[0]==s[-1])+min(map(self.minInsertions,(s[e:-1],s[1:n-e])))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 470920,
                "title": "python-simple-recursive-dp-with-explanation",
                "content": "Define `dp(s)` as the minimum number of steps to make `s` palindrome.\\nWe\\'ll get the recursion below:\\n`dp(s) = 0 if s == s[::-1]`\\n`dp(s) = dp(s[1:-1]) if s[0] == s[-1]`\\n`dp(s) = 1 + min(dp(s[1:]), dp(s[:-1])) otherwise`\\n\\n\\n```python\\nfrom functools import lru_cache\\n\\n\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        @lru_cache(None)\\n        def dp(s):\\n            if s == s[::-1]:\\n                return 0\\n            elif s[0] == s[-1]:\\n                return dp(s[1:-1])\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn 1 + min(dp(s[1:]), dp(s[:-1]))\\n        \\n        return dp(s)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```python\\nfrom functools import lru_cache\\n\\n\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        @lru_cache(None)\\n        def dp(s):\\n            if s == s[::-1]:\\n                return 0\\n            elif s[0] == s[-1]:\\n                return dp(s[1:-1])\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn 1 + min(dp(s[1:]), dp(s[:-1]))\\n        \\n        return dp(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 470729,
                "title": "c-simple-recursive-dp-o-n-2",
                "content": "This hard problem, is not that hard if we try to establish the recurrence relation. \\nLet\\'s say we start comparing the characters of the string, from both the ends i.e. `i` as starting index of string as `0` and `j` as ending index of string as `n-1`, where `n` is the length of the string.\\nSo, the recurrence relation between the indices can be written as : \\n\\n```\\nif s[i] == s[j]\\n    DP(i, j) = DP(i + 1, j - 1)\\notherwise,\\n    DP(i, j) = 1 + min( DP(i + 1, j), DP(i, j - 1)) //Required to add a character, and see where addition gives minimum characters to insert\\n```\\nThen you can memoize the results in a matrix, for strings of large length. As here the sub-problems are overlapping. Or you can run an iterative DP length wise.\\n\\nTime complexity : `O(n^2)`, Space : `O(n^2)`\\n```\\nclass Solution {\\npublic:\\n    bool isPal(string s)\\n    {\\n        if(s.size() <= 1)\\n            return 1;\\n        for(int i = 0, j = s.size() - 1; i < j; i++,j--)\\n        {\\n            if(s[i] != s[j])\\n                return 0;\\n        }\\n        return 1;\\n    }\\n    vector<vector<int>> dp;\\n    int f(string &s, int i, int j)\\n    {\\n        if(i >= j)\\n            return 0;\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        if(s[i] == s[j])\\n        {\\n            dp[i][j] = f(s, i + 1, j - 1);   \\n        }\\n        else\\n            dp[i][j] = min(f(s, i , j - 1), f(s, i + 1, j)) + 1;\\n        \\n        return dp[i][j];\\n    }\\n    \\n    int minInsertions(string s) {\\n        if(isPal(s))\\n            return 0;\\n        int n = s.size();\\n        int i = 0, j = n - 1;\\n        dp = vector<vector<int>> (n, vector<int>(n, - 1));\\n        return f(s, i, j);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nif s[i] == s[j]\\n    DP(i, j) = DP(i + 1, j - 1)\\notherwise,\\n    DP(i, j) = 1 + min( DP(i + 1, j), DP(i, j - 1)) //Required to add a character, and see where addition gives minimum characters to insert\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPal(string s)\\n    {\\n        if(s.size() <= 1)\\n            return 1;\\n        for(int i = 0, j = s.size() - 1; i < j; i++,j--)\\n        {\\n            if(s[i] != s[j])\\n                return 0;\\n        }\\n        return 1;\\n    }\\n    vector<vector<int>> dp;\\n    int f(string &s, int i, int j)\\n    {\\n        if(i >= j)\\n            return 0;\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        if(s[i] == s[j])\\n        {\\n            dp[i][j] = f(s, i + 1, j - 1);   \\n        }\\n        else\\n            dp[i][j] = min(f(s, i , j - 1), f(s, i + 1, j)) + 1;\\n        \\n        return dp[i][j];\\n    }\\n    \\n    int minInsertions(string s) {\\n        if(isPal(s))\\n            return 0;\\n        int n = s.size();\\n        int i = 0, j = n - 1;\\n        dp = vector<vector<int>> (n, vector<int>(n, - 1));\\n        return f(s, i, j);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565030,
                "title": "c-dp-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,string &s,vector<vector<int>> &dp){\\n        if(i>=j)return 0;\\n        if(dp[i][j] != -1)return dp[i][j];\\n        if(s[i]==s[j]){\\n            return dp[i][j] = solve(i+1,j-1,s,dp);\\n        }else{\\n            return dp[i][j] = min({solve(i+1,j,s,dp),solve(i,j-1,s,dp)})+1;\\n        }\\n    }\\n    int minInsertions(string s) {\\n        int n = s.length();\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        return solve(0,n-1,s,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,string &s,vector<vector<int>> &dp){\\n        if(i>=j)return 0;\\n        if(dp[i][j] != -1)return dp[i][j];\\n        if(s[i]==s[j]){\\n            return dp[i][j] = solve(i+1,j-1,s,dp);\\n        }else{\\n            return dp[i][j] = min({solve(i+1,j,s,dp),solve(i,j-1,s,dp)})+1;\\n        }\\n    }\\n    int minInsertions(string s) {\\n        int n = s.length();\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        return solve(0,n-1,s,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444530,
                "title": "simple-solution-using-recursion-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n  //  min no.of insertions = total length- longest palindromic subsequence \\n\\n    public int minInsertions(String s) {\\n       \\n       Integer dp[][]=new Integer[s.length()][s.length()]; //memo\\n\\n       return s.length() - lps(s,rev(s),s.length()-1,s.length()-1,dp);\\n\\n    }\\n    int lps(String s1,String s2,int i,int j,Integer dp[][]){\\n\\n         if(i<0 || j<0)return 0; //base\\n\\n         if(dp[i][j]!=null)return dp[i][j];\\n\\n         if(s1.charAt(i)==s2.charAt(j)){         //if both characters of string and reversed string matches moe both pointers\\n             return dp[i][j]=1+lps(s1,s2,i-1,j-1,dp);\\n         }else{\\n             return dp[i][j]=Math.max(lps(s1,s2,i-1,j,dp),lps(s1,s2,i,j-1,dp)); //else check moving one pointer at a time \\n         }\\n    }\\n    String rev(String s){\\n        StringBuilder sb=new StringBuilder(s);\\n        sb.reverse();\\n        return sb.toString();\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n\\n  //  min no.of insertions = total length- longest palindromic subsequence \\n\\n    public int minInsertions(String s) {\\n       \\n       Integer dp[][]=new Integer[s.length()][s.length()]; //memo\\n\\n       return s.length() - lps(s,rev(s),s.length()-1,s.length()-1,dp);\\n\\n    }\\n    int lps(String s1,String s2,int i,int j,Integer dp[][]){\\n\\n         if(i<0 || j<0)return 0; //base\\n\\n         if(dp[i][j]!=null)return dp[i][j];\\n\\n         if(s1.charAt(i)==s2.charAt(j)){         //if both characters of string and reversed string matches moe both pointers\\n             return dp[i][j]=1+lps(s1,s2,i-1,j-1,dp);\\n         }else{\\n             return dp[i][j]=Math.max(lps(s1,s2,i-1,j,dp),lps(s1,s2,i,j-1,dp)); //else check moving one pointer at a time \\n         }\\n    }\\n    String rev(String s){\\n        StringBuilder sb=new StringBuilder(s);\\n        sb.reverse();\\n        return sb.toString();\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443346,
                "title": "rust-dp-short-and-concise-solution",
                "content": "# Intuition\\nSimple dynamic programming approach. The subtask is to solve it for substring of length `j` starting with index `i`.\\n`dp[i][j]` - the number of insersions to make palindrome from substring `s[i..=i+j]`.\\nEvery time you add one more character to substring you check if it\\'s the same as first character, if so, `dp[i][j] = dp[i - 2][j]`, otherwise, to make it palindrome you need to make one insersion to the beginning or the end, so `dp[i][j] = min(dp[i - 1][j], dp[i - 1][j + 1]) + 1`.\\n\\n# Code\\n```\\nuse std::cmp::min;\\n\\nimpl Solution {\\n    pub fn min_insertions(s: String) -> i32 {\\n        let chars: Vec<char> = s.chars().collect();\\n        let mut dp = vec![vec![0; chars.len()]; chars.len() + 1];\\n        for i in 2..chars.len() + 1 {\\n            for j in 0..chars.len() - i + 1 {\\n                if chars[j] == chars[j + i - 1] {\\n                    dp[i][j] = dp[i - 2][j + 1];\\n                } else {\\n                    dp[i][j] = min(dp[i - 1][j], dp[i - 1][j + 1]) + 1;\\n                }\\n            }\\n        }\\n\\n        return dp[chars.len()][0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::cmp::min;\\n\\nimpl Solution {\\n    pub fn min_insertions(s: String) -> i32 {\\n        let chars: Vec<char> = s.chars().collect();\\n        let mut dp = vec![vec![0; chars.len()]; chars.len() + 1];\\n        for i in 2..chars.len() + 1 {\\n            for j in 0..chars.len() - i + 1 {\\n                if chars[j] == chars[j + i - 1] {\\n                    dp[i][j] = dp[i - 2][j + 1];\\n                } else {\\n                    dp[i][j] = min(dp[i - 1][j], dp[i - 1][j + 1]) + 1;\\n                }\\n            }\\n        }\\n\\n        return dp[chars.len()][0];\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3442588,
                "title": "dp-time-o-m-n-space-o-n-c",
                "content": "````\\nclass Solution {\\npublic:\\n    int minInsertions(string s1) {\\n        int n = s1.length();\\n        vector<int> dp1(n+1,0),dp2(n+1,0);\\n        string s2 = s1;\\n        reverse(s1.begin(),s1.end());\\n        int i,j;\\n        for(i = 1; i <= n; i++){\\n            for(j = 1; j <= n; j++){\\n                if(s1[i-1]==s2[j-1]){\\n                    dp2[j] = dp1[j-1]+1;\\n                }else{\\n                    dp2[j] = max(dp1[j],dp2[j-1]);\\n                }\\n            }\\n            dp1 =  dp2;\\n        }\\n        return n-dp1[n];\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int minInsertions(string s1) {\\n        int n = s1.length();\\n        vector<int> dp1(n+1,0),dp2(n+1,0);\\n        string s2 = s1;\\n        reverse(s1.begin(),s1.end());\\n        int i,j;\\n        for(i = 1; i <= n; i++){\\n            for(j = 1; j <= n; j++){\\n                if(s1[i-1]==s2[j-1]){\\n                    dp2[j] = dp1[j-1]+1;\\n                }else{\\n                    dp2[j] = max(dp1[j],dp2[j-1]);\\n                }\\n            }\\n            dp1 =  dp2;\\n        }\\n        return n-dp1[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442533,
                "title": "python3-clean-solution-beats-100-with-proof",
                "content": "# Code\\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        if s == s[::-1]: return 0 \\n        n = len(s)\\n        dp = [[0] * n for _ in range(n)]\\n        for i in range(n-1,-1,-1):\\n            dp[i][i] = 1\\n            for j in range(i+1,n):\\n                if s[i] == s[j]:dp[i][j] = dp[i+1][j-1]+2\\n                else: dp[i][j] = max(dp[i+1][j], dp[i][j-1])\\n        return n-dp[0][n-1]\\n```\\n# Proof \\n![Screenshot 2023-04-22 at 8.55.23 AM.png](https://assets.leetcode.com/users/images/1e0f2718-936c-46b2-a3bb-4c05969dace8_1682134037.1165948.png)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        if s == s[::-1]: return 0 \\n        n = len(s)\\n        dp = [[0] * n for _ in range(n)]\\n        for i in range(n-1,-1,-1):\\n            dp[i][i] = 1\\n            for j in range(i+1,n):\\n                if s[i] == s[j]:dp[i][j] = dp[i+1][j-1]+2\\n                else: dp[i][j] = max(dp[i+1][j], dp[i][j-1])\\n        return n-dp[0][n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442412,
                "title": "java-dp-10-lines-clean-simple-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we figure out the longest palindromic subsequence as per [this leetcode problem](https://leetcode.com/problems/longest-palindromic-subsequence/description/), the answer to the current problem should be the length of the string - the length of the longest palindromic subsequence. The rationale is that we can simply add a matching character for each existing character that is not part of the longest palindromic subsequence and make the entire string a palindrome.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int minInsertions(String s) {\\n    var n = s.length();\\n    var dp = new int[n];\\n    var dpPrev = new int[n];\\n\\n    for (var i = n-1; i >= 0; i--) {\\n      dp[i] = 1;\\n\\n      for (var j = i+1; j < n; j++) {\\n        dp[j] =\\n          s.charAt(i) == s.charAt(j)\\n          ? 2 + dpPrev[j-1]\\n          : Math.max(dpPrev[j], dp[j-1]);        \\n      }\\n      dpPrev = dp.clone();\\n    }\\n    return n - dp[n-1];\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n  public int minInsertions(String s) {\\n    var n = s.length();\\n    var dp = new int[n];\\n    var dpPrev = new int[n];\\n\\n    for (var i = n-1; i >= 0; i--) {\\n      dp[i] = 1;\\n\\n      for (var j = i+1; j < n; j++) {\\n        dp[j] =\\n          s.charAt(i) == s.charAt(j)\\n          ? 2 + dpPrev[j-1]\\n          : Math.max(dpPrev[j], dp[j-1]);        \\n      }\\n      dpPrev = dp.clone();\\n    }\\n    return n - dp[n-1];\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442356,
                "title": "c-dynamic-programming-longest-palindromic-subsequence-longest-common-subsequence",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int lcs(string s,string b){\\n    int a=s.size();\\n    int m=b.size();\\n    int dp[a+1][m+1];\\n    for(int i=0;i<a+1;i++){\\n        for(int j=0;j<m+1;j++){\\n            if(i==0 || j==0)\\n            dp[i][j]=0;\\n        }\\n    }\\n    for(int i=1;i<a+1;i++){\\n        for(int j=1;j<m+1;j++){\\n            if(s[i-1]==b[j-1])\\n            dp[i][j]=1+dp[i-1][j-1];\\n            else\\n            dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n        }\\n    }\\n    return dp[a][m];\\n}\\n    int longestPalinSubseq(string A) {\\n        string s1=A;\\n        reverse(s1.begin(),s1.end());\\n        return lcs(A,s1);\\n    }\\n    int minInsertions(string s) {\\n        int a=s.length();\\n        int b=longestPalinSubseq(s);\\n        return a-b;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lcs(string s,string b){\\n    int a=s.size();\\n    int m=b.size();\\n    int dp[a+1][m+1];\\n    for(int i=0;i<a+1;i++){\\n        for(int j=0;j<m+1;j++){\\n            if(i==0 || j==0)\\n            dp[i][j]=0;\\n        }\\n    }\\n    for(int i=1;i<a+1;i++){\\n        for(int j=1;j<m+1;j++){\\n            if(s[i-1]==b[j-1])\\n            dp[i][j]=1+dp[i-1][j-1];\\n            else\\n            dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n        }\\n    }\\n    return dp[a][m];\\n}\\n    int longestPalinSubseq(string A) {\\n        string s1=A;\\n        reverse(s1.begin(),s1.end());\\n        return lcs(A,s1);\\n    }\\n    int minInsertions(string s) {\\n        int a=s.length();\\n        int b=longestPalinSubseq(s);\\n        return a-b;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146073,
                "title": "easy-java-solution-using-recursion-dynamic-programming",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int n= s.length();\\n        int[][] dp= new int[n+1][n+1];\\n        for(int[] temp: dp){\\n            Arrays.fill(temp, -1);\\n        }\\n        return getCount(s, 0, n-1, dp);\\n    }\\n\\n    public int getCount(String s, int left, int right, int[][] dp){\\n        if(dp[left][right] != -1){\\n            return dp[left][right];\\n        }\\n        if(left == right){\\n            return 0;\\n        }\\n        if(left+1 == right){\\n            if(s.charAt(left) == s.charAt(right)){\\n                return 0;\\n            }\\n            else{\\n                return 1;\\n            }\\n        }\\n        \\n        if(s.charAt(left) == s.charAt(right)){\\n            int ans= getCount(s, left+1, right-1, dp);\\n            dp[left][right]= ans;\\n            return ans;\\n        }\\n        else{\\n            int ans1= getCount(s, left, right-1, dp);\\n            int ans2= getCount(s, left+1, right, dp);\\n            dp[left][right]= Math.min(ans1, ans2)+1;\\n            return Math.min(ans1, ans2)+1;\\n        }\\n    }\\n}\\n```\\n\\n![please-upvote.jpg](https://assets.leetcode.com/users/images/4879be9f-a5ea-48fb-9b92-e07417255daf_1675598078.2915068.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int n= s.length();\\n        int[][] dp= new int[n+1][n+1];\\n        for(int[] temp: dp){\\n            Arrays.fill(temp, -1);\\n        }\\n        return getCount(s, 0, n-1, dp);\\n    }\\n\\n    public int getCount(String s, int left, int right, int[][] dp){\\n        if(dp[left][right] != -1){\\n            return dp[left][right];\\n        }\\n        if(left == right){\\n            return 0;\\n        }\\n        if(left+1 == right){\\n            if(s.charAt(left) == s.charAt(right)){\\n                return 0;\\n            }\\n            else{\\n                return 1;\\n            }\\n        }\\n        \\n        if(s.charAt(left) == s.charAt(right)){\\n            int ans= getCount(s, left+1, right-1, dp);\\n            dp[left][right]= ans;\\n            return ans;\\n        }\\n        else{\\n            int ans1= getCount(s, left, right-1, dp);\\n            int ans2= getCount(s, left+1, right, dp);\\n            dp[left][right]= Math.min(ans1, ans2)+1;\\n            return Math.min(ans1, ans2)+1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2377045,
                "title": "java-simple-explanation-code-with-detailed-comments",
                "content": "Simple Explanation of Bottom-up (Tabulation) approach\\n\\nhttps://www.youtube.com/watch?v=7UpPnWW9GJY\\n\\nFor more:-\\n**Telegram group** - https://t.me/+IK5-RpKtVWUxMDI1\\n**Telegram channel**- https://t.me/betterSoftEng\\n\\n```\\nclass LongestPalindromeInAStringSolution{\\n    static String longestPalin(String S){\\n        // code here\\n        if(S.length() == 0) return S;\\n        if(S.length() == 1) return S;\\n\\n        //Initializing longest Palindromic substring found so far with\\n        //first letter\\n        int maxLength = 1;\\n        int maxPalinStartIndex = 0;\\n        int maxPalinEndIndex = 0;\\n\\n        int i = 1;\\n        int n = S.length();\\n\\n        int j; int k;\\n\\n        int currentLength;\\n        int currentPalinStartIndex;\\n        int currentPalinEndIndex;\\n\\n        //No use of having last letter as centre. Because, max palindromic\\n        //substring from there can be of just length = 1.\\n\\n        //One iteration of this loop fixes a centre.\\n        for(i=0; i<n-1; i++) {\\n            //Centre length = 1\\n            //These two are pointers that will move - one to the left\\n            // one to the right.\\n            j=i-1;\\n            k=i+1;\\n\\n            //Below information will keep track of current palindrome we have\\n            currentLength = 1;\\n            currentPalinStartIndex = i;\\n            currentPalinEndIndex = i;\\n\\n            //While no index breaches boundary and we have equal characters\\n            while(j>=0 && k<n && S.charAt(j) == S.charAt(k)) {\\n                currentPalinStartIndex = j;\\n                currentPalinEndIndex = k;\\n                currentLength = currentLength + 2;\\n                j--;\\n                k++;\\n            }\\n\\n            if(currentLength > maxLength) {\\n                maxLength = currentLength;\\n                maxPalinStartIndex = currentPalinStartIndex;\\n                maxPalinEndIndex = currentPalinEndIndex;\\n            }\\n\\n            // If Centre length = 2 is possible\\n            if(S.charAt(i) == S.charAt(i+1)) {\\n                currentLength = 2;\\n                currentPalinStartIndex = i;\\n                currentPalinEndIndex = i+1;\\n\\n                j=i-1;\\n                k=i+2;\\n\\n                while(j>=0 && k<n && S.charAt(j) == S.charAt(k)) {\\n                    currentPalinStartIndex = j;\\n                    currentPalinEndIndex = k;\\n                    currentLength = currentLength + 2;\\n                    j--;\\n                    k++;\\n                }\\n\\n                if(currentLength > maxLength) {\\n                    maxLength = currentLength;\\n                    maxPalinStartIndex = currentPalinStartIndex;\\n                    maxPalinEndIndex = currentPalinEndIndex;\\n                }\\n            }\\n\\n        }\\n\\n        return S.substring(maxPalinStartIndex, maxPalinEndIndex+1);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass LongestPalindromeInAStringSolution{\\n    static String longestPalin(String S){\\n        // code here\\n        if(S.length() == 0) return S;\\n        if(S.length() == 1) return S;\\n\\n        //Initializing longest Palindromic substring found so far with\\n        //first letter\\n        int maxLength = 1;\\n        int maxPalinStartIndex = 0;\\n        int maxPalinEndIndex = 0;\\n\\n        int i = 1;\\n        int n = S.length();\\n\\n        int j; int k;\\n\\n        int currentLength;\\n        int currentPalinStartIndex;\\n        int currentPalinEndIndex;\\n\\n        //No use of having last letter as centre. Because, max palindromic\\n        //substring from there can be of just length = 1.\\n\\n        //One iteration of this loop fixes a centre.\\n        for(i=0; i<n-1; i++) {\\n            //Centre length = 1\\n            //These two are pointers that will move - one to the left\\n            // one to the right.\\n            j=i-1;\\n            k=i+1;\\n\\n            //Below information will keep track of current palindrome we have\\n            currentLength = 1;\\n            currentPalinStartIndex = i;\\n            currentPalinEndIndex = i;\\n\\n            //While no index breaches boundary and we have equal characters\\n            while(j>=0 && k<n && S.charAt(j) == S.charAt(k)) {\\n                currentPalinStartIndex = j;\\n                currentPalinEndIndex = k;\\n                currentLength = currentLength + 2;\\n                j--;\\n                k++;\\n            }\\n\\n            if(currentLength > maxLength) {\\n                maxLength = currentLength;\\n                maxPalinStartIndex = currentPalinStartIndex;\\n                maxPalinEndIndex = currentPalinEndIndex;\\n            }\\n\\n            // If Centre length = 2 is possible\\n            if(S.charAt(i) == S.charAt(i+1)) {\\n                currentLength = 2;\\n                currentPalinStartIndex = i;\\n                currentPalinEndIndex = i+1;\\n\\n                j=i-1;\\n                k=i+2;\\n\\n                while(j>=0 && k<n && S.charAt(j) == S.charAt(k)) {\\n                    currentPalinStartIndex = j;\\n                    currentPalinEndIndex = k;\\n                    currentLength = currentLength + 2;\\n                    j--;\\n                    k++;\\n                }\\n\\n                if(currentLength > maxLength) {\\n                    maxLength = currentLength;\\n                    maxPalinStartIndex = currentPalinStartIndex;\\n                    maxPalinEndIndex = currentPalinEndIndex;\\n                }\\n            }\\n\\n        }\\n\\n        return S.substring(maxPalinStartIndex, maxPalinEndIndex+1);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2364818,
                "title": "java-simple-explanation-code-with-detailed-comments",
                "content": "Simple explanation https://www.youtube.com/watch?v=IWV3wolx13k\\n\\nAbove video explains Recursion and Top-Down DP approach. Part 2 of the video will have Bottom up approach as well\\n\\nFor more:-\\n**Telegram group** - https://t.me/+IK5-RpKtVWUxMDI1\\n**Telegram channel** - https://t.me/betterSoftEng\\n\\n```\\nclass FormAPalindromeSolution{\\n    static int countMin(String str)\\n    {\\n        // code here\\n        int n = str.length();\\n\\n        //Each element of the matrix stores the result for substring from i to j\\n        int[][] matrix = new int[n][n];\\n\\n        //Gap indicates the length of the string for which we are filling the matrix\\n        //currently\\n        int gap;\\n\\n        //First we fill size 1 substrings\\n        //Then we fill size 2 substrings and so on.\\n        for(gap = 1; gap<=n; gap++) {\\n            fillMatrix(matrix, gap, str);\\n        }\\n\\n        return matrix[0][n-1];\\n    }\\n\\n    private static void fillMatrix(int[][] matrix, int gap, String s) {\\n\\n        int n = s.length();\\n        //To iterate over string to get a starting position\\n        int i;\\n        // j tracks end position\\n        int j;\\n        //If gap = 1 => all 1-length strings are already palindromes.\\n\\n        int resultLeft;\\n        int resultRight;\\n        int resultMid;\\n\\n        //For gap 1, i and j are same\\n        if(gap == 1) {\\n            for(i=0; i<=n-1; i++) {\\n                j = i;\\n                matrix[i][j] = 0;\\n            }\\n        }\\n\\n        if(gap == 2) {\\n            //Starting position shouldn\\'t reach last character\\n            for(i=0; i<n-1; i++) {\\n                //Since length = 2 => j = i+1\\n                j = i+1;\\n                if(s.charAt(i) == s.charAt(j)) {\\n                    matrix[i][j] = 0;\\n                } else {\\n                    matrix[i][j] = 1;\\n                }\\n            }\\n        }\\n        for(gap=3; gap<=n; gap++) {\\n            //Loop till Starting position i can reach\\n            for(i=0; i<=n-gap; i++) {\\n                //Calculate end position wrt i\\n                j = i+gap-1;\\n                //The result for substring except last character + 1\\n                resultLeft = matrix[i][j-1] + 1;\\n                // The result for substring except first character + 1\\n                resultRight = matrix[i+1][j] + 1;\\n\\n                if(s.charAt(i) == s.charAt(j)) {\\n                    //The result if first and last character are same, then\\n                    //how many insertions does it take to make the middle string\\n                    //palindrome\\n                    resultMid = matrix[i+1][j-1];\\n                    //Minimum of all 3\\n                    matrix[i][j] = Math.min(resultMid, Math.min(resultLeft, resultRight));\\n                } else {\\n                    matrix[i][j] = Math.min(resultLeft, resultRight);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass FormAPalindromeSolution{\\n    static int countMin(String str)\\n    {\\n        // code here\\n        int n = str.length();\\n\\n        //Each element of the matrix stores the result for substring from i to j\\n        int[][] matrix = new int[n][n];\\n\\n        //Gap indicates the length of the string for which we are filling the matrix\\n        //currently\\n        int gap;\\n\\n        //First we fill size 1 substrings\\n        //Then we fill size 2 substrings and so on.\\n        for(gap = 1; gap<=n; gap++) {\\n            fillMatrix(matrix, gap, str);\\n        }\\n\\n        return matrix[0][n-1];\\n    }\\n\\n    private static void fillMatrix(int[][] matrix, int gap, String s) {\\n\\n        int n = s.length();\\n        //To iterate over string to get a starting position\\n        int i;\\n        // j tracks end position\\n        int j;\\n        //If gap = 1 => all 1-length strings are already palindromes.\\n\\n        int resultLeft;\\n        int resultRight;\\n        int resultMid;\\n\\n        //For gap 1, i and j are same\\n        if(gap == 1) {\\n            for(i=0; i<=n-1; i++) {\\n                j = i;\\n                matrix[i][j] = 0;\\n            }\\n        }\\n\\n        if(gap == 2) {\\n            //Starting position shouldn\\'t reach last character\\n            for(i=0; i<n-1; i++) {\\n                //Since length = 2 => j = i+1\\n                j = i+1;\\n                if(s.charAt(i) == s.charAt(j)) {\\n                    matrix[i][j] = 0;\\n                } else {\\n                    matrix[i][j] = 1;\\n                }\\n            }\\n        }\\n        for(gap=3; gap<=n; gap++) {\\n            //Loop till Starting position i can reach\\n            for(i=0; i<=n-gap; i++) {\\n                //Calculate end position wrt i\\n                j = i+gap-1;\\n                //The result for substring except last character + 1\\n                resultLeft = matrix[i][j-1] + 1;\\n                // The result for substring except first character + 1\\n                resultRight = matrix[i+1][j] + 1;\\n\\n                if(s.charAt(i) == s.charAt(j)) {\\n                    //The result if first and last character are same, then\\n                    //how many insertions does it take to make the middle string\\n                    //palindrome\\n                    resultMid = matrix[i+1][j-1];\\n                    //Minimum of all 3\\n                    matrix[i][j] = Math.min(resultMid, Math.min(resultLeft, resultRight));\\n                } else {\\n                    matrix[i][j] = Math.min(resultLeft, resultRight);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2232835,
                "title": "c-java-python-easy-to-understand-o-n-2-time-and-o-n-space-bottom-up-dp",
                "content": "Minimum Insertion Steps to Make a String Palindrome = Length of string - Length of longest palindromic subsequence.  \\n\\nC++ implementation:\\n```\\nclass Solution {\\nprivate:\\n    int findLCS(string &s1, string &s2) {\\n        int n = s1.size();\\n        vector<int> dp(n + 1, 0);\\n        for(int i = 1; i <= n; ++i) {\\n            vector<int> current(n + 1, 0);\\n            for(int j = 1; j <= n; ++j) {\\n                // match\\n                if(s1[i - 1] == s2[j - 1])\\n                    current[j] = 1 + dp[j - 1];\\n                // not a match\\n                else \\n                    current[j] = max(dp[j], current[j - 1]);\\n            }\\n            dp = current;\\n        }\\n        return dp[n];\\n    }\\npublic:\\n    int minInsertions(string &s1) {\\n        string s2 = s1;\\n        reverse(s2.begin(), s2.end());\\n        return s1.size() - findLCS(s1, s2);\\n    }\\n};\\n```\\n\\nJava implementation:\\n\\n```\\nclass Solution {\\n    private int findLCS(String s, String reverse) {\\n        int n = s.length();\\n        int[] dp = new int[n + 1];\\n        for(int i = 1; i <= n; ++i) {\\n            int[] current = new int[n + 1];\\n            for(int j = 1; j <= n; ++j) {\\n                if(s.charAt(i - 1) == reverse.charAt(j - 1))\\n                    current[j] = 1 + dp[j - 1];\\n                else\\n                    current[j] = Math.max(dp[j], current[j - 1]);\\n            }\\n            dp = current;\\n        }\\n        return dp[n];\\n    }\\n    \\n    public int minInsertions(String s) {\\n        String reverse = new StringBuilder(s).reverse().toString();\\n        return s.length() - findLCS(s, reverse);\\n    }\\n}\\n```\\n\\nPython implementation:\\n\\n```\\nclass Solution:\\n    def findLCS(self, s: str, reverse: str) -> int:\\n        n = len(s)\\n        dp = [0] * (n + 1)\\n        for i in range(1, n + 1):\\n            current = [0] * (n + 1)\\n            for j in range(1, n + 1):\\n                # match\\n                if s[i - 1] == reverse[j - 1]:\\n                    current[j] = 1 + dp[j - 1]\\n                else:\\n                    current[j] = max(dp[j], current[j - 1])\\n            dp = current\\n        return dp[n]\\n    \\n    def minInsertions(self, s: str) -> int:\\n        # using slicing to reverse a string\\n        reverse = s[::-1]\\n        return len(s) - self.findLCS(s, reverse)\\n```\\n\\nTime complexity: O(n^2)\\nSpace-complexity: O(n)\\n\\n\\u23E9Thanks for reading! An upvote would be appreciated.  ^_^",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int findLCS(string &s1, string &s2) {\\n        int n = s1.size();\\n        vector<int> dp(n + 1, 0);\\n        for(int i = 1; i <= n; ++i) {\\n            vector<int> current(n + 1, 0);\\n            for(int j = 1; j <= n; ++j) {\\n                // match\\n                if(s1[i - 1] == s2[j - 1])\\n                    current[j] = 1 + dp[j - 1];\\n                // not a match\\n                else \\n                    current[j] = max(dp[j], current[j - 1]);\\n            }\\n            dp = current;\\n        }\\n        return dp[n];\\n    }\\npublic:\\n    int minInsertions(string &s1) {\\n        string s2 = s1;\\n        reverse(s2.begin(), s2.end());\\n        return s1.size() - findLCS(s1, s2);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    private int findLCS(String s, String reverse) {\\n        int n = s.length();\\n        int[] dp = new int[n + 1];\\n        for(int i = 1; i <= n; ++i) {\\n            int[] current = new int[n + 1];\\n            for(int j = 1; j <= n; ++j) {\\n                if(s.charAt(i - 1) == reverse.charAt(j - 1))\\n                    current[j] = 1 + dp[j - 1];\\n                else\\n                    current[j] = Math.max(dp[j], current[j - 1]);\\n            }\\n            dp = current;\\n        }\\n        return dp[n];\\n    }\\n    \\n    public int minInsertions(String s) {\\n        String reverse = new StringBuilder(s).reverse().toString();\\n        return s.length() - findLCS(s, reverse);\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def findLCS(self, s: str, reverse: str) -> int:\\n        n = len(s)\\n        dp = [0] * (n + 1)\\n        for i in range(1, n + 1):\\n            current = [0] * (n + 1)\\n            for j in range(1, n + 1):\\n                # match\\n                if s[i - 1] == reverse[j - 1]:\\n                    current[j] = 1 + dp[j - 1]\\n                else:\\n                    current[j] = max(dp[j], current[j - 1])\\n            dp = current\\n        return dp[n]\\n    \\n    def minInsertions(self, s: str) -> int:\\n        # using slicing to reverse a string\\n        reverse = s[::-1]\\n        return len(s) - self.findLCS(s, reverse)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1707123,
                "title": "java-brute-force-using-dp-if-anyone-knows-a-better-solution-please-share",
                "content": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int len = s.length();\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(s);\\n        sb.reverse();\\n        int [][] dp = new int[len+1][len+1];\\n        \\n        for(int i =0;i<len+1;i++){\\n            dp[i][0]=0;\\n        }\\n        for(int j =0;j<len+1;j++){\\n            dp[0][j]=0;\\n        }\\n        for(int i =1;i<len+1;i++){\\n            for(int j=1;j<len+1;j++){\\n                if(s.charAt(i-1)==sb.charAt(j-1))\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                else\\n                    dp[i][j] =Math.max(dp[i-1][j], dp[i][j-1]);\\n            }\\n        }\\n        return len-dp[len][len];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int len = s.length();\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(s);\\n        sb.reverse();\\n        int [][] dp = new int[len+1][len+1];\\n        \\n        for(int i =0;i<len+1;i++){\\n            dp[i][0]=0;\\n        }\\n        for(int j =0;j<len+1;j++){\\n            dp[0][j]=0;\\n        }\\n        for(int i =1;i<len+1;i++){\\n            for(int j=1;j<len+1;j++){\\n                if(s.charAt(i-1)==sb.charAt(j-1))\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                else\\n                    dp[i][j] =Math.max(dp[i-1][j], dp[i][j-1]);\\n            }\\n        }\\n        return len-dp[len][len];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1464302,
                "title": "why-won-t-the-frequency-of-letters-work-why-will-lcs-work",
                "content": "```\\ndef minInsertions(self, s: str) -> int:\\n        if s == s[::-1] or len(s)==1:\\n            return 0\\n        t = s[::-1]\\n        dp = [[0]*(len(s)+1) for _ in range(len(t)+1)]\\n        for i in range(1,len(s)+1):\\n            for j in range(1,len(t)+1):\\n                if s[i-1]==t[j-1]:\\n                    dp[i][j] = 1+dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = max(dp[i-1][j],dp[i][j-1])\\n        # print(dp)\\n        return len(s)-dp[-1][-1]\\n```\\nAs a noob the first solution that came to my mind was counting the frequency of letters as the minimum requirement to have a string as palindrome is every letter should have even frequency except one. One letter is allowed to have an odd frequency. \\nex: **MEMEM**\\nIt is a palindrome with E : 2 and M:3. \\n Now why wont the capturing of just freq won\\'t work? \\n It is because in this question we are concerned with the positioning of the letters as well while in freqency capturing technique, we are concerned with any permutation of string which would turn into a plindrome by least insertions.\\n EX:\\n Lets see a string : \"ZJVEIIWVC\"\\n the freq table will look like this: \\n {\\n Z:1,\\n E:1\\n J:1,\\n V:2\\n I:2\\n W:1\\n C:1\\n }\\n So if we just choose any 4 letters among (E,Z,J,W,C) our minimum insertion will be 4 but only one of the permutation of resultant string will be palindrome. \\nResultant string can be : Z E W C V I J I V C W E Z\\n\\nBut with LCS we can find the least insertion we need to do to make the given string a palindrome and not any of its permutations.\\n\\n**Thanks and Please do let me know if you need any further clarifications**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef minInsertions(self, s: str) -> int:\\n        if s == s[::-1] or len(s)==1:\\n            return 0\\n        t = s[::-1]\\n        dp = [[0]*(len(s)+1) for _ in range(len(t)+1)]\\n        for i in range(1,len(s)+1):\\n            for j in range(1,len(t)+1):\\n                if s[i-1]==t[j-1]:\\n                    dp[i][j] = 1+dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = max(dp[i-1][j],dp[i][j-1])\\n        # print(dp)\\n        return len(s)-dp[-1][-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 984918,
                "title": "c-dp-heavy-comments-on-each-line",
                "content": "```\\nclass Solution {\\npublic:\\n    // Before reading this, I would highly recommend to take a rought notebook and draw the flow chart of these recursive calls, change the variables values and check for yourself on how all these recursive values are adding up finally and what value is actually getting returned.\\n// It would be a little tedious process but it will help u in Visualising the recursion tree.\\n// Solve this code for \"mbadm\"\\n    int minInsert(string& s,int i,int j,vector<vector<int>>& dp) {\\n        if(i>=j) { // base case\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1) { // if we have the value already calculated , just return that value\\n            return dp[i][j];\\n        }\\n        if(s[i]==s[j]) { \\n            dp[i][j]=minInsert(s,i+1,j-1,dp); // call recursion by decreasing j and increasing i and save the result of dp[i][j] which will be calculated recursively\\n            return dp[i][j]; // return the result that we got above \\n        }\\n        // Now if the chars at s[i] and s[j] are not same/palindrome, NOW WE HAVE 2 DECISION, EITHER ADD A CHARACTER ON THE LEFT SIDE(i pointer) OR ADD A CHARCTER on the RIGHT SIDE(j pointer)\\n        int dec1=minInsert(s,i+1,j,dp)+1; // ADDING ONE CHAR ON THE LEFT AND INCREMENT THE DECISION+1 AND calling recursively ON i+1 and j\\n        int dec2=minInsert(s,i,j-1,dp)+1; //ADDING ONE CHAR ON THE RIGHT AND INCREMENT THE DECISION+1 AND calling recursively ON i and j+1\\n        dp[i][j]=min(dec1,dec2); // SAVING THE MINIMUM OF THE 2 DECISION ON dp[i][j]\\n        return min(dec1,dec2); // RETURNING THE MINIMUM DECISION THAT WE GOT\\n    } \\n    int minInsertions(string s) {\\n        int len=s.length(); // calculating length\\n        vector<vector<int>>dp(len,vector<int>(len,-1)); // creating 2d vector of size len*len and filling with -1\\n        return minInsert(s,0,len-1,dp); // calling recursively \\n    }\\n};\\n```\\n\\n`TC will be O(len*len) since we are filling the dp[][] table which is of size len*len`",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Before reading this, I would highly recommend to take a rought notebook and draw the flow chart of these recursive calls, change the variables values and check for yourself on how all these recursive values are adding up finally and what value is actually getting returned.\\n// It would be a little tedious process but it will help u in Visualising the recursion tree.\\n// Solve this code for \"mbadm\"\\n    int minInsert(string& s,int i,int j,vector<vector<int>>& dp) {\\n        if(i>=j) { // base case\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1) { // if we have the value already calculated , just return that value\\n            return dp[i][j];\\n        }\\n        if(s[i]==s[j]) { \\n            dp[i][j]=minInsert(s,i+1,j-1,dp); // call recursion by decreasing j and increasing i and save the result of dp[i][j] which will be calculated recursively\\n            return dp[i][j]; // return the result that we got above \\n        }\\n        // Now if the chars at s[i] and s[j] are not same/palindrome, NOW WE HAVE 2 DECISION, EITHER ADD A CHARACTER ON THE LEFT SIDE(i pointer) OR ADD A CHARCTER on the RIGHT SIDE(j pointer)\\n        int dec1=minInsert(s,i+1,j,dp)+1; // ADDING ONE CHAR ON THE LEFT AND INCREMENT THE DECISION+1 AND calling recursively ON i+1 and j\\n        int dec2=minInsert(s,i,j-1,dp)+1; //ADDING ONE CHAR ON THE RIGHT AND INCREMENT THE DECISION+1 AND calling recursively ON i and j+1\\n        dp[i][j]=min(dec1,dec2); // SAVING THE MINIMUM OF THE 2 DECISION ON dp[i][j]\\n        return min(dec1,dec2); // RETURNING THE MINIMUM DECISION THAT WE GOT\\n    } \\n    int minInsertions(string s) {\\n        int len=s.length(); // calculating length\\n        vector<vector<int>>dp(len,vector<int>(len,-1)); // creating 2d vector of size len*len and filling with -1\\n        return minInsert(s,0,len-1,dp); // calling recursively \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 624034,
                "title": "java-easy-solution-using-longest-common-subsequence",
                "content": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        StringBuilder S = new StringBuilder();\\n        S.append(s);\\n        return S.length() - longestCommonSubsequence(s, S.reverse().toString());\\n    }\\n    public int longestCommonSubsequence(String text1, String text2) {\\n        int m = text1.length(), n = text2.length();\\n        int[][] dp = new int[m + 1][n + 1];\\n        for(int i = 1; i <= m; i++)\\n            for(int j = 1; j <= n; j++)\\n                if(text1.charAt(i-1) == text2.charAt(j-1)) dp[i][j] = dp[i-1][j-1] + 1;\\n                else dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\\n        return dp[m][n];\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int minInsertions(String s) {\\n        StringBuilder S = new StringBuilder();\\n        S.append(s);\\n        return S.length() - longestCommonSubsequence(s, S.reverse().toString());\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3697385,
                "title": "java-dp-tabulation",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        String s2 = new StringBuilder(s).reverse().toString();\\n        int n = s.length();\\n        int[][] dp = new int[n+1][n+1];\\n\\n        for(int i = 1; i <= n; i++) {\\n            for(int j = 1; j <= n; j++) {\\n                if(s.charAt(i-1) == s2.charAt(j-1)) dp[i][j] = 1 + dp[i-1][j-1];\\n                else dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\\n            }\\n        }\\n        return n - dp[n][n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        String s2 = new StringBuilder(s).reverse().toString();\\n        int n = s.length();\\n        int[][] dp = new int[n+1][n+1];\\n\\n        for(int i = 1; i <= n; i++) {\\n            for(int j = 1; j <= n; j++) {\\n                if(s.charAt(i-1) == s2.charAt(j-1)) dp[i][j] = 1 + dp[i-1][j-1];\\n                else dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\\n            }\\n        }\\n        return n - dp[n][n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551295,
                "title": "c-memoization-approach-without-using-lcs",
                "content": "Solution without using reverse of the string\\n```\\nclass Solution {\\npublic:\\n\\n     int helper(string &s, int i, int j, vector<vector<int>> & dp){\\n         if(i>j)return 0;\\n         if(i==j)return 0;\\n         if(dp[i][j]!=-1)return dp[i][j];\\n         if(s[i-1]==s[j-1]){\\n             return dp[i][j]=helper(s, i+1, j-1,dp);\\n         }\\n         else{\\n             return dp[i][j]=min(1+helper(s,i+1, j,dp), 1+helper(s, i, j-1, dp));\\n         }\\n    }\\n\\n    int minInsertions(string s) {\\n        int n=s.size();\\n        vector<vector<int>> dp(n+1, vector<int>(n+1, 0));\\n        return helper(s, 1, n, dp);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n     int helper(string &s, int i, int j, vector<vector<int>> & dp){\\n         if(i>j)return 0;\\n         if(i==j)return 0;\\n         if(dp[i][j]!=-1)return dp[i][j];\\n         if(s[i-1]==s[j-1]){\\n             return dp[i][j]=helper(s, i+1, j-1,dp);\\n         }\\n         else{\\n             return dp[i][j]=min(1+helper(s,i+1, j,dp), 1+helper(s, i, j-1, dp));\\n         }\\n    }\\n\\n    int minInsertions(string s) {\\n        int n=s.size();\\n        vector<vector<int>> dp(n+1, vector<int>(n+1, 0));\\n        return helper(s, 1, n, dp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452874,
                "title": "without-knowing-lcs",
                "content": "# Intuition\\nStarted thougth process from checking palindrome.\\n\\n# Approach\\n- Approached from checking palindrome.\\n- Added base condition.\\n- Checked if character are same or not.\\n- If not I just take the minimum of moving from both the ends.\\n\\nAnalyzed all the possibilities came up with ```recursion``` solution, than converted recursion to ```memoization```.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n\\n- Space complexity:$$O(n^2)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int solve(string &s, int i, int j){\\n        if(i>=j)\\n            return 0;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        if(s[i]==s[j])\\n            return dp[i][j]=solve(s, i+1, j-1);\\n        else\\n            return dp[i][j]=1+min(solve(s, i+1, j), solve(s, i, j-1));\\n        return dp[i][j]=0;\\n    }\\n    int minInsertions(string s) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(s, 0, s.length()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```recursion```\n```memoization```\n```\\nclass Solution {\\npublic:\\n    int dp[501][501];\\n    int solve(string &s, int i, int j){\\n        if(i>=j)\\n            return 0;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        if(s[i]==s[j])\\n            return dp[i][j]=solve(s, i+1, j-1);\\n        else\\n            return dp[i][j]=1+min(solve(s, i+1, j), solve(s, i, j-1));\\n        return dp[i][j]=0;\\n    }\\n    int minInsertions(string s) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(s, 0, s.length()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446702,
                "title": "java-dp-well-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first intuition was that the no. of insertions needed to make the string palindromic would be **same as the no. of deletions** required to make the string palindromic. suppose we have the string ***abbca***. \\n\\nEither we can add c to make it palindromic ***acbbca*** or we can remove c to make it palindromic ***abba***.\\n\\nNow the question has reduced to [Find the Longest Palindromic subsequence](https://leetcode.com/problems/longest-palindromic-subsequence/description/). Then subtract the length of LPS from the actual length of the string.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn the above example :\\n- length of the LPS -> ***abba*** = 4\\n- length of the actual string ***abbca*** = 5\\n- ans -> 5 - 4 = 1\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nwe are iterating the string n times for each character. So the time complexity would be $$O(n^2)$$.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe are using 2D array for DP. So the space complexity is $$O(n^2)$$.\\nIt can further be reduced to $$O(n)$$ as for a particular moment we are just using the above row to make use to DP. We just need to rows instead of the whole DP array. *For the sake for simplicity I have used 2D array (you can try and further optimise it to $$O(n)$$).*\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int solve(String s) {\\n        int[][] dp = new int[s.length() + 1][s.length() + 1];\\n        String sr = (new StringBuilder(s)).reverse().toString();\\n\\n        for(int i = 1; i <= s.length(); i++) {\\n            for(int j = 1; j <= s.length(); j++) {\\n                char a = s.charAt(i - 1);\\n                char b = sr.charAt(j - 1);\\n                if(a == b) {\\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\\n                } else {\\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\\n                }\\n            }\\n        }\\n        return dp[s.length()][s.length()];\\n    }\\n\\n    public int minInsertions(String s) {\\n        return s.length() - solve(s);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int solve(String s) {\\n        int[][] dp = new int[s.length() + 1][s.length() + 1];\\n        String sr = (new StringBuilder(s)).reverse().toString();\\n\\n        for(int i = 1; i <= s.length(); i++) {\\n            for(int j = 1; j <= s.length(); j++) {\\n                char a = s.charAt(i - 1);\\n                char b = sr.charAt(j - 1);\\n                if(a == b) {\\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\\n                } else {\\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\\n                }\\n            }\\n        }\\n        return dp[s.length()][s.length()];\\n    }\\n\\n    public int minInsertions(String s) {\\n        return s.length() - solve(s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444319,
                "title": "best-c-solution-dp-2-approach-memorization-vs-tabulation",
                "content": "\\n\\n# Code\\n```\\n#define vi vector<int>\\n#define vvi vector<vi>\\n\\nclass Solution {\\npublic:\\n    int solveMem(string& a, string& b, int i, int j, vvi& dp)   {\\n        if(i == a.length() || j == b.length())  return 0;\\n        if(dp[i][j] != -1)  return dp[i][j];\\n        if(a[i] == b[j])    dp[i][j] = 1 + solveMem(a, b, i+1, j+1, dp);\\n        else    dp[i][j] = max(solveMem(a, b, i+1, j, dp), solveMem(a, b, i, j+1, dp));\\n        return dp[i][j];\\n    }\\n\\n    int solveTab(string& a, string& b)  {\\n        vvi dp(a.length() + 1, vi(a.length() + 1, 0));\\n        \\n        for(int i=a.length()-1; i>=0; i--)  {\\n            for(int j=b.length()-1; j>=0; j--)  {\\n                if(a[i] == b[j])    dp[i][j] = 1 + dp[i+1][j+1];\\n                else    dp[i][j] = max(dp[i+1][j], dp[i][j+1]);\\n            }\\n        }\\n\\n        return dp[0][0];\\n    }\\n\\n\\n    int minInsertions(string s) {\\n        string rev = s;\\n        reverse(rev.begin(), rev.end());\\n        vvi dp(s.length(), vi(s.length(), -1));\\n        return s.length() - solveMem(s, rev, 0, 0, dp);\\n\\n        // return s.length() - solveTab(s, rev);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define vi vector<int>\\n#define vvi vector<vi>\\n\\nclass Solution {\\npublic:\\n    int solveMem(string& a, string& b, int i, int j, vvi& dp)   {\\n        if(i == a.length() || j == b.length())  return 0;\\n        if(dp[i][j] != -1)  return dp[i][j];\\n        if(a[i] == b[j])    dp[i][j] = 1 + solveMem(a, b, i+1, j+1, dp);\\n        else    dp[i][j] = max(solveMem(a, b, i+1, j, dp), solveMem(a, b, i, j+1, dp));\\n        return dp[i][j];\\n    }\\n\\n    int solveTab(string& a, string& b)  {\\n        vvi dp(a.length() + 1, vi(a.length() + 1, 0));\\n        \\n        for(int i=a.length()-1; i>=0; i--)  {\\n            for(int j=b.length()-1; j>=0; j--)  {\\n                if(a[i] == b[j])    dp[i][j] = 1 + dp[i+1][j+1];\\n                else    dp[i][j] = max(dp[i+1][j], dp[i][j+1]);\\n            }\\n        }\\n\\n        return dp[0][0];\\n    }\\n\\n\\n    int minInsertions(string s) {\\n        string rev = s;\\n        reverse(rev.begin(), rev.end());\\n        vvi dp(s.length(), vi(s.length(), -1));\\n        return s.length() - solveMem(s, rev, 0, 0, dp);\\n\\n        // return s.length() - solveTab(s, rev);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444177,
                "title": "recursion-memoization-dp-with-explanations-using-go",
                "content": "# Intuition\\nDivide the problem into sub problems.\\nfor a string s with length n, \\n- if s[0]==s[n-1], then f(s) = f(s[1:n-1]) \\n- else, f(s) = 1+min(f(s[1:n]), f(s(:n-1)))\\n\\nSo we can use recursion to solve this problem\\n\\n# Approach\\nRecursion\\n\\n# Complexity\\n- Time complexity:\\nO(2^N) for the worst situation\\n\\n- Space complexity:\\nO(Recursion\\'s depth) = O(N)\\n\\n# Code\\n```\\nfunc minInsertions(s string) int {\\n    n := len(s)\\n    if n <= 1 {return 0}\\n    if s[0]==s[n-1] {return minInsertions(s[1:n-1])}\\n    return 1+min2(minInsertions(s[1:]), minInsertions(s[:n-1]))\\n}\\nfunc min2(a, b int) int {if a < b {return a} else {return b}}\\n```\\n\\n# Improve with memorization\\nAs we can see, recursion\\'s time complexity is O(2^N), a lot of same sub problems are repeatedly computed. \\ne.g. for the following equation,\\n- else, f(s) = 1+min(f(s[1:n]), f(s(:n-1)))\\n\\nwe can conclude that f(s[1:n-1]) would be computed in both f(s[1:n]) and f(s[:n-1]), so f(s[1:n-1]) is repeatedly computed. And the same situation for every f(s[i:j]) when i>=1 and j<=n-1 and i<j.\\n\\nWe can use two variables (l, r) to mark one specific sub problem. Imagine function `f` is what we want, `f(0, n-1)` denotes the original problem. In this way, we need compute every sub problem, which is `f(i, j), for every i<j pair`.\\n\\nMoreover, use some way to store every sub problem\\'s result to avoid repeated computing. This is of vital importance to understand further improvements.\\n\\nSo what we use and how we use it to store every sub problem\\'s result?\\nThe answer is easy, use the easiest data structure, which is array. Use the\\n2D array, dp[i][j] to denote the answer of sub problem `f(i,j)`, which means the answer of f(s[i:j])\\n```\\nfunc minInsertions(s string) int {\\n    n := len(s)\\n    dp := make([][]int, n)\\n    for i:=0; i<n; i++ {\\n        dp[i] = make([]int, n)\\n        for j:=0; j<n; j++ {dp[i][j] = -1}\\n    }\\n\\n    var helper func(int, int) int\\n    helper = func(l, r int) int {\\n        if r-l<=0 {return 0}\\n        if dp[l][r] > -1 {return dp[l][r]}\\n        if s[l] == s[r] {\\n            dp[l+1][r-1] = helper(l+1, r-1)\\n            dp[l][r] = dp[l+1][r-1]\\n            return dp[l][r]\\n        }\\n        dp[l][r] = 1 + min2(helper(l+1, r), helper(l, r-1))\\n        return dp[l][r]\\n    }\\n    return helper(0, n-1)\\n}\\n\\nfunc min2(a, b int) int {if a < b {return a} else {return b}}\\n```\\n\\nAt last, we already understand how to use the memoization to solve this\\nproblem, we can simplify it one step further.\\n\\nWe use the bottom-up way, which can help we avoid using recursion.\\n\\n```\\nfunc minInsertions(s string) int {\\n    n := len(s)\\n    dp := make([][]int, n)\\n    for i:=0; i<n; i++ {dp[i] = make([]int, n)}\\n\\n    for d:=1; d<n; d++ {  // d means distance\\n        for i:=0; i+d<n; i++ {\\n            if s[i]==s[i+d] {\\n                dp[i][i+d] = dp[i+1][i+d-1]\\n            } else {\\n                dp[i][i+d] = 1 + min2(dp[i][i+d-1], dp[i+1][i+d])\\n            }\\n        }\\n    }\\n    return dp[0][n-1]\\n}\\nfunc min2(a, b int) int {if a < b {return a} else {return b}}\\n```\\nWe need pay attention to lots of details here. e.g. dp[i][i] is always equal to 0, because dp[i][i] means the ith character of s, and for one character, it is palindrome itself, so dp[i][i] = 0",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nfunc minInsertions(s string) int {\\n    n := len(s)\\n    if n <= 1 {return 0}\\n    if s[0]==s[n-1] {return minInsertions(s[1:n-1])}\\n    return 1+min2(minInsertions(s[1:]), minInsertions(s[:n-1]))\\n}\\nfunc min2(a, b int) int {if a < b {return a} else {return b}}\\n```\n```\\nfunc minInsertions(s string) int {\\n    n := len(s)\\n    dp := make([][]int, n)\\n    for i:=0; i<n; i++ {\\n        dp[i] = make([]int, n)\\n        for j:=0; j<n; j++ {dp[i][j] = -1}\\n    }\\n\\n    var helper func(int, int) int\\n    helper = func(l, r int) int {\\n        if r-l<=0 {return 0}\\n        if dp[l][r] > -1 {return dp[l][r]}\\n        if s[l] == s[r] {\\n            dp[l+1][r-1] = helper(l+1, r-1)\\n            dp[l][r] = dp[l+1][r-1]\\n            return dp[l][r]\\n        }\\n        dp[l][r] = 1 + min2(helper(l+1, r), helper(l, r-1))\\n        return dp[l][r]\\n    }\\n    return helper(0, n-1)\\n}\\n\\nfunc min2(a, b int) int {if a < b {return a} else {return b}}\\n```\n```\\nfunc minInsertions(s string) int {\\n    n := len(s)\\n    dp := make([][]int, n)\\n    for i:=0; i<n; i++ {dp[i] = make([]int, n)}\\n\\n    for d:=1; d<n; d++ {  // d means distance\\n        for i:=0; i+d<n; i++ {\\n            if s[i]==s[i+d] {\\n                dp[i][i+d] = dp[i+1][i+d-1]\\n            } else {\\n                dp[i][i+d] = 1 + min2(dp[i][i+d-1], dp[i+1][i+d])\\n            }\\n        }\\n    }\\n    return dp[0][n-1]\\n}\\nfunc min2(a, b int) int {if a < b {return a} else {return b}}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3444140,
                "title": "solution-using-dp",
                "content": "# Intuition\\nTo solve this problem, we can use dynamic programming (DP). We define dp[i][j] as the minimum number of insertions needed to make the substring s[i...j] a palindrome.\\n\\n# Approach\\nWe can observe that if the characters s[i] and s[j] are the same, then we don\\'t need to do anything and we can just consider the substring s[i+1...j-1]. Otherwise, we have two options:\\n\\n1. Insert the character s[j] at the end of the substring s[i...j-1], and consider the substring s[i...j-2] for the next step.\\n2. Insert the character s[i] at the beginning of the substring s[i+1...j], and consider the substring s[i+1...j-1] for the next step.\\nWe can compute the dp values using bottom-up DP. The base case is when i=j, which means that the substring is already a palindrome and we don\\'t need any insertions.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.length();\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n        for (int len = 2; len <= n; len++) {\\n            for (int i = 0; i < n - len + 1; i++) {\\n                int j = i + len - 1;\\n                if (s[i] == s[j]) {\\n                    dp[i][j] = dp[i+1][j-1];\\n                } else {\\n                    dp[i][j] = min(dp[i+1][j], dp[i][j-1]) + 1;\\n                }\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.length();\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n        for (int len = 2; len <= n; len++) {\\n            for (int i = 0; i < n - len + 1; i++) {\\n                int j = i + len - 1;\\n                if (s[i] == s[j]) {\\n                    dp[i][j] = dp[i+1][j-1];\\n                } else {\\n                    dp[i][j] = min(dp[i+1][j], dp[i][j-1]) + 1;\\n                }\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443466,
                "title": "tle-dp-approach-using-two-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLet\\'s say s=\"abscsdfa\". The longest palindromic subsequence in this string is \"ascsa\". So, the number of insertions required is `8 - 5 = 3`.\\n\\nSo we will first find longest palindromic subsequence and then will subtract from total length of string to get the desired answer.\\n\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Recursive Solution -- Got TLE\\n```\\nclass Solution {\\n    int dfs(string &s, int i, int j){\\n        if (i>j) \\n            return 0;\\n        if (i==j)\\n            return 1;\\n\\n        if (s[i]==s[j]){\\n            return 2 + dfs(s, i+1, j-1);\\n        }\\n        return max( dfs(s, i+1, j) , dfs(s, i, j-1) );\\n    }\\n\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.length();\\n        return n - dfs(s, 0, n-1);\\n    }\\n};\\n```\\n.\\n.\\n# Recursive Solution -- With DP\\n```C++ []\\nclass Solution {\\n    vector<vector<int>> dp;\\n    int dfs(string &s, int i, int j){\\n        if (i>j) \\n            return 0;\\n        if (i==j)\\n            return 1;\\n        \\n        if (dp[i][j]^-1)  return dp[i][j];\\n\\n        if (s[i]==s[j]){\\n            return dp[i][j] = 2 + dfs(s, i+1, j-1);\\n        }\\n        return dp[i][j] = max( dfs(s, i+1, j) , dfs(s, i, j-1) );\\n    }\\n\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.length();\\n        dp.resize(n+1, vector<int> (n+1,-1));\\n        return n - dfs(s, 0, n-1);\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(string &s, int i, int j){\\n        if (i>j) \\n            return 0;\\n        if (i==j)\\n            return 1;\\n\\n        if (s[i]==s[j]){\\n            return 2 + dfs(s, i+1, j-1);\\n        }\\n        return max( dfs(s, i+1, j) , dfs(s, i, j-1) );\\n    }\\n\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.length();\\n        return n - dfs(s, 0, n-1);\\n    }\\n};\\n```\n```C++ []\\nclass Solution {\\n    vector<vector<int>> dp;\\n    int dfs(string &s, int i, int j){\\n        if (i>j) \\n            return 0;\\n        if (i==j)\\n            return 1;\\n        \\n        if (dp[i][j]^-1)  return dp[i][j];\\n\\n        if (s[i]==s[j]){\\n            return dp[i][j] = 2 + dfs(s, i+1, j-1);\\n        }\\n        return dp[i][j] = max( dfs(s, i+1, j) , dfs(s, i, j-1) );\\n    }\\n\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.length();\\n        dp.resize(n+1, vector<int> (n+1,-1));\\n        return n - dfs(s, 0, n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443127,
                "title": "typescript-top-down-dynamic-programming-detailed-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA Palindrome string is one that reads the same forward and backward. One way to determine if a string is palindromic is by using a **two-pointer algorithm**. In this case, we use two pointers, one at the start of the string and the other at the end of the string, and then we start comparing the characters at both pointers as we move the pointers.\\n\\nWe can use this same idea to determine the number of insertions required to make a string a palindrome.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOur approach involves using two pointers, one on the first index `[i]` and the other on the last index `[j]`. We move the pointers based on the following rules:\\n\\n- If the characters at both pointers are the same (i.e `s[i] === s[j]`), we move both pointers forward `(i++, j--)`, and no insertion operation is necessary.\\n- If the characters at both pointers are NOT the same (i.e `s[i] !== s[j]`), we have two options:\\n\\n    - We move the first pointer and leave the second pointer `(i++, j)`, and increment the number of operations by 1. This operation is equivalent to inserting one character before index `j`(i.e `j+1`) that matches the one at index `i`.\\n    - We move the second pointer and leave the first pointer `(i, j--)`, and increment the number of operations by 1. This operation is equivalent to inserting one character before index `i` (i.e `i-1`) that matches the one at index `j`.\\n\\n\\nTo implement this approach, we wrote a recursive function that keeps track of both pointers and a cache to optimize the solution by storing the results for all pointer pairs to avoid duplicate computations.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\nn = length of string (s.length)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n\\n# Code\\n```\\nfunction minInsertions(s: string): number {\\n    const cache: number[][] = new Array(501);\\n\\n    for(let i = 0; i < cache.length; i++){\\n        cache[i] = new Array(501).fill(-1);\\n    }\\n\\n    return helper(0, s.length - 1);\\n\\n    function helper(i: number, j: number): number {\\n        if(i >= j){\\n            return 0;\\n        }\\n        if(cache[i][j] !== -1){\\n            return cache[i][j];\\n        }\\n\\n        let min: number = Number.MAX_VALUE;\\n\\n        if(s[i] === s[j]){\\n            min = Math.min(min, helper(i+1, j-1));\\n        } else {\\n            min = Math.min(\\n                min,\\n                helper(i+1, j) + 1,\\n                helper(i, j-1) + 1\\n            );\\n        }\\n\\n        cache[i][j] = min;\\n        return min;\\n    }\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunction minInsertions(s: string): number {\\n    const cache: number[][] = new Array(501);\\n\\n    for(let i = 0; i < cache.length; i++){\\n        cache[i] = new Array(501).fill(-1);\\n    }\\n\\n    return helper(0, s.length - 1);\\n\\n    function helper(i: number, j: number): number {\\n        if(i >= j){\\n            return 0;\\n        }\\n        if(cache[i][j] !== -1){\\n            return cache[i][j];\\n        }\\n\\n        let min: number = Number.MAX_VALUE;\\n\\n        if(s[i] === s[j]){\\n            min = Math.min(min, helper(i+1, j-1));\\n        } else {\\n            min = Math.min(\\n                min,\\n                helper(i+1, j) + 1,\\n                helper(i, j-1) + 1\\n            );\\n        }\\n\\n        cache[i][j] = min;\\n        return min;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3442727,
                "title": "python-2-solutions-recursive-1-liner-dp-iterative-space-optimised-dp",
                "content": "# Approach 1: Recursive DP with memoization\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n\\n- Space complexity: $$O(n^2)$$\\n\\nwhere, `n is length of s`.\\n\\n# Code\\nFormatted to multiline for readability.\\n```python\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        @cache\\n        def min_inserts(i: int, j: int) -> int:\\n            return (\\n                min_inserts(i + 1, j - 1)\\n                if s[i] == s[j]\\n                else 1 + min(min_inserts(i, j - 1), min_inserts(i + 1, j))\\n            ) if i < j else 0\\n        \\n        return min_inserts(0, len(s) - 1)\\n\\n```\\n\\n---\\n\\n# Approach 2: Iterative DP with space optimzation\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n\\n- Space complexity: $$O(n)$$\\n\\nwhere, `n is length of s`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        n = len(s)\\n        dp = [0] * (n + 1)\\n        for i in range(n - 1, -1, -1):\\n            prev = dp[i]\\n            for j in range(i + 1, n):\\n                k = j + 1\\n                prev, dp[k] = (dp[k], prev if s[i] == s[j] else 1 + min(dp[k - 1], dp[k]))\\n        return dp[-1]\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        @cache\\n        def min_inserts(i: int, j: int) -> int:\\n            return (\\n                min_inserts(i + 1, j - 1)\\n                if s[i] == s[j]\\n                else 1 + min(min_inserts(i, j - 1), min_inserts(i + 1, j))\\n            ) if i < j else 0\\n        \\n        return min_inserts(0, len(s) - 1)\\n\\n```\n```python\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        n = len(s)\\n        dp = [0] * (n + 1)\\n        for i in range(n - 1, -1, -1):\\n            prev = dp[i]\\n            for j in range(i + 1, n):\\n                k = j + 1\\n                prev, dp[k] = (dp[k], prev if s[i] == s[j] else 1 + min(dp[k - 1], dp[k]))\\n        return dp[-1]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442570,
                "title": "easy-explaination-minimum-insertion-steps-to-make-string-palimdrome",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint vec[501][501];\\n\\n\\t\\tint fun(string &s1, string &s2, int n1, int n2)\\n\\t\\t{\\n\\t\\t\\tif(n1 == 0 || n2 == 0)\\n\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\tif(vec[n1 - 1][n2 - 1] != -1)\\n\\t\\t\\t\\treturn vec[n1 - 1][n2 - 1];\\n\\n\\t\\t\\tif(s1[n1 - 1] == s2[n2 - 1])\\n\\t\\t\\t\\treturn vec[n1 - 1][n2 - 1] = (1 + fun(s1, s2, n1 - 1, n2 -1));\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn vec[n1 - 1][n2 - 1] = max(fun(s1, s2, n1 - 1, n2), fun(s1, s2, n1, n2 - 1));\\n\\n\\t\\t}\\n\\n\\t\\tint minInsertions(string s) {\\n\\t\\t\\tstring srev = s;\\n\\t\\t\\treverse(s.begin(), s.end());\\n\\n\\t\\t\\tfor(int i = 0; i < 501; i++)\\n\\t\\t\\t\\tfor(int j = 0; j < 501; j++)\\n\\t\\t\\t\\t\\tvec[i][j] = -1;\\n\\n\\t\\t\\tfun(srev, s, s.length(), s.length());\\n\\n\\t\\t\\treturn s.length()- vec[s.length() - 1][s.length() - 1];\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "String",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint vec[501][501];\\n\\n\\t\\tint fun(string &s1, string &s2, int n1, int n2)\\n\\t\\t{\\n\\t\\t\\tif(n1 == 0 || n2 == 0)\\n\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\tif(vec[n1 - 1][n2 - 1] != -1)\\n\\t\\t\\t\\treturn vec[n1 - 1][n2 - 1];\\n\\n\\t\\t\\tif(s1[n1 - 1] == s2[n2 - 1])\\n\\t\\t\\t\\treturn vec[n1 - 1][n2 - 1] = (1 + fun(s1, s2, n1 - 1, n2 -1));\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn vec[n1 - 1][n2 - 1] = max(fun(s1, s2, n1 - 1, n2), fun(s1, s2, n1, n2 - 1));\\n\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3442463,
                "title": "easy-golang-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\no(n^2) because of (n+1)*(n+1) array.\\n\\n- Space complexity:\\no(n^2) because of (n+1)*(n+1) array.\\n\\n\\n# Code\\n```\\npackage main\\n\\nfunc minInsertions(s string) int {\\n    n := len(s)\\n    dp := make([][]int, n+1)\\n    for i := 0; i <= n; i++ {\\n        dp[i] = make([]int, n+1)\\n    }\\n    r := reverse(s)\\n    for i := 0; i <= n; i++ {\\n        for j := 0; j <= n; j++ {\\n            if i == 0 || j == 0 {\\n                dp[i][j] = 0\\n            } else if s[i-1] == r[j-1] {\\n                dp[i][j] = dp[i-1][j-1] + 1\\n            } else {\\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\\n            }\\n        }\\n    }\\n    return n - dp[n][n]\\n}\\n\\nfunc reverse(s string) string {\\n    n := len(s)\\n    r := make([]byte, n)\\n    for i := 0; i < n; i++ {\\n        r[i] = s[n-i-1]\\n    }\\n    return string(r)\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Brainteaser"
                ],
                "code": "```\\npackage main\\n\\nfunc minInsertions(s string) int {\\n    n := len(s)\\n    dp := make([][]int, n+1)\\n    for i := 0; i <= n; i++ {\\n        dp[i] = make([]int, n+1)\\n    }\\n    r := reverse(s)\\n    for i := 0; i <= n; i++ {\\n        for j := 0; j <= n; j++ {\\n            if i == 0 || j == 0 {\\n                dp[i][j] = 0\\n            } else if s[i-1] == r[j-1] {\\n                dp[i][j] = dp[i-1][j-1] + 1\\n            } else {\\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\\n            }\\n        }\\n    }\\n    return n - dp[n][n]\\n}\\n\\nfunc reverse(s string) string {\\n    n := len(s)\\n    r := make([]byte, n)\\n    for i := 0; i < n; i++ {\\n        r[i] = s[n-i-1]\\n    }\\n    return string(r)\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3442390,
                "title": "c-memoization-solution-easiest",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[510][510];\\n    int mininsertions(string&s, int si, int ei){\\n        if(dp[si][ei]!=-1)return dp[si][ei];\\n        if(si>=ei)return 0;\\n        if(s[si]==s[ei]){\\n            return dp[si][ei]=mininsertions(s,si+1,ei-1);\\n        }\\n        return dp[si][ei]=1+min(mininsertions(s,si+1,ei),mininsertions(s,si,ei-1));\\n    }\\n    int minInsertions(string s) {\\n        memset(dp,-1,sizeof(dp));\\n        return mininsertions(s,0,s.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[510][510];\\n    int mininsertions(string&s, int si, int ei){\\n        if(dp[si][ei]!=-1)return dp[si][ei];\\n        if(si>=ei)return 0;\\n        if(s[si]==s[ei]){\\n            return dp[si][ei]=mininsertions(s,si+1,ei-1);\\n        }\\n        return dp[si][ei]=1+min(mininsertions(s,si+1,ei),mininsertions(s,si,ei-1));\\n    }\\n    int minInsertions(string s) {\\n        memset(dp,-1,sizeof(dp));\\n        return mininsertions(s,0,s.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442341,
                "title": "c-using-longest-palindromic-subsequence",
                "content": "# Approach\\nUsing [516. Longest Palindromic Subsequence](https://leetcode.com/problems/longest-palindromic-subsequence/).\\nIf we know the longest palindromic sub-sequence is x and the length of the string is $$n$$ then, what is the answer to this problem? It is $$n - x$$ as we need $$n - x$$ insertions to make the remaining characters also palindrome.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n \\\\times m)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    private readonly Dictionary<(int i, int j), int> _cache = new();\\n\\n    public int MinInsertions(string s)\\n    {\\n        var reversedString = string.Join(\"\", s.Reverse());\\n        return s.Length - getLCS(s, 0, reversedString, 0);\\n    }\\n    \\n    private int getLCS(string a, int i, string b, int j)\\n    {\\n        if (i >= a.Length || j >= b.Length)\\n        {\\n            return 0;\\n        }\\n\\n        if (_cache.TryGetValue((i, j), out var value))\\n        {\\n            return value;\\n        }\\n\\n        if (a[i] == b[j])\\n        {\\n            return _cache[(i, j)] = 1 + getLCS(a, i + 1, b, j + 1);\\n        }\\n\\n        return _cache[(i, j)] = Math.Max(getLCS(a, i + 1, b, j), getLCS(a, i, b, j + 1));\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    private readonly Dictionary<(int i, int j), int> _cache = new();\\n\\n    public int MinInsertions(string s)\\n    {\\n        var reversedString = string.Join(\"\", s.Reverse());\\n        return s.Length - getLCS(s, 0, reversedString, 0);\\n    }\\n    \\n    private int getLCS(string a, int i, string b, int j)\\n    {\\n        if (i >= a.Length || j >= b.Length)\\n        {\\n            return 0;\\n        }\\n\\n        if (_cache.TryGetValue((i, j), out var value))\\n        {\\n            return value;\\n        }\\n\\n        if (a[i] == b[j])\\n        {\\n            return _cache[(i, j)] = 1 + getLCS(a, i + 1, b, j + 1);\\n        }\\n\\n        return _cache[(i, j)] = Math.Max(getLCS(a, i + 1, b, j), getLCS(a, i, b, j + 1));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442295,
                "title": "daily-leetcoding-challenge-april-day-22",
                "content": "This problem is the Daily LeetCoding Challenge for April, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Dynamic Programming\n\n  \n**Approach 2:** Iterative Dynamic Programming\n\n  \n**Approach 3:** Dynamic Programming with Space Optimization\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3437070,
                "title": "longest-plindromic-subsequence-c",
                "content": "````\\nclass Solution {\\npublic:\\n    int minInsertions(string s1) {\\n        int n = s1.length();\\n        vector<int> dp1(n+1,0),dp2(n+1,0);\\n        string s2 = s1;\\n        reverse(s1.begin(),s1.end());\\n        int i,j;\\n        for(i = 1; i <= n; i++){\\n            for(j = 1; j <= n; j++){\\n                if(s1[i-1]==s2[j-1]){\\n                    dp2[j] = dp1[j-1]+1;\\n                }else{\\n                    dp2[j] = max(dp1[j],dp2[j-1]);\\n                }\\n            }\\n            dp1 =  dp2;\\n        }\\n        return n-dp1[n];\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int minInsertions(string s1) {\\n        int n = s1.length();\\n        vector<int> dp1(n+1,0),dp2(n+1,0);\\n        string s2 = s1;\\n        reverse(s1.begin(),s1.end());\\n        int i,j;\\n        for(i = 1; i <= n; i++){\\n            for(j = 1; j <= n; j++){\\n                if(s1[i-1]==s2[j-1]){\\n                    dp2[j] = dp1[j-1]+1;\\n                }else{\\n                    dp2[j] = max(dp1[j],dp2[j-1]);\\n                }\\n            }\\n            dp1 =  dp2;\\n        }\\n        return n-dp1[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233329,
                "title": "c-recursion-top-down-bottom-up",
                "content": "# Code [Recursion] (Gives TLE)\\n```\\nclass Solution {\\npublic:\\n    int n;\\n\\n    int insertions(string&s ,int i, int j){\\n        if(i>j) return INT_MAX;\\n        if((i==j) || (j-i==1 && s[i]==s[j])) return 0;\\n        if(s[i]==s[j]){\\n            return insertions(s,i+1,j-1);\\n        }\\n        return min(insertions(s,i+1,j),insertions(s,i,j-1)) + 1;\\n    }\\n\\n    int minInsertions(string s) {\\n        n = s.length();\\n        return insertions(s,0,n-1);\\n    }\\n};\\n```\\n__________________________________\\n\\n# Code [Top-Down]\\n```\\nclass Solution {\\npublic:\\n    int n;\\n\\n    int insertions(string&s ,int i, int j,vector<vector<int>>&dp){\\n        if(i>j) return INT_MAX;\\n        if((i==j)||(j-i==1 && s[i]==s[j])) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = 0;\\n\\n        if(s[i]==s[j]) ans = insertions(s,i+1,j-1,dp);\\n        else ans = min(insertions(s,i+1,j,dp),insertions(s,i,j-1,dp)) + 1;\\n        return dp[i][j]=ans;\\n    }\\n\\n    int minInsertions(string s) {\\n        n = s.length();\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        return insertions(s,0,n-1,dp);\\n    }\\n};\\n```\\n_________________\\n# Code [Bottom-Up]\\n```\\nclass Solution {\\npublic:\\n    int n;\\n\\n    int insertions(string &s){\\n        vector<vector<int>> dp(n,vector<int>(n,INT_MAX));\\n        for(int i=0;i<n;i++){\\n            dp[i][i] = 0;\\n        }\\n        for(int i=0;i<n-1;i++){\\n            if(s[i]==s[i+1]) dp[i][i+1]=0;\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=i+1;j<n;j++){\\n                if(dp[i][j]==0) continue;\\n                if(s[i]==s[j]) dp[i][j] = dp[i+1][j-1];\\n                else dp[i][j] = min(dp[i+1][j],dp[i][j-1])+1;\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n\\n    int minInsertions(string s) {\\n        n = s.length();\\n        return insertions(s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n\\n    int insertions(string&s ,int i, int j){\\n        if(i>j) return INT_MAX;\\n        if((i==j) || (j-i==1 && s[i]==s[j])) return 0;\\n        if(s[i]==s[j]){\\n            return insertions(s,i+1,j-1);\\n        }\\n        return min(insertions(s,i+1,j),insertions(s,i,j-1)) + 1;\\n    }\\n\\n    int minInsertions(string s) {\\n        n = s.length();\\n        return insertions(s,0,n-1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int n;\\n\\n    int insertions(string&s ,int i, int j,vector<vector<int>>&dp){\\n        if(i>j) return INT_MAX;\\n        if((i==j)||(j-i==1 && s[i]==s[j])) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans = 0;\\n\\n        if(s[i]==s[j]) ans = insertions(s,i+1,j-1,dp);\\n        else ans = min(insertions(s,i+1,j,dp),insertions(s,i,j-1,dp)) + 1;\\n        return dp[i][j]=ans;\\n    }\\n\\n    int minInsertions(string s) {\\n        n = s.length();\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        return insertions(s,0,n-1,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int n;\\n\\n    int insertions(string &s){\\n        vector<vector<int>> dp(n,vector<int>(n,INT_MAX));\\n        for(int i=0;i<n;i++){\\n            dp[i][i] = 0;\\n        }\\n        for(int i=0;i<n-1;i++){\\n            if(s[i]==s[i+1]) dp[i][i+1]=0;\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=i+1;j<n;j++){\\n                if(dp[i][j]==0) continue;\\n                if(s[i]==s[j]) dp[i][j] = dp[i+1][j-1];\\n                else dp[i][j] = min(dp[i+1][j],dp[i][j-1])+1;\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n\\n    int minInsertions(string s) {\\n        n = s.length();\\n        return insertions(s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096748,
                "title": "tabulation-simple-and-easy-to-understand-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.size();\\n        string t = s;\\n        reverse(t.begin(),t.end());\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,0));\\n        for(int i=0;i<=n;i++) dp[i][0] = 0;\\n        for(int j=0;j<=n;j++) dp[0][j] = 0;\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=n;j++){\\n                if(s[i-1] == t[j-1]){\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                }\\n                else{\\n                    dp[i][j] = max( dp[i-1][j] , dp[i][j-1] );\\n                }\\n            }\\n        }\\n        return n - dp[n][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.size();\\n        string t = s;\\n        reverse(t.begin(),t.end());\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,0));\\n        for(int i=0;i<=n;i++) dp[i][0] = 0;\\n        for(int j=0;j<=n;j++) dp[0][j] = 0;\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=n;j++){\\n                if(s[i-1] == t[j-1]){\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                }\\n                else{\\n                    dp[i][j] = max( dp[i-1][j] , dp[i][j-1] );\\n                }\\n            }\\n        }\\n        return n - dp[n][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2663128,
                "title": "java-bottom-up-easy-dp-solution-with-detailed-explanation",
                "content": "The idea is simple here, we need to find the minimum insertion to make a string pallindrome, so what we can do is we can find the LPS of the current string, because that is the length which is already a pallindrom it means the remaining length needs to be converted to palindrome or in other words the remaining length indicates the no of insertion to make the whole string palindrom(just think)\\n\\nSo a = leetcode\\nb = edocteel (a reversed)\\n\\nNow LPS of these 2 strings is **eee** (right?) So we need to convert the remaining string to palindrome right?\\nHow many remaining char are there which is s.Length - LPS which is  8 - 3 = 5 \\nSo for these 5 charcters if we add 1 addtitional char for each 1 of these 5 chars we will make the whole string palindrome right?\\n\\nSo to generalize min insertions = S.Length - LPS(S), here LPS(S) will return the length of lps(s)\\nBelow is the implementation\\n\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        StringBuilder sb = new StringBuilder(s);\\n        String s1 = sb.reverse().toString();\\n        \\n        int [][] dp = new int[s.length()+1][s1.length()+1];\\n      \\n        for(int i=1;i<=s.length();i++)\\n        {\\n            for(int j =1;j<=s1.length();j++)\\n            {\\n                if(s.charAt(i-1) == s1.charAt(j-1))\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                else\\n                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\\n            }\\n        }\\n        return s.length() - dp[s.length()][s1.length()];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        StringBuilder sb = new StringBuilder(s);\\n        String s1 = sb.reverse().toString();\\n        \\n        int [][] dp = new int[s.length()+1][s1.length()+1];\\n      \\n        for(int i=1;i<=s.length();i++)\\n        {\\n            for(int j =1;j<=s1.length();j++)\\n            {\\n                if(s.charAt(i-1) == s1.charAt(j-1))\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                else\\n                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\\n            }\\n        }\\n        return s.length() - dp[s.length()][s1.length()];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2651301,
                "title": "dp-c-easy-to-understand",
                "content": "\\n# Approach\\nLet us create a recursive function minCount, that gives us the minimum number of insertions required to make the segment [Sidx1 .... Sidx2] palindrome. Obviously, our answer would be minCount(0, n-1), where n is the length of the string. The base case of the recursion would be if idx1 >= idx2 (meaning there is only one length string (idx1 == idx2), which is already a palindrome, or the string has ended (idx1 > idx2)), then we return 0. If S[idx1] == S[idx2], than we need to count minimum insertions for the part [Sidx1+1 ... Sidx2-1]. If S[idx1] != S[idx2], then there are two cases. Case 1 is we make a insertion at position idx2 to make it equal to S[idx1] and calculate the answer for S[idx1+1 ... idx2]. Case 2 is we make a insertion at position idx1 to make it equal to S[idx2] and calculate the answer for S[idx1 ... idx2-1]. Then we have to take the minimum of Case 1 and Case 2. \\nWe can easily observe that there are many overlapping subproblems. Thus we can memoise the results of our recursive calls. \\n\\n# Complexity\\n- Time complexity:\\nO(n^2) // where n is the length of the string\\n\\n- Space complexity:\\nO(n^2) // where n is the length of the string\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[505][505];\\n    int minCount(int idx1, int idx2, string &s) {\\n        if(idx1 >= idx2) return 0;\\n        if(dp[idx1][idx2] != -1) return dp[idx1][idx2];\\n        if(s[idx1] == s[idx2]) {\\n            return dp[idx1][idx2] = minCount(idx1+1, idx2-1, s);\\n        }\\n        return dp[idx1][idx2] = 1 + min(minCount(idx1+1, idx2, s), minCount(idx1, idx2-1, s));\\n    }\\n    int minInsertions(string s) {\\n        int n = s.length();\\n        memset(dp, -1, sizeof dp);\\n        return minCount(0, n-1, s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[505][505];\\n    int minCount(int idx1, int idx2, string &s) {\\n        if(idx1 >= idx2) return 0;\\n        if(dp[idx1][idx2] != -1) return dp[idx1][idx2];\\n        if(s[idx1] == s[idx2]) {\\n            return dp[idx1][idx2] = minCount(idx1+1, idx2-1, s);\\n        }\\n        return dp[idx1][idx2] = 1 + min(minCount(idx1+1, idx2, s), minCount(idx1, idx2-1, s));\\n    }\\n    int minInsertions(string s) {\\n        int n = s.length();\\n        memset(dp, -1, sizeof dp);\\n        return minCount(0, n-1, s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2634722,
                "title": "python-easy-solution",
                "content": "**The algorithm is stated as follows:**\\n\\n* We are given a string (say s), store its length as n.\\n\\n* Find the length of the longest palindromic subsequence ( say k)\\n\\n* Return n-k as answer.\\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        def lcp(n,s,st_r,prev):\\n            for i in range(1,n+1):\\n                temp=[0]*(n+1)\\n                for j in range(1,n+1):\\n                    if s[i-1]==st_r[j-1]:\\n                        temp[j]=1+prev[j-1]\\n                    else:\\n                        temp[j]=max(prev[j],temp[j-1])\\n                prev=temp\\n            return (n-prev[n])\\n        \\n        n=len(s)\\n        st_r=s[::-1]\\n        prev=[0]*(n+1)\\n        return lcp(n,s,st_r,prev)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        def lcp(n,s,st_r,prev):\\n            for i in range(1,n+1):\\n                temp=[0]*(n+1)\\n                for j in range(1,n+1):\\n                    if s[i-1]==st_r[j-1]:\\n                        temp[j]=1+prev[j-1]\\n                    else:\\n                        temp[j]=max(prev[j],temp[j-1])\\n                prev=temp\\n            return (n-prev[n])\\n        \\n        n=len(s)\\n        st_r=s[::-1]\\n        prev=[0]*(n+1)\\n        return lcp(n,s,st_r,prev)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2495811,
                "title": "c-lcs",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) \\n    {\\n        return s.size() - longestPalindromeSubseq(s);\\n    }\\n    \\nprivate:\\n    int longestPalindromeSubseq(string s) \\n    {\\n        string t = s;\\n        reverse(t.begin(), t.end());\\n        return longestCommonSubsequence(s, t);\\n    }\\n    \\n    int longestCommonSubsequence(string text1, string text2) \\n    {\\n        int n = text1.size(), m = text2.size();\\n        vector<int> prev(m + 1, 0), cur(m + 1, 0);\\n        \\n        for (int i = 1; i <= n; i++)\\n        {\\n            for (int j = 1; j <= m; j++)\\n            {\\n                if (text1[i - 1] == text2[j - 1])\\n                    cur[j] = 1 + prev[j - 1];\\n                else\\n                    cur[j] = max(prev[j], cur[j - 1]);\\n            }\\n            prev = cur;\\n        }\\n        return prev[m];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) \\n    {\\n        return s.size() - longestPalindromeSubseq(s);\\n    }\\n    \\nprivate:\\n    int longestPalindromeSubseq(string s) \\n    {\\n        string t = s;\\n        reverse(t.begin(), t.end());\\n        return longestCommonSubsequence(s, t);\\n    }\\n    \\n    int longestCommonSubsequence(string text1, string text2) \\n    {\\n        int n = text1.size(), m = text2.size();\\n        vector<int> prev(m + 1, 0), cur(m + 1, 0);\\n        \\n        for (int i = 1; i <= n; i++)\\n        {\\n            for (int j = 1; j <= m; j++)\\n            {\\n                if (text1[i - 1] == text2[j - 1])\\n                    cur[j] = 1 + prev[j - 1];\\n                else\\n                    cur[j] = max(prev[j], cur[j - 1]);\\n            }\\n            prev = cur;\\n        }\\n        return prev[m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459601,
                "title": "aditya-verma-lcs-tabulation",
                "content": "\\n\\n    int minInsertions(string s1) {\\n        string s2 = s1;\\n        reverse(s2.begin(),s2.end());\\n        int n = s1.length();\\n        int m = s2.length();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1));\\n        for(int i=0; i<n+1; i++)\\n        {\\n          for(int j=0; j<m+1; j++)\\n          {\\n              if(i==0 || j==0)\\n                  dp[i][j]  = 0;\\n          }\\n        }\\n        \\n        for(int i=1; i<n+1; i++)\\n        {\\n            for(int j=1; j<m+1; j++)\\n            {\\n                if(s1[i-1]==s2[j-1])\\n                    dp[i][j] = 1+dp[i-1][j-1];\\n                else\\n                    dp[i][j] = max(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        return (s2.length()-dp[n][m]);\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\n\\n    int minInsertions(string s1) {\\n        string s2 = s1;\\n        reverse(s2.begin(),s2.end());\\n        int n = s1.length();\\n        int m = s2.length();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1));\\n        for(int i=0; i<n+1; i++)\\n        {\\n          for(int j=0; j<m+1; j++)\\n          {\\n              if(i==0 || j==0)\\n                  dp[i][j]  = 0;\\n          }\\n        }\\n        \\n        for(int i=1; i<n+1; i++)\\n        {\\n            for(int j=1; j<m+1; j++)\\n            {\\n                if(s1[i-1]==s2[j-1])\\n                    dp[i][j] = 1+dp[i-1][j-1];\\n                else\\n                    dp[i][j] = max(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        return (s2.length()-dp[n][m]);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2415665,
                "title": "c-longest-common-subsequence",
                "content": "```\\nint longestCommonSubsequence(string& t1,string& t2)\\n    {\\n        int n=t1.length(),m=t2.length();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,0));\\n        for(int i=1;i<=n;i++)\\n            for(int j=1;j<=m;j++)\\n                if(t1[i-1]==t2[j-1])\\n                    dp[i][j]=1+dp[i-1][j-1];\\n            else\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n        \\n        return t1.length()-dp[n][m];\\n    }\\n    int minInsertions(string s) {\\n        string t=s;\\n        reverse(s.begin(),s.end());\\n        if(t==s)\\n            return 0;\\n        return longestCommonSubsequence(t,s);\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint longestCommonSubsequence(string& t1,string& t2)\\n    {\\n        int n=t1.length(),m=t2.length();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,0));\\n        for(int i=1;i<=n;i++)\\n            for(int j=1;j<=m;j++)\\n                if(t1[i-1]==t2[j-1])\\n                    dp[i][j]=1+dp[i-1][j-1];\\n            else\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n        \\n        return t1.length()-dp[n][m];\\n    }\\n    int minInsertions(string s) {\\n        string t=s;\\n        reverse(s.begin(),s.end());\\n        if(t==s)\\n            return 0;\\n        return longestCommonSubsequence(t,s);\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2397677,
                "title": "c-accepted-solution-dp-memo-solution-fix-your-tle-error-using",
                "content": "**If  you are facing TLE in your memo approach just pass the strings by reference \\uD83D\\uDE03 It will work**\\n\\n\\nclass Solution {\\npublic:\\n\\n    int dp[501][501];\\n    int f(string &s,string &s1,int m,int n){\\n        if(m==-1 ||n==-1) return 0;\\n        if(dp[m][n]!=-1) return dp[m][n];\\n        int ans=0;\\n        if(s[m]==s1[n]){\\n            ans=f(s,s1,m-1,n-1)+1;\\n        }else{\\n            ans=max(f(s,s1,m-1,n),f(s,s1,m,n-1));\\n        }\\n        return dp[m][n]=ans;\\n    }\\n    int minInsertions(string s) {\\n        string s1=s;\\n        memset(dp,-1,sizeof(dp));\\n        reverse(s1.begin(),s1.end());\\n        int n=s.length();\\n        int v=f(s,s1,n-1,n-1);\\n        return (n-v);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int dp[501][501];\\n    int f(string &s,string &s1,int m,int n){\\n        if(m==-1 ||n==-1) return 0;\\n        if(dp[m][n]!=-1) return dp[m][n];\\n        int ans=0;\\n        if(s[m]==s1[n]){\\n            ans=f(s,s1,m-1,n-1)+1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2350481,
                "title": "java-solution-top-down-dp-very-easy",
                "content": "```\\n  static int lcs(int x, int y, String s1, String s2)\\n    {\\n        // your code here\\n         int[][] t = new int[x+1][y+1];\\n        //fill the rows and col for n==0 , m==0 (base case);\\n        for(int i=0;i<=x;i++){\\n            for(int j=0;j<=y;j++){\\n                if(i==0){\\n                    t[i][j]=0;\\n                }\\n                else if(j==0){\\n                    t[i][j]=0;\\n                }\\n            }\\n        }\\n        //choice diagram code=> top-down approch\\n        for(int i=1;i<=x;i++){\\n            for(int j=1;j<=y;j++){\\n                if(s1.charAt(i-1)==s2.charAt(j-1)){\\n                    t[i][j]=1+t[i-1][j-1];\\n                }\\n                else{\\n                    t[i][j]=Math.max(t[i][j-1],t[i-1][j]);\\n                }\\n            }\\n        }\\n        return t[x][y];\\n    }\\n    \\n    public int minInsertions(String s) {\\n          int x=s.length();\\n        String s2 = \"\";\\n        char ch;\\n            \\n      for (int i=0; i<s.length(); i++)\\n      {\\n        ch= s.charAt(i); //extracts each character\\n        s2= ch+s2; //adds each character in front of the existing string\\n      }\\n      // longest palindromic subsequence value stored !!\\n      int value =  lcs(x,x,s,s2);\\n        // subtract\\n    return x-value;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n  static int lcs(int x, int y, String s1, String s2)\\n    {\\n        // your code here\\n         int[][] t = new int[x+1][y+1];\\n        //fill the rows and col for n==0 , m==0 (base case);\\n        for(int i=0;i<=x;i++){\\n            for(int j=0;j<=y;j++){\\n                if(i==0){\\n                    t[i][j]=0;\\n                }\\n                else if(j==0){\\n                    t[i][j]=0;\\n                }\\n            }\\n        }\\n        //choice diagram code=> top-down approch\\n        for(int i=1;i<=x;i++){\\n            for(int j=1;j<=y;j++){\\n                if(s1.charAt(i-1)==s2.charAt(j-1)){\\n                    t[i][j]=1+t[i-1][j-1];\\n                }\\n                else{\\n                    t[i][j]=Math.max(t[i][j-1],t[i-1][j]);\\n                }\\n            }\\n        }\\n        return t[x][y];\\n    }\\n    \\n    public int minInsertions(String s) {\\n          int x=s.length();\\n        String s2 = \"\";\\n        char ch;\\n            \\n      for (int i=0; i<s.length(); i++)\\n      {\\n        ch= s.charAt(i); //extracts each character\\n        s2= ch+s2; //adds each character in front of the existing string\\n      }\\n      // longest palindromic subsequence value stored !!\\n      int value =  lcs(x,x,s,s2);\\n        // subtract\\n    return x-value;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2296987,
                "title": "done-using-lps-easy-to-understand-code",
                "content": "Done using Longest Palindromic Subsequence\\nAns : len of string - len of LPS\\n\\n```class Solution {\\npublic:\\n    \\n    int lcs(string x,string y,int n){\\n        vector< vector< int>> dp(n+1,vector< int>(n+1,-1));\\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=n;j++){\\n                if(i == 0 || j == 0)\\n                    dp[i][j] = 0;\\n                else{\\n                    if(x[i-1] == y[j-1]){\\n                        dp[i][j] = 1 + dp[i-1][j-1];\\n                    }else{\\n                        dp[i][j] = max(dp[i-1][j],dp[i][j-1]);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[n][n];\\n}\\n    int minInsertions(string x) {\\n        int n=x.size();\\n        string y = x; \\n        reverse(x.begin(),x.end());\\n        int len = lcs(x,y,n);\\n        return n-len;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int lcs(string x,string y,int n){\\n        vector< vector< int>> dp(n+1,vector< int>(n+1,-1));\\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=n;j++){\\n                if(i == 0 || j == 0)\\n                    dp[i][j] = 0;\\n                else{\\n                    if(x[i-1] == y[j-1]){\\n                        dp[i][j] = 1 + dp[i-1][j-1];\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2296614,
                "title": "easy-c-solution-4-approaches-lcs-recursion-dp",
                "content": "#  -> Approach 1 : Recursive (TLE)\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        string t = s;\\n        reverse(t.begin(), t.end());\\n        return s.length() - lcs(s.length()-1, s.length()-1, s, t);\\n    }\\n    \\n    int lcs(int i, int j, string s, string t){\\n        if(i<0 || j<0)\\n            return 0;\\n        \\n        if(s[i] == t[j])\\n            return 1+lcs(i-1, j-1, s, t);\\n        else\\n            return max(lcs(i, j-1, s, t), lcs(i-1, j, s, t));\\n    }\\n};\\n```\\n\\n#  -> Approach 2 : Memoization (TLE)\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        string t = s;\\n        reverse(t.begin(), t.end());\\n        vector<vector<int>> dp(s.length()+1, vector<int> (s.length()+1, -1));\\n        return s.length() - lcs(s.length(), s.length(), s, t, dp);\\n    }\\n    \\n    int lcs(int i, int j, string s, string t, vector<vector<int>> dp){\\n        if(i==0 || j==0)\\n            return 0;\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        if(s[i-1] == t[j-1])\\n            return dp[i][j] = 1+lcs(i-1, j-1, s, t, dp);\\n        else\\n            return dp[i][j] = max(lcs(i, j-1, s, t, dp), lcs(i-1, j, s, t, dp));\\n    }\\n};\\n```\\n\\n#  Approach 3 : Tabulation (Accepted)\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        string t = s;\\n        reverse(t.begin(), t.end());\\n        vector<vector<int>> dp(s.length()+1, vector<int> (s.length()+1, 0));\\n        \\n        for(int i=1; i<=s.length(); i++){\\n            for(int j=1; j<=s.length(); j++){\\n                if(s[i-1] == t[j-1])\\n                    dp[i][j] = 1+dp[i-1][j-1];\\n                else\\n                    dp[i][j] = max(dp[i][j-1], dp[i-1][j]);\\n            }\\n        }\\n                                   \\n        int lcs = dp[s.length()][s.length()];\\n        return s.length() - lcs;\\n    }\\n};\\n```\\n\\n#  Approach 4 : Space Optimisation (Accepted)\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        string t = s;\\n        reverse(t.begin(), t.end());\\n        vector <int> prev(s.length()+1, 0);\\n        \\n        for(int i=1; i<=s.length(); i++){\\n            vector <int> curr(s.length()+1, 0);\\n            for(int j=1; j<=s.length(); j++){\\n                if(s[i-1] == t[j-1])\\n                    curr[j] = 1+prev[j-1];\\n                else\\n                    curr[j] = max(curr[j-1], prev[j]);\\n            }\\n            prev = curr;\\n        }\\n                                   \\n        int lcs = prev[s.length()];\\n        return s.length() - lcs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        string t = s;\\n        reverse(t.begin(), t.end());\\n        return s.length() - lcs(s.length()-1, s.length()-1, s, t);\\n    }\\n    \\n    int lcs(int i, int j, string s, string t){\\n        if(i<0 || j<0)\\n            return 0;\\n        \\n        if(s[i] == t[j])\\n            return 1+lcs(i-1, j-1, s, t);\\n        else\\n            return max(lcs(i, j-1, s, t), lcs(i-1, j, s, t));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        string t = s;\\n        reverse(t.begin(), t.end());\\n        vector<vector<int>> dp(s.length()+1, vector<int> (s.length()+1, -1));\\n        return s.length() - lcs(s.length(), s.length(), s, t, dp);\\n    }\\n    \\n    int lcs(int i, int j, string s, string t, vector<vector<int>> dp){\\n        if(i==0 || j==0)\\n            return 0;\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        if(s[i-1] == t[j-1])\\n            return dp[i][j] = 1+lcs(i-1, j-1, s, t, dp);\\n        else\\n            return dp[i][j] = max(lcs(i, j-1, s, t, dp), lcs(i-1, j, s, t, dp));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        string t = s;\\n        reverse(t.begin(), t.end());\\n        vector<vector<int>> dp(s.length()+1, vector<int> (s.length()+1, 0));\\n        \\n        for(int i=1; i<=s.length(); i++){\\n            for(int j=1; j<=s.length(); j++){\\n                if(s[i-1] == t[j-1])\\n                    dp[i][j] = 1+dp[i-1][j-1];\\n                else\\n                    dp[i][j] = max(dp[i][j-1], dp[i-1][j]);\\n            }\\n        }\\n                                   \\n        int lcs = dp[s.length()][s.length()];\\n        return s.length() - lcs;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        string t = s;\\n        reverse(t.begin(), t.end());\\n        vector <int> prev(s.length()+1, 0);\\n        \\n        for(int i=1; i<=s.length(); i++){\\n            vector <int> curr(s.length()+1, 0);\\n            for(int j=1; j<=s.length(); j++){\\n                if(s[i-1] == t[j-1])\\n                    curr[j] = 1+prev[j-1];\\n                else\\n                    curr[j] = max(curr[j-1], prev[j]);\\n            }\\n            prev = curr;\\n        }\\n                                   \\n        int lcs = prev[s.length()];\\n        return s.length() - lcs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166052,
                "title": "c-simple-dp-top-down-lcs",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string str) {\\n    string k =str;\\n    reverse(k.begin(),k.end());\\n    int n = str.length(); \\n    int dp[n+1][n+1];\\n    for(int i=0;i<=n;i++){\\n        for(int j=0;j<=n;j++){\\n            if(i==0||j==0){\\n                dp[i][j]=0;\\n            }\\n            else if(str[i-1]==k[j-1]){\\n                dp[i][j] = 1+dp[i-1][j-1];\\n            }\\n            else{\\n                dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n    }\\n    \\n    return n - dp[n][n];  \\n   }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string str) {\\n    string k =str;\\n    reverse(k.begin(),k.end());\\n    int n = str.length(); \\n    int dp[n+1][n+1];\\n    for(int i=0;i<=n;i++){\\n        for(int j=0;j<=n;j++){\\n            if(i==0||j==0){\\n                dp[i][j]=0;\\n            }\\n            else if(str[i-1]==k[j-1]){\\n                dp[i][j] = 1+dp[i-1][j-1];\\n            }\\n            else{\\n                dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n    }\\n    \\n    return n - dp[n][n];  \\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2098272,
                "title": "lord-aditya-verma-lps-easy-c-solution",
                "content": "```\\n    int minInsertions(string str) {\\n        string a=str;\\n        int n=str.size();\\n        reverse(str.begin(),str.end());\\n        int dp[n+1][n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=n;j++)\\n            {\\n                if(i==0 || j==0)\\n                    dp[i][j]=0;\\n                else if(str[i-1]==a[j-1])\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                else \\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n            }\\n\\n        }\\n        return n-dp[n][n];\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\n    int minInsertions(string str) {\\n        string a=str;\\n        int n=str.size();\\n        reverse(str.begin(),str.end());\\n        int dp[n+1][n+1];\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<=n;j++)\\n            {\\n                if(i==0 || j==0)\\n                    dp[i][j]=0;\\n                else if(str[i-1]==a[j-1])\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                else \\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n            }\\n\\n        }\\n        return n-dp[n][n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2096600,
                "title": "c-soln-using-lps-and-lcs",
                "content": "```\\nclass Solution {\\npublic:\\n    //lcs\\n    int lcs(string s1, string s2){\\n        int n = s1.size();\\n        int m = s2.size();\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, -1));\\n        for(int i=0; i<=n; i++){\\n            dp[i][0] = 0;\\n            \\n        }\\n        for(int i=0; i<=m; i++){\\n            dp[0][i] = 0;\\n            \\n        }\\n        \\n        for(int i=1; i<=n; i++){\\n            for(int j = 1; j<=m; j++){\\n                if(s1[i-1] == s2[j-1])\\n                    dp[i][j] = 1+ dp[i-1][j-1];\\n                else{\\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[n][m];\\n    }\\n    \\n    \\n    //longest palindromic subsequence\\n    int lps(string s){\\n        string rev = s;\\n        reverse(s.begin(), s.end());\\n        \\n        return lcs(s, rev);\\n    }\\n    \\n    \\n    // The difference between the size of the string and the length of lps will give us the number of chars that needs to be inserted to make the string a palindrome\\n    \\n    int minInsertions(string s) {\\n        return s.size() - lps(s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //lcs\\n    int lcs(string s1, string s2){\\n        int n = s1.size();\\n        int m = s2.size();\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, -1));\\n        for(int i=0; i<=n; i++){\\n            dp[i][0] = 0;\\n            \\n        }\\n        for(int i=0; i<=m; i++){\\n            dp[0][i] = 0;\\n            \\n        }\\n        \\n        for(int i=1; i<=n; i++){\\n            for(int j = 1; j<=m; j++){\\n                if(s1[i-1] == s2[j-1])\\n                    dp[i][j] = 1+ dp[i-1][j-1];\\n                else{\\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[n][m];\\n    }\\n    \\n    \\n    //longest palindromic subsequence\\n    int lps(string s){\\n        string rev = s;\\n        reverse(s.begin(), s.end());\\n        \\n        return lcs(s, rev);\\n    }\\n    \\n    \\n    // The difference between the size of the string and the length of lps will give us the number of chars that needs to be inserted to make the string a palindrome\\n    \\n    int minInsertions(string s) {\\n        return s.size() - lps(s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2082847,
                "title": "c-easy-short-lps",
                "content": "Ok, we need minimum number of insertions in that string, so what we is we calculate the longest palindromic subseqence from given string and it\\'s reverse (because we need to make this string palindrome, reversing it will have no effect on palindromic subsequence and finding **LCS of these strings will give LPS**), then we subtract the length of string and length of LPS,why because think like this ,adding this number(above calculated ans) of characters somehere in string will make it palindromic.\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n=s.length();\\n        string s2=s;\\n        reverse(s.begin(),s.end());\\n        int dp[n+1][n+1];\\n        memset(dp,0,sizeof(dp));\\n        int ans=INT_MIN;\\n\\t\\t//top-down dp for finding LPS\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=n;j++){\\n                if(s[i-1]==s2[j-1]){\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                    ans = max(ans,dp[i][j]);\\n                }else dp[i][j]=max(dp[i][j-1],dp[i-1][j]);\\n            }\\n        }\\n        return ans==INT_MIN ? (n%2==0 ? n : n-1) : n-ans;\\n    }\\n};\\n```\\n**Upvote if helped!!**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n=s.length();\\n        string s2=s;\\n        reverse(s.begin(),s.end());\\n        int dp[n+1][n+1];\\n        memset(dp,0,sizeof(dp));\\n        int ans=INT_MIN;\\n\\t\\t//top-down dp for finding LPS\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=n;j++){\\n                if(s[i-1]==s2[j-1]){\\n                    dp[i][j]=1+dp[i-1][j-1];\\n                    ans = max(ans,dp[i][j]);\\n                }else dp[i][j]=max(dp[i][j-1],dp[i-1][j]);\\n            }\\n        }\\n        return ans==INT_MIN ? (n%2==0 ? n : n-1) : n-ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2066667,
                "title": "c-without-using-lcs-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int f(int l,int r,string &s,vector<vector<int>>&dp){\\n      if(l>=r) return 0;\\n      \\n      if(dp[l][r]!=-1) return dp[l][r];\\n      \\n      int x=1e9,y=1e9;\\n      \\n      if(s[l]==s[r]){\\n        x=f(l+1,r-1,s,dp);\\n      }\\n      else{\\n        y=1+min(f(l+1,r,s,dp),f(l,r-1,s,dp));\\n     }\\n      \\n      return dp[l][r]=min(x,y);\\n    }\\n    int minInsertions(string s) {\\n      vector<vector<int>>dp(s.size(),vector<int>(s.size(),-1));\\n      \\n      return f(0,s.size()-1,s,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int l,int r,string &s,vector<vector<int>>&dp){\\n      if(l>=r) return 0;\\n      \\n      if(dp[l][r]!=-1) return dp[l][r];\\n      \\n      int x=1e9,y=1e9;\\n      \\n      if(s[l]==s[r]){\\n        x=f(l+1,r-1,s,dp);\\n      }\\n      else{\\n        y=1+min(f(l+1,r,s,dp),f(l,r-1,s,dp));\\n     }\\n      \\n      return dp[l][r]=min(x,y);\\n    }\\n    int minInsertions(string s) {\\n      vector<vector<int>>dp(s.size(),vector<int>(s.size(),-1));\\n      \\n      return f(0,s.size()-1,s,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1852912,
                "title": "using-lcs-with-detail-explanation-using-example",
                "content": "```class Solution {\\n    public int minInsertions(String s) {\\n        int len = s.length();\\n       int dp[][] = new int[len+1][len+1];\\n        String t = new StringBuilder(s).reverse().toString();\\n        \\n        for(int i=1; i<=len; i++  ){\\n            for(int j=1; j<=len; j++){\\n               if(s.charAt(i-1) == t.charAt(j-1)){\\n                   dp[i][j] = dp[i-1][j-1]+1;\\n               } \\n                else\\n                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\\n                \\n            }\\n        }\\n        \\n        return len-dp[len][len];\\n    }\\n}\\n```\\n\\n/**\\nWe take reverse of given string and try to find longest-common subsequence (LCS).\\n\\nFor example:- \\n\\nString s < - >  reverse of s\\nleetcode < - > edocteel\\nleETcodE < - > EdocTEel\\n\\nso LCS is \"e t e\" and if we remove it from the 2 words, we are left with\\n\\nletcod  < - >   docel\\n\\n\\nIf a string is palindrome then its reverse would also be palindrome, \\nor in other words each character would be present in order in both of the Strings.\\n\\nString left after removing th LCS chars is nothing but those characters which are not present in order in its reversed\\nString.\\nIt means if we insert \"letcod\" into \"edocteel\" or \"docel\" into \"leetcode\" then we would have our palindrome strings.\\n\\nHere we insert \"docel\" into \"leetcode\".\\nl e e D O C t c o d e E L   <-Palindrome\\n\\n\\n\\nConclusion:-  Find length of LCS,  subtract it from given string length and we have our answer. \\n\\nUpvote if it helps.\\n\\n\\nBelow is LCS approach for first given sample input.\\n\\n\\n______________________________\\n...........0   1   2   3   4   5 \\n ..........@  m   b   a   d   m    \\n0  @ .. 0   0   0   0   0   0    \\n1  m ... 0   1   1   1   1   1\\n2  d  .... 0   1   1   1   2   2\\n3  a ....  0   1   1   2   2   2\\n4  b .... 0   1   2   2   2   2\\n5  m ... 0   1   2   2   2   3 \\n____________________________\\n**/",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```class Solution {\\n    public int minInsertions(String s) {\\n        int len = s.length();\\n       int dp[][] = new int[len+1][len+1];\\n        String t = new StringBuilder(s).reverse().toString();\\n        \\n        for(int i=1; i<=len; i++  ){\\n            for(int j=1; j<=len; j++){\\n               if(s.charAt(i-1) == t.charAt(j-1)){\\n                   dp[i][j] = dp[i-1][j-1]+1;\\n               } \\n                else\\n                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\\n                \\n            }\\n        }\\n        \\n        return len-dp[len][len];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1788296,
                "title": "python-3-solution-lcs-aditya-verma",
                "content": "```\\nclass Solution:\\n    def minInsertions(self, X: str) -> int:\\n        \\n        Y = X[::-1]\\n        n = len(Y)\\n        m = len(X)\\n        \\n        t = [[0 for i in range(n+1)] for j in range(m+1)]\\n        \\n        for i in range(1,m+1):\\n            for j in range(1,n+1):\\n                \\n                if X[i-1]==Y[j-1]:\\n                    t[i][j] = 1+t[i-1][j-1]\\n                else:\\n                    t[i][j] = max(t[i-1][j],t[i][j-1])\\n        return n-t[n][n]\\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, X: str) -> int:\\n        \\n        Y = X[::-1]\\n        n = len(Y)\\n        m = len(X)\\n        \\n        t = [[0 for i in range(n+1)] for j in range(m+1)]\\n        \\n        for i in range(1,m+1):\\n            for j in range(1,n+1):\\n                \\n                if X[i-1]==Y[j-1]:\\n                    t[i][j] = 1+t[i-1][j-1]\\n                else:\\n                    t[i][j] = max(t[i-1][j],t[i][j-1])\\n        return n-t[n][n]\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772223,
                "title": "c-lcs-dp-top-down-easy-to-understand",
                "content": "# 1312. Minimum Insertion Steps to Make a String Palindrome\\n\\n**KNOCKCAT**\\n\\n```\\n1. Easy C++\\n2. Dynamic Programming.\\n3. Memoization with top - down.\\n4. Line by Line Explanation with Comments.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n```\\n[LeetCode](https://github.com/knockcat/Leetcode)\\n\\n**CODE WITH EXPLANATION**\\n\\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\n    \\n    int LCS(string s)\\n    {\\n        string r = s; // initialising r to s;\\n        \\n        reverse(r.begin(),r.end()); // reverse string for finding Longest Palindromic Subsequence\\n        \\n        //ideally both length are same\\n        int m = s.length(); // length of s;\\n        int n = r.length(); // lenght of r\\n        \\n        int t[m+1][n+1]; // matrix for memoization\\n        \\n        for(int i= 0; i<m+1; ++i)\\n        {\\n            for(int j = 0; j<n+1; ++j)\\n            {\\n                if(i == 0 || j == 0)    // initialising first row and first column to zero\\n                    t[i][j] = 0;        \\n            }\\n        }\\n        \\n        for(int i = 1;i< m+1; ++i)\\n        {\\n            for(int j = 1; j<n+1; ++j)\\n            {\\n                if(s[i-1] == r[j-1])\\n                    t[i][j] = 1 + t[i-1][j-1];\\n                    else\\n                        t[i][j] = max(t[i-1][j], t[i][j-1]);\\n            }\\n        }\\n        \\n         // string length - lPS will give no of minimum insertions  \\n        // we have to find out single character pair\\n        return s.length() - t[m][n];\\n        \\n    }\\n    \\npublic:\\n    int minInsertions(string s) {\\n        return LCS(s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n1. Easy C++\\n2. Dynamic Programming.\\n3. Memoization with top - down.\\n4. Line by Line Explanation with Comments.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n```\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\n    \\n    int LCS(string s)\\n    {\\n        string r = s; // initialising r to s;\\n        \\n        reverse(r.begin(),r.end()); // reverse string for finding Longest Palindromic Subsequence\\n        \\n        //ideally both length are same\\n        int m = s.length(); // length of s;\\n        int n = r.length(); // lenght of r\\n        \\n        int t[m+1][n+1]; // matrix for memoization\\n        \\n        for(int i= 0; i<m+1; ++i)\\n        {\\n            for(int j = 0; j<n+1; ++j)\\n            {\\n                if(i == 0 || j == 0)    // initialising first row and first column to zero\\n                    t[i][j] = 0;        \\n            }\\n        }\\n        \\n        for(int i = 1;i< m+1; ++i)\\n        {\\n            for(int j = 1; j<n+1; ++j)\\n            {\\n                if(s[i-1] == r[j-1])\\n                    t[i][j] = 1 + t[i-1][j-1];\\n                    else\\n                        t[i][j] = max(t[i-1][j], t[i][j-1]);\\n            }\\n        }\\n        \\n         // string length - lPS will give no of minimum insertions  \\n        // we have to find out single character pair\\n        return s.length() - t[m][n];\\n        \\n    }\\n    \\npublic:\\n    int minInsertions(string s) {\\n        return LCS(s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1737503,
                "title": "simple-dp-solution-different-approach-explained-with-example-c-easy",
                "content": "\\tExample string -> \"abc\"\\n\\ta -> already a palindrome\\n\\tb -> already a palindrome\\n\\tc -> already a palindrome\\n\\tab -> a b a = 1 (that is we only need to add 1)\\n\\tbc -> c b c = 1 (that is we only need to add 1)\\n\\tabc -> since a!=c -> min (ab,bc) +1 => min(1,1) +1 => 2  // min(dp[i+1][j],dp[i][j-1]) +1\\n\\t\\t\\t\\t\\tif we take  ab-> c+abac\\n\\t\\t\\t\\t\\tif we take  bc-> acbc+a\\n\\tANS = 2\\n\\t\\n\\tExample string -> \"aba\"\\n\\ta -> already a palindrome = 0\\n\\tb -> already a palindrome = 0\\n\\ta -> already a palindrome = 0\\n\\tab -> a b a = 1 (that is we only need to add 1)\\n\\tba -> a b a = 1 (that is we only need to add 1)\\n\\taba -> since a==a -> here we will only take b\\'s value (i.e. 0) //  dp[i+1][j-1]\\n\\tANS = 0\\n```\\nint minInsertions(string s) {\\n        int N=s.length();\\n        vector<vector<int>> dp(N, vector<int>(N,0));\\n        int k,j;\\n        for (int i=N-2; i>=0; i--) {\\n            for(j=i+1; j<N; j++) {\\n                 if (s[i]!=s[j]) {\\n                   dp[i][j]  = min(dp[i][j-1], dp[i+1][j]) + 1;\\n                } else {\\n                    dp[i][j] = dp[i+1][j-1];\\n                }\\n            }\\n           \\n        }\\n        return  dp[0][N-1];\\n    }\\n\\t\\n\\t\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nint minInsertions(string s) {\\n        int N=s.length();\\n        vector<vector<int>> dp(N, vector<int>(N,0));\\n        int k,j;\\n        for (int i=N-2; i>=0; i--) {\\n            for(j=i+1; j<N; j++) {\\n                 if (s[i]!=s[j]) {\\n                   dp[i][j]  = min(dp[i][j-1], dp[i+1][j]) + 1;\\n                } else {\\n                    dp[i][j] = dp[i+1][j-1];\\n                }\\n            }\\n           \\n        }\\n        return  dp[0][N-1];\\n    }\\n\\t\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1684010,
                "title": "recursion-top-down-bottom-up-solution",
                "content": "A huge shoutout to Aditya Verma\\'s DP Playlist. Without it, I would be far away from solving this problem.\\n*Before solving this question, solve Longest Common Subsequence, Longest Palindromic Subsequence*\\n\\n**Recursive Solution: (Does not pass all test cases)**\\nGoal: Figure out the minimum number of *insertions* to convert a string into a Palindrome.\\nIdea: \\n1. First, we can check if there is at least some instance of palindrome in a string. \\n\\tExample: \"mbadm\" - if we take a look at this test case, \"mam\" would be a palindrome. Thereafter, if we want \"bd\" to be a part of palindrome,  we will have to add 2 characters to the original string. Notice that  \"mam\" is the LCS of \"mbadm\". \\n\\t\\n\\tExample: \"zzazz\" - already a palindrome. No need to add anything.\\n\\n2. From both the example above, it is evident that the answer is s.size() - lengthOfLcs(s, reverse(s))\\t\\n\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        string reverseS = s;\\n        reverse(reverseS.begin(), reverseS.end());\\n        return s.size() - LCS(s, reverseS, s.size(), s.size());\\n    }\\n    int LCS(string& A, string& B, int m, int n) {\\n        if(!m || !n) return 0;\\n        \\n        if(A[m - 1] == B[n - 1]) return 1 + LCS(A, B, m - 1, n - 1);\\n        else return max(LCS(A, B, m - 1, n), LCS(A, B, m, n - 1));\\n    }\\n};\\n```\\n\\n**Top - Down [Recursion + Memoization]**\\n\\n```\\nclass Solution {\\npublic:\\n    int DP[501][501];\\n    int minInsertions(string s) {\\n        string reverseS = s;\\n        reverse(reverseS.begin(), reverseS.end());\\n        memset(DP, -1, sizeof(DP));\\n        return s.size() - LCS(s, reverseS, s.size(), s.size());\\n    }\\n\\t//Don\\'t forget to pass string A and B by reference. Otherwise the very long test cases cause TLE.\\n    int LCS(string& A, string& B, int m, int n) {\\n        if(!m || !n) return 0;\\n        if(DP[m][n] != -1) return DP[m][n];\\n        \\n        if(A[m - 1] == B[n - 1]) return DP[m][n] = 1 + LCS(A, B, m - 1, n - 1);\\n        else return DP[m][n] = max(LCS(A, B, m - 1, n), LCS(A, B, m, n - 1));\\n    }\\n};\\n```\\n\\n**Bottom - Up [Tabulation]**\\n\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string A) {\\n        string B = A;\\n        reverse(B.begin(), B.end());\\n        \\n        int n = A.size(), lcsLength = INT_MIN;\\n        \\n        int DP[n + 1][n + 1];\\n        \\n        for(int i = 0; i <= n; i++)\\n            for(int j = 0; j <= n; j++)\\n                if(!i || !j) DP[i][j] = 0;\\n        \\n        for(int i = 1; i <= n; i++)\\n            for(int j = 1; j <= n; j++) {\\n                if(A[i - 1] == B[j - 1]) DP[i][j] = 1 + DP[i - 1][j - 1];\\n                else DP[i][j] = max(DP[i - 1][j], DP[i][j - 1]);\\n                lcsLength = max(lcsLength, DP[i][j]);\\n            }\\n\\n        return n - lcsLength;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        string reverseS = s;\\n        reverse(reverseS.begin(), reverseS.end());\\n        return s.size() - LCS(s, reverseS, s.size(), s.size());\\n    }\\n    int LCS(string& A, string& B, int m, int n) {\\n        if(!m || !n) return 0;\\n        \\n        if(A[m - 1] == B[n - 1]) return 1 + LCS(A, B, m - 1, n - 1);\\n        else return max(LCS(A, B, m - 1, n), LCS(A, B, m, n - 1));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int DP[501][501];\\n    int minInsertions(string s) {\\n        string reverseS = s;\\n        reverse(reverseS.begin(), reverseS.end());\\n        memset(DP, -1, sizeof(DP));\\n        return s.size() - LCS(s, reverseS, s.size(), s.size());\\n    }\\n\\t//Don\\'t forget to pass string A and B by reference. Otherwise the very long test cases cause TLE.\\n    int LCS(string& A, string& B, int m, int n) {\\n        if(!m || !n) return 0;\\n        if(DP[m][n] != -1) return DP[m][n];\\n        \\n        if(A[m - 1] == B[n - 1]) return DP[m][n] = 1 + LCS(A, B, m - 1, n - 1);\\n        else return DP[m][n] = max(LCS(A, B, m - 1, n), LCS(A, B, m, n - 1));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string A) {\\n        string B = A;\\n        reverse(B.begin(), B.end());\\n        \\n        int n = A.size(), lcsLength = INT_MIN;\\n        \\n        int DP[n + 1][n + 1];\\n        \\n        for(int i = 0; i <= n; i++)\\n            for(int j = 0; j <= n; j++)\\n                if(!i || !j) DP[i][j] = 0;\\n        \\n        for(int i = 1; i <= n; i++)\\n            for(int j = 1; j <= n; j++) {\\n                if(A[i - 1] == B[j - 1]) DP[i][j] = 1 + DP[i - 1][j - 1];\\n                else DP[i][j] = max(DP[i - 1][j], DP[i][j - 1]);\\n                lcsLength = max(lcsLength, DP[i][j]);\\n            }\\n\\n        return n - lcsLength;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1539254,
                "title": "lsc-palindromic-subsequence",
                "content": "```\\nint longestPalindromicSubsequenceMemo(string& s, int i, int j, vector<vector<int>>& memo) {\\n        if(i > j)\\n            return 0;\\n        if(i == j)\\n            return 1;\\n        if(s[i] == s[j] && i+1 == j)\\n            return 2;\\n\\n        if(memo[i][j] != -1)\\n            return memo[i][j];\\n        if(s[i] == s[j]) {\\n            memo[i][j] =  2 + longestPalindromicSubsequenceMemo(s, i+1, j-1, memo);\\n        } else {\\n            memo[i][j] =  max(longestPalindromicSubsequenceMemo(s, i+1, j, memo), longestPalindromicSubsequenceMemo(s, i, j-1, memo));\\n        }\\n        return memo[i][j];\\n\\n    }\\n    \\n    int minInsertions(string s) {\\n        int n = s.length();\\n        vector<vector<int>> memo(n, vector<int>(n, -1));\\n        return n-longestPalindromicSubsequenceMemo(s, 0, n-1, memo);\\n    }\\n    \\n    /** LCS way*/\\n    int minInsertions(string s) {\\n        int n = s.length();\\n        vector<vector<int>> dp(n+1, vector<int>(n+1, 0));\\n        string rev = s;\\n        reverse(rev.begin(), rev.end());\\n        for(int i = 1; i <=n; i++) {\\n            for(int j = 1; j <=n; j++) {\\n                if(s[i-1] == rev[j-1])\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                else {\\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\\n                }\\n            }\\n        }\\n        return n - dp[n][n];\\n    }",
                "solutionTags": [],
                "code": "```\\nint longestPalindromicSubsequenceMemo(string& s, int i, int j, vector<vector<int>>& memo) {\\n        if(i > j)\\n            return 0;\\n        if(i == j)\\n            return 1;\\n        if(s[i] == s[j] && i+1 == j)\\n            return 2;\\n\\n        if(memo[i][j] != -1)\\n            return memo[i][j];\\n        if(s[i] == s[j]) {\\n            memo[i][j] =  2 + longestPalindromicSubsequenceMemo(s, i+1, j-1, memo);\\n        } else {\\n            memo[i][j] =  max(longestPalindromicSubsequenceMemo(s, i+1, j, memo), longestPalindromicSubsequenceMemo(s, i, j-1, memo));\\n        }\\n        return memo[i][j];\\n\\n    }\\n    \\n    int minInsertions(string s) {\\n        int n = s.length();\\n        vector<vector<int>> memo(n, vector<int>(n, -1));\\n        return n-longestPalindromicSubsequenceMemo(s, 0, n-1, memo);\\n    }\\n    \\n    /** LCS way*/\\n    int minInsertions(string s) {\\n        int n = s.length();\\n        vector<vector<int>> dp(n+1, vector<int>(n+1, 0));\\n        string rev = s;\\n        reverse(rev.begin(), rev.end());\\n        for(int i = 1; i <=n; i++) {\\n            for(int j = 1; j <=n; j++) {\\n                if(s[i-1] == rev[j-1])\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                else {\\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\\n                }\\n            }\\n        }\\n        return n - dp[n][n];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1473711,
                "title": "c-aditya-verma-explained",
                "content": "this question is exactly similar to the question where we were asked to find the minimum deletions to make a string palindrome.\\nwe need to find the LCS between the orignal string and the reversed string in order to get out LCS.\\nthis LCS actually is LPS(longest palindromic subsequence ) which means that it will be same in both the string and we only need to care about the left overs because they dont have any element for form palindrome.\\n\\n\\n```\\n int minInsertions(string s) {\\n        string a=s;\\n        reverse(s.begin(),s.end());\\n        int size=s.size();\\n        int dp[size+1][size+1];\\n        for(int i=0;i<=size;i++)\\n        {\\n            dp[i][0]=0;\\n            dp[0][i]=0;\\n        }\\n        for(int i=1;i<=size;i++)\\n        {\\n            for(int j=1;j<=size;j++)\\n            {\\n                if(s[i-1]==a[j-1])\\n                {\\n                    dp[i][j]=dp[i-1][j-1]+1;\\n                }\\n                else\\n                {\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n                }\\n            }\\n        }\\n        return size-dp[size][size];\\n    }\\n```\\n\\nplease upvote if you liked my solution.\\n#happy_coding",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n int minInsertions(string s) {\\n        string a=s;\\n        reverse(s.begin(),s.end());\\n        int size=s.size();\\n        int dp[size+1][size+1];\\n        for(int i=0;i<=size;i++)\\n        {\\n            dp[i][0]=0;\\n            dp[0][i]=0;\\n        }\\n        for(int i=1;i<=size;i++)\\n        {\\n            for(int j=1;j<=size;j++)\\n            {\\n                if(s[i-1]==a[j-1])\\n                {\\n                    dp[i][j]=dp[i-1][j-1]+1;\\n                }\\n                else\\n                {\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n                }\\n            }\\n        }\\n        return size-dp[size][size];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1421096,
                "title": "lcs-solution-faster-than-100-c-solutions",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int minInsertions(string a) \\n    {\\n        int n = a.size();\\n        string b = a;\\n        reverse(b.begin(), b.end());\\n        int dp[n + 1][n + 1];\\n        memset(dp, 0, sizeof(dp));\\n        for(int i = 1; i <= n; i++)\\n        {\\n            for(int j = 1; j <= n; j++)\\n            {\\n                if(a[i - 1] == b[j - 1]) dp[i][j] = 1 + dp[i - 1][j - 1];\\n                else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\\n            }\\n        }\\n        return n - dp[n][n];\\n    }\\n};\\n```\\nDon\\'t Forget To Upvote!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minInsertions(string a) \\n    {\\n        int n = a.size();\\n        string b = a;\\n        reverse(b.begin(), b.end());\\n        int dp[n + 1][n + 1];\\n        memset(dp, 0, sizeof(dp));\\n        for(int i = 1; i <= n; i++)\\n        {\\n            for(int j = 1; j <= n; j++)\\n            {\\n                if(a[i - 1] == b[j - 1]) dp[i][j] = 1 + dp[i - 1][j - 1];\\n                else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\\n            }\\n        }\\n        return n - dp[n][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 838050,
                "title": "c-using-longest-common-subsequence",
                "content": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n         \\n         string text1 = s;\\n         reverse(s.begin(), s.end());\\n         string text2 = s;\\n        \\n         int n = text1.size();\\n         int m = text2.size(); \\n         int dp[n+1][m+1];\\n        \\n         for(int i = 0; i<=n; i++)\\n         {\\n             for(int j = 0; j<=m; j++)\\n             {\\n                    dp[i][j] = 0;\\n             }\\n         }\\n        \\n        for(int i = 1; i<=n; i++)\\n        {\\n            for(int j = 1; j<=m; j++)\\n            {\\n                if(text1[i-1] == text2[j-1])\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                \\n                else\\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);   \\n            }\\n        }\\n         \\n        return (n - dp[n][m]);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n         \\n         string text1 = s;\\n         reverse(s.begin(), s.end());\\n         string text2 = s;\\n        \\n         int n = text1.size();\\n         int m = text2.size(); \\n         int dp[n+1][m+1];\\n        \\n         for(int i = 0; i<=n; i++)\\n         {\\n             for(int j = 0; j<=m; j++)\\n             {\\n                    dp[i][j] = 0;\\n             }\\n         }\\n        \\n        for(int i = 1; i<=n; i++)\\n        {\\n            for(int j = 1; j<=m; j++)\\n            {\\n                if(text1[i-1] == text2[j-1])\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                \\n                else\\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);   \\n            }\\n        }\\n         \\n        return (n - dp[n][m]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 536732,
                "title": "java-dp-solution",
                "content": "Denote `dp[i][j]` as the minimum number of insertions we need to make `s[i..j]` a palindrome. For chars at two ends, if they are the same, no further insertion needed. Otherwise, we just ignore any one of the ends and insert the same char as the other one in order to make `s[i...j-1]` or `s[i+1...j]` a palindrome. That is how we solve a problem with its subproblem.\\n\\nThus, based on the analysis above, we have transition function for this dynamic programming problem is\\n```\\nif s[i] == s[j]:\\n    dp[i][j] = dp[i+1][j-1]\\nelse:\\n    dp[i][j] = min(dp[i+1][j] + 1, dp[i][j-1] + 1)\\n```\\n\\nThe code in Java is in following segment. Note that our method is **from a short substring to longer one**. So the nested loop should handle to indecies in opposite ways or control the loop with starting point and size of substring. \\n\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int n = s.length();\\n        int[][] dp = new int[n][n];\\n        for(int j = 1; j < n; j++) {\\n            for(int i = j-1; i >= 0; i--) {\\n                if(s.charAt(i) == s.charAt(j)) {\\n                    if(j - i <= 1)\\n                        dp[i][j] = 0;   // Two adjasent chars are the same. No insertion needed.\\n                    else\\n                        dp[i][j] = dp[i+1][j-1];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i+1][j] + 1, dp[i][j-1] + 1);\\n                }\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nif s[i] == s[j]:\\n    dp[i][j] = dp[i+1][j-1]\\nelse:\\n    dp[i][j] = min(dp[i+1][j] + 1, dp[i][j-1] + 1)\\n```\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int n = s.length();\\n        int[][] dp = new int[n][n];\\n        for(int j = 1; j < n; j++) {\\n            for(int i = j-1; i >= 0; i--) {\\n                if(s.charAt(i) == s.charAt(j)) {\\n                    if(j - i <= 1)\\n                        dp[i][j] = 0;   // Two adjasent chars are the same. No insertion needed.\\n                    else\\n                        dp[i][j] = dp[i+1][j-1];\\n                } else {\\n                    dp[i][j] = Math.min(dp[i+1][j] + 1, dp[i][j-1] + 1);\\n                }\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 476599,
                "title": "javascript-easy-to-understand-dp",
                "content": "Let\\'s see, if the final string is a palindrome, then the most left and most right char must be the same.\\n\\nOK, back to the string we have. If we want the range `[left, right]` is a palindrome, then the `s[left] === s[right]` must be `true`. So, here we have 2 situations:\\n\\n- `s[left] === s[right]`: then we need to deal with range `[left + 1, right - 1]`\\n- `s[left] !== s[right]`: then we need to calculate `1 + min([left + 1, right], [left, right - 1])`\\n\\nSo here\\'s the recursion expression:\\n\\n```js\\nf(left, right) = s[left] === s[right] ? f(left + 1, right - 1) : 1 + min(f(left + 1, right), f(left, right - 1))\\n```\\n\\nAnd according to what we have above, we could write code such as this:\\n\\n```js\\nconst minInsertions = s => {\\n  const LEN = s.length;\\n  const dp = [];\\n  for (let i = 0; i < LEN; ++i) {\\n    dp[i] = new Uint16Array(LEN);\\n    dp[i][i + 1] = s[i] === s[i + 1] ? 0 : 1;\\n  }\\n  for (let i = 2; i < s.length; ++i) {\\n    for (j = 0; j < s.length - i; ++j) {\\n      dp[j][j + i] = s[j] === s[j + i]\\n        ? dp[j + 1][j + i - 1]\\n        : 1 + Math.min(dp[j + 1][j + i], dp[j][j + i - 1]);\\n    }\\n  }\\n  return dp[0][s.length - 1];\\n};\\n```\\n\\nIt costs O(n^2) time and O(n^2) space. But could we do more?\\n\\nActually we could just use O(n) space. By which, we can\\'t store all Intermediate variables, so we need to change the direction of traversal. The code may like this:\\n\\n```js\\nconst minInsertions = s => {\\n  const LEN = s.length;\\n  const dp = new Uint16Array(LEN);\\n  for (let i = LEN - 2; i >= 0; i--) {\\n    let prev = 0;\\n    for (let j = i + 1; j < LEN; j++) {\\n      const tmp = dp[j];\\n      dp[j] = s[i] == s[j] ? prev : 1 + Math.min(dp[j], dp[j - 1]);\\n      prev = tmp;\\n    }\\n  }\\n  return dp[s.length - 1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nf(left, right) = s[left] === s[right] ? f(left + 1, right - 1) : 1 + min(f(left + 1, right), f(left, right - 1))\\n```\n```js\\nconst minInsertions = s => {\\n  const LEN = s.length;\\n  const dp = [];\\n  for (let i = 0; i < LEN; ++i) {\\n    dp[i] = new Uint16Array(LEN);\\n    dp[i][i + 1] = s[i] === s[i + 1] ? 0 : 1;\\n  }\\n  for (let i = 2; i < s.length; ++i) {\\n    for (j = 0; j < s.length - i; ++j) {\\n      dp[j][j + i] = s[j] === s[j + i]\\n        ? dp[j + 1][j + i - 1]\\n        : 1 + Math.min(dp[j + 1][j + i], dp[j][j + i - 1]);\\n    }\\n  }\\n  return dp[0][s.length - 1];\\n};\\n```\n```js\\nconst minInsertions = s => {\\n  const LEN = s.length;\\n  const dp = new Uint16Array(LEN);\\n  for (let i = LEN - 2; i >= 0; i--) {\\n    let prev = 0;\\n    for (let j = i + 1; j < LEN; j++) {\\n      const tmp = dp[j];\\n      dp[j] = s[i] == s[j] ? prev : 1 + Math.min(dp[j], dp[j - 1]);\\n      prev = tmp;\\n    }\\n  }\\n  return dp[s.length - 1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 471217,
                "title": "tle-while-submitting-but-individual-test-case-passes",
                "content": "I\\'m getting TLE while submitting the code but while i ran my code on same input, it gets accepted.\\nBelow is my code: Input string: \"rvobfrrlvqfxrpbhfovkuahhphqpyhhzmhmtgrycobzbxfychioupeidgdkupnbcjnxkovkekgwbhssvrlwsaqadmudnekbheereujpfsmynldeokexsztwaudpcccvlggvorqvpmobcsekuboputkkpsgikhrzwndrxbrzwzounsjafmrnnnksnykfactbjsnmeyabqgqpjdycoenybcxtjdzeiwgwpyaaghslzgulqvondqbnkekyqnxamvznxwcuzvlrxizulvtmrkaezkipesyftqmxuuhyomcrvylrkaqpfnnzawf\"\\nint minInsertions(string s) {\\n        int len = s.length();\\n        int arr[len+1][len+1];\\n        \\n        for (int i = 0; i <= len; i++) { arr[i][0] = 0; arr[0][i] = 0; }\\n        \\n        for (int i = 1; i < len+1; i++) {\\n            for (int j = 1; j < len+1; j++) {\\n                if (s[i-1] == s[len-1-(j-1)]) arr[i][j] = arr[i-1][j-1] + 1;\\n                else arr[i][j] = max(arr[i-1][j], arr[i][j-1]);\\n            }\\n        }   \\n        return (len - arr[len][len]);\\n    }",
                "solutionTags": [],
                "code": "I\\'m getting TLE while submitting the code but while i ran my code on same input, it gets accepted.\\nBelow is my code: Input string: \"rvobfrrlvqfxrpbhfovkuahhphqpyhhzmhmtgrycobzbxfychioupeidgdkupnbcjnxkovkekgwbhssvrlwsaqadmudnekbheereujpfsmynldeokexsztwaudpcccvlggvorqvpmobcsekuboputkkpsgikhrzwndrxbrzwzounsjafmrnnnksnykfactbjsnmeyabqgqpjdycoenybcxtjdzeiwgwpyaaghslzgulqvondqbnkekyqnxamvznxwcuzvlrxizulvtmrkaezkipesyftqmxuuhyomcrvylrkaqpfnnzawf\"\\nint minInsertions(string s) {\\n        int len = s.length();\\n        int arr[len+1][len+1];\\n        \\n        for (int i = 0; i <= len; i++) { arr[i][0] = 0; arr[0][i] = 0; }\\n        \\n        for (int i = 1; i < len+1; i++) {\\n            for (int j = 1; j < len+1; j++) {\\n                if (s[i-1] == s[len-1-(j-1)]) arr[i][j] = arr[i-1][j-1] + 1;\\n                else arr[i][j] = max(arr[i-1][j], arr[i][j-1]);\\n            }\\n        }   \\n        return (len - arr[len][len]);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 470856,
                "title": "python-3-four-lines-dp-lcs",
                "content": "```\\nclass Solution:\\n    def minInsertions(self, S: str) -> int:\\n        L = len(S)\\n        DP = [[0 for _ in range(L+1)] for _ in range(L+1)]\\n        for i,j in itertools.product(range(L),range(L)): DP[i+1][j+1] = DP[i][j] + 1 if S[i] == S[L-1-j] else max(DP[i][j+1],DP[i+1][j])\\n        return L - DP[-1][-1]\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, S: str) -> int:\\n        L = len(S)\\n        DP = [[0 for _ in range(L+1)] for _ in range(L+1)]\\n        for i,j in itertools.product(range(L),range(L)): DP[i+1][j+1] = DP[i][j] + 1 if S[i] == S[L-1-j] else max(DP[i][j+1],DP[i+1][j])\\n        return L - DP[-1][-1]\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "codeTag": "Java"
            },
            {
                "id": 470704,
                "title": "java-dfs-with-memoization-similar-to-1216-valid-palindrome-iii",
                "content": "```java\\nclass Solution {\\n    public int minInsertions(String s) {\\n        if (s == null || s.length() == 0) return 0;\\n        int[][] min = new int[s.length()][s.length()];\\n        for (int[] row : min) Arrays.fill(row, -1);\\n        return dp(s, 0, s.length() - 1, min);\\n    }\\n    private int dp(String s, int l, int r, int[][] min) {\\n        if (l >= r) return 0;\\n        if (min[l][r] >= 0) return min[l][r];\\n        min[l][r] = s.charAt(l) == s.charAt(r) ? dp(s, l + 1, r - 1, min) : Math.min(dp(s, l + 1, r, min), dp(s, l, r - 1, min)) + 1;\\n        return min[l][r];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```java\\nclass Solution {\\n    public int minInsertions(String s) {\\n        if (s == null || s.length() == 0) return 0;\\n        int[][] min = new int[s.length()][s.length()];\\n        for (int[] row : min) Arrays.fill(row, -1);\\n        return dp(s, 0, s.length() - 1, min);\\n    }\\n    private int dp(String s, int l, int r, int[][] min) {\\n        if (l >= r) return 0;\\n        if (min[l][r] >= 0) return min[l][r];\\n        min[l][r] = s.charAt(l) == s.charAt(r) ? dp(s, l + 1, r - 1, min) : Math.min(dp(s, l + 1, r, min), dp(s, l, r - 1, min)) + 1;\\n        return min[l][r];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 470698,
                "title": "java-small-code-with-recursion-with-memoization",
                "content": "```\\n int[][]dp;\\n    public int minInsertions(String s) {\\n        int n = s.length();\\n        dp = new int[n][n];\\n        for(int i=0; i<n; i++) {\\n            Arrays.fill(dp[i], Integer.MAX_VALUE);\\n        }\\n        int res = find(s.toCharArray(), 0, s.length()-1);\\n        return res;\\n    }\\n    \\n    int find(char[] str, int i, int j) {\\n        if(i>=j) return 0;\\n        if(dp[i][j] != Integer.MAX_VALUE) return dp[i][j];\\n        \\n        if(str[i] == str[j]) {\\n            dp[i][j] = find(str, i+1, j-1);\\n        } else {\\n            dp[i][j] = Math.min(find(str,i+1,j)+1, find(str,i,j-1)+1);\\n        }\\n        \\n        return dp[i][j];\\n    }",
                "solutionTags": [],
                "code": "```\\n int[][]dp;\\n    public int minInsertions(String s) {\\n        int n = s.length();\\n        dp = new int[n][n];\\n        for(int i=0; i<n; i++) {\\n            Arrays.fill(dp[i], Integer.MAX_VALUE);\\n        }\\n        int res = find(s.toCharArray(), 0, s.length()-1);\\n        return res;\\n    }\\n    \\n    int find(char[] str, int i, int j) {\\n        if(i>=j) return 0;\\n        if(dp[i][j] != Integer.MAX_VALUE) return dp[i][j];\\n        \\n        if(str[i] == str[j]) {\\n            dp[i][j] = find(str, i+1, j-1);\\n        } else {\\n            dp[i][j] = Math.min(find(str,i+1,j)+1, find(str,i,j-1)+1);\\n        }\\n        \\n        return dp[i][j];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 470690,
                "title": "java-recursion-memoization",
                "content": "```\\nclass Solution {\\n    public static int func(String s, int start, int end, int[][] dp) {\\n        if(start >= end) return 0;\\n        if(dp[start][end] != -1) return dp[start][end];\\n        if(s.charAt(start) == s.charAt(end)) return dp[start][end] = func(s, start + 1, end - 1, dp);\\n        int x1 = func(s, start + 1, end, dp);\\n        int x2 = func(s, start, end - 1, dp);\\n        return dp[start][end] = 1 + Math.min(x1, x2);\\n    }\\n    public int minInsertions(String s) {\\n        int n = s.length();\\n        int[][] dp = new int[n][n];\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < n; j++) dp[i][j] = - 1;\\n        }\\n        return func(s, 0 , n - 1, dp);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public static int func(String s, int start, int end, int[][] dp) {\\n        if(start >= end) return 0;\\n        if(dp[start][end] != -1) return dp[start][end];\\n        if(s.charAt(start) == s.charAt(end)) return dp[start][end] = func(s, start + 1, end - 1, dp);\\n        int x1 = func(s, start + 1, end, dp);\\n        int x2 = func(s, start, end - 1, dp);\\n        return dp[start][end] = 1 + Math.min(x1, x2);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3919485,
                "title": "python-easy-dp-lcs-approach",
                "content": "Intuition: \\nWe need to find the minimum insertions required to make a string palindrome. Let us keep the \\u201Cminimum\\u201D criteria aside and think, how can we make any given string palindrome by inserting characters?\\n\\nThe easiest way is to add the reverse of the string at the back of the original string. This will make any string palindrome.\\n\\neg: str - \\'abcaa\\'\\n      palindromic str - \\'abcaaaacba\\'\\n\\nHere the number of characters inserted will be equal to n (length of the string). This is the maximum number of characters we can insert to make strings palindrome.\\n\\nThe problem states us to find the minimum of insertions. Let us try to figure it out:\\n\\nTo minimize the insertions, we will first try to refrain from adding those characters again which are already making the given string palindrome. For the given example, \\u201Caaa\\u201D, \\u201Caba\\u201D,\\u201Daca\\u201D, any of these are themselves palindromic components of the string. We can take any of them( as all are of equal length) and keep them intact. (let\\u2019s say \\u201Caaa\\u201D).\\n\\nNow, there are two characters(\\u2018b\\u2019 and \\u2018c\\u2019) remaining which prevent the string from being a palindrome. We can reverse their order and add them to the string to make the entire string palindrome.\\n\\nWe can do this by taking some other components (like \\u201Caca\\u201D) as well. \\n\\nIn order to minimize the insertions, we need to find the length of the longest palindromic component or in other words, the longest palindromic subsequence.\\n\\nMinimum Insertion required = n(length of the string) \\u2013 length of longest palindromic subsequence.\\n\\nApproach:\\n\\nThe algorithm is stated as follows:\\n\\nWe are given a string (say s), store its length as n.\\nFind the length of the longest palindromic subsequence\\nReturn n-k as answer.\\n\\n```\\n#Tabulation(Top-Down)\\n#Time Complexity: O(n^2)\\n#Space Complexity: O(n^2)\\nclass Solution1:\\n    def minInsertions(self, s: str) -> int:\\n        n=len(s)\\n        s2=s[-1::-1]\\n        dp=[[0 for j in range(n+1)] for i in range(n+1)]\\n        for i in range(1,n+1):\\n            for j in range(1,n+1):\\n                if s[i-1]==s2[j-1]:\\n                    dp[i][j]=1+dp[i-1][j-1]\\n                else:\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1])\\n        return n-dp[n][n]\\n    \\n#Space Optimization\\n#Time Complexity: O(n^2)\\n#Space Complexity: O(n)\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        n=len(s)\\n        s2=s[-1::-1]\\n        prev=[0]*(n+1)\\n        for i in range(1,n+1):\\n            curr=[0]*(n+1)\\n            for j in range(1,n+1):\\n                if s[i-1]==s2[j-1]:\\n                    curr[j]=1+prev[j-1]\\n                else:\\n                    curr[j]=max(prev[j],curr[j-1])\\n            prev=curr[:]\\n        return n-prev[n]    \\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\n#Tabulation(Top-Down)\\n#Time Complexity: O(n^2)\\n#Space Complexity: O(n^2)\\nclass Solution1:\\n    def minInsertions(self, s: str) -> int:\\n        n=len(s)\\n        s2=s[-1::-1]\\n        dp=[[0 for j in range(n+1)] for i in range(n+1)]\\n        for i in range(1,n+1):\\n            for j in range(1,n+1):\\n                if s[i-1]==s2[j-1]:\\n                    dp[i][j]=1+dp[i-1][j-1]\\n                else:\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1])\\n        return n-dp[n][n]\\n    \\n#Space Optimization\\n#Time Complexity: O(n^2)\\n#Space Complexity: O(n)\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        n=len(s)\\n        s2=s[-1::-1]\\n        prev=[0]*(n+1)\\n        for i in range(1,n+1):\\n            curr=[0]*(n+1)\\n            for j in range(1,n+1):\\n                if s[i-1]==s2[j-1]:\\n                    curr[j]=1+prev[j-1]\\n                else:\\n                    curr[j]=max(prev[j],curr[j-1])\\n            prev=curr[:]\\n        return n-prev[n]    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887907,
                "title": "c-dp-memoization-tabulation",
                "content": "Method 1 MEMOIZATION\\n```\\nclass Solution {\\n    int help(int i,int j,vector<vector<int>>& dp,string & s){  // i from left and j form right\\n        if(i>=j){  //pass or equal then 0\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int ans=0;\\n        if(s[i]==s[j]){\\n            ans=help(i+1,j-1,dp,s);  //equal hai to insert karne ki need nhi\\n        }\\n        else{\\n            ans=1+min(help(i+1,j,dp,s),help(i,j-1,dp,s)); //equal nhi to check karke mininum insert kisme kare\\n        }\\n        return dp[i][j]=ans;\\n    }\\npublic:\\n    int minInsertions(string s) {\\n        int n=s.size();\\n        vector<vector<int>>dp(n,vector<int>(n,-1));\\n        return help(0,n-1,dp,s);\\n    }\\n};\\n```\\nMETHOD 2 TABULATION\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.size();\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n        \\n        for (int len = 2; len <= n; ++len) {\\n            for (int i = 0; i <= n - len; ++i) {\\n                int j = i + len - 1;\\n                if (s[i] == s[j]) {\\n                    dp[i][j] = dp[i + 1][j - 1];\\n                } else {\\n                    dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j - 1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[0][n - 1];\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/698dbd73-1930-409b-8656-7e94605d95f1_1691933144.371001.webp)\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int help(int i,int j,vector<vector<int>>& dp,string & s){  // i from left and j form right\\n        if(i>=j){  //pass or equal then 0\\n            return 0;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int ans=0;\\n        if(s[i]==s[j]){\\n            ans=help(i+1,j-1,dp,s);  //equal hai to insert karne ki need nhi\\n        }\\n        else{\\n            ans=1+min(help(i+1,j,dp,s),help(i,j-1,dp,s)); //equal nhi to check karke mininum insert kisme kare\\n        }\\n        return dp[i][j]=ans;\\n    }\\npublic:\\n    int minInsertions(string s) {\\n        int n=s.size();\\n        vector<vector<int>>dp(n,vector<int>(n,-1));\\n        return help(0,n-1,dp,s);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.size();\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n        \\n        for (int len = 2; len <= n; ++len) {\\n            for (int i = 0; i <= n - len; ++i) {\\n                int j = i + len - 1;\\n                if (s[i] == s[j]) {\\n                    dp[i][j] = dp[i + 1][j - 1];\\n                } else {\\n                    dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j - 1]);\\n                }\\n            }\\n        }\\n        \\n        return dp[0][n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841478,
                "title": "c-clean-dp-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.size();\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n\\n        for (int len = 2; len <= n; len++) {\\n            for (int i = 0; i < n - len + 1; i++) {\\n                int j = i + len - 1;\\n                if (s[i] == s[j])\\n                    dp[i][j] = dp[i + 1][j - 1];\\n                else\\n                    dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1;\\n            }\\n        }\\n\\n        return dp[0][n - 1];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.size();\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n\\n        for (int len = 2; len <= n; len++) {\\n            for (int i = 0; i < n - len + 1; i++) {\\n                int j = i + len - 1;\\n                if (s[i] == s[j])\\n                    dp[i][j] = dp[i + 1][j - 1];\\n                else\\n                    dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1;\\n            }\\n        }\\n\\n        return dp[0][n - 1];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786594,
                "title": "c-dp-tabulation-space-optimized-simple",
                "content": "# Intuition\\n\\n```\\n* Check longest common subsequence between string s and it\\'s reverse string t.\\n* len(s) - lcs(s, t) will be the number of non-matching characters.\\n* Hence we need to add those many characters.\\n```\\n\\n# Tabulation (Not space optimized)\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        string t = s; reverse(t.begin(), t.end()); \\n        int n = s.size();\\n        return n - lcs(s, t, n);\\n    }\\n\\nprivate:\\n    int lcs(string& s, string& t, int& n) {\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (s[i-1] == t[j-1]) dp[i][j] = 1 + dp[i-1][j-1];\\n                else dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\\n            }\\n        }\\n\\n        return dp[n][n];\\n    }\\n};\\n```\\n\\n# Tabulation (Space optimized)\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.size();\\n        return n - lcs(s, n);\\n    }\\n\\nprivate:\\n    int lcs(string& s, int& n) {\\n        vector<int> prev(n + 1, 0);\\n        vector<int> curr(n + 1, 0);\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (s[i-1] == s[n-j]) curr[j] = 1 + prev[j-1];\\n                else curr[j] = max(prev[j], curr[j-1]);\\n            }\\n            prev = curr;\\n        }\\n\\n        return prev[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\n* Check longest common subsequence between string s and it\\'s reverse string t.\\n* len(s) - lcs(s, t) will be the number of non-matching characters.\\n* Hence we need to add those many characters.\\n```\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        string t = s; reverse(t.begin(), t.end()); \\n        int n = s.size();\\n        return n - lcs(s, t, n);\\n    }\\n\\nprivate:\\n    int lcs(string& s, string& t, int& n) {\\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (s[i-1] == t[j-1]) dp[i][j] = 1 + dp[i-1][j-1];\\n                else dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\\n            }\\n        }\\n\\n        return dp[n][n];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.size();\\n        return n - lcs(s, n);\\n    }\\n\\nprivate:\\n    int lcs(string& s, int& n) {\\n        vector<int> prev(n + 1, 0);\\n        vector<int> curr(n + 1, 0);\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (s[i-1] == s[n-j]) curr[j] = 1 + prev[j-1];\\n                else curr[j] = max(prev[j], curr[j-1]);\\n            }\\n            prev = curr;\\n        }\\n\\n        return prev[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783936,
                "title": "c-tabulation-memory-optimization-best-and-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\njust removing the letter count from length of string and length of longest common palindromic subsequence.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N X N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        // n-len(l c palindromic subseq).\\n        int n=s.size();\\n        string s1=s;\\n        reverse(s.begin(), s.end());\\n        string s2=s;\\n        vector<int> prev(n+1, 0), curr(n+1, 0);\\n        for (int i=1; i<=n; i++){\\n            for (int j=1; j<=n; j++){\\n                if (s1[i-1]==s2[j-1]){\\n                    curr[j]=prev[j-1]+1;\\n                }else{\\n                    curr[j]=max(curr[j-1], prev[j]);\\n                }\\n            }prev=curr;\\n        }\\n        int palin=prev[n];\\n        int ans=n-palin;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        // n-len(l c palindromic subseq).\\n        int n=s.size();\\n        string s1=s;\\n        reverse(s.begin(), s.end());\\n        string s2=s;\\n        vector<int> prev(n+1, 0), curr(n+1, 0);\\n        for (int i=1; i<=n; i++){\\n            for (int j=1; j<=n; j++){\\n                if (s1[i-1]==s2[j-1]){\\n                    curr[j]=prev[j-1]+1;\\n                }else{\\n                    curr[j]=max(curr[j-1], prev[j]);\\n                }\\n            }prev=curr;\\n        }\\n        int palin=prev[n];\\n        int ans=n-palin;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749746,
                "title": "simple-solution-using-edit-distance",
                "content": "int minInsertions(string s) \\n    {\\n     string rev=s;\\tint n=s.size();\\n\\t\\t reverse(rev.begin(),rev.end());\\n\\t   int matrix[n+1][n+1];\\n\\t   for(int i=0;i<n+1;i++)\\n\\t\\t {\\n\\t        matrix[i][0]=i;\\n\\t        matrix[0][i]=i;\\n\\t\\t }\\n\\t   for(int i=1;i<n+1;i++)\\n\\t   for(int j=1;j<n+1;j++)\\n\\t   {\\n\\t       if(s[i-1]==rev[j-1])\\n\\t        matrix[i][j]=matrix[i-1][j-1];\\n\\t       else\\n\\t        matrix[i][j]=1+min(matrix[i][j-1],matrix[i-1][j]);\\n\\t   }\\n\\t   return matrix[n][n]/2;\\n\\t}\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "int minInsertions(string s) \\n    {\\n     string rev=s;\\tint n=s.size();\\n\\t\\t reverse(rev.begin(),rev.end());\\n\\t   int matrix[n+1][n+1];\\n\\t   for(int i=0;i<n+1;i++)\\n\\t\\t {\\n\\t        matrix[i][0]=i;\\n\\t        matrix[0][i]=i;\\n\\t\\t }\\n\\t   for(int i=1;i<n+1;i++)\\n\\t   for(int j=1;j<n+1;j++)\\n\\t   {\\n\\t       if(s[i-1]==rev[j-1])\\n\\t        matrix[i][j]=matrix[i-1][j-1];\\n\\t       else\\n\\t        matrix[i][j]=1+min(matrix[i][j-1],matrix[i-1][j]);\\n\\t   }\\n\\t   return matrix[n][n]/2;\\n\\t}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3740334,
                "title": "top-down-approach-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis question is a **variation of longest palindromic subsequence**(Q.no- 516).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind the length of LCS of given string and it\\'s reverse. The **difference of the length of string and the LCS will give minimum no. of insertions and deletion** in the string to make it a palindrome\\n# Complexity\\n- Time complexity: **O(n*n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: **O(n*n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int LCS(string a,string b)\\n    {\\n        int n=a.size(),m=b.size();\\n        int t[n+1][m+1];\\n        for(int i=0;i<n+1;i++)\\n            t[i][0]=0;\\n        for(int j=0;j<m+1;j++)\\n            t[0][j]=0;\\n        for(int i=1;i<n+1;i++)\\n            for(int j=1;j<m+1;j++)\\n            {\\n                if(a[i-1]==b[j-1])\\n                    t[i][j]=1+t[i-1][j-1];\\n                else\\n                    t[i][j]=max(t[i-1][j],t[i][j-1]);\\n            }\\n        return t[n][m];\\n\\n    }\\n    int minInsertions(string s) {\\n        int l=s.size();\\n        if(l==1)\\n        return 0;\\n        string sr;\\n        sr.append(s);\\n        reverse(s.begin(),s.end());\\n        return l-LCS(s,sr);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int LCS(string a,string b)\\n    {\\n        int n=a.size(),m=b.size();\\n        int t[n+1][m+1];\\n        for(int i=0;i<n+1;i++)\\n            t[i][0]=0;\\n        for(int j=0;j<m+1;j++)\\n            t[0][j]=0;\\n        for(int i=1;i<n+1;i++)\\n            for(int j=1;j<m+1;j++)\\n            {\\n                if(a[i-1]==b[j-1])\\n                    t[i][j]=1+t[i-1][j-1];\\n                else\\n                    t[i][j]=max(t[i-1][j],t[i][j-1]);\\n            }\\n        return t[n][m];\\n\\n    }\\n    int minInsertions(string s) {\\n        int l=s.size();\\n        if(l==1)\\n        return 0;\\n        string sr;\\n        sr.append(s);\\n        reverse(s.begin(),s.end());\\n        return l-LCS(s,sr);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589042,
                "title": "easiest-solution-just-one-line-of-logic-basic-intuition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThink of applying Longest Common Subsequence to it\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake a string, then reverse it \\nNow, for string to be a palindrome, the original and reversed string should be equal\\n\\n\\nNow observe that when you remove longest common subsequence of both strings(orginal and reversed string) you will be left with characters that are not forming a palindrome i.e we need to insert the copy of these left characters to original string to make it a plaindrome\\n\\n# Complexity\\n- Time complexity: O(mn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n   \\n    Where m:length of string\\n          n:length of reversed string\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        String s1 = \"\";\\n        for(int i=0;i<s.length();i++){\\n            s1 = s.charAt(i) + s1;\\n        }\\n        int lcs = lcs(s1,s,s.length(),s.length());\\n\\n        // Main Logic //\\n\\n        return s.length()-lcs;\\n\\n        //            // \\n\\n    }\\n    public int lcs(String str1, String str2, int m, int n){\\n        int[][] dp = new int[m+1][n+1];\\n        for(int i=0;i<=m;i++){\\n            for(int j=0;j<=n;j++){\\n                if(i==0||j==0) dp[i][j]=0;\\n            }\\n        }\\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                if(str1.charAt(i-1)==str2.charAt(j-1))\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                else{\\n                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        String s1 = \"\";\\n        for(int i=0;i<s.length();i++){\\n            s1 = s.charAt(i) + s1;\\n        }\\n        int lcs = lcs(s1,s,s.length(),s.length());\\n\\n        // Main Logic //\\n\\n        return s.length()-lcs;\\n\\n        //            // \\n\\n    }\\n    public int lcs(String str1, String str2, int m, int n){\\n        int[][] dp = new int[m+1][n+1];\\n        for(int i=0;i<=m;i++){\\n            for(int j=0;j<=n;j++){\\n                if(i==0||j==0) dp[i][j]=0;\\n            }\\n        }\\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                if(str1.charAt(i-1)==str2.charAt(j-1))\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                else{\\n                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3552985,
                "title": "c-lcs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int lcs(string &s, string&t,int i1, int i2, vector<vector<int>>&dp)\\n    {\\n        if(i1<0 || i2<0)return 0;\\n        if(dp[i1][i2]!=-1)return dp[i1][i2];\\n        if(s[i1]==t[i2])return dp[i1][i2]=1+lcs(s,t,i1-1,i2-1,dp);\\n        return dp[i1][i2]=max(lcs(s,t,i1-1,i2,dp),lcs(s,t,i1,i2-1,dp));\\n    }\\npublic:\\n    int minInsertions(string s) {\\n        int ans = 0;\\n       int p1 = 0, p2 = s.length()-1;\\n       vector<vector<int>>dp(s.length(),vector<int>(s.length(),-1));\\n       string t = s;\\n       reverse(t.begin(),t.end());\\n       int x = lcs(s,t,s.length()-1,s.length()-1,dp);\\n       return s.length()-x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int lcs(string &s, string&t,int i1, int i2, vector<vector<int>>&dp)\\n    {\\n        if(i1<0 || i2<0)return 0;\\n        if(dp[i1][i2]!=-1)return dp[i1][i2];\\n        if(s[i1]==t[i2])return dp[i1][i2]=1+lcs(s,t,i1-1,i2-1,dp);\\n        return dp[i1][i2]=max(lcs(s,t,i1-1,i2,dp),lcs(s,t,i1,i2-1,dp));\\n    }\\npublic:\\n    int minInsertions(string s) {\\n        int ans = 0;\\n       int p1 = 0, p2 = s.length()-1;\\n       vector<vector<int>>dp(s.length(),vector<int>(s.length(),-1));\\n       string t = s;\\n       reverse(t.begin(),t.end());\\n       int x = lcs(s,t,s.length()-1,s.length()-1,dp);\\n       return s.length()-x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525992,
                "title": "shortest-simplest-code-ever-easy-to-understand-rec-memo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        String ss = \"\";\\n        for(int i =s.length()-1; i>=0; i--){\\n            ss+= s.charAt(i);\\n        }\\n        int n = s.length();\\n        int dp[][] = new int[n][n];\\n        for(int r[] : dp) Arrays.fill(r,-1);\\n        int lcs= f( 0,0, s, ss, dp);\\n        return n - lcs;\\n\\n    }\\n    private int f(int i ,int j ,String s ,String ss , int dp[][] ){\\n        if( i>s.length()-1 || j>ss.length()-1) return 0; \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        if( s.charAt(i)==ss.charAt(j))      \\n            return dp[i][j]= 1+f( i+1, j+1, s, ss, dp);\\n        return dp[i][j]= Math.max(f( i, j+1, s,ss,dp), f(i+1, j, s, ss, dp));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        String ss = \"\";\\n        for(int i =s.length()-1; i>=0; i--){\\n            ss+= s.charAt(i);\\n        }\\n        int n = s.length();\\n        int dp[][] = new int[n][n];\\n        for(int r[] : dp) Arrays.fill(r,-1);\\n        int lcs= f( 0,0, s, ss, dp);\\n        return n - lcs;\\n\\n    }\\n    private int f(int i ,int j ,String s ,String ss , int dp[][] ){\\n        if( i>s.length()-1 || j>ss.length()-1) return 0; \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        if( s.charAt(i)==ss.charAt(j))      \\n            return dp[i][j]= 1+f( i+1, j+1, s, ss, dp);\\n        return dp[i][j]= Math.max(f( i, j+1, s,ss,dp), f(i+1, j, s, ss, dp));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448585,
                "title": "ex-amazon-explains-a-solution-with-a-video-python-javascript-java-and-c",
                "content": "# My youtube channel - KeetCode(Ex-Amazon)\\nI create 155 videos for leetcode questions as of April 24, 2023. I believe my channel helps you prepare for the coming technical interviews. Please subscribe my channel!\\n\\n### Please subscribe my channel - KeetCode(Ex-Amazon) from here.\\n\\n**I created a video for this question. I believe you can understand easily with visualization.** \\n\\n**My youtube channel - KeetCode(Ex-Amazon)**\\nThere is my channel link under picture in LeetCode profile.\\nhttps://leetcode.com/niits/\\n\\n![FotoJet (57).jpg](https://assets.leetcode.com/users/images/2154d840-dc22-454b-9993-09603e41de4c_1682286305.0137026.jpeg)\\n\\n\\n# Intuition\\nUse 1D dynamic programming to store minimum steps\\n\\n# Approach\\n1. Get the length of the input string s and store it in a variable n.\\n\\n2. Create a list dp of length n filled with zeros to store the dynamic programming values.\\n\\n3. Loop through the indices of the string s from n - 2 to 0 in reverse order using for i in range(n - 2, -1, -1):.\\n\\n4. Inside the outer loop, initialize a variable prev to 0 to keep track of the previous dynamic programming value.\\n\\n5. Loop through the indices of the string s from i + 1 to n using for j in range(i + 1, n):.\\n\\n6. Inside the inner loop, store the current dynamic programming value in a temporary variable temp for future reference.\\n\\n7. Check if the characters at indices i and j in the string s are the same using if s[i] == s[j]:.\\n\\n8. If the characters are the same, update the dynamic programming value at index j in the dp list with the previous dynamic programming value prev.\\n\\n9. If the characters are different, update the dynamic programming value at index j in the dp list with the minimum of the dynamic programming values at index j and j-1 in the dp list, incremented by 1.\\n\\n10. Update the prev variable with the temporary variable temp.\\n\\n11. After the inner loop completes, the dynamic programming values in the dp list represent the minimum number of insertions needed to make s a palindrome.\\n\\n12. Return the dynamic programming value at index n-1 in the dp list as the final result. This represents the minimum number of insertions needed to make the entire string s a palindrome.\\n\\n\\n---\\n\\n\\n**If you don\\'t understand the algorithm, let\\'s check my video solution.\\nThere is my channel link under picture in LeetCode profile.**\\nhttps://leetcode.com/niits/\\n\\n\\n---\\n\\n# Complexity\\n- Time complexity: O(n^2)\\nn is the length of the input string \\'s\\'. This is because there are two nested loops. The outer loop runs from n-2 to 0, and the inner loop runs from i+1 to n-1. In the worst case, the inner loop iterates n-1 times for each value of i, resulting in a total of (n-2) + (n-3) + ... + 1 = n(n-1)/2 iterations. Therefore, the overall time complexity is O(n^2).\\n\\n- Space complexity: O(n)\\nn is the length of the input string \\'s\\'. This is because the code uses an array \\'dp\\' of size n to store the minimum number of insertions required at each position in \\'s\\'. Hence, the space complexity is linear with respect to the length of the input string.\\n\\n# Python\\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        n = len(s)\\n        dp = [0] * n\\n\\n        for i in range(n - 2, -1, -1):\\n            prev = 0\\n\\n            for j in range(i + 1, n):\\n                temp = dp[j]\\n\\n                if s[i] == s[j]:\\n                    dp[j] = prev\\n                else:\\n                    dp[j] = min(dp[j], dp[j-1]) + 1\\n            \\n                prev = temp\\n        \\n        return dp[n-1]\\n```\\n# JavaScript\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minInsertions = function(s) {\\n    const n = s.length;\\n    const dp = new Array(n).fill(0);\\n\\n    for (let i = n - 2; i >= 0; i--) {\\n        let prev = 0;\\n\\n        for (let j = i + 1; j < n; j++) {\\n            const temp = dp[j];\\n\\n            if (s[i] === s[j]) {\\n                dp[j] = prev;\\n            } else {\\n                dp[j] = Math.min(dp[j], dp[j-1]) + 1;\\n            }\\n\\n            prev = temp;\\n        }\\n    }\\n\\n    return dp[n-1];    \\n};\\n```\\n# Java\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int n = s.length();\\n        int[] dp = new int[n];\\n\\n        for (int i = n - 2; i >= 0; i--) {\\n            int prev = 0;\\n\\n            for (int j = i + 1; j < n; j++) {\\n                int temp = dp[j];\\n\\n                if (s.charAt(i) == s.charAt(j)) {\\n                    dp[j] = prev;\\n                } else {\\n                    dp[j] = Math.min(dp[j], dp[j-1]) + 1;\\n                }\\n\\n                prev = temp;\\n            }\\n        }\\n\\n        return dp[n-1];        \\n    }\\n}\\n```\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.length();\\n        vector<int> dp(n, 0);\\n\\n        for (int i = n - 2; i >= 0; i--) {\\n            int prev = 0;\\n\\n            for (int j = i + 1; j < n; j++) {\\n                int temp = dp[j];\\n\\n                if (s[i] == s[j]) {\\n                    dp[j] = prev;\\n                } else {\\n                    dp[j] = min(dp[j], dp[j-1]) + 1;\\n                }\\n\\n                prev = temp;\\n            }\\n        }\\n\\n        return dp[n-1];        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        n = len(s)\\n        dp = [0] * n\\n\\n        for i in range(n - 2, -1, -1):\\n            prev = 0\\n\\n            for j in range(i + 1, n):\\n                temp = dp[j]\\n\\n                if s[i] == s[j]:\\n                    dp[j] = prev\\n                else:\\n                    dp[j] = min(dp[j], dp[j-1]) + 1\\n            \\n                prev = temp\\n        \\n        return dp[n-1]\\n```\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minInsertions = function(s) {\\n    const n = s.length;\\n    const dp = new Array(n).fill(0);\\n\\n    for (let i = n - 2; i >= 0; i--) {\\n        let prev = 0;\\n\\n        for (let j = i + 1; j < n; j++) {\\n            const temp = dp[j];\\n\\n            if (s[i] === s[j]) {\\n                dp[j] = prev;\\n            } else {\\n                dp[j] = Math.min(dp[j], dp[j-1]) + 1;\\n            }\\n\\n            prev = temp;\\n        }\\n    }\\n\\n    return dp[n-1];    \\n};\\n```\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int n = s.length();\\n        int[] dp = new int[n];\\n\\n        for (int i = n - 2; i >= 0; i--) {\\n            int prev = 0;\\n\\n            for (int j = i + 1; j < n; j++) {\\n                int temp = dp[j];\\n\\n                if (s.charAt(i) == s.charAt(j)) {\\n                    dp[j] = prev;\\n                } else {\\n                    dp[j] = Math.min(dp[j], dp[j-1]) + 1;\\n                }\\n\\n                prev = temp;\\n            }\\n        }\\n\\n        return dp[n-1];        \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.length();\\n        vector<int> dp(n, 0);\\n\\n        for (int i = n - 2; i >= 0; i--) {\\n            int prev = 0;\\n\\n            for (int j = i + 1; j < n; j++) {\\n                int temp = dp[j];\\n\\n                if (s[i] == s[j]) {\\n                    dp[j] = prev;\\n                } else {\\n                    dp[j] = min(dp[j], dp[j-1]) + 1;\\n                }\\n\\n                prev = temp;\\n            }\\n        }\\n\\n        return dp[n-1];        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446715,
                "title": "easy-cpp-solution-using-dynamic-programming-using-lcs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        string v=s;\\n        reverse(v.begin(),v.end());\\n        int n=s.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,0));\\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<n+1;j++){\\n                if(s[i-1]==v[j-1]) dp[i][j]=dp[i-1][j-1]+1;\\n                else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        return n-dp[n][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        string v=s;\\n        reverse(v.begin(),v.end());\\n        int n=s.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,0));\\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<n+1;j++){\\n                if(s[i-1]==v[j-1]) dp[i][j]=dp[i-1][j-1]+1;\\n                else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\\n            }\\n        }\\n        return n-dp[n][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445219,
                "title": "60-faster-c-tips-optimizations-appreciated",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nmy idea was that when checking if the string is a palindrom, starting with two pointers at the end and start of the string, if the characters at the two pointers arent equal you are presented with two options.\\n\\n1. insertion of the right pointer character behind left pointer\\n2. insertion of the left pointer character in front of right pointer\\n\\ncalculating these two sub problems and choosing the minimum of the two gives you the least number of insertions for the string at given left pointer and right pointer.\\n# Approach\\nactually inserting the character into the string is done logically, but in the code is not actually needed since we are never interacting with characters behind our left pointer or in front of our right pointer.\\n\\ndynamic programming is used here to store the results from the sub-problem calculations mentioned in the intuituion, if we calculated the best number of insertions for a unique left and right pointer, we shouldn\\'t need to calculate it again.\\n\\nNOTE: my solution was TLE for a while and it made me very sad :((, stopped TLE when I passed the string by reference since we aren\\'t modifiying it :))))!\\n\\n# Complexity\\n- Time complexity: O(n^2) (I think?)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int permInsert(string& s, int l, int r, vector<vector<int>>& dp) {\\n        if (l >= r) return 0; // base case\\n        if (dp[l][r] != -1) return dp[l][r]; //dp, have we solved for this comparison before?\\n\\n        int res; // if no dp, solve for this comparison\\n        if (s[l] == s[r]) res = permInsert(s, l + 1, r - 1, dp);\\n        else res = 1 + min(permInsert(s, l, r - 1, dp), permInsert(s, l + 1, r, dp));\\n\\n        dp[l][r] = res; //store result\\n        return dp[l][r]; //return\\n    }\\n\\n    int minInsertions(string s) {\\n        vector<vector<int>> dp(s.length(), vector<int>(s.length(), -1));\\n        return permInsert(s, 0, s.length() - 1, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int permInsert(string& s, int l, int r, vector<vector<int>>& dp) {\\n        if (l >= r) return 0; // base case\\n        if (dp[l][r] != -1) return dp[l][r]; //dp, have we solved for this comparison before?\\n\\n        int res; // if no dp, solve for this comparison\\n        if (s[l] == s[r]) res = permInsert(s, l + 1, r - 1, dp);\\n        else res = 1 + min(permInsert(s, l, r - 1, dp), permInsert(s, l + 1, r, dp));\\n\\n        dp[l][r] = res; //store result\\n        return dp[l][r]; //return\\n    }\\n\\n    int minInsertions(string s) {\\n        vector<vector<int>> dp(s.length(), vector<int>(s.length(), -1));\\n        return permInsert(s, 0, s.length() - 1, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445142,
                "title": "easy-problem-c-recursion-memoziation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int function(string  &s,int i,int j,vector<vector<int>>&dp){\\n   if(i>=j){\\n       return 0;\\n   }\\n   else if(dp[i][j]!=-1) return dp[i][j];\\n   else if(s[i]==s[j]){\\n      return function(s,i+1,j-1,dp);\\n   }\\n    else{\\n    int l=1+function(s,i+1,j,dp);\\n     int r=1+function(s,i,j-1,dp);\\n    dp[i][j]=min(l,r);\\n     return dp[i][j];\\n}\\n\\n\\n    }\\n\\n\\n    int minInsertions(string s) {\\n        int n=s.size();\\n        vector<vector<int>>dp(n,vector<int>(n,-1));\\n        // return makePalindrome(0,n-1,s,dp);\\n       return function (s,0,n-1,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int function(string  &s,int i,int j,vector<vector<int>>&dp){\\n   if(i>=j){\\n       return 0;\\n   }\\n   else if(dp[i][j]!=-1) return dp[i][j];\\n   else if(s[i]==s[j]){\\n      return function(s,i+1,j-1,dp);\\n   }\\n    else{\\n    int l=1+function(s,i+1,j,dp);\\n     int r=1+function(s,i,j-1,dp);\\n    dp[i][j]=min(l,r);\\n     return dp[i][j];\\n}\\n\\n\\n    }\\n\\n\\n    int minInsertions(string s) {\\n        int n=s.size();\\n        vector<vector<int>>dp(n,vector<int>(n,-1));\\n        // return makePalindrome(0,n-1,s,dp);\\n       return function (s,0,n-1,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445084,
                "title": "java-dp-memoization-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(s.length*s.length)\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int Util(String s,int i,int j,int[][] dp){\\n        if(i >= j)\\n            return 0;\\n\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n\\n        //If forward and backward characters match just move towards inside\\n        if(s.charAt(i) == s.charAt(j))\\n            return Util(s,i+1,j-1,dp);\\n        \\n        \\n        //If they donot match two solutions exist\\n    \\n        int ans = Integer.MAX_VALUE;\\n        \\n        //sol-1 insert a character near the j pointer which matches the character at\\n        //i poointer \\n        if(i+1<s.length())\\n            ans = Math.min(ans,1+Util(s,i+1,j,dp));\\n\\n        //sol-2 insert a character near the i pointer which matches the character at\\n        //j poointer \\n        if(j-1>=0)\\n            ans = Math.min(ans,1+Util(s,i,j-1,dp));\\n        \\n        //taking the best among both of the solutions and stroring them in a dp array for\\n        //future use\\n        return dp[i][j] = ans;\\n    }\\n\\n    public int minInsertions(String s) {\\n\\n        int[][] dp = new int[s.length()][s.length()];\\n\\n        for(int[] arr:dp)\\n            Arrays.fill(arr,-1);\\n\\n        return Util(s,0,s.length()-1,dp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int Util(String s,int i,int j,int[][] dp){\\n        if(i >= j)\\n            return 0;\\n\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n\\n        //If forward and backward characters match just move towards inside\\n        if(s.charAt(i) == s.charAt(j))\\n            return Util(s,i+1,j-1,dp);\\n        \\n        \\n        //If they donot match two solutions exist\\n    \\n        int ans = Integer.MAX_VALUE;\\n        \\n        //sol-1 insert a character near the j pointer which matches the character at\\n        //i poointer \\n        if(i+1<s.length())\\n            ans = Math.min(ans,1+Util(s,i+1,j,dp));\\n\\n        //sol-2 insert a character near the i pointer which matches the character at\\n        //j poointer \\n        if(j-1>=0)\\n            ans = Math.min(ans,1+Util(s,i,j-1,dp));\\n        \\n        //taking the best among both of the solutions and stroring them in a dp array for\\n        //future use\\n        return dp[i][j] = ans;\\n    }\\n\\n    public int minInsertions(String s) {\\n\\n        int[][] dp = new int[s.length()][s.length()];\\n\\n        for(int[] arr:dp)\\n            Arrays.fill(arr,-1);\\n\\n        return Util(s,0,s.length()-1,dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444897,
                "title": "php-solution-dynamic-programming",
                "content": "# Complexity\\n- Time complexity: $$O(n*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```PHP\\nclass Solution\\n{\\n\\n    /**\\n     * @param String $s\\n     * @return Integer\\n     */\\n    function minInsertions($s)\\n    {\\n        $n = strlen($s);\\n        $r = strrev($s);\\n        $a = array_fill(0, 2, array_fill(-1, $n + 1, 0));\\n\\n        for ($i = 0; $i < $n; $i++) {\\n            $c = $i % 2;\\n            for ($j = 0; $j < $n; $j++) {\\n                $a[$c][$j] = max($s[$i] === $r[$j] ? $a[1 - $c][$j - 1] + 1 : 0, $a[1 - $c][$j], $a[$c][$j - 1]);\\n            }\\n        }\\n        return $n - $a[$c][$n - 1];\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "PHP",
                    "Dynamic Programming"
                ],
                "code": "```PHP\\nclass Solution\\n{\\n\\n    /**\\n     * @param String $s\\n     * @return Integer\\n     */\\n    function minInsertions($s)\\n    {\\n        $n = strlen($s);\\n        $r = strrev($s);\\n        $a = array_fill(0, 2, array_fill(-1, $n + 1, 0));\\n\\n        for ($i = 0; $i < $n; $i++) {\\n            $c = $i % 2;\\n            for ($j = 0; $j < $n; $j++) {\\n                $a[$c][$j] = max($s[$i] === $r[$j] ? $a[1 - $c][$j - 1] + 1 : 0, $a[1 - $c][$j], $a[$c][$j - 1]);\\n            }\\n        }\\n        return $n - $a[$c][$n - 1];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444762,
                "title": "easy-dp-solution-top-down-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int solve(string& s,int i,int j , vector<vector<int>>&dp){\\n        if(i == j ) return 1;\\n        if(i > j) return 0;\\n        \\n        if(dp[i][j]  != -1) return dp[i][j];\\n        int ans = 0;\\n\\n        if(s[i] == s[j]) ans = 2 + solve(s,i+1,j-1,dp);\\n        else ans = max(solve(s,i+1,j,dp),solve(s,i,j-1,dp));\\n\\n        return  dp[i][j] = ans;\\n    }\\n    int minInsertions(string s) {\\n        vector<vector<int>>dp(s.size()+1,vector<int>(s.size()+1,-1));\\n        return s.size() - solve(s,0,s.size()-1,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int solve(string& s,int i,int j , vector<vector<int>>&dp){\\n        if(i == j ) return 1;\\n        if(i > j) return 0;\\n        \\n        if(dp[i][j]  != -1) return dp[i][j];\\n        int ans = 0;\\n\\n        if(s[i] == s[j]) ans = 2 + solve(s,i+1,j-1,dp);\\n        else ans = max(solve(s,i+1,j,dp),solve(s,i,j-1,dp));\\n\\n        return  dp[i][j] = ans;\\n    }\\n    int minInsertions(string s) {\\n        vector<vector<int>>dp(s.size()+1,vector<int>(s.size()+1,-1));\\n        return s.size() - solve(s,0,s.size()-1,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444651,
                "title": "very-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n O(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n# Code\\n```\\npublic class Solution {\\nint[,] dp = new int[501,501];\\n    private int solve(string s, int start, int end){\\n        if(start>=end){ // this is the terminating condition\\n            return 0;\\n        }else if(dp[start,end] != -1){\\n            return dp[start,end]; // return from dp \\n        }\\n        else{\\n            if(s[start] == s[end]){\\n                return dp[start,end] =  solve(s,start+1,end-1); // if both char match of both indexes than increment start index and decrement end index\\n            }\\n            else{ // there are two chioses 1) insert at beginning 2) insert at end\\n                int insertAtBegin = solve(s,start,end-1); // insert char at begining will keep start index constent to same postion but end index will decrease\\n                int insertAtEnd = solve(s,start+1,end); // insert at end will keep end index constent but start index will increase\\n                return dp[start,end] =  Math.Min(insertAtBegin, insertAtEnd) + 1; // get the minimum step out of both , +1 means no of char inserted\\n            }\\n        }\\n    }\\n    public int MinInsertions(string s) {\\n        int n= s.Length;\\n        for(int i=0;i<501;i++){\\n            for(int j=0;j<501;j++){\\n                dp[i,j] = -1; // iniktialize dp array with -1\\n            }\\n        }\\n        return solve(s,0,n-1); // pointer on 0th index and las index\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\nint[,] dp = new int[501,501];\\n    private int solve(string s, int start, int end){\\n        if(start>=end){ // this is the terminating condition\\n            return 0;\\n        }else if(dp[start,end] != -1){\\n            return dp[start,end]; // return from dp \\n        }\\n        else{\\n            if(s[start] == s[end]){\\n                return dp[start,end] =  solve(s,start+1,end-1); // if both char match of both indexes than increment start index and decrement end index\\n            }\\n            else{ // there are two chioses 1) insert at beginning 2) insert at end\\n                int insertAtBegin = solve(s,start,end-1); // insert char at begining will keep start index constent to same postion but end index will decrease\\n                int insertAtEnd = solve(s,start+1,end); // insert at end will keep end index constent but start index will increase\\n                return dp[start,end] =  Math.Min(insertAtBegin, insertAtEnd) + 1; // get the minimum step out of both , +1 means no of char inserted\\n            }\\n        }\\n    }\\n    public int MinInsertions(string s) {\\n        int n= s.Length;\\n        for(int i=0;i<501;i++){\\n            for(int j=0;j<501;j++){\\n                dp[i,j] = -1; // iniktialize dp array with -1\\n            }\\n        }\\n        return solve(s,0,n-1); // pointer on 0th index and las index\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444620,
                "title": "python-simple-python-solution-using-dynamic-programming",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 1317 ms, faster than 27.39% of Python3 online submissions for Minimum Insertion Steps to Make a String Palindrome.\\n# Memory Usage: 16 MB, less than 67.55% of Python3 online submissions for Minimum Insertion Steps to Make a String Palindrome.\\n\\n\\tclass Solution:\\n\\t\\tdef minInsertions(self, s: str) -> int:\\n\\n\\t\\t\\tdef LeastCommonSubsequence(string, reverse_string, row, col):\\n\\n\\t\\t\\t\\tdp = [[0 for _ in range(col + 1)] for _ in range(row + 1)]\\n\\n\\t\\t\\t\\tfor r in range(1, row + 1):\\n\\t\\t\\t\\t\\tfor c in range(1, col + 1):\\n\\n\\t\\t\\t\\t\\t\\tif string[r - 1] == reverse_string[c - 1]:\\n\\n\\t\\t\\t\\t\\t\\t\\tdp[r][c] = dp[r - 1][c - 1] + 1\\n\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tdp[r][c] = max(dp[r - 1][c] , dp[r][c - 1])\\n\\n\\t\\t\\t\\treturn dp[row][col]\\n\\n\\t\\t\\tlength = len(s)\\n\\n\\t\\t\\tresult = length - LeastCommonSubsequence(s , s[::-1] , length , length)\\n\\n\\t\\t\\treturn result\\n\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 1317 ms, faster than 27.39% of Python3 online submissions for Minimum Insertion Steps to Make a String Palindrome.\\n# Memory Usage: 16 MB, less than 67.55% of Python3 online submissions for Minimum Insertion Steps to Make a String Palindrome.\\n\\n\\tclass Solution:\\n\\t\\tdef minInsertions(self, s: str) -> int:\\n\\n\\t\\t\\tdef LeastCommonSubsequence(string, reverse_string, row, col):\\n\\n\\t\\t\\t\\tdp = [[0 for _ in range(col + 1)] for _ in range(row + 1)]\\n\\n\\t\\t\\t\\tfor r in range(1, row + 1):\\n\\t\\t\\t\\t\\tfor c in range(1, col + 1):\\n\\n\\t\\t\\t\\t\\t\\tif string[r - 1] == reverse_string[c - 1]:\\n\\n\\t\\t\\t\\t\\t\\t\\tdp[r][c] = dp[r - 1][c - 1] + 1\\n\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tdp[r][c] = max(dp[r - 1][c] , dp[r][c - 1])\\n\\n\\t\\t\\t\\treturn dp[row][col]\\n\\n\\t\\t\\tlength = len(s)\\n\\n\\t\\t\\tresult = length - LeastCommonSubsequence(s , s[::-1] , length , length)\\n\\n\\t\\t\\treturn result\\n\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 3444606,
                "title": "palindrome-insertions-problem-using-dynamic-programming-and-rolling-arrays-99-59-99-80",
                "content": "# Intuition\\nWhen first encountering this problem, our goal is to find the minimum number of insertions needed to turn the given string `s` into a palindrome. A palindrome is a string that reads the same forwards and backwards. To solve this problem, we can think of it as a variation of finding the longest palindromic subsequence (LPS) within the string. If we can find the LPS, the minimum number of insertions needed would be the difference between the length of the input string and the LPS.\\n\\n# Approach\\nOur approach to solving this problem is using dynamic programming. We first create a 2D table to store the LPS lengths for all possible substrings of the input string `s`. However, to optimize space complexity, we can use a technique called the \"rolling array\", which reduces the 2D table to two 1D arrays, `prev` and `curr`. We update the two arrays alternately while iterating through the input string `s` in reverse order.\\n\\nFor each character in the input string `s`, we compare it to the other characters in the substring starting from the next position to the end of the string. If the characters at positions `i` and `j` are equal, we update the LPS length in the `curr` array. If they\\'re not equal, we use the maximum LPS length from the previous row or the previous column in the DP table.\\n\\nAfter completing the iterations, the length of the longest palindromic subsequence will be stored in `prev[n - 1]`. We return the difference between the length of the input string `s` and the LPS as the minimum number of insertions needed to make the input string palindrome.\\n\\n**Rolling Array Technique**\\nThe rolling array technique is an optimization to save space when working with dynamic programming tables. Instead of using a full 2D table, we only keep two 1D arrays, `prev` and `curr`. We alternate between updating the arrays, using `prev` to store the previous row\\'s values and `curr` to store the current row\\'s values as we iterate through the input string `s`. By doing this, we reduce the space complexity of the solution.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\nThe time complexity of this solution is $$O(n^2)$$, where $$n$$ is the length of the input string `s`. This is because we iterate through the input string `s` in reverse order, and for each character, we iterate through the substring starting from its next position to the end of the string.\\n\\n- Space complexity: $$O(n)$$\\nThe space complexity of this solution is $$O(n)$$, where $$n$$ is the length of the input string `s`. By using the rolling array technique, we only need to maintain two 1D arrays, `prev` and `curr`, instead of a full 2D DP table.\\n\\n# Code\\n```typescript []\\n/**\\n * Return the minimum number of insertions needed to make a string palindrome.\\n *\\n * @param s - The input string, consisting of lowercase English letters.\\n * @returns The minimum number of insertions required to make the input string palindrome.\\n */\\nfunction minInsertions(s: string): number {\\n    const n: number = s.length;\\n\\n    // Initialize two 1D arrays for the rolling array technique.\\n    // \\'prev\\' will store the LPS lengths of the previous row in the DP table.\\n    // \\'curr\\' will store the LPS lengths of the current row in the DP table.\\n    let prev: number[] = new Array(n).fill(0);\\n    let curr: number[] = new Array(n).fill(0);\\n\\n    // Iterate through the input string in reverse order.\\n    for (let i = n - 1; i >= 0; i--) {\\n        // Set the LPS length of a single-character substring to 1.\\n        curr[i] = 1;\\n\\n        // Iterate through the substring starting from index i+1 to the end of the string.\\n        for (let j = i + 1; j < n; j++) {\\n            // If the characters at positions i and j are equal, update the LPS length.\\n            if (s[i] === s[j]) {\\n                curr[j] = prev[j - 1] + 2;\\n            } else {\\n                // If the characters are not equal, use the maximum LPS length from\\n                // the previous row or the previous column in the DP table.\\n                curr[j] = Math.max(prev[j], curr[j - 1]);\\n            }\\n        }\\n\\n        // Swap the \\'prev\\' and \\'curr\\' arrays for the next iteration.\\n        [prev, curr] = [curr, prev];\\n    }\\n\\n    // The length of the longest palindromic subsequence is stored in prev[n-1].\\n    const lps: number = prev[n - 1];\\n\\n    // Return the minimum number of insertions needed to make the input string palindrome.\\n    return n - lps;\\n}\\n```\\n```python []\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \"\"\"\\n        Return the minimum number of insertions needed to make a string palindrome.\\n\\n        Args:\\n            s (str): The input string, consisting of lowercase English letters.\\n\\n        Returns:\\n            int: The minimum number of insertions required to make the input string palindrome.\\n\\n        \"\"\"\\n        n = len(s)\\n\\n        # Initialize two 1D arrays for the rolling array technique.\\n        # \\'prev\\' will store the LPS lengths of the previous row in the DP table.\\n        # \\'curr\\' will store the LPS lengths of the current row in the DP table.\\n        prev = [0 for _ in range(n)]\\n        curr = [0 for _ in range(n)]\\n\\n        # Iterate through the input string in reverse order.\\n        for i in range(n - 1, -1, -1):\\n            # Set the LPS length of a single-character substring to 1.\\n            curr[i] = 1\\n\\n            # Iterate through the substring starting from index i+1 to the end of the string.\\n            for j in range(i + 1, n):\\n                # If the characters at positions i and j are equal, update the LPS length.\\n                if s[i] == s[j]:\\n                    curr[j] = prev[j - 1] + 2\\n                else:\\n                    # If the characters are not equal, use the maximum LPS length from\\n                    # the previous row or the previous column in the DP table.\\n                    curr[j] = max(prev[j], curr[j - 1])\\n\\n            # Swap the \\'prev\\' and \\'curr\\' arrays for the next iteration.\\n            prev, curr = curr, prev\\n\\n        # The length of the longest palindromic subsequence is stored in prev[n-1].\\n        lps = prev[n - 1]\\n\\n        # Return the minimum number of insertions needed to make the input string palindrome.\\n        return n - lps\\n```\\n![1312. Minimum Insertion Steps to Make a String Palindrome - Copy.PNG](https://assets.leetcode.com/users/images/c4fb0b37-7534-493d-91d7-d193f620bdf4_1682181512.2016158.png)\\n",
                "solutionTags": [
                    "Python3",
                    "TypeScript",
                    "Array",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```typescript []\\n/**\\n * Return the minimum number of insertions needed to make a string palindrome.\\n *\\n * @param s - The input string, consisting of lowercase English letters.\\n * @returns The minimum number of insertions required to make the input string palindrome.\\n */\\nfunction minInsertions(s: string): number {\\n    const n: number = s.length;\\n\\n    // Initialize two 1D arrays for the rolling array technique.\\n    // \\'prev\\' will store the LPS lengths of the previous row in the DP table.\\n    // \\'curr\\' will store the LPS lengths of the current row in the DP table.\\n    let prev: number[] = new Array(n).fill(0);\\n    let curr: number[] = new Array(n).fill(0);\\n\\n    // Iterate through the input string in reverse order.\\n    for (let i = n - 1; i >= 0; i--) {\\n        // Set the LPS length of a single-character substring to 1.\\n        curr[i] = 1;\\n\\n        // Iterate through the substring starting from index i+1 to the end of the string.\\n        for (let j = i + 1; j < n; j++) {\\n            // If the characters at positions i and j are equal, update the LPS length.\\n            if (s[i] === s[j]) {\\n                curr[j] = prev[j - 1] + 2;\\n            } else {\\n                // If the characters are not equal, use the maximum LPS length from\\n                // the previous row or the previous column in the DP table.\\n                curr[j] = Math.max(prev[j], curr[j - 1]);\\n            }\\n        }\\n\\n        // Swap the \\'prev\\' and \\'curr\\' arrays for the next iteration.\\n        [prev, curr] = [curr, prev];\\n    }\\n\\n    // The length of the longest palindromic subsequence is stored in prev[n-1].\\n    const lps: number = prev[n - 1];\\n\\n    // Return the minimum number of insertions needed to make the input string palindrome.\\n    return n - lps;\\n}\\n```\n```python []\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        \"\"\"\\n        Return the minimum number of insertions needed to make a string palindrome.\\n\\n        Args:\\n            s (str): The input string, consisting of lowercase English letters.\\n\\n        Returns:\\n            int: The minimum number of insertions required to make the input string palindrome.\\n\\n        \"\"\"\\n        n = len(s)\\n\\n        # Initialize two 1D arrays for the rolling array technique.\\n        # \\'prev\\' will store the LPS lengths of the previous row in the DP table.\\n        # \\'curr\\' will store the LPS lengths of the current row in the DP table.\\n        prev = [0 for _ in range(n)]\\n        curr = [0 for _ in range(n)]\\n\\n        # Iterate through the input string in reverse order.\\n        for i in range(n - 1, -1, -1):\\n            # Set the LPS length of a single-character substring to 1.\\n            curr[i] = 1\\n\\n            # Iterate through the substring starting from index i+1 to the end of the string.\\n            for j in range(i + 1, n):\\n                # If the characters at positions i and j are equal, update the LPS length.\\n                if s[i] == s[j]:\\n                    curr[j] = prev[j - 1] + 2\\n                else:\\n                    # If the characters are not equal, use the maximum LPS length from\\n                    # the previous row or the previous column in the DP table.\\n                    curr[j] = max(prev[j], curr[j - 1])\\n\\n            # Swap the \\'prev\\' and \\'curr\\' arrays for the next iteration.\\n            prev, curr = curr, prev\\n\\n        # The length of the longest palindromic subsequence is stored in prev[n-1].\\n        lps = prev[n - 1]\\n\\n        # Return the minimum number of insertions needed to make the input string palindrome.\\n        return n - lps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444144,
                "title": "very-easy-dp-solution-c-java-fast-explained",
                "content": "# Solution\\n- Use `Dynamic Programming` technique to try all possible ways to make the string palindrome.\\n- The `dp` array is a 2D array, where `dp[l][r]` is the minimum number of insertions needed to make the substring `s[l..r]` a palindrome.\\n- If `s[l] == s[r]`, then you can move the 2 pointers to the inside and calculate the minimum number of insertions needed for the substring `s[l + 1..r - 1]`.\\n- If `s[l] != s[r]`, then try the 2 options to move `l` to the right or `r` to the left.\\n- For all the combinations return the minimum number needed to convert the string to a palindrome one.\\n# Complexity\\n- Time Complexity: `O(N ^ 2)`, where `N` is the length of the string.\\n- Space Complexity: `O(N ^ 2)`, for the `dp` array.\\n\\n# Code\\n## C++\\n```cpp\\nclass Solution {\\npublic:\\n    int dp[505][505];\\n\\n    int solve(string &s, int l, int r) {\\n        if(l >= r) return 0;\\n\\n        auto & ret = dp[l][r];\\n        if(~ret) return ret;\\n\\n        if(s[l] == s[r]) ret = solve(s, l + 1, r - 1);\\n        else ret = 1 + min(solve(s, l + 1, r), solve(s, l, r - 1));\\n        return ret;\\n    }\\n\\n    int minInsertions(string s) {\\n        memset(dp, -1, sizeof dp);\\n        return solve(s, 0, (int) s.size() - 1);\\n    }\\n};\\n```\\n\\n## Java\\n```java\\nclass Solution {\\n    int [][] dp = new int[505][505];\\n\\n    int solve(String s, int l, int r) {\\n        if(l >= r) return 0;\\n        if(dp[l][r] != -1) return dp[l][r];\\n        if(s.charAt(l) == s.charAt(r)) return dp[l][r] = solve(s, l + 1, r - 1);\\n        return dp[l][r] = 1 + Math.min(solve(s, l + 1, r), solve(s, l, r - 1));\\n    }\\n\\n    public int minInsertions(String s) {\\n        for (int i = 0; i < 505; i++) {\\n            for (int j = 0; j < 505; j++) {\\n                dp[i][j] = -1;\\n            }\\n        }\\n        return solve(s, 0, s.length() - 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int dp[505][505];\\n\\n    int solve(string &s, int l, int r) {\\n        if(l >= r) return 0;\\n\\n        auto & ret = dp[l][r];\\n        if(~ret) return ret;\\n\\n        if(s[l] == s[r]) ret = solve(s, l + 1, r - 1);\\n        else ret = 1 + min(solve(s, l + 1, r), solve(s, l, r - 1));\\n        return ret;\\n    }\\n\\n    int minInsertions(string s) {\\n        memset(dp, -1, sizeof dp);\\n        return solve(s, 0, (int) s.size() - 1);\\n    }\\n};\\n```\n```java\\nclass Solution {\\n    int [][] dp = new int[505][505];\\n\\n    int solve(String s, int l, int r) {\\n        if(l >= r) return 0;\\n        if(dp[l][r] != -1) return dp[l][r];\\n        if(s.charAt(l) == s.charAt(r)) return dp[l][r] = solve(s, l + 1, r - 1);\\n        return dp[l][r] = 1 + Math.min(solve(s, l + 1, r), solve(s, l, r - 1));\\n    }\\n\\n    public int minInsertions(String s) {\\n        for (int i = 0; i < 505; i++) {\\n            for (int j = 0; j < 505; j++) {\\n                dp[i][j] = -1;\\n            }\\n        }\\n        return solve(s, 0, s.length() - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444114,
                "title": "easy-memoization-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n =s.size();\\n     int dp[n+1][n+1];\\n            string t=s;\\n             reverse(t.begin(),t.end());\\n           for(int i=0;i<n+1;i++){\\n               for (int j=0;j<n+1;j++){\\n                   if(i==0||j==0){\\n                       dp[i][j]=0;\\n                   }\\n               }\\n           }\\n           for(int i=1;i<n+1;i++){\\n          for(int j=1;j<n+1;j++){\\n              if(s[i-1]==t[j-1]){\\n                  dp[i][j] = 1+dp[i-1][j-1];\\n              }else{\\n                  dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\\n              }\\n          }\\n      }\\n\\n             int temp=dp[n][n];\\n            return n-temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n =s.size();\\n     int dp[n+1][n+1];\\n            string t=s;\\n             reverse(t.begin(),t.end());\\n           for(int i=0;i<n+1;i++){\\n               for (int j=0;j<n+1;j++){\\n                   if(i==0||j==0){\\n                       dp[i][j]=0;\\n                   }\\n               }\\n           }\\n           for(int i=1;i<n+1;i++){\\n          for(int j=1;j<n+1;j++){\\n              if(s[i-1]==t[j-1]){\\n                  dp[i][j] = 1+dp[i-1][j-1];\\n              }else{\\n                  dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\\n              }\\n          }\\n      }\\n\\n             int temp=dp[n][n];\\n            return n-temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443773,
                "title": "java-recursive-top-down-memoization",
                "content": "```\\nclass Solution {\\n    int[][] dp = new int[503][503];\\n    \\n    public int solve(String s, String p, int  i, int j ){\\n        if( i < 0 || j < 0)\\n            return 0;\\n    \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        char a = s.charAt(i);\\n        char b = p.charAt(j);\\n        \\n        if(a == b)\\n            dp[i][j] = 1+ solve(s,p,i-1,j-1);\\n        else\\n            dp[i][j] = (int) Math.max(solve(s,p,i-1,j), solve(s,p,i,j-1));\\n        \\n        return dp[i][j];\\n    }\\n    \\n    public int minInsertions(String s) {\\n        String p = \"\";\\n        for(char c : s.toCharArray())\\n            p=c+p;\\n        for(int i = 0 ;i <= s.length(); i++)\\n            Arrays.fill(dp[i],-1);\\n        return s.length()-solve(s,p,s.length()-1,p.length()-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int[][] dp = new int[503][503];\\n    \\n    public int solve(String s, String p, int  i, int j ){\\n        if( i < 0 || j < 0)\\n            return 0;\\n    \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        char a = s.charAt(i);\\n        char b = p.charAt(j);\\n        \\n        if(a == b)\\n            dp[i][j] = 1+ solve(s,p,i-1,j-1);\\n        else\\n            dp[i][j] = (int) Math.max(solve(s,p,i-1,j), solve(s,p,i,j-1));\\n        \\n        return dp[i][j];\\n    }\\n    \\n    public int minInsertions(String s) {\\n        String p = \"\";\\n        for(char c : s.toCharArray())\\n            p=c+p;\\n        for(int i = 0 ;i <= s.length(); i++)\\n            Arrays.fill(dp[i],-1);\\n        return s.length()-solve(s,p,s.length()-1,p.length()-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443758,
                "title": "lcs-longest-common-subsequence-dp-c",
                "content": "`Please Upvote If you Like !!!`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        string t = s;\\n        reverse(t.begin() , t.end());\\n        int n = s.size();\\n        vector<vector<int>> dp(n+1,vector<int> (n+1,0));\\n        int mx = 0;\\n        for(int i=1;i<=n;i++) {\\n            for(int j=1;j<=n;j++) {\\n                if(s[i-1] == t[j-1]) dp[i][j] = 1 + dp[i-1][j-1];\\n                else dp[i][j] = max(dp[i-1][j] , dp[i][j-1]);\\n                mx = max(mx,dp[i][j]);\\n            }\\n        }\\n        return n - mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        string t = s;\\n        reverse(t.begin() , t.end());\\n        int n = s.size();\\n        vector<vector<int>> dp(n+1,vector<int> (n+1,0));\\n        int mx = 0;\\n        for(int i=1;i<=n;i++) {\\n            for(int j=1;j<=n;j++) {\\n                if(s[i-1] == t[j-1]) dp[i][j] = 1 + dp[i-1][j-1];\\n                else dp[i][j] = max(dp[i-1][j] , dp[i][j-1]);\\n                mx = max(mx,dp[i][j]);\\n            }\\n        }\\n        return n - mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443682,
                "title": "short-simple-python-solution-using-dp",
                "content": "# Code\\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        dp=[[-1]*501 for _ in range(501)]\\n        def dfs(i,j):\\n            if i>j or i==j:\\n                return 0\\n            if dp[i][j]!=-1:\\n                return dp[i][j]\\n            if s[i]==s[j]:\\n                dp[i][j]=dfs(i+1,j-1)\\n            else:\\n                dp[i][j]=min(dfs(i,j-1),dfs(i+1,j))+1\\n            return dp[i][j]\\n        return dfs(0,len(s)-1)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        dp=[[-1]*501 for _ in range(501)]\\n        def dfs(i,j):\\n            if i>j or i==j:\\n                return 0\\n            if dp[i][j]!=-1:\\n                return dp[i][j]\\n            if s[i]==s[j]:\\n                dp[i][j]=dfs(i+1,j-1)\\n            else:\\n                dp[i][j]=min(dfs(i,j-1),dfs(i+1,j))+1\\n            return dp[i][j]\\n        return dfs(0,len(s)-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443503,
                "title": "c-simple-solution-easy-to-understand-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\no solve this problem would be to use dynamic programming to find the minimum number of insertions required to make the given string s a palindrome.\\n\\nSince we are allowed to insert any character at any index of the string, we can think of inserting characters in such a way that the resulting string becomes a palindrome. For example, if we insert a character at the beginning of the string, we should also insert the same character at the end of the string to maintain the symmetry required for a palindrome.\\n\\nDynamic programming would allow us to break down the problem into smaller subproblems that can be solved independently and then combined to solve the original problem. We can define a two-dimensional array dp where dp[i][j] represents the minimum number of insertions required to make the substring s[i...j] a palindrome.\\n\\nTo fill the dp array, we can start with the base cases where dp[i][i] = 0 for all i, since a single character is always a palindrome. Then, we can fill in the entries for substrings of length 2, 3, and so on, until we reach the entire string s.\\n\\nFor each substring s[i...j], we can compare the characters at positions i and j. If they are the same, then we can consider the substring s[i+1...j-1], since it must also be a palindrome. If they are different, then we can try inserting a character at position i or j to make the substring s[i...j] a palindrome. We can choose the option that requires the minimum number of insertions.\\n\\nFinally, the answer to the problem would be dp[0][n-1], where n is the length of the string s.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2), where n is the length of the input string s.\\n\\nThis is because we are filling a two-dimensional array dp of size n x n, and each entry requires constant time to compute. Specifically, we need to fill the diagonal entries dp[i][i] for i = 0 to n-1, which takes O(n) time. Then, for substrings of length 2, 3, and so on, we need to fill the entries of dp in a bottom-up manner. This requires computing each entry dp[i][j] as a function of dp[i+1][j-1], dp[i+1][j], and dp[i][j-1], which takes constant time. We need to fill n(n-1)/2 such entries, which takes O(n^2) time.\\n\\nTherefore, the overall time complexity of the solution is O(n^2), which is polynomial in the size of the input. This is an efficient algorithm for solving this problem for most practical purposes, since it can handle input strings with thousands or even millions of characters in reasonable time.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.size();\\n        vector<vector<int>> dp(n, vector<int>(n));\\n        for (int len = 2; len <= n; len++) {\\n            for (int i = 0; i <= n - len; i++) {\\n                int j = i + len - 1;\\n                if (s[i] == s[j]) {\\n                    dp[i][j] = dp[i+1][j-1];\\n                } else {\\n                    dp[i][j] = min(dp[i+1][j], dp[i][j-1]) + 1;\\n                }\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.size();\\n        vector<vector<int>> dp(n, vector<int>(n));\\n        for (int len = 2; len <= n; len++) {\\n            for (int i = 0; i <= n - len; i++) {\\n                int j = i + len - 1;\\n                if (s[i] == s[j]) {\\n                    dp[i][j] = dp[i+1][j-1];\\n                } else {\\n                    dp[i][j] = min(dp[i+1][j], dp[i][j-1]) + 1;\\n                }\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443467,
                "title": "java-beginner-friendly-using-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo solve this problem, we can use dynamic programming. We can define a 2D table dp, where dp[i][j] represents the minimum number of insertions needed to make the substring s[i...j] a palindrome.\\n\\nWe can start filling the table from the bottom up. For any i and j, if s[i] == s[j], then the substring s[i...j] is already a palindrome and we don\\'t need to insert any characters. So, we can set dp[i][j] = dp[i+1][j-1].\\n\\nIf s[i] != s[j], then we need to insert a character at either index i or j. So, we can take the minimum of dp[i+1][j] (inserting a character at index i) and dp[i][j-1] (inserting a character at index j), and add 1 to it (for the character we\\'re inserting). So, we can set dp[i][j] = min(dp[i+1][j], dp[i][j-1]) + 1.\\n\\nFinally, the minimum number of insertions needed to make the entire string s a palindrome is dp[0][n-1], where n is the length of the string.\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the algorithm is O(n^2), where n is the length of the input string. This is because we fill in a 2D array of size n x n using a nested loop, which takes O(n^2) time.\\n\\n\\n- Space complexity:\\nThe space complexity of the algorithm is O(n^2), where n is the length of the input string. This is because we use a 2D array of size n x n to store the minimum number of insertions needed to make each substring palindromic. Therefore, the space complexity of the algorithm is O(n^2).\\n\\n\\n\\n\\nplease use pen paper then see the magic\\uD83D\\uDE0A\\u2714\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int n = s.length();\\n    int[][] dp = new int[n][n];\\n    for (int gap = 1; gap < n; gap++) {\\n        for (int i = 0; i < n - gap; i++) {\\n            int j = i + gap;\\n            if (s.charAt(i) == s.charAt(j)) {\\n                dp[i][j] = dp[i+1][j-1];\\n            } else {\\n                dp[i][j] = Math.min(dp[i+1][j], dp[i][j-1]) + 1;\\n            }\\n        }\\n    }\\n    return dp[0][n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int n = s.length();\\n    int[][] dp = new int[n][n];\\n    for (int gap = 1; gap < n; gap++) {\\n        for (int i = 0; i < n - gap; i++) {\\n            int j = i + gap;\\n            if (s.charAt(i) == s.charAt(j)) {\\n                dp[i][j] = dp[i+1][j-1];\\n            } else {\\n                dp[i][j] = Math.min(dp[i+1][j], dp[i][j-1]) + 1;\\n            }\\n        }\\n    }\\n    return dp[0][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443458,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int lcs(string s1, string s2) \\n    {\\n    int n = s1.size();\\n    int m = s2.size();\\n    vector<int> prev(m + 1,0), cur(m + 1,0);\\n    for(int ind1 = 1;ind1 <= n; ind1++)\\n    {\\n        for(int ind2 = 1;ind2 <= m;ind2++)\\n        {\\n            if(s1[ind1 - 1] == s2[ind2 - 1])\\n                cur[ind2] = 1 + prev[ind2 - 1];\\n            else\\n                cur[ind2] = 0 + max(prev[ind2],cur[ind2 - 1]);\\n        }\\n        prev = cur;\\n    }\\n    return prev[m];\\n}\\n        int longestPalindromeSubsequence(string s)\\n        {\\n        string t = s;\\n        reverse(s.begin(),s.end());\\n        return lcs(s,t);\\n    }\\npublic:   \\n    int minInsertions(string s) \\n    {\\n        int n = s.size();\\n        int k = longestPalindromeSubsequence(s);\\n        return n-k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int lcs(string s1, string s2) \\n    {\\n    int n = s1.size();\\n    int m = s2.size();\\n    vector<int> prev(m + 1,0), cur(m + 1,0);\\n    for(int ind1 = 1;ind1 <= n; ind1++)\\n    {\\n        for(int ind2 = 1;ind2 <= m;ind2++)\\n        {\\n            if(s1[ind1 - 1] == s2[ind2 - 1])\\n                cur[ind2] = 1 + prev[ind2 - 1];\\n            else\\n                cur[ind2] = 0 + max(prev[ind2],cur[ind2 - 1]);\\n        }\\n        prev = cur;\\n    }\\n    return prev[m];\\n}\\n        int longestPalindromeSubsequence(string s)\\n        {\\n        string t = s;\\n        reverse(s.begin(),s.end());\\n        return lcs(s,t);\\n    }\\npublic:   \\n    int minInsertions(string s) \\n    {\\n        int n = s.size();\\n        int k = longestPalindromeSubsequence(s);\\n        return n-k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443425,
                "title": "beats-100-time-and-space",
                "content": "# Intuition\\n- constraints se to dp hi lag raha hai\\n# Approach\\n- dp[l][r] = Minimun insertion steps needed to make a string    palindrome in the range l to r inclusively\\n```\\ndp[l][r] = min(dp[l][r - 1], dp[l + 1][r]) + 1\\nif(s[l] == s[r]) dp[l][r] = min(dp[l][r], dp[l + 1][r - 1]);\\n```\\n- If we look closely at this transition, to fill `dp[l][r]` for a particular `l` and all possible values of `r`, we only need the values from the current and previous rows.\\n# Complexity\\n- Time complexity: $$O(n * n)$$\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int minInsertions(string s) {\\n        int n = s.size();\\n        int dp[n], prev, ans;\\n        for(int l = n - 1; l >= 0; l--) {\\n            dp[l] = 0;\\n            if(l + 1 < n)prev = dp[l + 1], dp[l + 1] = (s[l] != s[l + 1]);\\n            for(int r = l + 2; r < n; r++) {\\n                ans = min(dp[r - 1], dp[r]) + 1;\\n                if(s[l] == s[r]) ans = min(ans, prev);\\n                prev = dp[r];\\n                dp[r] = ans;\\n            }\\n        }\\n        return dp[n - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\ndp[l][r] = min(dp[l][r - 1], dp[l + 1][r]) + 1\\nif(s[l] == s[r]) dp[l][r] = min(dp[l][r], dp[l + 1][r - 1]);\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int minInsertions(string s) {\\n        int n = s.size();\\n        int dp[n], prev, ans;\\n        for(int l = n - 1; l >= 0; l--) {\\n            dp[l] = 0;\\n            if(l + 1 < n)prev = dp[l + 1], dp[l + 1] = (s[l] != s[l + 1]);\\n            for(int r = l + 2; r < n; r++) {\\n                ans = min(dp[r - 1], dp[r]) + 1;\\n                if(s[l] == s[r]) ans = min(ans, prev);\\n                prev = dp[r];\\n                dp[r] = ans;\\n            }\\n        }\\n        return dp[n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443424,
                "title": "java-optimal-solution-beginner-friendly-easy-explanation-dp-2-pointers",
                "content": "# Intuition\\nWe have 2 options to match character from, if outer characters are equal iterate until they dont match. if found characters which doesn\\'t match, you get 2 options to insert charcter equal to outer characters. In both cases find the minimum one which will be optimal.\\n\\n\\n**PLEASE UPVOTE IF YOU REALLY LIKED MY SOLUTION**\\n**CODE WITHOUT COMMENTS BELOW**\\n\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int n=s.length();\\n        int[][] dp=new int[n][n];   //dp to store if cases with current start and end character have been already handled\\n        char[] ar=s.toCharArray();\\n        return helper(ar,0,n-1,dp);\\n    }\\n    public int helper(char[] ar,int start,int end,int[][] dp){\\n        if(dp[start][end]!=0) return dp[start][end];   //if handled this case return val\\n\\n        //iterating until to outer characters dont match\\n        while(ar[start]==ar[end] && start<end){\\n            start++;\\n            end--;\\n        }\\n        //if every character in the current range match return 0\\n        if(start>=end) return 0;\\n\\n        // incrementing start pointer means we have inserted character equal to char at start in the position of end \\n        //incrementing end pointer means we have inserted character equal to char at end in the position of start\\n        int val=Math.min(helper(ar,start+1,end,dp),helper(ar,start,end-1,dp));\\n        return dp[start][end]=val+1;   //adding 1 \\n    }\\n}\\n```\\n**CODE WITHOUT COMMENTS**\\n\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int n=s.length();\\n        int[][] dp=new int[n][n];\\n        char[] ar=s.toCharArray();\\n        return helper(ar,0,n-1,dp);\\n    }\\n    public int helper(char[] ar,int start,int end,int[][] dp){\\n        if(dp[start][end]!=0) return dp[start][end];\\n        while(ar[start]==ar[end] && start<end){\\n            start++;\\n            end--;\\n        }\\n        if(start>=end) return 0;\\n        int val=Math.min(helper(ar,start+1,end,dp),helper(ar,start,end-1,dp));\\n        return dp[start][end]=val+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int n=s.length();\\n        int[][] dp=new int[n][n];   //dp to store if cases with current start and end character have been already handled\\n        char[] ar=s.toCharArray();\\n        return helper(ar,0,n-1,dp);\\n    }\\n    public int helper(char[] ar,int start,int end,int[][] dp){\\n        if(dp[start][end]!=0) return dp[start][end];   //if handled this case return val\\n\\n        //iterating until to outer characters dont match\\n        while(ar[start]==ar[end] && start<end){\\n            start++;\\n            end--;\\n        }\\n        //if every character in the current range match return 0\\n        if(start>=end) return 0;\\n\\n        // incrementing start pointer means we have inserted character equal to char at start in the position of end \\n        //incrementing end pointer means we have inserted character equal to char at end in the position of start\\n        int val=Math.min(helper(ar,start+1,end,dp),helper(ar,start,end-1,dp));\\n        return dp[start][end]=val+1;   //adding 1 \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        int n=s.length();\\n        int[][] dp=new int[n][n];\\n        char[] ar=s.toCharArray();\\n        return helper(ar,0,n-1,dp);\\n    }\\n    public int helper(char[] ar,int start,int end,int[][] dp){\\n        if(dp[start][end]!=0) return dp[start][end];\\n        while(ar[start]==ar[end] && start<end){\\n            start++;\\n            end--;\\n        }\\n        if(start>=end) return 0;\\n        int val=Math.min(helper(ar,start+1,end,dp),helper(ar,start,end-1,dp));\\n        return dp[start][end]=val+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443406,
                "title": "python-3-top-down-dp",
                "content": "# Intuition\\nLogic is straightforward.\\n\\nstate variable = left, right\\nDo all combination of left and right -> DP should be used.\\nIf s[left] == s[right], skip both left and right. Else, add either s[left] or s[right] and repeat the process.\\n\\n# Approach\\ntop-down dp\\n\\n# Complexity\\n- Time complexity:\\nO(n^2) -> dp on all states.\\n\\n- Space complexity:\\nO(n^2) -> cache size\\n\\n# Code\\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n\\n        @lru_cache(None)\\n        def dp(l, r): # return min step\\n            if l >= r:\\n                return 0\\n            \\n            if s[l] == s[r]:\\n                return dp(l+1, r-1)\\n\\n            else: # add left or right\\n                t1 = dp(l+1, r) + 1\\n                t2 = dp(l, r-1) + 1\\n                return min(t1, t2)\\n        \\n        return dp(0, len(s) - 1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n\\n        @lru_cache(None)\\n        def dp(l, r): # return min step\\n            if l >= r:\\n                return 0\\n            \\n            if s[l] == s[r]:\\n                return dp(l+1, r-1)\\n\\n            else: # add left or right\\n                t1 = dp(l+1, r) + 1\\n                t2 = dp(l, r-1) + 1\\n                return min(t1, t2)\\n        \\n        return dp(0, len(s) - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443374,
                "title": "clean-simple-easy-c-code-memoization",
                "content": "# Code\\n## Please Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    int helper(int i,int j,string& s,vector<vector<int>>& dp){\\n        if(i >= j)\\n            return 0;\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        int left = INT_MAX,right = INT_MAX;\\n        if(s[i] == s[j])\\n            left = helper(i+1,j-1,s,dp);\\n        else{\\n            left = 1 + helper(i+1,j,s,dp);\\n            right = 1 + helper(i,j-1,s,dp);\\n        }\\n        return dp[i][j] = min(left,right);\\n    }\\n    int minInsertions(string s) {\\n        int n = s.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        return helper(0,n-1,s,dp);\\n    }\\n};\\n```\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/f2368f92-ed3e-438c-b19e-dfa2e0bc8b4f_1682151400.3281825.png)\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int i,int j,string& s,vector<vector<int>>& dp){\\n        if(i >= j)\\n            return 0;\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        int left = INT_MAX,right = INT_MAX;\\n        if(s[i] == s[j])\\n            left = helper(i+1,j-1,s,dp);\\n        else{\\n            left = 1 + helper(i+1,j,s,dp);\\n            right = 1 + helper(i,j-1,s,dp);\\n        }\\n        return dp[i][j] = min(left,right);\\n    }\\n    int minInsertions(string s) {\\n        int n = s.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        return helper(0,n-1,s,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443350,
                "title": "java-simple-solution-using-recursion-memoization",
                "content": "# Code\\n```\\nclass Solution {\\n    public int helper(char[] arr, int i, int j, Integer[][] mem) {\\n        if(i>=j)\\n            return 0;\\n        if(mem[i][j] != null)\\n            return mem[i][j];\\n        if(arr[i] == arr[j])\\n            return mem[i][j] = helper(arr, i+1, j-1, mem);\\n        return mem[i][j] = Math.min(1+helper(arr, i+1, j, mem), 1+helper(arr, i, j-1, mem));\\n    }\\n    public int minInsertions(String s) {\\n        int n = s.length();\\n        return helper(s.toCharArray(), 0, n-1, new Integer[n][n]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int helper(char[] arr, int i, int j, Integer[][] mem) {\\n        if(i>=j)\\n            return 0;\\n        if(mem[i][j] != null)\\n            return mem[i][j];\\n        if(arr[i] == arr[j])\\n            return mem[i][j] = helper(arr, i+1, j-1, mem);\\n        return mem[i][j] = Math.min(1+helper(arr, i+1, j, mem), 1+helper(arr, i, j-1, mem));\\n    }\\n    public int minInsertions(String s) {\\n        int n = s.length();\\n        return helper(s.toCharArray(), 0, n-1, new Integer[n][n]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443337,
                "title": "ruby-dp",
                "content": "# Intuition\\n*If* s[i] == s[j] *then* no change *else* 1 change \\n\\\\+ how many changes required for min of s[i+1..j], s[i..j-1] substrings\\n\\n# Approach\\nUpside down: no changes required for substr size 1, then step to size 2 etc.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```ruby\\nclass Solver\\n    attr_reader :s, :sz\\n\\n    def initialize(s)\\n        @s, @sz = s, s.size\\n    end\\n\\n    def solve\\n        (sz - 2).downto(0).inject(Array.new(sz, 0)) {|dp, i|\\n            (i+1...sz).inject(0) {|tmp, j|\\n                (tmp, dp[j] = dp[j], ((s[i] == s[j]) ? tmp : 1 + dp[j-1..j].min)).first\\n            }\\n            dp\\n        }.last\\n    end\\nend\\n\\ndef min_insertions(s, l = 0, r = s.size-1)\\n    Solver.new(s).solve\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Dynamic Programming"
                ],
                "code": "```ruby\\nclass Solver\\n    attr_reader :s, :sz\\n\\n    def initialize(s)\\n        @s, @sz = s, s.size\\n    end\\n\\n    def solve\\n        (sz - 2).downto(0).inject(Array.new(sz, 0)) {|dp, i|\\n            (i+1...sz).inject(0) {|tmp, j|\\n                (tmp, dp[j] = dp[j], ((s[i] == s[j]) ? tmp : 1 + dp[j-1..j].min)).first\\n            }\\n            dp\\n        }.last\\n    end\\nend\\n\\ndef min_insertions(s, l = 0, r = s.size-1)\\n    Solver.new(s).solve\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443235,
                "title": "typescript-dp-simple-solution",
                "content": "\\n```\\nfunction minInsertions(s: string): number {\\n    let map={};\\n    function dp(left,right){\\n        if(left>=right)return 0;\\n        if(s[left]===s[right])return dp(left+1,right-1);\\n        if(map[left+\\':\\'+right])return map[left+\\':\\'+right];\\n        map[left+\\':\\'+right]=Math.min(dp(left+1,right),dp(left,right-1))+1;\\n        return map[left+\\':\\'+right];\\n    }\\n\\n    return dp(0,s.length-1);\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction minInsertions(s: string): number {\\n    let map={};\\n    function dp(left,right){\\n        if(left>=right)return 0;\\n        if(s[left]===s[right])return dp(left+1,right-1);\\n        if(map[left+\\':\\'+right])return map[left+\\':\\'+right];\\n        map[left+\\':\\'+right]=Math.min(dp(left+1,right),dp(left,right-1))+1;\\n        return map[left+\\':\\'+right];\\n    }\\n\\n    return dp(0,s.length-1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3443211,
                "title": "just-substract-longest-palindromic-subsequence-from-the-length-of-the-string",
                "content": "```\\nclass Solution {\\npublic:\\n    int LPS(int i,int j , string &s,vector<vector<int>> &cache)\\n    {\\n        if(i>j)\\n            return 0;\\n        if(cache[i][j]!=-1)\\n            return cache[i][j];\\n        if(i==j)\\n            return 1;\\n        if(s[i]==s[j]){\\n            \\n            return cache[i][j] =  2+(LPS(i+1,j-1,s,cache));\\n            \\n            \\n        }\\n        else\\n        {\\n            return cache[i][j] =  max(LPS(i+1,j,s,cache),LPS(i,j-1,s,cache));\\n        }\\n    }\\n    \\n    int minInsertions(string s) {\\n        int n = s.length();\\n        vector<vector<int>> cache(n,vector<int>(n,-1));\\n        int res = LPS(0,n-1,s,cache);\\n        return n-res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int LPS(int i,int j , string &s,vector<vector<int>> &cache)\\n    {\\n        if(i>j)\\n            return 0;\\n        if(cache[i][j]!=-1)\\n            return cache[i][j];\\n        if(i==j)\\n            return 1;\\n        if(s[i]==s[j]){\\n            \\n            return cache[i][j] =  2+(LPS(i+1,j-1,s,cache));\\n            \\n            \\n        }\\n        else\\n        {\\n            return cache[i][j] =  max(LPS(i+1,j,s,cache),LPS(i,j-1,s,cache));\\n        }\\n    }\\n    \\n    int minInsertions(string s) {\\n        int n = s.length();\\n        vector<vector<int>> cache(n,vector<int>(n,-1));\\n        int res = LPS(0,n-1,s,cache);\\n        return n-res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443120,
                "title": "question-of-the-day-java-easy-solution",
                "content": "\\n**Time complexity:**\\nO(n^2), where n is the length of the input string s. \\n\\n**Space complexity:**\\nO(n^2), where n is the length of the input string s. \\n\\n# Code\\n```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        String rev = new StringBuilder(s).reverse().toString();\\n        int n = s.length();\\n        int dp[][] = new int[n + 1][n + 1];\\n        for(int i = 1; i <= n; i++)\\n        {\\n            for(int j = 1; j <= n; j++)\\n            {\\n                if(s.charAt(i - 1) == rev.charAt(j - 1))\\n                {\\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\\n                }\\n                else\\n                {\\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\\n                }\\n            }\\n        }\\n        return n - dp[n][n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minInsertions(String s) {\\n        String rev = new StringBuilder(s).reverse().toString();\\n        int n = s.length();\\n        int dp[][] = new int[n + 1][n + 1];\\n        for(int i = 1; i <= n; i++)\\n        {\\n            for(int j = 1; j <= n; j++)\\n            {\\n                if(s.charAt(i - 1) == rev.charAt(j - 1))\\n                {\\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\\n                }\\n                else\\n                {\\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\\n                }\\n            }\\n        }\\n        return n - dp[n][n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443078,
                "title": "javascript-with-comments-100-100",
                "content": "# Code\\n```\\nvar minInsertions = function(s) {\\n    // dp[i] represents minimum number of insertion for first i chars\\n    const n = s.length, dp = Array(n).fill(0);\\n\\n    // Bottom up approach\\n    for(let i=n-2; ~i; --i) {\\n        let prev = 0;\\n        for(let j=i+1; j<n; ++j) {\\n            const cur = dp[j];\\n            dp[j] = s[i]===s[j] ? prev : Math.min(dp[j], dp[j-1]) + 1;\\n            prev = cur;\\n        }\\n    }\\n\\n    return dp[n-1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minInsertions = function(s) {\\n    // dp[i] represents minimum number of insertion for first i chars\\n    const n = s.length, dp = Array(n).fill(0);\\n\\n    // Bottom up approach\\n    for(let i=n-2; ~i; --i) {\\n        let prev = 0;\\n        for(let j=i+1; j<n; ++j) {\\n            const cur = dp[j];\\n            dp[j] = s[i]===s[j] ? prev : Math.min(dp[j], dp[j-1]) + 1;\\n            prev = cur;\\n        }\\n    }\\n\\n    return dp[n-1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3443021,
                "title": "java-top-down-dp-memoization-approach",
                "content": "```\\n// Approach 2: Top Down DP (Memoization)\\n\\n// Time complexity: O(n^2)\\n// Space complexity: O(n^2)\\n\\nclass Solution {\\n    int[][] memo;\\n    \\n    public int minInsertions(String s) {\\n        int n = s.length();\\n        memo = new int[n][n];\\n        return lcs(s, 0, n - 1);    \\n    }\\n    \\n    private int lcs(String s, int left, int right) {\\n        if (left > right)\\n            return 0;\\n        \\n        if (memo[left][right] != 0)\\n            return memo[left][right];\\n        \\n        if (s.charAt(left) == s.charAt(right))\\n            return memo[left][right] = lcs(s, left + 1, right - 1);\\n        \\n        return memo[left][right] = 1 + Math.min(lcs(s, left + 1, right), lcs(s, left, right - 1));\\n    }\\n}\\n```\\n\\n**Please upvote if you find this solution useful. Happy Coding!**",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n// Approach 2: Top Down DP (Memoization)\\n\\n// Time complexity: O(n^2)\\n// Space complexity: O(n^2)\\n\\nclass Solution {\\n    int[][] memo;\\n    \\n    public int minInsertions(String s) {\\n        int n = s.length();\\n        memo = new int[n][n];\\n        return lcs(s, 0, n - 1);    \\n    }\\n    \\n    private int lcs(String s, int left, int right) {\\n        if (left > right)\\n            return 0;\\n        \\n        if (memo[left][right] != 0)\\n            return memo[left][right];\\n        \\n        if (s.charAt(left) == s.charAt(right))\\n            return memo[left][right] = lcs(s, left + 1, right - 1);\\n        \\n        return memo[left][right] = 1 + Math.min(lcs(s, left + 1, right), lcs(s, left, right - 1));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443020,
                "title": "easy-dp-solution-with-explanation-go",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe define a 2D array \"dp\", where `dp[i][j]` represents the minimum number of insertions needed to make the substring `s[i..j]` a palindrome. \\n\\nObviously, when `i=j`, `dp[i][j]=0` because a single character is already a palindrome.\\n\\nNext, we consider how to convert `dp[i][j]` to `dp[i+1][j-1]`, that is, how to determine the palindromic property of `s[i..j]`. If `s[i]` and `s[j]` are equal, then `s[i..j]` is already a palindrome and we don\\'t need to insert any characters. Otherwise, we need to insert a character in either `s[i..j-1]` or `s[i+1..j]` to make it a palindrome.\\n\\nSpecifically, if we insert `s[j]` in `s[i..j-1]`, then `dp[i][j] = dp[i][j-1] + 1`. If we insert `s[i]` in `s[i+1..j]`, then `dp[i][j] = dp[i+1][j] + 1`. We can take the minimum value of these two cases as the value of `dp[i][j]`.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n$$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc minInsertions(s string) int {\\n    n := len(s)\\n    dp := make([][]int, n)\\n    for i := range dp {\\n        dp[i] = make([]int, n)\\n    }\\n    for i := n - 2; i >= 0; i-- {\\n        for j := i + 1; j < n; j++ {\\n            if s[i] == s[j] {\\n                dp[i][j] = dp[i+1][j-1]\\n            } else {\\n                dp[i][j] = min(dp[i+1][j], dp[i][j-1]) + 1\\n            }\\n        }\\n    }\\n    return dp[0][n-1]\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunc minInsertions(s string) int {\\n    n := len(s)\\n    dp := make([][]int, n)\\n    for i := range dp {\\n        dp[i] = make([]int, n)\\n    }\\n    for i := n - 2; i >= 0; i-- {\\n        for j := i + 1; j < n; j++ {\\n            if s[i] == s[j] {\\n                dp[i][j] = dp[i+1][j-1]\\n            } else {\\n                dp[i][j] = min(dp[i+1][j], dp[i][j-1]) + 1\\n            }\\n        }\\n    }\\n    return dp[0][n-1]\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3443018,
                "title": "recursive-memoization-dp-c",
                "content": "```\\nclass Solution {\\n    int dfs(int i, int j, string &s, vector<vector<int>> &dp) {\\n        if(i >= j) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        if(s[i] == s[j]) return dp[i][j] = dfs(i + 1, j - 1, s, dp);\\n        return dp[i][j] = 1 + min(dfs(i + 1, j, s, dp), dfs(i, j - 1, s, dp));\\n    }\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.size();\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        return dfs(0, n - 1, s, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(int i, int j, string &s, vector<vector<int>> &dp) {\\n        if(i >= j) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        if(s[i] == s[j]) return dp[i][j] = dfs(i + 1, j - 1, s, dp);\\n        return dp[i][j] = 1 + min(dfs(i + 1, j, s, dp), dfs(i, j - 1, s, dp));\\n    }\\npublic:\\n    int minInsertions(string s) {\\n        int n = s.size();\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        return dfs(0, n - 1, s, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443000,
                "title": "recursive-memoized-solution",
                "content": "Similar Questions - #5 Longest Palindromic Substring\\n                  - #647 Palindromic Substrings\\n```\\nclass Solution {\\npublic:\\nint dp[501][501]; // States - start index and end index\\n\\nint solve(string& s, int ind1, int ind2){\\n    if(ind1 == ind2) return 0;\\n\\n    if(ind2 - ind1 == 1){\\n        if(s[ind1] == s[ind2]) return 0;\\n        else return 1;\\n    }\\n\\n    if(dp[ind1][ind2] != -1) return dp[ind1][ind2];\\n    \\n    int ans;\\n\\n    ans = 1 + min(solve(s,ind1,ind2-1), solve(s,ind1+1,ind2));\\n\\n    if(s[ind1] == s[ind2]) ans = min(ans, solve(s,ind1+1,ind2 -1));\\n\\n    return dp[ind1][ind2] = ans;\\n }\\n    int minInsertions(string s) {\\n    memset(dp,-1,sizeof(dp));\\n\\n    return solve(s,0,s.size()-1);\\n\\n    }\\n};\\n```\\nTc: O(n^2) Amortized \\nSpace: O(n^2)\\n\\nFeel free to ask any doubts in the comments!",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint dp[501][501]; // States - start index and end index\\n\\nint solve(string& s, int ind1, int ind2){\\n    if(ind1 == ind2) return 0;\\n\\n    if(ind2 - ind1 == 1){\\n        if(s[ind1] == s[ind2]) return 0;\\n        else return 1;\\n    }\\n\\n    if(dp[ind1][ind2] != -1) return dp[ind1][ind2];\\n    \\n    int ans;\\n\\n    ans = 1 + min(solve(s,ind1,ind2-1), solve(s,ind1+1,ind2));\\n\\n    if(s[ind1] == s[ind2]) ans = min(ans, solve(s,ind1+1,ind2 -1));\\n\\n    return dp[ind1][ind2] = ans;\\n }\\n    int minInsertions(string s) {\\n    memset(dp,-1,sizeof(dp));\\n\\n    return solve(s,0,s.size()-1);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442984,
                "title": "python-top-down-memoization-solution",
                "content": "```\\neg: leetcode \\nWe try to insert at both ends if not equal\\n\\n1. Insert to the right and  match \\'l\\', cost is 1 then check remaining string  : 1 + rec(i+1,j)\\n2. Insert to left and match \\'e\\' , cost is 1 then check the remaining string : 1+rec(i,j-1)\\n3. if the ends are the same character , no cost : rec(i+1,j) \\n```\\n\\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        @lru_cache(None)\\n        def rec(i,j):\\n            if(i>=j ) : return 0\\n            elif(s[i]==s[j]): return rec(i+1,j-1) \\n            else: return 1+ min( rec(i+1,j) , rec(i,j-1))\\n        return rec(0,len(s)-1)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\neg: leetcode \\nWe try to insert at both ends if not equal\\n\\n1. Insert to the right and  match \\'l\\', cost is 1 then check remaining string  : 1 + rec(i+1,j)\\n2. Insert to left and match \\'e\\' , cost is 1 then check the remaining string : 1+rec(i,j-1)\\n3. if the ends are the same character , no cost : rec(i+1,j) \\n```\n```\\nclass Solution:\\n    def minInsertions(self, s: str) -> int:\\n        @lru_cache(None)\\n        def rec(i,j):\\n            if(i>=j ) : return 0\\n            elif(s[i]==s[j]): return rec(i+1,j-1) \\n            else: return 1+ min( rec(i+1,j) , rec(i,j-1))\\n        return rec(0,len(s)-1)\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1870522,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "My brain still hurts from yesterday"
                    },
                    {
                        "username": "jihweiliang",
                        "content": "It is super easy today. "
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "Can you share yesterday\\'s question?"
                    },
                    {
                        "username": "code_er7",
                        "content": "yesterday was kinda easy"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Mediums are marked as Hard\\nHards are marked as Medium\\nLeetcode\\u2615"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "Sahi kaha green color matching mandir wale babu😏 "
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "how can you say that for me all are hard!\\n"
                    },
                    {
                        "username": "alt909",
                        "content": "I panicked until I realized this one is actually an easy."
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Text1.length - longest palindromic subsequence"
                    },
                    {
                        "username": "Finesse",
                        "content": "It's very easy to solve with a simple dynamic programming:\n\n1. Use 2 pointers to walk from the string edges towards the center.\n2. When the letters at the pointers don't match, you can either add a letter on the left or add a letter on the right. In both cases you get a smaller problem (finding a solution for a substring).\n3. Solve both smaller problems recursively and choose the best result.\n\nNo need to know anything about the longest common subsequence algorithm, which is much harder."
                    },
                    {
                        "username": "portableCoder",
                        "content": "[@Mister_CK](/Mister_CK)  it's a state problem! you don't need the answer parameter. Remove that and replace it with this: (you also need memoization btw)\n```js\nvar minInsertions = function(s) {\n    let l = 0\n    let r = s.length -1\n    let state = {}\n    const makePalindrome = (left, right, word) => {\n       const st = `${left},${right}`\n        if(state[st] !== undefined) return state[st]\n        if (left >= right) return 0\n        if (word[left] === word[right]) {\nstate[st] = makePalindrome(left+1, right-1, word)\n   return state[st]\n}\n       state[st] = 1 + Math.min(makePalindrome(left, right-1, word), makePalindrome(left+1, right, word))\n     return state[st]\n\n    }\n    return makePalindrome(l, r, s)\n};\n```"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@Mister_CK](/Mister_CK) Yes this absolutely needs Memoization, realise that the number of calls to makePalindrome grows exponentially. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wrote the code as you described, but that gives me TLE, how do you prevent that from happening? Memoization? for reference this is my code (I solved it with last weeks code for LPS, but just curious):\\n\\n```\\nvar minInsertions = function(s) {\\n    let l = 0\\n    let r = s.length -1\\n    const makePalindrome = (left, right, word, answer) => {\\n        if (left >= right) return answer\\n        if (word[left] === word[right]) return makePalindrome(left+1, right-1, word, answer)\\n        else return Math.min(makePalindrome(left, right-1, word, answer+1), makePalindrome(left+1, right, word, answer+1))\\n    }\\n    return makePalindrome(l, r, s, 0)\\n};\\n```"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "definitely not a hard question !! also question must also can be stated as minimum no of deletions to make it a palidrome"
                    },
                    {
                        "username": "0xatul",
                        "content": "try coming up for a LCS solution by yourself, you will know why its hard"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "damn!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "That's the point\nIt's pretty tuff to notice that number of deletions will be equal to number of insertions"
                    },
                    {
                        "username": "crusifixx",
                        "content": "LeetCode\\'s urge to assign hard questions on weekends\\uD83D\\uDCC8\\uD83D\\uDCC8\\uD83D\\uDCC8"
                    },
                    {
                        "username": "bytecode15",
                        "content": "Leetcode and Weekends don\\'t match the vibe!\\n"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "yo!\\n"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Implicit LCS."
                    },
                    {
                        "username": "SidKay",
                        "content": "Alright, alright Leetcode, you win.\\nI\\'ll learn about dynamic programming now."
                    }
                ]
            },
            {
                "id": 1870678,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "My brain still hurts from yesterday"
                    },
                    {
                        "username": "jihweiliang",
                        "content": "It is super easy today. "
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "Can you share yesterday\\'s question?"
                    },
                    {
                        "username": "code_er7",
                        "content": "yesterday was kinda easy"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Mediums are marked as Hard\\nHards are marked as Medium\\nLeetcode\\u2615"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "Sahi kaha green color matching mandir wale babu😏 "
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "how can you say that for me all are hard!\\n"
                    },
                    {
                        "username": "alt909",
                        "content": "I panicked until I realized this one is actually an easy."
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Text1.length - longest palindromic subsequence"
                    },
                    {
                        "username": "Finesse",
                        "content": "It's very easy to solve with a simple dynamic programming:\n\n1. Use 2 pointers to walk from the string edges towards the center.\n2. When the letters at the pointers don't match, you can either add a letter on the left or add a letter on the right. In both cases you get a smaller problem (finding a solution for a substring).\n3. Solve both smaller problems recursively and choose the best result.\n\nNo need to know anything about the longest common subsequence algorithm, which is much harder."
                    },
                    {
                        "username": "portableCoder",
                        "content": "[@Mister_CK](/Mister_CK)  it's a state problem! you don't need the answer parameter. Remove that and replace it with this: (you also need memoization btw)\n```js\nvar minInsertions = function(s) {\n    let l = 0\n    let r = s.length -1\n    let state = {}\n    const makePalindrome = (left, right, word) => {\n       const st = `${left},${right}`\n        if(state[st] !== undefined) return state[st]\n        if (left >= right) return 0\n        if (word[left] === word[right]) {\nstate[st] = makePalindrome(left+1, right-1, word)\n   return state[st]\n}\n       state[st] = 1 + Math.min(makePalindrome(left, right-1, word), makePalindrome(left+1, right, word))\n     return state[st]\n\n    }\n    return makePalindrome(l, r, s)\n};\n```"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@Mister_CK](/Mister_CK) Yes this absolutely needs Memoization, realise that the number of calls to makePalindrome grows exponentially. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wrote the code as you described, but that gives me TLE, how do you prevent that from happening? Memoization? for reference this is my code (I solved it with last weeks code for LPS, but just curious):\\n\\n```\\nvar minInsertions = function(s) {\\n    let l = 0\\n    let r = s.length -1\\n    const makePalindrome = (left, right, word, answer) => {\\n        if (left >= right) return answer\\n        if (word[left] === word[right]) return makePalindrome(left+1, right-1, word, answer)\\n        else return Math.min(makePalindrome(left, right-1, word, answer+1), makePalindrome(left+1, right, word, answer+1))\\n    }\\n    return makePalindrome(l, r, s, 0)\\n};\\n```"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "definitely not a hard question !! also question must also can be stated as minimum no of deletions to make it a palidrome"
                    },
                    {
                        "username": "0xatul",
                        "content": "try coming up for a LCS solution by yourself, you will know why its hard"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "damn!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "That's the point\nIt's pretty tuff to notice that number of deletions will be equal to number of insertions"
                    },
                    {
                        "username": "crusifixx",
                        "content": "LeetCode\\'s urge to assign hard questions on weekends\\uD83D\\uDCC8\\uD83D\\uDCC8\\uD83D\\uDCC8"
                    },
                    {
                        "username": "bytecode15",
                        "content": "Leetcode and Weekends don\\'t match the vibe!\\n"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "yo!\\n"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Implicit LCS."
                    },
                    {
                        "username": "SidKay",
                        "content": "Alright, alright Leetcode, you win.\\nI\\'ll learn about dynamic programming now."
                    }
                ]
            },
            {
                "id": 1870520,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "My brain still hurts from yesterday"
                    },
                    {
                        "username": "jihweiliang",
                        "content": "It is super easy today. "
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "Can you share yesterday\\'s question?"
                    },
                    {
                        "username": "code_er7",
                        "content": "yesterday was kinda easy"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Mediums are marked as Hard\\nHards are marked as Medium\\nLeetcode\\u2615"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "Sahi kaha green color matching mandir wale babu😏 "
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "how can you say that for me all are hard!\\n"
                    },
                    {
                        "username": "alt909",
                        "content": "I panicked until I realized this one is actually an easy."
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Text1.length - longest palindromic subsequence"
                    },
                    {
                        "username": "Finesse",
                        "content": "It's very easy to solve with a simple dynamic programming:\n\n1. Use 2 pointers to walk from the string edges towards the center.\n2. When the letters at the pointers don't match, you can either add a letter on the left or add a letter on the right. In both cases you get a smaller problem (finding a solution for a substring).\n3. Solve both smaller problems recursively and choose the best result.\n\nNo need to know anything about the longest common subsequence algorithm, which is much harder."
                    },
                    {
                        "username": "portableCoder",
                        "content": "[@Mister_CK](/Mister_CK)  it's a state problem! you don't need the answer parameter. Remove that and replace it with this: (you also need memoization btw)\n```js\nvar minInsertions = function(s) {\n    let l = 0\n    let r = s.length -1\n    let state = {}\n    const makePalindrome = (left, right, word) => {\n       const st = `${left},${right}`\n        if(state[st] !== undefined) return state[st]\n        if (left >= right) return 0\n        if (word[left] === word[right]) {\nstate[st] = makePalindrome(left+1, right-1, word)\n   return state[st]\n}\n       state[st] = 1 + Math.min(makePalindrome(left, right-1, word), makePalindrome(left+1, right, word))\n     return state[st]\n\n    }\n    return makePalindrome(l, r, s)\n};\n```"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@Mister_CK](/Mister_CK) Yes this absolutely needs Memoization, realise that the number of calls to makePalindrome grows exponentially. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wrote the code as you described, but that gives me TLE, how do you prevent that from happening? Memoization? for reference this is my code (I solved it with last weeks code for LPS, but just curious):\\n\\n```\\nvar minInsertions = function(s) {\\n    let l = 0\\n    let r = s.length -1\\n    const makePalindrome = (left, right, word, answer) => {\\n        if (left >= right) return answer\\n        if (word[left] === word[right]) return makePalindrome(left+1, right-1, word, answer)\\n        else return Math.min(makePalindrome(left, right-1, word, answer+1), makePalindrome(left+1, right, word, answer+1))\\n    }\\n    return makePalindrome(l, r, s, 0)\\n};\\n```"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "definitely not a hard question !! also question must also can be stated as minimum no of deletions to make it a palidrome"
                    },
                    {
                        "username": "0xatul",
                        "content": "try coming up for a LCS solution by yourself, you will know why its hard"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "damn!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "That's the point\nIt's pretty tuff to notice that number of deletions will be equal to number of insertions"
                    },
                    {
                        "username": "crusifixx",
                        "content": "LeetCode\\'s urge to assign hard questions on weekends\\uD83D\\uDCC8\\uD83D\\uDCC8\\uD83D\\uDCC8"
                    },
                    {
                        "username": "bytecode15",
                        "content": "Leetcode and Weekends don\\'t match the vibe!\\n"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "yo!\\n"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Implicit LCS."
                    },
                    {
                        "username": "SidKay",
                        "content": "Alright, alright Leetcode, you win.\\nI\\'ll learn about dynamic programming now."
                    }
                ]
            },
            {
                "id": 1844262,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "My brain still hurts from yesterday"
                    },
                    {
                        "username": "jihweiliang",
                        "content": "It is super easy today. "
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "Can you share yesterday\\'s question?"
                    },
                    {
                        "username": "code_er7",
                        "content": "yesterday was kinda easy"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Mediums are marked as Hard\\nHards are marked as Medium\\nLeetcode\\u2615"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "Sahi kaha green color matching mandir wale babu😏 "
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "how can you say that for me all are hard!\\n"
                    },
                    {
                        "username": "alt909",
                        "content": "I panicked until I realized this one is actually an easy."
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Text1.length - longest palindromic subsequence"
                    },
                    {
                        "username": "Finesse",
                        "content": "It's very easy to solve with a simple dynamic programming:\n\n1. Use 2 pointers to walk from the string edges towards the center.\n2. When the letters at the pointers don't match, you can either add a letter on the left or add a letter on the right. In both cases you get a smaller problem (finding a solution for a substring).\n3. Solve both smaller problems recursively and choose the best result.\n\nNo need to know anything about the longest common subsequence algorithm, which is much harder."
                    },
                    {
                        "username": "portableCoder",
                        "content": "[@Mister_CK](/Mister_CK)  it's a state problem! you don't need the answer parameter. Remove that and replace it with this: (you also need memoization btw)\n```js\nvar minInsertions = function(s) {\n    let l = 0\n    let r = s.length -1\n    let state = {}\n    const makePalindrome = (left, right, word) => {\n       const st = `${left},${right}`\n        if(state[st] !== undefined) return state[st]\n        if (left >= right) return 0\n        if (word[left] === word[right]) {\nstate[st] = makePalindrome(left+1, right-1, word)\n   return state[st]\n}\n       state[st] = 1 + Math.min(makePalindrome(left, right-1, word), makePalindrome(left+1, right, word))\n     return state[st]\n\n    }\n    return makePalindrome(l, r, s)\n};\n```"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@Mister_CK](/Mister_CK) Yes this absolutely needs Memoization, realise that the number of calls to makePalindrome grows exponentially. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wrote the code as you described, but that gives me TLE, how do you prevent that from happening? Memoization? for reference this is my code (I solved it with last weeks code for LPS, but just curious):\\n\\n```\\nvar minInsertions = function(s) {\\n    let l = 0\\n    let r = s.length -1\\n    const makePalindrome = (left, right, word, answer) => {\\n        if (left >= right) return answer\\n        if (word[left] === word[right]) return makePalindrome(left+1, right-1, word, answer)\\n        else return Math.min(makePalindrome(left, right-1, word, answer+1), makePalindrome(left+1, right, word, answer+1))\\n    }\\n    return makePalindrome(l, r, s, 0)\\n};\\n```"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "definitely not a hard question !! also question must also can be stated as minimum no of deletions to make it a palidrome"
                    },
                    {
                        "username": "0xatul",
                        "content": "try coming up for a LCS solution by yourself, you will know why its hard"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "damn!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "That's the point\nIt's pretty tuff to notice that number of deletions will be equal to number of insertions"
                    },
                    {
                        "username": "crusifixx",
                        "content": "LeetCode\\'s urge to assign hard questions on weekends\\uD83D\\uDCC8\\uD83D\\uDCC8\\uD83D\\uDCC8"
                    },
                    {
                        "username": "bytecode15",
                        "content": "Leetcode and Weekends don\\'t match the vibe!\\n"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "yo!\\n"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Implicit LCS."
                    },
                    {
                        "username": "SidKay",
                        "content": "Alright, alright Leetcode, you win.\\nI\\'ll learn about dynamic programming now."
                    }
                ]
            },
            {
                "id": 1855199,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "My brain still hurts from yesterday"
                    },
                    {
                        "username": "jihweiliang",
                        "content": "It is super easy today. "
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "Can you share yesterday\\'s question?"
                    },
                    {
                        "username": "code_er7",
                        "content": "yesterday was kinda easy"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Mediums are marked as Hard\\nHards are marked as Medium\\nLeetcode\\u2615"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "Sahi kaha green color matching mandir wale babu😏 "
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "how can you say that for me all are hard!\\n"
                    },
                    {
                        "username": "alt909",
                        "content": "I panicked until I realized this one is actually an easy."
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Text1.length - longest palindromic subsequence"
                    },
                    {
                        "username": "Finesse",
                        "content": "It's very easy to solve with a simple dynamic programming:\n\n1. Use 2 pointers to walk from the string edges towards the center.\n2. When the letters at the pointers don't match, you can either add a letter on the left or add a letter on the right. In both cases you get a smaller problem (finding a solution for a substring).\n3. Solve both smaller problems recursively and choose the best result.\n\nNo need to know anything about the longest common subsequence algorithm, which is much harder."
                    },
                    {
                        "username": "portableCoder",
                        "content": "[@Mister_CK](/Mister_CK)  it's a state problem! you don't need the answer parameter. Remove that and replace it with this: (you also need memoization btw)\n```js\nvar minInsertions = function(s) {\n    let l = 0\n    let r = s.length -1\n    let state = {}\n    const makePalindrome = (left, right, word) => {\n       const st = `${left},${right}`\n        if(state[st] !== undefined) return state[st]\n        if (left >= right) return 0\n        if (word[left] === word[right]) {\nstate[st] = makePalindrome(left+1, right-1, word)\n   return state[st]\n}\n       state[st] = 1 + Math.min(makePalindrome(left, right-1, word), makePalindrome(left+1, right, word))\n     return state[st]\n\n    }\n    return makePalindrome(l, r, s)\n};\n```"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@Mister_CK](/Mister_CK) Yes this absolutely needs Memoization, realise that the number of calls to makePalindrome grows exponentially. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wrote the code as you described, but that gives me TLE, how do you prevent that from happening? Memoization? for reference this is my code (I solved it with last weeks code for LPS, but just curious):\\n\\n```\\nvar minInsertions = function(s) {\\n    let l = 0\\n    let r = s.length -1\\n    const makePalindrome = (left, right, word, answer) => {\\n        if (left >= right) return answer\\n        if (word[left] === word[right]) return makePalindrome(left+1, right-1, word, answer)\\n        else return Math.min(makePalindrome(left, right-1, word, answer+1), makePalindrome(left+1, right, word, answer+1))\\n    }\\n    return makePalindrome(l, r, s, 0)\\n};\\n```"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "definitely not a hard question !! also question must also can be stated as minimum no of deletions to make it a palidrome"
                    },
                    {
                        "username": "0xatul",
                        "content": "try coming up for a LCS solution by yourself, you will know why its hard"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "damn!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "That's the point\nIt's pretty tuff to notice that number of deletions will be equal to number of insertions"
                    },
                    {
                        "username": "crusifixx",
                        "content": "LeetCode\\'s urge to assign hard questions on weekends\\uD83D\\uDCC8\\uD83D\\uDCC8\\uD83D\\uDCC8"
                    },
                    {
                        "username": "bytecode15",
                        "content": "Leetcode and Weekends don\\'t match the vibe!\\n"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "yo!\\n"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Implicit LCS."
                    },
                    {
                        "username": "SidKay",
                        "content": "Alright, alright Leetcode, you win.\\nI\\'ll learn about dynamic programming now."
                    }
                ]
            },
            {
                "id": 1738234,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "My brain still hurts from yesterday"
                    },
                    {
                        "username": "jihweiliang",
                        "content": "It is super easy today. "
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "Can you share yesterday\\'s question?"
                    },
                    {
                        "username": "code_er7",
                        "content": "yesterday was kinda easy"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Mediums are marked as Hard\\nHards are marked as Medium\\nLeetcode\\u2615"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "Sahi kaha green color matching mandir wale babu😏 "
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "how can you say that for me all are hard!\\n"
                    },
                    {
                        "username": "alt909",
                        "content": "I panicked until I realized this one is actually an easy."
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Text1.length - longest palindromic subsequence"
                    },
                    {
                        "username": "Finesse",
                        "content": "It's very easy to solve with a simple dynamic programming:\n\n1. Use 2 pointers to walk from the string edges towards the center.\n2. When the letters at the pointers don't match, you can either add a letter on the left or add a letter on the right. In both cases you get a smaller problem (finding a solution for a substring).\n3. Solve both smaller problems recursively and choose the best result.\n\nNo need to know anything about the longest common subsequence algorithm, which is much harder."
                    },
                    {
                        "username": "portableCoder",
                        "content": "[@Mister_CK](/Mister_CK)  it's a state problem! you don't need the answer parameter. Remove that and replace it with this: (you also need memoization btw)\n```js\nvar minInsertions = function(s) {\n    let l = 0\n    let r = s.length -1\n    let state = {}\n    const makePalindrome = (left, right, word) => {\n       const st = `${left},${right}`\n        if(state[st] !== undefined) return state[st]\n        if (left >= right) return 0\n        if (word[left] === word[right]) {\nstate[st] = makePalindrome(left+1, right-1, word)\n   return state[st]\n}\n       state[st] = 1 + Math.min(makePalindrome(left, right-1, word), makePalindrome(left+1, right, word))\n     return state[st]\n\n    }\n    return makePalindrome(l, r, s)\n};\n```"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@Mister_CK](/Mister_CK) Yes this absolutely needs Memoization, realise that the number of calls to makePalindrome grows exponentially. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wrote the code as you described, but that gives me TLE, how do you prevent that from happening? Memoization? for reference this is my code (I solved it with last weeks code for LPS, but just curious):\\n\\n```\\nvar minInsertions = function(s) {\\n    let l = 0\\n    let r = s.length -1\\n    const makePalindrome = (left, right, word, answer) => {\\n        if (left >= right) return answer\\n        if (word[left] === word[right]) return makePalindrome(left+1, right-1, word, answer)\\n        else return Math.min(makePalindrome(left, right-1, word, answer+1), makePalindrome(left+1, right, word, answer+1))\\n    }\\n    return makePalindrome(l, r, s, 0)\\n};\\n```"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "definitely not a hard question !! also question must also can be stated as minimum no of deletions to make it a palidrome"
                    },
                    {
                        "username": "0xatul",
                        "content": "try coming up for a LCS solution by yourself, you will know why its hard"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "damn!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "That's the point\nIt's pretty tuff to notice that number of deletions will be equal to number of insertions"
                    },
                    {
                        "username": "crusifixx",
                        "content": "LeetCode\\'s urge to assign hard questions on weekends\\uD83D\\uDCC8\\uD83D\\uDCC8\\uD83D\\uDCC8"
                    },
                    {
                        "username": "bytecode15",
                        "content": "Leetcode and Weekends don\\'t match the vibe!\\n"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "yo!\\n"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Implicit LCS."
                    },
                    {
                        "username": "SidKay",
                        "content": "Alright, alright Leetcode, you win.\\nI\\'ll learn about dynamic programming now."
                    }
                ]
            },
            {
                "id": 1870671,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "My brain still hurts from yesterday"
                    },
                    {
                        "username": "jihweiliang",
                        "content": "It is super easy today. "
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "Can you share yesterday\\'s question?"
                    },
                    {
                        "username": "code_er7",
                        "content": "yesterday was kinda easy"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Mediums are marked as Hard\\nHards are marked as Medium\\nLeetcode\\u2615"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "Sahi kaha green color matching mandir wale babu😏 "
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "how can you say that for me all are hard!\\n"
                    },
                    {
                        "username": "alt909",
                        "content": "I panicked until I realized this one is actually an easy."
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Text1.length - longest palindromic subsequence"
                    },
                    {
                        "username": "Finesse",
                        "content": "It's very easy to solve with a simple dynamic programming:\n\n1. Use 2 pointers to walk from the string edges towards the center.\n2. When the letters at the pointers don't match, you can either add a letter on the left or add a letter on the right. In both cases you get a smaller problem (finding a solution for a substring).\n3. Solve both smaller problems recursively and choose the best result.\n\nNo need to know anything about the longest common subsequence algorithm, which is much harder."
                    },
                    {
                        "username": "portableCoder",
                        "content": "[@Mister_CK](/Mister_CK)  it's a state problem! you don't need the answer parameter. Remove that and replace it with this: (you also need memoization btw)\n```js\nvar minInsertions = function(s) {\n    let l = 0\n    let r = s.length -1\n    let state = {}\n    const makePalindrome = (left, right, word) => {\n       const st = `${left},${right}`\n        if(state[st] !== undefined) return state[st]\n        if (left >= right) return 0\n        if (word[left] === word[right]) {\nstate[st] = makePalindrome(left+1, right-1, word)\n   return state[st]\n}\n       state[st] = 1 + Math.min(makePalindrome(left, right-1, word), makePalindrome(left+1, right, word))\n     return state[st]\n\n    }\n    return makePalindrome(l, r, s)\n};\n```"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@Mister_CK](/Mister_CK) Yes this absolutely needs Memoization, realise that the number of calls to makePalindrome grows exponentially. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wrote the code as you described, but that gives me TLE, how do you prevent that from happening? Memoization? for reference this is my code (I solved it with last weeks code for LPS, but just curious):\\n\\n```\\nvar minInsertions = function(s) {\\n    let l = 0\\n    let r = s.length -1\\n    const makePalindrome = (left, right, word, answer) => {\\n        if (left >= right) return answer\\n        if (word[left] === word[right]) return makePalindrome(left+1, right-1, word, answer)\\n        else return Math.min(makePalindrome(left, right-1, word, answer+1), makePalindrome(left+1, right, word, answer+1))\\n    }\\n    return makePalindrome(l, r, s, 0)\\n};\\n```"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "definitely not a hard question !! also question must also can be stated as minimum no of deletions to make it a palidrome"
                    },
                    {
                        "username": "0xatul",
                        "content": "try coming up for a LCS solution by yourself, you will know why its hard"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "damn!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "That's the point\nIt's pretty tuff to notice that number of deletions will be equal to number of insertions"
                    },
                    {
                        "username": "crusifixx",
                        "content": "LeetCode\\'s urge to assign hard questions on weekends\\uD83D\\uDCC8\\uD83D\\uDCC8\\uD83D\\uDCC8"
                    },
                    {
                        "username": "bytecode15",
                        "content": "Leetcode and Weekends don\\'t match the vibe!\\n"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "yo!\\n"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Implicit LCS."
                    },
                    {
                        "username": "SidKay",
                        "content": "Alright, alright Leetcode, you win.\\nI\\'ll learn about dynamic programming now."
                    }
                ]
            },
            {
                "id": 1870800,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "My brain still hurts from yesterday"
                    },
                    {
                        "username": "jihweiliang",
                        "content": "It is super easy today. "
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "Can you share yesterday\\'s question?"
                    },
                    {
                        "username": "code_er7",
                        "content": "yesterday was kinda easy"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Mediums are marked as Hard\\nHards are marked as Medium\\nLeetcode\\u2615"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "Sahi kaha green color matching mandir wale babu😏 "
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "how can you say that for me all are hard!\\n"
                    },
                    {
                        "username": "alt909",
                        "content": "I panicked until I realized this one is actually an easy."
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Text1.length - longest palindromic subsequence"
                    },
                    {
                        "username": "Finesse",
                        "content": "It's very easy to solve with a simple dynamic programming:\n\n1. Use 2 pointers to walk from the string edges towards the center.\n2. When the letters at the pointers don't match, you can either add a letter on the left or add a letter on the right. In both cases you get a smaller problem (finding a solution for a substring).\n3. Solve both smaller problems recursively and choose the best result.\n\nNo need to know anything about the longest common subsequence algorithm, which is much harder."
                    },
                    {
                        "username": "portableCoder",
                        "content": "[@Mister_CK](/Mister_CK)  it's a state problem! you don't need the answer parameter. Remove that and replace it with this: (you also need memoization btw)\n```js\nvar minInsertions = function(s) {\n    let l = 0\n    let r = s.length -1\n    let state = {}\n    const makePalindrome = (left, right, word) => {\n       const st = `${left},${right}`\n        if(state[st] !== undefined) return state[st]\n        if (left >= right) return 0\n        if (word[left] === word[right]) {\nstate[st] = makePalindrome(left+1, right-1, word)\n   return state[st]\n}\n       state[st] = 1 + Math.min(makePalindrome(left, right-1, word), makePalindrome(left+1, right, word))\n     return state[st]\n\n    }\n    return makePalindrome(l, r, s)\n};\n```"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@Mister_CK](/Mister_CK) Yes this absolutely needs Memoization, realise that the number of calls to makePalindrome grows exponentially. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wrote the code as you described, but that gives me TLE, how do you prevent that from happening? Memoization? for reference this is my code (I solved it with last weeks code for LPS, but just curious):\\n\\n```\\nvar minInsertions = function(s) {\\n    let l = 0\\n    let r = s.length -1\\n    const makePalindrome = (left, right, word, answer) => {\\n        if (left >= right) return answer\\n        if (word[left] === word[right]) return makePalindrome(left+1, right-1, word, answer)\\n        else return Math.min(makePalindrome(left, right-1, word, answer+1), makePalindrome(left+1, right, word, answer+1))\\n    }\\n    return makePalindrome(l, r, s, 0)\\n};\\n```"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "definitely not a hard question !! also question must also can be stated as minimum no of deletions to make it a palidrome"
                    },
                    {
                        "username": "0xatul",
                        "content": "try coming up for a LCS solution by yourself, you will know why its hard"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "damn!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "That's the point\nIt's pretty tuff to notice that number of deletions will be equal to number of insertions"
                    },
                    {
                        "username": "crusifixx",
                        "content": "LeetCode\\'s urge to assign hard questions on weekends\\uD83D\\uDCC8\\uD83D\\uDCC8\\uD83D\\uDCC8"
                    },
                    {
                        "username": "bytecode15",
                        "content": "Leetcode and Weekends don\\'t match the vibe!\\n"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "yo!\\n"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Implicit LCS."
                    },
                    {
                        "username": "SidKay",
                        "content": "Alright, alright Leetcode, you win.\\nI\\'ll learn about dynamic programming now."
                    }
                ]
            },
            {
                "id": 1800924,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "My brain still hurts from yesterday"
                    },
                    {
                        "username": "jihweiliang",
                        "content": "It is super easy today. "
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "Can you share yesterday\\'s question?"
                    },
                    {
                        "username": "code_er7",
                        "content": "yesterday was kinda easy"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Mediums are marked as Hard\\nHards are marked as Medium\\nLeetcode\\u2615"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "Sahi kaha green color matching mandir wale babu😏 "
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "how can you say that for me all are hard!\\n"
                    },
                    {
                        "username": "alt909",
                        "content": "I panicked until I realized this one is actually an easy."
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Text1.length - longest palindromic subsequence"
                    },
                    {
                        "username": "Finesse",
                        "content": "It's very easy to solve with a simple dynamic programming:\n\n1. Use 2 pointers to walk from the string edges towards the center.\n2. When the letters at the pointers don't match, you can either add a letter on the left or add a letter on the right. In both cases you get a smaller problem (finding a solution for a substring).\n3. Solve both smaller problems recursively and choose the best result.\n\nNo need to know anything about the longest common subsequence algorithm, which is much harder."
                    },
                    {
                        "username": "portableCoder",
                        "content": "[@Mister_CK](/Mister_CK)  it's a state problem! you don't need the answer parameter. Remove that and replace it with this: (you also need memoization btw)\n```js\nvar minInsertions = function(s) {\n    let l = 0\n    let r = s.length -1\n    let state = {}\n    const makePalindrome = (left, right, word) => {\n       const st = `${left},${right}`\n        if(state[st] !== undefined) return state[st]\n        if (left >= right) return 0\n        if (word[left] === word[right]) {\nstate[st] = makePalindrome(left+1, right-1, word)\n   return state[st]\n}\n       state[st] = 1 + Math.min(makePalindrome(left, right-1, word), makePalindrome(left+1, right, word))\n     return state[st]\n\n    }\n    return makePalindrome(l, r, s)\n};\n```"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@Mister_CK](/Mister_CK) Yes this absolutely needs Memoization, realise that the number of calls to makePalindrome grows exponentially. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wrote the code as you described, but that gives me TLE, how do you prevent that from happening? Memoization? for reference this is my code (I solved it with last weeks code for LPS, but just curious):\\n\\n```\\nvar minInsertions = function(s) {\\n    let l = 0\\n    let r = s.length -1\\n    const makePalindrome = (left, right, word, answer) => {\\n        if (left >= right) return answer\\n        if (word[left] === word[right]) return makePalindrome(left+1, right-1, word, answer)\\n        else return Math.min(makePalindrome(left, right-1, word, answer+1), makePalindrome(left+1, right, word, answer+1))\\n    }\\n    return makePalindrome(l, r, s, 0)\\n};\\n```"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "definitely not a hard question !! also question must also can be stated as minimum no of deletions to make it a palidrome"
                    },
                    {
                        "username": "0xatul",
                        "content": "try coming up for a LCS solution by yourself, you will know why its hard"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "damn!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "That's the point\nIt's pretty tuff to notice that number of deletions will be equal to number of insertions"
                    },
                    {
                        "username": "crusifixx",
                        "content": "LeetCode\\'s urge to assign hard questions on weekends\\uD83D\\uDCC8\\uD83D\\uDCC8\\uD83D\\uDCC8"
                    },
                    {
                        "username": "bytecode15",
                        "content": "Leetcode and Weekends don\\'t match the vibe!\\n"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "yo!\\n"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Implicit LCS."
                    },
                    {
                        "username": "SidKay",
                        "content": "Alright, alright Leetcode, you win.\\nI\\'ll learn about dynamic programming now."
                    }
                ]
            },
            {
                "id": 1870889,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "My brain still hurts from yesterday"
                    },
                    {
                        "username": "jihweiliang",
                        "content": "It is super easy today. "
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "Can you share yesterday\\'s question?"
                    },
                    {
                        "username": "code_er7",
                        "content": "yesterday was kinda easy"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Mediums are marked as Hard\\nHards are marked as Medium\\nLeetcode\\u2615"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "Sahi kaha green color matching mandir wale babu😏 "
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "how can you say that for me all are hard!\\n"
                    },
                    {
                        "username": "alt909",
                        "content": "I panicked until I realized this one is actually an easy."
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Text1.length - longest palindromic subsequence"
                    },
                    {
                        "username": "Finesse",
                        "content": "It's very easy to solve with a simple dynamic programming:\n\n1. Use 2 pointers to walk from the string edges towards the center.\n2. When the letters at the pointers don't match, you can either add a letter on the left or add a letter on the right. In both cases you get a smaller problem (finding a solution for a substring).\n3. Solve both smaller problems recursively and choose the best result.\n\nNo need to know anything about the longest common subsequence algorithm, which is much harder."
                    },
                    {
                        "username": "portableCoder",
                        "content": "[@Mister_CK](/Mister_CK)  it's a state problem! you don't need the answer parameter. Remove that and replace it with this: (you also need memoization btw)\n```js\nvar minInsertions = function(s) {\n    let l = 0\n    let r = s.length -1\n    let state = {}\n    const makePalindrome = (left, right, word) => {\n       const st = `${left},${right}`\n        if(state[st] !== undefined) return state[st]\n        if (left >= right) return 0\n        if (word[left] === word[right]) {\nstate[st] = makePalindrome(left+1, right-1, word)\n   return state[st]\n}\n       state[st] = 1 + Math.min(makePalindrome(left, right-1, word), makePalindrome(left+1, right, word))\n     return state[st]\n\n    }\n    return makePalindrome(l, r, s)\n};\n```"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@Mister_CK](/Mister_CK) Yes this absolutely needs Memoization, realise that the number of calls to makePalindrome grows exponentially. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wrote the code as you described, but that gives me TLE, how do you prevent that from happening? Memoization? for reference this is my code (I solved it with last weeks code for LPS, but just curious):\\n\\n```\\nvar minInsertions = function(s) {\\n    let l = 0\\n    let r = s.length -1\\n    const makePalindrome = (left, right, word, answer) => {\\n        if (left >= right) return answer\\n        if (word[left] === word[right]) return makePalindrome(left+1, right-1, word, answer)\\n        else return Math.min(makePalindrome(left, right-1, word, answer+1), makePalindrome(left+1, right, word, answer+1))\\n    }\\n    return makePalindrome(l, r, s, 0)\\n};\\n```"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "definitely not a hard question !! also question must also can be stated as minimum no of deletions to make it a palidrome"
                    },
                    {
                        "username": "0xatul",
                        "content": "try coming up for a LCS solution by yourself, you will know why its hard"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "damn!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "That's the point\nIt's pretty tuff to notice that number of deletions will be equal to number of insertions"
                    },
                    {
                        "username": "crusifixx",
                        "content": "LeetCode\\'s urge to assign hard questions on weekends\\uD83D\\uDCC8\\uD83D\\uDCC8\\uD83D\\uDCC8"
                    },
                    {
                        "username": "bytecode15",
                        "content": "Leetcode and Weekends don\\'t match the vibe!\\n"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "yo!\\n"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Implicit LCS."
                    },
                    {
                        "username": "SidKay",
                        "content": "Alright, alright Leetcode, you win.\\nI\\'ll learn about dynamic programming now."
                    }
                ]
            },
            {
                "id": 1870522,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "My brain still hurts from yesterday"
                    },
                    {
                        "username": "jihweiliang",
                        "content": "It is super easy today. "
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "Can you share yesterday\\'s question?"
                    },
                    {
                        "username": "code_er7",
                        "content": "yesterday was kinda easy"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Mediums are marked as Hard\\nHards are marked as Medium\\nLeetcode\\u2615"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "Sahi kaha green color matching mandir wale babu😏 "
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "how can you say that for me all are hard!\\n"
                    },
                    {
                        "username": "alt909",
                        "content": "I panicked until I realized this one is actually an easy."
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Text1.length - longest palindromic subsequence"
                    },
                    {
                        "username": "Finesse",
                        "content": "It's very easy to solve with a simple dynamic programming:\n\n1. Use 2 pointers to walk from the string edges towards the center.\n2. When the letters at the pointers don't match, you can either add a letter on the left or add a letter on the right. In both cases you get a smaller problem (finding a solution for a substring).\n3. Solve both smaller problems recursively and choose the best result.\n\nNo need to know anything about the longest common subsequence algorithm, which is much harder."
                    },
                    {
                        "username": "portableCoder",
                        "content": "[@Mister_CK](/Mister_CK)  it's a state problem! you don't need the answer parameter. Remove that and replace it with this: (you also need memoization btw)\n```js\nvar minInsertions = function(s) {\n    let l = 0\n    let r = s.length -1\n    let state = {}\n    const makePalindrome = (left, right, word) => {\n       const st = `${left},${right}`\n        if(state[st] !== undefined) return state[st]\n        if (left >= right) return 0\n        if (word[left] === word[right]) {\nstate[st] = makePalindrome(left+1, right-1, word)\n   return state[st]\n}\n       state[st] = 1 + Math.min(makePalindrome(left, right-1, word), makePalindrome(left+1, right, word))\n     return state[st]\n\n    }\n    return makePalindrome(l, r, s)\n};\n```"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@Mister_CK](/Mister_CK) Yes this absolutely needs Memoization, realise that the number of calls to makePalindrome grows exponentially. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wrote the code as you described, but that gives me TLE, how do you prevent that from happening? Memoization? for reference this is my code (I solved it with last weeks code for LPS, but just curious):\\n\\n```\\nvar minInsertions = function(s) {\\n    let l = 0\\n    let r = s.length -1\\n    const makePalindrome = (left, right, word, answer) => {\\n        if (left >= right) return answer\\n        if (word[left] === word[right]) return makePalindrome(left+1, right-1, word, answer)\\n        else return Math.min(makePalindrome(left, right-1, word, answer+1), makePalindrome(left+1, right, word, answer+1))\\n    }\\n    return makePalindrome(l, r, s, 0)\\n};\\n```"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "definitely not a hard question !! also question must also can be stated as minimum no of deletions to make it a palidrome"
                    },
                    {
                        "username": "0xatul",
                        "content": "try coming up for a LCS solution by yourself, you will know why its hard"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "damn!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "That's the point\nIt's pretty tuff to notice that number of deletions will be equal to number of insertions"
                    },
                    {
                        "username": "crusifixx",
                        "content": "LeetCode\\'s urge to assign hard questions on weekends\\uD83D\\uDCC8\\uD83D\\uDCC8\\uD83D\\uDCC8"
                    },
                    {
                        "username": "bytecode15",
                        "content": "Leetcode and Weekends don\\'t match the vibe!\\n"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "yo!\\n"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Implicit LCS."
                    },
                    {
                        "username": "SidKay",
                        "content": "Alright, alright Leetcode, you win.\\nI\\'ll learn about dynamic programming now."
                    }
                ]
            },
            {
                "id": 1870678,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "My brain still hurts from yesterday"
                    },
                    {
                        "username": "jihweiliang",
                        "content": "It is super easy today. "
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "Can you share yesterday\\'s question?"
                    },
                    {
                        "username": "code_er7",
                        "content": "yesterday was kinda easy"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Mediums are marked as Hard\\nHards are marked as Medium\\nLeetcode\\u2615"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "Sahi kaha green color matching mandir wale babu😏 "
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "how can you say that for me all are hard!\\n"
                    },
                    {
                        "username": "alt909",
                        "content": "I panicked until I realized this one is actually an easy."
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Text1.length - longest palindromic subsequence"
                    },
                    {
                        "username": "Finesse",
                        "content": "It's very easy to solve with a simple dynamic programming:\n\n1. Use 2 pointers to walk from the string edges towards the center.\n2. When the letters at the pointers don't match, you can either add a letter on the left or add a letter on the right. In both cases you get a smaller problem (finding a solution for a substring).\n3. Solve both smaller problems recursively and choose the best result.\n\nNo need to know anything about the longest common subsequence algorithm, which is much harder."
                    },
                    {
                        "username": "portableCoder",
                        "content": "[@Mister_CK](/Mister_CK)  it's a state problem! you don't need the answer parameter. Remove that and replace it with this: (you also need memoization btw)\n```js\nvar minInsertions = function(s) {\n    let l = 0\n    let r = s.length -1\n    let state = {}\n    const makePalindrome = (left, right, word) => {\n       const st = `${left},${right}`\n        if(state[st] !== undefined) return state[st]\n        if (left >= right) return 0\n        if (word[left] === word[right]) {\nstate[st] = makePalindrome(left+1, right-1, word)\n   return state[st]\n}\n       state[st] = 1 + Math.min(makePalindrome(left, right-1, word), makePalindrome(left+1, right, word))\n     return state[st]\n\n    }\n    return makePalindrome(l, r, s)\n};\n```"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@Mister_CK](/Mister_CK) Yes this absolutely needs Memoization, realise that the number of calls to makePalindrome grows exponentially. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wrote the code as you described, but that gives me TLE, how do you prevent that from happening? Memoization? for reference this is my code (I solved it with last weeks code for LPS, but just curious):\\n\\n```\\nvar minInsertions = function(s) {\\n    let l = 0\\n    let r = s.length -1\\n    const makePalindrome = (left, right, word, answer) => {\\n        if (left >= right) return answer\\n        if (word[left] === word[right]) return makePalindrome(left+1, right-1, word, answer)\\n        else return Math.min(makePalindrome(left, right-1, word, answer+1), makePalindrome(left+1, right, word, answer+1))\\n    }\\n    return makePalindrome(l, r, s, 0)\\n};\\n```"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "definitely not a hard question !! also question must also can be stated as minimum no of deletions to make it a palidrome"
                    },
                    {
                        "username": "0xatul",
                        "content": "try coming up for a LCS solution by yourself, you will know why its hard"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "damn!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "That's the point\nIt's pretty tuff to notice that number of deletions will be equal to number of insertions"
                    },
                    {
                        "username": "crusifixx",
                        "content": "LeetCode\\'s urge to assign hard questions on weekends\\uD83D\\uDCC8\\uD83D\\uDCC8\\uD83D\\uDCC8"
                    },
                    {
                        "username": "bytecode15",
                        "content": "Leetcode and Weekends don\\'t match the vibe!\\n"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "yo!\\n"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Implicit LCS."
                    },
                    {
                        "username": "SidKay",
                        "content": "Alright, alright Leetcode, you win.\\nI\\'ll learn about dynamic programming now."
                    }
                ]
            },
            {
                "id": 1870520,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "My brain still hurts from yesterday"
                    },
                    {
                        "username": "jihweiliang",
                        "content": "It is super easy today. "
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "Can you share yesterday\\'s question?"
                    },
                    {
                        "username": "code_er7",
                        "content": "yesterday was kinda easy"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Mediums are marked as Hard\\nHards are marked as Medium\\nLeetcode\\u2615"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "Sahi kaha green color matching mandir wale babu😏 "
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "how can you say that for me all are hard!\\n"
                    },
                    {
                        "username": "alt909",
                        "content": "I panicked until I realized this one is actually an easy."
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Text1.length - longest palindromic subsequence"
                    },
                    {
                        "username": "Finesse",
                        "content": "It's very easy to solve with a simple dynamic programming:\n\n1. Use 2 pointers to walk from the string edges towards the center.\n2. When the letters at the pointers don't match, you can either add a letter on the left or add a letter on the right. In both cases you get a smaller problem (finding a solution for a substring).\n3. Solve both smaller problems recursively and choose the best result.\n\nNo need to know anything about the longest common subsequence algorithm, which is much harder."
                    },
                    {
                        "username": "portableCoder",
                        "content": "[@Mister_CK](/Mister_CK)  it's a state problem! you don't need the answer parameter. Remove that and replace it with this: (you also need memoization btw)\n```js\nvar minInsertions = function(s) {\n    let l = 0\n    let r = s.length -1\n    let state = {}\n    const makePalindrome = (left, right, word) => {\n       const st = `${left},${right}`\n        if(state[st] !== undefined) return state[st]\n        if (left >= right) return 0\n        if (word[left] === word[right]) {\nstate[st] = makePalindrome(left+1, right-1, word)\n   return state[st]\n}\n       state[st] = 1 + Math.min(makePalindrome(left, right-1, word), makePalindrome(left+1, right, word))\n     return state[st]\n\n    }\n    return makePalindrome(l, r, s)\n};\n```"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@Mister_CK](/Mister_CK) Yes this absolutely needs Memoization, realise that the number of calls to makePalindrome grows exponentially. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wrote the code as you described, but that gives me TLE, how do you prevent that from happening? Memoization? for reference this is my code (I solved it with last weeks code for LPS, but just curious):\\n\\n```\\nvar minInsertions = function(s) {\\n    let l = 0\\n    let r = s.length -1\\n    const makePalindrome = (left, right, word, answer) => {\\n        if (left >= right) return answer\\n        if (word[left] === word[right]) return makePalindrome(left+1, right-1, word, answer)\\n        else return Math.min(makePalindrome(left, right-1, word, answer+1), makePalindrome(left+1, right, word, answer+1))\\n    }\\n    return makePalindrome(l, r, s, 0)\\n};\\n```"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "definitely not a hard question !! also question must also can be stated as minimum no of deletions to make it a palidrome"
                    },
                    {
                        "username": "0xatul",
                        "content": "try coming up for a LCS solution by yourself, you will know why its hard"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "damn!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "That's the point\nIt's pretty tuff to notice that number of deletions will be equal to number of insertions"
                    },
                    {
                        "username": "crusifixx",
                        "content": "LeetCode\\'s urge to assign hard questions on weekends\\uD83D\\uDCC8\\uD83D\\uDCC8\\uD83D\\uDCC8"
                    },
                    {
                        "username": "bytecode15",
                        "content": "Leetcode and Weekends don\\'t match the vibe!\\n"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "yo!\\n"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Implicit LCS."
                    },
                    {
                        "username": "SidKay",
                        "content": "Alright, alright Leetcode, you win.\\nI\\'ll learn about dynamic programming now."
                    }
                ]
            },
            {
                "id": 1844262,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "My brain still hurts from yesterday"
                    },
                    {
                        "username": "jihweiliang",
                        "content": "It is super easy today. "
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "Can you share yesterday\\'s question?"
                    },
                    {
                        "username": "code_er7",
                        "content": "yesterday was kinda easy"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Mediums are marked as Hard\\nHards are marked as Medium\\nLeetcode\\u2615"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "Sahi kaha green color matching mandir wale babu😏 "
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "how can you say that for me all are hard!\\n"
                    },
                    {
                        "username": "alt909",
                        "content": "I panicked until I realized this one is actually an easy."
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Text1.length - longest palindromic subsequence"
                    },
                    {
                        "username": "Finesse",
                        "content": "It's very easy to solve with a simple dynamic programming:\n\n1. Use 2 pointers to walk from the string edges towards the center.\n2. When the letters at the pointers don't match, you can either add a letter on the left or add a letter on the right. In both cases you get a smaller problem (finding a solution for a substring).\n3. Solve both smaller problems recursively and choose the best result.\n\nNo need to know anything about the longest common subsequence algorithm, which is much harder."
                    },
                    {
                        "username": "portableCoder",
                        "content": "[@Mister_CK](/Mister_CK)  it's a state problem! you don't need the answer parameter. Remove that and replace it with this: (you also need memoization btw)\n```js\nvar minInsertions = function(s) {\n    let l = 0\n    let r = s.length -1\n    let state = {}\n    const makePalindrome = (left, right, word) => {\n       const st = `${left},${right}`\n        if(state[st] !== undefined) return state[st]\n        if (left >= right) return 0\n        if (word[left] === word[right]) {\nstate[st] = makePalindrome(left+1, right-1, word)\n   return state[st]\n}\n       state[st] = 1 + Math.min(makePalindrome(left, right-1, word), makePalindrome(left+1, right, word))\n     return state[st]\n\n    }\n    return makePalindrome(l, r, s)\n};\n```"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@Mister_CK](/Mister_CK) Yes this absolutely needs Memoization, realise that the number of calls to makePalindrome grows exponentially. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wrote the code as you described, but that gives me TLE, how do you prevent that from happening? Memoization? for reference this is my code (I solved it with last weeks code for LPS, but just curious):\\n\\n```\\nvar minInsertions = function(s) {\\n    let l = 0\\n    let r = s.length -1\\n    const makePalindrome = (left, right, word, answer) => {\\n        if (left >= right) return answer\\n        if (word[left] === word[right]) return makePalindrome(left+1, right-1, word, answer)\\n        else return Math.min(makePalindrome(left, right-1, word, answer+1), makePalindrome(left+1, right, word, answer+1))\\n    }\\n    return makePalindrome(l, r, s, 0)\\n};\\n```"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "definitely not a hard question !! also question must also can be stated as minimum no of deletions to make it a palidrome"
                    },
                    {
                        "username": "0xatul",
                        "content": "try coming up for a LCS solution by yourself, you will know why its hard"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "damn!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "That's the point\nIt's pretty tuff to notice that number of deletions will be equal to number of insertions"
                    },
                    {
                        "username": "crusifixx",
                        "content": "LeetCode\\'s urge to assign hard questions on weekends\\uD83D\\uDCC8\\uD83D\\uDCC8\\uD83D\\uDCC8"
                    },
                    {
                        "username": "bytecode15",
                        "content": "Leetcode and Weekends don\\'t match the vibe!\\n"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "yo!\\n"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Implicit LCS."
                    },
                    {
                        "username": "SidKay",
                        "content": "Alright, alright Leetcode, you win.\\nI\\'ll learn about dynamic programming now."
                    }
                ]
            },
            {
                "id": 1855199,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "My brain still hurts from yesterday"
                    },
                    {
                        "username": "jihweiliang",
                        "content": "It is super easy today. "
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "Can you share yesterday\\'s question?"
                    },
                    {
                        "username": "code_er7",
                        "content": "yesterday was kinda easy"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Mediums are marked as Hard\\nHards are marked as Medium\\nLeetcode\\u2615"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "Sahi kaha green color matching mandir wale babu😏 "
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "how can you say that for me all are hard!\\n"
                    },
                    {
                        "username": "alt909",
                        "content": "I panicked until I realized this one is actually an easy."
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Text1.length - longest palindromic subsequence"
                    },
                    {
                        "username": "Finesse",
                        "content": "It's very easy to solve with a simple dynamic programming:\n\n1. Use 2 pointers to walk from the string edges towards the center.\n2. When the letters at the pointers don't match, you can either add a letter on the left or add a letter on the right. In both cases you get a smaller problem (finding a solution for a substring).\n3. Solve both smaller problems recursively and choose the best result.\n\nNo need to know anything about the longest common subsequence algorithm, which is much harder."
                    },
                    {
                        "username": "portableCoder",
                        "content": "[@Mister_CK](/Mister_CK)  it's a state problem! you don't need the answer parameter. Remove that and replace it with this: (you also need memoization btw)\n```js\nvar minInsertions = function(s) {\n    let l = 0\n    let r = s.length -1\n    let state = {}\n    const makePalindrome = (left, right, word) => {\n       const st = `${left},${right}`\n        if(state[st] !== undefined) return state[st]\n        if (left >= right) return 0\n        if (word[left] === word[right]) {\nstate[st] = makePalindrome(left+1, right-1, word)\n   return state[st]\n}\n       state[st] = 1 + Math.min(makePalindrome(left, right-1, word), makePalindrome(left+1, right, word))\n     return state[st]\n\n    }\n    return makePalindrome(l, r, s)\n};\n```"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@Mister_CK](/Mister_CK) Yes this absolutely needs Memoization, realise that the number of calls to makePalindrome grows exponentially. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wrote the code as you described, but that gives me TLE, how do you prevent that from happening? Memoization? for reference this is my code (I solved it with last weeks code for LPS, but just curious):\\n\\n```\\nvar minInsertions = function(s) {\\n    let l = 0\\n    let r = s.length -1\\n    const makePalindrome = (left, right, word, answer) => {\\n        if (left >= right) return answer\\n        if (word[left] === word[right]) return makePalindrome(left+1, right-1, word, answer)\\n        else return Math.min(makePalindrome(left, right-1, word, answer+1), makePalindrome(left+1, right, word, answer+1))\\n    }\\n    return makePalindrome(l, r, s, 0)\\n};\\n```"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "definitely not a hard question !! also question must also can be stated as minimum no of deletions to make it a palidrome"
                    },
                    {
                        "username": "0xatul",
                        "content": "try coming up for a LCS solution by yourself, you will know why its hard"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "damn!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "That's the point\nIt's pretty tuff to notice that number of deletions will be equal to number of insertions"
                    },
                    {
                        "username": "crusifixx",
                        "content": "LeetCode\\'s urge to assign hard questions on weekends\\uD83D\\uDCC8\\uD83D\\uDCC8\\uD83D\\uDCC8"
                    },
                    {
                        "username": "bytecode15",
                        "content": "Leetcode and Weekends don\\'t match the vibe!\\n"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "yo!\\n"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Implicit LCS."
                    },
                    {
                        "username": "SidKay",
                        "content": "Alright, alright Leetcode, you win.\\nI\\'ll learn about dynamic programming now."
                    }
                ]
            },
            {
                "id": 1738234,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "My brain still hurts from yesterday"
                    },
                    {
                        "username": "jihweiliang",
                        "content": "It is super easy today. "
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "Can you share yesterday\\'s question?"
                    },
                    {
                        "username": "code_er7",
                        "content": "yesterday was kinda easy"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Mediums are marked as Hard\\nHards are marked as Medium\\nLeetcode\\u2615"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "Sahi kaha green color matching mandir wale babu😏 "
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "how can you say that for me all are hard!\\n"
                    },
                    {
                        "username": "alt909",
                        "content": "I panicked until I realized this one is actually an easy."
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Text1.length - longest palindromic subsequence"
                    },
                    {
                        "username": "Finesse",
                        "content": "It's very easy to solve with a simple dynamic programming:\n\n1. Use 2 pointers to walk from the string edges towards the center.\n2. When the letters at the pointers don't match, you can either add a letter on the left or add a letter on the right. In both cases you get a smaller problem (finding a solution for a substring).\n3. Solve both smaller problems recursively and choose the best result.\n\nNo need to know anything about the longest common subsequence algorithm, which is much harder."
                    },
                    {
                        "username": "portableCoder",
                        "content": "[@Mister_CK](/Mister_CK)  it's a state problem! you don't need the answer parameter. Remove that and replace it with this: (you also need memoization btw)\n```js\nvar minInsertions = function(s) {\n    let l = 0\n    let r = s.length -1\n    let state = {}\n    const makePalindrome = (left, right, word) => {\n       const st = `${left},${right}`\n        if(state[st] !== undefined) return state[st]\n        if (left >= right) return 0\n        if (word[left] === word[right]) {\nstate[st] = makePalindrome(left+1, right-1, word)\n   return state[st]\n}\n       state[st] = 1 + Math.min(makePalindrome(left, right-1, word), makePalindrome(left+1, right, word))\n     return state[st]\n\n    }\n    return makePalindrome(l, r, s)\n};\n```"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@Mister_CK](/Mister_CK) Yes this absolutely needs Memoization, realise that the number of calls to makePalindrome grows exponentially. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wrote the code as you described, but that gives me TLE, how do you prevent that from happening? Memoization? for reference this is my code (I solved it with last weeks code for LPS, but just curious):\\n\\n```\\nvar minInsertions = function(s) {\\n    let l = 0\\n    let r = s.length -1\\n    const makePalindrome = (left, right, word, answer) => {\\n        if (left >= right) return answer\\n        if (word[left] === word[right]) return makePalindrome(left+1, right-1, word, answer)\\n        else return Math.min(makePalindrome(left, right-1, word, answer+1), makePalindrome(left+1, right, word, answer+1))\\n    }\\n    return makePalindrome(l, r, s, 0)\\n};\\n```"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "definitely not a hard question !! also question must also can be stated as minimum no of deletions to make it a palidrome"
                    },
                    {
                        "username": "0xatul",
                        "content": "try coming up for a LCS solution by yourself, you will know why its hard"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "damn!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "That's the point\nIt's pretty tuff to notice that number of deletions will be equal to number of insertions"
                    },
                    {
                        "username": "crusifixx",
                        "content": "LeetCode\\'s urge to assign hard questions on weekends\\uD83D\\uDCC8\\uD83D\\uDCC8\\uD83D\\uDCC8"
                    },
                    {
                        "username": "bytecode15",
                        "content": "Leetcode and Weekends don\\'t match the vibe!\\n"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "yo!\\n"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Implicit LCS."
                    },
                    {
                        "username": "SidKay",
                        "content": "Alright, alright Leetcode, you win.\\nI\\'ll learn about dynamic programming now."
                    }
                ]
            },
            {
                "id": 1870671,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "My brain still hurts from yesterday"
                    },
                    {
                        "username": "jihweiliang",
                        "content": "It is super easy today. "
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "Can you share yesterday\\'s question?"
                    },
                    {
                        "username": "code_er7",
                        "content": "yesterday was kinda easy"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Mediums are marked as Hard\\nHards are marked as Medium\\nLeetcode\\u2615"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "Sahi kaha green color matching mandir wale babu😏 "
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "how can you say that for me all are hard!\\n"
                    },
                    {
                        "username": "alt909",
                        "content": "I panicked until I realized this one is actually an easy."
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Text1.length - longest palindromic subsequence"
                    },
                    {
                        "username": "Finesse",
                        "content": "It's very easy to solve with a simple dynamic programming:\n\n1. Use 2 pointers to walk from the string edges towards the center.\n2. When the letters at the pointers don't match, you can either add a letter on the left or add a letter on the right. In both cases you get a smaller problem (finding a solution for a substring).\n3. Solve both smaller problems recursively and choose the best result.\n\nNo need to know anything about the longest common subsequence algorithm, which is much harder."
                    },
                    {
                        "username": "portableCoder",
                        "content": "[@Mister_CK](/Mister_CK)  it's a state problem! you don't need the answer parameter. Remove that and replace it with this: (you also need memoization btw)\n```js\nvar minInsertions = function(s) {\n    let l = 0\n    let r = s.length -1\n    let state = {}\n    const makePalindrome = (left, right, word) => {\n       const st = `${left},${right}`\n        if(state[st] !== undefined) return state[st]\n        if (left >= right) return 0\n        if (word[left] === word[right]) {\nstate[st] = makePalindrome(left+1, right-1, word)\n   return state[st]\n}\n       state[st] = 1 + Math.min(makePalindrome(left, right-1, word), makePalindrome(left+1, right, word))\n     return state[st]\n\n    }\n    return makePalindrome(l, r, s)\n};\n```"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@Mister_CK](/Mister_CK) Yes this absolutely needs Memoization, realise that the number of calls to makePalindrome grows exponentially. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wrote the code as you described, but that gives me TLE, how do you prevent that from happening? Memoization? for reference this is my code (I solved it with last weeks code for LPS, but just curious):\\n\\n```\\nvar minInsertions = function(s) {\\n    let l = 0\\n    let r = s.length -1\\n    const makePalindrome = (left, right, word, answer) => {\\n        if (left >= right) return answer\\n        if (word[left] === word[right]) return makePalindrome(left+1, right-1, word, answer)\\n        else return Math.min(makePalindrome(left, right-1, word, answer+1), makePalindrome(left+1, right, word, answer+1))\\n    }\\n    return makePalindrome(l, r, s, 0)\\n};\\n```"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "definitely not a hard question !! also question must also can be stated as minimum no of deletions to make it a palidrome"
                    },
                    {
                        "username": "0xatul",
                        "content": "try coming up for a LCS solution by yourself, you will know why its hard"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "damn!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "That's the point\nIt's pretty tuff to notice that number of deletions will be equal to number of insertions"
                    },
                    {
                        "username": "crusifixx",
                        "content": "LeetCode\\'s urge to assign hard questions on weekends\\uD83D\\uDCC8\\uD83D\\uDCC8\\uD83D\\uDCC8"
                    },
                    {
                        "username": "bytecode15",
                        "content": "Leetcode and Weekends don\\'t match the vibe!\\n"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "yo!\\n"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Implicit LCS."
                    },
                    {
                        "username": "SidKay",
                        "content": "Alright, alright Leetcode, you win.\\nI\\'ll learn about dynamic programming now."
                    }
                ]
            },
            {
                "id": 1870800,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "My brain still hurts from yesterday"
                    },
                    {
                        "username": "jihweiliang",
                        "content": "It is super easy today. "
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "Can you share yesterday\\'s question?"
                    },
                    {
                        "username": "code_er7",
                        "content": "yesterday was kinda easy"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Mediums are marked as Hard\\nHards are marked as Medium\\nLeetcode\\u2615"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "Sahi kaha green color matching mandir wale babu😏 "
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "how can you say that for me all are hard!\\n"
                    },
                    {
                        "username": "alt909",
                        "content": "I panicked until I realized this one is actually an easy."
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Text1.length - longest palindromic subsequence"
                    },
                    {
                        "username": "Finesse",
                        "content": "It's very easy to solve with a simple dynamic programming:\n\n1. Use 2 pointers to walk from the string edges towards the center.\n2. When the letters at the pointers don't match, you can either add a letter on the left or add a letter on the right. In both cases you get a smaller problem (finding a solution for a substring).\n3. Solve both smaller problems recursively and choose the best result.\n\nNo need to know anything about the longest common subsequence algorithm, which is much harder."
                    },
                    {
                        "username": "portableCoder",
                        "content": "[@Mister_CK](/Mister_CK)  it's a state problem! you don't need the answer parameter. Remove that and replace it with this: (you also need memoization btw)\n```js\nvar minInsertions = function(s) {\n    let l = 0\n    let r = s.length -1\n    let state = {}\n    const makePalindrome = (left, right, word) => {\n       const st = `${left},${right}`\n        if(state[st] !== undefined) return state[st]\n        if (left >= right) return 0\n        if (word[left] === word[right]) {\nstate[st] = makePalindrome(left+1, right-1, word)\n   return state[st]\n}\n       state[st] = 1 + Math.min(makePalindrome(left, right-1, word), makePalindrome(left+1, right, word))\n     return state[st]\n\n    }\n    return makePalindrome(l, r, s)\n};\n```"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@Mister_CK](/Mister_CK) Yes this absolutely needs Memoization, realise that the number of calls to makePalindrome grows exponentially. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wrote the code as you described, but that gives me TLE, how do you prevent that from happening? Memoization? for reference this is my code (I solved it with last weeks code for LPS, but just curious):\\n\\n```\\nvar minInsertions = function(s) {\\n    let l = 0\\n    let r = s.length -1\\n    const makePalindrome = (left, right, word, answer) => {\\n        if (left >= right) return answer\\n        if (word[left] === word[right]) return makePalindrome(left+1, right-1, word, answer)\\n        else return Math.min(makePalindrome(left, right-1, word, answer+1), makePalindrome(left+1, right, word, answer+1))\\n    }\\n    return makePalindrome(l, r, s, 0)\\n};\\n```"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "definitely not a hard question !! also question must also can be stated as minimum no of deletions to make it a palidrome"
                    },
                    {
                        "username": "0xatul",
                        "content": "try coming up for a LCS solution by yourself, you will know why its hard"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "damn!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "That's the point\nIt's pretty tuff to notice that number of deletions will be equal to number of insertions"
                    },
                    {
                        "username": "crusifixx",
                        "content": "LeetCode\\'s urge to assign hard questions on weekends\\uD83D\\uDCC8\\uD83D\\uDCC8\\uD83D\\uDCC8"
                    },
                    {
                        "username": "bytecode15",
                        "content": "Leetcode and Weekends don\\'t match the vibe!\\n"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "yo!\\n"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Implicit LCS."
                    },
                    {
                        "username": "SidKay",
                        "content": "Alright, alright Leetcode, you win.\\nI\\'ll learn about dynamic programming now."
                    }
                ]
            },
            {
                "id": 1800924,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "My brain still hurts from yesterday"
                    },
                    {
                        "username": "jihweiliang",
                        "content": "It is super easy today. "
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "Can you share yesterday\\'s question?"
                    },
                    {
                        "username": "code_er7",
                        "content": "yesterday was kinda easy"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Mediums are marked as Hard\\nHards are marked as Medium\\nLeetcode\\u2615"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "Sahi kaha green color matching mandir wale babu😏 "
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "how can you say that for me all are hard!\\n"
                    },
                    {
                        "username": "alt909",
                        "content": "I panicked until I realized this one is actually an easy."
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Text1.length - longest palindromic subsequence"
                    },
                    {
                        "username": "Finesse",
                        "content": "It's very easy to solve with a simple dynamic programming:\n\n1. Use 2 pointers to walk from the string edges towards the center.\n2. When the letters at the pointers don't match, you can either add a letter on the left or add a letter on the right. In both cases you get a smaller problem (finding a solution for a substring).\n3. Solve both smaller problems recursively and choose the best result.\n\nNo need to know anything about the longest common subsequence algorithm, which is much harder."
                    },
                    {
                        "username": "portableCoder",
                        "content": "[@Mister_CK](/Mister_CK)  it's a state problem! you don't need the answer parameter. Remove that and replace it with this: (you also need memoization btw)\n```js\nvar minInsertions = function(s) {\n    let l = 0\n    let r = s.length -1\n    let state = {}\n    const makePalindrome = (left, right, word) => {\n       const st = `${left},${right}`\n        if(state[st] !== undefined) return state[st]\n        if (left >= right) return 0\n        if (word[left] === word[right]) {\nstate[st] = makePalindrome(left+1, right-1, word)\n   return state[st]\n}\n       state[st] = 1 + Math.min(makePalindrome(left, right-1, word), makePalindrome(left+1, right, word))\n     return state[st]\n\n    }\n    return makePalindrome(l, r, s)\n};\n```"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@Mister_CK](/Mister_CK) Yes this absolutely needs Memoization, realise that the number of calls to makePalindrome grows exponentially. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wrote the code as you described, but that gives me TLE, how do you prevent that from happening? Memoization? for reference this is my code (I solved it with last weeks code for LPS, but just curious):\\n\\n```\\nvar minInsertions = function(s) {\\n    let l = 0\\n    let r = s.length -1\\n    const makePalindrome = (left, right, word, answer) => {\\n        if (left >= right) return answer\\n        if (word[left] === word[right]) return makePalindrome(left+1, right-1, word, answer)\\n        else return Math.min(makePalindrome(left, right-1, word, answer+1), makePalindrome(left+1, right, word, answer+1))\\n    }\\n    return makePalindrome(l, r, s, 0)\\n};\\n```"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "definitely not a hard question !! also question must also can be stated as minimum no of deletions to make it a palidrome"
                    },
                    {
                        "username": "0xatul",
                        "content": "try coming up for a LCS solution by yourself, you will know why its hard"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "damn!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "That's the point\nIt's pretty tuff to notice that number of deletions will be equal to number of insertions"
                    },
                    {
                        "username": "crusifixx",
                        "content": "LeetCode\\'s urge to assign hard questions on weekends\\uD83D\\uDCC8\\uD83D\\uDCC8\\uD83D\\uDCC8"
                    },
                    {
                        "username": "bytecode15",
                        "content": "Leetcode and Weekends don\\'t match the vibe!\\n"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "yo!\\n"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Implicit LCS."
                    },
                    {
                        "username": "SidKay",
                        "content": "Alright, alright Leetcode, you win.\\nI\\'ll learn about dynamic programming now."
                    }
                ]
            },
            {
                "id": 1870889,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "My brain still hurts from yesterday"
                    },
                    {
                        "username": "jihweiliang",
                        "content": "It is super easy today. "
                    },
                    {
                        "username": "PeaceAndPower",
                        "content": "Can you share yesterday\\'s question?"
                    },
                    {
                        "username": "code_er7",
                        "content": "yesterday was kinda easy"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Mediums are marked as Hard\\nHards are marked as Medium\\nLeetcode\\u2615"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "Sahi kaha green color matching mandir wale babu😏 "
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "how can you say that for me all are hard!\\n"
                    },
                    {
                        "username": "alt909",
                        "content": "I panicked until I realized this one is actually an easy."
                    },
                    {
                        "username": "gurnainwadhwa",
                        "content": "Text1.length - longest palindromic subsequence"
                    },
                    {
                        "username": "Finesse",
                        "content": "It's very easy to solve with a simple dynamic programming:\n\n1. Use 2 pointers to walk from the string edges towards the center.\n2. When the letters at the pointers don't match, you can either add a letter on the left or add a letter on the right. In both cases you get a smaller problem (finding a solution for a substring).\n3. Solve both smaller problems recursively and choose the best result.\n\nNo need to know anything about the longest common subsequence algorithm, which is much harder."
                    },
                    {
                        "username": "portableCoder",
                        "content": "[@Mister_CK](/Mister_CK)  it's a state problem! you don't need the answer parameter. Remove that and replace it with this: (you also need memoization btw)\n```js\nvar minInsertions = function(s) {\n    let l = 0\n    let r = s.length -1\n    let state = {}\n    const makePalindrome = (left, right, word) => {\n       const st = `${left},${right}`\n        if(state[st] !== undefined) return state[st]\n        if (left >= right) return 0\n        if (word[left] === word[right]) {\nstate[st] = makePalindrome(left+1, right-1, word)\n   return state[st]\n}\n       state[st] = 1 + Math.min(makePalindrome(left, right-1, word), makePalindrome(left+1, right, word))\n     return state[st]\n\n    }\n    return makePalindrome(l, r, s)\n};\n```"
                    },
                    {
                        "username": "mshoosterman",
                        "content": "[@Mister_CK](/Mister_CK) Yes this absolutely needs Memoization, realise that the number of calls to makePalindrome grows exponentially. "
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I wrote the code as you described, but that gives me TLE, how do you prevent that from happening? Memoization? for reference this is my code (I solved it with last weeks code for LPS, but just curious):\\n\\n```\\nvar minInsertions = function(s) {\\n    let l = 0\\n    let r = s.length -1\\n    const makePalindrome = (left, right, word, answer) => {\\n        if (left >= right) return answer\\n        if (word[left] === word[right]) return makePalindrome(left+1, right-1, word, answer)\\n        else return Math.min(makePalindrome(left, right-1, word, answer+1), makePalindrome(left+1, right, word, answer+1))\\n    }\\n    return makePalindrome(l, r, s, 0)\\n};\\n```"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "definitely not a hard question !! also question must also can be stated as minimum no of deletions to make it a palidrome"
                    },
                    {
                        "username": "0xatul",
                        "content": "try coming up for a LCS solution by yourself, you will know why its hard"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "damn!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "That's the point\nIt's pretty tuff to notice that number of deletions will be equal to number of insertions"
                    },
                    {
                        "username": "crusifixx",
                        "content": "LeetCode\\'s urge to assign hard questions on weekends\\uD83D\\uDCC8\\uD83D\\uDCC8\\uD83D\\uDCC8"
                    },
                    {
                        "username": "bytecode15",
                        "content": "Leetcode and Weekends don\\'t match the vibe!\\n"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "yo!\\n"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Implicit LCS."
                    },
                    {
                        "username": "SidKay",
                        "content": "Alright, alright Leetcode, you win.\\nI\\'ll learn about dynamic programming now."
                    }
                ]
            },
            {
                "id": 1870797,
                "content": [
                    {
                        "username": "singhom",
                        "content": "i just coded it and thought it wont work and it worked"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "[@Mshashikanth](/Mshashikanth)  it will happen \\uD83D\\uDE00"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "why can\\'t that type of wonders can\\'t happen to me, it is the fact i\\'m not coding ??"
                    },
                    {
                        "username": "zhuzhupang001",
                        "content": "if you never worked with DP, this is hard.\\nIf you are comfortable with most DP problems, this is easy to medium"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "You don\\'t need to use LCS for this, in fact if you need to resort to using an older question you solved to solve a new question you really aren\\'t learning anything new. For anyone trying to get better at dp, don\\'t memorize (or should I say memoize huh , not good, ok !) any solution. Properly understand why we are doing what we are doing. For this particular question it\\'s a simple choice, insert at left or right position in case of mismatch and pick the better solution."
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "[@cartesPerforees](/cartesPerforees)  My comment was mainly targeted towards people who were not able to solve this and used the solution in editorial (partial fault of lc editorial, thats why you should always visit solutions tab as well), if you solved this on your own using LPS then thats good.\n\nI don't have anything against repetition, that how we all learn, my point was when  you are doing a new question what should be more important : Learning something new or repeating something already done.\n\nYou are right on the point that its not trivial to break down a problem into another and requires good skills, I didn't think of LPS solution until i saw the editorial.\n\n\"if reusing an algorithm you already know is taboo, I wish you good luck on all binary search questions for example\" - Completely wrong comparison, binary search is a standard algorithm, whereas finding LPS is a popular problem what can be solved efficiently by DP, which is what I'm encouraging people to do this question with from scratch in the first place, the ideal way to solve this question is through DP and not have any dependency on LPS.\n"
                    },
                    {
                        "username": "kyleyarwood",
                        "content": "Resorting to an older question is not a bad thing. Reducing to a known problem is an extremely effective way of solving problems."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I couldn't disagree more with \" in fact if you need to resort to using an older question you solved to solve a new question you really aren't learning anything new\", which is a completely counter-pedagogic statement on so many accounts:\n- You learn by repetition. I'm glad for you if you learn and master every algorithm after seeing them once, but most humans don't, and re-visiting and adapting an previously seen solution is a great way to practise reinforcement learning\n- 99% of problems you will see IRL are a reformulation of something you or someone else has already done before. Recognizing patterns and re-using previous knowledge is a skill that you have to learn. You are learning that.\n- Reformulating a problem as an equivalent one can be far from trivial in many cases and it is a mental habit that needs to be practised\n- if reusing an algorithm you already know is taboo, I wish you good luck on all binary search questions for example\n\nWhile I agree that other solutions are important to consider, I thought the broad generalization you're making is totally wrong.\nIn this case, I would in fact argue that recognizing that you can use the LCS on the reverse string is not obvious and requires as much insight and thought as the direct solution"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "ohh pols agyi pols. Palindromic pols"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@codeMonarch](/codeMonarch) na na daro na ji LCS modi5 karay hunda he ji"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "oo daro na mallo, eh to two pointer hai"
                    },
                    {
                        "username": "aalmos",
                        "content": "While I was coding the trivial DP solution I kept thinking it\\'d TLE and what trick-based greedy solution I could apply instead that would justify the hard tag..."
                    },
                    {
                        "username": "code_er7",
                        "content": "Why there have to be so many DP problems ."
                    },
                    {
                        "username": "053_NeerajKumar",
                        "content": "Approach -\\n\\n1) Take two pointer to begin and end of string.\\n2) For string to be palindrome s[begin] == s[end]\\n  -> If yes, no need of insertion, check in remaining substring\\n    So, fun(begin, end) = fun(begin+1, end-1).\\n  -> If no, then a new char should be inserted to make them equal and this insertion can be done at position begin or end (whichever results in min insertion further,\\n    So, fun(begin, end) = 1+min(fun(begin+1, end), fun(begin, end-1)).\\n3) Use dp[begin][end] to remove repititive function calls."
                    },
                    {
                        "username": "rawatpravesh0016",
                        "content": "This is giving TLE"
                    },
                    {
                        "username": "RkRohitKumar",
                        "content": "its a super easy problem"
                    },
                    {
                        "username": "_sri_hari_",
                        "content": "When you are coding the memoization, declare the vector globally rather than passing to the function as It gave MLE when I coded in C++.\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n=s.length();\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        return dfs(s,0,n-1,dp);\\n    }\\n    int dfs(string s,int i,int j,vector<vector<int>>& dp){\\n        if(i>=j)return 0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        if(s[i]==s[j])return dp[i][j]=dfs(s,i+1,j-1,dp);\\n        return dp[i][j]=min(1+dfs(s,i,j-1,dp),1+dfs(s,i+1,j,dp));\\n    }\\n};\\n"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "2nd hint is the complete solution itself : D"
                    }
                ]
            },
            {
                "id": 1870608,
                "content": [
                    {
                        "username": "singhom",
                        "content": "i just coded it and thought it wont work and it worked"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "[@Mshashikanth](/Mshashikanth)  it will happen \\uD83D\\uDE00"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "why can\\'t that type of wonders can\\'t happen to me, it is the fact i\\'m not coding ??"
                    },
                    {
                        "username": "zhuzhupang001",
                        "content": "if you never worked with DP, this is hard.\\nIf you are comfortable with most DP problems, this is easy to medium"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "You don\\'t need to use LCS for this, in fact if you need to resort to using an older question you solved to solve a new question you really aren\\'t learning anything new. For anyone trying to get better at dp, don\\'t memorize (or should I say memoize huh , not good, ok !) any solution. Properly understand why we are doing what we are doing. For this particular question it\\'s a simple choice, insert at left or right position in case of mismatch and pick the better solution."
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "[@cartesPerforees](/cartesPerforees)  My comment was mainly targeted towards people who were not able to solve this and used the solution in editorial (partial fault of lc editorial, thats why you should always visit solutions tab as well), if you solved this on your own using LPS then thats good.\n\nI don't have anything against repetition, that how we all learn, my point was when  you are doing a new question what should be more important : Learning something new or repeating something already done.\n\nYou are right on the point that its not trivial to break down a problem into another and requires good skills, I didn't think of LPS solution until i saw the editorial.\n\n\"if reusing an algorithm you already know is taboo, I wish you good luck on all binary search questions for example\" - Completely wrong comparison, binary search is a standard algorithm, whereas finding LPS is a popular problem what can be solved efficiently by DP, which is what I'm encouraging people to do this question with from scratch in the first place, the ideal way to solve this question is through DP and not have any dependency on LPS.\n"
                    },
                    {
                        "username": "kyleyarwood",
                        "content": "Resorting to an older question is not a bad thing. Reducing to a known problem is an extremely effective way of solving problems."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I couldn't disagree more with \" in fact if you need to resort to using an older question you solved to solve a new question you really aren't learning anything new\", which is a completely counter-pedagogic statement on so many accounts:\n- You learn by repetition. I'm glad for you if you learn and master every algorithm after seeing them once, but most humans don't, and re-visiting and adapting an previously seen solution is a great way to practise reinforcement learning\n- 99% of problems you will see IRL are a reformulation of something you or someone else has already done before. Recognizing patterns and re-using previous knowledge is a skill that you have to learn. You are learning that.\n- Reformulating a problem as an equivalent one can be far from trivial in many cases and it is a mental habit that needs to be practised\n- if reusing an algorithm you already know is taboo, I wish you good luck on all binary search questions for example\n\nWhile I agree that other solutions are important to consider, I thought the broad generalization you're making is totally wrong.\nIn this case, I would in fact argue that recognizing that you can use the LCS on the reverse string is not obvious and requires as much insight and thought as the direct solution"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "ohh pols agyi pols. Palindromic pols"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@codeMonarch](/codeMonarch) na na daro na ji LCS modi5 karay hunda he ji"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "oo daro na mallo, eh to two pointer hai"
                    },
                    {
                        "username": "aalmos",
                        "content": "While I was coding the trivial DP solution I kept thinking it\\'d TLE and what trick-based greedy solution I could apply instead that would justify the hard tag..."
                    },
                    {
                        "username": "code_er7",
                        "content": "Why there have to be so many DP problems ."
                    },
                    {
                        "username": "053_NeerajKumar",
                        "content": "Approach -\\n\\n1) Take two pointer to begin and end of string.\\n2) For string to be palindrome s[begin] == s[end]\\n  -> If yes, no need of insertion, check in remaining substring\\n    So, fun(begin, end) = fun(begin+1, end-1).\\n  -> If no, then a new char should be inserted to make them equal and this insertion can be done at position begin or end (whichever results in min insertion further,\\n    So, fun(begin, end) = 1+min(fun(begin+1, end), fun(begin, end-1)).\\n3) Use dp[begin][end] to remove repititive function calls."
                    },
                    {
                        "username": "rawatpravesh0016",
                        "content": "This is giving TLE"
                    },
                    {
                        "username": "RkRohitKumar",
                        "content": "its a super easy problem"
                    },
                    {
                        "username": "_sri_hari_",
                        "content": "When you are coding the memoization, declare the vector globally rather than passing to the function as It gave MLE when I coded in C++.\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n=s.length();\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        return dfs(s,0,n-1,dp);\\n    }\\n    int dfs(string s,int i,int j,vector<vector<int>>& dp){\\n        if(i>=j)return 0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        if(s[i]==s[j])return dp[i][j]=dfs(s,i+1,j-1,dp);\\n        return dp[i][j]=min(1+dfs(s,i,j-1,dp),1+dfs(s,i+1,j,dp));\\n    }\\n};\\n"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "2nd hint is the complete solution itself : D"
                    }
                ]
            },
            {
                "id": 1870629,
                "content": [
                    {
                        "username": "singhom",
                        "content": "i just coded it and thought it wont work and it worked"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "[@Mshashikanth](/Mshashikanth)  it will happen \\uD83D\\uDE00"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "why can\\'t that type of wonders can\\'t happen to me, it is the fact i\\'m not coding ??"
                    },
                    {
                        "username": "zhuzhupang001",
                        "content": "if you never worked with DP, this is hard.\\nIf you are comfortable with most DP problems, this is easy to medium"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "You don\\'t need to use LCS for this, in fact if you need to resort to using an older question you solved to solve a new question you really aren\\'t learning anything new. For anyone trying to get better at dp, don\\'t memorize (or should I say memoize huh , not good, ok !) any solution. Properly understand why we are doing what we are doing. For this particular question it\\'s a simple choice, insert at left or right position in case of mismatch and pick the better solution."
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "[@cartesPerforees](/cartesPerforees)  My comment was mainly targeted towards people who were not able to solve this and used the solution in editorial (partial fault of lc editorial, thats why you should always visit solutions tab as well), if you solved this on your own using LPS then thats good.\n\nI don't have anything against repetition, that how we all learn, my point was when  you are doing a new question what should be more important : Learning something new or repeating something already done.\n\nYou are right on the point that its not trivial to break down a problem into another and requires good skills, I didn't think of LPS solution until i saw the editorial.\n\n\"if reusing an algorithm you already know is taboo, I wish you good luck on all binary search questions for example\" - Completely wrong comparison, binary search is a standard algorithm, whereas finding LPS is a popular problem what can be solved efficiently by DP, which is what I'm encouraging people to do this question with from scratch in the first place, the ideal way to solve this question is through DP and not have any dependency on LPS.\n"
                    },
                    {
                        "username": "kyleyarwood",
                        "content": "Resorting to an older question is not a bad thing. Reducing to a known problem is an extremely effective way of solving problems."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I couldn't disagree more with \" in fact if you need to resort to using an older question you solved to solve a new question you really aren't learning anything new\", which is a completely counter-pedagogic statement on so many accounts:\n- You learn by repetition. I'm glad for you if you learn and master every algorithm after seeing them once, but most humans don't, and re-visiting and adapting an previously seen solution is a great way to practise reinforcement learning\n- 99% of problems you will see IRL are a reformulation of something you or someone else has already done before. Recognizing patterns and re-using previous knowledge is a skill that you have to learn. You are learning that.\n- Reformulating a problem as an equivalent one can be far from trivial in many cases and it is a mental habit that needs to be practised\n- if reusing an algorithm you already know is taboo, I wish you good luck on all binary search questions for example\n\nWhile I agree that other solutions are important to consider, I thought the broad generalization you're making is totally wrong.\nIn this case, I would in fact argue that recognizing that you can use the LCS on the reverse string is not obvious and requires as much insight and thought as the direct solution"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "ohh pols agyi pols. Palindromic pols"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@codeMonarch](/codeMonarch) na na daro na ji LCS modi5 karay hunda he ji"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "oo daro na mallo, eh to two pointer hai"
                    },
                    {
                        "username": "aalmos",
                        "content": "While I was coding the trivial DP solution I kept thinking it\\'d TLE and what trick-based greedy solution I could apply instead that would justify the hard tag..."
                    },
                    {
                        "username": "code_er7",
                        "content": "Why there have to be so many DP problems ."
                    },
                    {
                        "username": "053_NeerajKumar",
                        "content": "Approach -\\n\\n1) Take two pointer to begin and end of string.\\n2) For string to be palindrome s[begin] == s[end]\\n  -> If yes, no need of insertion, check in remaining substring\\n    So, fun(begin, end) = fun(begin+1, end-1).\\n  -> If no, then a new char should be inserted to make them equal and this insertion can be done at position begin or end (whichever results in min insertion further,\\n    So, fun(begin, end) = 1+min(fun(begin+1, end), fun(begin, end-1)).\\n3) Use dp[begin][end] to remove repititive function calls."
                    },
                    {
                        "username": "rawatpravesh0016",
                        "content": "This is giving TLE"
                    },
                    {
                        "username": "RkRohitKumar",
                        "content": "its a super easy problem"
                    },
                    {
                        "username": "_sri_hari_",
                        "content": "When you are coding the memoization, declare the vector globally rather than passing to the function as It gave MLE when I coded in C++.\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n=s.length();\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        return dfs(s,0,n-1,dp);\\n    }\\n    int dfs(string s,int i,int j,vector<vector<int>>& dp){\\n        if(i>=j)return 0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        if(s[i]==s[j])return dp[i][j]=dfs(s,i+1,j-1,dp);\\n        return dp[i][j]=min(1+dfs(s,i,j-1,dp),1+dfs(s,i+1,j,dp));\\n    }\\n};\\n"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "2nd hint is the complete solution itself : D"
                    }
                ]
            },
            {
                "id": 1871000,
                "content": [
                    {
                        "username": "singhom",
                        "content": "i just coded it and thought it wont work and it worked"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "[@Mshashikanth](/Mshashikanth)  it will happen \\uD83D\\uDE00"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "why can\\'t that type of wonders can\\'t happen to me, it is the fact i\\'m not coding ??"
                    },
                    {
                        "username": "zhuzhupang001",
                        "content": "if you never worked with DP, this is hard.\\nIf you are comfortable with most DP problems, this is easy to medium"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "You don\\'t need to use LCS for this, in fact if you need to resort to using an older question you solved to solve a new question you really aren\\'t learning anything new. For anyone trying to get better at dp, don\\'t memorize (or should I say memoize huh , not good, ok !) any solution. Properly understand why we are doing what we are doing. For this particular question it\\'s a simple choice, insert at left or right position in case of mismatch and pick the better solution."
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "[@cartesPerforees](/cartesPerforees)  My comment was mainly targeted towards people who were not able to solve this and used the solution in editorial (partial fault of lc editorial, thats why you should always visit solutions tab as well), if you solved this on your own using LPS then thats good.\n\nI don't have anything against repetition, that how we all learn, my point was when  you are doing a new question what should be more important : Learning something new or repeating something already done.\n\nYou are right on the point that its not trivial to break down a problem into another and requires good skills, I didn't think of LPS solution until i saw the editorial.\n\n\"if reusing an algorithm you already know is taboo, I wish you good luck on all binary search questions for example\" - Completely wrong comparison, binary search is a standard algorithm, whereas finding LPS is a popular problem what can be solved efficiently by DP, which is what I'm encouraging people to do this question with from scratch in the first place, the ideal way to solve this question is through DP and not have any dependency on LPS.\n"
                    },
                    {
                        "username": "kyleyarwood",
                        "content": "Resorting to an older question is not a bad thing. Reducing to a known problem is an extremely effective way of solving problems."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I couldn't disagree more with \" in fact if you need to resort to using an older question you solved to solve a new question you really aren't learning anything new\", which is a completely counter-pedagogic statement on so many accounts:\n- You learn by repetition. I'm glad for you if you learn and master every algorithm after seeing them once, but most humans don't, and re-visiting and adapting an previously seen solution is a great way to practise reinforcement learning\n- 99% of problems you will see IRL are a reformulation of something you or someone else has already done before. Recognizing patterns and re-using previous knowledge is a skill that you have to learn. You are learning that.\n- Reformulating a problem as an equivalent one can be far from trivial in many cases and it is a mental habit that needs to be practised\n- if reusing an algorithm you already know is taboo, I wish you good luck on all binary search questions for example\n\nWhile I agree that other solutions are important to consider, I thought the broad generalization you're making is totally wrong.\nIn this case, I would in fact argue that recognizing that you can use the LCS on the reverse string is not obvious and requires as much insight and thought as the direct solution"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "ohh pols agyi pols. Palindromic pols"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@codeMonarch](/codeMonarch) na na daro na ji LCS modi5 karay hunda he ji"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "oo daro na mallo, eh to two pointer hai"
                    },
                    {
                        "username": "aalmos",
                        "content": "While I was coding the trivial DP solution I kept thinking it\\'d TLE and what trick-based greedy solution I could apply instead that would justify the hard tag..."
                    },
                    {
                        "username": "code_er7",
                        "content": "Why there have to be so many DP problems ."
                    },
                    {
                        "username": "053_NeerajKumar",
                        "content": "Approach -\\n\\n1) Take two pointer to begin and end of string.\\n2) For string to be palindrome s[begin] == s[end]\\n  -> If yes, no need of insertion, check in remaining substring\\n    So, fun(begin, end) = fun(begin+1, end-1).\\n  -> If no, then a new char should be inserted to make them equal and this insertion can be done at position begin or end (whichever results in min insertion further,\\n    So, fun(begin, end) = 1+min(fun(begin+1, end), fun(begin, end-1)).\\n3) Use dp[begin][end] to remove repititive function calls."
                    },
                    {
                        "username": "rawatpravesh0016",
                        "content": "This is giving TLE"
                    },
                    {
                        "username": "RkRohitKumar",
                        "content": "its a super easy problem"
                    },
                    {
                        "username": "_sri_hari_",
                        "content": "When you are coding the memoization, declare the vector globally rather than passing to the function as It gave MLE when I coded in C++.\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n=s.length();\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        return dfs(s,0,n-1,dp);\\n    }\\n    int dfs(string s,int i,int j,vector<vector<int>>& dp){\\n        if(i>=j)return 0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        if(s[i]==s[j])return dp[i][j]=dfs(s,i+1,j-1,dp);\\n        return dp[i][j]=min(1+dfs(s,i,j-1,dp),1+dfs(s,i+1,j,dp));\\n    }\\n};\\n"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "2nd hint is the complete solution itself : D"
                    }
                ]
            },
            {
                "id": 1870729,
                "content": [
                    {
                        "username": "singhom",
                        "content": "i just coded it and thought it wont work and it worked"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "[@Mshashikanth](/Mshashikanth)  it will happen \\uD83D\\uDE00"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "why can\\'t that type of wonders can\\'t happen to me, it is the fact i\\'m not coding ??"
                    },
                    {
                        "username": "zhuzhupang001",
                        "content": "if you never worked with DP, this is hard.\\nIf you are comfortable with most DP problems, this is easy to medium"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "You don\\'t need to use LCS for this, in fact if you need to resort to using an older question you solved to solve a new question you really aren\\'t learning anything new. For anyone trying to get better at dp, don\\'t memorize (or should I say memoize huh , not good, ok !) any solution. Properly understand why we are doing what we are doing. For this particular question it\\'s a simple choice, insert at left or right position in case of mismatch and pick the better solution."
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "[@cartesPerforees](/cartesPerforees)  My comment was mainly targeted towards people who were not able to solve this and used the solution in editorial (partial fault of lc editorial, thats why you should always visit solutions tab as well), if you solved this on your own using LPS then thats good.\n\nI don't have anything against repetition, that how we all learn, my point was when  you are doing a new question what should be more important : Learning something new or repeating something already done.\n\nYou are right on the point that its not trivial to break down a problem into another and requires good skills, I didn't think of LPS solution until i saw the editorial.\n\n\"if reusing an algorithm you already know is taboo, I wish you good luck on all binary search questions for example\" - Completely wrong comparison, binary search is a standard algorithm, whereas finding LPS is a popular problem what can be solved efficiently by DP, which is what I'm encouraging people to do this question with from scratch in the first place, the ideal way to solve this question is through DP and not have any dependency on LPS.\n"
                    },
                    {
                        "username": "kyleyarwood",
                        "content": "Resorting to an older question is not a bad thing. Reducing to a known problem is an extremely effective way of solving problems."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I couldn't disagree more with \" in fact if you need to resort to using an older question you solved to solve a new question you really aren't learning anything new\", which is a completely counter-pedagogic statement on so many accounts:\n- You learn by repetition. I'm glad for you if you learn and master every algorithm after seeing them once, but most humans don't, and re-visiting and adapting an previously seen solution is a great way to practise reinforcement learning\n- 99% of problems you will see IRL are a reformulation of something you or someone else has already done before. Recognizing patterns and re-using previous knowledge is a skill that you have to learn. You are learning that.\n- Reformulating a problem as an equivalent one can be far from trivial in many cases and it is a mental habit that needs to be practised\n- if reusing an algorithm you already know is taboo, I wish you good luck on all binary search questions for example\n\nWhile I agree that other solutions are important to consider, I thought the broad generalization you're making is totally wrong.\nIn this case, I would in fact argue that recognizing that you can use the LCS on the reverse string is not obvious and requires as much insight and thought as the direct solution"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "ohh pols agyi pols. Palindromic pols"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@codeMonarch](/codeMonarch) na na daro na ji LCS modi5 karay hunda he ji"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "oo daro na mallo, eh to two pointer hai"
                    },
                    {
                        "username": "aalmos",
                        "content": "While I was coding the trivial DP solution I kept thinking it\\'d TLE and what trick-based greedy solution I could apply instead that would justify the hard tag..."
                    },
                    {
                        "username": "code_er7",
                        "content": "Why there have to be so many DP problems ."
                    },
                    {
                        "username": "053_NeerajKumar",
                        "content": "Approach -\\n\\n1) Take two pointer to begin and end of string.\\n2) For string to be palindrome s[begin] == s[end]\\n  -> If yes, no need of insertion, check in remaining substring\\n    So, fun(begin, end) = fun(begin+1, end-1).\\n  -> If no, then a new char should be inserted to make them equal and this insertion can be done at position begin or end (whichever results in min insertion further,\\n    So, fun(begin, end) = 1+min(fun(begin+1, end), fun(begin, end-1)).\\n3) Use dp[begin][end] to remove repititive function calls."
                    },
                    {
                        "username": "rawatpravesh0016",
                        "content": "This is giving TLE"
                    },
                    {
                        "username": "RkRohitKumar",
                        "content": "its a super easy problem"
                    },
                    {
                        "username": "_sri_hari_",
                        "content": "When you are coding the memoization, declare the vector globally rather than passing to the function as It gave MLE when I coded in C++.\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n=s.length();\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        return dfs(s,0,n-1,dp);\\n    }\\n    int dfs(string s,int i,int j,vector<vector<int>>& dp){\\n        if(i>=j)return 0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        if(s[i]==s[j])return dp[i][j]=dfs(s,i+1,j-1,dp);\\n        return dp[i][j]=min(1+dfs(s,i,j-1,dp),1+dfs(s,i+1,j,dp));\\n    }\\n};\\n"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "2nd hint is the complete solution itself : D"
                    }
                ]
            },
            {
                "id": 1870701,
                "content": [
                    {
                        "username": "singhom",
                        "content": "i just coded it and thought it wont work and it worked"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "[@Mshashikanth](/Mshashikanth)  it will happen \\uD83D\\uDE00"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "why can\\'t that type of wonders can\\'t happen to me, it is the fact i\\'m not coding ??"
                    },
                    {
                        "username": "zhuzhupang001",
                        "content": "if you never worked with DP, this is hard.\\nIf you are comfortable with most DP problems, this is easy to medium"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "You don\\'t need to use LCS for this, in fact if you need to resort to using an older question you solved to solve a new question you really aren\\'t learning anything new. For anyone trying to get better at dp, don\\'t memorize (or should I say memoize huh , not good, ok !) any solution. Properly understand why we are doing what we are doing. For this particular question it\\'s a simple choice, insert at left or right position in case of mismatch and pick the better solution."
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "[@cartesPerforees](/cartesPerforees)  My comment was mainly targeted towards people who were not able to solve this and used the solution in editorial (partial fault of lc editorial, thats why you should always visit solutions tab as well), if you solved this on your own using LPS then thats good.\n\nI don't have anything against repetition, that how we all learn, my point was when  you are doing a new question what should be more important : Learning something new or repeating something already done.\n\nYou are right on the point that its not trivial to break down a problem into another and requires good skills, I didn't think of LPS solution until i saw the editorial.\n\n\"if reusing an algorithm you already know is taboo, I wish you good luck on all binary search questions for example\" - Completely wrong comparison, binary search is a standard algorithm, whereas finding LPS is a popular problem what can be solved efficiently by DP, which is what I'm encouraging people to do this question with from scratch in the first place, the ideal way to solve this question is through DP and not have any dependency on LPS.\n"
                    },
                    {
                        "username": "kyleyarwood",
                        "content": "Resorting to an older question is not a bad thing. Reducing to a known problem is an extremely effective way of solving problems."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I couldn't disagree more with \" in fact if you need to resort to using an older question you solved to solve a new question you really aren't learning anything new\", which is a completely counter-pedagogic statement on so many accounts:\n- You learn by repetition. I'm glad for you if you learn and master every algorithm after seeing them once, but most humans don't, and re-visiting and adapting an previously seen solution is a great way to practise reinforcement learning\n- 99% of problems you will see IRL are a reformulation of something you or someone else has already done before. Recognizing patterns and re-using previous knowledge is a skill that you have to learn. You are learning that.\n- Reformulating a problem as an equivalent one can be far from trivial in many cases and it is a mental habit that needs to be practised\n- if reusing an algorithm you already know is taboo, I wish you good luck on all binary search questions for example\n\nWhile I agree that other solutions are important to consider, I thought the broad generalization you're making is totally wrong.\nIn this case, I would in fact argue that recognizing that you can use the LCS on the reverse string is not obvious and requires as much insight and thought as the direct solution"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "ohh pols agyi pols. Palindromic pols"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@codeMonarch](/codeMonarch) na na daro na ji LCS modi5 karay hunda he ji"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "oo daro na mallo, eh to two pointer hai"
                    },
                    {
                        "username": "aalmos",
                        "content": "While I was coding the trivial DP solution I kept thinking it\\'d TLE and what trick-based greedy solution I could apply instead that would justify the hard tag..."
                    },
                    {
                        "username": "code_er7",
                        "content": "Why there have to be so many DP problems ."
                    },
                    {
                        "username": "053_NeerajKumar",
                        "content": "Approach -\\n\\n1) Take two pointer to begin and end of string.\\n2) For string to be palindrome s[begin] == s[end]\\n  -> If yes, no need of insertion, check in remaining substring\\n    So, fun(begin, end) = fun(begin+1, end-1).\\n  -> If no, then a new char should be inserted to make them equal and this insertion can be done at position begin or end (whichever results in min insertion further,\\n    So, fun(begin, end) = 1+min(fun(begin+1, end), fun(begin, end-1)).\\n3) Use dp[begin][end] to remove repititive function calls."
                    },
                    {
                        "username": "rawatpravesh0016",
                        "content": "This is giving TLE"
                    },
                    {
                        "username": "RkRohitKumar",
                        "content": "its a super easy problem"
                    },
                    {
                        "username": "_sri_hari_",
                        "content": "When you are coding the memoization, declare the vector globally rather than passing to the function as It gave MLE when I coded in C++.\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n=s.length();\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        return dfs(s,0,n-1,dp);\\n    }\\n    int dfs(string s,int i,int j,vector<vector<int>>& dp){\\n        if(i>=j)return 0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        if(s[i]==s[j])return dp[i][j]=dfs(s,i+1,j-1,dp);\\n        return dp[i][j]=min(1+dfs(s,i,j-1,dp),1+dfs(s,i+1,j,dp));\\n    }\\n};\\n"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "2nd hint is the complete solution itself : D"
                    }
                ]
            },
            {
                "id": 1870571,
                "content": [
                    {
                        "username": "singhom",
                        "content": "i just coded it and thought it wont work and it worked"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "[@Mshashikanth](/Mshashikanth)  it will happen \\uD83D\\uDE00"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "why can\\'t that type of wonders can\\'t happen to me, it is the fact i\\'m not coding ??"
                    },
                    {
                        "username": "zhuzhupang001",
                        "content": "if you never worked with DP, this is hard.\\nIf you are comfortable with most DP problems, this is easy to medium"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "You don\\'t need to use LCS for this, in fact if you need to resort to using an older question you solved to solve a new question you really aren\\'t learning anything new. For anyone trying to get better at dp, don\\'t memorize (or should I say memoize huh , not good, ok !) any solution. Properly understand why we are doing what we are doing. For this particular question it\\'s a simple choice, insert at left or right position in case of mismatch and pick the better solution."
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "[@cartesPerforees](/cartesPerforees)  My comment was mainly targeted towards people who were not able to solve this and used the solution in editorial (partial fault of lc editorial, thats why you should always visit solutions tab as well), if you solved this on your own using LPS then thats good.\n\nI don't have anything against repetition, that how we all learn, my point was when  you are doing a new question what should be more important : Learning something new or repeating something already done.\n\nYou are right on the point that its not trivial to break down a problem into another and requires good skills, I didn't think of LPS solution until i saw the editorial.\n\n\"if reusing an algorithm you already know is taboo, I wish you good luck on all binary search questions for example\" - Completely wrong comparison, binary search is a standard algorithm, whereas finding LPS is a popular problem what can be solved efficiently by DP, which is what I'm encouraging people to do this question with from scratch in the first place, the ideal way to solve this question is through DP and not have any dependency on LPS.\n"
                    },
                    {
                        "username": "kyleyarwood",
                        "content": "Resorting to an older question is not a bad thing. Reducing to a known problem is an extremely effective way of solving problems."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I couldn't disagree more with \" in fact if you need to resort to using an older question you solved to solve a new question you really aren't learning anything new\", which is a completely counter-pedagogic statement on so many accounts:\n- You learn by repetition. I'm glad for you if you learn and master every algorithm after seeing them once, but most humans don't, and re-visiting and adapting an previously seen solution is a great way to practise reinforcement learning\n- 99% of problems you will see IRL are a reformulation of something you or someone else has already done before. Recognizing patterns and re-using previous knowledge is a skill that you have to learn. You are learning that.\n- Reformulating a problem as an equivalent one can be far from trivial in many cases and it is a mental habit that needs to be practised\n- if reusing an algorithm you already know is taboo, I wish you good luck on all binary search questions for example\n\nWhile I agree that other solutions are important to consider, I thought the broad generalization you're making is totally wrong.\nIn this case, I would in fact argue that recognizing that you can use the LCS on the reverse string is not obvious and requires as much insight and thought as the direct solution"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "ohh pols agyi pols. Palindromic pols"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@codeMonarch](/codeMonarch) na na daro na ji LCS modi5 karay hunda he ji"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "oo daro na mallo, eh to two pointer hai"
                    },
                    {
                        "username": "aalmos",
                        "content": "While I was coding the trivial DP solution I kept thinking it\\'d TLE and what trick-based greedy solution I could apply instead that would justify the hard tag..."
                    },
                    {
                        "username": "code_er7",
                        "content": "Why there have to be so many DP problems ."
                    },
                    {
                        "username": "053_NeerajKumar",
                        "content": "Approach -\\n\\n1) Take two pointer to begin and end of string.\\n2) For string to be palindrome s[begin] == s[end]\\n  -> If yes, no need of insertion, check in remaining substring\\n    So, fun(begin, end) = fun(begin+1, end-1).\\n  -> If no, then a new char should be inserted to make them equal and this insertion can be done at position begin or end (whichever results in min insertion further,\\n    So, fun(begin, end) = 1+min(fun(begin+1, end), fun(begin, end-1)).\\n3) Use dp[begin][end] to remove repititive function calls."
                    },
                    {
                        "username": "rawatpravesh0016",
                        "content": "This is giving TLE"
                    },
                    {
                        "username": "RkRohitKumar",
                        "content": "its a super easy problem"
                    },
                    {
                        "username": "_sri_hari_",
                        "content": "When you are coding the memoization, declare the vector globally rather than passing to the function as It gave MLE when I coded in C++.\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n=s.length();\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        return dfs(s,0,n-1,dp);\\n    }\\n    int dfs(string s,int i,int j,vector<vector<int>>& dp){\\n        if(i>=j)return 0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        if(s[i]==s[j])return dp[i][j]=dfs(s,i+1,j-1,dp);\\n        return dp[i][j]=min(1+dfs(s,i,j-1,dp),1+dfs(s,i+1,j,dp));\\n    }\\n};\\n"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "2nd hint is the complete solution itself : D"
                    }
                ]
            },
            {
                "id": 2065950,
                "content": [
                    {
                        "username": "singhom",
                        "content": "i just coded it and thought it wont work and it worked"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "[@Mshashikanth](/Mshashikanth)  it will happen \\uD83D\\uDE00"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "why can\\'t that type of wonders can\\'t happen to me, it is the fact i\\'m not coding ??"
                    },
                    {
                        "username": "zhuzhupang001",
                        "content": "if you never worked with DP, this is hard.\\nIf you are comfortable with most DP problems, this is easy to medium"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "You don\\'t need to use LCS for this, in fact if you need to resort to using an older question you solved to solve a new question you really aren\\'t learning anything new. For anyone trying to get better at dp, don\\'t memorize (or should I say memoize huh , not good, ok !) any solution. Properly understand why we are doing what we are doing. For this particular question it\\'s a simple choice, insert at left or right position in case of mismatch and pick the better solution."
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "[@cartesPerforees](/cartesPerforees)  My comment was mainly targeted towards people who were not able to solve this and used the solution in editorial (partial fault of lc editorial, thats why you should always visit solutions tab as well), if you solved this on your own using LPS then thats good.\n\nI don't have anything against repetition, that how we all learn, my point was when  you are doing a new question what should be more important : Learning something new or repeating something already done.\n\nYou are right on the point that its not trivial to break down a problem into another and requires good skills, I didn't think of LPS solution until i saw the editorial.\n\n\"if reusing an algorithm you already know is taboo, I wish you good luck on all binary search questions for example\" - Completely wrong comparison, binary search is a standard algorithm, whereas finding LPS is a popular problem what can be solved efficiently by DP, which is what I'm encouraging people to do this question with from scratch in the first place, the ideal way to solve this question is through DP and not have any dependency on LPS.\n"
                    },
                    {
                        "username": "kyleyarwood",
                        "content": "Resorting to an older question is not a bad thing. Reducing to a known problem is an extremely effective way of solving problems."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I couldn't disagree more with \" in fact if you need to resort to using an older question you solved to solve a new question you really aren't learning anything new\", which is a completely counter-pedagogic statement on so many accounts:\n- You learn by repetition. I'm glad for you if you learn and master every algorithm after seeing them once, but most humans don't, and re-visiting and adapting an previously seen solution is a great way to practise reinforcement learning\n- 99% of problems you will see IRL are a reformulation of something you or someone else has already done before. Recognizing patterns and re-using previous knowledge is a skill that you have to learn. You are learning that.\n- Reformulating a problem as an equivalent one can be far from trivial in many cases and it is a mental habit that needs to be practised\n- if reusing an algorithm you already know is taboo, I wish you good luck on all binary search questions for example\n\nWhile I agree that other solutions are important to consider, I thought the broad generalization you're making is totally wrong.\nIn this case, I would in fact argue that recognizing that you can use the LCS on the reverse string is not obvious and requires as much insight and thought as the direct solution"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "ohh pols agyi pols. Palindromic pols"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@codeMonarch](/codeMonarch) na na daro na ji LCS modi5 karay hunda he ji"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "oo daro na mallo, eh to two pointer hai"
                    },
                    {
                        "username": "aalmos",
                        "content": "While I was coding the trivial DP solution I kept thinking it\\'d TLE and what trick-based greedy solution I could apply instead that would justify the hard tag..."
                    },
                    {
                        "username": "code_er7",
                        "content": "Why there have to be so many DP problems ."
                    },
                    {
                        "username": "053_NeerajKumar",
                        "content": "Approach -\\n\\n1) Take two pointer to begin and end of string.\\n2) For string to be palindrome s[begin] == s[end]\\n  -> If yes, no need of insertion, check in remaining substring\\n    So, fun(begin, end) = fun(begin+1, end-1).\\n  -> If no, then a new char should be inserted to make them equal and this insertion can be done at position begin or end (whichever results in min insertion further,\\n    So, fun(begin, end) = 1+min(fun(begin+1, end), fun(begin, end-1)).\\n3) Use dp[begin][end] to remove repititive function calls."
                    },
                    {
                        "username": "rawatpravesh0016",
                        "content": "This is giving TLE"
                    },
                    {
                        "username": "RkRohitKumar",
                        "content": "its a super easy problem"
                    },
                    {
                        "username": "_sri_hari_",
                        "content": "When you are coding the memoization, declare the vector globally rather than passing to the function as It gave MLE when I coded in C++.\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n=s.length();\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        return dfs(s,0,n-1,dp);\\n    }\\n    int dfs(string s,int i,int j,vector<vector<int>>& dp){\\n        if(i>=j)return 0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        if(s[i]==s[j])return dp[i][j]=dfs(s,i+1,j-1,dp);\\n        return dp[i][j]=min(1+dfs(s,i,j-1,dp),1+dfs(s,i+1,j,dp));\\n    }\\n};\\n"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "2nd hint is the complete solution itself : D"
                    }
                ]
            },
            {
                "id": 2059313,
                "content": [
                    {
                        "username": "singhom",
                        "content": "i just coded it and thought it wont work and it worked"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "[@Mshashikanth](/Mshashikanth)  it will happen \\uD83D\\uDE00"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "why can\\'t that type of wonders can\\'t happen to me, it is the fact i\\'m not coding ??"
                    },
                    {
                        "username": "zhuzhupang001",
                        "content": "if you never worked with DP, this is hard.\\nIf you are comfortable with most DP problems, this is easy to medium"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "You don\\'t need to use LCS for this, in fact if you need to resort to using an older question you solved to solve a new question you really aren\\'t learning anything new. For anyone trying to get better at dp, don\\'t memorize (or should I say memoize huh , not good, ok !) any solution. Properly understand why we are doing what we are doing. For this particular question it\\'s a simple choice, insert at left or right position in case of mismatch and pick the better solution."
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "[@cartesPerforees](/cartesPerforees)  My comment was mainly targeted towards people who were not able to solve this and used the solution in editorial (partial fault of lc editorial, thats why you should always visit solutions tab as well), if you solved this on your own using LPS then thats good.\n\nI don't have anything against repetition, that how we all learn, my point was when  you are doing a new question what should be more important : Learning something new or repeating something already done.\n\nYou are right on the point that its not trivial to break down a problem into another and requires good skills, I didn't think of LPS solution until i saw the editorial.\n\n\"if reusing an algorithm you already know is taboo, I wish you good luck on all binary search questions for example\" - Completely wrong comparison, binary search is a standard algorithm, whereas finding LPS is a popular problem what can be solved efficiently by DP, which is what I'm encouraging people to do this question with from scratch in the first place, the ideal way to solve this question is through DP and not have any dependency on LPS.\n"
                    },
                    {
                        "username": "kyleyarwood",
                        "content": "Resorting to an older question is not a bad thing. Reducing to a known problem is an extremely effective way of solving problems."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I couldn't disagree more with \" in fact if you need to resort to using an older question you solved to solve a new question you really aren't learning anything new\", which is a completely counter-pedagogic statement on so many accounts:\n- You learn by repetition. I'm glad for you if you learn and master every algorithm after seeing them once, but most humans don't, and re-visiting and adapting an previously seen solution is a great way to practise reinforcement learning\n- 99% of problems you will see IRL are a reformulation of something you or someone else has already done before. Recognizing patterns and re-using previous knowledge is a skill that you have to learn. You are learning that.\n- Reformulating a problem as an equivalent one can be far from trivial in many cases and it is a mental habit that needs to be practised\n- if reusing an algorithm you already know is taboo, I wish you good luck on all binary search questions for example\n\nWhile I agree that other solutions are important to consider, I thought the broad generalization you're making is totally wrong.\nIn this case, I would in fact argue that recognizing that you can use the LCS on the reverse string is not obvious and requires as much insight and thought as the direct solution"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "ohh pols agyi pols. Palindromic pols"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@codeMonarch](/codeMonarch) na na daro na ji LCS modi5 karay hunda he ji"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "oo daro na mallo, eh to two pointer hai"
                    },
                    {
                        "username": "aalmos",
                        "content": "While I was coding the trivial DP solution I kept thinking it\\'d TLE and what trick-based greedy solution I could apply instead that would justify the hard tag..."
                    },
                    {
                        "username": "code_er7",
                        "content": "Why there have to be so many DP problems ."
                    },
                    {
                        "username": "053_NeerajKumar",
                        "content": "Approach -\\n\\n1) Take two pointer to begin and end of string.\\n2) For string to be palindrome s[begin] == s[end]\\n  -> If yes, no need of insertion, check in remaining substring\\n    So, fun(begin, end) = fun(begin+1, end-1).\\n  -> If no, then a new char should be inserted to make them equal and this insertion can be done at position begin or end (whichever results in min insertion further,\\n    So, fun(begin, end) = 1+min(fun(begin+1, end), fun(begin, end-1)).\\n3) Use dp[begin][end] to remove repititive function calls."
                    },
                    {
                        "username": "rawatpravesh0016",
                        "content": "This is giving TLE"
                    },
                    {
                        "username": "RkRohitKumar",
                        "content": "its a super easy problem"
                    },
                    {
                        "username": "_sri_hari_",
                        "content": "When you are coding the memoization, declare the vector globally rather than passing to the function as It gave MLE when I coded in C++.\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n=s.length();\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        return dfs(s,0,n-1,dp);\\n    }\\n    int dfs(string s,int i,int j,vector<vector<int>>& dp){\\n        if(i>=j)return 0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        if(s[i]==s[j])return dp[i][j]=dfs(s,i+1,j-1,dp);\\n        return dp[i][j]=min(1+dfs(s,i,j-1,dp),1+dfs(s,i+1,j,dp));\\n    }\\n};\\n"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "2nd hint is the complete solution itself : D"
                    }
                ]
            },
            {
                "id": 1995533,
                "content": [
                    {
                        "username": "singhom",
                        "content": "i just coded it and thought it wont work and it worked"
                    },
                    {
                        "username": "Sujansinh_Thakor",
                        "content": "[@Mshashikanth](/Mshashikanth)  it will happen \\uD83D\\uDE00"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "why can\\'t that type of wonders can\\'t happen to me, it is the fact i\\'m not coding ??"
                    },
                    {
                        "username": "zhuzhupang001",
                        "content": "if you never worked with DP, this is hard.\\nIf you are comfortable with most DP problems, this is easy to medium"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "You don\\'t need to use LCS for this, in fact if you need to resort to using an older question you solved to solve a new question you really aren\\'t learning anything new. For anyone trying to get better at dp, don\\'t memorize (or should I say memoize huh , not good, ok !) any solution. Properly understand why we are doing what we are doing. For this particular question it\\'s a simple choice, insert at left or right position in case of mismatch and pick the better solution."
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "[@cartesPerforees](/cartesPerforees)  My comment was mainly targeted towards people who were not able to solve this and used the solution in editorial (partial fault of lc editorial, thats why you should always visit solutions tab as well), if you solved this on your own using LPS then thats good.\n\nI don't have anything against repetition, that how we all learn, my point was when  you are doing a new question what should be more important : Learning something new or repeating something already done.\n\nYou are right on the point that its not trivial to break down a problem into another and requires good skills, I didn't think of LPS solution until i saw the editorial.\n\n\"if reusing an algorithm you already know is taboo, I wish you good luck on all binary search questions for example\" - Completely wrong comparison, binary search is a standard algorithm, whereas finding LPS is a popular problem what can be solved efficiently by DP, which is what I'm encouraging people to do this question with from scratch in the first place, the ideal way to solve this question is through DP and not have any dependency on LPS.\n"
                    },
                    {
                        "username": "kyleyarwood",
                        "content": "Resorting to an older question is not a bad thing. Reducing to a known problem is an extremely effective way of solving problems."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I couldn't disagree more with \" in fact if you need to resort to using an older question you solved to solve a new question you really aren't learning anything new\", which is a completely counter-pedagogic statement on so many accounts:\n- You learn by repetition. I'm glad for you if you learn and master every algorithm after seeing them once, but most humans don't, and re-visiting and adapting an previously seen solution is a great way to practise reinforcement learning\n- 99% of problems you will see IRL are a reformulation of something you or someone else has already done before. Recognizing patterns and re-using previous knowledge is a skill that you have to learn. You are learning that.\n- Reformulating a problem as an equivalent one can be far from trivial in many cases and it is a mental habit that needs to be practised\n- if reusing an algorithm you already know is taboo, I wish you good luck on all binary search questions for example\n\nWhile I agree that other solutions are important to consider, I thought the broad generalization you're making is totally wrong.\nIn this case, I would in fact argue that recognizing that you can use the LCS on the reverse string is not obvious and requires as much insight and thought as the direct solution"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "ohh pols agyi pols. Palindromic pols"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@codeMonarch](/codeMonarch) na na daro na ji LCS modi5 karay hunda he ji"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "oo daro na mallo, eh to two pointer hai"
                    },
                    {
                        "username": "aalmos",
                        "content": "While I was coding the trivial DP solution I kept thinking it\\'d TLE and what trick-based greedy solution I could apply instead that would justify the hard tag..."
                    },
                    {
                        "username": "code_er7",
                        "content": "Why there have to be so many DP problems ."
                    },
                    {
                        "username": "053_NeerajKumar",
                        "content": "Approach -\\n\\n1) Take two pointer to begin and end of string.\\n2) For string to be palindrome s[begin] == s[end]\\n  -> If yes, no need of insertion, check in remaining substring\\n    So, fun(begin, end) = fun(begin+1, end-1).\\n  -> If no, then a new char should be inserted to make them equal and this insertion can be done at position begin or end (whichever results in min insertion further,\\n    So, fun(begin, end) = 1+min(fun(begin+1, end), fun(begin, end-1)).\\n3) Use dp[begin][end] to remove repititive function calls."
                    },
                    {
                        "username": "rawatpravesh0016",
                        "content": "This is giving TLE"
                    },
                    {
                        "username": "RkRohitKumar",
                        "content": "its a super easy problem"
                    },
                    {
                        "username": "_sri_hari_",
                        "content": "When you are coding the memoization, declare the vector globally rather than passing to the function as It gave MLE when I coded in C++.\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int n=s.length();\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        return dfs(s,0,n-1,dp);\\n    }\\n    int dfs(string s,int i,int j,vector<vector<int>>& dp){\\n        if(i>=j)return 0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        if(s[i]==s[j])return dp[i][j]=dfs(s,i+1,j-1,dp);\\n        return dp[i][j]=min(1+dfs(s,i,j-1,dp),1+dfs(s,i+1,j,dp));\\n    }\\n};\\n"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "2nd hint is the complete solution itself : D"
                    }
                ]
            },
            {
                "id": 1994013,
                "content": [
                    {
                        "username": "dvakar",
                        "content": "1.  `\"e\"`\\n2.  `\"le\"`\\n3.  `\"gpbsbdrfyapdarigjwyidhnxzecuddrcohufbjjzudpyenvnypqkcyvpydnvtijalwfmzbsvqhalvlurdabfmjddjmfbadrulvlahqvsbzmfwlajitvndypvyckqpynvneypduzjjbfuhocrdducezxnhdiywjgiradpayfrdbsbpg\"`"
                    },
                    {
                        "username": "sarthak95r",
                        "content": "\\nI spent like 2 hours on this one, read discuss section for some hint.\\nThen it became an easy problem( if you know the trick).\\nOtherwise it is very tough to come up in an interview situation \\n\\nBasically the number of insertion is equal to len(str) -len(longest palindromic subsequence)"
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "without hint this is hard ...with hint this is easy\\n"
                    },
                    {
                        "username": "jihweiliang",
                        "content": "This is easy if you are familiar with LCS. "
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "First time i my life i just give it a try  , run my own solution ,and it passed in one go \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "tin1254",
                        "content": "Once you see the hint then it becomes a medium problem."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Eid Mubarak from Bangladesh"
                    },
                    {
                        "username": "ankitsumitsharma80",
                        "content": "This doesn\\'t looks to be hard, Leet code is marking medium as hard "
                    },
                    {
                        "username": "arumuga007",
                        "content": "where is \\'e\\' in \"leetcode\" in 3rd example"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "leetcodo(1)c(2)t(3)e(4)`e`l(5)"
                    },
                    {
                        "username": "kausachan",
                        "content": "After learning DP my thought process reduced, before knowing DP my brain would have spent hours thinking on how to optimize this, in that time new approaches will click. But now after seeing the question brain realizes that its a DP problem, without any big thinking just proceeds to memoize :-("
                    }
                ]
            },
            {
                "id": 1980301,
                "content": [
                    {
                        "username": "dvakar",
                        "content": "1.  `\"e\"`\\n2.  `\"le\"`\\n3.  `\"gpbsbdrfyapdarigjwyidhnxzecuddrcohufbjjzudpyenvnypqkcyvpydnvtijalwfmzbsvqhalvlurdabfmjddjmfbadrulvlahqvsbzmfwlajitvndypvyckqpynvneypduzjjbfuhocrdducezxnhdiywjgiradpayfrdbsbpg\"`"
                    },
                    {
                        "username": "sarthak95r",
                        "content": "\\nI spent like 2 hours on this one, read discuss section for some hint.\\nThen it became an easy problem( if you know the trick).\\nOtherwise it is very tough to come up in an interview situation \\n\\nBasically the number of insertion is equal to len(str) -len(longest palindromic subsequence)"
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "without hint this is hard ...with hint this is easy\\n"
                    },
                    {
                        "username": "jihweiliang",
                        "content": "This is easy if you are familiar with LCS. "
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "First time i my life i just give it a try  , run my own solution ,and it passed in one go \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "tin1254",
                        "content": "Once you see the hint then it becomes a medium problem."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Eid Mubarak from Bangladesh"
                    },
                    {
                        "username": "ankitsumitsharma80",
                        "content": "This doesn\\'t looks to be hard, Leet code is marking medium as hard "
                    },
                    {
                        "username": "arumuga007",
                        "content": "where is \\'e\\' in \"leetcode\" in 3rd example"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "leetcodo(1)c(2)t(3)e(4)`e`l(5)"
                    },
                    {
                        "username": "kausachan",
                        "content": "After learning DP my thought process reduced, before knowing DP my brain would have spent hours thinking on how to optimize this, in that time new approaches will click. But now after seeing the question brain realizes that its a DP problem, without any big thinking just proceeds to memoize :-("
                    }
                ]
            },
            {
                "id": 1947154,
                "content": [
                    {
                        "username": "dvakar",
                        "content": "1.  `\"e\"`\\n2.  `\"le\"`\\n3.  `\"gpbsbdrfyapdarigjwyidhnxzecuddrcohufbjjzudpyenvnypqkcyvpydnvtijalwfmzbsvqhalvlurdabfmjddjmfbadrulvlahqvsbzmfwlajitvndypvyckqpynvneypduzjjbfuhocrdducezxnhdiywjgiradpayfrdbsbpg\"`"
                    },
                    {
                        "username": "sarthak95r",
                        "content": "\\nI spent like 2 hours on this one, read discuss section for some hint.\\nThen it became an easy problem( if you know the trick).\\nOtherwise it is very tough to come up in an interview situation \\n\\nBasically the number of insertion is equal to len(str) -len(longest palindromic subsequence)"
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "without hint this is hard ...with hint this is easy\\n"
                    },
                    {
                        "username": "jihweiliang",
                        "content": "This is easy if you are familiar with LCS. "
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "First time i my life i just give it a try  , run my own solution ,and it passed in one go \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "tin1254",
                        "content": "Once you see the hint then it becomes a medium problem."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Eid Mubarak from Bangladesh"
                    },
                    {
                        "username": "ankitsumitsharma80",
                        "content": "This doesn\\'t looks to be hard, Leet code is marking medium as hard "
                    },
                    {
                        "username": "arumuga007",
                        "content": "where is \\'e\\' in \"leetcode\" in 3rd example"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "leetcodo(1)c(2)t(3)e(4)`e`l(5)"
                    },
                    {
                        "username": "kausachan",
                        "content": "After learning DP my thought process reduced, before knowing DP my brain would have spent hours thinking on how to optimize this, in that time new approaches will click. But now after seeing the question brain realizes that its a DP problem, without any big thinking just proceeds to memoize :-("
                    }
                ]
            },
            {
                "id": 1871225,
                "content": [
                    {
                        "username": "dvakar",
                        "content": "1.  `\"e\"`\\n2.  `\"le\"`\\n3.  `\"gpbsbdrfyapdarigjwyidhnxzecuddrcohufbjjzudpyenvnypqkcyvpydnvtijalwfmzbsvqhalvlurdabfmjddjmfbadrulvlahqvsbzmfwlajitvndypvyckqpynvneypduzjjbfuhocrdducezxnhdiywjgiradpayfrdbsbpg\"`"
                    },
                    {
                        "username": "sarthak95r",
                        "content": "\\nI spent like 2 hours on this one, read discuss section for some hint.\\nThen it became an easy problem( if you know the trick).\\nOtherwise it is very tough to come up in an interview situation \\n\\nBasically the number of insertion is equal to len(str) -len(longest palindromic subsequence)"
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "without hint this is hard ...with hint this is easy\\n"
                    },
                    {
                        "username": "jihweiliang",
                        "content": "This is easy if you are familiar with LCS. "
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "First time i my life i just give it a try  , run my own solution ,and it passed in one go \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "tin1254",
                        "content": "Once you see the hint then it becomes a medium problem."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Eid Mubarak from Bangladesh"
                    },
                    {
                        "username": "ankitsumitsharma80",
                        "content": "This doesn\\'t looks to be hard, Leet code is marking medium as hard "
                    },
                    {
                        "username": "arumuga007",
                        "content": "where is \\'e\\' in \"leetcode\" in 3rd example"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "leetcodo(1)c(2)t(3)e(4)`e`l(5)"
                    },
                    {
                        "username": "kausachan",
                        "content": "After learning DP my thought process reduced, before knowing DP my brain would have spent hours thinking on how to optimize this, in that time new approaches will click. But now after seeing the question brain realizes that its a DP problem, without any big thinking just proceeds to memoize :-("
                    }
                ]
            },
            {
                "id": 1871077,
                "content": [
                    {
                        "username": "dvakar",
                        "content": "1.  `\"e\"`\\n2.  `\"le\"`\\n3.  `\"gpbsbdrfyapdarigjwyidhnxzecuddrcohufbjjzudpyenvnypqkcyvpydnvtijalwfmzbsvqhalvlurdabfmjddjmfbadrulvlahqvsbzmfwlajitvndypvyckqpynvneypduzjjbfuhocrdducezxnhdiywjgiradpayfrdbsbpg\"`"
                    },
                    {
                        "username": "sarthak95r",
                        "content": "\\nI spent like 2 hours on this one, read discuss section for some hint.\\nThen it became an easy problem( if you know the trick).\\nOtherwise it is very tough to come up in an interview situation \\n\\nBasically the number of insertion is equal to len(str) -len(longest palindromic subsequence)"
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "without hint this is hard ...with hint this is easy\\n"
                    },
                    {
                        "username": "jihweiliang",
                        "content": "This is easy if you are familiar with LCS. "
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "First time i my life i just give it a try  , run my own solution ,and it passed in one go \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "tin1254",
                        "content": "Once you see the hint then it becomes a medium problem."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Eid Mubarak from Bangladesh"
                    },
                    {
                        "username": "ankitsumitsharma80",
                        "content": "This doesn\\'t looks to be hard, Leet code is marking medium as hard "
                    },
                    {
                        "username": "arumuga007",
                        "content": "where is \\'e\\' in \"leetcode\" in 3rd example"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "leetcodo(1)c(2)t(3)e(4)`e`l(5)"
                    },
                    {
                        "username": "kausachan",
                        "content": "After learning DP my thought process reduced, before knowing DP my brain would have spent hours thinking on how to optimize this, in that time new approaches will click. But now after seeing the question brain realizes that its a DP problem, without any big thinking just proceeds to memoize :-("
                    }
                ]
            },
            {
                "id": 1871046,
                "content": [
                    {
                        "username": "dvakar",
                        "content": "1.  `\"e\"`\\n2.  `\"le\"`\\n3.  `\"gpbsbdrfyapdarigjwyidhnxzecuddrcohufbjjzudpyenvnypqkcyvpydnvtijalwfmzbsvqhalvlurdabfmjddjmfbadrulvlahqvsbzmfwlajitvndypvyckqpynvneypduzjjbfuhocrdducezxnhdiywjgiradpayfrdbsbpg\"`"
                    },
                    {
                        "username": "sarthak95r",
                        "content": "\\nI spent like 2 hours on this one, read discuss section for some hint.\\nThen it became an easy problem( if you know the trick).\\nOtherwise it is very tough to come up in an interview situation \\n\\nBasically the number of insertion is equal to len(str) -len(longest palindromic subsequence)"
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "without hint this is hard ...with hint this is easy\\n"
                    },
                    {
                        "username": "jihweiliang",
                        "content": "This is easy if you are familiar with LCS. "
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "First time i my life i just give it a try  , run my own solution ,and it passed in one go \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "tin1254",
                        "content": "Once you see the hint then it becomes a medium problem."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Eid Mubarak from Bangladesh"
                    },
                    {
                        "username": "ankitsumitsharma80",
                        "content": "This doesn\\'t looks to be hard, Leet code is marking medium as hard "
                    },
                    {
                        "username": "arumuga007",
                        "content": "where is \\'e\\' in \"leetcode\" in 3rd example"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "leetcodo(1)c(2)t(3)e(4)`e`l(5)"
                    },
                    {
                        "username": "kausachan",
                        "content": "After learning DP my thought process reduced, before knowing DP my brain would have spent hours thinking on how to optimize this, in that time new approaches will click. But now after seeing the question brain realizes that its a DP problem, without any big thinking just proceeds to memoize :-("
                    }
                ]
            },
            {
                "id": 1871028,
                "content": [
                    {
                        "username": "dvakar",
                        "content": "1.  `\"e\"`\\n2.  `\"le\"`\\n3.  `\"gpbsbdrfyapdarigjwyidhnxzecuddrcohufbjjzudpyenvnypqkcyvpydnvtijalwfmzbsvqhalvlurdabfmjddjmfbadrulvlahqvsbzmfwlajitvndypvyckqpynvneypduzjjbfuhocrdducezxnhdiywjgiradpayfrdbsbpg\"`"
                    },
                    {
                        "username": "sarthak95r",
                        "content": "\\nI spent like 2 hours on this one, read discuss section for some hint.\\nThen it became an easy problem( if you know the trick).\\nOtherwise it is very tough to come up in an interview situation \\n\\nBasically the number of insertion is equal to len(str) -len(longest palindromic subsequence)"
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "without hint this is hard ...with hint this is easy\\n"
                    },
                    {
                        "username": "jihweiliang",
                        "content": "This is easy if you are familiar with LCS. "
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "First time i my life i just give it a try  , run my own solution ,and it passed in one go \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "tin1254",
                        "content": "Once you see the hint then it becomes a medium problem."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Eid Mubarak from Bangladesh"
                    },
                    {
                        "username": "ankitsumitsharma80",
                        "content": "This doesn\\'t looks to be hard, Leet code is marking medium as hard "
                    },
                    {
                        "username": "arumuga007",
                        "content": "where is \\'e\\' in \"leetcode\" in 3rd example"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "leetcodo(1)c(2)t(3)e(4)`e`l(5)"
                    },
                    {
                        "username": "kausachan",
                        "content": "After learning DP my thought process reduced, before knowing DP my brain would have spent hours thinking on how to optimize this, in that time new approaches will click. But now after seeing the question brain realizes that its a DP problem, without any big thinking just proceeds to memoize :-("
                    }
                ]
            },
            {
                "id": 1870985,
                "content": [
                    {
                        "username": "dvakar",
                        "content": "1.  `\"e\"`\\n2.  `\"le\"`\\n3.  `\"gpbsbdrfyapdarigjwyidhnxzecuddrcohufbjjzudpyenvnypqkcyvpydnvtijalwfmzbsvqhalvlurdabfmjddjmfbadrulvlahqvsbzmfwlajitvndypvyckqpynvneypduzjjbfuhocrdducezxnhdiywjgiradpayfrdbsbpg\"`"
                    },
                    {
                        "username": "sarthak95r",
                        "content": "\\nI spent like 2 hours on this one, read discuss section for some hint.\\nThen it became an easy problem( if you know the trick).\\nOtherwise it is very tough to come up in an interview situation \\n\\nBasically the number of insertion is equal to len(str) -len(longest palindromic subsequence)"
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "without hint this is hard ...with hint this is easy\\n"
                    },
                    {
                        "username": "jihweiliang",
                        "content": "This is easy if you are familiar with LCS. "
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "First time i my life i just give it a try  , run my own solution ,and it passed in one go \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "tin1254",
                        "content": "Once you see the hint then it becomes a medium problem."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Eid Mubarak from Bangladesh"
                    },
                    {
                        "username": "ankitsumitsharma80",
                        "content": "This doesn\\'t looks to be hard, Leet code is marking medium as hard "
                    },
                    {
                        "username": "arumuga007",
                        "content": "where is \\'e\\' in \"leetcode\" in 3rd example"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "leetcodo(1)c(2)t(3)e(4)`e`l(5)"
                    },
                    {
                        "username": "kausachan",
                        "content": "After learning DP my thought process reduced, before knowing DP my brain would have spent hours thinking on how to optimize this, in that time new approaches will click. But now after seeing the question brain realizes that its a DP problem, without any big thinking just proceeds to memoize :-("
                    }
                ]
            },
            {
                "id": 1870913,
                "content": [
                    {
                        "username": "dvakar",
                        "content": "1.  `\"e\"`\\n2.  `\"le\"`\\n3.  `\"gpbsbdrfyapdarigjwyidhnxzecuddrcohufbjjzudpyenvnypqkcyvpydnvtijalwfmzbsvqhalvlurdabfmjddjmfbadrulvlahqvsbzmfwlajitvndypvyckqpynvneypduzjjbfuhocrdducezxnhdiywjgiradpayfrdbsbpg\"`"
                    },
                    {
                        "username": "sarthak95r",
                        "content": "\\nI spent like 2 hours on this one, read discuss section for some hint.\\nThen it became an easy problem( if you know the trick).\\nOtherwise it is very tough to come up in an interview situation \\n\\nBasically the number of insertion is equal to len(str) -len(longest palindromic subsequence)"
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "without hint this is hard ...with hint this is easy\\n"
                    },
                    {
                        "username": "jihweiliang",
                        "content": "This is easy if you are familiar with LCS. "
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "First time i my life i just give it a try  , run my own solution ,and it passed in one go \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "tin1254",
                        "content": "Once you see the hint then it becomes a medium problem."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Eid Mubarak from Bangladesh"
                    },
                    {
                        "username": "ankitsumitsharma80",
                        "content": "This doesn\\'t looks to be hard, Leet code is marking medium as hard "
                    },
                    {
                        "username": "arumuga007",
                        "content": "where is \\'e\\' in \"leetcode\" in 3rd example"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "leetcodo(1)c(2)t(3)e(4)`e`l(5)"
                    },
                    {
                        "username": "kausachan",
                        "content": "After learning DP my thought process reduced, before knowing DP my brain would have spent hours thinking on how to optimize this, in that time new approaches will click. But now after seeing the question brain realizes that its a DP problem, without any big thinking just proceeds to memoize :-("
                    }
                ]
            },
            {
                "id": 1870825,
                "content": [
                    {
                        "username": "dvakar",
                        "content": "1.  `\"e\"`\\n2.  `\"le\"`\\n3.  `\"gpbsbdrfyapdarigjwyidhnxzecuddrcohufbjjzudpyenvnypqkcyvpydnvtijalwfmzbsvqhalvlurdabfmjddjmfbadrulvlahqvsbzmfwlajitvndypvyckqpynvneypduzjjbfuhocrdducezxnhdiywjgiradpayfrdbsbpg\"`"
                    },
                    {
                        "username": "sarthak95r",
                        "content": "\\nI spent like 2 hours on this one, read discuss section for some hint.\\nThen it became an easy problem( if you know the trick).\\nOtherwise it is very tough to come up in an interview situation \\n\\nBasically the number of insertion is equal to len(str) -len(longest palindromic subsequence)"
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "without hint this is hard ...with hint this is easy\\n"
                    },
                    {
                        "username": "jihweiliang",
                        "content": "This is easy if you are familiar with LCS. "
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "First time i my life i just give it a try  , run my own solution ,and it passed in one go \\uD83D\\uDE0A\\uD83D\\uDE0A"
                    },
                    {
                        "username": "tin1254",
                        "content": "Once you see the hint then it becomes a medium problem."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Eid Mubarak from Bangladesh"
                    },
                    {
                        "username": "ankitsumitsharma80",
                        "content": "This doesn\\'t looks to be hard, Leet code is marking medium as hard "
                    },
                    {
                        "username": "arumuga007",
                        "content": "where is \\'e\\' in \"leetcode\" in 3rd example"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "leetcodo(1)c(2)t(3)e(4)`e`l(5)"
                    },
                    {
                        "username": "kausachan",
                        "content": "After learning DP my thought process reduced, before knowing DP my brain would have spent hours thinking on how to optimize this, in that time new approaches will click. But now after seeing the question brain realizes that its a DP problem, without any big thinking just proceeds to memoize :-("
                    }
                ]
            },
            {
                "id": 1870807,
                "content": [
                    {
                        "username": "ankitJava",
                        "content": "LCS made my life easier"
                    },
                    {
                        "username": "user8419tm",
                        "content": "Can anyone explain me third example. Answer should be leetcodedocteel   ??"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "leetcode => leetcod`octe`e`l` => 5"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Cannot solve? Solve the next Medium problems first:\\n- [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)\\n- [516. Longest Palindromic Subsequence\\n](https://leetcode.com/problems/longest-palindromic-subsequence/)"
                    },
                    {
                        "username": "Sagarchauhan_88",
                        "content": "//why it is not working for all the testcase? Anyone??\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int count = 0;\\n        int left = 0 , right = s.size()-1;\\n\\n        while(left <= right){\\n            if(s[left] == s[right]){\\n                left++;\\n                right--;\\n            }\\n            else{\\n                if(left == right){\\n                    count++;\\n                    break;\\n                }\\n                if(s[left + 1] == s[right]){\\n                    count++;\\n                    left++;\\n                }\\n                else if(s[left] == s[right-1]){ \\n                    count++;\\n                    right--;\\n\\n                }\\n                else{\\n                    left++;\\n                    right--;\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "kausachan",
                        "content": "cool! code you have written follows greedy approach. But here you have to try all possible way of inserting a character to make the string palindrome. Let's take this example case \ns = \"mbadm\"\nas per you code, \nl = 0\nr = 4\nafter first iteration, \"mbadm\"\nl = 1\nr = 3\ncount = 0\n\nafter second iteration, \"bad\"\nl = 2\nr = 2\ncount  = 1\n\nafter third iteration, \"a\"\nl = 3\nr = 1\ncount = 1\n\nresult - 1 (count)\n\nObserve the mistake in second iteration, you're code flow goes to the nested else part where i++ and j-- and count++ happens, which doesn't make sense because it is impossible to make \"bad\" a palindrome by adding 1 letter to it. to make \"bad\" palindrome what you can do is (one possible way is listed here)\nadd \"b\" at end:\nbadb -> since same letters exists in start and end ignore it -> ad\nnow add \"a\" at end\nada ->  since same letters exists in start and end ignore it -> d\n\n\"mbadm\" has been transformed to \"mbadabm\" with 2 additions\n\nso we made minimum of 2 additions to make it a palindrome\n\nPlease reply here in case of doubts"
                    },
                    {
                        "username": "sahilkadian400",
                        "content": "it gives TLE can anyone help me why it gives TLE because when the test case run manually it runs without any error.\\n\\nint solve2Mem(string s,int st,int en,vector<vector<int>>& dp){\\n        if(st>=en){\\n            return 0;\\n        }\\n        if(dp[st][en] != -1) return dp[st][en];\\n        if(s[st]==s[en]){\\n            return dp[st][en] = solve2Mem(s,st+1,en-1,dp);\\n        }\\n        return dp[st][en] = 1+min(solve2Mem(s,st,en-1,dp),solve2Mem(s,st+1,en,dp));\\n    }"
                    },
                    {
                        "username": "beardedone",
                        "content": "Every time you call solve2Mem(), a copy of the string (s) is created.  The copy turns your O(n^2) solution into an O(n^3) solution.  Your code is not mutating the string; try passing it by const reference instead of by value:\n\nint solve2Mem(const std::string& s ...."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Thank daily challenge editors for making me use my brain more and grow my neuron connections."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Why this solution giving TLE as it taking same time compared to lcs?\n\nclass Solution {\npublic:\n    int helper(int left, int right, string s, vector<vector<int>>&dp){\n        if(left >= right)return 0;\n        if(dp[left][right] != -1)return dp[left][right];\n        if(s[left] == s[right]){\n            return dp[left][right] = helper(left+1, right-1, s, dp);\n        }else{\n            return dp[left][right] = 1+ min(helper(left+1,right,s, dp), helper(left, right-1, s, dp));\n        }\n    }\n    int minInsertions(string s) {\n        vector<vector<int>>dp(s.size()+1,vector<int>(s.size()+1,-1));\n        return helper(0,s.size()-1,s,dp);\n    }\n};\n"
                    },
                    {
                        "username": "beardedone",
                        "content": "It might be because every call to helper() is copying the string.  Try passing the string in as a const reference instead."
                    },
                    {
                        "username": "artinegi1607",
                        "content": "I am not getting the question. example: As per the question, for string \"mbadm\" output is =2.\\nBut i think if change only 1 char in string that it would be a palindrome eg: mbabm or mdadm.\\nCan you anyone explains this to me? "
                    },
                    {
                        "username": "harshsinghrajput",
                        "content": "[@AlcalinoGitHub](/AlcalinoGitHub) Then why in the third example last e of leetcode is changed to o"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "The question asks about the minimum number of insertions. You can add any characters you want, but you cannot change the ones that are already in the string"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "if u solved last week\\'s 516.longest palindromic subsequence\\nthen solution for this is literally adding a single more line to the code"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I remind another problem several days ago, very similar to today\\'s one but more difficult?"
                    }
                ]
            },
            {
                "id": 1870802,
                "content": [
                    {
                        "username": "ankitJava",
                        "content": "LCS made my life easier"
                    },
                    {
                        "username": "user8419tm",
                        "content": "Can anyone explain me third example. Answer should be leetcodedocteel   ??"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "leetcode => leetcod`octe`e`l` => 5"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Cannot solve? Solve the next Medium problems first:\\n- [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)\\n- [516. Longest Palindromic Subsequence\\n](https://leetcode.com/problems/longest-palindromic-subsequence/)"
                    },
                    {
                        "username": "Sagarchauhan_88",
                        "content": "//why it is not working for all the testcase? Anyone??\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int count = 0;\\n        int left = 0 , right = s.size()-1;\\n\\n        while(left <= right){\\n            if(s[left] == s[right]){\\n                left++;\\n                right--;\\n            }\\n            else{\\n                if(left == right){\\n                    count++;\\n                    break;\\n                }\\n                if(s[left + 1] == s[right]){\\n                    count++;\\n                    left++;\\n                }\\n                else if(s[left] == s[right-1]){ \\n                    count++;\\n                    right--;\\n\\n                }\\n                else{\\n                    left++;\\n                    right--;\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "kausachan",
                        "content": "cool! code you have written follows greedy approach. But here you have to try all possible way of inserting a character to make the string palindrome. Let's take this example case \ns = \"mbadm\"\nas per you code, \nl = 0\nr = 4\nafter first iteration, \"mbadm\"\nl = 1\nr = 3\ncount = 0\n\nafter second iteration, \"bad\"\nl = 2\nr = 2\ncount  = 1\n\nafter third iteration, \"a\"\nl = 3\nr = 1\ncount = 1\n\nresult - 1 (count)\n\nObserve the mistake in second iteration, you're code flow goes to the nested else part where i++ and j-- and count++ happens, which doesn't make sense because it is impossible to make \"bad\" a palindrome by adding 1 letter to it. to make \"bad\" palindrome what you can do is (one possible way is listed here)\nadd \"b\" at end:\nbadb -> since same letters exists in start and end ignore it -> ad\nnow add \"a\" at end\nada ->  since same letters exists in start and end ignore it -> d\n\n\"mbadm\" has been transformed to \"mbadabm\" with 2 additions\n\nso we made minimum of 2 additions to make it a palindrome\n\nPlease reply here in case of doubts"
                    },
                    {
                        "username": "sahilkadian400",
                        "content": "it gives TLE can anyone help me why it gives TLE because when the test case run manually it runs without any error.\\n\\nint solve2Mem(string s,int st,int en,vector<vector<int>>& dp){\\n        if(st>=en){\\n            return 0;\\n        }\\n        if(dp[st][en] != -1) return dp[st][en];\\n        if(s[st]==s[en]){\\n            return dp[st][en] = solve2Mem(s,st+1,en-1,dp);\\n        }\\n        return dp[st][en] = 1+min(solve2Mem(s,st,en-1,dp),solve2Mem(s,st+1,en,dp));\\n    }"
                    },
                    {
                        "username": "beardedone",
                        "content": "Every time you call solve2Mem(), a copy of the string (s) is created.  The copy turns your O(n^2) solution into an O(n^3) solution.  Your code is not mutating the string; try passing it by const reference instead of by value:\n\nint solve2Mem(const std::string& s ...."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Thank daily challenge editors for making me use my brain more and grow my neuron connections."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Why this solution giving TLE as it taking same time compared to lcs?\n\nclass Solution {\npublic:\n    int helper(int left, int right, string s, vector<vector<int>>&dp){\n        if(left >= right)return 0;\n        if(dp[left][right] != -1)return dp[left][right];\n        if(s[left] == s[right]){\n            return dp[left][right] = helper(left+1, right-1, s, dp);\n        }else{\n            return dp[left][right] = 1+ min(helper(left+1,right,s, dp), helper(left, right-1, s, dp));\n        }\n    }\n    int minInsertions(string s) {\n        vector<vector<int>>dp(s.size()+1,vector<int>(s.size()+1,-1));\n        return helper(0,s.size()-1,s,dp);\n    }\n};\n"
                    },
                    {
                        "username": "beardedone",
                        "content": "It might be because every call to helper() is copying the string.  Try passing the string in as a const reference instead."
                    },
                    {
                        "username": "artinegi1607",
                        "content": "I am not getting the question. example: As per the question, for string \"mbadm\" output is =2.\\nBut i think if change only 1 char in string that it would be a palindrome eg: mbabm or mdadm.\\nCan you anyone explains this to me? "
                    },
                    {
                        "username": "harshsinghrajput",
                        "content": "[@AlcalinoGitHub](/AlcalinoGitHub) Then why in the third example last e of leetcode is changed to o"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "The question asks about the minimum number of insertions. You can add any characters you want, but you cannot change the ones that are already in the string"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "if u solved last week\\'s 516.longest palindromic subsequence\\nthen solution for this is literally adding a single more line to the code"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I remind another problem several days ago, very similar to today\\'s one but more difficult?"
                    }
                ]
            },
            {
                "id": 1870710,
                "content": [
                    {
                        "username": "ankitJava",
                        "content": "LCS made my life easier"
                    },
                    {
                        "username": "user8419tm",
                        "content": "Can anyone explain me third example. Answer should be leetcodedocteel   ??"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "leetcode => leetcod`octe`e`l` => 5"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Cannot solve? Solve the next Medium problems first:\\n- [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)\\n- [516. Longest Palindromic Subsequence\\n](https://leetcode.com/problems/longest-palindromic-subsequence/)"
                    },
                    {
                        "username": "Sagarchauhan_88",
                        "content": "//why it is not working for all the testcase? Anyone??\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int count = 0;\\n        int left = 0 , right = s.size()-1;\\n\\n        while(left <= right){\\n            if(s[left] == s[right]){\\n                left++;\\n                right--;\\n            }\\n            else{\\n                if(left == right){\\n                    count++;\\n                    break;\\n                }\\n                if(s[left + 1] == s[right]){\\n                    count++;\\n                    left++;\\n                }\\n                else if(s[left] == s[right-1]){ \\n                    count++;\\n                    right--;\\n\\n                }\\n                else{\\n                    left++;\\n                    right--;\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "kausachan",
                        "content": "cool! code you have written follows greedy approach. But here you have to try all possible way of inserting a character to make the string palindrome. Let's take this example case \ns = \"mbadm\"\nas per you code, \nl = 0\nr = 4\nafter first iteration, \"mbadm\"\nl = 1\nr = 3\ncount = 0\n\nafter second iteration, \"bad\"\nl = 2\nr = 2\ncount  = 1\n\nafter third iteration, \"a\"\nl = 3\nr = 1\ncount = 1\n\nresult - 1 (count)\n\nObserve the mistake in second iteration, you're code flow goes to the nested else part where i++ and j-- and count++ happens, which doesn't make sense because it is impossible to make \"bad\" a palindrome by adding 1 letter to it. to make \"bad\" palindrome what you can do is (one possible way is listed here)\nadd \"b\" at end:\nbadb -> since same letters exists in start and end ignore it -> ad\nnow add \"a\" at end\nada ->  since same letters exists in start and end ignore it -> d\n\n\"mbadm\" has been transformed to \"mbadabm\" with 2 additions\n\nso we made minimum of 2 additions to make it a palindrome\n\nPlease reply here in case of doubts"
                    },
                    {
                        "username": "sahilkadian400",
                        "content": "it gives TLE can anyone help me why it gives TLE because when the test case run manually it runs without any error.\\n\\nint solve2Mem(string s,int st,int en,vector<vector<int>>& dp){\\n        if(st>=en){\\n            return 0;\\n        }\\n        if(dp[st][en] != -1) return dp[st][en];\\n        if(s[st]==s[en]){\\n            return dp[st][en] = solve2Mem(s,st+1,en-1,dp);\\n        }\\n        return dp[st][en] = 1+min(solve2Mem(s,st,en-1,dp),solve2Mem(s,st+1,en,dp));\\n    }"
                    },
                    {
                        "username": "beardedone",
                        "content": "Every time you call solve2Mem(), a copy of the string (s) is created.  The copy turns your O(n^2) solution into an O(n^3) solution.  Your code is not mutating the string; try passing it by const reference instead of by value:\n\nint solve2Mem(const std::string& s ...."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Thank daily challenge editors for making me use my brain more and grow my neuron connections."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Why this solution giving TLE as it taking same time compared to lcs?\n\nclass Solution {\npublic:\n    int helper(int left, int right, string s, vector<vector<int>>&dp){\n        if(left >= right)return 0;\n        if(dp[left][right] != -1)return dp[left][right];\n        if(s[left] == s[right]){\n            return dp[left][right] = helper(left+1, right-1, s, dp);\n        }else{\n            return dp[left][right] = 1+ min(helper(left+1,right,s, dp), helper(left, right-1, s, dp));\n        }\n    }\n    int minInsertions(string s) {\n        vector<vector<int>>dp(s.size()+1,vector<int>(s.size()+1,-1));\n        return helper(0,s.size()-1,s,dp);\n    }\n};\n"
                    },
                    {
                        "username": "beardedone",
                        "content": "It might be because every call to helper() is copying the string.  Try passing the string in as a const reference instead."
                    },
                    {
                        "username": "artinegi1607",
                        "content": "I am not getting the question. example: As per the question, for string \"mbadm\" output is =2.\\nBut i think if change only 1 char in string that it would be a palindrome eg: mbabm or mdadm.\\nCan you anyone explains this to me? "
                    },
                    {
                        "username": "harshsinghrajput",
                        "content": "[@AlcalinoGitHub](/AlcalinoGitHub) Then why in the third example last e of leetcode is changed to o"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "The question asks about the minimum number of insertions. You can add any characters you want, but you cannot change the ones that are already in the string"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "if u solved last week\\'s 516.longest palindromic subsequence\\nthen solution for this is literally adding a single more line to the code"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I remind another problem several days ago, very similar to today\\'s one but more difficult?"
                    }
                ]
            },
            {
                "id": 1870707,
                "content": [
                    {
                        "username": "ankitJava",
                        "content": "LCS made my life easier"
                    },
                    {
                        "username": "user8419tm",
                        "content": "Can anyone explain me third example. Answer should be leetcodedocteel   ??"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "leetcode => leetcod`octe`e`l` => 5"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Cannot solve? Solve the next Medium problems first:\\n- [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)\\n- [516. Longest Palindromic Subsequence\\n](https://leetcode.com/problems/longest-palindromic-subsequence/)"
                    },
                    {
                        "username": "Sagarchauhan_88",
                        "content": "//why it is not working for all the testcase? Anyone??\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int count = 0;\\n        int left = 0 , right = s.size()-1;\\n\\n        while(left <= right){\\n            if(s[left] == s[right]){\\n                left++;\\n                right--;\\n            }\\n            else{\\n                if(left == right){\\n                    count++;\\n                    break;\\n                }\\n                if(s[left + 1] == s[right]){\\n                    count++;\\n                    left++;\\n                }\\n                else if(s[left] == s[right-1]){ \\n                    count++;\\n                    right--;\\n\\n                }\\n                else{\\n                    left++;\\n                    right--;\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "kausachan",
                        "content": "cool! code you have written follows greedy approach. But here you have to try all possible way of inserting a character to make the string palindrome. Let's take this example case \ns = \"mbadm\"\nas per you code, \nl = 0\nr = 4\nafter first iteration, \"mbadm\"\nl = 1\nr = 3\ncount = 0\n\nafter second iteration, \"bad\"\nl = 2\nr = 2\ncount  = 1\n\nafter third iteration, \"a\"\nl = 3\nr = 1\ncount = 1\n\nresult - 1 (count)\n\nObserve the mistake in second iteration, you're code flow goes to the nested else part where i++ and j-- and count++ happens, which doesn't make sense because it is impossible to make \"bad\" a palindrome by adding 1 letter to it. to make \"bad\" palindrome what you can do is (one possible way is listed here)\nadd \"b\" at end:\nbadb -> since same letters exists in start and end ignore it -> ad\nnow add \"a\" at end\nada ->  since same letters exists in start and end ignore it -> d\n\n\"mbadm\" has been transformed to \"mbadabm\" with 2 additions\n\nso we made minimum of 2 additions to make it a palindrome\n\nPlease reply here in case of doubts"
                    },
                    {
                        "username": "sahilkadian400",
                        "content": "it gives TLE can anyone help me why it gives TLE because when the test case run manually it runs without any error.\\n\\nint solve2Mem(string s,int st,int en,vector<vector<int>>& dp){\\n        if(st>=en){\\n            return 0;\\n        }\\n        if(dp[st][en] != -1) return dp[st][en];\\n        if(s[st]==s[en]){\\n            return dp[st][en] = solve2Mem(s,st+1,en-1,dp);\\n        }\\n        return dp[st][en] = 1+min(solve2Mem(s,st,en-1,dp),solve2Mem(s,st+1,en,dp));\\n    }"
                    },
                    {
                        "username": "beardedone",
                        "content": "Every time you call solve2Mem(), a copy of the string (s) is created.  The copy turns your O(n^2) solution into an O(n^3) solution.  Your code is not mutating the string; try passing it by const reference instead of by value:\n\nint solve2Mem(const std::string& s ...."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Thank daily challenge editors for making me use my brain more and grow my neuron connections."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Why this solution giving TLE as it taking same time compared to lcs?\n\nclass Solution {\npublic:\n    int helper(int left, int right, string s, vector<vector<int>>&dp){\n        if(left >= right)return 0;\n        if(dp[left][right] != -1)return dp[left][right];\n        if(s[left] == s[right]){\n            return dp[left][right] = helper(left+1, right-1, s, dp);\n        }else{\n            return dp[left][right] = 1+ min(helper(left+1,right,s, dp), helper(left, right-1, s, dp));\n        }\n    }\n    int minInsertions(string s) {\n        vector<vector<int>>dp(s.size()+1,vector<int>(s.size()+1,-1));\n        return helper(0,s.size()-1,s,dp);\n    }\n};\n"
                    },
                    {
                        "username": "beardedone",
                        "content": "It might be because every call to helper() is copying the string.  Try passing the string in as a const reference instead."
                    },
                    {
                        "username": "artinegi1607",
                        "content": "I am not getting the question. example: As per the question, for string \"mbadm\" output is =2.\\nBut i think if change only 1 char in string that it would be a palindrome eg: mbabm or mdadm.\\nCan you anyone explains this to me? "
                    },
                    {
                        "username": "harshsinghrajput",
                        "content": "[@AlcalinoGitHub](/AlcalinoGitHub) Then why in the third example last e of leetcode is changed to o"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "The question asks about the minimum number of insertions. You can add any characters you want, but you cannot change the ones that are already in the string"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "if u solved last week\\'s 516.longest palindromic subsequence\\nthen solution for this is literally adding a single more line to the code"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I remind another problem several days ago, very similar to today\\'s one but more difficult?"
                    }
                ]
            },
            {
                "id": 1870706,
                "content": [
                    {
                        "username": "ankitJava",
                        "content": "LCS made my life easier"
                    },
                    {
                        "username": "user8419tm",
                        "content": "Can anyone explain me third example. Answer should be leetcodedocteel   ??"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "leetcode => leetcod`octe`e`l` => 5"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Cannot solve? Solve the next Medium problems first:\\n- [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)\\n- [516. Longest Palindromic Subsequence\\n](https://leetcode.com/problems/longest-palindromic-subsequence/)"
                    },
                    {
                        "username": "Sagarchauhan_88",
                        "content": "//why it is not working for all the testcase? Anyone??\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int count = 0;\\n        int left = 0 , right = s.size()-1;\\n\\n        while(left <= right){\\n            if(s[left] == s[right]){\\n                left++;\\n                right--;\\n            }\\n            else{\\n                if(left == right){\\n                    count++;\\n                    break;\\n                }\\n                if(s[left + 1] == s[right]){\\n                    count++;\\n                    left++;\\n                }\\n                else if(s[left] == s[right-1]){ \\n                    count++;\\n                    right--;\\n\\n                }\\n                else{\\n                    left++;\\n                    right--;\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "kausachan",
                        "content": "cool! code you have written follows greedy approach. But here you have to try all possible way of inserting a character to make the string palindrome. Let's take this example case \ns = \"mbadm\"\nas per you code, \nl = 0\nr = 4\nafter first iteration, \"mbadm\"\nl = 1\nr = 3\ncount = 0\n\nafter second iteration, \"bad\"\nl = 2\nr = 2\ncount  = 1\n\nafter third iteration, \"a\"\nl = 3\nr = 1\ncount = 1\n\nresult - 1 (count)\n\nObserve the mistake in second iteration, you're code flow goes to the nested else part where i++ and j-- and count++ happens, which doesn't make sense because it is impossible to make \"bad\" a palindrome by adding 1 letter to it. to make \"bad\" palindrome what you can do is (one possible way is listed here)\nadd \"b\" at end:\nbadb -> since same letters exists in start and end ignore it -> ad\nnow add \"a\" at end\nada ->  since same letters exists in start and end ignore it -> d\n\n\"mbadm\" has been transformed to \"mbadabm\" with 2 additions\n\nso we made minimum of 2 additions to make it a palindrome\n\nPlease reply here in case of doubts"
                    },
                    {
                        "username": "sahilkadian400",
                        "content": "it gives TLE can anyone help me why it gives TLE because when the test case run manually it runs without any error.\\n\\nint solve2Mem(string s,int st,int en,vector<vector<int>>& dp){\\n        if(st>=en){\\n            return 0;\\n        }\\n        if(dp[st][en] != -1) return dp[st][en];\\n        if(s[st]==s[en]){\\n            return dp[st][en] = solve2Mem(s,st+1,en-1,dp);\\n        }\\n        return dp[st][en] = 1+min(solve2Mem(s,st,en-1,dp),solve2Mem(s,st+1,en,dp));\\n    }"
                    },
                    {
                        "username": "beardedone",
                        "content": "Every time you call solve2Mem(), a copy of the string (s) is created.  The copy turns your O(n^2) solution into an O(n^3) solution.  Your code is not mutating the string; try passing it by const reference instead of by value:\n\nint solve2Mem(const std::string& s ...."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Thank daily challenge editors for making me use my brain more and grow my neuron connections."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Why this solution giving TLE as it taking same time compared to lcs?\n\nclass Solution {\npublic:\n    int helper(int left, int right, string s, vector<vector<int>>&dp){\n        if(left >= right)return 0;\n        if(dp[left][right] != -1)return dp[left][right];\n        if(s[left] == s[right]){\n            return dp[left][right] = helper(left+1, right-1, s, dp);\n        }else{\n            return dp[left][right] = 1+ min(helper(left+1,right,s, dp), helper(left, right-1, s, dp));\n        }\n    }\n    int minInsertions(string s) {\n        vector<vector<int>>dp(s.size()+1,vector<int>(s.size()+1,-1));\n        return helper(0,s.size()-1,s,dp);\n    }\n};\n"
                    },
                    {
                        "username": "beardedone",
                        "content": "It might be because every call to helper() is copying the string.  Try passing the string in as a const reference instead."
                    },
                    {
                        "username": "artinegi1607",
                        "content": "I am not getting the question. example: As per the question, for string \"mbadm\" output is =2.\\nBut i think if change only 1 char in string that it would be a palindrome eg: mbabm or mdadm.\\nCan you anyone explains this to me? "
                    },
                    {
                        "username": "harshsinghrajput",
                        "content": "[@AlcalinoGitHub](/AlcalinoGitHub) Then why in the third example last e of leetcode is changed to o"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "The question asks about the minimum number of insertions. You can add any characters you want, but you cannot change the ones that are already in the string"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "if u solved last week\\'s 516.longest palindromic subsequence\\nthen solution for this is literally adding a single more line to the code"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I remind another problem several days ago, very similar to today\\'s one but more difficult?"
                    }
                ]
            },
            {
                "id": 1870661,
                "content": [
                    {
                        "username": "ankitJava",
                        "content": "LCS made my life easier"
                    },
                    {
                        "username": "user8419tm",
                        "content": "Can anyone explain me third example. Answer should be leetcodedocteel   ??"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "leetcode => leetcod`octe`e`l` => 5"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Cannot solve? Solve the next Medium problems first:\\n- [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)\\n- [516. Longest Palindromic Subsequence\\n](https://leetcode.com/problems/longest-palindromic-subsequence/)"
                    },
                    {
                        "username": "Sagarchauhan_88",
                        "content": "//why it is not working for all the testcase? Anyone??\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int count = 0;\\n        int left = 0 , right = s.size()-1;\\n\\n        while(left <= right){\\n            if(s[left] == s[right]){\\n                left++;\\n                right--;\\n            }\\n            else{\\n                if(left == right){\\n                    count++;\\n                    break;\\n                }\\n                if(s[left + 1] == s[right]){\\n                    count++;\\n                    left++;\\n                }\\n                else if(s[left] == s[right-1]){ \\n                    count++;\\n                    right--;\\n\\n                }\\n                else{\\n                    left++;\\n                    right--;\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "kausachan",
                        "content": "cool! code you have written follows greedy approach. But here you have to try all possible way of inserting a character to make the string palindrome. Let's take this example case \ns = \"mbadm\"\nas per you code, \nl = 0\nr = 4\nafter first iteration, \"mbadm\"\nl = 1\nr = 3\ncount = 0\n\nafter second iteration, \"bad\"\nl = 2\nr = 2\ncount  = 1\n\nafter third iteration, \"a\"\nl = 3\nr = 1\ncount = 1\n\nresult - 1 (count)\n\nObserve the mistake in second iteration, you're code flow goes to the nested else part where i++ and j-- and count++ happens, which doesn't make sense because it is impossible to make \"bad\" a palindrome by adding 1 letter to it. to make \"bad\" palindrome what you can do is (one possible way is listed here)\nadd \"b\" at end:\nbadb -> since same letters exists in start and end ignore it -> ad\nnow add \"a\" at end\nada ->  since same letters exists in start and end ignore it -> d\n\n\"mbadm\" has been transformed to \"mbadabm\" with 2 additions\n\nso we made minimum of 2 additions to make it a palindrome\n\nPlease reply here in case of doubts"
                    },
                    {
                        "username": "sahilkadian400",
                        "content": "it gives TLE can anyone help me why it gives TLE because when the test case run manually it runs without any error.\\n\\nint solve2Mem(string s,int st,int en,vector<vector<int>>& dp){\\n        if(st>=en){\\n            return 0;\\n        }\\n        if(dp[st][en] != -1) return dp[st][en];\\n        if(s[st]==s[en]){\\n            return dp[st][en] = solve2Mem(s,st+1,en-1,dp);\\n        }\\n        return dp[st][en] = 1+min(solve2Mem(s,st,en-1,dp),solve2Mem(s,st+1,en,dp));\\n    }"
                    },
                    {
                        "username": "beardedone",
                        "content": "Every time you call solve2Mem(), a copy of the string (s) is created.  The copy turns your O(n^2) solution into an O(n^3) solution.  Your code is not mutating the string; try passing it by const reference instead of by value:\n\nint solve2Mem(const std::string& s ...."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Thank daily challenge editors for making me use my brain more and grow my neuron connections."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Why this solution giving TLE as it taking same time compared to lcs?\n\nclass Solution {\npublic:\n    int helper(int left, int right, string s, vector<vector<int>>&dp){\n        if(left >= right)return 0;\n        if(dp[left][right] != -1)return dp[left][right];\n        if(s[left] == s[right]){\n            return dp[left][right] = helper(left+1, right-1, s, dp);\n        }else{\n            return dp[left][right] = 1+ min(helper(left+1,right,s, dp), helper(left, right-1, s, dp));\n        }\n    }\n    int minInsertions(string s) {\n        vector<vector<int>>dp(s.size()+1,vector<int>(s.size()+1,-1));\n        return helper(0,s.size()-1,s,dp);\n    }\n};\n"
                    },
                    {
                        "username": "beardedone",
                        "content": "It might be because every call to helper() is copying the string.  Try passing the string in as a const reference instead."
                    },
                    {
                        "username": "artinegi1607",
                        "content": "I am not getting the question. example: As per the question, for string \"mbadm\" output is =2.\\nBut i think if change only 1 char in string that it would be a palindrome eg: mbabm or mdadm.\\nCan you anyone explains this to me? "
                    },
                    {
                        "username": "harshsinghrajput",
                        "content": "[@AlcalinoGitHub](/AlcalinoGitHub) Then why in the third example last e of leetcode is changed to o"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "The question asks about the minimum number of insertions. You can add any characters you want, but you cannot change the ones that are already in the string"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "if u solved last week\\'s 516.longest palindromic subsequence\\nthen solution for this is literally adding a single more line to the code"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I remind another problem several days ago, very similar to today\\'s one but more difficult?"
                    }
                ]
            },
            {
                "id": 1870622,
                "content": [
                    {
                        "username": "ankitJava",
                        "content": "LCS made my life easier"
                    },
                    {
                        "username": "user8419tm",
                        "content": "Can anyone explain me third example. Answer should be leetcodedocteel   ??"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "leetcode => leetcod`octe`e`l` => 5"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Cannot solve? Solve the next Medium problems first:\\n- [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)\\n- [516. Longest Palindromic Subsequence\\n](https://leetcode.com/problems/longest-palindromic-subsequence/)"
                    },
                    {
                        "username": "Sagarchauhan_88",
                        "content": "//why it is not working for all the testcase? Anyone??\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int count = 0;\\n        int left = 0 , right = s.size()-1;\\n\\n        while(left <= right){\\n            if(s[left] == s[right]){\\n                left++;\\n                right--;\\n            }\\n            else{\\n                if(left == right){\\n                    count++;\\n                    break;\\n                }\\n                if(s[left + 1] == s[right]){\\n                    count++;\\n                    left++;\\n                }\\n                else if(s[left] == s[right-1]){ \\n                    count++;\\n                    right--;\\n\\n                }\\n                else{\\n                    left++;\\n                    right--;\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "kausachan",
                        "content": "cool! code you have written follows greedy approach. But here you have to try all possible way of inserting a character to make the string palindrome. Let's take this example case \ns = \"mbadm\"\nas per you code, \nl = 0\nr = 4\nafter first iteration, \"mbadm\"\nl = 1\nr = 3\ncount = 0\n\nafter second iteration, \"bad\"\nl = 2\nr = 2\ncount  = 1\n\nafter third iteration, \"a\"\nl = 3\nr = 1\ncount = 1\n\nresult - 1 (count)\n\nObserve the mistake in second iteration, you're code flow goes to the nested else part where i++ and j-- and count++ happens, which doesn't make sense because it is impossible to make \"bad\" a palindrome by adding 1 letter to it. to make \"bad\" palindrome what you can do is (one possible way is listed here)\nadd \"b\" at end:\nbadb -> since same letters exists in start and end ignore it -> ad\nnow add \"a\" at end\nada ->  since same letters exists in start and end ignore it -> d\n\n\"mbadm\" has been transformed to \"mbadabm\" with 2 additions\n\nso we made minimum of 2 additions to make it a palindrome\n\nPlease reply here in case of doubts"
                    },
                    {
                        "username": "sahilkadian400",
                        "content": "it gives TLE can anyone help me why it gives TLE because when the test case run manually it runs without any error.\\n\\nint solve2Mem(string s,int st,int en,vector<vector<int>>& dp){\\n        if(st>=en){\\n            return 0;\\n        }\\n        if(dp[st][en] != -1) return dp[st][en];\\n        if(s[st]==s[en]){\\n            return dp[st][en] = solve2Mem(s,st+1,en-1,dp);\\n        }\\n        return dp[st][en] = 1+min(solve2Mem(s,st,en-1,dp),solve2Mem(s,st+1,en,dp));\\n    }"
                    },
                    {
                        "username": "beardedone",
                        "content": "Every time you call solve2Mem(), a copy of the string (s) is created.  The copy turns your O(n^2) solution into an O(n^3) solution.  Your code is not mutating the string; try passing it by const reference instead of by value:\n\nint solve2Mem(const std::string& s ...."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Thank daily challenge editors for making me use my brain more and grow my neuron connections."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Why this solution giving TLE as it taking same time compared to lcs?\n\nclass Solution {\npublic:\n    int helper(int left, int right, string s, vector<vector<int>>&dp){\n        if(left >= right)return 0;\n        if(dp[left][right] != -1)return dp[left][right];\n        if(s[left] == s[right]){\n            return dp[left][right] = helper(left+1, right-1, s, dp);\n        }else{\n            return dp[left][right] = 1+ min(helper(left+1,right,s, dp), helper(left, right-1, s, dp));\n        }\n    }\n    int minInsertions(string s) {\n        vector<vector<int>>dp(s.size()+1,vector<int>(s.size()+1,-1));\n        return helper(0,s.size()-1,s,dp);\n    }\n};\n"
                    },
                    {
                        "username": "beardedone",
                        "content": "It might be because every call to helper() is copying the string.  Try passing the string in as a const reference instead."
                    },
                    {
                        "username": "artinegi1607",
                        "content": "I am not getting the question. example: As per the question, for string \"mbadm\" output is =2.\\nBut i think if change only 1 char in string that it would be a palindrome eg: mbabm or mdadm.\\nCan you anyone explains this to me? "
                    },
                    {
                        "username": "harshsinghrajput",
                        "content": "[@AlcalinoGitHub](/AlcalinoGitHub) Then why in the third example last e of leetcode is changed to o"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "The question asks about the minimum number of insertions. You can add any characters you want, but you cannot change the ones that are already in the string"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "if u solved last week\\'s 516.longest palindromic subsequence\\nthen solution for this is literally adding a single more line to the code"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I remind another problem several days ago, very similar to today\\'s one but more difficult?"
                    }
                ]
            },
            {
                "id": 1870619,
                "content": [
                    {
                        "username": "ankitJava",
                        "content": "LCS made my life easier"
                    },
                    {
                        "username": "user8419tm",
                        "content": "Can anyone explain me third example. Answer should be leetcodedocteel   ??"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "leetcode => leetcod`octe`e`l` => 5"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Cannot solve? Solve the next Medium problems first:\\n- [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)\\n- [516. Longest Palindromic Subsequence\\n](https://leetcode.com/problems/longest-palindromic-subsequence/)"
                    },
                    {
                        "username": "Sagarchauhan_88",
                        "content": "//why it is not working for all the testcase? Anyone??\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int count = 0;\\n        int left = 0 , right = s.size()-1;\\n\\n        while(left <= right){\\n            if(s[left] == s[right]){\\n                left++;\\n                right--;\\n            }\\n            else{\\n                if(left == right){\\n                    count++;\\n                    break;\\n                }\\n                if(s[left + 1] == s[right]){\\n                    count++;\\n                    left++;\\n                }\\n                else if(s[left] == s[right-1]){ \\n                    count++;\\n                    right--;\\n\\n                }\\n                else{\\n                    left++;\\n                    right--;\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "kausachan",
                        "content": "cool! code you have written follows greedy approach. But here you have to try all possible way of inserting a character to make the string palindrome. Let's take this example case \ns = \"mbadm\"\nas per you code, \nl = 0\nr = 4\nafter first iteration, \"mbadm\"\nl = 1\nr = 3\ncount = 0\n\nafter second iteration, \"bad\"\nl = 2\nr = 2\ncount  = 1\n\nafter third iteration, \"a\"\nl = 3\nr = 1\ncount = 1\n\nresult - 1 (count)\n\nObserve the mistake in second iteration, you're code flow goes to the nested else part where i++ and j-- and count++ happens, which doesn't make sense because it is impossible to make \"bad\" a palindrome by adding 1 letter to it. to make \"bad\" palindrome what you can do is (one possible way is listed here)\nadd \"b\" at end:\nbadb -> since same letters exists in start and end ignore it -> ad\nnow add \"a\" at end\nada ->  since same letters exists in start and end ignore it -> d\n\n\"mbadm\" has been transformed to \"mbadabm\" with 2 additions\n\nso we made minimum of 2 additions to make it a palindrome\n\nPlease reply here in case of doubts"
                    },
                    {
                        "username": "sahilkadian400",
                        "content": "it gives TLE can anyone help me why it gives TLE because when the test case run manually it runs without any error.\\n\\nint solve2Mem(string s,int st,int en,vector<vector<int>>& dp){\\n        if(st>=en){\\n            return 0;\\n        }\\n        if(dp[st][en] != -1) return dp[st][en];\\n        if(s[st]==s[en]){\\n            return dp[st][en] = solve2Mem(s,st+1,en-1,dp);\\n        }\\n        return dp[st][en] = 1+min(solve2Mem(s,st,en-1,dp),solve2Mem(s,st+1,en,dp));\\n    }"
                    },
                    {
                        "username": "beardedone",
                        "content": "Every time you call solve2Mem(), a copy of the string (s) is created.  The copy turns your O(n^2) solution into an O(n^3) solution.  Your code is not mutating the string; try passing it by const reference instead of by value:\n\nint solve2Mem(const std::string& s ...."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Thank daily challenge editors for making me use my brain more and grow my neuron connections."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Why this solution giving TLE as it taking same time compared to lcs?\n\nclass Solution {\npublic:\n    int helper(int left, int right, string s, vector<vector<int>>&dp){\n        if(left >= right)return 0;\n        if(dp[left][right] != -1)return dp[left][right];\n        if(s[left] == s[right]){\n            return dp[left][right] = helper(left+1, right-1, s, dp);\n        }else{\n            return dp[left][right] = 1+ min(helper(left+1,right,s, dp), helper(left, right-1, s, dp));\n        }\n    }\n    int minInsertions(string s) {\n        vector<vector<int>>dp(s.size()+1,vector<int>(s.size()+1,-1));\n        return helper(0,s.size()-1,s,dp);\n    }\n};\n"
                    },
                    {
                        "username": "beardedone",
                        "content": "It might be because every call to helper() is copying the string.  Try passing the string in as a const reference instead."
                    },
                    {
                        "username": "artinegi1607",
                        "content": "I am not getting the question. example: As per the question, for string \"mbadm\" output is =2.\\nBut i think if change only 1 char in string that it would be a palindrome eg: mbabm or mdadm.\\nCan you anyone explains this to me? "
                    },
                    {
                        "username": "harshsinghrajput",
                        "content": "[@AlcalinoGitHub](/AlcalinoGitHub) Then why in the third example last e of leetcode is changed to o"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "The question asks about the minimum number of insertions. You can add any characters you want, but you cannot change the ones that are already in the string"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "if u solved last week\\'s 516.longest palindromic subsequence\\nthen solution for this is literally adding a single more line to the code"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I remind another problem several days ago, very similar to today\\'s one but more difficult?"
                    }
                ]
            },
            {
                "id": 1870613,
                "content": [
                    {
                        "username": "ankitJava",
                        "content": "LCS made my life easier"
                    },
                    {
                        "username": "user8419tm",
                        "content": "Can anyone explain me third example. Answer should be leetcodedocteel   ??"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "leetcode => leetcod`octe`e`l` => 5"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Cannot solve? Solve the next Medium problems first:\\n- [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)\\n- [516. Longest Palindromic Subsequence\\n](https://leetcode.com/problems/longest-palindromic-subsequence/)"
                    },
                    {
                        "username": "Sagarchauhan_88",
                        "content": "//why it is not working for all the testcase? Anyone??\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int count = 0;\\n        int left = 0 , right = s.size()-1;\\n\\n        while(left <= right){\\n            if(s[left] == s[right]){\\n                left++;\\n                right--;\\n            }\\n            else{\\n                if(left == right){\\n                    count++;\\n                    break;\\n                }\\n                if(s[left + 1] == s[right]){\\n                    count++;\\n                    left++;\\n                }\\n                else if(s[left] == s[right-1]){ \\n                    count++;\\n                    right--;\\n\\n                }\\n                else{\\n                    left++;\\n                    right--;\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "kausachan",
                        "content": "cool! code you have written follows greedy approach. But here you have to try all possible way of inserting a character to make the string palindrome. Let's take this example case \ns = \"mbadm\"\nas per you code, \nl = 0\nr = 4\nafter first iteration, \"mbadm\"\nl = 1\nr = 3\ncount = 0\n\nafter second iteration, \"bad\"\nl = 2\nr = 2\ncount  = 1\n\nafter third iteration, \"a\"\nl = 3\nr = 1\ncount = 1\n\nresult - 1 (count)\n\nObserve the mistake in second iteration, you're code flow goes to the nested else part where i++ and j-- and count++ happens, which doesn't make sense because it is impossible to make \"bad\" a palindrome by adding 1 letter to it. to make \"bad\" palindrome what you can do is (one possible way is listed here)\nadd \"b\" at end:\nbadb -> since same letters exists in start and end ignore it -> ad\nnow add \"a\" at end\nada ->  since same letters exists in start and end ignore it -> d\n\n\"mbadm\" has been transformed to \"mbadabm\" with 2 additions\n\nso we made minimum of 2 additions to make it a palindrome\n\nPlease reply here in case of doubts"
                    },
                    {
                        "username": "sahilkadian400",
                        "content": "it gives TLE can anyone help me why it gives TLE because when the test case run manually it runs without any error.\\n\\nint solve2Mem(string s,int st,int en,vector<vector<int>>& dp){\\n        if(st>=en){\\n            return 0;\\n        }\\n        if(dp[st][en] != -1) return dp[st][en];\\n        if(s[st]==s[en]){\\n            return dp[st][en] = solve2Mem(s,st+1,en-1,dp);\\n        }\\n        return dp[st][en] = 1+min(solve2Mem(s,st,en-1,dp),solve2Mem(s,st+1,en,dp));\\n    }"
                    },
                    {
                        "username": "beardedone",
                        "content": "Every time you call solve2Mem(), a copy of the string (s) is created.  The copy turns your O(n^2) solution into an O(n^3) solution.  Your code is not mutating the string; try passing it by const reference instead of by value:\n\nint solve2Mem(const std::string& s ...."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Thank daily challenge editors for making me use my brain more and grow my neuron connections."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Why this solution giving TLE as it taking same time compared to lcs?\n\nclass Solution {\npublic:\n    int helper(int left, int right, string s, vector<vector<int>>&dp){\n        if(left >= right)return 0;\n        if(dp[left][right] != -1)return dp[left][right];\n        if(s[left] == s[right]){\n            return dp[left][right] = helper(left+1, right-1, s, dp);\n        }else{\n            return dp[left][right] = 1+ min(helper(left+1,right,s, dp), helper(left, right-1, s, dp));\n        }\n    }\n    int minInsertions(string s) {\n        vector<vector<int>>dp(s.size()+1,vector<int>(s.size()+1,-1));\n        return helper(0,s.size()-1,s,dp);\n    }\n};\n"
                    },
                    {
                        "username": "beardedone",
                        "content": "It might be because every call to helper() is copying the string.  Try passing the string in as a const reference instead."
                    },
                    {
                        "username": "artinegi1607",
                        "content": "I am not getting the question. example: As per the question, for string \"mbadm\" output is =2.\\nBut i think if change only 1 char in string that it would be a palindrome eg: mbabm or mdadm.\\nCan you anyone explains this to me? "
                    },
                    {
                        "username": "harshsinghrajput",
                        "content": "[@AlcalinoGitHub](/AlcalinoGitHub) Then why in the third example last e of leetcode is changed to o"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "The question asks about the minimum number of insertions. You can add any characters you want, but you cannot change the ones that are already in the string"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "if u solved last week\\'s 516.longest palindromic subsequence\\nthen solution for this is literally adding a single more line to the code"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I remind another problem several days ago, very similar to today\\'s one but more difficult?"
                    }
                ]
            },
            {
                "id": 1870607,
                "content": [
                    {
                        "username": "ankitJava",
                        "content": "LCS made my life easier"
                    },
                    {
                        "username": "user8419tm",
                        "content": "Can anyone explain me third example. Answer should be leetcodedocteel   ??"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "leetcode => leetcod`octe`e`l` => 5"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Cannot solve? Solve the next Medium problems first:\\n- [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)\\n- [516. Longest Palindromic Subsequence\\n](https://leetcode.com/problems/longest-palindromic-subsequence/)"
                    },
                    {
                        "username": "Sagarchauhan_88",
                        "content": "//why it is not working for all the testcase? Anyone??\\nclass Solution {\\npublic:\\n    int minInsertions(string s) {\\n        int count = 0;\\n        int left = 0 , right = s.size()-1;\\n\\n        while(left <= right){\\n            if(s[left] == s[right]){\\n                left++;\\n                right--;\\n            }\\n            else{\\n                if(left == right){\\n                    count++;\\n                    break;\\n                }\\n                if(s[left + 1] == s[right]){\\n                    count++;\\n                    left++;\\n                }\\n                else if(s[left] == s[right-1]){ \\n                    count++;\\n                    right--;\\n\\n                }\\n                else{\\n                    left++;\\n                    right--;\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "kausachan",
                        "content": "cool! code you have written follows greedy approach. But here you have to try all possible way of inserting a character to make the string palindrome. Let's take this example case \ns = \"mbadm\"\nas per you code, \nl = 0\nr = 4\nafter first iteration, \"mbadm\"\nl = 1\nr = 3\ncount = 0\n\nafter second iteration, \"bad\"\nl = 2\nr = 2\ncount  = 1\n\nafter third iteration, \"a\"\nl = 3\nr = 1\ncount = 1\n\nresult - 1 (count)\n\nObserve the mistake in second iteration, you're code flow goes to the nested else part where i++ and j-- and count++ happens, which doesn't make sense because it is impossible to make \"bad\" a palindrome by adding 1 letter to it. to make \"bad\" palindrome what you can do is (one possible way is listed here)\nadd \"b\" at end:\nbadb -> since same letters exists in start and end ignore it -> ad\nnow add \"a\" at end\nada ->  since same letters exists in start and end ignore it -> d\n\n\"mbadm\" has been transformed to \"mbadabm\" with 2 additions\n\nso we made minimum of 2 additions to make it a palindrome\n\nPlease reply here in case of doubts"
                    },
                    {
                        "username": "sahilkadian400",
                        "content": "it gives TLE can anyone help me why it gives TLE because when the test case run manually it runs without any error.\\n\\nint solve2Mem(string s,int st,int en,vector<vector<int>>& dp){\\n        if(st>=en){\\n            return 0;\\n        }\\n        if(dp[st][en] != -1) return dp[st][en];\\n        if(s[st]==s[en]){\\n            return dp[st][en] = solve2Mem(s,st+1,en-1,dp);\\n        }\\n        return dp[st][en] = 1+min(solve2Mem(s,st,en-1,dp),solve2Mem(s,st+1,en,dp));\\n    }"
                    },
                    {
                        "username": "beardedone",
                        "content": "Every time you call solve2Mem(), a copy of the string (s) is created.  The copy turns your O(n^2) solution into an O(n^3) solution.  Your code is not mutating the string; try passing it by const reference instead of by value:\n\nint solve2Mem(const std::string& s ...."
                    },
                    {
                        "username": "daring-calf",
                        "content": "Thank daily challenge editors for making me use my brain more and grow my neuron connections."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Why this solution giving TLE as it taking same time compared to lcs?\n\nclass Solution {\npublic:\n    int helper(int left, int right, string s, vector<vector<int>>&dp){\n        if(left >= right)return 0;\n        if(dp[left][right] != -1)return dp[left][right];\n        if(s[left] == s[right]){\n            return dp[left][right] = helper(left+1, right-1, s, dp);\n        }else{\n            return dp[left][right] = 1+ min(helper(left+1,right,s, dp), helper(left, right-1, s, dp));\n        }\n    }\n    int minInsertions(string s) {\n        vector<vector<int>>dp(s.size()+1,vector<int>(s.size()+1,-1));\n        return helper(0,s.size()-1,s,dp);\n    }\n};\n"
                    },
                    {
                        "username": "beardedone",
                        "content": "It might be because every call to helper() is copying the string.  Try passing the string in as a const reference instead."
                    },
                    {
                        "username": "artinegi1607",
                        "content": "I am not getting the question. example: As per the question, for string \"mbadm\" output is =2.\\nBut i think if change only 1 char in string that it would be a palindrome eg: mbabm or mdadm.\\nCan you anyone explains this to me? "
                    },
                    {
                        "username": "harshsinghrajput",
                        "content": "[@AlcalinoGitHub](/AlcalinoGitHub) Then why in the third example last e of leetcode is changed to o"
                    },
                    {
                        "username": "AlcalinoGitHub",
                        "content": "The question asks about the minimum number of insertions. You can add any characters you want, but you cannot change the ones that are already in the string"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "if u solved last week\\'s 516.longest palindromic subsequence\\nthen solution for this is literally adding a single more line to the code"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I remind another problem several days ago, very similar to today\\'s one but more difficult?"
                    }
                ]
            },
            {
                "id": 1870602,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "hint \\nsize-length of longest common subsequence of given string and reverse of it\\n"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "this is not a hint, straight up solution \\n"
                    },
                    {
                        "username": "_adarshagrawal_",
                        "content": "They have basically given the complete answer as a hint for this question. \\nAfter seeing the hint you just have to apply LCS on s and reverse(s) which is quite pointless.\\n"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I think it still qualifies as a hard question, it becomes a medium question only after you use the hints."
                    },
                    {
                        "username": "ahmedrizk",
                        "content": "Medium problem "
                    },
                    {
                        "username": "JustBored",
                        "content": "This problem is just an easier variation of LC 72 edit distance"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Recursion Tree</span>\\n![](https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/Figures/1312/1312-1.png)"
                    },
                    {
                        "username": "jacoboy",
                        "content": "this should be a medium"
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem is a variation of LCS.\\nFirst find LPS(longest palindromic subsequence);\\nthen return (length of string - LPS);"
                    },
                    {
                        "username": "BHAVTOSH_DASH",
                        "content": "WHY IS IT NOT ACCEPTING THE MEMOIZATION SOLUTION FOR THIS CODE?\\nBUT IF A TRY THE SAME CODE WITH TABULATION METHOD IT ACCEPTS IT.\\n\\n\\n    int LCS(string s1, string s2, int n, int m, vector<vector<int>> &dp)\\n    {\\n        if(n<=0 or m<=0)\\n            return 0;\\n        if(dp[n][m] != -1)\\n            return dp[n][m];\\n        \\n        if(s1[n-1] == s2[m-1])\\n            return dp[n][m]=1+LCS(s1,s2,n-1,m-1,dp);\\n        \\n        int call_1=LCS(s1,s2,n-1,m,dp);\\n\\n        int call_2=LCS(s1,s2,n,m-1,dp);\\n\\n        return dp[n][m]=max(call_1,call_2);\\n    }\\n    int minInsertions(string s) {\\n        \\n        // step-1 : find the longest palindromic subsequence(LPS)\\n        // step-2 : length(s)-length(LPS(s)) == answer\\n\\n        string s1=s;\\n        reverse(s.begin(),s.end());\\n        string s2=s;\\n\\n        int n,m;\\n        n=m=s.size();\\n\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n\\n        int LPS_count=LCS(s1,s2,n,m,dp);\\n\\n        return n-LPS_count;\\n    }\\n"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@sam7244](/sam7244) always forget to do this , thanks for the tip bro."
                    },
                    {
                        "username": "sam7244",
                        "content": "try passing the strings with references like &s1 and &s2 in "
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Very easy. If you can\\'t do this, gitgud"
                    }
                ]
            },
            {
                "id": 1870601,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "hint \\nsize-length of longest common subsequence of given string and reverse of it\\n"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "this is not a hint, straight up solution \\n"
                    },
                    {
                        "username": "_adarshagrawal_",
                        "content": "They have basically given the complete answer as a hint for this question. \\nAfter seeing the hint you just have to apply LCS on s and reverse(s) which is quite pointless.\\n"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I think it still qualifies as a hard question, it becomes a medium question only after you use the hints."
                    },
                    {
                        "username": "ahmedrizk",
                        "content": "Medium problem "
                    },
                    {
                        "username": "JustBored",
                        "content": "This problem is just an easier variation of LC 72 edit distance"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Recursion Tree</span>\\n![](https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/Figures/1312/1312-1.png)"
                    },
                    {
                        "username": "jacoboy",
                        "content": "this should be a medium"
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem is a variation of LCS.\\nFirst find LPS(longest palindromic subsequence);\\nthen return (length of string - LPS);"
                    },
                    {
                        "username": "BHAVTOSH_DASH",
                        "content": "WHY IS IT NOT ACCEPTING THE MEMOIZATION SOLUTION FOR THIS CODE?\\nBUT IF A TRY THE SAME CODE WITH TABULATION METHOD IT ACCEPTS IT.\\n\\n\\n    int LCS(string s1, string s2, int n, int m, vector<vector<int>> &dp)\\n    {\\n        if(n<=0 or m<=0)\\n            return 0;\\n        if(dp[n][m] != -1)\\n            return dp[n][m];\\n        \\n        if(s1[n-1] == s2[m-1])\\n            return dp[n][m]=1+LCS(s1,s2,n-1,m-1,dp);\\n        \\n        int call_1=LCS(s1,s2,n-1,m,dp);\\n\\n        int call_2=LCS(s1,s2,n,m-1,dp);\\n\\n        return dp[n][m]=max(call_1,call_2);\\n    }\\n    int minInsertions(string s) {\\n        \\n        // step-1 : find the longest palindromic subsequence(LPS)\\n        // step-2 : length(s)-length(LPS(s)) == answer\\n\\n        string s1=s;\\n        reverse(s.begin(),s.end());\\n        string s2=s;\\n\\n        int n,m;\\n        n=m=s.size();\\n\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n\\n        int LPS_count=LCS(s1,s2,n,m,dp);\\n\\n        return n-LPS_count;\\n    }\\n"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@sam7244](/sam7244) always forget to do this , thanks for the tip bro."
                    },
                    {
                        "username": "sam7244",
                        "content": "try passing the strings with references like &s1 and &s2 in "
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Very easy. If you can\\'t do this, gitgud"
                    }
                ]
            },
            {
                "id": 1870585,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "hint \\nsize-length of longest common subsequence of given string and reverse of it\\n"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "this is not a hint, straight up solution \\n"
                    },
                    {
                        "username": "_adarshagrawal_",
                        "content": "They have basically given the complete answer as a hint for this question. \\nAfter seeing the hint you just have to apply LCS on s and reverse(s) which is quite pointless.\\n"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I think it still qualifies as a hard question, it becomes a medium question only after you use the hints."
                    },
                    {
                        "username": "ahmedrizk",
                        "content": "Medium problem "
                    },
                    {
                        "username": "JustBored",
                        "content": "This problem is just an easier variation of LC 72 edit distance"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Recursion Tree</span>\\n![](https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/Figures/1312/1312-1.png)"
                    },
                    {
                        "username": "jacoboy",
                        "content": "this should be a medium"
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem is a variation of LCS.\\nFirst find LPS(longest palindromic subsequence);\\nthen return (length of string - LPS);"
                    },
                    {
                        "username": "BHAVTOSH_DASH",
                        "content": "WHY IS IT NOT ACCEPTING THE MEMOIZATION SOLUTION FOR THIS CODE?\\nBUT IF A TRY THE SAME CODE WITH TABULATION METHOD IT ACCEPTS IT.\\n\\n\\n    int LCS(string s1, string s2, int n, int m, vector<vector<int>> &dp)\\n    {\\n        if(n<=0 or m<=0)\\n            return 0;\\n        if(dp[n][m] != -1)\\n            return dp[n][m];\\n        \\n        if(s1[n-1] == s2[m-1])\\n            return dp[n][m]=1+LCS(s1,s2,n-1,m-1,dp);\\n        \\n        int call_1=LCS(s1,s2,n-1,m,dp);\\n\\n        int call_2=LCS(s1,s2,n,m-1,dp);\\n\\n        return dp[n][m]=max(call_1,call_2);\\n    }\\n    int minInsertions(string s) {\\n        \\n        // step-1 : find the longest palindromic subsequence(LPS)\\n        // step-2 : length(s)-length(LPS(s)) == answer\\n\\n        string s1=s;\\n        reverse(s.begin(),s.end());\\n        string s2=s;\\n\\n        int n,m;\\n        n=m=s.size();\\n\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n\\n        int LPS_count=LCS(s1,s2,n,m,dp);\\n\\n        return n-LPS_count;\\n    }\\n"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@sam7244](/sam7244) always forget to do this , thanks for the tip bro."
                    },
                    {
                        "username": "sam7244",
                        "content": "try passing the strings with references like &s1 and &s2 in "
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Very easy. If you can\\'t do this, gitgud"
                    }
                ]
            },
            {
                "id": 1870567,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "hint \\nsize-length of longest common subsequence of given string and reverse of it\\n"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "this is not a hint, straight up solution \\n"
                    },
                    {
                        "username": "_adarshagrawal_",
                        "content": "They have basically given the complete answer as a hint for this question. \\nAfter seeing the hint you just have to apply LCS on s and reverse(s) which is quite pointless.\\n"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I think it still qualifies as a hard question, it becomes a medium question only after you use the hints."
                    },
                    {
                        "username": "ahmedrizk",
                        "content": "Medium problem "
                    },
                    {
                        "username": "JustBored",
                        "content": "This problem is just an easier variation of LC 72 edit distance"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Recursion Tree</span>\\n![](https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/Figures/1312/1312-1.png)"
                    },
                    {
                        "username": "jacoboy",
                        "content": "this should be a medium"
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem is a variation of LCS.\\nFirst find LPS(longest palindromic subsequence);\\nthen return (length of string - LPS);"
                    },
                    {
                        "username": "BHAVTOSH_DASH",
                        "content": "WHY IS IT NOT ACCEPTING THE MEMOIZATION SOLUTION FOR THIS CODE?\\nBUT IF A TRY THE SAME CODE WITH TABULATION METHOD IT ACCEPTS IT.\\n\\n\\n    int LCS(string s1, string s2, int n, int m, vector<vector<int>> &dp)\\n    {\\n        if(n<=0 or m<=0)\\n            return 0;\\n        if(dp[n][m] != -1)\\n            return dp[n][m];\\n        \\n        if(s1[n-1] == s2[m-1])\\n            return dp[n][m]=1+LCS(s1,s2,n-1,m-1,dp);\\n        \\n        int call_1=LCS(s1,s2,n-1,m,dp);\\n\\n        int call_2=LCS(s1,s2,n,m-1,dp);\\n\\n        return dp[n][m]=max(call_1,call_2);\\n    }\\n    int minInsertions(string s) {\\n        \\n        // step-1 : find the longest palindromic subsequence(LPS)\\n        // step-2 : length(s)-length(LPS(s)) == answer\\n\\n        string s1=s;\\n        reverse(s.begin(),s.end());\\n        string s2=s;\\n\\n        int n,m;\\n        n=m=s.size();\\n\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n\\n        int LPS_count=LCS(s1,s2,n,m,dp);\\n\\n        return n-LPS_count;\\n    }\\n"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@sam7244](/sam7244) always forget to do this , thanks for the tip bro."
                    },
                    {
                        "username": "sam7244",
                        "content": "try passing the strings with references like &s1 and &s2 in "
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Very easy. If you can\\'t do this, gitgud"
                    }
                ]
            },
            {
                "id": 1870552,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "hint \\nsize-length of longest common subsequence of given string and reverse of it\\n"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "this is not a hint, straight up solution \\n"
                    },
                    {
                        "username": "_adarshagrawal_",
                        "content": "They have basically given the complete answer as a hint for this question. \\nAfter seeing the hint you just have to apply LCS on s and reverse(s) which is quite pointless.\\n"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I think it still qualifies as a hard question, it becomes a medium question only after you use the hints."
                    },
                    {
                        "username": "ahmedrizk",
                        "content": "Medium problem "
                    },
                    {
                        "username": "JustBored",
                        "content": "This problem is just an easier variation of LC 72 edit distance"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Recursion Tree</span>\\n![](https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/Figures/1312/1312-1.png)"
                    },
                    {
                        "username": "jacoboy",
                        "content": "this should be a medium"
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem is a variation of LCS.\\nFirst find LPS(longest palindromic subsequence);\\nthen return (length of string - LPS);"
                    },
                    {
                        "username": "BHAVTOSH_DASH",
                        "content": "WHY IS IT NOT ACCEPTING THE MEMOIZATION SOLUTION FOR THIS CODE?\\nBUT IF A TRY THE SAME CODE WITH TABULATION METHOD IT ACCEPTS IT.\\n\\n\\n    int LCS(string s1, string s2, int n, int m, vector<vector<int>> &dp)\\n    {\\n        if(n<=0 or m<=0)\\n            return 0;\\n        if(dp[n][m] != -1)\\n            return dp[n][m];\\n        \\n        if(s1[n-1] == s2[m-1])\\n            return dp[n][m]=1+LCS(s1,s2,n-1,m-1,dp);\\n        \\n        int call_1=LCS(s1,s2,n-1,m,dp);\\n\\n        int call_2=LCS(s1,s2,n,m-1,dp);\\n\\n        return dp[n][m]=max(call_1,call_2);\\n    }\\n    int minInsertions(string s) {\\n        \\n        // step-1 : find the longest palindromic subsequence(LPS)\\n        // step-2 : length(s)-length(LPS(s)) == answer\\n\\n        string s1=s;\\n        reverse(s.begin(),s.end());\\n        string s2=s;\\n\\n        int n,m;\\n        n=m=s.size();\\n\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n\\n        int LPS_count=LCS(s1,s2,n,m,dp);\\n\\n        return n-LPS_count;\\n    }\\n"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@sam7244](/sam7244) always forget to do this , thanks for the tip bro."
                    },
                    {
                        "username": "sam7244",
                        "content": "try passing the strings with references like &s1 and &s2 in "
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Very easy. If you can\\'t do this, gitgud"
                    }
                ]
            },
            {
                "id": 1870529,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "hint \\nsize-length of longest common subsequence of given string and reverse of it\\n"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "this is not a hint, straight up solution \\n"
                    },
                    {
                        "username": "_adarshagrawal_",
                        "content": "They have basically given the complete answer as a hint for this question. \\nAfter seeing the hint you just have to apply LCS on s and reverse(s) which is quite pointless.\\n"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I think it still qualifies as a hard question, it becomes a medium question only after you use the hints."
                    },
                    {
                        "username": "ahmedrizk",
                        "content": "Medium problem "
                    },
                    {
                        "username": "JustBored",
                        "content": "This problem is just an easier variation of LC 72 edit distance"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Recursion Tree</span>\\n![](https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/Figures/1312/1312-1.png)"
                    },
                    {
                        "username": "jacoboy",
                        "content": "this should be a medium"
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem is a variation of LCS.\\nFirst find LPS(longest palindromic subsequence);\\nthen return (length of string - LPS);"
                    },
                    {
                        "username": "BHAVTOSH_DASH",
                        "content": "WHY IS IT NOT ACCEPTING THE MEMOIZATION SOLUTION FOR THIS CODE?\\nBUT IF A TRY THE SAME CODE WITH TABULATION METHOD IT ACCEPTS IT.\\n\\n\\n    int LCS(string s1, string s2, int n, int m, vector<vector<int>> &dp)\\n    {\\n        if(n<=0 or m<=0)\\n            return 0;\\n        if(dp[n][m] != -1)\\n            return dp[n][m];\\n        \\n        if(s1[n-1] == s2[m-1])\\n            return dp[n][m]=1+LCS(s1,s2,n-1,m-1,dp);\\n        \\n        int call_1=LCS(s1,s2,n-1,m,dp);\\n\\n        int call_2=LCS(s1,s2,n,m-1,dp);\\n\\n        return dp[n][m]=max(call_1,call_2);\\n    }\\n    int minInsertions(string s) {\\n        \\n        // step-1 : find the longest palindromic subsequence(LPS)\\n        // step-2 : length(s)-length(LPS(s)) == answer\\n\\n        string s1=s;\\n        reverse(s.begin(),s.end());\\n        string s2=s;\\n\\n        int n,m;\\n        n=m=s.size();\\n\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n\\n        int LPS_count=LCS(s1,s2,n,m,dp);\\n\\n        return n-LPS_count;\\n    }\\n"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@sam7244](/sam7244) always forget to do this , thanks for the tip bro."
                    },
                    {
                        "username": "sam7244",
                        "content": "try passing the strings with references like &s1 and &s2 in "
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Very easy. If you can\\'t do this, gitgud"
                    }
                ]
            },
            {
                "id": 1870525,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "hint \\nsize-length of longest common subsequence of given string and reverse of it\\n"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "this is not a hint, straight up solution \\n"
                    },
                    {
                        "username": "_adarshagrawal_",
                        "content": "They have basically given the complete answer as a hint for this question. \\nAfter seeing the hint you just have to apply LCS on s and reverse(s) which is quite pointless.\\n"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I think it still qualifies as a hard question, it becomes a medium question only after you use the hints."
                    },
                    {
                        "username": "ahmedrizk",
                        "content": "Medium problem "
                    },
                    {
                        "username": "JustBored",
                        "content": "This problem is just an easier variation of LC 72 edit distance"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Recursion Tree</span>\\n![](https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/Figures/1312/1312-1.png)"
                    },
                    {
                        "username": "jacoboy",
                        "content": "this should be a medium"
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem is a variation of LCS.\\nFirst find LPS(longest palindromic subsequence);\\nthen return (length of string - LPS);"
                    },
                    {
                        "username": "BHAVTOSH_DASH",
                        "content": "WHY IS IT NOT ACCEPTING THE MEMOIZATION SOLUTION FOR THIS CODE?\\nBUT IF A TRY THE SAME CODE WITH TABULATION METHOD IT ACCEPTS IT.\\n\\n\\n    int LCS(string s1, string s2, int n, int m, vector<vector<int>> &dp)\\n    {\\n        if(n<=0 or m<=0)\\n            return 0;\\n        if(dp[n][m] != -1)\\n            return dp[n][m];\\n        \\n        if(s1[n-1] == s2[m-1])\\n            return dp[n][m]=1+LCS(s1,s2,n-1,m-1,dp);\\n        \\n        int call_1=LCS(s1,s2,n-1,m,dp);\\n\\n        int call_2=LCS(s1,s2,n,m-1,dp);\\n\\n        return dp[n][m]=max(call_1,call_2);\\n    }\\n    int minInsertions(string s) {\\n        \\n        // step-1 : find the longest palindromic subsequence(LPS)\\n        // step-2 : length(s)-length(LPS(s)) == answer\\n\\n        string s1=s;\\n        reverse(s.begin(),s.end());\\n        string s2=s;\\n\\n        int n,m;\\n        n=m=s.size();\\n\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n\\n        int LPS_count=LCS(s1,s2,n,m,dp);\\n\\n        return n-LPS_count;\\n    }\\n"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@sam7244](/sam7244) always forget to do this , thanks for the tip bro."
                    },
                    {
                        "username": "sam7244",
                        "content": "try passing the strings with references like &s1 and &s2 in "
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Very easy. If you can\\'t do this, gitgud"
                    }
                ]
            },
            {
                "id": 1854538,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "hint \\nsize-length of longest common subsequence of given string and reverse of it\\n"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "this is not a hint, straight up solution \\n"
                    },
                    {
                        "username": "_adarshagrawal_",
                        "content": "They have basically given the complete answer as a hint for this question. \\nAfter seeing the hint you just have to apply LCS on s and reverse(s) which is quite pointless.\\n"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I think it still qualifies as a hard question, it becomes a medium question only after you use the hints."
                    },
                    {
                        "username": "ahmedrizk",
                        "content": "Medium problem "
                    },
                    {
                        "username": "JustBored",
                        "content": "This problem is just an easier variation of LC 72 edit distance"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Recursion Tree</span>\\n![](https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/Figures/1312/1312-1.png)"
                    },
                    {
                        "username": "jacoboy",
                        "content": "this should be a medium"
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem is a variation of LCS.\\nFirst find LPS(longest palindromic subsequence);\\nthen return (length of string - LPS);"
                    },
                    {
                        "username": "BHAVTOSH_DASH",
                        "content": "WHY IS IT NOT ACCEPTING THE MEMOIZATION SOLUTION FOR THIS CODE?\\nBUT IF A TRY THE SAME CODE WITH TABULATION METHOD IT ACCEPTS IT.\\n\\n\\n    int LCS(string s1, string s2, int n, int m, vector<vector<int>> &dp)\\n    {\\n        if(n<=0 or m<=0)\\n            return 0;\\n        if(dp[n][m] != -1)\\n            return dp[n][m];\\n        \\n        if(s1[n-1] == s2[m-1])\\n            return dp[n][m]=1+LCS(s1,s2,n-1,m-1,dp);\\n        \\n        int call_1=LCS(s1,s2,n-1,m,dp);\\n\\n        int call_2=LCS(s1,s2,n,m-1,dp);\\n\\n        return dp[n][m]=max(call_1,call_2);\\n    }\\n    int minInsertions(string s) {\\n        \\n        // step-1 : find the longest palindromic subsequence(LPS)\\n        // step-2 : length(s)-length(LPS(s)) == answer\\n\\n        string s1=s;\\n        reverse(s.begin(),s.end());\\n        string s2=s;\\n\\n        int n,m;\\n        n=m=s.size();\\n\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n\\n        int LPS_count=LCS(s1,s2,n,m,dp);\\n\\n        return n-LPS_count;\\n    }\\n"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@sam7244](/sam7244) always forget to do this , thanks for the tip bro."
                    },
                    {
                        "username": "sam7244",
                        "content": "try passing the strings with references like &s1 and &s2 in "
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Very easy. If you can\\'t do this, gitgud"
                    }
                ]
            },
            {
                "id": 1680646,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "hint \\nsize-length of longest common subsequence of given string and reverse of it\\n"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "this is not a hint, straight up solution \\n"
                    },
                    {
                        "username": "_adarshagrawal_",
                        "content": "They have basically given the complete answer as a hint for this question. \\nAfter seeing the hint you just have to apply LCS on s and reverse(s) which is quite pointless.\\n"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I think it still qualifies as a hard question, it becomes a medium question only after you use the hints."
                    },
                    {
                        "username": "ahmedrizk",
                        "content": "Medium problem "
                    },
                    {
                        "username": "JustBored",
                        "content": "This problem is just an easier variation of LC 72 edit distance"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Recursion Tree</span>\\n![](https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/Figures/1312/1312-1.png)"
                    },
                    {
                        "username": "jacoboy",
                        "content": "this should be a medium"
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem is a variation of LCS.\\nFirst find LPS(longest palindromic subsequence);\\nthen return (length of string - LPS);"
                    },
                    {
                        "username": "BHAVTOSH_DASH",
                        "content": "WHY IS IT NOT ACCEPTING THE MEMOIZATION SOLUTION FOR THIS CODE?\\nBUT IF A TRY THE SAME CODE WITH TABULATION METHOD IT ACCEPTS IT.\\n\\n\\n    int LCS(string s1, string s2, int n, int m, vector<vector<int>> &dp)\\n    {\\n        if(n<=0 or m<=0)\\n            return 0;\\n        if(dp[n][m] != -1)\\n            return dp[n][m];\\n        \\n        if(s1[n-1] == s2[m-1])\\n            return dp[n][m]=1+LCS(s1,s2,n-1,m-1,dp);\\n        \\n        int call_1=LCS(s1,s2,n-1,m,dp);\\n\\n        int call_2=LCS(s1,s2,n,m-1,dp);\\n\\n        return dp[n][m]=max(call_1,call_2);\\n    }\\n    int minInsertions(string s) {\\n        \\n        // step-1 : find the longest palindromic subsequence(LPS)\\n        // step-2 : length(s)-length(LPS(s)) == answer\\n\\n        string s1=s;\\n        reverse(s.begin(),s.end());\\n        string s2=s;\\n\\n        int n,m;\\n        n=m=s.size();\\n\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n\\n        int LPS_count=LCS(s1,s2,n,m,dp);\\n\\n        return n-LPS_count;\\n    }\\n"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@sam7244](/sam7244) always forget to do this , thanks for the tip bro."
                    },
                    {
                        "username": "sam7244",
                        "content": "try passing the strings with references like &s1 and &s2 in "
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Very easy. If you can\\'t do this, gitgud"
                    }
                ]
            },
            {
                "id": 1871113,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "hint \\nsize-length of longest common subsequence of given string and reverse of it\\n"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "this is not a hint, straight up solution \\n"
                    },
                    {
                        "username": "_adarshagrawal_",
                        "content": "They have basically given the complete answer as a hint for this question. \\nAfter seeing the hint you just have to apply LCS on s and reverse(s) which is quite pointless.\\n"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "I think it still qualifies as a hard question, it becomes a medium question only after you use the hints."
                    },
                    {
                        "username": "ahmedrizk",
                        "content": "Medium problem "
                    },
                    {
                        "username": "JustBored",
                        "content": "This problem is just an easier variation of LC 72 edit distance"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Recursion Tree</span>\\n![](https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/Figures/1312/1312-1.png)"
                    },
                    {
                        "username": "jacoboy",
                        "content": "this should be a medium"
                    },
                    {
                        "username": "aftab0711",
                        "content": "This problem is a variation of LCS.\\nFirst find LPS(longest palindromic subsequence);\\nthen return (length of string - LPS);"
                    },
                    {
                        "username": "BHAVTOSH_DASH",
                        "content": "WHY IS IT NOT ACCEPTING THE MEMOIZATION SOLUTION FOR THIS CODE?\\nBUT IF A TRY THE SAME CODE WITH TABULATION METHOD IT ACCEPTS IT.\\n\\n\\n    int LCS(string s1, string s2, int n, int m, vector<vector<int>> &dp)\\n    {\\n        if(n<=0 or m<=0)\\n            return 0;\\n        if(dp[n][m] != -1)\\n            return dp[n][m];\\n        \\n        if(s1[n-1] == s2[m-1])\\n            return dp[n][m]=1+LCS(s1,s2,n-1,m-1,dp);\\n        \\n        int call_1=LCS(s1,s2,n-1,m,dp);\\n\\n        int call_2=LCS(s1,s2,n,m-1,dp);\\n\\n        return dp[n][m]=max(call_1,call_2);\\n    }\\n    int minInsertions(string s) {\\n        \\n        // step-1 : find the longest palindromic subsequence(LPS)\\n        // step-2 : length(s)-length(LPS(s)) == answer\\n\\n        string s1=s;\\n        reverse(s.begin(),s.end());\\n        string s2=s;\\n\\n        int n,m;\\n        n=m=s.size();\\n\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n\\n        int LPS_count=LCS(s1,s2,n,m,dp);\\n\\n        return n-LPS_count;\\n    }\\n"
                    },
                    {
                        "username": "ashish7475",
                        "content": "[@sam7244](/sam7244) always forget to do this , thanks for the tip bro."
                    },
                    {
                        "username": "sam7244",
                        "content": "try passing the strings with references like &s1 and &s2 in "
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Very easy. If you can\\'t do this, gitgud"
                    }
                ]
            }
        ]
    },
    {
        "title": "Decode XORed Array",
        "question_content": "<p>There is a <strong>hidden</strong> integer array <code>arr</code> that consists of <code>n</code> non-negative integers.</p>\n\n<p>It was encoded into another integer array <code>encoded</code> of length <code>n - 1</code>, such that <code>encoded[i] = arr[i] XOR arr[i + 1]</code>. For example, if <code>arr = [1,0,2,1]</code>, then <code>encoded = [1,2,3]</code>.</p>\n\n<p>You are given the <code>encoded</code> array. You are also given an integer <code>first</code>, that is the first element of <code>arr</code>, i.e. <code>arr[0]</code>.</p>\n\n<p>Return <em>the original array</em> <code>arr</code>. It can be proved that the answer exists and is unique.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> encoded = [1,2,3], first = 1\n<strong>Output:</strong> [1,0,2,1]\n<strong>Explanation:</strong> If arr = [1,0,2,1], then first = 1 and encoded = [1 XOR 0, 0 XOR 2, 2 XOR 1] = [1,2,3]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> encoded = [6,2,7,3], first = 4\n<strong>Output:</strong> [4,2,0,7,4]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>encoded.length == n - 1</code></li>\n\t<li><code>0 &lt;= encoded[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= first &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1009844,
                "title": "java-c-python-easy-and-concise",
                "content": "# **Explanation**\\n`cur` means the current decoded element.\\n\\nFor each element we have\\n`A[i] = res[i] ^ res[i+1]`\\n`A[i] ^ A[i] ^ res[i+1] = res[i] ^ res[i+1] ^ A[i] ^ res[i+1]`\\n`res[i+1] = res[i] ^ A[i]`\\n\\nSo we use the conslusion above,\\niterate the input encoded array `A`,\\nupdate `res[i + 1] = res[i] ^ A[i]`.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(n)`\\n<br>\\n\\n**Java:**\\n```java\\n    public int[] decode(int[] A, int first) {\\n        int n = A.length, res[] = new int[n + 1];\\n        res[0] = first;\\n        for (int i = 0; i < n; ++i)\\n            res[i + 1] = res[i] ^ A[i];\\n        return res;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    vector<int> decode(vector<int>& A, int cur) {\\n        vector<int> res = {cur};\\n        for (int& a: A)\\n            res.push_back(cur ^= a);\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def decode(self, A, first):\\n        res = [first]\\n        for a in A:\\n            res.append(res[-1] ^ a)\\n        return res\\n```\\n\\n**Python3**\\n```py\\n    def decode(self, A, first):\\n        return list(accumulate([first] + A, lambda x, y: x ^ y))\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int[] decode(int[] A, int first) {\\n        int n = A.length, res[] = new int[n + 1];\\n        res[0] = first;\\n        for (int i = 0; i < n; ++i)\\n            res[i + 1] = res[i] ^ A[i];\\n        return res;\\n    }\\n```\n```cpp\\n    vector<int> decode(vector<int>& A, int cur) {\\n        vector<int> res = {cur};\\n        for (int& a: A)\\n            res.push_back(cur ^= a);\\n        return res;\\n    }\\n```\n```py\\n    def decode(self, A, first):\\n        res = [first]\\n        for a in A:\\n            res.append(res[-1] ^ a)\\n        return res\\n```\n```py\\n    def decode(self, A, first):\\n        return list(accumulate([first] + A, lambda x, y: x ^ y))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1009791,
                "title": "python-java-cpp-c-easy-solution-with-explanation-accepted",
                "content": "\\n\\n**Explanation**\\n**a XOR b = c**, we know the values of **a** and **c**. we use the formula to find **b**  ->  **a XOR c = b**  \\n**Complexity**\\n\\nTime ```O(N)```\\nSpace ```O(10)```\\n\\n**Python:**\\n```\\ndef decode(self, encoded: List[int], first: int) -> List[int]:\\n        r = [first]\\n        for i in encoded:\\n            r.append(r[-1]^i)\\n        return r\\n```\\n\\n\\n**JAVA** \\n```\\npublic int[] decode(int[] encoded, int first) {\\n        int[] res = new int[encoded.length+1];\\n        res[0] = first;\\n        for(int i = 0; i < encoded.length; i++)\\n            res[i+1] = res[i] ^ encoded[i];\\n        return res;\\n    }\\n```\\n\\n**C++**\\n\\n```\\nvector<int> decode(vector<int>& encoded, int first) {\\n        vector<int> res;\\n        res.push_back(first);\\n        for(int i = 0; i < encoded.size(); i++)\\n            res.push_back(res[i] ^ encoded[i]);\\n        return res;\\n    }\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```O(N)```\n```O(10)```\n```\\ndef decode(self, encoded: List[int], first: int) -> List[int]:\\n        r = [first]\\n        for i in encoded:\\n            r.append(r[-1]^i)\\n        return r\\n```\n```\\npublic int[] decode(int[] encoded, int first) {\\n        int[] res = new int[encoded.length+1];\\n        res[0] = first;\\n        for(int i = 0; i < encoded.length; i++)\\n            res[i+1] = res[i] ^ encoded[i];\\n        return res;\\n    }\\n```\n```\\nvector<int> decode(vector<int>& encoded, int first) {\\n        vector<int> res;\\n        res.push_back(first);\\n        for(int i = 0; i < encoded.size(); i++)\\n            res.push_back(res[i] ^ encoded[i]);\\n        return res;\\n    }\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1012825,
                "title": "c-o-n-one-pass-no-extra-memory-used",
                "content": "a<sub>i</sub> ^ a<sub>i+1</sub> = b<sub>i</sub> `=>` a<sub>i</sub> ^ a<sub>i+1</sub> ^ a<sub>i</sub> = b<sub>i</sub> ^ a<sub>i</sub> `=>` a<sub>i+1</sub> = b<sub>i</sub> ^ a<sub>i</sub>\\n\\nIt\\'s easy to create a new array and just append the decoded numbers to it.\\nWhat if the interviewer asks you to do it in-place? (For example, you need to decode a (infinite) stream on the fly)\\n\\nImagine `first` is a<sub>i</sub> and `n` is b<sub>i</sub>, we firstly put a<sub>i</sub> in the ith slot by swapping a<sub>i</sub> and b<sub>i</sub>, then calculate a<sub>i+1</sub> and store in `first`.\\nAt the end `first` will be the last number.\\n```cpp\\nvector<int> decode(vector<int>& encoded, int first) {\\n\\tfor (int &n : encoded) {\\n\\t\\tswap(n, first);\\n\\t\\tfirst ^= n;\\n\\t}\\n\\tencoded.push_back(first);\\n\\treturn encoded;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nvector<int> decode(vector<int>& encoded, int first) {\\n\\tfor (int &n : encoded) {\\n\\t\\tswap(n, first);\\n\\t\\tfirst ^= n;\\n\\t}\\n\\tencoded.push_back(first);\\n\\treturn encoded;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1042039,
                "title": "4-lines-c-faster-than-75-less-memory-than-100",
                "content": "The only thing you need to do is to **insert** the first element at first position **and** **do the same xor** operations as the encoder did.\\n```\\nvector<int> decode(vector<int>& encoded, int first) {\\n        encoded.insert(encoded.begin(),first);\\n        for(int i=1;i<encoded.size();i++)\\n        {\\n        encoded[i] = encoded[i] xor  encoded[i-1];\\n        }\\n        return encoded;\\n    }\\n```\\nIf you liked my solution give it an **upvote**\\uD83D\\uDD25",
                "solutionTags": [],
                "code": "```\\nvector<int> decode(vector<int>& encoded, int first) {\\n        encoded.insert(encoded.begin(),first);\\n        for(int i=1;i<encoded.size();i++)\\n        {\\n        encoded[i] = encoded[i] xor  encoded[i-1];\\n        }\\n        return encoded;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1075067,
                "title": "python-1-liner-list-comprehension-with-assignment-expresion",
                "content": "```\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        return [first] + [first:= first ^ x for x in encoded]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        return [first] + [first:= first ^ x for x in encoded]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1264403,
                "title": "c-easy-one-line-solution-with-explanation",
                "content": "We are given, `encoded[i] = array[i]^array[i+1]`\\nNow, for the first element, `encoded[0] = array[0]^array[1] `(`array[0]` has been given to us as `\\'first\\'`)\\nSo, `encoded[0] = first^array[1]`\\nTaking `^` with first on both sides,\\n`first^encoded[0] = first^first^array[1]`\\n=> `array[1] = first^encoded[0]`\\nSimilarly, `array[2] = array[1]^encoded[1]`, But we can reduce this to the following code-\\n\\n```\\nloop(i, n){\\narray[i+1] = first^encoded[i];\\nfirst = array[i+1];\\n}\\n```\\n\\nThis can be further reduced to one-liner in CPP using vectors.\\nFinal Code: \\n```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int> ans{first};\\n        for(int x: encoded)\\n            ans.push_back(first^=x);\\n        return ans;\\n    }\\n};\\n```\\n\\nPS: This is my first post. Please give it a thumbs up if you liked it.",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nloop(i, n){\\narray[i+1] = first^encoded[i];\\nfirst = array[i+1];\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int> ans{first};\\n        for(int x: encoded)\\n            ans.push_back(first^=x);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1157703,
                "title": "swift-decode-xored-array",
                "content": "```swift\\nclass Solution {\\n    func decode(_ encoded: [Int], _ first: Int) -> [Int] {\\n        var ans = [first]\\n        encoded.forEach({ ans.append(ans.last! ^ $0) })\\n        return ans\\n    }\\n}\\n```\\n\\n```swift\\nimport XCTest\\n\\n// Executed 2 tests, with 0 failures (0 unexpected) in 0.006 (0.008) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func testExample1() {\\n        XCTAssertEqual(s.decode([1,2,3], 1), [1,0,2,1]) // success\\n    }\\n    func testExample2() {\\n        XCTAssertEqual(s.decode([6,2,7,3], 4), [4,2,0,7,4]) // success\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func decode(_ encoded: [Int], _ first: Int) -> [Int] {\\n        var ans = [first]\\n        encoded.forEach({ ans.append(ans.last! ^ $0) })\\n        return ans\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 2 tests, with 0 failures (0 unexpected) in 0.006 (0.008) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func testExample1() {\\n        XCTAssertEqual(s.decode([1,2,3], 1), [1,0,2,1]) // success\\n    }\\n    func testExample2() {\\n        XCTAssertEqual(s.decode([6,2,7,3], 4), [4,2,0,7,4]) // success\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1292671,
                "title": "python-simple-one-liner-100-faster",
                "content": "The more difficult thing of this problem is understanding how do decode the XOR operation, because the code that does it is simple.\\nThe key is in realising the following:\\n\\nIf `c = a XOR b`, then we know that `a == c XOR b` and `b == c XOR a`. What is more, XOR is both commutative and associative, so it really is a nice function and to decode we just have to encode all over again!\\n\\nThe single line of code you need is the following:\\n\\n```py\\nreturn itertools.accumulate(encoded, operator.xor, initial=first)\\n```\\n\\nFor reference, here are the docs pages on the two functions I used:\\n\\n - [`itertools.accumulate`](https://docs.python.org/3/library/itertools.html#itertools.accumulate)\\n - [`operator.xor`](https://docs.python.org/3/library/operator.html#operator.xor)\\n\\nThe `accumulate` function is an algorithm that is very similar to `functools.reduce`, but that produces intermediate results. You can learn about `reduce` [here](mathspp.com/blog/pydonts/the-power-of-reduce).\\nIt just applies the same function iteratively along a list (the function we want is the `xor` function), but it gives you the intermediate results.\\n\\nThat line of code is more or less equivalent to the following piece of code:\\n\\n```py\\nresult = [first]\\nfor num in encoded:\\n\\tresult.append(result[-1] ^ num)\\n```\\n\\nAnd the final result is stored in there.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```py\\nreturn itertools.accumulate(encoded, operator.xor, initial=first)\\n```\n```py\\nresult = [first]\\nfor num in encoded:\\n\\tresult.append(result[-1] ^ num)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3435620,
                "title": "easy-to-understand-c-code-time-complexity-o-n-space-complexity-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    XOR the elements and storing it into vector.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n) - As we are only traversing the encoded vector once.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int> ans;\\n        ans.push_back(first);\\n        int ele = first;\\n        for(int i = 0 ; i < encoded.size() ; i++)\\n        {\\n            int temp = ele^encoded[i];\\n            ele = temp;\\n            ans.push_back(ele);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int> ans;\\n        ans.push_back(first);\\n        int ele = first;\\n        for(int i = 0 ; i < encoded.size() ; i++)\\n        {\\n            int temp = ele^encoded[i];\\n            ele = temp;\\n            ans.push_back(ele);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1988430,
                "title": "java-100-faster-o-n-solution",
                "content": "# Please Upvote If You Find This Helpful\\n![image](https://assets.leetcode.com/users/images/484f6886-fabf-4a11-b938-3059c8e846de_1651129307.0023184.png)\\n```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int[] ans = new int[encoded.length + 1];\\n        ans[0] = first;\\n        for (int i = 0; i < encoded.length; i++) {\\n            ans[i + 1] = ans[i] ^ encoded[i];\\n        }\\n        return ans;\\n    }\\n}\\n```\\n# Please Upvote If You Find This Helpful",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int[] ans = new int[encoded.length + 1];\\n        ans[0] = first;\\n        for (int i = 0; i < encoded.length; i++) {\\n            ans[i + 1] = ans[i] ^ encoded[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1046860,
                "title": "simple-js-solution",
                "content": "```\\nconst decode = (encoded, first) => {\\n    const out = [first]\\n    encoded.forEach((x, i) => out.push(out[i] ^ x))\\n    return out\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst decode = (encoded, first) => {\\n    const out = [first]\\n    encoded.forEach((x, i) => out.push(out[i] ^ x))\\n    return out\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2478647,
                "title": "c-easy-bit-manipulation",
                "content": "**LOGIC :_**\\n                 ***Inverse of Xor is Xor itself***\\n **eg:**-   7 ^ 6 = 1\\n          now,1 ^ 6 = 7\\n\\t\\t     &, 1 ^ 7 =6\\n*now , lets use yhis concept and do this code :-*\\n\\n**CODE :-**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int>ans;\\n        ans.push_back(first); // as the first element of the ans array is given\\n        for(int i=0;i<encoded.size();i++)\\n        {\\n            int x=ans[i]^encoded[i]; // calculating the next elements using the concept above\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nPlease Upvote if You Like",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int>ans;\\n        ans.push_back(first); // as the first element of the ans array is given\\n        for(int i=0;i<encoded.size();i++)\\n        {\\n            int x=ans[i]^encoded[i]; // calculating the next elements using the concept above\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1048405,
                "title": "c-easy-solution-95-faster-96-5-less-space",
                "content": "Hello everyone,\\nThis solution is following the same basic idea behind all the other solutions you\\'ll find in the discussions but it makes effective use of space and it is fast because it saves a lot of pushing operations in vectors.\\n\\nIf you like it, please upvote! :)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        encoded.insert(encoded.begin(),first);\\n        for(int i = 1; i < encoded.size(); i++)\\n        {\\n            encoded[i] = encoded[i-1]^encoded[i];\\n        }\\n        return encoded;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        encoded.insert(encoded.begin(),first);\\n        for(int i = 1; i < encoded.size(); i++)\\n        {\\n            encoded[i] = encoded[i-1]^encoded[i];\\n        }\\n        return encoded;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1015640,
                "title": "javascript-2-solutions",
                "content": "Using loop\\n```\\nconst decode = (encoded, first) => {\\n\\tlet result = [first];\\n\\n\\tfor (let i = 0; i < encoded.length; i++) {\\n\\t\\tresult.push(result[i] ^ encoded[i]);\\n\\t}\\n\\n\\treturn result;\\n};\\n```\\n\\n\\nUsing reduce\\n```\\nconst decode = (encoded, first) => {\\n\\treturn encoded.reduce(\\n\\t\\t(acc, cv, i) => {\\n\\t\\t\\tacc.push(acc[i] ^ cv);\\n\\n\\t\\t\\treturn acc;\\n\\t\\t},\\n\\t\\t[first]\\n\\t);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst decode = (encoded, first) => {\\n\\tlet result = [first];\\n\\n\\tfor (let i = 0; i < encoded.length; i++) {\\n\\t\\tresult.push(result[i] ^ encoded[i]);\\n\\t}\\n\\n\\treturn result;\\n};\\n```\n```\\nconst decode = (encoded, first) => {\\n\\treturn encoded.reduce(\\n\\t\\t(acc, cv, i) => {\\n\\t\\t\\tacc.push(acc[i] ^ cv);\\n\\n\\t\\t\\treturn acc;\\n\\t\\t},\\n\\t\\t[first]\\n\\t);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2065977,
                "title": "c-best-and-beginner-friendly",
                "content": "upvote if helpful :)\\n```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int>ans;\\n        int x;\\n        ans.push_back(first);\\n        for(int i=0;i<encoded.size();i++){\\n             x=ans[i]^encoded[i];\\n            ans.push_back(x);\\n        }\\n       return ans; \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int>ans;\\n        int x;\\n        ans.push_back(first);\\n        for(int i=0;i<encoded.size();i++){\\n             x=ans[i]^encoded[i];\\n            ans.push_back(x);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3686668,
                "title": "2-line-cpp-solution",
                "content": "# Hint\\nv[i+1]=encoded[i]^v[i]\\n# Approach\\n- Create a new vector v;\\n- push_back(first);\\n- make a loop till end of encoded vector\\n- keep pushing encoded[i]^v[i]\\n- outside the loop return v;\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int>v;\\n        v.push_back(first);\\n        for(int i=0;i<encoded.size();i++)\\n        {\\n        v.push_back(encoded[i]^v[i]);\\n        }\\n        return v;\\n    }\\n};\\n```\\n# Please upvote if you understand!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int>v;\\n        v.push_back(first);\\n        for(int i=0;i<encoded.size();i++)\\n        {\\n        v.push_back(encoded[i]^v[i]);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1572515,
                "title": "c-simple-approach",
                "content": "Logic - First of all push first element (first) in the vector vec. now store the next element in x ( x = encoded[i] ^ arr[i] ) . Now push the value of x in the vector vec. after completing the loop return the vector vec which store all the value of x.\\narr[i]^x=encoded[i]; -->x=encoded[i]^arr[i];  (inverse of XOR is XOR itself)\\n```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int>vec;\\n      int x=0;\\n         vec.push_back(first);        //push first element in vector \\n        for(int i=0;i<encoded.size();i++){\\n       x = encoded[i] ^ vec[i]  ;\\n            vec.push_back(x);\\n        }\\n       return vec; \\n    }\\n};\\n```\\nif you like this solution then please upvote it.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int>vec;\\n      int x=0;\\n         vec.push_back(first);        //push first element in vector \\n        for(int i=0;i<encoded.size();i++){\\n       x = encoded[i] ^ vec[i]  ;\\n            vec.push_back(x);\\n        }\\n       return vec; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1056155,
                "title": "simple-python-3-liner",
                "content": "```\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        arr = [first]\\n        for i in range(0, len(encoded)):\\n            arr.append(arr[i] ^ encoded[i])\\n        return arr\\n```\\nFor more such problems: https://github.com/vanigupta20024/Programming-Challenges",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        arr = [first]\\n        for i in range(0, len(encoded)):\\n            arr.append(arr[i] ^ encoded[i])\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470689,
                "title": "my-decode",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} encoded\\n * @param {number} first\\n * @return {number[]}\\n */\\nvar decode = function (encoded, first) {\\n  const temp = first;\\n\\n  const result = encoded.map(curval => first ^= curval);\\n  result.unshift(temp);\\n\\n  return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} encoded\\n * @param {number} first\\n * @return {number[]}\\n */\\nvar decode = function (encoded, first) {\\n  const temp = first;\\n\\n  const result = encoded.map(curval => first ^= curval);\\n  result.unshift(temp);\\n\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2983504,
                "title": "java-easy-soln-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int arr[]=new int[encoded.length+1];\\n        arr[0]=first;\\n        for(int i=0;i<encoded.length;i++){\\n            arr[i+1]=arr[i]^encoded[i];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int arr[]=new int[encoded.length+1];\\n        arr[0]=first;\\n        for(int i=0;i<encoded.length;i++){\\n            arr[i+1]=arr[i]^encoded[i];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2664498,
                "title": "simple-c-xor",
                "content": "// THIS question is bases on XOR property \\n// if a^b=c then b^c=a and a^c=b\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int>ans;\\n        ans.push_back(first);\\n        for(int i=0;i<encoded.size();i++)\\n        {\\n            ans.push_back(ans[i]^encoded[i]);\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int>ans;\\n        ans.push_back(first);\\n        for(int i=0;i<encoded.size();i++)\\n        {\\n            ans.push_back(ans[i]^encoded[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1625442,
                "title": "python-o-n-tc-o-1-space-complexity-92-100",
                "content": "We avoid O(n) space by directly decoding the original array rather than making a new one. It follows an induction kind of vibe.\\n```\\nclass Solution(object):\\n    def decode(self, encoded, first):\\n        \"\"\"\\n        :type encoded: List[int]\\n        :type first: int\\n        :rtype: List[int]\\n        \"\"\"\\n        encoded.insert(0, first)\\n        for i in range(1, len(encoded)):\\n            encoded[i] = encoded[i]^encoded[i-1]\\n        return encoded\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def decode(self, encoded, first):\\n        \"\"\"\\n        :type encoded: List[int]\\n        :type first: int\\n        :rtype: List[int]\\n        \"\"\"\\n        encoded.insert(0, first)\\n        for i in range(1, len(encoded)):\\n            encoded[i] = encoded[i]^encoded[i-1]\\n        return encoded\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1200363,
                "title": "python3-simple-solution",
                "content": "```\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        arr = [first] \\n        for i in encoded:\\n            arr.append(i^arr[-1])\\n        return arr\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        arr = [first] \\n        for i in encoded:\\n            arr.append(i^arr[-1])\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1156667,
                "title": "rust-8ms-solution-with-scan",
                "content": "```\\nimpl Solution {\\n    pub fn decode(encoded: Vec<i32>, first: i32) -> Vec<i32> {\\n        std::iter::once(&first)\\n            .chain(encoded.iter())\\n            .scan(0, |xored, &x| {\\n                *xored ^= x;\\n                Some(*xored)\\n            })\\n            .collect::<Vec<i32>>()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn decode(encoded: Vec<i32>, first: i32) -> Vec<i32> {\\n        std::iter::once(&first)\\n            .chain(encoded.iter())\\n            .scan(0, |xored, &x| {\\n                *xored ^= x;\\n                Some(*xored)\\n            })\\n            .collect::<Vec<i32>>()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1055052,
                "title": "python-3-solution-optimal-space-and-time-complexity",
                "content": "**First approach:**\\nWe can create a new list with the size of `len(encoded) + 1` and then iterate on encoded list, xor every elements and push it in the new list:\\n- **Time Complexity**: because of iterating over encoded list, if we assume the size of encoded list is `n`, the time complexity would be `O(n)`.\\n- **Space Complexity**: since we define a new list, if we assue the size of the encoded list is `n`, the space complexity would be: `O(n+1)`.\\n\\n```\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n\\t\\tans = [first]\\n        \\n        for i in range(len(encoded)):\\n            ans.append(encoded[i] ^ ans[-1]) \\n       \\n            \\n        return ans\\n```\\n\\n\\n**Second approach:**\\nA better solution is to consider space. We can build the target list in place, without occupying any space.\\n- **Time Complexity:** there is a for loop with the size of the encoded array, if we assume the encoded array size is `n` the time complexity would be `O(n)`,\\n- **Space Complexity**: in this case, since we did not define any new space the space complexity would be: `O(1)`.\\n\\n```\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        encoded.insert(0, first)\\n        \\n        for i in range(1, len(encoded)):\\n            encoded[i] = encoded[i-1] ^ encoded[i] \\n       \\n            \\n        return encoded\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n\\t\\tans = [first]\\n        \\n        for i in range(len(encoded)):\\n            ans.append(encoded[i] ^ ans[-1]) \\n       \\n            \\n        return ans\\n```\n```\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        encoded.insert(0, first)\\n        \\n        for i in range(1, len(encoded)):\\n            encoded[i] = encoded[i-1] ^ encoded[i] \\n       \\n            \\n        return encoded\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1011856,
                "title": "swift-solution",
                "content": "Swift solution\\n```\\nclass Solution {\\n    func decode(_ encoded: [Int], _ first: Int) -> [Int] {\\n        var result: [Int] = [first], decoded = first\\n        for num in encoded {\\n            decoded = num ^ decoded\\n            result.append(decoded)\\n        }\\n        return result\\n    }\\n}\\n```\\nOne-liner\\n```\\nclass Solution {\\n    func decode(_ encoded: [Int], _ first: Int) -> [Int] {\\n        return encoded.reduce(into: [first], { $0.append($0.last! ^ $1) })\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func decode(_ encoded: [Int], _ first: Int) -> [Int] {\\n        var result: [Int] = [first], decoded = first\\n        for num in encoded {\\n            decoded = num ^ decoded\\n            result.append(decoded)\\n        }\\n        return result\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func decode(_ encoded: [Int], _ first: Int) -> [Int] {\\n        return encoded.reduce(into: [first], { $0.append($0.last! ^ $1) })\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656891,
                "title": "3-lines-solution-o-n",
                "content": "# Intuition\\nSince the array contains all the needed information to generate a new one, the initial array can be reused.\\n\\n# Approach\\nThe first element of the result must be added to the beginning of the initial array.\\n`encoded = append([]int{first}, encoded...)`\\nAfter this, the output can be generated by using the `XOR` operation for each element of the array.\\n`encoded[i+1] = encoded[i+1] ^ encoded[i]`\\n\\n# Complexity\\n- Time complexity:\\n`O(n)`\\n\\n- Space complexity:\\n`O(1)`\\n\\n# Code\\n```\\nfunc decode(encoded []int, first int) []int {\\n\\tencoded = append([]int{first}, encoded...)\\n\\tfor i := 0; i < len(encoded)-1; i++ {\\n\\t\\tencoded[i+1] = encoded[i+1] ^ encoded[i]\\n\\t}\\n\\n\\treturn encoded\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc decode(encoded []int, first int) []int {\\n\\tencoded = append([]int{first}, encoded...)\\n\\tfor i := 0; i < len(encoded)-1; i++ {\\n\\t\\tencoded[i+1] = encoded[i+1] ^ encoded[i]\\n\\t}\\n\\n\\treturn encoded\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3099442,
                "title": "java-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n    \\n    int[] result = new int[encoded.length + 1];\\n    result[0] = first;\\n\\n    for (int i = 0; i < encoded.length; i++) {\\n        result[i + 1] = result[i]^encoded[i];\\n    }\\n\\n    return result; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n    \\n    int[] result = new int[encoded.length + 1];\\n    result[0] = first;\\n\\n    for (int i = 0; i < encoded.length; i++) {\\n        result[i + 1] = result[i]^encoded[i];\\n    }\\n\\n    return result; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2846769,
                "title": "c-very-easy-solution",
                "content": "Easy solution with comments\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\nvector decode(vector& encoded, int first) {\\nvector arr;\\narr.push_back(first); // Means Element is pushed at 0th position of arr i.e. arr[0];\\n\\n    for(int i=0;i<encoded.size();i++){\\n     arr.push_back(encoded[i]^arr[i]); //In 1st iteration it takes arr[i] = arr[0],Bcoz i is 0 in 1st itr\\n    }\\n    return arr;\\n}\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\nvector decode(vector& encoded, int first) {\\nvector arr;\\narr.push_back(first); // Means Element is pushed at 0th position of arr i.e. arr[0];\\n\\n    for(int i=0;i<encoded.size();i++){\\n     arr.push_back(encoded[i]^arr[i]); //In 1st iteration it takes arr[i] = arr[0],Bcoz i is 0 in 1st itr\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2704144,
                "title": "java-2ms-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n        //encoded[i] = arr[i]^arr[i + 1]\\n        //encoded[i]^arr[i] = arr[i]^arr[i+1]^arr[i]\\n        //xor two same cancels each other\\n        //encoded[i]^arr[i] = arr[i+1]\\n        //arr[i+1] = encoded[i]^arr[i]\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int[] arr = new int[encoded.length + 1];\\n        arr[0] = first;\\n        for(int i = 0 ; i < encoded.length ; i++){\\n            arr[i+1] = encoded[i]^arr[i];\\n        }\\n        return arr; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int[] arr = new int[encoded.length + 1];\\n        arr[0] = first;\\n        for(int i = 0 ; i < encoded.length ; i++){\\n            arr[i+1] = encoded[i]^arr[i];\\n        }\\n        return arr; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2222397,
                "title": "javascript-inverse-xor",
                "content": "\\nIf `encoded[i] = arr[i] XOR arr[i + 1]` then we need to use inverse XOR to get the answer `arr[i + 1]`.\\nSurprisingly the inverse operation of XOR is XOR.\\n![image](https://assets.leetcode.com/users/images/8e350914-87cb-4fd2-b934-b1f7636b191a_1656669386.0482025.jpeg)\\n\\nSo to get `arr[i + 1]` we need to just change places of the variables: `arr[i + 1] =  arr[i] XOR encoded[i]`.\\nP.S. I chose `arr[i + 1]` and not `arr[i]` because we are decoding and the arr[0] is already know, so we start right from the `arr[1] = arr[0] XOR encoded[0]`.\\n\\n```\\nconst decode = (encoded, first) => {\\n    let arr = [first];\\n    for (let i = 0; i < encoded.length; i++) {\\n        arr[i + 1] = arr[i] ^ encoded[i];\\n    }\\n    return arr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst decode = (encoded, first) => {\\n    let arr = [first];\\n    for (let i = 0; i < encoded.length; i++) {\\n        arr[i + 1] = arr[i] ^ encoded[i];\\n    }\\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2121455,
                "title": "java-solution-xor-operator-easy-o-n-time-complexity",
                "content": "To calculate original array. The first index of original array is already given.\\nAlso it is said that\\nencoded[i] = arr[i] XOR arr[i + 1]\\nFrom here we can deduce that \\narr[i+1] = encoded[i] XOR arr[i] where i starts from 0 < arr.length-1 and arr[0] = first.\\n\\n```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int[] arr = new int[encoded.length+1];\\n        // Given that encoded[i] = arr[i] XOR arr[i + 1]\\n        // then arr[i+1] = encoded[i] XOR arr[i].\\n        arr[0] = first;// Given\\n        for (int i = 0; i <arr.length-1 ; i++) {\\n            arr[i+1] = encoded[i]^arr[i];\\n        }\\n        return arr;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int[] arr = new int[encoded.length+1];\\n        // Given that encoded[i] = arr[i] XOR arr[i + 1]\\n        // then arr[i+1] = encoded[i] XOR arr[i].\\n        arr[0] = first;// Given\\n        for (int i = 0; i <arr.length-1 ; i++) {\\n            arr[i+1] = encoded[i]^arr[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1798490,
                "title": "java-most-easy-solution",
                "content": "\\n\\tclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n       int arr[] = new int[encoded.length+1];\\n       arr[0] = first;\\n        for(int i =0; i<arr.length-1; i++){\\n            arr[i+1] = arr[i]^encoded[i];\\n        }\\n        return arr;\\n       }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] decode(int[] encoded, int first) {\\n       int arr[] = new int[encoded.length+1];\\n       arr[0] = first;\\n        for(int i =0; i<arr.length-1; i++){\\n            arr[i+1] = arr[i]^encoded[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1748315,
                "title": "python-59ms-using-dunder-method",
                "content": "```\\ndef decode(self, encoded: List[int], first: int) -> List[int]:\\n        x=[first]\\n        for i in range (len(encoded)):\\n                x.append(int.__xor__(encoded[i],x[i]))\\n        return x\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef decode(self, encoded: List[int], first: int) -> List[int]:\\n        x=[first]\\n        for i in range (len(encoded)):\\n                x.append(int.__xor__(encoded[i],x[i]))\\n        return x\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1662221,
                "title": "easy-and-beginner-friendly-o-n-solution",
                "content": "Just iterate over the for loop\\n```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int>ans(encoded.size()+1);\\n        ans[0] = first;\\n        for(int i = 0 ; i < encoded.size() ; i++){\\n            ans[i+1] = ans[i] ^ encoded[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int>ans(encoded.size()+1);\\n        ans[0] = first;\\n        for(int i = 0 ; i < encoded.size() ; i++){\\n            ans[i+1] = ans[i] ^ encoded[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1033953,
                "title": "python-prefix-sum-like-solution",
                "content": "```py\\n\\'\\'\\'\\nw: array\\nh: prefix sum like solution\\n   a ^ b = c  --> b = a ^ c\\n\\'\\'\\'\\n\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        res = [first]\\n        for i in encoded:\\n            res.append(res[-1]^i)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```py\\n\\'\\'\\'\\nw: array\\nh: prefix sum like solution\\n   a ^ b = c  --> b = a ^ c\\n\\'\\'\\'\\n\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        res = [first]\\n        for i in encoded:\\n            res.append(res[-1]^i)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1016610,
                "title": "java-solution-o-n-100-faster-and-99-less-memory",
                "content": "public int[] decode(int[] encoded, int first) {\\n\\n        int len = encoded.length;\\n        int arr[] = new int[len+1];\\n        \\n        arr[0] = first;\\n        for(int i = 1; i <= len; i++) {\\n            arr[i] = encoded[i - 1] ^ arr[i - 1];\\n        }\\n        \\n        return arr;\\n    }",
                "solutionTags": [],
                "code": "public int[] decode(int[] encoded, int first) {\\n\\n        int len = encoded.length;\\n        int arr[] = new int[len+1];\\n        \\n        arr[0] = first;\\n        for(int i = 1; i <= len; i++) {\\n            arr[i] = encoded[i - 1] ^ arr[i - 1];\\n        }\\n        \\n        return arr;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1009783,
                "title": "python3-scan-o-n",
                "content": "\\nAlgo\\nUtilzing the fact that `x ^ x = 0` and `x ^ 0 = x`. \\n\\nImplementation\\n```\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        ans = [first]\\n        for x in encoded: \\n            ans.append(ans[-1] ^ x)\\n        return ans \\n```\\n\\nAnalysis\\nTime complexity `O(N)`\\nSpace complexity `O(N)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        ans = [first]\\n        for x in encoded: \\n            ans.append(ans[-1] ^ x)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977409,
                "title": "easy-solution-explained",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        result = []\\n        for i in range(0, len(encoded)+1):\\n            if(i == 0):\\n                result.append(0^first)\\n            else:\\n                result.append(encoded[i-1]^result[i-1])\\n        return result\\n\\n\\'\\'\\'\\nAccording to the property of XOR we know that if c = a ^ b, we can get back a or b if you have other value. \\ni.e:\\na = c ^ b\\nb = c ^ a\\nAnd order need not necessarily be the same\\n\\nSo in this question, we can write the above property as:\\nencoded[i] = arr[i] ^ arr[i+1]\\n\\nWe have encoded array in our hands, and we want the resultant, so simply interchange them:\\nresult[0] = first\\nresult[i+1] = result[i] ^ encoded[i]\\n\\'\\'\\'\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        result = []\\n        for i in range(0, len(encoded)+1):\\n            if(i == 0):\\n                result.append(0^first)\\n            else:\\n                result.append(encoded[i-1]^result[i-1])\\n        return result\\n\\n\\'\\'\\'\\nAccording to the property of XOR we know that if c = a ^ b, we can get back a or b if you have other value. \\ni.e:\\na = c ^ b\\nb = c ^ a\\nAnd order need not necessarily be the same\\n\\nSo in this question, we can write the above property as:\\nencoded[i] = arr[i] ^ arr[i+1]\\n\\nWe have encoded array in our hands, and we want the resultant, so simply interchange them:\\nresult[0] = first\\nresult[i+1] = result[i] ^ encoded[i]\\n\\'\\'\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830557,
                "title": "beats-100-very-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int[] result=new int[encoded.length+1];\\n        result[0]=first;\\n        for(int i=0;i<encoded.length;i++)\\n        {\\n            result[i+1]=encoded[i] ^ result[i];\\n        }\\n        return result;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int[] result=new int[encoded.length+1];\\n        result[0]=first;\\n        for(int i=0;i<encoded.length;i++)\\n        {\\n            result[i+1]=encoded[i] ^ result[i];\\n        }\\n        return result;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830362,
                "title": "simple-java-solution-2ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int[] ans=new int[encoded.length+1];\\n        ans[0]=first;\\n        for(int i=0;i<encoded.length+1-1;i++)\\n        {\\n            ans[i+1]=encoded[i] ^ ans[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int[] ans=new int[encoded.length+1];\\n        ans[0]=first;\\n        for(int i=0;i<encoded.length+1-1;i++)\\n        {\\n            ans[i+1]=encoded[i] ^ ans[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517488,
                "title": "java-simle-solution",
                "content": "Simple and imtuitive Java solution\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int[] decode(int[] encoded, int first) {\\n        int[] decoded = new int[encoded.length + 1];\\n        decoded[0] = first;\\n        \\n        for (int elementIndex = 0; elementIndex < encoded.length; elementIndex++) {\\n            decoded[elementIndex + 1] = encoded[elementIndex] ^ decoded[elementIndex];\\n        }\\n        \\n        return decoded;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int[] decode(int[] encoded, int first) {\\n        int[] decoded = new int[encoded.length + 1];\\n        decoded[0] = first;\\n        \\n        for (int elementIndex = 0; elementIndex < encoded.length; elementIndex++) {\\n            decoded[elementIndex + 1] = encoded[elementIndex] ^ decoded[elementIndex];\\n        }\\n        \\n        return decoded;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454908,
                "title": "java-xor-decoder-fascinating-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int size = encoded.length+1, numStore = first;\\n        int[] arr = new int[size];\\n        \\n        for(int i = 0; i < size; i++){\\n            if(i < size-1){\\n            arr[i] = numStore;\\n            numStore = encoded[i]^numStore;\\n            }else\\n            arr[i] = numStore;\\n        }\\n        \\n        return arr;\\n    }\\n}\\n```\\nPlease upvote me, it encourages me a lot!!",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int size = encoded.length+1, numStore = first;\\n        int[] arr = new int[size];\\n        \\n        for(int i = 0; i < size; i++){\\n            if(i < size-1){\\n            arr[i] = numStore;\\n            numStore = encoded[i]^numStore;\\n            }else\\n            arr[i] = numStore;\\n        }\\n        \\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3414944,
                "title": "decode-xored-array-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        int i;\\n        vector<int> ans;\\n        ans.push_back(first);\\n        for(i=0 ; i<encoded.size() ; i++)\\n        {\\n            ans.push_back(encoded[i]^ans[ans.size()-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        int i;\\n        vector<int> ans;\\n        ans.push_back(first);\\n        for(i=0 ; i<encoded.size() ; i++)\\n        {\\n            ans.push_back(encoded[i]^ans[ans.size()-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259252,
                "title": "beginner-friendly-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple approach, understand the question what it is asking for?\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int[] result = new int[encoded.length + 1];\\n        result[0] = first;\\n        for (int i = 0; i < encoded.length; i++) {\\n            result[i + 1] = result[i] ^ encoded[i];\\n            }\\n        return result;\\n        }\\n        \\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int[] result = new int[encoded.length + 1];\\n        result[0] = first;\\n        for (int i = 0; i < encoded.length; i++) {\\n            result[i + 1] = result[i] ^ encoded[i];\\n            }\\n        return result;\\n        }\\n        \\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3150360,
                "title": "c-two-different-solution-beat-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n We Have given first element of (arr) .\\n What We have to do?\\nThe XOR result of consecutive elements of arr should be equal to encoded array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe created a new array  (ARR )and inserted given first elemnet of it and then inserted remaining elements into it.\\nthen we havr to check consecutively XOR or current index and previous index and store result into current index.\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n    // in this solution we are not creating a new array.      \\n    //just inserting the given first element into same array.\\n    // remaining procedure is same checking XOR of current index \\n    //and previous index and inserting result in current index.\\n\\n     \\n    class Solution{\\n    public:\\n    vector<int>& encoded,int first}{  \\n    encoded.insert(encoded.begin(),first);\\n        for(int i=1;i<encoded.size();i++)\\n        {\\n        encoded[i] = encoded[i] xor  encoded[i-1];\\n        }\\n        return encoded;\\n    }};\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        // create array which holds the answer \\n        vector<int>arr;\\n\\n        // since first element is given we pushed into new array\\n        arr.push_back(first);\\n\\n        // and pushing remaining elements of encoded into new array\\n        for(int i=0;i<encoded.size();i++)\\n            arr.push_back(encoded[i]);\\n\\n        // checking xor of current index with previous index    \\n        for(int i=1;i<arr.size();i++)\\n        arr[i] = arr[i] xor  arr[i-1];\\n        \\n        // returning the obtained array\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        // create array which holds the answer \\n        vector<int>arr;\\n\\n        // since first element is given we pushed into new array\\n        arr.push_back(first);\\n\\n        // and pushing remaining elements of encoded into new array\\n        for(int i=0;i<encoded.size();i++)\\n            arr.push_back(encoded[i]);\\n\\n        // checking xor of current index with previous index    \\n        for(int i=1;i<arr.size();i++)\\n        arr[i] = arr[i] xor  arr[i-1];\\n        \\n        // returning the obtained array\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3128529,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        \\n\\n        \\n        vector<int> ans;\\n        int n=encoded.size();\\n        ans.push_back(first);\\n        int temp=first;\\n        for(int i=0;i<n;i++)\\n        {\\n            temp=encoded[i]^temp;\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        \\n\\n        \\n        vector<int> ans;\\n        int n=encoded.size();\\n        ans.push_back(first);\\n        int temp=first;\\n        for(int i=0;i<n;i++)\\n        {\\n            temp=encoded[i]^temp;\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2865988,
                "title": "c-easy-solution-beats-87",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        int n=encoded.size();\\n        vector<int>v(n+1);\\n        v[0]=first;\\n        for(int i=1;i<=n;++i)\\n        {\\n            v[i]=encoded[i-1]^v[i-1];\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        int n=encoded.size();\\n        vector<int>v(n+1);\\n        v[0]=first;\\n        for(int i=1;i<=n;++i)\\n        {\\n            v[i]=encoded[i-1]^v[i-1];\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777104,
                "title": "java-4line-code-100-faster",
                "content": "```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int[]arr=new int[encoded.length+1];\\n        arr[0]=first;\\n        for(int i=1;i<encoded.length+1;i++){\\n            arr[i]=arr[i-1]^encoded[i-1];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int[]arr=new int[encoded.length+1];\\n        arr[0]=first;\\n        for(int i=1;i<encoded.length+1;i++){\\n            arr[i]=arr[i-1]^encoded[i-1];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2548071,
                "title": "90-time-beats-time-o-n-space-o-ans-size-c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int &first) {\\n        vector<int> ans = {first};\\n        first = 0;\\n        for(auto &i: encoded){\\n            ans.push_back((i^ans[first]));\\n            first++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int &first) {\\n        vector<int> ans = {first};\\n        first = 0;\\n        for(auto &i: encoded){\\n            ans.push_back((i^ans[first]));\\n            first++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2223405,
                "title": "https-leetcode-com-problems-decode-xored-array",
                "content": "class Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int> arr;\\n        arr.push_back(first);\\n        for(int i=0;i<encoded.size();i++){\\n           arr.push_back(arr[i]^encoded[i]);\\n\\t\\t   \\n          \\n        }\\n        return arr;\\n        \\n    }\\n};\\nif you like it please upvote",
                "solutionTags": [
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int> arr;\\n        arr.push_back(first);\\n        for(int i=0;i<encoded.size();i++){\\n           arr.push_back(arr[i]^encoded[i]);\\n\\t\\t   \\n          \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2221022,
                "title": "faang-optimised-code-0-n",
                "content": "# upvote PLZ \\n```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int> res;\\n        res.emplace_back(first);\\n        for(int i = 0 ; i < encoded.size() ; i++){\\n            res.emplace_back(encoded[i] ^ res[i]);  \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int> res;\\n        res.emplace_back(first);\\n        for(int i = 0 ; i < encoded.size() ; i++){\\n            res.emplace_back(encoded[i] ^ res[i]);  \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2203769,
                "title": "swift-solution-array",
                "content": "```\\nclass Solution {\\n    func decode(_ encoded: [Int], _ first: Int) -> [Int] {\\n        var res=[Int]()\\n        res.append(first)\\n        for i in 0..<encoded.count{\\n            res.append(encoded[i]^res[i])\\n        }\\n        \\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    func decode(_ encoded: [Int], _ first: Int) -> [Int] {\\n        var res=[Int]()\\n        res.append(first)\\n        for i in 0..<encoded.count{\\n            res.append(encoded[i]^res[i])\\n        }\\n        \\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2107967,
                "title": "short-javascript-solution",
                "content": "Found this solution helpful? Consider showing support by upvoting this post.\\nHave a question? Kindly leave a comment below.\\nThank you and happy hacking!\\n```\\nvar decode = function (encoded, first) {\\n    let result = [first];\\n\\n    for (let i = 0; i < encoded.length; i++) {\\n        result.push(result[result.length - 1] ^ encoded[i])\\n    }\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar decode = function (encoded, first) {\\n    let result = [first];\\n\\n    for (let i = 0; i < encoded.length; i++) {\\n        result.push(result[result.length - 1] ^ encoded[i])\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1988002,
                "title": "c-solution-o-n-with-explanation",
                "content": "```\\npublic class Solution {\\n\\t// O(N) Solution\\n    // encoded[i] = arr[i] XOR arr[i+1]\\n    // let: arr[i] = A, arr[i+1] = B, encoded[i] = C\\n    // then: A XOR B = C\\n    // from XOR properties this implies\\n    // C XOR A = B\\n    // therefore: encoded[i] XOR arr[i] = arr[i+1]\\n    public int[] Decode(int[] encoded, int first) {\\n        var arr = new int[encoded.Length+1];\\n        arr[0] = first;\\n        for(int i=0; i<encoded.Length; i++){\\n            arr[i+1] = encoded[i] ^ arr[i];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n\\t// O(N) Solution\\n    // encoded[i] = arr[i] XOR arr[i+1]\\n    // let: arr[i] = A, arr[i+1] = B, encoded[i] = C\\n    // then: A XOR B = C\\n    // from XOR properties this implies\\n    // C XOR A = B\\n    // therefore: encoded[i] XOR arr[i] = arr[i+1]\\n    public int[] Decode(int[] encoded, int first) {\\n        var arr = new int[encoded.Length+1];\\n        arr[0] = first;\\n        for(int i=0; i<encoded.Length; i++){\\n            arr[i+1] = encoded[i] ^ arr[i];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1946743,
                "title": "simplest-solution-in-java",
                "content": "**The reverse of any xor operation is itself. This is a fundamental property of xor, applying it twice gets you back where you started.**\\n```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int arr[] = new int[encoded.length + 1];\\n        arr[0] = first;\\n        int j = 0;\\n        j++;\\n        for (int i = 0; i < encoded.length; i++) {\\n            arr[j] = encoded[i] ^ first;\\n            first = arr[j];\\n            j++;\\n\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int arr[] = new int[encoded.length + 1];\\n        arr[0] = first;\\n        int j = 0;\\n        j++;\\n        for (int i = 0; i < encoded.length; i++) {\\n            arr[j] = encoded[i] ^ first;\\n            first = arr[j];\\n            j++;\\n\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1927236,
                "title": "c-solution-simple-and-easy-to-understand",
                "content": "class Solution {\\npublic:\\n\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int> v;\\n        int ele = first;\\n        v.push_back(ele);\\n        for (int i = 0; i < encoded.size(); i++)\\n        {\\n            ele = encoded[i] ^ ele;\\n            v.push_back(ele);\\n        }\\n        return v;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int> v;\\n        int ele = first;\\n        v.push_back(ele);\\n        for (int i = 0; i < encoded.size(); i++)\\n        {\\n            ele = encoded[i] ^ ele;\\n            v.push_back(ele);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1833405,
                "title": "simple-c-soln-easy-to-understand",
                "content": "**class Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int> ans(encoded.size()+1);\\n        ans[0] = first;\\n        for(int i =0;i<encoded.size();i++)\\n          ans[i+1] = ans[i]^encoded[i];\\n        return ans;\\n    }\\n};**",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int> ans(encoded.size()+1);\\n        ans[0] = first;\\n        for(int i =0;i<encoded.size();i++)\\n          ans[i+1] = ans[i]^encoded[i];\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1687011,
                "title": "easy-explanations-c-o-n-conceptual-xor-property-explained",
                "content": "**EXPLAINATION**\\nThere is a important property of XOR that is :\\n    If a^b = c which can be written as b = c^a we can transfer the XOR operation\\n    E.g :                 \\n            Orig Arr:    [a   b   c   d   e]    We know \\'a\\' here \\n            Encoded :      [6   2   7   3]\\n\\t\\t\\t;\\n\\t\\t\\tHere 6 means a^b\\n                 2 means b^c\\n                 7 means c^d\\n                 3 means d^e\\n\\t\\t\\t\\t :\\n            By this we get \\n            :\\n            6 = a^b    where a = 4\\n            6 = 4^b    using XOR Property\\n            b = 4^6\\n            b = 2     we get our b \\n            :\\n            Similarly we do this for c, d, e\\n```\\nclass Solution \\n{\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) \\n    {\\n        int n = encoded.size();\\n        vector<int> ans(n+1 , 0);\\n        ans[0] = first;\\n        for(int i=1 ; i<=n ; i++)\\n            ans[i] = ans[i-1]^encoded[i-1];\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) \\n    {\\n        int n = encoded.size();\\n        vector<int> ans(n+1 , 0);\\n        ans[0] = first;\\n        for(int i=1 ; i<=n ; i++)\\n            ans[i] = ans[i-1]^encoded[i-1];\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610810,
                "title": "c-memory-efficient-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        encoded.insert(encoded.begin(),first);\\n        for(int i=1;i<encoded.size();i++){\\n            encoded[i]=encoded[i] ^ encoded[i-1];\\n        }\\n        return encoded;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        encoded.insert(encoded.begin(),first);\\n        for(int i=1;i<encoded.size();i++){\\n            encoded[i]=encoded[i] ^ encoded[i-1];\\n        }\\n        return encoded;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549900,
                "title": "concise-pythonic-way-o-n-time-complexity-o-n-space-complexity",
                "content": "```\\nclass Solution(object):\\n    def decode(self, encoded, first):\\n        arr = [first]\\n        for en in encoded:\\n            arr.append(arr[-1] ^ en)\\n        return arr\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def decode(self, encoded, first):\\n        arr = [first]\\n        for en in encoded:\\n            arr.append(arr[-1] ^ en)\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1325242,
                "title": "python-o-n-solution",
                "content": "```\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        ans=[first]\\n        for i in range(len(encoded)):\\n            ans.append(ans[-1]^encoded[i])\\n        return ans",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        ans=[first]\\n        for i in range(len(encoded)):\\n            ans.append(ans[-1]^encoded[i])\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1287917,
                "title": "implement-c-code-in-4-lines",
                "content": "Time Complexity: O(n)\\nSpace Complexity: O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int> ans;\\n        ans.push_back(first);\\n        for(int i=0; i<encoded.size(); i++) ans.push_back(ans[i]^encoded[i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int> ans;\\n        ans.push_back(first);\\n        for(int i=0; i<encoded.size(); i++) ans.push_back(ans[i]^encoded[i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1267100,
                "title": "java-easy-solution-1ms-100-faster",
                "content": "```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        \\n        int[] arr = new int[encoded.length+1];\\n        \\n        arr[0] = first;\\n        \\n        for(int i = 0; i<encoded.length; i++){\\n            \\n            arr[i+1] = encoded[i] ^ arr[i];\\n            \\n        }\\n        \\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        \\n        int[] arr = new int[encoded.length+1];\\n        \\n        arr[0] = first;\\n        \\n        for(int i = 0; i<encoded.length; i++){\\n            \\n            arr[i+1] = encoded[i] ^ arr[i];\\n            \\n        }\\n        \\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1231233,
                "title": "simple-c-solution",
                "content": "class Solution {\\npublic:\\n    vector<int> decode(vector<int>& e, int f) {\\n        int n=e.size();\\n        vector<int> a(n+1);\\n        /*\\n        as e[i]=a[i]^a[i+1];\\n        now e[i]^e[i]^a[i+1] which is equalent to a[i+1] also equlant to a[i]^a[i+1]^e[i]^a[i+1] (putting first e[i] as a[i]^a[i+1]);\\n        so, a[i+1]=a[i]^e[i];\\n        */\\n        a[0]=f;\\n        for(int i=0;i<n;i++){\\n            a[i+1]=a[i]^e[i];\\n        }\\n        return a;\\n    }\\n};\\n\\nUpvote if you like it.",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> decode(vector<int>& e, int f) {\\n        int n=e.size();\\n        vector<int> a(n+1);\\n        /*\\n        as e[i]=a[i]^a[i+1];\\n        now e[i]^e[i]^a[i+1] which is equalent to a[i+1] also equlant to a[i]^a[i+1]^e[i]^a[i+1] (putting first e[i] as a[i]^a[i+1]);\\n        so, a[i+1]=a[i]^e[i];\\n        */\\n        a[0]=f;\\n        for(int i=0;i<n;i++){\\n            a[i+1]=a[i]^e[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1214466,
                "title": "java-100-fast-easy",
                "content": "\\'\\'\\'\\n\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n       \\n        int[] result = new int[encoded.length+1];\\n        result[0] = first;\\n        \\n        for(int i=0; i<encoded.length;i++){\\n            result[i+1] = result[i] ^ encoded[i];\\n        }\\n        return result;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] decode(int[] encoded, int first) {\\n       \\n        int[] result = new int[encoded.length+1];\\n        result[0] = first;\\n        \\n        for(int i=0; i<encoded.length;i++){\\n            result[i+1] = result[i] ^ encoded[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1203390,
                "title": "c",
                "content": "```\\n* Two pass with O(n) time complexity and O(1) Space Complexity\\nvector<int> decode(vector<int>& encoded, int first) {\\n        encoded.resize(encoded.size()+1);\\n        for(int i=encoded.size()-2;i>=0;i--){\\n                encoded[i+1] = encoded[i];  //Shift all the array element in th same array\\n        }\\n        \\n        encoded[0] = first; //substitue the first number as the first array element.\\n        for(int i=1;i<encoded.size();i++){\\n            encoded[i] = encoded[i]^encoded[i-1]; //Xor the array with previosu element\\n        }\\n        return encoded;\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n* Two pass with O(n) time complexity and O(1) Space Complexity\\nvector<int> decode(vector<int>& encoded, int first) {\\n        encoded.resize(encoded.size()+1);\\n        for(int i=encoded.size()-2;i>=0;i--){\\n                encoded[i+1] = encoded[i];  //Shift all the array element in th same array\\n        }\\n        \\n        encoded[0] = first; //substitue the first number as the first array element.\\n        for(int i=1;i<encoded.size();i++){\\n            encoded[i] = encoded[i]^encoded[i-1]; //Xor the array with previosu element\\n        }\\n        return encoded;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1160088,
                "title": "1ms-100-faster-using-simple-xor",
                "content": "The inverse of XOR is XOR itself.\\n```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int [] result = new int [encoded.length+1];\\n        result[0] = first;\\n        int i=1;\\n        for(int num:encoded)\\n        {\\n            result[i] = num ^ result[i-1];\\n            i++;\\n\\n        }\\n        return result;\\n    }\\n}\\n```\\nPS: Do upvote if you like the solution",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int [] result = new int [encoded.length+1];\\n        result[0] = first;\\n        int i=1;\\n        for(int num:encoded)\\n        {\\n            result[i] = num ^ result[i-1];\\n            i++;\\n\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1131773,
                "title": "c-solution-property-of-xor-used-here-is-a-b-k-a",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        // to solve this question, have this property of XOR in your mind\\n        // for two numbers a and b\\n        // a^b = k ^ a (in this question we have to find this number b)\\n        // so just xor the current element of encoded vector with the last element pushed back\\n        // in the vector of the answer.\\n        vector<int>decode;\\n        decode.push_back(first); // pushing back the first element\\n        \\n        int size = encoded.size();\\n       for(int i = 0;i < size;i++){\\n           decode.push_back(encoded[i] ^ decode.back());\\n           // pushing back the xor using property a ^ b = k ^ a;\\n       }\\n        \\n        return decode;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        // to solve this question, have this property of XOR in your mind\\n        // for two numbers a and b\\n        // a^b = k ^ a (in this question we have to find this number b)\\n        // so just xor the current element of encoded vector with the last element pushed back\\n        // in the vector of the answer.\\n        vector<int>decode;\\n        decode.push_back(first); // pushing back the first element\\n        \\n        int size = encoded.size();\\n       for(int i = 0;i < size;i++){\\n           decode.push_back(encoded[i] ^ decode.back());\\n           // pushing back the xor using property a ^ b = k ^ a;\\n       }\\n        \\n        return decode;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1066840,
                "title": "java-easy-and-fast",
                "content": "if you like it pls upvote\\n\\nJava\\n\\n```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int[]res = new int[encoded.length+1];\\n        \\n        res[0] = first;\\n        \\n        for(int i = 0;i<encoded.length;i++){\\n            res[i+1] = res[i]^encoded[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int[]res = new int[encoded.length+1];\\n        \\n        res[0] = first;\\n        \\n        for(int i = 0;i<encoded.length;i++){\\n            res[i+1] = res[i]^encoded[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1030757,
                "title": "javascript-1-line-solution",
                "content": "```\\nvar decode = function(encoded, first) {\\n    return [first].concat(encoded).map((x,i,a)=>{return i===0? x : a[i] ^= a[i-1]});\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar decode = function(encoded, first) {\\n    return [first].concat(encoded).map((x,i,a)=>{return i===0? x : a[i] ^= a[i-1]});\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1025097,
                "title": "ruby-one-liner",
                "content": "```\\ndef decode(e, f)\\n  [f, *e.map { |x| f ^= x }]\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef decode(e, f)\\n  [f, *e.map { |x| f ^= x }]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1012920,
                "title": "python-3-liner-easy-solution-with-explanation",
                "content": "```\\nPlatform: leetcode.com\\n1720. Decode XORed Array\\nLink: https://leetcode.com/problems/decode-xored-array/\\nDifficulty: Easy\\nAuthor: hritik5102\\nDate: 12/2/2021\\nSubmission: https://leetcode.com/submissions/detail/441977780/\\n(Time, Space) Complexity : O(n), O(n)\\n```\\n\\n## According to Xor property \\n\\nThe inverse is XOR!\\n\\nIf you have:\\n\\nc = a^b;\\nYou can get a or b back if you have the other value available:\\n\\na = c^b; // or b^c (order is not important)\\nb = c^a; // or a^c\\n\\n> encoded[i] = arr[i] ^ arr[i+1]  \\n\\nHere we have an encoded array, and we want a resultant array, so we can interchange\\n\\n> res[0] = first\\n> res[i+1] = res[i] ^ encoded[i]\\n \\n```\\nclass Solution:\\n    def decode(self, encoded, first):\\n        res = []\\n        for i in range(0,len(encoded)+1):\\n            res.append(0^first if i==0 else encoded[i-1]^res[i-1])\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nPlatform: leetcode.com\\n1720. Decode XORed Array\\nLink: https://leetcode.com/problems/decode-xored-array/\\nDifficulty: Easy\\nAuthor: hritik5102\\nDate: 12/2/2021\\nSubmission: https://leetcode.com/submissions/detail/441977780/\\n(Time, Space) Complexity : O(n), O(n)\\n```\n```\\nclass Solution:\\n    def decode(self, encoded, first):\\n        res = []\\n        for i in range(0,len(encoded)+1):\\n            res.append(0^first if i==0 else encoded[i-1]^res[i-1])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1010949,
                "title": "javascript-fastest-solution",
                "content": "```javascript\\n/**\\n * @param {number[]} encoded\\n * @param {number} first\\n * @return {number[]}\\n */\\nvar decode = function(encoded, first) {\\n    let result = [first]\\n   for(let i = 0; i < encoded.length ; i++) {\\n      result.push(first ^= encoded[i])\\n   }\\n    return result\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} encoded\\n * @param {number} first\\n * @return {number[]}\\n */\\nvar decode = function(encoded, first) {\\n    let result = [first]\\n   for(let i = 0; i < encoded.length ; i++) {\\n      result.push(first ^= encoded[i])\\n   }\\n    return result\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1009850,
                "title": "simple-solution-in-java-using-array-only",
                "content": "class Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int x[]=new int[encoded.length+1];\\n        x[0]=first;\\n        for(int i=0;i<encoded.length;i++){\\n            x[i+1]=encoded[i]^x[i];\\n            \\n        }\\n        return x;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int x[]=new int[encoded.length+1];\\n        x[0]=first;\\n        for(int i=0;i<encoded.length;i++){\\n            x[i+1]=encoded[i]^x[i];\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1009846,
                "title": "java-0-n",
                "content": "```\\npublic int[] decode(int[] encoded, int first) {\\n\\tint[] result = new int[encoded.length + 1];\\n\\tresult[0] = first;\\n\\tfor(int i=0;i<encoded.length;i++)\\n\\t\\tresult[i+1] = result[i] ^ encoded[i];\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] decode(int[] encoded, int first) {\\n\\tint[] result = new int[encoded.length + 1];\\n\\tresult[0] = first;\\n\\tfor(int i=0;i<encoded.length;i++)\\n\\t\\tresult[i+1] = result[i] ^ encoded[i];\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1009775,
                "title": "python-3",
                "content": "How ```XOR``` works:\\n```\\nFirst XOR origVal   = encodeVal\\nFirst XOR encodeVal = origVal\\n```\\nWe are applying this iteratively on whole sequence.\\n```\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        a=first\\n        for i in range(len(encoded)):\\n            encoded[i]=a ^ encoded[i]\\n            a=encoded[i]\\n        return [first]+encoded\\n```",
                "solutionTags": [],
                "code": "```XOR```\n```\\nFirst XOR origVal   = encodeVal\\nFirst XOR encodeVal = origVal\\n```\n```\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        a=first\\n        for i in range(len(encoded)):\\n            encoded[i]=a ^ encoded[i]\\n            a=encoded[i]\\n        return [first]+encoded\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009766,
                "title": "kt-js-py3-cpp-xor-last",
                "content": "**Synopsis:**\\n\\nConstruct the answer `ans` by initializing `ans = [ K ]`, where the input `K` is the first value of the answer.  Then construct the remaining `N - 1` values of the answer by xor\\'ing each value `x` of the input array `A` with the last value of the answer `ans` so far.\\n\\n---\\n\\n**Contest 223 Screenshare:**\\n\\n![image](https://assets.leetcode.com/users/images/a4c3c7cc-1a32-4b20-92e0-3d8b12890fe2_1610252252.408869.png)\\n\\nhttps://www.youtube.com/watch?v=aA97JUqchWM\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun decode(A: IntArray, K: Int): IntArray {\\n        var ans = mutableListOf<Int>(K)\\n        A.forEach{ ans.add(it xor ans.last()) }\\n        return ans.toIntArray()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet decode = (A, K, ans = [K]) => {\\n    for (let x of A)\\n        ans.push(x ^ ans[ans.length - 1]);\\n    return ans;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def decode(self, A: List[int], K: int) -> List[int]:\\n        ans = [ K ]\\n        for x in A:\\n            ans.append(x ^ ans[-1])\\n        return ans\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    VI decode(VI& A, int K) {\\n        VI ans{ K };\\n        for (auto x: A)\\n            ans.push_back(x ^ ans.back());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun decode(A: IntArray, K: Int): IntArray {\\n        var ans = mutableListOf<Int>(K)\\n        A.forEach{ ans.add(it xor ans.last()) }\\n        return ans.toIntArray()\\n    }\\n}\\n```\n```\\nlet decode = (A, K, ans = [K]) => {\\n    for (let x of A)\\n        ans.push(x ^ ans[ans.length - 1]);\\n    return ans;\\n};\\n```\n```\\nclass Solution:\\n    def decode(self, A: List[int], K: int) -> List[int]:\\n        ans = [ K ]\\n        for x in A:\\n            ans.append(x ^ ans[-1])\\n        return ans\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    VI decode(VI& A, int K) {\\n        VI ans{ K };\\n        for (auto x: A)\\n            ans.push_back(x ^ ans.back());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081581,
                "title": "decoding-xor-logic-for-efficient-o-n-solutions-typescript-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    A ^ A = 0 (for any number A)\\n    A ^ 0 = A (for any number A)\\n    A ^ B ^ A = B (for any numbers A and B)\\n- XOR operation is reversible. \\n- Xoring a and b will give c\\n- a^b = c, here we know `a` value is equal to `first`\\n- if we reverse then, Xoring b and c will give a\\n- b^c = a \\n- Starting with the first element, we XOR it with each element in the encoded array to reconstruct the original array. The first element acts as the base from which we rebuild the array using XOR operations.\\n\\n-  Start with the first element in the original array.\\n\\n- For each i from 0 to n (where n is the length of the encoded array)\\n- Decode the next element in the original array using XOR: decodedArr[i+1] = encoded[i] ^ decodedArr[i].\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\na. Initialize an empty array arr.\\n\\nb. Push the given first element into arr.\\n\\nc. Iterate through the encoded array:\\n\\n- Calculate the next element in the original array by XORing the last element added to arr with the corresponding element from encoded.\\n    Push this calculated element into arr.\\n\\nd. Return the resulting arr.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction decode(encoded: number[], first: number): number[] {\\n\\n  // initializes an empty array decodedArr to store the decoded XOR values.\\n  const decodedArr: number[] = []\\n\\n  // Push the given first element into arr.\\n  decodedArr.push(first)\\n\\n  // Iterate through the encoded array\\n  for(let i=0; i<encoded.length; i++){\\n\\n    // XOR the last element added to decodedArr with the corresponding element from encoded.\\n    decodedArr.push(decodedArr[i] ^ encoded[i])\\n  }\\n\\n  return decodedArr\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction decode(encoded: number[], first: number): number[] {\\n\\n  // initializes an empty array decodedArr to store the decoded XOR values.\\n  const decodedArr: number[] = []\\n\\n  // Push the given first element into arr.\\n  decodedArr.push(first)\\n\\n  // Iterate through the encoded array\\n  for(let i=0; i<encoded.length; i++){\\n\\n    // XOR the last element added to decodedArr with the corresponding element from encoded.\\n    decodedArr.push(decodedArr[i] ^ encoded[i])\\n  }\\n\\n  return decodedArr\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4081266,
                "title": "typescript-javascript-o-n-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$(not including the ans array)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction decode(encoded: number[], first: number): number[] {\\n  const n = encoded.length;\\n  const ans: number[] = [first];\\n\\n  // the inverse of xor is xor\\n  // i.e if a ^ b = c then b ^ c = a\\n  // where c and a will have same value\\n  // in the given problem the first element\\n  // of the array is given, so we\\'ll xor the\\n  // first element of both the array and then\\n  // push the result to the ans where it\\'ll be\\n  // used in the next iterations\\n  for (let i = 0; i < n; i++) {\\n    ans.push(encoded[i] ^ ans[i]);\\n  }\\n\\n  return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction decode(encoded: number[], first: number): number[] {\\n  const n = encoded.length;\\n  const ans: number[] = [first];\\n\\n  // the inverse of xor is xor\\n  // i.e if a ^ b = c then b ^ c = a\\n  // where c and a will have same value\\n  // in the given problem the first element\\n  // of the array is given, so we\\'ll xor the\\n  // first element of both the array and then\\n  // push the result to the ans where it\\'ll be\\n  // used in the next iterations\\n  for (let i = 0; i < n; i++) {\\n    ans.push(encoded[i] ^ ans[i]);\\n  }\\n\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3821113,
                "title": "1720-java-bit-manipulation-100-efficient",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int decoded[]=new int[encoded.length+1];\\n        decoded[0]=first;\\n        for(int i=0;i<encoded.length;i++)\\n        {\\n            decoded[i+1]=first^encoded[i];\\n            first=decoded[i+1];\\n        }\\n        return decoded;\\n    }\\n}\\n\\n\\n```\\n\\nUPVOTE ! IF YOU LIKE SOLUTION \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int decoded[]=new int[encoded.length+1];\\n        decoded[0]=first;\\n        for(int i=0;i<encoded.length;i++)\\n        {\\n            decoded[i+1]=first^encoded[i];\\n            first=decoded[i+1];\\n        }\\n        return decoded;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531551,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int>ans;\\n        ans.push_back(first);\\n        for(int i=0; i<encoded.size(); i++){\\n            ans.push_back(encoded[i]^ans.back());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int>ans;\\n        ans.push_back(first);\\n        for(int i=0; i<encoded.size(); i++){\\n            ans.push_back(encoded[i]^ans.back());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522761,
                "title": "easy-java-solution",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decode(int[] a, int f) {\\n        int n=a.length;\\n        int ans[]=new int[n+1];\\n        ans[0]=f;\\n        for(int i=1;i<n+1;i++){\\n            ans[i]=ans[i-1]^a[i-1];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decode(int[] a, int f) {\\n        int n=a.length;\\n        int ans[]=new int[n+1];\\n        ans[0]=f;\\n        for(int i=1;i<n+1;i++){\\n            ans[i]=ans[i-1]^a[i-1];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488877,
                "title": "simple-java-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int arr[] = new int[encoded.length + 1];\\n        arr[0] = first;\\n        for(int i = 1; i < arr.length ; i++) {\\n            arr[i] = (encoded[i - 1] ^ arr[i - 1]);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int arr[] = new int[encoded.length + 1];\\n        arr[0] = first;\\n        for(int i = 1; i < arr.length ; i++) {\\n            arr[i] = (encoded[i - 1] ^ arr[i - 1]);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485559,
                "title": "java-o-n-beats-100-explained",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs already stated \\nencoded[i] = arr[i] XOR arr[i + 1]. \\nFrom this statement we can easily say : \\narr[i] = arr[i-1] XOR encoded[i-1]\\n\\n# Intution:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe are already provided with arr[0]. According to question to get encoded[i] we need to know arr[i] and arr[i-1]. \\n\\nLet\\'s see how we get encoded[0] for encoded[1,2,3] with arr[1,0,2,1] :\\n``` \\n1 ^ 0 = 1 // arr[i] = arr[i-1] XOR encoded[i-1]\\n\\nWe are already provided with first element of arr[0]. \\nTo find arr[1] we can do arr[0] XOR encoded[0].\\n```\\n- Time Complexity : \\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int[] ans = new int[encoded.length+1];\\n        ans[0] = first;\\n      for(int i = 1;i<ans.length;i++) {\\n       ans[i] = ans[i-1] ^ encoded[i-1];\\n      }\\n       return ans; \\n    }\\n}\\n```\\n\\nPLz upvote if you understand my explanation.",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` \\n1 ^ 0 = 1 // arr[i] = arr[i-1] XOR encoded[i-1]\\n\\nWe are already provided with first element of arr[0]. \\nTo find arr[1] we can do arr[0] XOR encoded[0].\\n```\n```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int[] ans = new int[encoded.length+1];\\n        ans[0] = first;\\n      for(int i = 1;i<ans.length;i++) {\\n       ans[i] = ans[i-1] ^ encoded[i-1];\\n      }\\n       return ans; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276819,
                "title": "decode-xored-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        arr=[first]\\n        temp=0\\n        for i in encoded:\\n            temp=i^first\\n            arr.append(temp)\\n            first=temp\\n        return arr\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        arr=[first]\\n        temp=0\\n        for i in encoded:\\n            temp=i^first\\n            arr.append(temp)\\n            first=temp\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263224,
                "title": "easy-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int n = encoded.length;\\n        int[] dec = new int[n + 1];\\n        dec[0] = first;\\n        for(int i = 1; i <= n; i++){\\n            dec[i] = (encoded[i - 1] ^ dec[i - 1]);\\n        }\\n        return dec;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int n = encoded.length;\\n        int[] dec = new int[n + 1];\\n        dec[0] = first;\\n        for(int i = 1; i <= n; i++){\\n            dec[i] = (encoded[i - 1] ^ dec[i - 1]);\\n        }\\n        return dec;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243866,
                "title": "easy-solution-beats-99-74",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n   vector<int>arr;\\n   arr.push_back(first);\\n   for(int i=0;i<encoded.size();i++)        arr.push_back(encoded[i]);\\n      for(int i=1;i<arr.size();i++)\\n          arr[i] = arr[i] xor  arr[i-1];\\n          return arr;     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n   vector<int>arr;\\n   arr.push_back(first);\\n   for(int i=0;i<encoded.size();i++)        arr.push_back(encoded[i]);\\n      for(int i=1;i<arr.size();i++)\\n          arr[i] = arr[i] xor  arr[i-1];\\n          return arr;     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3239860,
                "title": "as-much-as-simple",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} encoded\\n * @param {number} first\\n * @return {number[]}\\n */\\nvar decode = function (encoded, first) {\\n  const result = [first];\\n  for (let i = 0; i < encoded.length; i++) {\\n    result.push(result[i] ^ encoded[i]);\\n  }\\n  return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} encoded\\n * @param {number} first\\n * @return {number[]}\\n */\\nvar decode = function (encoded, first) {\\n  const result = [first];\\n  for (let i = 0; i < encoded.length; i++) {\\n    result.push(result[i] ^ encoded[i]);\\n  }\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3225971,
                "title": "easy-to-understand-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int[] ans = new int[encoded.length+1];\\n        ans[0]=first;\\n        for(int i=0;i<encoded.length;i++){\\n            ans[i+1] = encoded[i]^ans[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int[] ans = new int[encoded.length+1];\\n        ans[0]=first;\\n        for(int i=0;i<encoded.length;i++){\\n            ans[i+1] = encoded[i]^ans[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205410,
                "title": "100-solution-in-java-and-less-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int len = encoded.length;\\n        int[] decode = new int[len + 1];\\n        decode[0] = first;\\n        for(int i = 0; i < len; i++)\\n            decode[i+1] = encoded[i]^decode[i];\\n        return decode;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int len = encoded.length;\\n        int[] decode = new int[len + 1];\\n        decode[0] = first;\\n        for(int i = 0; i < len; i++)\\n            decode[i+1] = encoded[i]^decode[i];\\n        return decode;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107214,
                "title": "one-liner-reduce-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} encoded\\n * @param {number} first\\n * @return {number[]}\\n */\\nvar decode = function(encoded, first) {\\n    return encoded.reduce((acc, encodedNum) => [...acc, acc.at(-1) ^ encodedNum], [first]);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} encoded\\n * @param {number} first\\n * @return {number[]}\\n */\\nvar decode = function(encoded, first) {\\n    return encoded.reduce((acc, encodedNum) => [...acc, acc.at(-1) ^ encodedNum], [first]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2833932,
                "title": "reverse-xor",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& e, int f) {\\n        int n = e.size();\\n        vector<int > res(n+1);\\n        res[0] = f;\\n        for(int i=0;i<n;i++)\\n        {\\n            res[i+1] = res[i]^e[i];\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& e, int f) {\\n        int n = e.size();\\n        vector<int > res(n+1);\\n        res[0] = f;\\n        for(int i=0;i<n;i++)\\n        {\\n            res[i+1] = res[i]^e[i];\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661330,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        L=[first]\\n        temp = 0\\n        for i in encoded:\\n            temp = i ^ first\\n            L.append(temp)\\n            first = temp\\n        return L\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        L=[first]\\n        temp = 0\\n        for i in encoded:\\n            temp = i ^ first\\n            L.append(temp)\\n            first = temp\\n        return L\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661304,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int> v;\\n        v.push_back(first);\\n        int temp;\\n        for (int x:encoded){\\n            temp=x^first;\\n            v.push_back(temp);\\n            first = temp;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int> v;\\n        v.push_back(first);\\n        int temp;\\n        for (int x:encoded){\\n            temp=x^first;\\n            v.push_back(temp);\\n            first = temp;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2644305,
                "title": "c-easy-step-by-step",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   vector<int> decode(vector<int>& A, int cur) {\\n        vector<int> res = {cur};\\n        for (int& a: A)\\n            res.push_back(cur ^= a);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   vector<int> decode(vector<int>& A, int cur) {\\n        vector<int> res = {cur};\\n        for (int& a: A)\\n            res.push_back(cur ^= a);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2632339,
                "title": "python-easy-solution-in-6-lines",
                "content": "```\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        n=len(encoded)\\n        arr=[0]*(n+1)\\n        arr[0]=first\\n        for i in range(1,n+1):\\n            arr[i]=encoded[i-1]^arr[i-1]\\n        return arr\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        n=len(encoded)\\n        arr=[0]*(n+1)\\n        arr[0]=first\\n        for i in range(1,n+1):\\n            arr[i]=encoded[i-1]^arr[i-1]\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2622622,
                "title": "c-easy-and-fastest-solution",
                "content": "\\t\\tvector<int>vec(encoded.size()+1);\\n        vec[0]=first;\\n        for(int i=0;i<encoded.size();i++)\\n        {\\n            vec[i+1]=vec[i]^encoded[i];\\n        }\\n        return vec;",
                "solutionTags": [],
                "code": "\\t\\tvector<int>vec(encoded.size()+1);\\n        vec[0]=first;\\n        for(int i=0;i<encoded.size();i++)\\n        {\\n            vec[i+1]=vec[i]^encoded[i];\\n        }\\n        return vec;",
                "codeTag": "Unknown"
            },
            {
                "id": 2591704,
                "title": "xor-and-append",
                "content": "```\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        n = len(encoded)\\n        arr = [0]*(n+1)\\n        arr[0] = first\\n        for i in range(n):\\n            arr[i+1] = (encoded[i] ^ arr[i])\\n        return arr\\n```\\nfaster than 93%.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        n = len(encoded)\\n        arr = [0]*(n+1)\\n        arr[0] = first\\n        for i in range(n):\\n            arr[i+1] = (encoded[i] ^ arr[i])\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589245,
                "title": "c-easy-understanding-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& E, int first) {\\n        vector<int>rs(E.size()+1);\\n        rs[0] = first;\\n        for (int i = 0 ; i < E.size() ; i++){\\n            rs[i+1] = rs[i] ^ E[i];\\n        }\\n        return rs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& E, int first) {\\n        vector<int>rs(E.size()+1);\\n        rs[0] = first;\\n        for (int i = 0 ; i < E.size() ; i++){\\n            rs[i+1] = rs[i] ^ E[i];\\n        }\\n        return rs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2572472,
                "title": "c-solution-easy-to-understand",
                "content": "\\'\\'\\'int* decode(int* encoded, int encodedSize, int first, int* returnSize){\\n\\n    int *enArray;\\n    *returnSize=encodedSize+1;\\n    enArray=(int*)malloc(sizeof(int)*(*returnSize));\\n    enArray[0]=first;\\n    for(int i=0;i<encodedSize;i++){\\n        enArray[i+1]=enArray[i]^encoded[i];\\n    }\\n    return enArray;\\n    \\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "\\'\\'\\'int* decode(int* encoded, int encodedSize, int first, int* returnSize){\\n\\n    int *enArray;\\n    *returnSize=encodedSize+1;\\n    enArray=(int*)malloc(sizeof(int)*(*returnSize));\\n    enArray[0]=first;\\n    for(int i=0;i<encodedSize;i++){\\n        enArray[i+1]=enArray[i]^encoded[i];\\n    }\\n    return enArray;\\n    \\n}\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2546079,
                "title": "python-c-easy-understanding-with-explanation",
                "content": "# Python Solution\\n```\\n\\'\\'\\'\\n**Explanation **\\n-- In question   encoded[i] = arr[i] XOR arr[i + 1]\\n \\twe need to get arr[i + 1] \\n\\txor property\\n\\t\\t\\tX xor X = 0\\n\\t\\t\\tX xor 0 = X\\n\\tencoded[i] = arr[i] XOR arr[i + 1]   take arr[i] xor on both side\\n\\twe get arr[i] XOR encoded[i] = arr[i] XOR arr[i] XOR arr[i + 1]\\n\\tarr[i] XOR arr[i] XOR = 0\\n\\tso we get arr[i] XOR encoded[i] = arr[i + 1]\\n\\tthen we just need to loop and append it\\n\\'\\'\\'\\n\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        ans = []\\n        ans.append(first)\\n        for i in range(len(encoded)):\\n            ans.append(encoded[i]^ans[i])\\n        return ans\\n```\\n\\n# C++ Solution\\n```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int>ans;\\n        ans.push_back(first);\\n        int n = encoded.size();\\n        for(int i = 0; i<n; ++i){\\n            ans.push_back(encoded[i]^ans[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\n\\'\\'\\'\\n**Explanation **\\n-- In question   encoded[i] = arr[i] XOR arr[i + 1]\\n \\twe need to get arr[i + 1] \\n\\txor property\\n\\t\\t\\tX xor X = 0\\n\\t\\t\\tX xor 0 = X\\n\\tencoded[i] = arr[i] XOR arr[i + 1]   take arr[i] xor on both side\\n\\twe get arr[i] XOR encoded[i] = arr[i] XOR arr[i] XOR arr[i + 1]\\n\\tarr[i] XOR arr[i] XOR = 0\\n\\tso we get arr[i] XOR encoded[i] = arr[i + 1]\\n\\tthen we just need to loop and append it\\n\\'\\'\\'\\n\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        ans = []\\n        ans.append(first)\\n        for i in range(len(encoded)):\\n            ans.append(encoded[i]^ans[i])\\n        return ans\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int>ans;\\n        ans.push_back(first);\\n        int n = encoded.size();\\n        for(int i = 0; i<n; ++i){\\n            ans.push_back(encoded[i]^ans[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2543837,
                "title": "python-solution-easy-easy-to-understand-beginner-friendly",
                "content": "```\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]: \\n        l=[]\\n        l.append(first)\\n        for i in range(len(encoded)):\\n            l.append(l[i]^encoded[i]) \\n        return l\\n``` \\n**Please upvote if you found it helpful**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]: \\n        l=[]\\n        l.append(first)\\n        for i in range(len(encoded)):\\n            l.append(l[i]^encoded[i]) \\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2538142,
                "title": "python-solution-o-n",
                "content": "Time and Space Complexcity O(N)\\n```\\nclass Solution:\\n    def decode(self, A: List[int], first: int) -> List[int]:\\n        ans=[first]\\n        n=len(A)\\n        for i in range(n):\\n            a=ans[-1]^A[i]\\n            ans.append(a)\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decode(self, A: List[int], first: int) -> List[int]:\\n        ans=[first]\\n        n=len(A)\\n        for i in range(n):\\n            a=ans[-1]^A[i]\\n            ans.append(a)\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2526134,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int> ans;\\n        ans.push_back(first);\\n        for(int i = 0 ; i < encoded.size(); i++)\\n        {\\n            ans.push_back(encoded[i] ^ ans[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int> ans;\\n        ans.push_back(first);\\n        for(int i = 0 ; i < encoded.size(); i++)\\n        {\\n            ans.push_back(encoded[i] ^ ans[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2515024,
                "title": "java-easy-2ms",
                "content": "# Please Upvote\\n\\n```\\nint a[] = new int[encoded.length + 1];\\n        int n = encoded.length;\\n        a[0] = first;\\n        for(int i = 1; i <= n; i++){\\n            a[i] = a[i - 1] ^ encoded[i - 1];\\n        }\\n        return a;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nint a[] = new int[encoded.length + 1];\\n        int n = encoded.length;\\n        a[0] = first;\\n        for(int i = 1; i <= n; i++){\\n            a[i] = a[i - 1] ^ encoded[i - 1];\\n        }\\n        return a;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2510678,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int> v;\\n        v.push_back(first);\\n        for(int i=0; i<encoded.size(); i++)\\n        {\\n            v.push_back((v[i]^encoded[i]));\\n        }\\n        return v;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int> v;\\n        v.push_back(first);\\n        for(int i=0; i<encoded.size(); i++)\\n        {\\n            v.push_back((v[i]^encoded[i]));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2482804,
                "title": "c-inplace-replacement-o-n-tc-o-1-sc",
                "content": "\\'\\'\\'\\n\\n\\t#define pb push_back\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<int> decode(vector<int>& encoded, int first) {\\n\\t\\t\\t\\tint y = 0;\\n\\t\\t\\t\\tfor(int i=0; i<encoded.size(); ++i){\\n\\t\\t\\t\\t\\tint temp = encoded[i];\\n\\t\\t\\t\\t\\tencoded[i] = first ^ y;\\n\\t\\t\\t\\t\\ty = temp;\\n\\t\\t\\t\\t\\tfirst = encoded[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tencoded.pb(first ^ y);\\n\\t\\t\\t\\treturn encoded;\\n\\t\\t\\t}\\n\\t\\t};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<int> decode(vector<int>& encoded, int first) {\\n\\t\\t\\t\\tint y = 0;\\n\\t\\t\\t\\tfor(int i=0; i<encoded.size(); ++i){\\n\\t\\t\\t\\t\\tint temp = encoded[i];\\n\\t\\t\\t\\t\\tencoded[i] = first ^ y;\\n\\t\\t\\t\\t\\ty = temp;\\n\\t\\t\\t\\t\\tfirst = encoded[i];\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2473390,
                "title": "python-one-liner-comprehension-with-walrus",
                "content": "```\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        return [first] + [first := first ^ num for num in encoded]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        return [first] + [first := first ^ num for num in encoded]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2405153,
                "title": "simplest-solution-in-javascript",
                "content": "```\\nvar decode = function(encoded, first) {\\n    let vals = [];\\n    vals.push(first);\\n    for(var i=0;i<encoded.length;i++){\\n        first = encoded[i]^first;\\n        vals.push(first);\\n    }\\n    return vals;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar decode = function(encoded, first) {\\n    let vals = [];\\n    vals.push(first);\\n    for(var i=0;i<encoded.length;i++){\\n        first = encoded[i]^first;\\n        vals.push(first);\\n    }\\n    return vals;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2394921,
                "title": "c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        \\n        vector<int> arr;\\n        int n = encoded.size();\\n        \\n        arr.push_back(first);\\n        for(int i=0;i<n;i++)\\n        {\\n            first^=encoded[i];\\n            arr.push_back(first);\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        \\n        vector<int> arr;\\n        int n = encoded.size();\\n        \\n        arr.push_back(first);\\n        for(int i=0;i<n;i++)\\n        {\\n            first^=encoded[i];\\n            arr.push_back(first);\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2369582,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int n = encoded.length+1;\\n        int[] ans = new int[n];\\n        ans[0] = first;\\n        for(int i=1;i<n;i++){\\n            ans[i] = encoded[i-1]^ans[i-1];\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int n = encoded.length+1;\\n        int[] ans = new int[n];\\n        ans[0] = first;\\n        for(int i=1;i<n;i++){\\n            ans[i] = encoded[i-1]^ans[i-1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2350979,
                "title": "c-easily-understandable-bit-manipulation",
                "content": "```\\nTime: O(n)  Space: O(1)\\n\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& en, int f) {\\n        int n=size(en);\\n        vector<int> res(n+1);\\n        res[0]=f;\\n        for(int i=1;i<=n;i++)\\n            res[i]=res[i-1]^en[i-1];\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nTime: O(n)  Space: O(1)\\n\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& en, int f) {\\n        int n=size(en);\\n        vector<int> res(n+1);\\n        res[0]=f;\\n        for(int i=1;i<=n;i++)\\n            res[i]=res[i-1]^en[i-1];\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2333071,
                "title": "easy-cpp-solution-faster-than-97-26ms",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int>ans;\\n        ans.push_back(first);\\n        for(int i=0;i<encoded.size();i++){\\n            first=encoded[i]^first;\\n            ans.push_back(first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int>ans;\\n        ans.push_back(first);\\n        for(int i=0;i<encoded.size();i++){\\n            first=encoded[i]^first;\\n            ans.push_back(first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323305,
                "title": "java-100-faster-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int n=encoded.length;\\n        int arr[] = new int[n+1];\\n        arr[0]=first;\\n        for(int i=1;i<n+1;i++){\\n           arr[i]=arr[i-1]^encoded[i-1];\\n        }\\n        return arr;\\n    }\\n    \\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int n=encoded.length;\\n        int arr[] = new int[n+1];\\n        arr[0]=first;\\n        for(int i=1;i<n+1;i++){\\n           arr[i]=arr[i-1]^encoded[i-1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2315116,
                "title": "python-easy-and-simple",
                "content": "```\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        res = [first]\\n        for e in encoded:\\n            res.append(res[-1]^e)\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        res = [first]\\n        for e in encoded:\\n            res.append(res[-1]^e)\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2277621,
                "title": "c-xor-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int> res;\\n        res.push_back(first);\\n        for(int i=0;i<encoded.size();i++)\\n        {\\n            res.push_back(first^encoded[i]);// A xor B xor B = A\\n            first=res[i+1];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int> res;\\n        res.push_back(first);\\n        for(int i=0;i<encoded.size();i++)\\n        {\\n            res.push_back(first^encoded[i]);// A xor B xor B = A\\n            first=res[i+1];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263882,
                "title": "c-python-easy-using-xor",
                "content": "# C++\\n```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int> v={first};\\n        for(int i=0;i<encoded.size();i++) {\\n            v.push_back(encoded[i]^v[i]);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\n# Python\\n```\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        ans=[first]\\n        for i in range(0,len(encoded)):\\n            ans.append(encoded[i]^ans[i])\\n        return ans\\n```\\n\\n**Space Complexity : O(N)\\nTime Complexity : O(N)**",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int> v={first};\\n        for(int i=0;i<encoded.size();i++) {\\n            v.push_back(encoded[i]^v[i]);\\n        }\\n        return v;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        ans=[first]\\n        for i in range(0,len(encoded)):\\n            ans.append(encoded[i]^ans[i])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2246556,
                "title": "java-easy-2ms-xor",
                "content": "```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int[] arr=new int[encoded.length+1];\\n        arr[0]=first;\\n        for(int i=1;i<arr.length;i++){\\n            arr[i]=arr[i-1]^encoded[i-1]; \\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int[] arr=new int[encoded.length+1];\\n        arr[0]=first;\\n        for(int i=1;i<arr.length;i++){\\n            arr[i]=arr[i-1]^encoded[i-1]; \\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2145719,
                "title": "java-easy-solution",
                "content": "for this problem we have to use xor operator concept\\n0^1=1\\n1^0=1\\n0^0=0\\n1^1=0\\n\\n\\n\\n```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int n= encoded.length;\\n        int[] res = new int[n+1];\\n        res[0]=first;\\n        for(int i=0;i<n;i++)\\n        {\\n            res[i+1]=res[i]^encoded[i];\\n        }\\n        return res;\\n    }\\n}********\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int n= encoded.length;\\n        int[] res = new int[n+1];\\n        res[0]=first;\\n        for(int i=0;i<n;i++)\\n        {\\n            res[i+1]=res[i]^encoded[i];\\n        }\\n        return res;\\n    }\\n}********\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2116613,
                "title": "easy-solution-in-c",
                "content": "**If a^b=c  then b^c = a and a^c = b**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) \\n    {\\n        vector<int> array(encoded.size());\\n        int value = 0;\\n        fill(array.begin(), array.end(), value);\\n        auto it = array.insert(array.begin(), first);\\n        for(int i =0; i<encoded.size(); i++)\\n        {\\n            array[i+1] = array[i] ^ encoded[i]; \\n        }\\n        return array;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) \\n    {\\n        vector<int> array(encoded.size());\\n        int value = 0;\\n        fill(array.begin(), array.end(), value);\\n        auto it = array.insert(array.begin(), first);\\n        for(int i =0; i<encoded.size(); i++)\\n        {\\n            array[i+1] = array[i] ^ encoded[i]; \\n        }\\n        return array;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065958,
                "title": "c-easy-3-liner",
                "content": "upvote if you find helpful\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int>ans;\\n        ans.push_back(first);\\n        for(int i=0;i<encoded.size();i++){\\n            int x=ans[i]^encoded[i];\\n            ans.push_back(x);\\n        }\\n       return ans; \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int>ans;\\n        ans.push_back(first);\\n        for(int i=0;i<encoded.size();i++){\\n            int x=ans[i]^encoded[i];\\n            ans.push_back(x);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2047953,
                "title": "illustrated-explanation",
                "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/4c56ad2a-616c-4007-ba4a-fc25c7c6d17c_1652792607.3319657.png)\\n\\n\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        \"\"\" O(N)TS \"\"\"\\n        return itertools.accumulate(encoded, operator.xor, initial=first)",
                "solutionTags": [],
                "code": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/4c56ad2a-616c-4007-ba4a-fc25c7c6d17c_1652792607.3319657.png)\\n\\n\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        \"\"\" O(N)TS \"\"\"\\n        return itertools.accumulate(encoded, operator.xor, initial=first)",
                "codeTag": "Python3"
            },
            {
                "id": 2023897,
                "title": "faster-than-94-52-of-python3-easiest-solution",
                "content": "class Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        l=len(encoded)\\n        arr=[first]\\n        for i in range(l):\\n            arr.append(encoded[i] ^ arr[i])\\n        return arr",
                "solutionTags": [],
                "code": "class Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        l=len(encoded)\\n        arr=[first]\\n        for i in range(l):\\n            arr.append(encoded[i] ^ arr[i])\\n        return arr",
                "codeTag": "Java"
            },
            {
                "id": 1959135,
                "title": "java-simple-three-line-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int[] arr = new int[encoded.length+1];\\n        arr[0] = first;\\n        for (int i = 0; i < encoded.length; i++) arr[i + 1] = encoded[i] ^ arr[i];\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int[] arr = new int[encoded.length+1];\\n        arr[0] = first;\\n        for (int i = 0; i < encoded.length; i++) arr[i + 1] = encoded[i] ^ arr[i];\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1892188,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        s=[first]\\n        for i in range(len(encoded)):\\n            first^=encoded[i]\\n            s.append(first)\\n        return s\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        s=[first]\\n        for i in range(len(encoded)):\\n            first^=encoded[i]\\n            s.append(first)\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1876989,
                "title": "c-easy-solution-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int> ans = {first};\\n\\t\\t\\n        for(int i = 0; i < encoded.size(); i++) {\\n            int temp = encoded[i]^ans[i];\\n            ans.push_back(temp);\\n        }\\n\\t\\t\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int> ans = {first};\\n\\t\\t\\n        for(int i = 0; i < encoded.size(); i++) {\\n            int temp = encoded[i]^ans[i];\\n            ans.push_back(temp);\\n        }\\n\\t\\t\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1868969,
                "title": "90-faster-python-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/ab381da4-b2c2-4d9e-b5bf-196e6f94b8a1_1647833338.436705.png)\\n\\n\\'\\'\\'\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        #Basic check \\n        if encoded is None or len(encoded) == 0: return []\\n        \\n        arr = [None] * (len(encoded) + 1)\\n        \\n        arr[0] = first\\n        \\n        for i in range(len(encoded)):\\n            arr[i+1] = encoded[i] ^ arr[i]\\n            \\n        return arr\\n          \\'\\'\\'\\n\\t\\t  \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/ab381da4-b2c2-4d9e-b5bf-196e6f94b8a1_1647833338.436705.png)\\n\\n\\'\\'\\'\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        #Basic check \\n        if encoded is None or len(encoded) == 0: return []\\n        \\n        arr = [None] * (len(encoded) + 1)\\n        \\n        arr[0] = first\\n        \\n        for i in range(len(encoded)):\\n            arr[i+1] = encoded[i] ^ arr[i]\\n            \\n        return arr\\n          \\'\\'\\'\\n\\t\\t  \\n",
                "codeTag": "Java"
            },
            {
                "id": 1867014,
                "title": "cpp-simple-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        int n=encoded.size();\\n        vector<int> ans;\\n        ans.push_back(first);\\n        for(int i=0;i<n;i++)\\n        {\\n            int temp=ans[i]^encoded[i];\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        int n=encoded.size();\\n        vector<int> ans;\\n        ans.push_back(first);\\n        for(int i=0;i<n;i++)\\n        {\\n            int temp=ans[i]^encoded[i];\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1813853,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        int n=encoded.size();\\n        vector<int> vec;\\n        int temp=first;\\n        vec.push_back(first);\\n        for(int i=0;i<n;i++){\\n            temp=temp^encoded[i];\\n            vec.push_back(temp);\\n        }\\n        return vec;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        int n=encoded.size();\\n        vector<int> vec;\\n        int temp=first;\\n        vec.push_back(first);\\n        for(int i=0;i<n;i++){\\n            temp=temp^encoded[i];\\n            vec.push_back(temp);\\n        }\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1794971,
                "title": "python3-easy-solution-bit-manipulation",
                "content": "```\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        arr=[first]\\n        for i in encoded:\\n            arr.append(arr[-1]^i)\\n        return arr\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        arr=[first]\\n        for i in encoded:\\n            arr.append(arr[-1]^i)\\n        return arr\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1794177,
                "title": "decode-xor-array",
                "content": "python\\n```\\nclass Solution(object):\\n    def decode(self, encoded, first):\\n      \\n        arr = [first]\\n        for num in encoded:\\n            arr.append(arr[-1]^num)\\n        return arr\\n```\\njavaScript\\n```\\nvar decode = function(encoded, first) {\\n    const arr = [first];\\n    encoded.forEach((num, i ) => arr.push(arr[i]^num))\\n    return arr\\n};\\n```\\njavaScript\\n```\\n    return encoded.reduce(\\n\\t\\t(acc, cv, i) => {\\n\\t\\t\\tacc.push(acc[i] ^ cv);\\n\\n\\t\\t\\treturn acc;\\n\\t\\t},\\n\\t\\t[first]\\n\\t);\\n};\\n```\\njavaScript but this will create runtime error, for easyUnderstanding\\n```\\nvar decode = function(encoded, first) {\\n    const arr = [first];\\n    \\n    for (let i=0; i<encoded.length; i++) {\\n        result.push(result[i]^encoded[i]);\\n    }\\n    return arr\\n};\\n",
                "solutionTags": [
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution(object):\\n    def decode(self, encoded, first):\\n      \\n        arr = [first]\\n        for num in encoded:\\n            arr.append(arr[-1]^num)\\n        return arr\\n```\n```\\nvar decode = function(encoded, first) {\\n    const arr = [first];\\n    encoded.forEach((num, i ) => arr.push(arr[i]^num))\\n    return arr\\n};\\n```\n```\\n    return encoded.reduce(\\n\\t\\t(acc, cv, i) => {\\n\\t\\t\\tacc.push(acc[i] ^ cv);\\n\\n\\t\\t\\treturn acc;\\n\\t\\t},\\n\\t\\t[first]\\n\\t);\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774847,
                "title": "elegant-python-solution",
                "content": "Logic here is simple if we know these 2 **property of xor**:\\n1. `x ^ 0 = x`\\n2. `x ^ x = 0`\\n\\nNow in the problem, we know that:\\n`encoded[i] = arr[i] ^ arr[i+1]` , xor both side with arr[i] \\n`arr[i] ^ encoded[i] = arr[i] ^ arr[i] ^ arr[i+1]`\\nTherefore `arr[i+1] = arr[i] ^ encoded[i] `\\n\\n\\n\\nWe get the hint to xor both sides withh arr[i] because we are given `arr[0] = first`.\\nNow the code:\\n```\\ndef decode(encoded, first):\\n\\tarr = []\\n\\tarr.append(first)\\n\\ti = 0\\n\\tfor each in encoded:\\n\\t\\tarr.append(arr[i]^each)\\n\\t\\ti += 1\\n\\treturn arr\\n```\\nWe can make it more elegant by using slicing and not using `i` to iterate. Here\\'s how that will look:\\n```\\ndef decode(encoded, first):\\n\\tarr = [first]\\n\\tfor each in encoded:\\n\\t\\tarr.append(arr[-1]^each)\\n\\n\\treturn arr\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef decode(encoded, first):\\n\\tarr = []\\n\\tarr.append(first)\\n\\ti = 0\\n\\tfor each in encoded:\\n\\t\\tarr.append(arr[i]^each)\\n\\t\\ti += 1\\n\\treturn arr\\n```\n```\\ndef decode(encoded, first):\\n\\tarr = [first]\\n\\tfor each in encoded:\\n\\t\\tarr.append(arr[-1]^each)\\n\\n\\treturn arr\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1729684,
                "title": "space-optimized-cpp-solution-simple",
                "content": "Time : O(n), Space : O(1)\\n```\\n\\nvector<int> decode(vector<int>& a, int first) {\\n        a.insert(a.begin(), first);\\n        int n = a.size();\\n        for(int i = 0; i<n-1; i++){\\n            a[i+1] ^= a[i];\\n        }\\n        return a;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\nvector<int> decode(vector<int>& a, int first) {\\n        a.insert(a.begin(), first);\\n        int n = a.size();\\n        for(int i = 0; i<n-1; i++){\\n            a[i+1] ^= a[i];\\n        }\\n        return a;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1724189,
                "title": "c-beginner-friendly-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int> ans;\\n        ans.push_back(first);\\n        \\n        for(int i=1;i<=encoded.size();i++)\\n            ans.push_back(ans[i-1]^encoded[i-1]);\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int> ans;\\n        ans.push_back(first);\\n        \\n        for(int i=1;i<=encoded.size();i++)\\n            ans.push_back(ans[i-1]^encoded[i-1]);\\n        \\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1709275,
                "title": "java-solution-easy",
                "content": "```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int[] result = new int[encoded.length+1];\\n        \\n        int j=0;\\n        result[0]=first;\\n        \\n        for(int i=1;i<encoded.length+1;i++)\\n        {\\n            result[i]= (result[i-1]^encoded[j++]);\\n        }\\n        return result;       \\n    }\\n}\\n```\\n\\nPlease upvote if you liked the approach and feel free to comment for explanation or different approaches.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int[] result = new int[encoded.length+1];\\n        \\n        int j=0;\\n        result[0]=first;\\n        \\n        for(int i=1;i<encoded.length+1;i++)\\n        {\\n            result[i]= (result[i-1]^encoded[j++]);\\n        }\\n        return result;       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1695394,
                "title": "simple-c-accepted",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int> reVec;\\n        reVec.push_back(first);\\n        for(int i=0;i<encoded.size();i++)\\n        {\\n            int xorVal;\\n            xorVal=encoded[i] ^ reVec[i];\\n            reVec.push_back(xorVal);\\n        }\\n        return reVec;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int> reVec;\\n        reVec.push_back(first);\\n        for(int i=0;i<encoded.size();i++)\\n        {\\n            int xorVal;\\n            xorVal=encoded[i] ^ reVec[i];\\n            reVec.push_back(xorVal);\\n        }\\n        return reVec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1690504,
                "title": "o-1-space-complexity-python-solution",
                "content": "### **Complexity**\\nSpace Complexity `O(1)`\\nTime Complexity  `O(N)`\\n```\\ndef decode(encoded,first):\\n    n=len(encoded)\\n    encoded.insert(0,first)\\n    for i in range(1,n+1):\\n        encoded[i]=encoded[i-1]^encoded[i]\\n    return encoded\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef decode(encoded,first):\\n    n=len(encoded)\\n    encoded.insert(0,first)\\n    for i in range(1,n+1):\\n        encoded[i]=encoded[i-1]^encoded[i]\\n    return encoded\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1674473,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} encoded\\n * @param {number} first\\n * @return {number[]}\\n */\\nvar decode = function(encoded, first) {\\n    let arr = new Array(encoded.length + 1);\\n    arr[0] = first;\\n    for(let i=0; i<encoded.length; i++){\\n        arr[i+1] = arr[i] ^ encoded[i];\\n    }\\n    return arr;\\n};\\n```\\n\\nTime Complexity : O(n)\\nwhere n : length of encoded matrix",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} encoded\\n * @param {number} first\\n * @return {number[]}\\n */\\nvar decode = function(encoded, first) {\\n    let arr = new Array(encoded.length + 1);\\n    arr[0] = first;\\n    for(let i=0; i<encoded.length; i++){\\n        arr[i+1] = arr[i] ^ encoded[i];\\n    }\\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1674470,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int arr[] = new int[encoded.length + 1];\\n        arr[0] = first;\\n        for(int i=0; i<encoded.length; i++){\\n            arr[i+1] = arr[i] ^ encoded[i];\\n        }\\n        return arr;\\n    }\\n}\\n```\\n\\nTime Complexity : O(n)\\nwhere n : length of encoded matrix",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int arr[] = new int[encoded.length + 1];\\n        arr[0] = first;\\n        for(int i=0; i<encoded.length; i++){\\n            arr[i+1] = arr[i] ^ encoded[i];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668523,
                "title": "c-simple-approach",
                "content": "class Solution {\\npublic:\\n    vector<int> decode(vector`<int>`& encoded, int first) {\\n        vector`<int>` ans;\\n        ans.push_back(first);\\n        for(int i=0;i<encoded.size();i++){\\n            int a=encoded[i]^ans[i];\\n            ans.push_back(a);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> decode(vector`<int>`& encoded, int first) {\\n        vector`<int>` ans;\\n        ans.push_back(first);\\n        for(int i=0;i<encoded.size();i++){\\n            int a=encoded[i]^ans[i];\\n            ans.push_back(a);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1628544,
                "title": "c-o-n-straightforward",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        const size_t N = encoded.size();\\n        vector<int> ret(N+1u);\\n        ret[0] = first;\\n        for(size_t i = 1; i <= N; ++i) {\\n            ret[i] = encoded[i-1] ^ ret[i-1];\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        const size_t N = encoded.size();\\n        vector<int> ret(N+1u);\\n        ret[0] = first;\\n        for(size_t i = 1; i <= N; ++i) {\\n            ret[i] = encoded[i-1] ^ ret[i-1];\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603145,
                "title": "python3-3-lines",
                "content": "```\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        res=[first]\\n        for el in encoded: res.append(el^res[-1])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        res=[first]\\n        for el in encoded: res.append(el^res[-1])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599589,
                "title": "c-easy-traversal-linear-time-using-xor-operator-only",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int>ans;\\n        //pushed the first element into the ans array\\n        ans.push_back(first);\\n        \\n        //just remember the xor property\\n        //a^b = c \\n        //a^c = b\\n        //c^b = a\\n        //a^a = 0;\\n        //a^0 = a;\\n        \\n        //these above properties will solve most of the question \\n        \\n        //we just xored the last element of the ans and the current element of the encode array\\n        for(int i = 0; i<encoded.size(); i++){\\n            ans.push_back(ans.back()^encoded[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int>ans;\\n        //pushed the first element into the ans array\\n        ans.push_back(first);\\n        \\n        //just remember the xor property\\n        //a^b = c \\n        //a^c = b\\n        //c^b = a\\n        //a^a = 0;\\n        //a^0 = a;\\n        \\n        //these above properties will solve most of the question \\n        \\n        //we just xored the last element of the ans and the current element of the encode array\\n        for(int i = 0; i<encoded.size(); i++){\\n            ans.push_back(ans.back()^encoded[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1538984,
                "title": "using-concept-a-b-c-is-equivalent-a-c-b-in-python3",
                "content": "def decode(self, encoded: List[int], first: int) -> List[int]:\\n        ans=[first]\\n        for i in range(len(encoded)):\\n            ans.append(ans[-1]^encoded[i])\\n        return ans",
                "solutionTags": [],
                "code": "def decode(self, encoded: List[int], first: int) -> List[int]:\\n        ans=[first]\\n        for i in range(len(encoded)):\\n            ans.append(ans[-1]^encoded[i])\\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 1530509,
                "title": "c-pure-as-walter-white-meth-97-14",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        int n = encoded.size();\\n        vector<int>nums(n + 1);\\n        nums[0]=first;\\n        for(int i = 1 ; i <= n ;i++)\\n            nums[i] = (nums[i - 1] ^ encoded[i - 1] );\\n        return nums;\\n    }\\n};````\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        int n = encoded.size();\\n        vector<int>nums(n + 1);\\n        nums[0]=first;\\n        for(int i = 1 ; i <= n ;i++)\\n            nums[i] = (nums[i - 1] ^ encoded[i - 1] );\\n        return nums;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 1511748,
                "title": "easy-c-solution",
                "content": "```\\nstd::vector<int> decode(std::vector<int>& encoded, int first) {\\n\\t\\tstd::vector<int> decoded;\\n\\t\\tdecoded.push_back(first);\\n\\t\\tfor(int i = 0; i < encoded.size(); ++i)\\n\\t\\t{\\n\\t\\t\\tdecoded.push_back(decoded.at(i) ^ encoded.at(i));\\n\\t\\t}\\n\\t\\treturn decoded;\\n\\t}",
                "solutionTags": [],
                "code": "```\\nstd::vector<int> decode(std::vector<int>& encoded, int first) {\\n\\t\\tstd::vector<int> decoded;\\n\\t\\tdecoded.push_back(first);\\n\\t\\tfor(int i = 0; i < encoded.size(); ++i)\\n\\t\\t{\\n\\t\\t\\tdecoded.push_back(decoded.at(i) ^ encoded.at(i));\\n\\t\\t}\\n\\t\\treturn decoded;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1476867,
                "title": "simplest-c-code-with-explanation-easy-to-understand",
                "content": "**Easy concept:-**\\n  ***arr[i]^arr[i+1] == encoded[i] which means xor on both side with arr[i]\\n   We get--> arr[i+1]=encoded[i]^arr[i].***\\n   \\n   ***And arr[0] is given to us. So arr[1]=arr[0]^encoded[0],\\n   Similarly   arr[i]=arr[i-1]^encoded[i-1]{Starting i from 1}***\\n```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int> res;\\n        res.push_back(first);\\n        \\n        for(int i=0;i<encoded.size();i++)\\n        {  int x=encoded[i]^res[i];\\n           res.push_back(x);\\n        }\\n        \\n        return res;\\n         \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int> res;\\n        res.push_back(first);\\n        \\n        for(int i=0;i<encoded.size();i++)\\n        {  int x=encoded[i]^res[i];\\n           res.push_back(x);\\n        }\\n        \\n        return res;\\n         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1462306,
                "title": "python-solution",
                "content": "Time Complexity  - O(n)\\n```\\n        output = [first]\\n        \\n        for i in encoded:\\n            output.append(i^output[-1])\\n        return output\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "Time Complexity  - O(n)\\n```\\n        output = [first]\\n        \\n        for i in encoded:\\n            output.append(i^output[-1])\\n        return output\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1427701,
                "title": "c-simple-solution",
                "content": "```\\nint* decode(int* encoded, int encodedSize, int first, int* returnSize){\\n    int * solution = (int *) malloc(sizeof(int) * (encodedSize+1));\\n    *returnSize = (encodedSize+1);\\n    solution[0] = first;\\n    // ^ is the bitwise XOR operator\\n    for(int i = 0; i < encodedSize; i++)\\n    {\\n        solution[i+1] = solution[i] ^ encoded[i];\\n    }\\n    return solution;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint* decode(int* encoded, int encodedSize, int first, int* returnSize){\\n    int * solution = (int *) malloc(sizeof(int) * (encodedSize+1));\\n    *returnSize = (encodedSize+1);\\n    solution[0] = first;\\n    // ^ is the bitwise XOR operator\\n    for(int i = 0; i < encodedSize; i++)\\n    {\\n        solution[i+1] = solution[i] ^ encoded[i];\\n    }\\n    return solution;\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1566382,
                "content": [
                    {
                        "username": "pradovski",
                        "content": "a xor b = c\\n(a xor b) xor a = c xor a\\n(a xor a) xor b = c xor a\\n0 xor b = c xor a\\nb = c xor a"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "__Thank You__ !! For Intuition!!\n\nBasically XOR has few interesting _property_ like :\n-  a^a = 0 [ XOR between any two same number gives zero ]\n-  a^0 = a [ XOR between any number with zero gives itself ]\n - a^b=c \n   a^c = b [XOR reverse operation]\n\nThis is what i know so far :)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/decode-xored-array/solutions/2221022/faang-optimised-code-0-n/"
                    },
                    {
                        "username": "kishokkumar",
                        "content": "XOR working:\\nLets take the Input as [1,0,2,1] and output will be [1,2,3]\\n\\nExplanation:\\nFirst we need to understand XOR operation\\n\\n\\uD83D\\uDC49XOR operations:\\n     0+0 = 0\\n     1+1 = 0\\n     1+0 = 1\\n     0+1 = 1 \\n\\nLet\\'s perform some binary XOR operation from the input above:\\n1 => 0001\\n0 => 0000\\nres = 0001 (As per the XOR operation, we got the results as 0001, which is \"1\")\\u2705\\n\\nfor, 0 XOR 2 = 2\\u2705\\n\\nthen 2 XOR 1 will be,\\n2 => 0010\\n1 => 0001\\nres = 0011 ( 3 )\\u2705\\n\\nThis is how we got the output as [1, 2, 3] \\u2705\\n\\nIf u have any doubts. comment down below, \\nAll the best to find the efficient solution.\\u2764\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "can someone explain the XOR part in English please.. I mean what is actually going on here..\\n `encoded[i] = arr[i] XOR arr[i + 1]`\\nwhat is XOR doing up there..\\nAppreciated\\n"
                    },
                    {
                        "username": "kashish2031225",
                        "content": "the XOR of ith and (i+1)th element of the original array(output array) i.e.,arr is stored in encoded array(given array)\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "okay I get it, after doing some research here is the link if you wanna take a look... https://www.pcmag.com/encyclopedia/term/xor#:~:text=XOR%20compares%20two%20input%20bits,different%2C%20the%20result%20is%201."
                    },
                    {
                        "username": "jlbroughton",
                        "content": "why on earth do people put solutions in the discussion section"
                    },
                    {
                        "username": "eduard92",
                        "content": "I like it when they write FAANG CODE, like you have to memorize it."
                    },
                    {
                        "username": "ecrane0107",
                        "content": "Can some one explain the xor operator better for python? \\n\\nThank you"
                    },
                    {
                        "username": "muhammadaliskipq",
                        "content": "This \"^\" operator is used for XOR in python."
                    },
                    {
                        "username": "__kpsingh__",
                        "content": "A thing about XOR:\\n\\nif a^b = c\\nthen a = c^b"
                    },
                    {
                        "username": "bmolutov",
                        "content": "If we have the following:\\na ^ b = c\\nand we need to find b\\n\\ndo the steps:\\n1) xor both sides\\na ^ b ^ a = c ^ a\\n2) use commutativity property of xor\\na ^ a ^ b = c ^ a\\n3) we know that a ^ a = 0 and 0 ^ b = b\\nb = c ^ a\\n\\nso, b = c ^ a"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        int n=encoded.size();\\n        vector<int>v(n+1);\\n       \\n        v[0]=first;\\n        for(int i=0;i<n;i++){\\n            v[i+1]=encoded[i]^v[i];\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/decode-xored-array/solutions/2969946/javascript-solution-linear-time-linear-space/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# FAANG OPTIMISED CODE 0(N)\\nhttps://leetcode.com/problems/decode-xored-array/solutions/2221022/faang-optimised-code-0-n/"
                    }
                ]
            },
            {
                "id": 1818607,
                "content": [
                    {
                        "username": "pradovski",
                        "content": "a xor b = c\\n(a xor b) xor a = c xor a\\n(a xor a) xor b = c xor a\\n0 xor b = c xor a\\nb = c xor a"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "__Thank You__ !! For Intuition!!\n\nBasically XOR has few interesting _property_ like :\n-  a^a = 0 [ XOR between any two same number gives zero ]\n-  a^0 = a [ XOR between any number with zero gives itself ]\n - a^b=c \n   a^c = b [XOR reverse operation]\n\nThis is what i know so far :)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/decode-xored-array/solutions/2221022/faang-optimised-code-0-n/"
                    },
                    {
                        "username": "kishokkumar",
                        "content": "XOR working:\\nLets take the Input as [1,0,2,1] and output will be [1,2,3]\\n\\nExplanation:\\nFirst we need to understand XOR operation\\n\\n\\uD83D\\uDC49XOR operations:\\n     0+0 = 0\\n     1+1 = 0\\n     1+0 = 1\\n     0+1 = 1 \\n\\nLet\\'s perform some binary XOR operation from the input above:\\n1 => 0001\\n0 => 0000\\nres = 0001 (As per the XOR operation, we got the results as 0001, which is \"1\")\\u2705\\n\\nfor, 0 XOR 2 = 2\\u2705\\n\\nthen 2 XOR 1 will be,\\n2 => 0010\\n1 => 0001\\nres = 0011 ( 3 )\\u2705\\n\\nThis is how we got the output as [1, 2, 3] \\u2705\\n\\nIf u have any doubts. comment down below, \\nAll the best to find the efficient solution.\\u2764\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "can someone explain the XOR part in English please.. I mean what is actually going on here..\\n `encoded[i] = arr[i] XOR arr[i + 1]`\\nwhat is XOR doing up there..\\nAppreciated\\n"
                    },
                    {
                        "username": "kashish2031225",
                        "content": "the XOR of ith and (i+1)th element of the original array(output array) i.e.,arr is stored in encoded array(given array)\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "okay I get it, after doing some research here is the link if you wanna take a look... https://www.pcmag.com/encyclopedia/term/xor#:~:text=XOR%20compares%20two%20input%20bits,different%2C%20the%20result%20is%201."
                    },
                    {
                        "username": "jlbroughton",
                        "content": "why on earth do people put solutions in the discussion section"
                    },
                    {
                        "username": "eduard92",
                        "content": "I like it when they write FAANG CODE, like you have to memorize it."
                    },
                    {
                        "username": "ecrane0107",
                        "content": "Can some one explain the xor operator better for python? \\n\\nThank you"
                    },
                    {
                        "username": "muhammadaliskipq",
                        "content": "This \"^\" operator is used for XOR in python."
                    },
                    {
                        "username": "__kpsingh__",
                        "content": "A thing about XOR:\\n\\nif a^b = c\\nthen a = c^b"
                    },
                    {
                        "username": "bmolutov",
                        "content": "If we have the following:\\na ^ b = c\\nand we need to find b\\n\\ndo the steps:\\n1) xor both sides\\na ^ b ^ a = c ^ a\\n2) use commutativity property of xor\\na ^ a ^ b = c ^ a\\n3) we know that a ^ a = 0 and 0 ^ b = b\\nb = c ^ a\\n\\nso, b = c ^ a"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        int n=encoded.size();\\n        vector<int>v(n+1);\\n       \\n        v[0]=first;\\n        for(int i=0;i<n;i++){\\n            v[i+1]=encoded[i]^v[i];\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/decode-xored-array/solutions/2969946/javascript-solution-linear-time-linear-space/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# FAANG OPTIMISED CODE 0(N)\\nhttps://leetcode.com/problems/decode-xored-array/solutions/2221022/faang-optimised-code-0-n/"
                    }
                ]
            },
            {
                "id": 1685296,
                "content": [
                    {
                        "username": "pradovski",
                        "content": "a xor b = c\\n(a xor b) xor a = c xor a\\n(a xor a) xor b = c xor a\\n0 xor b = c xor a\\nb = c xor a"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "__Thank You__ !! For Intuition!!\n\nBasically XOR has few interesting _property_ like :\n-  a^a = 0 [ XOR between any two same number gives zero ]\n-  a^0 = a [ XOR between any number with zero gives itself ]\n - a^b=c \n   a^c = b [XOR reverse operation]\n\nThis is what i know so far :)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/decode-xored-array/solutions/2221022/faang-optimised-code-0-n/"
                    },
                    {
                        "username": "kishokkumar",
                        "content": "XOR working:\\nLets take the Input as [1,0,2,1] and output will be [1,2,3]\\n\\nExplanation:\\nFirst we need to understand XOR operation\\n\\n\\uD83D\\uDC49XOR operations:\\n     0+0 = 0\\n     1+1 = 0\\n     1+0 = 1\\n     0+1 = 1 \\n\\nLet\\'s perform some binary XOR operation from the input above:\\n1 => 0001\\n0 => 0000\\nres = 0001 (As per the XOR operation, we got the results as 0001, which is \"1\")\\u2705\\n\\nfor, 0 XOR 2 = 2\\u2705\\n\\nthen 2 XOR 1 will be,\\n2 => 0010\\n1 => 0001\\nres = 0011 ( 3 )\\u2705\\n\\nThis is how we got the output as [1, 2, 3] \\u2705\\n\\nIf u have any doubts. comment down below, \\nAll the best to find the efficient solution.\\u2764\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "can someone explain the XOR part in English please.. I mean what is actually going on here..\\n `encoded[i] = arr[i] XOR arr[i + 1]`\\nwhat is XOR doing up there..\\nAppreciated\\n"
                    },
                    {
                        "username": "kashish2031225",
                        "content": "the XOR of ith and (i+1)th element of the original array(output array) i.e.,arr is stored in encoded array(given array)\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "okay I get it, after doing some research here is the link if you wanna take a look... https://www.pcmag.com/encyclopedia/term/xor#:~:text=XOR%20compares%20two%20input%20bits,different%2C%20the%20result%20is%201."
                    },
                    {
                        "username": "jlbroughton",
                        "content": "why on earth do people put solutions in the discussion section"
                    },
                    {
                        "username": "eduard92",
                        "content": "I like it when they write FAANG CODE, like you have to memorize it."
                    },
                    {
                        "username": "ecrane0107",
                        "content": "Can some one explain the xor operator better for python? \\n\\nThank you"
                    },
                    {
                        "username": "muhammadaliskipq",
                        "content": "This \"^\" operator is used for XOR in python."
                    },
                    {
                        "username": "__kpsingh__",
                        "content": "A thing about XOR:\\n\\nif a^b = c\\nthen a = c^b"
                    },
                    {
                        "username": "bmolutov",
                        "content": "If we have the following:\\na ^ b = c\\nand we need to find b\\n\\ndo the steps:\\n1) xor both sides\\na ^ b ^ a = c ^ a\\n2) use commutativity property of xor\\na ^ a ^ b = c ^ a\\n3) we know that a ^ a = 0 and 0 ^ b = b\\nb = c ^ a\\n\\nso, b = c ^ a"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        int n=encoded.size();\\n        vector<int>v(n+1);\\n       \\n        v[0]=first;\\n        for(int i=0;i<n;i++){\\n            v[i+1]=encoded[i]^v[i];\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/decode-xored-array/solutions/2969946/javascript-solution-linear-time-linear-space/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# FAANG OPTIMISED CODE 0(N)\\nhttps://leetcode.com/problems/decode-xored-array/solutions/2221022/faang-optimised-code-0-n/"
                    }
                ]
            },
            {
                "id": 1960567,
                "content": [
                    {
                        "username": "pradovski",
                        "content": "a xor b = c\\n(a xor b) xor a = c xor a\\n(a xor a) xor b = c xor a\\n0 xor b = c xor a\\nb = c xor a"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "__Thank You__ !! For Intuition!!\n\nBasically XOR has few interesting _property_ like :\n-  a^a = 0 [ XOR between any two same number gives zero ]\n-  a^0 = a [ XOR between any number with zero gives itself ]\n - a^b=c \n   a^c = b [XOR reverse operation]\n\nThis is what i know so far :)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/decode-xored-array/solutions/2221022/faang-optimised-code-0-n/"
                    },
                    {
                        "username": "kishokkumar",
                        "content": "XOR working:\\nLets take the Input as [1,0,2,1] and output will be [1,2,3]\\n\\nExplanation:\\nFirst we need to understand XOR operation\\n\\n\\uD83D\\uDC49XOR operations:\\n     0+0 = 0\\n     1+1 = 0\\n     1+0 = 1\\n     0+1 = 1 \\n\\nLet\\'s perform some binary XOR operation from the input above:\\n1 => 0001\\n0 => 0000\\nres = 0001 (As per the XOR operation, we got the results as 0001, which is \"1\")\\u2705\\n\\nfor, 0 XOR 2 = 2\\u2705\\n\\nthen 2 XOR 1 will be,\\n2 => 0010\\n1 => 0001\\nres = 0011 ( 3 )\\u2705\\n\\nThis is how we got the output as [1, 2, 3] \\u2705\\n\\nIf u have any doubts. comment down below, \\nAll the best to find the efficient solution.\\u2764\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "can someone explain the XOR part in English please.. I mean what is actually going on here..\\n `encoded[i] = arr[i] XOR arr[i + 1]`\\nwhat is XOR doing up there..\\nAppreciated\\n"
                    },
                    {
                        "username": "kashish2031225",
                        "content": "the XOR of ith and (i+1)th element of the original array(output array) i.e.,arr is stored in encoded array(given array)\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "okay I get it, after doing some research here is the link if you wanna take a look... https://www.pcmag.com/encyclopedia/term/xor#:~:text=XOR%20compares%20two%20input%20bits,different%2C%20the%20result%20is%201."
                    },
                    {
                        "username": "jlbroughton",
                        "content": "why on earth do people put solutions in the discussion section"
                    },
                    {
                        "username": "eduard92",
                        "content": "I like it when they write FAANG CODE, like you have to memorize it."
                    },
                    {
                        "username": "ecrane0107",
                        "content": "Can some one explain the xor operator better for python? \\n\\nThank you"
                    },
                    {
                        "username": "muhammadaliskipq",
                        "content": "This \"^\" operator is used for XOR in python."
                    },
                    {
                        "username": "__kpsingh__",
                        "content": "A thing about XOR:\\n\\nif a^b = c\\nthen a = c^b"
                    },
                    {
                        "username": "bmolutov",
                        "content": "If we have the following:\\na ^ b = c\\nand we need to find b\\n\\ndo the steps:\\n1) xor both sides\\na ^ b ^ a = c ^ a\\n2) use commutativity property of xor\\na ^ a ^ b = c ^ a\\n3) we know that a ^ a = 0 and 0 ^ b = b\\nb = c ^ a\\n\\nso, b = c ^ a"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        int n=encoded.size();\\n        vector<int>v(n+1);\\n       \\n        v[0]=first;\\n        for(int i=0;i<n;i++){\\n            v[i+1]=encoded[i]^v[i];\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/decode-xored-array/solutions/2969946/javascript-solution-linear-time-linear-space/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# FAANG OPTIMISED CODE 0(N)\\nhttps://leetcode.com/problems/decode-xored-array/solutions/2221022/faang-optimised-code-0-n/"
                    }
                ]
            },
            {
                "id": 1722624,
                "content": [
                    {
                        "username": "pradovski",
                        "content": "a xor b = c\\n(a xor b) xor a = c xor a\\n(a xor a) xor b = c xor a\\n0 xor b = c xor a\\nb = c xor a"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "__Thank You__ !! For Intuition!!\n\nBasically XOR has few interesting _property_ like :\n-  a^a = 0 [ XOR between any two same number gives zero ]\n-  a^0 = a [ XOR between any number with zero gives itself ]\n - a^b=c \n   a^c = b [XOR reverse operation]\n\nThis is what i know so far :)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/decode-xored-array/solutions/2221022/faang-optimised-code-0-n/"
                    },
                    {
                        "username": "kishokkumar",
                        "content": "XOR working:\\nLets take the Input as [1,0,2,1] and output will be [1,2,3]\\n\\nExplanation:\\nFirst we need to understand XOR operation\\n\\n\\uD83D\\uDC49XOR operations:\\n     0+0 = 0\\n     1+1 = 0\\n     1+0 = 1\\n     0+1 = 1 \\n\\nLet\\'s perform some binary XOR operation from the input above:\\n1 => 0001\\n0 => 0000\\nres = 0001 (As per the XOR operation, we got the results as 0001, which is \"1\")\\u2705\\n\\nfor, 0 XOR 2 = 2\\u2705\\n\\nthen 2 XOR 1 will be,\\n2 => 0010\\n1 => 0001\\nres = 0011 ( 3 )\\u2705\\n\\nThis is how we got the output as [1, 2, 3] \\u2705\\n\\nIf u have any doubts. comment down below, \\nAll the best to find the efficient solution.\\u2764\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "can someone explain the XOR part in English please.. I mean what is actually going on here..\\n `encoded[i] = arr[i] XOR arr[i + 1]`\\nwhat is XOR doing up there..\\nAppreciated\\n"
                    },
                    {
                        "username": "kashish2031225",
                        "content": "the XOR of ith and (i+1)th element of the original array(output array) i.e.,arr is stored in encoded array(given array)\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "okay I get it, after doing some research here is the link if you wanna take a look... https://www.pcmag.com/encyclopedia/term/xor#:~:text=XOR%20compares%20two%20input%20bits,different%2C%20the%20result%20is%201."
                    },
                    {
                        "username": "jlbroughton",
                        "content": "why on earth do people put solutions in the discussion section"
                    },
                    {
                        "username": "eduard92",
                        "content": "I like it when they write FAANG CODE, like you have to memorize it."
                    },
                    {
                        "username": "ecrane0107",
                        "content": "Can some one explain the xor operator better for python? \\n\\nThank you"
                    },
                    {
                        "username": "muhammadaliskipq",
                        "content": "This \"^\" operator is used for XOR in python."
                    },
                    {
                        "username": "__kpsingh__",
                        "content": "A thing about XOR:\\n\\nif a^b = c\\nthen a = c^b"
                    },
                    {
                        "username": "bmolutov",
                        "content": "If we have the following:\\na ^ b = c\\nand we need to find b\\n\\ndo the steps:\\n1) xor both sides\\na ^ b ^ a = c ^ a\\n2) use commutativity property of xor\\na ^ a ^ b = c ^ a\\n3) we know that a ^ a = 0 and 0 ^ b = b\\nb = c ^ a\\n\\nso, b = c ^ a"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        int n=encoded.size();\\n        vector<int>v(n+1);\\n       \\n        v[0]=first;\\n        for(int i=0;i<n;i++){\\n            v[i+1]=encoded[i]^v[i];\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/decode-xored-array/solutions/2969946/javascript-solution-linear-time-linear-space/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# FAANG OPTIMISED CODE 0(N)\\nhttps://leetcode.com/problems/decode-xored-array/solutions/2221022/faang-optimised-code-0-n/"
                    }
                ]
            },
            {
                "id": 1799875,
                "content": [
                    {
                        "username": "pradovski",
                        "content": "a xor b = c\\n(a xor b) xor a = c xor a\\n(a xor a) xor b = c xor a\\n0 xor b = c xor a\\nb = c xor a"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "__Thank You__ !! For Intuition!!\n\nBasically XOR has few interesting _property_ like :\n-  a^a = 0 [ XOR between any two same number gives zero ]\n-  a^0 = a [ XOR between any number with zero gives itself ]\n - a^b=c \n   a^c = b [XOR reverse operation]\n\nThis is what i know so far :)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/decode-xored-array/solutions/2221022/faang-optimised-code-0-n/"
                    },
                    {
                        "username": "kishokkumar",
                        "content": "XOR working:\\nLets take the Input as [1,0,2,1] and output will be [1,2,3]\\n\\nExplanation:\\nFirst we need to understand XOR operation\\n\\n\\uD83D\\uDC49XOR operations:\\n     0+0 = 0\\n     1+1 = 0\\n     1+0 = 1\\n     0+1 = 1 \\n\\nLet\\'s perform some binary XOR operation from the input above:\\n1 => 0001\\n0 => 0000\\nres = 0001 (As per the XOR operation, we got the results as 0001, which is \"1\")\\u2705\\n\\nfor, 0 XOR 2 = 2\\u2705\\n\\nthen 2 XOR 1 will be,\\n2 => 0010\\n1 => 0001\\nres = 0011 ( 3 )\\u2705\\n\\nThis is how we got the output as [1, 2, 3] \\u2705\\n\\nIf u have any doubts. comment down below, \\nAll the best to find the efficient solution.\\u2764\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "can someone explain the XOR part in English please.. I mean what is actually going on here..\\n `encoded[i] = arr[i] XOR arr[i + 1]`\\nwhat is XOR doing up there..\\nAppreciated\\n"
                    },
                    {
                        "username": "kashish2031225",
                        "content": "the XOR of ith and (i+1)th element of the original array(output array) i.e.,arr is stored in encoded array(given array)\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "okay I get it, after doing some research here is the link if you wanna take a look... https://www.pcmag.com/encyclopedia/term/xor#:~:text=XOR%20compares%20two%20input%20bits,different%2C%20the%20result%20is%201."
                    },
                    {
                        "username": "jlbroughton",
                        "content": "why on earth do people put solutions in the discussion section"
                    },
                    {
                        "username": "eduard92",
                        "content": "I like it when they write FAANG CODE, like you have to memorize it."
                    },
                    {
                        "username": "ecrane0107",
                        "content": "Can some one explain the xor operator better for python? \\n\\nThank you"
                    },
                    {
                        "username": "muhammadaliskipq",
                        "content": "This \"^\" operator is used for XOR in python."
                    },
                    {
                        "username": "__kpsingh__",
                        "content": "A thing about XOR:\\n\\nif a^b = c\\nthen a = c^b"
                    },
                    {
                        "username": "bmolutov",
                        "content": "If we have the following:\\na ^ b = c\\nand we need to find b\\n\\ndo the steps:\\n1) xor both sides\\na ^ b ^ a = c ^ a\\n2) use commutativity property of xor\\na ^ a ^ b = c ^ a\\n3) we know that a ^ a = 0 and 0 ^ b = b\\nb = c ^ a\\n\\nso, b = c ^ a"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        int n=encoded.size();\\n        vector<int>v(n+1);\\n       \\n        v[0]=first;\\n        for(int i=0;i<n;i++){\\n            v[i+1]=encoded[i]^v[i];\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/decode-xored-array/solutions/2969946/javascript-solution-linear-time-linear-space/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# FAANG OPTIMISED CODE 0(N)\\nhttps://leetcode.com/problems/decode-xored-array/solutions/2221022/faang-optimised-code-0-n/"
                    }
                ]
            },
            {
                "id": 1956204,
                "content": [
                    {
                        "username": "pradovski",
                        "content": "a xor b = c\\n(a xor b) xor a = c xor a\\n(a xor a) xor b = c xor a\\n0 xor b = c xor a\\nb = c xor a"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "__Thank You__ !! For Intuition!!\n\nBasically XOR has few interesting _property_ like :\n-  a^a = 0 [ XOR between any two same number gives zero ]\n-  a^0 = a [ XOR between any number with zero gives itself ]\n - a^b=c \n   a^c = b [XOR reverse operation]\n\nThis is what i know so far :)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/decode-xored-array/solutions/2221022/faang-optimised-code-0-n/"
                    },
                    {
                        "username": "kishokkumar",
                        "content": "XOR working:\\nLets take the Input as [1,0,2,1] and output will be [1,2,3]\\n\\nExplanation:\\nFirst we need to understand XOR operation\\n\\n\\uD83D\\uDC49XOR operations:\\n     0+0 = 0\\n     1+1 = 0\\n     1+0 = 1\\n     0+1 = 1 \\n\\nLet\\'s perform some binary XOR operation from the input above:\\n1 => 0001\\n0 => 0000\\nres = 0001 (As per the XOR operation, we got the results as 0001, which is \"1\")\\u2705\\n\\nfor, 0 XOR 2 = 2\\u2705\\n\\nthen 2 XOR 1 will be,\\n2 => 0010\\n1 => 0001\\nres = 0011 ( 3 )\\u2705\\n\\nThis is how we got the output as [1, 2, 3] \\u2705\\n\\nIf u have any doubts. comment down below, \\nAll the best to find the efficient solution.\\u2764\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "can someone explain the XOR part in English please.. I mean what is actually going on here..\\n `encoded[i] = arr[i] XOR arr[i + 1]`\\nwhat is XOR doing up there..\\nAppreciated\\n"
                    },
                    {
                        "username": "kashish2031225",
                        "content": "the XOR of ith and (i+1)th element of the original array(output array) i.e.,arr is stored in encoded array(given array)\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "okay I get it, after doing some research here is the link if you wanna take a look... https://www.pcmag.com/encyclopedia/term/xor#:~:text=XOR%20compares%20two%20input%20bits,different%2C%20the%20result%20is%201."
                    },
                    {
                        "username": "jlbroughton",
                        "content": "why on earth do people put solutions in the discussion section"
                    },
                    {
                        "username": "eduard92",
                        "content": "I like it when they write FAANG CODE, like you have to memorize it."
                    },
                    {
                        "username": "ecrane0107",
                        "content": "Can some one explain the xor operator better for python? \\n\\nThank you"
                    },
                    {
                        "username": "muhammadaliskipq",
                        "content": "This \"^\" operator is used for XOR in python."
                    },
                    {
                        "username": "__kpsingh__",
                        "content": "A thing about XOR:\\n\\nif a^b = c\\nthen a = c^b"
                    },
                    {
                        "username": "bmolutov",
                        "content": "If we have the following:\\na ^ b = c\\nand we need to find b\\n\\ndo the steps:\\n1) xor both sides\\na ^ b ^ a = c ^ a\\n2) use commutativity property of xor\\na ^ a ^ b = c ^ a\\n3) we know that a ^ a = 0 and 0 ^ b = b\\nb = c ^ a\\n\\nso, b = c ^ a"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        int n=encoded.size();\\n        vector<int>v(n+1);\\n       \\n        v[0]=first;\\n        for(int i=0;i<n;i++){\\n            v[i+1]=encoded[i]^v[i];\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/decode-xored-array/solutions/2969946/javascript-solution-linear-time-linear-space/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# FAANG OPTIMISED CODE 0(N)\\nhttps://leetcode.com/problems/decode-xored-array/solutions/2221022/faang-optimised-code-0-n/"
                    }
                ]
            },
            {
                "id": 1833865,
                "content": [
                    {
                        "username": "pradovski",
                        "content": "a xor b = c\\n(a xor b) xor a = c xor a\\n(a xor a) xor b = c xor a\\n0 xor b = c xor a\\nb = c xor a"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "__Thank You__ !! For Intuition!!\n\nBasically XOR has few interesting _property_ like :\n-  a^a = 0 [ XOR between any two same number gives zero ]\n-  a^0 = a [ XOR between any number with zero gives itself ]\n - a^b=c \n   a^c = b [XOR reverse operation]\n\nThis is what i know so far :)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/decode-xored-array/solutions/2221022/faang-optimised-code-0-n/"
                    },
                    {
                        "username": "kishokkumar",
                        "content": "XOR working:\\nLets take the Input as [1,0,2,1] and output will be [1,2,3]\\n\\nExplanation:\\nFirst we need to understand XOR operation\\n\\n\\uD83D\\uDC49XOR operations:\\n     0+0 = 0\\n     1+1 = 0\\n     1+0 = 1\\n     0+1 = 1 \\n\\nLet\\'s perform some binary XOR operation from the input above:\\n1 => 0001\\n0 => 0000\\nres = 0001 (As per the XOR operation, we got the results as 0001, which is \"1\")\\u2705\\n\\nfor, 0 XOR 2 = 2\\u2705\\n\\nthen 2 XOR 1 will be,\\n2 => 0010\\n1 => 0001\\nres = 0011 ( 3 )\\u2705\\n\\nThis is how we got the output as [1, 2, 3] \\u2705\\n\\nIf u have any doubts. comment down below, \\nAll the best to find the efficient solution.\\u2764\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "can someone explain the XOR part in English please.. I mean what is actually going on here..\\n `encoded[i] = arr[i] XOR arr[i + 1]`\\nwhat is XOR doing up there..\\nAppreciated\\n"
                    },
                    {
                        "username": "kashish2031225",
                        "content": "the XOR of ith and (i+1)th element of the original array(output array) i.e.,arr is stored in encoded array(given array)\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "okay I get it, after doing some research here is the link if you wanna take a look... https://www.pcmag.com/encyclopedia/term/xor#:~:text=XOR%20compares%20two%20input%20bits,different%2C%20the%20result%20is%201."
                    },
                    {
                        "username": "jlbroughton",
                        "content": "why on earth do people put solutions in the discussion section"
                    },
                    {
                        "username": "eduard92",
                        "content": "I like it when they write FAANG CODE, like you have to memorize it."
                    },
                    {
                        "username": "ecrane0107",
                        "content": "Can some one explain the xor operator better for python? \\n\\nThank you"
                    },
                    {
                        "username": "muhammadaliskipq",
                        "content": "This \"^\" operator is used for XOR in python."
                    },
                    {
                        "username": "__kpsingh__",
                        "content": "A thing about XOR:\\n\\nif a^b = c\\nthen a = c^b"
                    },
                    {
                        "username": "bmolutov",
                        "content": "If we have the following:\\na ^ b = c\\nand we need to find b\\n\\ndo the steps:\\n1) xor both sides\\na ^ b ^ a = c ^ a\\n2) use commutativity property of xor\\na ^ a ^ b = c ^ a\\n3) we know that a ^ a = 0 and 0 ^ b = b\\nb = c ^ a\\n\\nso, b = c ^ a"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        int n=encoded.size();\\n        vector<int>v(n+1);\\n       \\n        v[0]=first;\\n        for(int i=0;i<n;i++){\\n            v[i+1]=encoded[i]^v[i];\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/decode-xored-array/solutions/2969946/javascript-solution-linear-time-linear-space/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# FAANG OPTIMISED CODE 0(N)\\nhttps://leetcode.com/problems/decode-xored-array/solutions/2221022/faang-optimised-code-0-n/"
                    }
                ]
            },
            {
                "id": 1733873,
                "content": [
                    {
                        "username": "pradovski",
                        "content": "a xor b = c\\n(a xor b) xor a = c xor a\\n(a xor a) xor b = c xor a\\n0 xor b = c xor a\\nb = c xor a"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "__Thank You__ !! For Intuition!!\n\nBasically XOR has few interesting _property_ like :\n-  a^a = 0 [ XOR between any two same number gives zero ]\n-  a^0 = a [ XOR between any number with zero gives itself ]\n - a^b=c \n   a^c = b [XOR reverse operation]\n\nThis is what i know so far :)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/decode-xored-array/solutions/2221022/faang-optimised-code-0-n/"
                    },
                    {
                        "username": "kishokkumar",
                        "content": "XOR working:\\nLets take the Input as [1,0,2,1] and output will be [1,2,3]\\n\\nExplanation:\\nFirst we need to understand XOR operation\\n\\n\\uD83D\\uDC49XOR operations:\\n     0+0 = 0\\n     1+1 = 0\\n     1+0 = 1\\n     0+1 = 1 \\n\\nLet\\'s perform some binary XOR operation from the input above:\\n1 => 0001\\n0 => 0000\\nres = 0001 (As per the XOR operation, we got the results as 0001, which is \"1\")\\u2705\\n\\nfor, 0 XOR 2 = 2\\u2705\\n\\nthen 2 XOR 1 will be,\\n2 => 0010\\n1 => 0001\\nres = 0011 ( 3 )\\u2705\\n\\nThis is how we got the output as [1, 2, 3] \\u2705\\n\\nIf u have any doubts. comment down below, \\nAll the best to find the efficient solution.\\u2764\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "can someone explain the XOR part in English please.. I mean what is actually going on here..\\n `encoded[i] = arr[i] XOR arr[i + 1]`\\nwhat is XOR doing up there..\\nAppreciated\\n"
                    },
                    {
                        "username": "kashish2031225",
                        "content": "the XOR of ith and (i+1)th element of the original array(output array) i.e.,arr is stored in encoded array(given array)\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "okay I get it, after doing some research here is the link if you wanna take a look... https://www.pcmag.com/encyclopedia/term/xor#:~:text=XOR%20compares%20two%20input%20bits,different%2C%20the%20result%20is%201."
                    },
                    {
                        "username": "jlbroughton",
                        "content": "why on earth do people put solutions in the discussion section"
                    },
                    {
                        "username": "eduard92",
                        "content": "I like it when they write FAANG CODE, like you have to memorize it."
                    },
                    {
                        "username": "ecrane0107",
                        "content": "Can some one explain the xor operator better for python? \\n\\nThank you"
                    },
                    {
                        "username": "muhammadaliskipq",
                        "content": "This \"^\" operator is used for XOR in python."
                    },
                    {
                        "username": "__kpsingh__",
                        "content": "A thing about XOR:\\n\\nif a^b = c\\nthen a = c^b"
                    },
                    {
                        "username": "bmolutov",
                        "content": "If we have the following:\\na ^ b = c\\nand we need to find b\\n\\ndo the steps:\\n1) xor both sides\\na ^ b ^ a = c ^ a\\n2) use commutativity property of xor\\na ^ a ^ b = c ^ a\\n3) we know that a ^ a = 0 and 0 ^ b = b\\nb = c ^ a\\n\\nso, b = c ^ a"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        int n=encoded.size();\\n        vector<int>v(n+1);\\n       \\n        v[0]=first;\\n        for(int i=0;i<n;i++){\\n            v[i+1]=encoded[i]^v[i];\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/decode-xored-array/solutions/2969946/javascript-solution-linear-time-linear-space/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# FAANG OPTIMISED CODE 0(N)\\nhttps://leetcode.com/problems/decode-xored-array/solutions/2221022/faang-optimised-code-0-n/"
                    }
                ]
            },
            {
                "id": 1680306,
                "content": [
                    {
                        "username": "pradovski",
                        "content": "a xor b = c\\n(a xor b) xor a = c xor a\\n(a xor a) xor b = c xor a\\n0 xor b = c xor a\\nb = c xor a"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "__Thank You__ !! For Intuition!!\n\nBasically XOR has few interesting _property_ like :\n-  a^a = 0 [ XOR between any two same number gives zero ]\n-  a^0 = a [ XOR between any number with zero gives itself ]\n - a^b=c \n   a^c = b [XOR reverse operation]\n\nThis is what i know so far :)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/decode-xored-array/solutions/2221022/faang-optimised-code-0-n/"
                    },
                    {
                        "username": "kishokkumar",
                        "content": "XOR working:\\nLets take the Input as [1,0,2,1] and output will be [1,2,3]\\n\\nExplanation:\\nFirst we need to understand XOR operation\\n\\n\\uD83D\\uDC49XOR operations:\\n     0+0 = 0\\n     1+1 = 0\\n     1+0 = 1\\n     0+1 = 1 \\n\\nLet\\'s perform some binary XOR operation from the input above:\\n1 => 0001\\n0 => 0000\\nres = 0001 (As per the XOR operation, we got the results as 0001, which is \"1\")\\u2705\\n\\nfor, 0 XOR 2 = 2\\u2705\\n\\nthen 2 XOR 1 will be,\\n2 => 0010\\n1 => 0001\\nres = 0011 ( 3 )\\u2705\\n\\nThis is how we got the output as [1, 2, 3] \\u2705\\n\\nIf u have any doubts. comment down below, \\nAll the best to find the efficient solution.\\u2764\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "can someone explain the XOR part in English please.. I mean what is actually going on here..\\n `encoded[i] = arr[i] XOR arr[i + 1]`\\nwhat is XOR doing up there..\\nAppreciated\\n"
                    },
                    {
                        "username": "kashish2031225",
                        "content": "the XOR of ith and (i+1)th element of the original array(output array) i.e.,arr is stored in encoded array(given array)\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "okay I get it, after doing some research here is the link if you wanna take a look... https://www.pcmag.com/encyclopedia/term/xor#:~:text=XOR%20compares%20two%20input%20bits,different%2C%20the%20result%20is%201."
                    },
                    {
                        "username": "jlbroughton",
                        "content": "why on earth do people put solutions in the discussion section"
                    },
                    {
                        "username": "eduard92",
                        "content": "I like it when they write FAANG CODE, like you have to memorize it."
                    },
                    {
                        "username": "ecrane0107",
                        "content": "Can some one explain the xor operator better for python? \\n\\nThank you"
                    },
                    {
                        "username": "muhammadaliskipq",
                        "content": "This \"^\" operator is used for XOR in python."
                    },
                    {
                        "username": "__kpsingh__",
                        "content": "A thing about XOR:\\n\\nif a^b = c\\nthen a = c^b"
                    },
                    {
                        "username": "bmolutov",
                        "content": "If we have the following:\\na ^ b = c\\nand we need to find b\\n\\ndo the steps:\\n1) xor both sides\\na ^ b ^ a = c ^ a\\n2) use commutativity property of xor\\na ^ a ^ b = c ^ a\\n3) we know that a ^ a = 0 and 0 ^ b = b\\nb = c ^ a\\n\\nso, b = c ^ a"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        int n=encoded.size();\\n        vector<int>v(n+1);\\n       \\n        v[0]=first;\\n        for(int i=0;i<n;i++){\\n            v[i+1]=encoded[i]^v[i];\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/decode-xored-array/solutions/2969946/javascript-solution-linear-time-linear-space/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# FAANG OPTIMISED CODE 0(N)\\nhttps://leetcode.com/problems/decode-xored-array/solutions/2221022/faang-optimised-code-0-n/"
                    }
                ]
            },
            {
                "id": 1566382,
                "content": [
                    {
                        "username": "pradovski",
                        "content": "a xor b = c\\n(a xor b) xor a = c xor a\\n(a xor a) xor b = c xor a\\n0 xor b = c xor a\\nb = c xor a"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "__Thank You__ !! For Intuition!!\n\nBasically XOR has few interesting _property_ like :\n-  a^a = 0 [ XOR between any two same number gives zero ]\n-  a^0 = a [ XOR between any number with zero gives itself ]\n - a^b=c \n   a^c = b [XOR reverse operation]\n\nThis is what i know so far :)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/decode-xored-array/solutions/2221022/faang-optimised-code-0-n/"
                    },
                    {
                        "username": "kishokkumar",
                        "content": "XOR working:\\nLets take the Input as [1,0,2,1] and output will be [1,2,3]\\n\\nExplanation:\\nFirst we need to understand XOR operation\\n\\n\\uD83D\\uDC49XOR operations:\\n     0+0 = 0\\n     1+1 = 0\\n     1+0 = 1\\n     0+1 = 1 \\n\\nLet\\'s perform some binary XOR operation from the input above:\\n1 => 0001\\n0 => 0000\\nres = 0001 (As per the XOR operation, we got the results as 0001, which is \"1\")\\u2705\\n\\nfor, 0 XOR 2 = 2\\u2705\\n\\nthen 2 XOR 1 will be,\\n2 => 0010\\n1 => 0001\\nres = 0011 ( 3 )\\u2705\\n\\nThis is how we got the output as [1, 2, 3] \\u2705\\n\\nIf u have any doubts. comment down below, \\nAll the best to find the efficient solution.\\u2764\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "can someone explain the XOR part in English please.. I mean what is actually going on here..\\n `encoded[i] = arr[i] XOR arr[i + 1]`\\nwhat is XOR doing up there..\\nAppreciated\\n"
                    },
                    {
                        "username": "kashish2031225",
                        "content": "the XOR of ith and (i+1)th element of the original array(output array) i.e.,arr is stored in encoded array(given array)\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "okay I get it, after doing some research here is the link if you wanna take a look... https://www.pcmag.com/encyclopedia/term/xor#:~:text=XOR%20compares%20two%20input%20bits,different%2C%20the%20result%20is%201."
                    },
                    {
                        "username": "jlbroughton",
                        "content": "why on earth do people put solutions in the discussion section"
                    },
                    {
                        "username": "eduard92",
                        "content": "I like it when they write FAANG CODE, like you have to memorize it."
                    },
                    {
                        "username": "ecrane0107",
                        "content": "Can some one explain the xor operator better for python? \\n\\nThank you"
                    },
                    {
                        "username": "muhammadaliskipq",
                        "content": "This \"^\" operator is used for XOR in python."
                    },
                    {
                        "username": "__kpsingh__",
                        "content": "A thing about XOR:\\n\\nif a^b = c\\nthen a = c^b"
                    },
                    {
                        "username": "bmolutov",
                        "content": "If we have the following:\\na ^ b = c\\nand we need to find b\\n\\ndo the steps:\\n1) xor both sides\\na ^ b ^ a = c ^ a\\n2) use commutativity property of xor\\na ^ a ^ b = c ^ a\\n3) we know that a ^ a = 0 and 0 ^ b = b\\nb = c ^ a\\n\\nso, b = c ^ a"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        int n=encoded.size();\\n        vector<int>v(n+1);\\n       \\n        v[0]=first;\\n        for(int i=0;i<n;i++){\\n            v[i+1]=encoded[i]^v[i];\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/decode-xored-array/solutions/2969946/javascript-solution-linear-time-linear-space/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# FAANG OPTIMISED CODE 0(N)\\nhttps://leetcode.com/problems/decode-xored-array/solutions/2221022/faang-optimised-code-0-n/"
                    }
                ]
            },
            {
                "id": 1818607,
                "content": [
                    {
                        "username": "pradovski",
                        "content": "a xor b = c\\n(a xor b) xor a = c xor a\\n(a xor a) xor b = c xor a\\n0 xor b = c xor a\\nb = c xor a"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "__Thank You__ !! For Intuition!!\n\nBasically XOR has few interesting _property_ like :\n-  a^a = 0 [ XOR between any two same number gives zero ]\n-  a^0 = a [ XOR between any number with zero gives itself ]\n - a^b=c \n   a^c = b [XOR reverse operation]\n\nThis is what i know so far :)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/decode-xored-array/solutions/2221022/faang-optimised-code-0-n/"
                    },
                    {
                        "username": "kishokkumar",
                        "content": "XOR working:\\nLets take the Input as [1,0,2,1] and output will be [1,2,3]\\n\\nExplanation:\\nFirst we need to understand XOR operation\\n\\n\\uD83D\\uDC49XOR operations:\\n     0+0 = 0\\n     1+1 = 0\\n     1+0 = 1\\n     0+1 = 1 \\n\\nLet\\'s perform some binary XOR operation from the input above:\\n1 => 0001\\n0 => 0000\\nres = 0001 (As per the XOR operation, we got the results as 0001, which is \"1\")\\u2705\\n\\nfor, 0 XOR 2 = 2\\u2705\\n\\nthen 2 XOR 1 will be,\\n2 => 0010\\n1 => 0001\\nres = 0011 ( 3 )\\u2705\\n\\nThis is how we got the output as [1, 2, 3] \\u2705\\n\\nIf u have any doubts. comment down below, \\nAll the best to find the efficient solution.\\u2764\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "can someone explain the XOR part in English please.. I mean what is actually going on here..\\n `encoded[i] = arr[i] XOR arr[i + 1]`\\nwhat is XOR doing up there..\\nAppreciated\\n"
                    },
                    {
                        "username": "kashish2031225",
                        "content": "the XOR of ith and (i+1)th element of the original array(output array) i.e.,arr is stored in encoded array(given array)\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "okay I get it, after doing some research here is the link if you wanna take a look... https://www.pcmag.com/encyclopedia/term/xor#:~:text=XOR%20compares%20two%20input%20bits,different%2C%20the%20result%20is%201."
                    },
                    {
                        "username": "jlbroughton",
                        "content": "why on earth do people put solutions in the discussion section"
                    },
                    {
                        "username": "eduard92",
                        "content": "I like it when they write FAANG CODE, like you have to memorize it."
                    },
                    {
                        "username": "ecrane0107",
                        "content": "Can some one explain the xor operator better for python? \\n\\nThank you"
                    },
                    {
                        "username": "muhammadaliskipq",
                        "content": "This \"^\" operator is used for XOR in python."
                    },
                    {
                        "username": "__kpsingh__",
                        "content": "A thing about XOR:\\n\\nif a^b = c\\nthen a = c^b"
                    },
                    {
                        "username": "bmolutov",
                        "content": "If we have the following:\\na ^ b = c\\nand we need to find b\\n\\ndo the steps:\\n1) xor both sides\\na ^ b ^ a = c ^ a\\n2) use commutativity property of xor\\na ^ a ^ b = c ^ a\\n3) we know that a ^ a = 0 and 0 ^ b = b\\nb = c ^ a\\n\\nso, b = c ^ a"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        int n=encoded.size();\\n        vector<int>v(n+1);\\n       \\n        v[0]=first;\\n        for(int i=0;i<n;i++){\\n            v[i+1]=encoded[i]^v[i];\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/decode-xored-array/solutions/2969946/javascript-solution-linear-time-linear-space/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# FAANG OPTIMISED CODE 0(N)\\nhttps://leetcode.com/problems/decode-xored-array/solutions/2221022/faang-optimised-code-0-n/"
                    }
                ]
            },
            {
                "id": 1685296,
                "content": [
                    {
                        "username": "pradovski",
                        "content": "a xor b = c\\n(a xor b) xor a = c xor a\\n(a xor a) xor b = c xor a\\n0 xor b = c xor a\\nb = c xor a"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "__Thank You__ !! For Intuition!!\n\nBasically XOR has few interesting _property_ like :\n-  a^a = 0 [ XOR between any two same number gives zero ]\n-  a^0 = a [ XOR between any number with zero gives itself ]\n - a^b=c \n   a^c = b [XOR reverse operation]\n\nThis is what i know so far :)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/decode-xored-array/solutions/2221022/faang-optimised-code-0-n/"
                    },
                    {
                        "username": "kishokkumar",
                        "content": "XOR working:\\nLets take the Input as [1,0,2,1] and output will be [1,2,3]\\n\\nExplanation:\\nFirst we need to understand XOR operation\\n\\n\\uD83D\\uDC49XOR operations:\\n     0+0 = 0\\n     1+1 = 0\\n     1+0 = 1\\n     0+1 = 1 \\n\\nLet\\'s perform some binary XOR operation from the input above:\\n1 => 0001\\n0 => 0000\\nres = 0001 (As per the XOR operation, we got the results as 0001, which is \"1\")\\u2705\\n\\nfor, 0 XOR 2 = 2\\u2705\\n\\nthen 2 XOR 1 will be,\\n2 => 0010\\n1 => 0001\\nres = 0011 ( 3 )\\u2705\\n\\nThis is how we got the output as [1, 2, 3] \\u2705\\n\\nIf u have any doubts. comment down below, \\nAll the best to find the efficient solution.\\u2764\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "can someone explain the XOR part in English please.. I mean what is actually going on here..\\n `encoded[i] = arr[i] XOR arr[i + 1]`\\nwhat is XOR doing up there..\\nAppreciated\\n"
                    },
                    {
                        "username": "kashish2031225",
                        "content": "the XOR of ith and (i+1)th element of the original array(output array) i.e.,arr is stored in encoded array(given array)\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "okay I get it, after doing some research here is the link if you wanna take a look... https://www.pcmag.com/encyclopedia/term/xor#:~:text=XOR%20compares%20two%20input%20bits,different%2C%20the%20result%20is%201."
                    },
                    {
                        "username": "jlbroughton",
                        "content": "why on earth do people put solutions in the discussion section"
                    },
                    {
                        "username": "eduard92",
                        "content": "I like it when they write FAANG CODE, like you have to memorize it."
                    },
                    {
                        "username": "ecrane0107",
                        "content": "Can some one explain the xor operator better for python? \\n\\nThank you"
                    },
                    {
                        "username": "muhammadaliskipq",
                        "content": "This \"^\" operator is used for XOR in python."
                    },
                    {
                        "username": "__kpsingh__",
                        "content": "A thing about XOR:\\n\\nif a^b = c\\nthen a = c^b"
                    },
                    {
                        "username": "bmolutov",
                        "content": "If we have the following:\\na ^ b = c\\nand we need to find b\\n\\ndo the steps:\\n1) xor both sides\\na ^ b ^ a = c ^ a\\n2) use commutativity property of xor\\na ^ a ^ b = c ^ a\\n3) we know that a ^ a = 0 and 0 ^ b = b\\nb = c ^ a\\n\\nso, b = c ^ a"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        int n=encoded.size();\\n        vector<int>v(n+1);\\n       \\n        v[0]=first;\\n        for(int i=0;i<n;i++){\\n            v[i+1]=encoded[i]^v[i];\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/decode-xored-array/solutions/2969946/javascript-solution-linear-time-linear-space/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# FAANG OPTIMISED CODE 0(N)\\nhttps://leetcode.com/problems/decode-xored-array/solutions/2221022/faang-optimised-code-0-n/"
                    }
                ]
            },
            {
                "id": 1960567,
                "content": [
                    {
                        "username": "pradovski",
                        "content": "a xor b = c\\n(a xor b) xor a = c xor a\\n(a xor a) xor b = c xor a\\n0 xor b = c xor a\\nb = c xor a"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "__Thank You__ !! For Intuition!!\n\nBasically XOR has few interesting _property_ like :\n-  a^a = 0 [ XOR between any two same number gives zero ]\n-  a^0 = a [ XOR between any number with zero gives itself ]\n - a^b=c \n   a^c = b [XOR reverse operation]\n\nThis is what i know so far :)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/decode-xored-array/solutions/2221022/faang-optimised-code-0-n/"
                    },
                    {
                        "username": "kishokkumar",
                        "content": "XOR working:\\nLets take the Input as [1,0,2,1] and output will be [1,2,3]\\n\\nExplanation:\\nFirst we need to understand XOR operation\\n\\n\\uD83D\\uDC49XOR operations:\\n     0+0 = 0\\n     1+1 = 0\\n     1+0 = 1\\n     0+1 = 1 \\n\\nLet\\'s perform some binary XOR operation from the input above:\\n1 => 0001\\n0 => 0000\\nres = 0001 (As per the XOR operation, we got the results as 0001, which is \"1\")\\u2705\\n\\nfor, 0 XOR 2 = 2\\u2705\\n\\nthen 2 XOR 1 will be,\\n2 => 0010\\n1 => 0001\\nres = 0011 ( 3 )\\u2705\\n\\nThis is how we got the output as [1, 2, 3] \\u2705\\n\\nIf u have any doubts. comment down below, \\nAll the best to find the efficient solution.\\u2764\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "can someone explain the XOR part in English please.. I mean what is actually going on here..\\n `encoded[i] = arr[i] XOR arr[i + 1]`\\nwhat is XOR doing up there..\\nAppreciated\\n"
                    },
                    {
                        "username": "kashish2031225",
                        "content": "the XOR of ith and (i+1)th element of the original array(output array) i.e.,arr is stored in encoded array(given array)\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "okay I get it, after doing some research here is the link if you wanna take a look... https://www.pcmag.com/encyclopedia/term/xor#:~:text=XOR%20compares%20two%20input%20bits,different%2C%20the%20result%20is%201."
                    },
                    {
                        "username": "jlbroughton",
                        "content": "why on earth do people put solutions in the discussion section"
                    },
                    {
                        "username": "eduard92",
                        "content": "I like it when they write FAANG CODE, like you have to memorize it."
                    },
                    {
                        "username": "ecrane0107",
                        "content": "Can some one explain the xor operator better for python? \\n\\nThank you"
                    },
                    {
                        "username": "muhammadaliskipq",
                        "content": "This \"^\" operator is used for XOR in python."
                    },
                    {
                        "username": "__kpsingh__",
                        "content": "A thing about XOR:\\n\\nif a^b = c\\nthen a = c^b"
                    },
                    {
                        "username": "bmolutov",
                        "content": "If we have the following:\\na ^ b = c\\nand we need to find b\\n\\ndo the steps:\\n1) xor both sides\\na ^ b ^ a = c ^ a\\n2) use commutativity property of xor\\na ^ a ^ b = c ^ a\\n3) we know that a ^ a = 0 and 0 ^ b = b\\nb = c ^ a\\n\\nso, b = c ^ a"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        int n=encoded.size();\\n        vector<int>v(n+1);\\n       \\n        v[0]=first;\\n        for(int i=0;i<n;i++){\\n            v[i+1]=encoded[i]^v[i];\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/decode-xored-array/solutions/2969946/javascript-solution-linear-time-linear-space/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# FAANG OPTIMISED CODE 0(N)\\nhttps://leetcode.com/problems/decode-xored-array/solutions/2221022/faang-optimised-code-0-n/"
                    }
                ]
            },
            {
                "id": 1722624,
                "content": [
                    {
                        "username": "pradovski",
                        "content": "a xor b = c\\n(a xor b) xor a = c xor a\\n(a xor a) xor b = c xor a\\n0 xor b = c xor a\\nb = c xor a"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "__Thank You__ !! For Intuition!!\n\nBasically XOR has few interesting _property_ like :\n-  a^a = 0 [ XOR between any two same number gives zero ]\n-  a^0 = a [ XOR between any number with zero gives itself ]\n - a^b=c \n   a^c = b [XOR reverse operation]\n\nThis is what i know so far :)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/decode-xored-array/solutions/2221022/faang-optimised-code-0-n/"
                    },
                    {
                        "username": "kishokkumar",
                        "content": "XOR working:\\nLets take the Input as [1,0,2,1] and output will be [1,2,3]\\n\\nExplanation:\\nFirst we need to understand XOR operation\\n\\n\\uD83D\\uDC49XOR operations:\\n     0+0 = 0\\n     1+1 = 0\\n     1+0 = 1\\n     0+1 = 1 \\n\\nLet\\'s perform some binary XOR operation from the input above:\\n1 => 0001\\n0 => 0000\\nres = 0001 (As per the XOR operation, we got the results as 0001, which is \"1\")\\u2705\\n\\nfor, 0 XOR 2 = 2\\u2705\\n\\nthen 2 XOR 1 will be,\\n2 => 0010\\n1 => 0001\\nres = 0011 ( 3 )\\u2705\\n\\nThis is how we got the output as [1, 2, 3] \\u2705\\n\\nIf u have any doubts. comment down below, \\nAll the best to find the efficient solution.\\u2764\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "can someone explain the XOR part in English please.. I mean what is actually going on here..\\n `encoded[i] = arr[i] XOR arr[i + 1]`\\nwhat is XOR doing up there..\\nAppreciated\\n"
                    },
                    {
                        "username": "kashish2031225",
                        "content": "the XOR of ith and (i+1)th element of the original array(output array) i.e.,arr is stored in encoded array(given array)\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "okay I get it, after doing some research here is the link if you wanna take a look... https://www.pcmag.com/encyclopedia/term/xor#:~:text=XOR%20compares%20two%20input%20bits,different%2C%20the%20result%20is%201."
                    },
                    {
                        "username": "jlbroughton",
                        "content": "why on earth do people put solutions in the discussion section"
                    },
                    {
                        "username": "eduard92",
                        "content": "I like it when they write FAANG CODE, like you have to memorize it."
                    },
                    {
                        "username": "ecrane0107",
                        "content": "Can some one explain the xor operator better for python? \\n\\nThank you"
                    },
                    {
                        "username": "muhammadaliskipq",
                        "content": "This \"^\" operator is used for XOR in python."
                    },
                    {
                        "username": "__kpsingh__",
                        "content": "A thing about XOR:\\n\\nif a^b = c\\nthen a = c^b"
                    },
                    {
                        "username": "bmolutov",
                        "content": "If we have the following:\\na ^ b = c\\nand we need to find b\\n\\ndo the steps:\\n1) xor both sides\\na ^ b ^ a = c ^ a\\n2) use commutativity property of xor\\na ^ a ^ b = c ^ a\\n3) we know that a ^ a = 0 and 0 ^ b = b\\nb = c ^ a\\n\\nso, b = c ^ a"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        int n=encoded.size();\\n        vector<int>v(n+1);\\n       \\n        v[0]=first;\\n        for(int i=0;i<n;i++){\\n            v[i+1]=encoded[i]^v[i];\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/decode-xored-array/solutions/2969946/javascript-solution-linear-time-linear-space/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# FAANG OPTIMISED CODE 0(N)\\nhttps://leetcode.com/problems/decode-xored-array/solutions/2221022/faang-optimised-code-0-n/"
                    }
                ]
            },
            {
                "id": 1799875,
                "content": [
                    {
                        "username": "pradovski",
                        "content": "a xor b = c\\n(a xor b) xor a = c xor a\\n(a xor a) xor b = c xor a\\n0 xor b = c xor a\\nb = c xor a"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "__Thank You__ !! For Intuition!!\n\nBasically XOR has few interesting _property_ like :\n-  a^a = 0 [ XOR between any two same number gives zero ]\n-  a^0 = a [ XOR between any number with zero gives itself ]\n - a^b=c \n   a^c = b [XOR reverse operation]\n\nThis is what i know so far :)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/decode-xored-array/solutions/2221022/faang-optimised-code-0-n/"
                    },
                    {
                        "username": "kishokkumar",
                        "content": "XOR working:\\nLets take the Input as [1,0,2,1] and output will be [1,2,3]\\n\\nExplanation:\\nFirst we need to understand XOR operation\\n\\n\\uD83D\\uDC49XOR operations:\\n     0+0 = 0\\n     1+1 = 0\\n     1+0 = 1\\n     0+1 = 1 \\n\\nLet\\'s perform some binary XOR operation from the input above:\\n1 => 0001\\n0 => 0000\\nres = 0001 (As per the XOR operation, we got the results as 0001, which is \"1\")\\u2705\\n\\nfor, 0 XOR 2 = 2\\u2705\\n\\nthen 2 XOR 1 will be,\\n2 => 0010\\n1 => 0001\\nres = 0011 ( 3 )\\u2705\\n\\nThis is how we got the output as [1, 2, 3] \\u2705\\n\\nIf u have any doubts. comment down below, \\nAll the best to find the efficient solution.\\u2764\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "can someone explain the XOR part in English please.. I mean what is actually going on here..\\n `encoded[i] = arr[i] XOR arr[i + 1]`\\nwhat is XOR doing up there..\\nAppreciated\\n"
                    },
                    {
                        "username": "kashish2031225",
                        "content": "the XOR of ith and (i+1)th element of the original array(output array) i.e.,arr is stored in encoded array(given array)\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "okay I get it, after doing some research here is the link if you wanna take a look... https://www.pcmag.com/encyclopedia/term/xor#:~:text=XOR%20compares%20two%20input%20bits,different%2C%20the%20result%20is%201."
                    },
                    {
                        "username": "jlbroughton",
                        "content": "why on earth do people put solutions in the discussion section"
                    },
                    {
                        "username": "eduard92",
                        "content": "I like it when they write FAANG CODE, like you have to memorize it."
                    },
                    {
                        "username": "ecrane0107",
                        "content": "Can some one explain the xor operator better for python? \\n\\nThank you"
                    },
                    {
                        "username": "muhammadaliskipq",
                        "content": "This \"^\" operator is used for XOR in python."
                    },
                    {
                        "username": "__kpsingh__",
                        "content": "A thing about XOR:\\n\\nif a^b = c\\nthen a = c^b"
                    },
                    {
                        "username": "bmolutov",
                        "content": "If we have the following:\\na ^ b = c\\nand we need to find b\\n\\ndo the steps:\\n1) xor both sides\\na ^ b ^ a = c ^ a\\n2) use commutativity property of xor\\na ^ a ^ b = c ^ a\\n3) we know that a ^ a = 0 and 0 ^ b = b\\nb = c ^ a\\n\\nso, b = c ^ a"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        int n=encoded.size();\\n        vector<int>v(n+1);\\n       \\n        v[0]=first;\\n        for(int i=0;i<n;i++){\\n            v[i+1]=encoded[i]^v[i];\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/decode-xored-array/solutions/2969946/javascript-solution-linear-time-linear-space/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# FAANG OPTIMISED CODE 0(N)\\nhttps://leetcode.com/problems/decode-xored-array/solutions/2221022/faang-optimised-code-0-n/"
                    }
                ]
            },
            {
                "id": 1956204,
                "content": [
                    {
                        "username": "pradovski",
                        "content": "a xor b = c\\n(a xor b) xor a = c xor a\\n(a xor a) xor b = c xor a\\n0 xor b = c xor a\\nb = c xor a"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "__Thank You__ !! For Intuition!!\n\nBasically XOR has few interesting _property_ like :\n-  a^a = 0 [ XOR between any two same number gives zero ]\n-  a^0 = a [ XOR between any number with zero gives itself ]\n - a^b=c \n   a^c = b [XOR reverse operation]\n\nThis is what i know so far :)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/decode-xored-array/solutions/2221022/faang-optimised-code-0-n/"
                    },
                    {
                        "username": "kishokkumar",
                        "content": "XOR working:\\nLets take the Input as [1,0,2,1] and output will be [1,2,3]\\n\\nExplanation:\\nFirst we need to understand XOR operation\\n\\n\\uD83D\\uDC49XOR operations:\\n     0+0 = 0\\n     1+1 = 0\\n     1+0 = 1\\n     0+1 = 1 \\n\\nLet\\'s perform some binary XOR operation from the input above:\\n1 => 0001\\n0 => 0000\\nres = 0001 (As per the XOR operation, we got the results as 0001, which is \"1\")\\u2705\\n\\nfor, 0 XOR 2 = 2\\u2705\\n\\nthen 2 XOR 1 will be,\\n2 => 0010\\n1 => 0001\\nres = 0011 ( 3 )\\u2705\\n\\nThis is how we got the output as [1, 2, 3] \\u2705\\n\\nIf u have any doubts. comment down below, \\nAll the best to find the efficient solution.\\u2764\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "can someone explain the XOR part in English please.. I mean what is actually going on here..\\n `encoded[i] = arr[i] XOR arr[i + 1]`\\nwhat is XOR doing up there..\\nAppreciated\\n"
                    },
                    {
                        "username": "kashish2031225",
                        "content": "the XOR of ith and (i+1)th element of the original array(output array) i.e.,arr is stored in encoded array(given array)\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "okay I get it, after doing some research here is the link if you wanna take a look... https://www.pcmag.com/encyclopedia/term/xor#:~:text=XOR%20compares%20two%20input%20bits,different%2C%20the%20result%20is%201."
                    },
                    {
                        "username": "jlbroughton",
                        "content": "why on earth do people put solutions in the discussion section"
                    },
                    {
                        "username": "eduard92",
                        "content": "I like it when they write FAANG CODE, like you have to memorize it."
                    },
                    {
                        "username": "ecrane0107",
                        "content": "Can some one explain the xor operator better for python? \\n\\nThank you"
                    },
                    {
                        "username": "muhammadaliskipq",
                        "content": "This \"^\" operator is used for XOR in python."
                    },
                    {
                        "username": "__kpsingh__",
                        "content": "A thing about XOR:\\n\\nif a^b = c\\nthen a = c^b"
                    },
                    {
                        "username": "bmolutov",
                        "content": "If we have the following:\\na ^ b = c\\nand we need to find b\\n\\ndo the steps:\\n1) xor both sides\\na ^ b ^ a = c ^ a\\n2) use commutativity property of xor\\na ^ a ^ b = c ^ a\\n3) we know that a ^ a = 0 and 0 ^ b = b\\nb = c ^ a\\n\\nso, b = c ^ a"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        int n=encoded.size();\\n        vector<int>v(n+1);\\n       \\n        v[0]=first;\\n        for(int i=0;i<n;i++){\\n            v[i+1]=encoded[i]^v[i];\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/decode-xored-array/solutions/2969946/javascript-solution-linear-time-linear-space/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# FAANG OPTIMISED CODE 0(N)\\nhttps://leetcode.com/problems/decode-xored-array/solutions/2221022/faang-optimised-code-0-n/"
                    }
                ]
            },
            {
                "id": 1833865,
                "content": [
                    {
                        "username": "pradovski",
                        "content": "a xor b = c\\n(a xor b) xor a = c xor a\\n(a xor a) xor b = c xor a\\n0 xor b = c xor a\\nb = c xor a"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "__Thank You__ !! For Intuition!!\n\nBasically XOR has few interesting _property_ like :\n-  a^a = 0 [ XOR between any two same number gives zero ]\n-  a^0 = a [ XOR between any number with zero gives itself ]\n - a^b=c \n   a^c = b [XOR reverse operation]\n\nThis is what i know so far :)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/decode-xored-array/solutions/2221022/faang-optimised-code-0-n/"
                    },
                    {
                        "username": "kishokkumar",
                        "content": "XOR working:\\nLets take the Input as [1,0,2,1] and output will be [1,2,3]\\n\\nExplanation:\\nFirst we need to understand XOR operation\\n\\n\\uD83D\\uDC49XOR operations:\\n     0+0 = 0\\n     1+1 = 0\\n     1+0 = 1\\n     0+1 = 1 \\n\\nLet\\'s perform some binary XOR operation from the input above:\\n1 => 0001\\n0 => 0000\\nres = 0001 (As per the XOR operation, we got the results as 0001, which is \"1\")\\u2705\\n\\nfor, 0 XOR 2 = 2\\u2705\\n\\nthen 2 XOR 1 will be,\\n2 => 0010\\n1 => 0001\\nres = 0011 ( 3 )\\u2705\\n\\nThis is how we got the output as [1, 2, 3] \\u2705\\n\\nIf u have any doubts. comment down below, \\nAll the best to find the efficient solution.\\u2764\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "can someone explain the XOR part in English please.. I mean what is actually going on here..\\n `encoded[i] = arr[i] XOR arr[i + 1]`\\nwhat is XOR doing up there..\\nAppreciated\\n"
                    },
                    {
                        "username": "kashish2031225",
                        "content": "the XOR of ith and (i+1)th element of the original array(output array) i.e.,arr is stored in encoded array(given array)\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "okay I get it, after doing some research here is the link if you wanna take a look... https://www.pcmag.com/encyclopedia/term/xor#:~:text=XOR%20compares%20two%20input%20bits,different%2C%20the%20result%20is%201."
                    },
                    {
                        "username": "jlbroughton",
                        "content": "why on earth do people put solutions in the discussion section"
                    },
                    {
                        "username": "eduard92",
                        "content": "I like it when they write FAANG CODE, like you have to memorize it."
                    },
                    {
                        "username": "ecrane0107",
                        "content": "Can some one explain the xor operator better for python? \\n\\nThank you"
                    },
                    {
                        "username": "muhammadaliskipq",
                        "content": "This \"^\" operator is used for XOR in python."
                    },
                    {
                        "username": "__kpsingh__",
                        "content": "A thing about XOR:\\n\\nif a^b = c\\nthen a = c^b"
                    },
                    {
                        "username": "bmolutov",
                        "content": "If we have the following:\\na ^ b = c\\nand we need to find b\\n\\ndo the steps:\\n1) xor both sides\\na ^ b ^ a = c ^ a\\n2) use commutativity property of xor\\na ^ a ^ b = c ^ a\\n3) we know that a ^ a = 0 and 0 ^ b = b\\nb = c ^ a\\n\\nso, b = c ^ a"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        int n=encoded.size();\\n        vector<int>v(n+1);\\n       \\n        v[0]=first;\\n        for(int i=0;i<n;i++){\\n            v[i+1]=encoded[i]^v[i];\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/decode-xored-array/solutions/2969946/javascript-solution-linear-time-linear-space/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# FAANG OPTIMISED CODE 0(N)\\nhttps://leetcode.com/problems/decode-xored-array/solutions/2221022/faang-optimised-code-0-n/"
                    }
                ]
            },
            {
                "id": 1733873,
                "content": [
                    {
                        "username": "pradovski",
                        "content": "a xor b = c\\n(a xor b) xor a = c xor a\\n(a xor a) xor b = c xor a\\n0 xor b = c xor a\\nb = c xor a"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "__Thank You__ !! For Intuition!!\n\nBasically XOR has few interesting _property_ like :\n-  a^a = 0 [ XOR between any two same number gives zero ]\n-  a^0 = a [ XOR between any number with zero gives itself ]\n - a^b=c \n   a^c = b [XOR reverse operation]\n\nThis is what i know so far :)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/decode-xored-array/solutions/2221022/faang-optimised-code-0-n/"
                    },
                    {
                        "username": "kishokkumar",
                        "content": "XOR working:\\nLets take the Input as [1,0,2,1] and output will be [1,2,3]\\n\\nExplanation:\\nFirst we need to understand XOR operation\\n\\n\\uD83D\\uDC49XOR operations:\\n     0+0 = 0\\n     1+1 = 0\\n     1+0 = 1\\n     0+1 = 1 \\n\\nLet\\'s perform some binary XOR operation from the input above:\\n1 => 0001\\n0 => 0000\\nres = 0001 (As per the XOR operation, we got the results as 0001, which is \"1\")\\u2705\\n\\nfor, 0 XOR 2 = 2\\u2705\\n\\nthen 2 XOR 1 will be,\\n2 => 0010\\n1 => 0001\\nres = 0011 ( 3 )\\u2705\\n\\nThis is how we got the output as [1, 2, 3] \\u2705\\n\\nIf u have any doubts. comment down below, \\nAll the best to find the efficient solution.\\u2764\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "can someone explain the XOR part in English please.. I mean what is actually going on here..\\n `encoded[i] = arr[i] XOR arr[i + 1]`\\nwhat is XOR doing up there..\\nAppreciated\\n"
                    },
                    {
                        "username": "kashish2031225",
                        "content": "the XOR of ith and (i+1)th element of the original array(output array) i.e.,arr is stored in encoded array(given array)\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "okay I get it, after doing some research here is the link if you wanna take a look... https://www.pcmag.com/encyclopedia/term/xor#:~:text=XOR%20compares%20two%20input%20bits,different%2C%20the%20result%20is%201."
                    },
                    {
                        "username": "jlbroughton",
                        "content": "why on earth do people put solutions in the discussion section"
                    },
                    {
                        "username": "eduard92",
                        "content": "I like it when they write FAANG CODE, like you have to memorize it."
                    },
                    {
                        "username": "ecrane0107",
                        "content": "Can some one explain the xor operator better for python? \\n\\nThank you"
                    },
                    {
                        "username": "muhammadaliskipq",
                        "content": "This \"^\" operator is used for XOR in python."
                    },
                    {
                        "username": "__kpsingh__",
                        "content": "A thing about XOR:\\n\\nif a^b = c\\nthen a = c^b"
                    },
                    {
                        "username": "bmolutov",
                        "content": "If we have the following:\\na ^ b = c\\nand we need to find b\\n\\ndo the steps:\\n1) xor both sides\\na ^ b ^ a = c ^ a\\n2) use commutativity property of xor\\na ^ a ^ b = c ^ a\\n3) we know that a ^ a = 0 and 0 ^ b = b\\nb = c ^ a\\n\\nso, b = c ^ a"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        int n=encoded.size();\\n        vector<int>v(n+1);\\n       \\n        v[0]=first;\\n        for(int i=0;i<n;i++){\\n            v[i+1]=encoded[i]^v[i];\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/decode-xored-array/solutions/2969946/javascript-solution-linear-time-linear-space/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# FAANG OPTIMISED CODE 0(N)\\nhttps://leetcode.com/problems/decode-xored-array/solutions/2221022/faang-optimised-code-0-n/"
                    }
                ]
            },
            {
                "id": 1680306,
                "content": [
                    {
                        "username": "pradovski",
                        "content": "a xor b = c\\n(a xor b) xor a = c xor a\\n(a xor a) xor b = c xor a\\n0 xor b = c xor a\\nb = c xor a"
                    },
                    {
                        "username": "bhargav1811",
                        "content": "__Thank You__ !! For Intuition!!\n\nBasically XOR has few interesting _property_ like :\n-  a^a = 0 [ XOR between any two same number gives zero ]\n-  a^0 = a [ XOR between any number with zero gives itself ]\n - a^b=c \n   a^c = b [XOR reverse operation]\n\nThis is what i know so far :)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/decode-xored-array/solutions/2221022/faang-optimised-code-0-n/"
                    },
                    {
                        "username": "kishokkumar",
                        "content": "XOR working:\\nLets take the Input as [1,0,2,1] and output will be [1,2,3]\\n\\nExplanation:\\nFirst we need to understand XOR operation\\n\\n\\uD83D\\uDC49XOR operations:\\n     0+0 = 0\\n     1+1 = 0\\n     1+0 = 1\\n     0+1 = 1 \\n\\nLet\\'s perform some binary XOR operation from the input above:\\n1 => 0001\\n0 => 0000\\nres = 0001 (As per the XOR operation, we got the results as 0001, which is \"1\")\\u2705\\n\\nfor, 0 XOR 2 = 2\\u2705\\n\\nthen 2 XOR 1 will be,\\n2 => 0010\\n1 => 0001\\nres = 0011 ( 3 )\\u2705\\n\\nThis is how we got the output as [1, 2, 3] \\u2705\\n\\nIf u have any doubts. comment down below, \\nAll the best to find the efficient solution.\\u2764\\uFE0F"
                    },
                    {
                        "username": "Bobzero",
                        "content": "can someone explain the XOR part in English please.. I mean what is actually going on here..\\n `encoded[i] = arr[i] XOR arr[i + 1]`\\nwhat is XOR doing up there..\\nAppreciated\\n"
                    },
                    {
                        "username": "kashish2031225",
                        "content": "the XOR of ith and (i+1)th element of the original array(output array) i.e.,arr is stored in encoded array(given array)\\n"
                    },
                    {
                        "username": "Bobzero",
                        "content": "okay I get it, after doing some research here is the link if you wanna take a look... https://www.pcmag.com/encyclopedia/term/xor#:~:text=XOR%20compares%20two%20input%20bits,different%2C%20the%20result%20is%201."
                    },
                    {
                        "username": "jlbroughton",
                        "content": "why on earth do people put solutions in the discussion section"
                    },
                    {
                        "username": "eduard92",
                        "content": "I like it when they write FAANG CODE, like you have to memorize it."
                    },
                    {
                        "username": "ecrane0107",
                        "content": "Can some one explain the xor operator better for python? \\n\\nThank you"
                    },
                    {
                        "username": "muhammadaliskipq",
                        "content": "This \"^\" operator is used for XOR in python."
                    },
                    {
                        "username": "__kpsingh__",
                        "content": "A thing about XOR:\\n\\nif a^b = c\\nthen a = c^b"
                    },
                    {
                        "username": "bmolutov",
                        "content": "If we have the following:\\na ^ b = c\\nand we need to find b\\n\\ndo the steps:\\n1) xor both sides\\na ^ b ^ a = c ^ a\\n2) use commutativity property of xor\\na ^ a ^ b = c ^ a\\n3) we know that a ^ a = 0 and 0 ^ b = b\\nb = c ^ a\\n\\nso, b = c ^ a"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        int n=encoded.size();\\n        vector<int>v(n+1);\\n       \\n        v[0]=first;\\n        for(int i=0;i<n;i++){\\n            v[i+1]=encoded[i]^v[i];\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/decode-xored-array/solutions/2969946/javascript-solution-linear-time-linear-space/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# FAANG OPTIMISED CODE 0(N)\\nhttps://leetcode.com/problems/decode-xored-array/solutions/2221022/faang-optimised-code-0-n/"
                    }
                ]
            },
            {
                "id": 2073068,
                "content": [
                    {
                        "username": "harshverma_",
                        "content": "randi\\n"
                    },
                    {
                        "username": "harshverma_",
                        "content": "Please provide some hard level questions.These type are not expected from you leetcode.F--k Off\\n"
                    },
                    {
                        "username": "harshverma_",
                        "content": "very down level question.Not upto the mark!!!\\n\\n"
                    },
                    {
                        "username": "harshverma_",
                        "content": "too much easy"
                    },
                    {
                        "username": "FerdinaKusumah",
                        "content": "Great explanation is like this\\nsource from here\\nhttps://stackoverflow.com/questions/18335587/finding-the-number-missing-in-the-sequence\\n\\nA XOR B = C => C XOR A = B\\n\\n(PARTIAL SUM) XOR (MISSING ELEMENT) = (TOTAL) \\nSo\\n\\n(TOTAL) XOR ( PATIAL SUM) = (MISSING ELEMNT)\\n\\nas example above\\nencoded = [1,2,3], first = 1\\n\\narray = [1] <- we get result for first value\\n\\n- doing loop each element in encoded\\n\\n- loop 1\\nwe get result = 1 (from encoded) -> we need to xor with last value from array\\n1 (encoded) xor 1 (last value from array) = 0 <- append to array (now array [1, 0])\\n\\n- loop 2\\nwe get result = 2 (from encoded) -> we need to xor with last value from array\\n2 (encoded) xor 0 (last value from array) = 2 <- append to array (now array [1, 0, 2])\\n\\n- loop 3\\nwe get result = 3 (from encoded) -> we need to xor with last value from array\\n2 (encoded) xor 3 (last value from array) = 1 <- append to array (now array [1, 0, 2, 1])\\n\\nthen our final array is like this\\nresult = [1,0,2,1]"
                    },
                    {
                        "username": "prince21212",
                        "content": "hello friends ...\\n  there are nothing in this question if you know the concept of XOR operation and how it works on Bit . lets see some XOR operation \\nits basically that if any of the bit is different on the comparison of second one its give that true .\\n0 ^ 0 = 0 .\\n0 ^ 1 = 1.\\n1 ^ 0 = 1.\\n1 ^ 1 = 0.\\ndecoded[i] = ( encoded[i - 1] ) ^ ( decoded[i - 1] ) \\n\\nIn the above question we have to do this operation basically .\\n\\nthank you !!"
                    },
                    {
                        "username": "itsramashish",
                        "content": "Suggested: Please try once by yourself if u get stuck at any point then u can see the solution here..\\n\\nHere is the Java Code for this Problem \\n\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int ans[] = new int[encoded.length+1];\\n        ans[0] = first;\\n        int j=1;\\n        for(int i=0; i<encoded.length; i++){\\n            ans[j] = encoded[i] ^ ans[i];\\n            j++;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Draklife",
                        "content": "easy x-or oparetion"
                    },
                    {
                        "username": "van146",
                        "content": "Easy one - except that part when you are using JS... everything ordinary become complicated here..."
                    },
                    {
                        "username": "ajayharsh869",
                        "content": "why this code giving run time error??\\n\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector <int> a;\\n        a.push_back(first);\\n        for(int i=0; i<=encoded.size(); i++){\\n            \\n            a.push_back(encoded[i] ^ a[i]);\\n        }\\n        return a;\\n    }\\n};"
                    },
                    {
                        "username": "HarshMishra2k02",
                        "content": "remove the equals to sign from the loop in \"i <= encoded.size() \". Use this instead  \" i < encoded.size() \""
                    }
                ]
            },
            {
                "id": 2073067,
                "content": [
                    {
                        "username": "harshverma_",
                        "content": "randi\\n"
                    },
                    {
                        "username": "harshverma_",
                        "content": "Please provide some hard level questions.These type are not expected from you leetcode.F--k Off\\n"
                    },
                    {
                        "username": "harshverma_",
                        "content": "very down level question.Not upto the mark!!!\\n\\n"
                    },
                    {
                        "username": "harshverma_",
                        "content": "too much easy"
                    },
                    {
                        "username": "FerdinaKusumah",
                        "content": "Great explanation is like this\\nsource from here\\nhttps://stackoverflow.com/questions/18335587/finding-the-number-missing-in-the-sequence\\n\\nA XOR B = C => C XOR A = B\\n\\n(PARTIAL SUM) XOR (MISSING ELEMENT) = (TOTAL) \\nSo\\n\\n(TOTAL) XOR ( PATIAL SUM) = (MISSING ELEMNT)\\n\\nas example above\\nencoded = [1,2,3], first = 1\\n\\narray = [1] <- we get result for first value\\n\\n- doing loop each element in encoded\\n\\n- loop 1\\nwe get result = 1 (from encoded) -> we need to xor with last value from array\\n1 (encoded) xor 1 (last value from array) = 0 <- append to array (now array [1, 0])\\n\\n- loop 2\\nwe get result = 2 (from encoded) -> we need to xor with last value from array\\n2 (encoded) xor 0 (last value from array) = 2 <- append to array (now array [1, 0, 2])\\n\\n- loop 3\\nwe get result = 3 (from encoded) -> we need to xor with last value from array\\n2 (encoded) xor 3 (last value from array) = 1 <- append to array (now array [1, 0, 2, 1])\\n\\nthen our final array is like this\\nresult = [1,0,2,1]"
                    },
                    {
                        "username": "prince21212",
                        "content": "hello friends ...\\n  there are nothing in this question if you know the concept of XOR operation and how it works on Bit . lets see some XOR operation \\nits basically that if any of the bit is different on the comparison of second one its give that true .\\n0 ^ 0 = 0 .\\n0 ^ 1 = 1.\\n1 ^ 0 = 1.\\n1 ^ 1 = 0.\\ndecoded[i] = ( encoded[i - 1] ) ^ ( decoded[i - 1] ) \\n\\nIn the above question we have to do this operation basically .\\n\\nthank you !!"
                    },
                    {
                        "username": "itsramashish",
                        "content": "Suggested: Please try once by yourself if u get stuck at any point then u can see the solution here..\\n\\nHere is the Java Code for this Problem \\n\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int ans[] = new int[encoded.length+1];\\n        ans[0] = first;\\n        int j=1;\\n        for(int i=0; i<encoded.length; i++){\\n            ans[j] = encoded[i] ^ ans[i];\\n            j++;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Draklife",
                        "content": "easy x-or oparetion"
                    },
                    {
                        "username": "van146",
                        "content": "Easy one - except that part when you are using JS... everything ordinary become complicated here..."
                    },
                    {
                        "username": "ajayharsh869",
                        "content": "why this code giving run time error??\\n\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector <int> a;\\n        a.push_back(first);\\n        for(int i=0; i<=encoded.size(); i++){\\n            \\n            a.push_back(encoded[i] ^ a[i]);\\n        }\\n        return a;\\n    }\\n};"
                    },
                    {
                        "username": "HarshMishra2k02",
                        "content": "remove the equals to sign from the loop in \"i <= encoded.size() \". Use this instead  \" i < encoded.size() \""
                    }
                ]
            },
            {
                "id": 2073066,
                "content": [
                    {
                        "username": "harshverma_",
                        "content": "randi\\n"
                    },
                    {
                        "username": "harshverma_",
                        "content": "Please provide some hard level questions.These type are not expected from you leetcode.F--k Off\\n"
                    },
                    {
                        "username": "harshverma_",
                        "content": "very down level question.Not upto the mark!!!\\n\\n"
                    },
                    {
                        "username": "harshverma_",
                        "content": "too much easy"
                    },
                    {
                        "username": "FerdinaKusumah",
                        "content": "Great explanation is like this\\nsource from here\\nhttps://stackoverflow.com/questions/18335587/finding-the-number-missing-in-the-sequence\\n\\nA XOR B = C => C XOR A = B\\n\\n(PARTIAL SUM) XOR (MISSING ELEMENT) = (TOTAL) \\nSo\\n\\n(TOTAL) XOR ( PATIAL SUM) = (MISSING ELEMNT)\\n\\nas example above\\nencoded = [1,2,3], first = 1\\n\\narray = [1] <- we get result for first value\\n\\n- doing loop each element in encoded\\n\\n- loop 1\\nwe get result = 1 (from encoded) -> we need to xor with last value from array\\n1 (encoded) xor 1 (last value from array) = 0 <- append to array (now array [1, 0])\\n\\n- loop 2\\nwe get result = 2 (from encoded) -> we need to xor with last value from array\\n2 (encoded) xor 0 (last value from array) = 2 <- append to array (now array [1, 0, 2])\\n\\n- loop 3\\nwe get result = 3 (from encoded) -> we need to xor with last value from array\\n2 (encoded) xor 3 (last value from array) = 1 <- append to array (now array [1, 0, 2, 1])\\n\\nthen our final array is like this\\nresult = [1,0,2,1]"
                    },
                    {
                        "username": "prince21212",
                        "content": "hello friends ...\\n  there are nothing in this question if you know the concept of XOR operation and how it works on Bit . lets see some XOR operation \\nits basically that if any of the bit is different on the comparison of second one its give that true .\\n0 ^ 0 = 0 .\\n0 ^ 1 = 1.\\n1 ^ 0 = 1.\\n1 ^ 1 = 0.\\ndecoded[i] = ( encoded[i - 1] ) ^ ( decoded[i - 1] ) \\n\\nIn the above question we have to do this operation basically .\\n\\nthank you !!"
                    },
                    {
                        "username": "itsramashish",
                        "content": "Suggested: Please try once by yourself if u get stuck at any point then u can see the solution here..\\n\\nHere is the Java Code for this Problem \\n\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int ans[] = new int[encoded.length+1];\\n        ans[0] = first;\\n        int j=1;\\n        for(int i=0; i<encoded.length; i++){\\n            ans[j] = encoded[i] ^ ans[i];\\n            j++;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Draklife",
                        "content": "easy x-or oparetion"
                    },
                    {
                        "username": "van146",
                        "content": "Easy one - except that part when you are using JS... everything ordinary become complicated here..."
                    },
                    {
                        "username": "ajayharsh869",
                        "content": "why this code giving run time error??\\n\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector <int> a;\\n        a.push_back(first);\\n        for(int i=0; i<=encoded.size(); i++){\\n            \\n            a.push_back(encoded[i] ^ a[i]);\\n        }\\n        return a;\\n    }\\n};"
                    },
                    {
                        "username": "HarshMishra2k02",
                        "content": "remove the equals to sign from the loop in \"i <= encoded.size() \". Use this instead  \" i < encoded.size() \""
                    }
                ]
            },
            {
                "id": 2073065,
                "content": [
                    {
                        "username": "harshverma_",
                        "content": "randi\\n"
                    },
                    {
                        "username": "harshverma_",
                        "content": "Please provide some hard level questions.These type are not expected from you leetcode.F--k Off\\n"
                    },
                    {
                        "username": "harshverma_",
                        "content": "very down level question.Not upto the mark!!!\\n\\n"
                    },
                    {
                        "username": "harshverma_",
                        "content": "too much easy"
                    },
                    {
                        "username": "FerdinaKusumah",
                        "content": "Great explanation is like this\\nsource from here\\nhttps://stackoverflow.com/questions/18335587/finding-the-number-missing-in-the-sequence\\n\\nA XOR B = C => C XOR A = B\\n\\n(PARTIAL SUM) XOR (MISSING ELEMENT) = (TOTAL) \\nSo\\n\\n(TOTAL) XOR ( PATIAL SUM) = (MISSING ELEMNT)\\n\\nas example above\\nencoded = [1,2,3], first = 1\\n\\narray = [1] <- we get result for first value\\n\\n- doing loop each element in encoded\\n\\n- loop 1\\nwe get result = 1 (from encoded) -> we need to xor with last value from array\\n1 (encoded) xor 1 (last value from array) = 0 <- append to array (now array [1, 0])\\n\\n- loop 2\\nwe get result = 2 (from encoded) -> we need to xor with last value from array\\n2 (encoded) xor 0 (last value from array) = 2 <- append to array (now array [1, 0, 2])\\n\\n- loop 3\\nwe get result = 3 (from encoded) -> we need to xor with last value from array\\n2 (encoded) xor 3 (last value from array) = 1 <- append to array (now array [1, 0, 2, 1])\\n\\nthen our final array is like this\\nresult = [1,0,2,1]"
                    },
                    {
                        "username": "prince21212",
                        "content": "hello friends ...\\n  there are nothing in this question if you know the concept of XOR operation and how it works on Bit . lets see some XOR operation \\nits basically that if any of the bit is different on the comparison of second one its give that true .\\n0 ^ 0 = 0 .\\n0 ^ 1 = 1.\\n1 ^ 0 = 1.\\n1 ^ 1 = 0.\\ndecoded[i] = ( encoded[i - 1] ) ^ ( decoded[i - 1] ) \\n\\nIn the above question we have to do this operation basically .\\n\\nthank you !!"
                    },
                    {
                        "username": "itsramashish",
                        "content": "Suggested: Please try once by yourself if u get stuck at any point then u can see the solution here..\\n\\nHere is the Java Code for this Problem \\n\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int ans[] = new int[encoded.length+1];\\n        ans[0] = first;\\n        int j=1;\\n        for(int i=0; i<encoded.length; i++){\\n            ans[j] = encoded[i] ^ ans[i];\\n            j++;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Draklife",
                        "content": "easy x-or oparetion"
                    },
                    {
                        "username": "van146",
                        "content": "Easy one - except that part when you are using JS... everything ordinary become complicated here..."
                    },
                    {
                        "username": "ajayharsh869",
                        "content": "why this code giving run time error??\\n\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector <int> a;\\n        a.push_back(first);\\n        for(int i=0; i<=encoded.size(); i++){\\n            \\n            a.push_back(encoded[i] ^ a[i]);\\n        }\\n        return a;\\n    }\\n};"
                    },
                    {
                        "username": "HarshMishra2k02",
                        "content": "remove the equals to sign from the loop in \"i <= encoded.size() \". Use this instead  \" i < encoded.size() \""
                    }
                ]
            },
            {
                "id": 2026515,
                "content": [
                    {
                        "username": "harshverma_",
                        "content": "randi\\n"
                    },
                    {
                        "username": "harshverma_",
                        "content": "Please provide some hard level questions.These type are not expected from you leetcode.F--k Off\\n"
                    },
                    {
                        "username": "harshverma_",
                        "content": "very down level question.Not upto the mark!!!\\n\\n"
                    },
                    {
                        "username": "harshverma_",
                        "content": "too much easy"
                    },
                    {
                        "username": "FerdinaKusumah",
                        "content": "Great explanation is like this\\nsource from here\\nhttps://stackoverflow.com/questions/18335587/finding-the-number-missing-in-the-sequence\\n\\nA XOR B = C => C XOR A = B\\n\\n(PARTIAL SUM) XOR (MISSING ELEMENT) = (TOTAL) \\nSo\\n\\n(TOTAL) XOR ( PATIAL SUM) = (MISSING ELEMNT)\\n\\nas example above\\nencoded = [1,2,3], first = 1\\n\\narray = [1] <- we get result for first value\\n\\n- doing loop each element in encoded\\n\\n- loop 1\\nwe get result = 1 (from encoded) -> we need to xor with last value from array\\n1 (encoded) xor 1 (last value from array) = 0 <- append to array (now array [1, 0])\\n\\n- loop 2\\nwe get result = 2 (from encoded) -> we need to xor with last value from array\\n2 (encoded) xor 0 (last value from array) = 2 <- append to array (now array [1, 0, 2])\\n\\n- loop 3\\nwe get result = 3 (from encoded) -> we need to xor with last value from array\\n2 (encoded) xor 3 (last value from array) = 1 <- append to array (now array [1, 0, 2, 1])\\n\\nthen our final array is like this\\nresult = [1,0,2,1]"
                    },
                    {
                        "username": "prince21212",
                        "content": "hello friends ...\\n  there are nothing in this question if you know the concept of XOR operation and how it works on Bit . lets see some XOR operation \\nits basically that if any of the bit is different on the comparison of second one its give that true .\\n0 ^ 0 = 0 .\\n0 ^ 1 = 1.\\n1 ^ 0 = 1.\\n1 ^ 1 = 0.\\ndecoded[i] = ( encoded[i - 1] ) ^ ( decoded[i - 1] ) \\n\\nIn the above question we have to do this operation basically .\\n\\nthank you !!"
                    },
                    {
                        "username": "itsramashish",
                        "content": "Suggested: Please try once by yourself if u get stuck at any point then u can see the solution here..\\n\\nHere is the Java Code for this Problem \\n\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int ans[] = new int[encoded.length+1];\\n        ans[0] = first;\\n        int j=1;\\n        for(int i=0; i<encoded.length; i++){\\n            ans[j] = encoded[i] ^ ans[i];\\n            j++;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Draklife",
                        "content": "easy x-or oparetion"
                    },
                    {
                        "username": "van146",
                        "content": "Easy one - except that part when you are using JS... everything ordinary become complicated here..."
                    },
                    {
                        "username": "ajayharsh869",
                        "content": "why this code giving run time error??\\n\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector <int> a;\\n        a.push_back(first);\\n        for(int i=0; i<=encoded.size(); i++){\\n            \\n            a.push_back(encoded[i] ^ a[i]);\\n        }\\n        return a;\\n    }\\n};"
                    },
                    {
                        "username": "HarshMishra2k02",
                        "content": "remove the equals to sign from the loop in \"i <= encoded.size() \". Use this instead  \" i < encoded.size() \""
                    }
                ]
            },
            {
                "id": 1975641,
                "content": [
                    {
                        "username": "harshverma_",
                        "content": "randi\\n"
                    },
                    {
                        "username": "harshverma_",
                        "content": "Please provide some hard level questions.These type are not expected from you leetcode.F--k Off\\n"
                    },
                    {
                        "username": "harshverma_",
                        "content": "very down level question.Not upto the mark!!!\\n\\n"
                    },
                    {
                        "username": "harshverma_",
                        "content": "too much easy"
                    },
                    {
                        "username": "FerdinaKusumah",
                        "content": "Great explanation is like this\\nsource from here\\nhttps://stackoverflow.com/questions/18335587/finding-the-number-missing-in-the-sequence\\n\\nA XOR B = C => C XOR A = B\\n\\n(PARTIAL SUM) XOR (MISSING ELEMENT) = (TOTAL) \\nSo\\n\\n(TOTAL) XOR ( PATIAL SUM) = (MISSING ELEMNT)\\n\\nas example above\\nencoded = [1,2,3], first = 1\\n\\narray = [1] <- we get result for first value\\n\\n- doing loop each element in encoded\\n\\n- loop 1\\nwe get result = 1 (from encoded) -> we need to xor with last value from array\\n1 (encoded) xor 1 (last value from array) = 0 <- append to array (now array [1, 0])\\n\\n- loop 2\\nwe get result = 2 (from encoded) -> we need to xor with last value from array\\n2 (encoded) xor 0 (last value from array) = 2 <- append to array (now array [1, 0, 2])\\n\\n- loop 3\\nwe get result = 3 (from encoded) -> we need to xor with last value from array\\n2 (encoded) xor 3 (last value from array) = 1 <- append to array (now array [1, 0, 2, 1])\\n\\nthen our final array is like this\\nresult = [1,0,2,1]"
                    },
                    {
                        "username": "prince21212",
                        "content": "hello friends ...\\n  there are nothing in this question if you know the concept of XOR operation and how it works on Bit . lets see some XOR operation \\nits basically that if any of the bit is different on the comparison of second one its give that true .\\n0 ^ 0 = 0 .\\n0 ^ 1 = 1.\\n1 ^ 0 = 1.\\n1 ^ 1 = 0.\\ndecoded[i] = ( encoded[i - 1] ) ^ ( decoded[i - 1] ) \\n\\nIn the above question we have to do this operation basically .\\n\\nthank you !!"
                    },
                    {
                        "username": "itsramashish",
                        "content": "Suggested: Please try once by yourself if u get stuck at any point then u can see the solution here..\\n\\nHere is the Java Code for this Problem \\n\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int ans[] = new int[encoded.length+1];\\n        ans[0] = first;\\n        int j=1;\\n        for(int i=0; i<encoded.length; i++){\\n            ans[j] = encoded[i] ^ ans[i];\\n            j++;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Draklife",
                        "content": "easy x-or oparetion"
                    },
                    {
                        "username": "van146",
                        "content": "Easy one - except that part when you are using JS... everything ordinary become complicated here..."
                    },
                    {
                        "username": "ajayharsh869",
                        "content": "why this code giving run time error??\\n\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector <int> a;\\n        a.push_back(first);\\n        for(int i=0; i<=encoded.size(); i++){\\n            \\n            a.push_back(encoded[i] ^ a[i]);\\n        }\\n        return a;\\n    }\\n};"
                    },
                    {
                        "username": "HarshMishra2k02",
                        "content": "remove the equals to sign from the loop in \"i <= encoded.size() \". Use this instead  \" i < encoded.size() \""
                    }
                ]
            },
            {
                "id": 1953739,
                "content": [
                    {
                        "username": "harshverma_",
                        "content": "randi\\n"
                    },
                    {
                        "username": "harshverma_",
                        "content": "Please provide some hard level questions.These type are not expected from you leetcode.F--k Off\\n"
                    },
                    {
                        "username": "harshverma_",
                        "content": "very down level question.Not upto the mark!!!\\n\\n"
                    },
                    {
                        "username": "harshverma_",
                        "content": "too much easy"
                    },
                    {
                        "username": "FerdinaKusumah",
                        "content": "Great explanation is like this\\nsource from here\\nhttps://stackoverflow.com/questions/18335587/finding-the-number-missing-in-the-sequence\\n\\nA XOR B = C => C XOR A = B\\n\\n(PARTIAL SUM) XOR (MISSING ELEMENT) = (TOTAL) \\nSo\\n\\n(TOTAL) XOR ( PATIAL SUM) = (MISSING ELEMNT)\\n\\nas example above\\nencoded = [1,2,3], first = 1\\n\\narray = [1] <- we get result for first value\\n\\n- doing loop each element in encoded\\n\\n- loop 1\\nwe get result = 1 (from encoded) -> we need to xor with last value from array\\n1 (encoded) xor 1 (last value from array) = 0 <- append to array (now array [1, 0])\\n\\n- loop 2\\nwe get result = 2 (from encoded) -> we need to xor with last value from array\\n2 (encoded) xor 0 (last value from array) = 2 <- append to array (now array [1, 0, 2])\\n\\n- loop 3\\nwe get result = 3 (from encoded) -> we need to xor with last value from array\\n2 (encoded) xor 3 (last value from array) = 1 <- append to array (now array [1, 0, 2, 1])\\n\\nthen our final array is like this\\nresult = [1,0,2,1]"
                    },
                    {
                        "username": "prince21212",
                        "content": "hello friends ...\\n  there are nothing in this question if you know the concept of XOR operation and how it works on Bit . lets see some XOR operation \\nits basically that if any of the bit is different on the comparison of second one its give that true .\\n0 ^ 0 = 0 .\\n0 ^ 1 = 1.\\n1 ^ 0 = 1.\\n1 ^ 1 = 0.\\ndecoded[i] = ( encoded[i - 1] ) ^ ( decoded[i - 1] ) \\n\\nIn the above question we have to do this operation basically .\\n\\nthank you !!"
                    },
                    {
                        "username": "itsramashish",
                        "content": "Suggested: Please try once by yourself if u get stuck at any point then u can see the solution here..\\n\\nHere is the Java Code for this Problem \\n\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int ans[] = new int[encoded.length+1];\\n        ans[0] = first;\\n        int j=1;\\n        for(int i=0; i<encoded.length; i++){\\n            ans[j] = encoded[i] ^ ans[i];\\n            j++;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Draklife",
                        "content": "easy x-or oparetion"
                    },
                    {
                        "username": "van146",
                        "content": "Easy one - except that part when you are using JS... everything ordinary become complicated here..."
                    },
                    {
                        "username": "ajayharsh869",
                        "content": "why this code giving run time error??\\n\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector <int> a;\\n        a.push_back(first);\\n        for(int i=0; i<=encoded.size(); i++){\\n            \\n            a.push_back(encoded[i] ^ a[i]);\\n        }\\n        return a;\\n    }\\n};"
                    },
                    {
                        "username": "HarshMishra2k02",
                        "content": "remove the equals to sign from the loop in \"i <= encoded.size() \". Use this instead  \" i < encoded.size() \""
                    }
                ]
            },
            {
                "id": 1884317,
                "content": [
                    {
                        "username": "harshverma_",
                        "content": "randi\\n"
                    },
                    {
                        "username": "harshverma_",
                        "content": "Please provide some hard level questions.These type are not expected from you leetcode.F--k Off\\n"
                    },
                    {
                        "username": "harshverma_",
                        "content": "very down level question.Not upto the mark!!!\\n\\n"
                    },
                    {
                        "username": "harshverma_",
                        "content": "too much easy"
                    },
                    {
                        "username": "FerdinaKusumah",
                        "content": "Great explanation is like this\\nsource from here\\nhttps://stackoverflow.com/questions/18335587/finding-the-number-missing-in-the-sequence\\n\\nA XOR B = C => C XOR A = B\\n\\n(PARTIAL SUM) XOR (MISSING ELEMENT) = (TOTAL) \\nSo\\n\\n(TOTAL) XOR ( PATIAL SUM) = (MISSING ELEMNT)\\n\\nas example above\\nencoded = [1,2,3], first = 1\\n\\narray = [1] <- we get result for first value\\n\\n- doing loop each element in encoded\\n\\n- loop 1\\nwe get result = 1 (from encoded) -> we need to xor with last value from array\\n1 (encoded) xor 1 (last value from array) = 0 <- append to array (now array [1, 0])\\n\\n- loop 2\\nwe get result = 2 (from encoded) -> we need to xor with last value from array\\n2 (encoded) xor 0 (last value from array) = 2 <- append to array (now array [1, 0, 2])\\n\\n- loop 3\\nwe get result = 3 (from encoded) -> we need to xor with last value from array\\n2 (encoded) xor 3 (last value from array) = 1 <- append to array (now array [1, 0, 2, 1])\\n\\nthen our final array is like this\\nresult = [1,0,2,1]"
                    },
                    {
                        "username": "prince21212",
                        "content": "hello friends ...\\n  there are nothing in this question if you know the concept of XOR operation and how it works on Bit . lets see some XOR operation \\nits basically that if any of the bit is different on the comparison of second one its give that true .\\n0 ^ 0 = 0 .\\n0 ^ 1 = 1.\\n1 ^ 0 = 1.\\n1 ^ 1 = 0.\\ndecoded[i] = ( encoded[i - 1] ) ^ ( decoded[i - 1] ) \\n\\nIn the above question we have to do this operation basically .\\n\\nthank you !!"
                    },
                    {
                        "username": "itsramashish",
                        "content": "Suggested: Please try once by yourself if u get stuck at any point then u can see the solution here..\\n\\nHere is the Java Code for this Problem \\n\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int ans[] = new int[encoded.length+1];\\n        ans[0] = first;\\n        int j=1;\\n        for(int i=0; i<encoded.length; i++){\\n            ans[j] = encoded[i] ^ ans[i];\\n            j++;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Draklife",
                        "content": "easy x-or oparetion"
                    },
                    {
                        "username": "van146",
                        "content": "Easy one - except that part when you are using JS... everything ordinary become complicated here..."
                    },
                    {
                        "username": "ajayharsh869",
                        "content": "why this code giving run time error??\\n\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector <int> a;\\n        a.push_back(first);\\n        for(int i=0; i<=encoded.size(); i++){\\n            \\n            a.push_back(encoded[i] ^ a[i]);\\n        }\\n        return a;\\n    }\\n};"
                    },
                    {
                        "username": "HarshMishra2k02",
                        "content": "remove the equals to sign from the loop in \"i <= encoded.size() \". Use this instead  \" i < encoded.size() \""
                    }
                ]
            },
            {
                "id": 1867036,
                "content": [
                    {
                        "username": "harshverma_",
                        "content": "randi\\n"
                    },
                    {
                        "username": "harshverma_",
                        "content": "Please provide some hard level questions.These type are not expected from you leetcode.F--k Off\\n"
                    },
                    {
                        "username": "harshverma_",
                        "content": "very down level question.Not upto the mark!!!\\n\\n"
                    },
                    {
                        "username": "harshverma_",
                        "content": "too much easy"
                    },
                    {
                        "username": "FerdinaKusumah",
                        "content": "Great explanation is like this\\nsource from here\\nhttps://stackoverflow.com/questions/18335587/finding-the-number-missing-in-the-sequence\\n\\nA XOR B = C => C XOR A = B\\n\\n(PARTIAL SUM) XOR (MISSING ELEMENT) = (TOTAL) \\nSo\\n\\n(TOTAL) XOR ( PATIAL SUM) = (MISSING ELEMNT)\\n\\nas example above\\nencoded = [1,2,3], first = 1\\n\\narray = [1] <- we get result for first value\\n\\n- doing loop each element in encoded\\n\\n- loop 1\\nwe get result = 1 (from encoded) -> we need to xor with last value from array\\n1 (encoded) xor 1 (last value from array) = 0 <- append to array (now array [1, 0])\\n\\n- loop 2\\nwe get result = 2 (from encoded) -> we need to xor with last value from array\\n2 (encoded) xor 0 (last value from array) = 2 <- append to array (now array [1, 0, 2])\\n\\n- loop 3\\nwe get result = 3 (from encoded) -> we need to xor with last value from array\\n2 (encoded) xor 3 (last value from array) = 1 <- append to array (now array [1, 0, 2, 1])\\n\\nthen our final array is like this\\nresult = [1,0,2,1]"
                    },
                    {
                        "username": "prince21212",
                        "content": "hello friends ...\\n  there are nothing in this question if you know the concept of XOR operation and how it works on Bit . lets see some XOR operation \\nits basically that if any of the bit is different on the comparison of second one its give that true .\\n0 ^ 0 = 0 .\\n0 ^ 1 = 1.\\n1 ^ 0 = 1.\\n1 ^ 1 = 0.\\ndecoded[i] = ( encoded[i - 1] ) ^ ( decoded[i - 1] ) \\n\\nIn the above question we have to do this operation basically .\\n\\nthank you !!"
                    },
                    {
                        "username": "itsramashish",
                        "content": "Suggested: Please try once by yourself if u get stuck at any point then u can see the solution here..\\n\\nHere is the Java Code for this Problem \\n\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int ans[] = new int[encoded.length+1];\\n        ans[0] = first;\\n        int j=1;\\n        for(int i=0; i<encoded.length; i++){\\n            ans[j] = encoded[i] ^ ans[i];\\n            j++;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Draklife",
                        "content": "easy x-or oparetion"
                    },
                    {
                        "username": "van146",
                        "content": "Easy one - except that part when you are using JS... everything ordinary become complicated here..."
                    },
                    {
                        "username": "ajayharsh869",
                        "content": "why this code giving run time error??\\n\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector <int> a;\\n        a.push_back(first);\\n        for(int i=0; i<=encoded.size(); i++){\\n            \\n            a.push_back(encoded[i] ^ a[i]);\\n        }\\n        return a;\\n    }\\n};"
                    },
                    {
                        "username": "HarshMishra2k02",
                        "content": "remove the equals to sign from the loop in \"i <= encoded.size() \". Use this instead  \" i < encoded.size() \""
                    }
                ]
            },
            {
                "id": 1754324,
                "content": [
                    {
                        "username": "harshverma_",
                        "content": "randi\\n"
                    },
                    {
                        "username": "harshverma_",
                        "content": "Please provide some hard level questions.These type are not expected from you leetcode.F--k Off\\n"
                    },
                    {
                        "username": "harshverma_",
                        "content": "very down level question.Not upto the mark!!!\\n\\n"
                    },
                    {
                        "username": "harshverma_",
                        "content": "too much easy"
                    },
                    {
                        "username": "FerdinaKusumah",
                        "content": "Great explanation is like this\\nsource from here\\nhttps://stackoverflow.com/questions/18335587/finding-the-number-missing-in-the-sequence\\n\\nA XOR B = C => C XOR A = B\\n\\n(PARTIAL SUM) XOR (MISSING ELEMENT) = (TOTAL) \\nSo\\n\\n(TOTAL) XOR ( PATIAL SUM) = (MISSING ELEMNT)\\n\\nas example above\\nencoded = [1,2,3], first = 1\\n\\narray = [1] <- we get result for first value\\n\\n- doing loop each element in encoded\\n\\n- loop 1\\nwe get result = 1 (from encoded) -> we need to xor with last value from array\\n1 (encoded) xor 1 (last value from array) = 0 <- append to array (now array [1, 0])\\n\\n- loop 2\\nwe get result = 2 (from encoded) -> we need to xor with last value from array\\n2 (encoded) xor 0 (last value from array) = 2 <- append to array (now array [1, 0, 2])\\n\\n- loop 3\\nwe get result = 3 (from encoded) -> we need to xor with last value from array\\n2 (encoded) xor 3 (last value from array) = 1 <- append to array (now array [1, 0, 2, 1])\\n\\nthen our final array is like this\\nresult = [1,0,2,1]"
                    },
                    {
                        "username": "prince21212",
                        "content": "hello friends ...\\n  there are nothing in this question if you know the concept of XOR operation and how it works on Bit . lets see some XOR operation \\nits basically that if any of the bit is different on the comparison of second one its give that true .\\n0 ^ 0 = 0 .\\n0 ^ 1 = 1.\\n1 ^ 0 = 1.\\n1 ^ 1 = 0.\\ndecoded[i] = ( encoded[i - 1] ) ^ ( decoded[i - 1] ) \\n\\nIn the above question we have to do this operation basically .\\n\\nthank you !!"
                    },
                    {
                        "username": "itsramashish",
                        "content": "Suggested: Please try once by yourself if u get stuck at any point then u can see the solution here..\\n\\nHere is the Java Code for this Problem \\n\\nclass Solution {\\n    public int[] decode(int[] encoded, int first) {\\n        int ans[] = new int[encoded.length+1];\\n        ans[0] = first;\\n        int j=1;\\n        for(int i=0; i<encoded.length; i++){\\n            ans[j] = encoded[i] ^ ans[i];\\n            j++;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Draklife",
                        "content": "easy x-or oparetion"
                    },
                    {
                        "username": "van146",
                        "content": "Easy one - except that part when you are using JS... everything ordinary become complicated here..."
                    },
                    {
                        "username": "ajayharsh869",
                        "content": "why this code giving run time error??\\n\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector <int> a;\\n        a.push_back(first);\\n        for(int i=0; i<=encoded.size(); i++){\\n            \\n            a.push_back(encoded[i] ^ a[i]);\\n        }\\n        return a;\\n    }\\n};"
                    },
                    {
                        "username": "HarshMishra2k02",
                        "content": "remove the equals to sign from the loop in \"i <= encoded.size() \". Use this instead  \" i < encoded.size() \""
                    }
                ]
            }
        ]
    }
]