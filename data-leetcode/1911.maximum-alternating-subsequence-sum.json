[
    {
        "title": "Distribute Candies to People",
        "question_content": "We distribute some&nbsp;number of candies, to a row of n =&nbsp;num_people&nbsp;people in the following way:\nWe then give 1 candy to the first person, 2 candies to the second person, and so on until we give n&nbsp;candies to the last person.\nThen, we go back to the start of the row, giving n&nbsp;+ 1 candies to the first person, n&nbsp;+ 2 candies to the second person, and so on until we give 2 * n&nbsp;candies to the last person.\nThis process repeats (with us giving one more candy each time, and moving to the start of the row after we reach the end) until we run out of candies.&nbsp; The last person will receive all of our remaining candies (not necessarily one more than the previous gift).\nReturn an array (of length num_people&nbsp;and sum candies) that represents the final distribution of candies.\n&nbsp;\nExample 1:\n\nInput: candies = 7, num_people = 4\nOutput: [1,2,3,1]\nExplanation:\nOn the first turn, ans[0] += 1, and the array is [1,0,0,0].\nOn the second turn, ans[1] += 2, and the array is [1,2,0,0].\nOn the third turn, ans[2] += 3, and the array is [1,2,3,0].\nOn the fourth turn, ans[3] += 1 (because there is only one candy left), and the final array is [1,2,3,1].\n\nExample 2:\n\nInput: candies = 10, num_people = 3\nOutput: [5,2,3]\nExplanation: \nOn the first turn, ans[0] += 1, and the array is [1,0,0].\nOn the second turn, ans[1] += 2, and the array is [1,2,0].\nOn the third turn, ans[2] += 3, and the array is [1,2,3].\nOn the fourth turn, ans[0] += 4, and the final array is [5,2,3].\n\n&nbsp;\nConstraints:\n\n\t1 <= candies <= 10^9\n\t1 <= num_people <= 1000",
        "solutions": [
            {
                "id": 323314,
                "title": "java-python3-easy-code-w-explanation-and-analysis",
                "content": "1. Use `give % num_people` to determine the current index of the people, where `give` is the `give-th` giving of candy;\\n2. Increase each giving amount by 1 till run out of candies.\\n\\n**Java:**\\n```\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] people = new int[num_people];\\n        for (int give = 0; candies > 0; candies -= give) {\\n            people[give % num_people] +=  Math.min(candies, ++give);\\n        }\\n        return people;\\n    }\\n```\\n----\\n**Python3:**\\n```\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        people = num_people * [0]\\n        give = 0\\n        while candies > 0:\\n            people[give % num_people] += min(candies, give + 1)\\n            give += 1\\n            candies -= give\\n        return people\\n```\\n**Analysis:**\\nAssume there are `give` times distribution such that `1 + 2 + ... + give >= candies`. Therefore,\\n`(1 + give) * give / 2 >= candies`, and when `give` is big enough, `(give + 1) * give /2 ~ candies`. We have: \\n```\\n1/2 * give ^ 2 < 1/2 * (give ^ 2 + give)  < 1/ 2 * (give + 1) ^ 2\\n```\\nthen \\n```\\n1/2 * give ^ 2 < candies < 1/ 2 * (give + 1) ^ 2\\n```\\nso\\n```\\ngive < sqrt(2 * candies) ~ O(sqrt(candies))\\n```\\nTime: O(sqrt(candies)), space: O(num_people) - including return array.",
                "solutionTags": [],
                "code": "```\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] people = new int[num_people];\\n        for (int give = 0; candies > 0; candies -= give) {\\n            people[give % num_people] +=  Math.min(candies, ++give);\\n        }\\n        return people;\\n    }\\n```\n```\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        people = num_people * [0]\\n        give = 0\\n        while candies > 0:\\n            people[give % num_people] += min(candies, give + 1)\\n            give += 1\\n            candies -= give\\n        return people\\n```\n```\\n1/2 * give ^ 2 < 1/2 * (give ^ 2 + give)  < 1/ 2 * (give + 1) ^ 2\\n```\n```\\n1/2 * give ^ 2 < candies < 1/ 2 * (give + 1) ^ 2\\n```\n```\\ngive < sqrt(2 * candies) ~ O(sqrt(candies))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 323364,
                "title": "java-c-python-math-solution-and-simulation-o-1-to-get-each",
                "content": "# **Solution 1: Math**\\nMath solution, but personally not really like it.\\nTime only `O(1)` to get value for each people, \\nthough `O(n)` for output.\\nAnd strictly speaking, `math.sqrt` also consumes the time.\\n\\n```python\\n    def distributeCandies(self, candies, n):\\n        x = int(math.sqrt(candies * 2 + 0.25) - 0.5)\\n        res = [0] * n\\n        for i in xrange(n):\\n            m = x / n + (x % n > i)\\n            res[i] = m * (i + 1) + m * (m - 1) / 2 * n\\n        res[x % n] += candies - x * (x + 1) / 2\\n        return res\\n```\\n<br>\\n\\n# **Intuition**\\nBrute force of simulation seems to be easy.\\nBut how is the time complexity?\\n<br>\\n\\n# **Solution 2: Explanation**\\nThe `i-th` distribution,\\nwe will distribute `i + 1` candies to `(i % n)`th people.\\nWe just simulate the process of distribution until we ran out of candies.\\n\\n# **Complexity**\\nTime `O(sqrt(candies) + n)`\\nSpace `O(n)` for output\\n\\nThe number of given candies is `i + 1`, which is an increasing sequence.\\nThe total number distributed candies is `c * (c + 1) / 2` until it\\'s bigger than `candies`.\\nSo the time it takes is `O(sqrt(candies))`\\n<br>\\n\\n**Java:**\\n```java\\n    public int[] distributeCandies(int candies, int n) {\\n        int[] res = new int[n];\\n        for (int i = 0; candies > 0; ++i) {\\n            res[i % n] += Math.min(candies, i + 1);\\n            candies -= i + 1;\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    vector<int> distributeCandies(int candies, int n) {\\n        vector<int> res(n);\\n        for (int i = 0; candies > 0; ++i) {\\n            res[i % n] += min(candies, i + 1);\\n            candies -= i + 1;\\n        }\\n        return res;\\n    }\\n```\\n**Python**\\n```python\\n    def distributeCandies(self, candies, n):\\n        res = [0] * n\\n        i = 0\\n        while candies > 0:\\n            res[i % n] += min(candies, i + 1)\\n            candies -= i + 1\\n            i += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\n    def distributeCandies(self, candies, n):\\n        x = int(math.sqrt(candies * 2 + 0.25) - 0.5)\\n        res = [0] * n\\n        for i in xrange(n):\\n            m = x / n + (x % n > i)\\n            res[i] = m * (i + 1) + m * (m - 1) / 2 * n\\n        res[x % n] += candies - x * (x + 1) / 2\\n        return res\\n```\n```java\\n    public int[] distributeCandies(int candies, int n) {\\n        int[] res = new int[n];\\n        for (int i = 0; candies > 0; ++i) {\\n            res[i % n] += Math.min(candies, i + 1);\\n            candies -= i + 1;\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    vector<int> distributeCandies(int candies, int n) {\\n        vector<int> res(n);\\n        for (int i = 0; candies > 0; ++i) {\\n            res[i % n] += min(candies, i + 1);\\n            candies -= i + 1;\\n        }\\n        return res;\\n    }\\n```\n```python\\n    def distributeCandies(self, candies, n):\\n        res = [0] * n\\n        i = 0\\n        while candies > 0:\\n            res[i % n] += min(candies, i + 1)\\n            candies -= i + 1\\n            i += 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 323298,
                "title": "c-brute-force",
                "content": "I was going down the mathematical path and it felt a bit tricky. Since the problem is \\'Easy\\', I guessed the brute-force should do for the contest.\\n```\\nvector<int> distributeCandies(int c, int num) {\\n  vector<int> res(num);\\n  for (auto i = 0; c > 0; c -= ++i) \\n    res[i % num] += min(i + 1, c);\\n  return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> distributeCandies(int c, int num) {\\n  vector<int> res(num);\\n  for (auto i = 0; c > 0; c -= ++i) \\n    res[i % num] += min(i + 1, c);\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 796574,
                "title": "python-math-o-k-solution-with-explanation",
                "content": "There are different ways how you can handle this problem, I prefer mathematical way. Let us define `k = num_people` and `n = candies` and try to understand how many candies we need to give to `i`-the person.  \\n\\n| 1    | 2   | 3    | ... | k   |\\n|------|-----|------|-----|-----|\\n| **k+1**  | **k+2** | **k+3**  | **...** | **2k**  |\\n| **...**  | **...** | **...**  | **...** | **...** |\\n| **sk+1** | **...** | **sk+i** |     |     |\\n\\nWe need to find the biggest `s`, such that the sum of numbers before is less or equal to `n`. Let us compute it:\\n\\n**1.** First row: `k(k+1)/2`, sum of arithmetic progression.\\n\\n**2.** Second row: `k(k+1)/2 + k^2`.\\n\\n**3.** Third row:  `k(k+1)/2 + 2*k^2`.\\n...\\n\\n**s-1.** `k(k+1)/2 + (s-1)*k^2`.\\n\\n**s.** `s*k*i + i(i+1)/2`.\\n\\nLet us evaluate this sum and solve quadratic inequality:\\n\\n![image](https://assets.leetcode.com/users/images/d526bc75-9a24-4903-a81f-361ab34dda1b_1597655950.5398853.png)\\n\\n\\nSo, we have root `s = ((-1-2*i) + sqrt(1+8*n))/(2*k)` and we need to find the biggest integer number which is less than `s`, let us define it `t = floor(s)`.\\nNow, how many candies we need to give to this person? It is `i + (k+i) + ... + (sk+i) = i*(t+1) + k*t*(t+1)//2`. Finally, we need to find the last person, who gets the rest of the candies. How we can do it? I evaluate difference `s - floor(s)` and choose the person with the biggest difference.\\n\\n**Complexity**: time and space complexity is `O(k)`, where `k` is number of people. \\n\\n\\n```\\nclass Solution:\\n    def distributeCandies(self, candies, num_people):\\n        k, n = num_people, candies\\n        alloc = [0]*k\\n        Final = (0, 0)\\n        for i in range(1, k+1):\\n            s = ((-1-2*i) + sqrt(1+8*n))/(2*k)\\n            t = floor(s)\\n            alloc[i-1] = i*(t+1) + k*t*(t+1)//2\\n            Final = max(Final, (s-floor(s), i)) \\n            \\n        alloc[Final[1]-1] += (n - sum(alloc))\\n            \\n        return alloc\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies, num_people):\\n        k, n = num_people, candies\\n        alloc = [0]*k\\n        Final = (0, 0)\\n        for i in range(1, k+1):\\n            s = ((-1-2*i) + sqrt(1+8*n))/(2*k)\\n            t = floor(s)\\n            alloc[i-1] = i*(t+1) + k*t*(t+1)//2\\n            Final = max(Final, (s-floor(s), i)) \\n            \\n        alloc[Final[1]-1] += (n - sum(alloc))\\n            \\n        return alloc\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796745,
                "title": "distribute-candies-0-ms-math-heavy-java",
                "content": "Of course, we could do literally what the problem says and simulate the distribution of candy - but as you imagine, this can get really slow when we reach `num_people = 10 ^ 9`.\\n\\nThe other approach is to skip the simulation and calculate the final candy distribution.\\n\\nLet\\'s imagine the candy distribution process for `candies = 10`, and `num_people = 3`:\\n\\nPerson 0 receives 1 piece of candy, Person 1 receives 2 pieces of candy, Person 2 receives 3 pieces of candy then we go back to Person 0 to give them the remaining 4 pieces of candy.\\nSo,\\n```\\n    p[0]  p[1]  p[2]\\n0:   1     2     3   +\\n1:   4\\n----------------\\n     5     2     3\\n```\\n\\nLet\\'s generalise: (`n = num_people`)\\n```\\n              p[0]            p[1]      ...       p[n - 1]\\n-----------------------------------------------------------\\n0:              1               2       ...           n\\n1:            n + 1           n + 2     ...         2 * n\\n...            ...             ...      ...          ... \\nk-1:  (k-1) * n + 1     (k-1)*n + 2     ...         k * n\\n```\\n(Remember this sum `1 + 2 + ... + n = n*(n + 1)/2`. Let\\'s call this as `gauss(n)` - EDIT: sum is `n*(n+1)/2` as user \\'cantbenix\\' said not `n*(n-1)/2` as I had left it before)\\nHow much candy have I distributed up until now? `1 + 2 + 3 + ... k * n = gauss(k * n)`\\nOf course, let\\'s not forget the remaining candy, which wouldn\\'t be enough to finish another row (or distribution cycle):\\n```\\n          k * n + 1       k * n + 2     ...\\n```\\nSo what did I need to do here? I want to find the greatest `k` such that I can do `k` passes of candy distribution \"automatically\". (I\\'ll do the remaining in a \"manual\" `for` loop.)\\nThat is, I need to find the greatest `k` so that `gauss(k * n) <= c`, where `c = candies`.\\nThis means: find greatest k such that `k*n * (k*n + 1) / 2 <= c`\\nWrite it again: \\n`n^2 * k^2 + n * k - 2*c <= 0`\\n\\nEDIT: Added process to obtain `k`.\\n![image](https://assets.leetcode.com/users/images/21103f79-5f58-4e0e-89c8-583395f1c721_1597852489.4983099.png)\\n\\n\\nIn code:\\n```\\nint k = (int) Math.floor((Math.sqrt(1 + 8 * (double) candies) - 1) / (double) (2 * num_people));\\n```\\nI have `k`, let\\'s take out our `k` distribution cycles of candy.\\n```\\ncandies -= gauss(k * num_people);\\n```\\n(gauss(n) in code:)\\n```\\nprivate int gauss(int n) {\\n\\treturn n * (n + 1) / 2;\\n}\\n```\\n(EDIT: in the last row, second column it should be n*gauss(k-1) + 2*k,  as user \\'Juggernaut12\\' said)\\nNow let\\'s go back to our rows - and add them up:\\n```\\n              p[0]            p[1]             ...       p[n - 1]\\n------------------------------------------------------------------------\\n0:              1                     2        ...           n\\n1:            n + 1                 n + 2      ...         2 * n\\n...            ...                   ...       ...          ... \\nk-1:  (k-1) * n + 1           (k-1)*n + 2      ...         n * n\\n---------------------------------------------------------------------------\\ns: n*gauss(k-1) + 1*k    n*gauss(k-1) + 2*k    ...    n*gauss(k-1) + n*k\\n```\\nIn code:\\n```\\nfor (int i = 0; i < num_people; i++) {\\n\\tp[i] += num_people * gauss(k - 1) + k * (i + 1);\\n}\\n```\\nAll that remains is the last remaining distribution cycle.\\nIn code:\\n```\\nint d = k * num_people + 1;\\nint j = d;\\nfor (; candies - j >= 0; j++) {\\n\\tp[j - d] += j;\\n\\tcandies -= j;\\n}\\n\\nif (candies > 0) {\\n\\tp[j - d] += candies;\\n}\\n```\\n\\nFull solution:\\n```\\npublic int[] distributeCandies(int candies, int num_people) {\\n\\tint[] p = new int[num_people];\\n\\n\\tint k = (int) Math.floor((Math.sqrt(1 + 8 * (double) candies) - 1) / (double) (2 * num_people));\\n\\tcandies -= gauss(k * num_people);\\n\\tfor (int i = 0; i < num_people; i++) {\\n\\t\\tp[i] += num_people * gauss(k - 1) + k * (i + 1);\\n\\t}\\n\\n\\tint d = k * num_people + 1;\\n\\tint j = d;\\n\\tfor (; candies - j >= 0; j++) {\\n\\t\\tp[j - d] += j;\\n\\t\\tcandies -= j;\\n\\t}\\n\\n\\tif (candies > 0) {\\n\\t\\tp[j - d] += candies;\\n\\t}\\n\\n\\treturn p;\\n}\\n\\nprivate int gauss(int n) {\\n\\treturn n * (n + 1) / 2;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n    p[0]  p[1]  p[2]\\n0:   1     2     3   +\\n1:   4\\n----------------\\n     5     2     3\\n```\n```\\n              p[0]            p[1]      ...       p[n - 1]\\n-----------------------------------------------------------\\n0:              1               2       ...           n\\n1:            n + 1           n + 2     ...         2 * n\\n...            ...             ...      ...          ... \\nk-1:  (k-1) * n + 1     (k-1)*n + 2     ...         k * n\\n```\n```\\n          k * n + 1       k * n + 2     ...\\n```\n```\\nint k = (int) Math.floor((Math.sqrt(1 + 8 * (double) candies) - 1) / (double) (2 * num_people));\\n```\n```\\ncandies -= gauss(k * num_people);\\n```\n```\\nprivate int gauss(int n) {\\n\\treturn n * (n + 1) / 2;\\n}\\n```\n```\\n              p[0]            p[1]             ...       p[n - 1]\\n------------------------------------------------------------------------\\n0:              1                     2        ...           n\\n1:            n + 1                 n + 2      ...         2 * n\\n...            ...                   ...       ...          ... \\nk-1:  (k-1) * n + 1           (k-1)*n + 2      ...         n * n\\n---------------------------------------------------------------------------\\ns: n*gauss(k-1) + 1*k    n*gauss(k-1) + 2*k    ...    n*gauss(k-1) + n*k\\n```\n```\\nfor (int i = 0; i < num_people; i++) {\\n\\tp[i] += num_people * gauss(k - 1) + k * (i + 1);\\n}\\n```\n```\\nint d = k * num_people + 1;\\nint j = d;\\nfor (; candies - j >= 0; j++) {\\n\\tp[j - d] += j;\\n\\tcandies -= j;\\n}\\n\\nif (candies > 0) {\\n\\tp[j - d] += candies;\\n}\\n```\n```\\npublic int[] distributeCandies(int candies, int num_people) {\\n\\tint[] p = new int[num_people];\\n\\n\\tint k = (int) Math.floor((Math.sqrt(1 + 8 * (double) candies) - 1) / (double) (2 * num_people));\\n\\tcandies -= gauss(k * num_people);\\n\\tfor (int i = 0; i < num_people; i++) {\\n\\t\\tp[i] += num_people * gauss(k - 1) + k * (i + 1);\\n\\t}\\n\\n\\tint d = k * num_people + 1;\\n\\tint j = d;\\n\\tfor (; candies - j >= 0; j++) {\\n\\t\\tp[j - d] += j;\\n\\t\\tcandies -= j;\\n\\t}\\n\\n\\tif (candies > 0) {\\n\\t\\tp[j - d] += candies;\\n\\t}\\n\\n\\treturn p;\\n}\\n\\nprivate int gauss(int n) {\\n\\treturn n * (n + 1) / 2;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 324215,
                "title": "java-o-num-people-one-pass-math-solution-solving-quadratic-function",
                "content": "Different solution from the O(sqrt(candies)) one.\\n\\nExplanation:\\n The operation of distributing candies is an Arithmetic Sequence. \\n If we want to get the sum from 1 to n, the formula is` (1+n) * n / 2`.\\n =>` (1+n) * n / 2 = candies => n^2 + n - 2*candies = 0` \\n If the one dimensional quadratic function is like `ax^2 + bx + c = 0` where a, b, c are parameters.\\n There is a formula to solve it which is[ x = (-b (+/-) sqrt(b^2-4\\\\*a\\\\*c)) / (2\\\\*a)](https://en.wikipedia.org/wiki/Quadratic_formula).\\n \\n Based on that, we can know the # of times which the candies are fully distributed where fully means the person get the # of candies which is supposed to distribute, \\n not the leftover.\\n \\n Let\\'s use 3 people as an example,\\n 1       ->  2       ->  3\\n (1+3)-> (2+3)  -> (3 + 3)\\n (1+2\\\\*3) -> (2+2\\\\*3) ->(3+2\\\\*3)\\n ......\\n It is quite obvious that except the first round, the value of each cell of the rest rounds is just the sum of their count at the first round\\n plus the length of the array times the number of rounds(0 based) it goes(Another Arithmetic sequence). Based on the length of the quadratic formula we calculated above, we can calculate the # of rounds, the mod, and the # of candies of the leftover. \\nThe complexity is `O(num_people)`, since we only need to assign value to the return array once.\\n \\n \\n     public int[] distributeCandies(int candies, int num_people) {\\n        int end = (int)((-1 + Math.sqrt(1L+8L*candies)) / 2f);  // Kind of dislike the overflow testcase of this question.\\n        int extra_candies = candies - (1 + end) * end / 2; // Get the leftover for the last distribution.\\n        int rounds = end / num_people;\\n        int rest = end % num_people;\\n        int[] res = new int[num_people];\\n\\t\\tfor (int i = 0; i < num_people; i++) {\\n\\t\\t\\tif (i < rest) {\\n\\t\\t\\t\\tres[i] = (int)((i + 1) * (rounds + 1) + (1 + rounds) * rounds / 2 * num_people);\\n\\t\\t\\t} else if (i == rest) {\\n\\t\\t\\t\\tres[i] = (i + 1) * rounds + (rounds - 1) * rounds / 2 * num_people + extra_candies;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tres[i] = (i + 1) * rounds + (rounds - 1) * rounds / 2 * num_people;\\n\\t\\t\\t}\\n\\t\\t}\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "Different solution from the O(sqrt(candies)) one.\\n\\nExplanation:\\n The operation of distributing candies is an Arithmetic Sequence. \\n If we want to get the sum from 1 to n, the formula is` (1+n) * n / 2`.\\n =>` (1+n) * n / 2 = candies => n^2 + n - 2*candies = 0` \\n If the one dimensional quadratic function is like `ax^2 + bx + c = 0` where a, b, c are parameters.\\n There is a formula to solve it which is[ x = (-b (+/-) sqrt(b^2-4\\\\*a\\\\*c)) / (2\\\\*a)](https://en.wikipedia.org/wiki/Quadratic_formula).\\n \\n Based on that, we can know the # of times which the candies are fully distributed where fully means the person get the # of candies which is supposed to distribute, \\n not the leftover.\\n \\n Let\\'s use 3 people as an example,\\n 1       ->  2       ->  3\\n (1+3)-> (2+3)  -> (3 + 3)\\n (1+2\\\\*3) -> (2+2\\\\*3) ->(3+2\\\\*3)\\n ......\\n It is quite obvious that except the first round, the value of each cell of the rest rounds is just the sum of their count at the first round\\n plus the length of the array times the number of rounds(0 based) it goes(Another Arithmetic sequence). Based on the length of the quadratic formula we calculated above, we can calculate the # of rounds, the mod, and the # of candies of the leftover. \\nThe complexity is `O(num_people)`, since we only need to assign value to the return array once.\\n \\n \\n     public int[] distributeCandies(int candies, int num_people) {\\n        int end = (int)((-1 + Math.sqrt(1L+8L*candies)) / 2f);  // Kind of dislike the overflow testcase of this question.\\n        int extra_candies = candies - (1 + end) * end / 2; // Get the leftover for the last distribution.\\n        int rounds = end / num_people;\\n        int rest = end % num_people;\\n        int[] res = new int[num_people];\\n\\t\\tfor (int i = 0; i < num_people; i++) {\\n\\t\\t\\tif (i < rest) {\\n\\t\\t\\t\\tres[i] = (int)((i + 1) * (rounds + 1) + (1 + rounds) * rounds / 2 * num_people);\\n\\t\\t\\t} else if (i == rest) {\\n\\t\\t\\t\\tres[i] = (i + 1) * rounds + (rounds - 1) * rounds / 2 * num_people + extra_candies;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tres[i] = (i + 1) * rounds + (rounds - 1) * rounds / 2 * num_people;\\n\\t\\t\\t}\\n\\t\\t}\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 796969,
                "title": "c-one-pass-solution",
                "content": "candies can be separated into kth consecutive numbers and remains (less than k + 1) which can be represented by \\n\\n![image](https://assets.leetcode.com/users/images/1912f310-2130-4725-a1c5-7bcef2f1749c_1597674695.8112812.png)\\n\\nAfter getting k, we can know how many rounds that all persons get the desire candies are performed.\\n![image](https://assets.leetcode.com/users/images/60f69745-3943-4290-8fb1-8660ac2070a2_1597674738.0373456.png)\\n\\n\\nfor ith person, the total candies that he obtains is \\n\\n![image](https://assets.leetcode.com/users/images/55e53b64-f0b6-415c-b9dd-8ba9de9a6550_1597674766.2962093.png)\\n\\n\\nConvert above into C++ code\\n```C++\\nvector<int> distributeCandies(double candies, int num_people) {\\n\\tvector<int> res(num_people, 0);\\n\\n\\tdouble total = floor((-1 + sqrt(1 + 8 * candies)) / 2);\\n\\tint round = floor(total / num_people);\\n\\n\\tfor (int i = 1; i <= num_people; i++)\\n\\t{\\n\\t\\tint first = i;\\n\\t\\tint last = first + num_people * (round - 1);\\n\\t\\tint inComplete = candies - (num_people+last) * (num_people + last - 1) / 2;\\n\\t\\tres[i - 1] = (first + last) * round / 2 + max(min(last + num_people, inComplete), 0);\\n\\t}\\n\\n\\treturn res;\\n}\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```C++\\nvector<int> distributeCandies(double candies, int num_people) {\\n\\tvector<int> res(num_people, 0);\\n\\n\\tdouble total = floor((-1 + sqrt(1 + 8 * candies)) / 2);\\n\\tint round = floor(total / num_people);\\n\\n\\tfor (int i = 1; i <= num_people; i++)\\n\\t{\\n\\t\\tint first = i;\\n\\t\\tint last = first + num_people * (round - 1);\\n\\t\\tint inComplete = candies - (num_people+last) * (num_people + last - 1) / 2;\\n\\t\\tres[i - 1] = (first + last) * round / 2 + max(min(last + num_people, inComplete), 0);\\n\\t}\\n\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 796427,
                "title": "easy-to-understand-java-solution-without-complex-math-formulas",
                "content": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] arr = new int[num_people];\\n        \\n        int currCandyCount = 1;\\n        \\n        while(candies > 0) {\\n            for(int i = 0; i<num_people; i++) {\\n                if(candies >= currCandyCount) { // check if we have enough candies to distribute next\\n                    arr[i]+= currCandyCount;\\n                    candies -=currCandyCount;\\n                    currCandyCount++;\\n                } else { // we don\\'t have enough candies to distribute\\n                    arr[i] += candies; // distribute whatever is remaining\\n                    candies = 0; // set to 0 so it exits the while loop\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] arr = new int[num_people];\\n        \\n        int currCandyCount = 1;\\n        \\n        while(candies > 0) {\\n            for(int i = 0; i<num_people; i++) {\\n                if(candies >= currCandyCount) { // check if we have enough candies to distribute next\\n                    arr[i]+= currCandyCount;\\n                    candies -=currCandyCount;\\n                    currCandyCount++;\\n                } else { // we don\\'t have enough candies to distribute\\n                    arr[i] += candies; // distribute whatever is remaining\\n                    candies = 0; // set to 0 so it exits the while loop\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 797848,
                "title": "solution-python",
                "content": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        # create an array of size num_people and initialize it with 0\\n        list_people = [0] * num_people\\n        \\n        # starting value\\n        index = 1\\n        \\n        # iterate until the number of candies are more than 0\\n        while candies > 0:\\n            \\n            # if candies are more than index value, add the index value to the location \\n            if candies > index:\\n                # we are using mod operation by the num_people to locate the index of the array\\n                # we are subtracting by 1 because the array index starts at 0\\n                list_people[(index - 1) % num_people] += index\\n            else:\\n                # if candies are less than index value, add all remaining candies to location\\n                list_people[(index - 1) % num_people] += candies\\n            \\n            # subtract the candies with index values\\n            candies -= index\\n            \\n            # increment the index values\\n            index += 1\\n        \\n        # return the resultant array\\n        return(list_people)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        # create an array of size num_people and initialize it with 0\\n        list_people = [0] * num_people\\n        \\n        # starting value\\n        index = 1\\n        \\n        # iterate until the number of candies are more than 0\\n        while candies > 0:\\n            \\n            # if candies are more than index value, add the index value to the location \\n            if candies > index:\\n                # we are using mod operation by the num_people to locate the index of the array\\n                # we are subtracting by 1 because the array index starts at 0\\n                list_people[(index - 1) % num_people] += index\\n            else:\\n                # if candies are less than index value, add all remaining candies to location\\n                list_people[(index - 1) % num_people] += candies\\n            \\n            # subtract the candies with index values\\n            candies -= index\\n            \\n            # increment the index values\\n            index += 1\\n        \\n        # return the resultant array\\n        return(list_people)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 331676,
                "title": "c-0ms-no-math",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        \\n        int c = 1, i = 0;\\n        \\n        vector<int> result(num_people, 0);\\n        \\n        while(candies) {\\n\\n            int give = min(c, candies);\\n            result[i] += give;\\n            candies -= give;\\n            \\n            c++;\\n            i = (i+1) % num_people; \\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        \\n        int c = 1, i = 0;\\n        \\n        vector<int> result(num_people, 0);\\n        \\n        while(candies) {\\n\\n            int give = min(c, candies);\\n            result[i] += give;\\n            candies -= give;\\n            \\n            c++;\\n            i = (i+1) % num_people; \\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796547,
                "title": "optimal-python-solution-with-clear-explanation-of-idea",
                "content": "Please read with patience for clear understanding - Before proceeding, remember that sum of first n natural numbers is n*(n+1)//2\\n```\\nclass Solution:\\n    def distributeCandies(self, candies, num_people):\\n       \\'\\'\\'\\n        Idea: Round number k (starting from 1)\\n              -> give away\\n              (k-1)*n+1 + (k-1)*n+2 + ... + (k-1)*n + n = \\n              (k-1)*n^2 + n*(n+1)/2 candies\\n              \\n        Assume we have completed K full rounds, then K is the largest integer >= 0 with\\n        \\n        K*n*(n+1)/2 + K * (K-1)/2 * n^2 <= candies \\n        \\n        Find K by binary search and then simulate the last round.\\n        \\n        The person at index i gets\\n    \\n        0*n+i+1 + ... + (K-1)*n+i+1 = K*(i+1) + n*K*(K-1)/2 \\n        \\n        candies from rounds 1 to K, plus everything they get on their\\n        last round.\\n        \\n        Important: Allow for the fact that we may not complete a single round.\\n\\n        REVIEW\\n\\t\\t\\'\\'\\'\\n\\t\\t\\n        lo, hi = 0, candies\\n        K = 0\\n        while lo <= hi:\\n            k = (lo + hi)//2\\n            if k*(num_people*(num_people+1))//2 + (k*(k-1))//2 * num_people**2 <= candies:\\n                K = k\\n                lo = k + 1\\n            else:\\n                hi = k - 1\\n        result = [(i+1)*K+num_people*(K*(K-1))//2 for i in range(num_people)]\\n        candies -= sum(result)\\n        for i in range(num_people):\\n            add = min(candies, K * num_people + i + 1)\\n            result[i] += add\\n            candies -= add\\n            if candies == 0:\\n                break\\n        return result  \\n\\t\\t```\\nIf you came till here - Please Upvote my effort",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies, num_people):\\n       \\'\\'\\'\\n        Idea: Round number k (starting from 1)\\n              -> give away\\n              (k-1)*n+1 + (k-1)*n+2 + ... + (k-1)*n + n = \\n              (k-1)*n^2 + n*(n+1)/2 candies\\n              \\n        Assume we have completed K full rounds, then K is the largest integer >= 0 with\\n        \\n        K*n*(n+1)/2 + K * (K-1)/2 * n^2 <= candies \\n        \\n        Find K by binary search and then simulate the last round.\\n        \\n        The person at index i gets\\n    \\n        0*n+i+1 + ... + (K-1)*n+i+1 = K*(i+1) + n*K*(K-1)/2 \\n        \\n        candies from rounds 1 to K, plus everything they get on their\\n        last round.\\n        \\n        Important: Allow for the fact that we may not complete a single round.\\n\\n        REVIEW\\n\\t\\t\\'\\'\\'\\n\\t\\t\\n        lo, hi = 0, candies\\n        K = 0\\n        while lo <= hi:\\n            k = (lo + hi)//2\\n            if k*(num_people*(num_people+1))//2 + (k*(k-1))//2 * num_people**2 <= candies:\\n                K = k\\n                lo = k + 1\\n            else:\\n                hi = k - 1\\n        result = [(i+1)*K+num_people*(K*(K-1))//2 for i in range(num_people)]\\n        candies -= sum(result)\\n        for i in range(num_people):\\n            add = min(candies, K * num_people + i + 1)\\n            result[i] += add\\n            candies -= add\\n            if candies == 0:\\n                break\\n        return result  \\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1088057,
                "title": "c-0-ms-faster-than-100-00-4-lines-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> res(num_people);\\n        for ( int index = 0; candies > 0; ++index, candies -= index )\\n            res[index % num_people] += min(index + 1, candies);\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> res(num_people);\\n        for ( int index = 0; candies > 0; ++index, candies -= index )\\n            res[index % num_people] += min(index + 1, candies);\\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 797184,
                "title": "c-very-performant-linear-approach-explained-100-time-75-space",
                "content": "Alright, I promise I will try to keep the math part to a minimum, but bear with me for that part.\\n\\nAssuming we have 4 people to feed glue + glucose (and diabetes) as in the first example and having a large amount of them, our situation would look like this:\\n\\n```cpp\\n 1   2   3   4 => 10\\n 5   6   7   8 => 10 + 16\\n 9  10  11  12 => 10 + 32\\n13  14  15  16 => 10 + 48\\n```\\n\\nCan we spot a pattern here? I would say so: for now let\\'s look at each row and we can see how each one is formed; the initial one comes from the sum of all the first `n` numbers, but we know how to handle this with the Gaussian formula (conveniently abstracted in the `gaussianSum` helper).\\n\\nThe following ones come having each an extra of `n` times `n`, which I stored as `squaredN` times the current iteration (counting from `0`); or, in other words: the first round will be giving out `gaussianSum(n)` candies (we will store this number initially in `partialSum`) and all the following ones will increase said amount by `squaredN`.\\n\\nNow we can have a loop to compute how many full iterations we can run before being left with not enough candy to go for a full round of gluttony and this is not a small advantage!\\n\\nThe whole logic of the first `while` loop is dedicated to that, so that we can have a reliable `countLoop` value which tells us how many full loops we can go [and I am sure you can also set it up as an equation to find them, but I felt uninspired for that and it was more fun this way].\\n\\nNext step, we will fill all the slots with all the candies you can get doing full runs of each row.\\n\\nLooks again at this:\\n\\n```cpp\\n 1   2   3   4\\n 5   6   7   8\\n 9  10  11  12\\n13  14  15  16\\n```\\n\\nBut focus on the columns now: we can see that each one is made of `countLoops` times its position (starting the count from `1`, not from `0`) plus `0` times `n` from the first row, `1` time `n` from the second row, `2` times `n` from the second row and so on - that is to say, `gaussianSum(countLoops - 1)` times `n`.\\n\\nIn our `for` loop we put both thing together and we can get away filling the data of the full runs in linear time once we have `countLoops` properly computed.\\n\\nLast step: we need another `while` loop to finish assigning our sticky bonbon, iterating with `nextValue` initially set to the minimum value between the current amount of `candies` and `countLoops * n + 1` (which would have been the value of the extra candies given to the very first person in the next iteration), going on like that until we have something to give away - ie: at each step we decrease the amount of leftover `candies` by `nextValue`, add the `i`th cell by `nextValue` and increase both `i` and `nextValue` by `1`.\\n\\nAgain linear time :)\\n\\nFinally, we return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int gaussianSum(int n) {\\n        return (n + 1) * n / 2;\\n    }\\n    vector<int> distributeCandies(int candies, int n) {\\n        vector<int> res(n);\\n        // setting up necessary variables\\n        int countLoops = 0, partialSum = gaussianSum(n), squaredN = n * n, numberOfNs, i, nextValue;\\n        // computing how many full loops we can get\\n        while (partialSum <= candies) {\\n            countLoops++;\\n            candies -= partialSum;\\n            partialSum += squaredN;\\n        }\\n        // filling the vector with the full runs\\n        numberOfNs = gaussianSum(countLoops - 1);\\n        for (i = 0; i < res.size(); i++) res[i] =  numberOfNs * n + (i + 1) * (countLoops);\\n        // adding residual values to each cell as long as we can proceed like that\\n        nextValue = min(candies, countLoops * n + 1);\\n        i = 0;\\n        while (candies) {\\n            candies -= nextValue;\\n            res[i++] += nextValue;\\n            nextValue = min(candies, nextValue + 1);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nWell, in the end I did feel inspired and went on for a more mathematical approach.\\n\\nSticking to the previous example, we know that each full loop is made of the Gaussian sum of all the numbers up to `n` times the number of loops, plus `n` times `n`, AKA `squaredN`, times the sum of all the first `n - 1` numbers (check them looking at the second part of the sequence with `16, 32, 48, ...`). Allow me to repeat the scheme:\\n\\n```cpp\\n 1   2   3   4 => 10\\n 5   6   7   8 => 10 + 16\\n 9  10  11  12 => 10 + 32\\n13  14  15  16 => 10 + 48\\n```\\n\\nNow, we can build an equation out of it:\\n\\n```cpp\\ncandies == sumToN * x + (x - 1) * x / 2 * squaredN\\n```\\n\\nWith `x` being the number of full loops we can do (basically `countLoop`, but I guess with `x` it is clearer to see it as an equation).\\n\\nGrouping, we can have\\n\\n```cpp\\n0 == (squaredN / 2) * (x * x) + (sumToN -squaredN / 2) * x - candies;\\n```\\n\\nSo, basically we just need to solve a second degree equation with this coefficients:\\n* `a`: `squaredN / 2`;\\n* `b`: `sumToN -squaredN / 2`;\\n* `c`: `- candies`;\\n* taking only the positive solution (negative loops do not make sense here): `(-b + sqrt(b * b - 4 * a * c)) / (2 * a)`.\\n\\nAnd that works!\\n\\nBut now we have another problem: nothing decreases our `candies` any more!\\n\\nWell, we just have to compute how many we gave away with full loops!\\n\\nGiven that the formula for one cell is (see explanation above) `numberOfNs * n + (i + 1) * (countLoops)`, we just have to compute how much would it be running it from `1` to `n`, but that is relatively easy!\\n\\nDoing some math, we see that the first part is constant, so it would be `numberOfNs * n * n` or, better, `numberOfNs * squaredN`; the second part is basically `countLoops` multiplied the sum of all the numbers from `1` to `n` , so `sumToN * countLoops`.\\n\\nWith that done, we just need to keep our previous logic for the final (partial) pass and we are done :)\\n\\nThe updated code, much faster for larger values of `candies`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int gaussianSum(int n) {\\n        return (n + 1) * n / 2;\\n    }\\n    vector<int> distributeCandies(int candies, int n) {\\n        vector<int> res(n);\\n        // setting up necessary variables\\n        int countLoops, sumToN = gaussianSum(n), squaredN = n * n, numberOfNs, i, nextValue;\\n        // computing how many full loops we can get\\n        float halfSquaredN = squaredN / 2.0, a = halfSquaredN, b = sumToN - halfSquaredN, c = -candies;\\n        countLoops = (-b + sqrt(b * b - 4 * a * c)) / (2 * a);\\n        // filling the vector with the full runs\\n        numberOfNs = gaussianSum(countLoops - 1);\\n        for (i = 0; i < res.size(); i++) res[i] =  numberOfNs * n + (i + 1) * (countLoops);\\n        // updating candies\\n        candies -= numberOfNs * squaredN + sumToN * countLoops;\\n        // adding residual values to each cell as long as we can proceed like that\\n        nextValue = min(candies, countLoops * n + 1);\\n        i = 0;\\n        while (candies) {\\n            candies -= nextValue;\\n            res[i++] += nextValue;\\n            nextValue = min(candies, nextValue + 1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```cpp\\n 1   2   3   4 => 10\\n 5   6   7   8 => 10 + 16\\n 9  10  11  12 => 10 + 32\\n13  14  15  16 => 10 + 48\\n```\n```cpp\\n 1   2   3   4\\n 5   6   7   8\\n 9  10  11  12\\n13  14  15  16\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int gaussianSum(int n) {\\n        return (n + 1) * n / 2;\\n    }\\n    vector<int> distributeCandies(int candies, int n) {\\n        vector<int> res(n);\\n        // setting up necessary variables\\n        int countLoops = 0, partialSum = gaussianSum(n), squaredN = n * n, numberOfNs, i, nextValue;\\n        // computing how many full loops we can get\\n        while (partialSum <= candies) {\\n            countLoops++;\\n            candies -= partialSum;\\n            partialSum += squaredN;\\n        }\\n        // filling the vector with the full runs\\n        numberOfNs = gaussianSum(countLoops - 1);\\n        for (i = 0; i < res.size(); i++) res[i] =  numberOfNs * n + (i + 1) * (countLoops);\\n        // adding residual values to each cell as long as we can proceed like that\\n        nextValue = min(candies, countLoops * n + 1);\\n        i = 0;\\n        while (candies) {\\n            candies -= nextValue;\\n            res[i++] += nextValue;\\n            nextValue = min(candies, nextValue + 1);\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\n 1   2   3   4 => 10\\n 5   6   7   8 => 10 + 16\\n 9  10  11  12 => 10 + 32\\n13  14  15  16 => 10 + 48\\n```\n```cpp\\ncandies == sumToN * x + (x - 1) * x / 2 * squaredN\\n```\n```cpp\\n0 == (squaredN / 2) * (x * x) + (sumToN -squaredN / 2) * x - candies;\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int gaussianSum(int n) {\\n        return (n + 1) * n / 2;\\n    }\\n    vector<int> distributeCandies(int candies, int n) {\\n        vector<int> res(n);\\n        // setting up necessary variables\\n        int countLoops, sumToN = gaussianSum(n), squaredN = n * n, numberOfNs, i, nextValue;\\n        // computing how many full loops we can get\\n        float halfSquaredN = squaredN / 2.0, a = halfSquaredN, b = sumToN - halfSquaredN, c = -candies;\\n        countLoops = (-b + sqrt(b * b - 4 * a * c)) / (2 * a);\\n        // filling the vector with the full runs\\n        numberOfNs = gaussianSum(countLoops - 1);\\n        for (i = 0; i < res.size(); i++) res[i] =  numberOfNs * n + (i + 1) * (countLoops);\\n        // updating candies\\n        candies -= numberOfNs * squaredN + sumToN * countLoops;\\n        // adding residual values to each cell as long as we can proceed like that\\n        nextValue = min(candies, countLoops * n + 1);\\n        i = 0;\\n        while (candies) {\\n            candies -= nextValue;\\n            res[i++] += nextValue;\\n            nextValue = min(candies, nextValue + 1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796528,
                "title": "c-simple-explained-solution-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> res(num_people, 0); // start with zero candies for each person\\n        int i=0;\\n        while (candies > 0) // while there are more candies to distribute\\n        {\\n            res[i%num_people]+=i+1;\\n            candies-=i+1;\\n            i++;\\n        }\\n        if (candies < 0) // if the last person got more than the candies we had left\\n            res[(i-1)%num_people] -= abs(candies);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> res(num_people, 0); // start with zero candies for each person\\n        int i=0;\\n        while (candies > 0) // while there are more candies to distribute\\n        {\\n            res[i%num_people]+=i+1;\\n            candies-=i+1;\\n            i++;\\n        }\\n        if (candies < 0) // if the last person got more than the candies we had left\\n            res[(i-1)%num_people] -= abs(candies);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323418,
                "title": "python-math-solution-explained-o-n",
                "content": "First check how many complete rounds\\nthen distribute the rest greedy.\\n```\\nclass Solution:\\n    def distributeCandies(self, c: int, n: int) -> List[int]:\\n        k = math.floor((math.sqrt(1+8*c)-1)/2/n)\\n        res = [0 for i in range(n)]\\n        for i in range(n):\\n            res[i] = (i+1+(k-1)*(n)+i+1)*k/2\\n        remain = c - sum(res)\\n        i = 0\\n        cur = k*n+1\\n        while remain >= 0:\\n            res[i] += min(remain,cur)\\n            remain -= cur\\n            \\n            cur += 1\\n            i += 1\\n        return [int(i) for i in res]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, c: int, n: int) -> List[int]:\\n        k = math.floor((math.sqrt(1+8*c)-1)/2/n)\\n        res = [0 for i in range(n)]\\n        for i in range(n):\\n            res[i] = (i+1+(k-1)*(n)+i+1)*k/2\\n        remain = c - sum(res)\\n        i = 0\\n        cur = k*n+1\\n        while remain >= 0:\\n            res[i] += min(remain,cur)\\n            remain -= cur\\n            \\n            cur += 1\\n            i += 1\\n        return [int(i) for i in res]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361640,
                "title": "java-o-num-people-beats-100-with-detailed-math-explanation",
                "content": "This solution is based on the hint provided in the question. *Give candy to everyone each \"turn\" first [until you can\\'t], then give candy to one person per turn.*\\n\\nFirst, we get the number of turns in which we can distribute candies on every one. For example if we have 21 candies and 3 people. We have 2 turns. In the first turn we give 1, 2, 3 and in the 2nd we give 4, 5, 6. The candies distributed per turn are as follows:\\n\\n1st turn  => 1, 2, 3, ...., n \\n\\n\\t=> 0 * n + 1 + 0 * n + 2 + 0 * n + 3, ..., 0 * n + n\\n\\t\\n2nd turn => n + 1, n + 2, n + 3, ... , n + n \\n\\n\\t=>  1 * n + 1 + 1 * n + 2 + 1 * n + 3, ..., 1 * n + n\\n\\t\\n3rd turn => 2n + 1, 2n + 2, 2n + 3, ...., 2n + n \\n\\n\\t=> 2 * n + 1 + 2 * n + 2 + 2 * n + 3, ..., 2 * n + n\\n\\t\\nkth turn \\n\\n\\t=> (k - 1) * n + 1 + (k - 1) * n + 2 + (k - 1) * n + 3, ..., (k - 1) * n + n\\n\\t\\nThe total number of candies per turn for all people can be described by \\n\\t\\n\\tn * (k - 1) * n + summation of sequence 1, 2, 3, .., n. \\n\\t=> n * (k - 1) * n + (n (n + 1)) / 2.\\n\\nGet the total number of turns by subtracting the total turn candies from the total number of candies.\\n\\n```\\nint turns = 0; // starting at turn 0 instead of doing k - 1\\nint n = num_people;\\nint closedSum = (n * (n + 1)) / 2;\\nint totalTurnSum = closedSum;\\n\\n// Getting total number of possible FULL turns\\nwhile (candies - totalTurnSum >= 0) {\\n\\tcandies -= totalTurnSum;\\n\\t// Setting totalTurnSum for next turn\\n\\ttotalTurnSum = n * (++turns) * n + closedSum;\\n}\\n```\\n\\nThe total number of candies for the ith person for all \"full\" turns can be described by summation of the sequence (k - 1) * n + (k - 1) * (i + 1) (Because the first person (i = 0) starts with 1) over k, where k is the number of turns. \\n\\n\\tsummation of  [ (k - 1) * n + (i + 1) ]  over k from 1 to turns\\n\\t= summation of (k - 1) * n + summation of (i + 1)\\n\\t= n * summation of (k - 1) + (i + 1) summation of 1\\n\\t= n * ((turns - 1) * turns) / 2 +  (i + 1) * turns\\n\\n```\\n// if we have at least 1 full turn\\nif (turns > 0) {\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tres[i] = n * (turns * (turns - 1)) / 2 + (i + 1) * turns;\\n\\t}\\n}\\n```\\n\\nFor the last incomplete turn we simply distribute the remaining coins. (Similar to this approach by rock https://leetcode.com/problems/distribute-candies-to-people/discuss/323314/JavaPython3-Easy-code-w-explanation-and-analysis.)\\n\\n```\\n// distributing the last incomplete turn\\nint offset = turns * n + 1;\\nfor (int i = 0; i < n && candies > 0; i++) {\\n\\tres[i] += Math.min(candies, offset);\\n\\tcandies -= offset++;\\n}\\n```\\n\\nThis might be an overkill for an easy question. Code modifications, tips and tricks are most welcome! :)\\n\\n```\\npublic int[] distributeCandies(int candies, int num_people) {\\n        if (candies == 0 || num_people == 0) return new int[num_people];\\n        int[] res = new int[num_people];\\n        int turns = 0;  // starting at turn 0 instead of doing k - 1\\n\\t\\tint n = num_people;\\n\\t\\tint closedSum = (n * (n + 1)) / 2;\\n\\t\\tint totalTurnSum = closedSum;\\n\\t\\t// Getting total number of possible FULL turns\\n\\t\\twhile (candies - totalTurnSum >= 0) {\\n\\t\\t\\tcandies -= totalTurnSum;\\n\\t\\t\\t// Setting totalTurnSum for next turn\\n\\t\\t\\ttotalTurnSum = n * (++turns) * n + closedSum;\\n\\t\\t}\\n        // if we have at least 1 full turn\\n        if (turns > 0) {\\n            for (int i = 0; i < n; i++) {\\n                res[i] = n * (turns * (turns - 1)) / 2 +  (i + 1) * turns;\\n            }\\n        }\\n        // distributing the last incomplete turn\\n        int offset = turns * n + 1;\\n        for (int i = 0; i < n && candies > 0; i++) {\\n            res[i] += Math.min(candies, offset);\\n            candies -= offset++;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nint turns = 0; // starting at turn 0 instead of doing k - 1\\nint n = num_people;\\nint closedSum = (n * (n + 1)) / 2;\\nint totalTurnSum = closedSum;\\n\\n// Getting total number of possible FULL turns\\nwhile (candies - totalTurnSum >= 0) {\\n\\tcandies -= totalTurnSum;\\n\\t// Setting totalTurnSum for next turn\\n\\ttotalTurnSum = n * (++turns) * n + closedSum;\\n}\\n```\n```\\n// if we have at least 1 full turn\\nif (turns > 0) {\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tres[i] = n * (turns * (turns - 1)) / 2 + (i + 1) * turns;\\n\\t}\\n}\\n```\n```\\n// distributing the last incomplete turn\\nint offset = turns * n + 1;\\nfor (int i = 0; i < n && candies > 0; i++) {\\n\\tres[i] += Math.min(candies, offset);\\n\\tcandies -= offset++;\\n}\\n```\n```\\npublic int[] distributeCandies(int candies, int num_people) {\\n        if (candies == 0 || num_people == 0) return new int[num_people];\\n        int[] res = new int[num_people];\\n        int turns = 0;  // starting at turn 0 instead of doing k - 1\\n\\t\\tint n = num_people;\\n\\t\\tint closedSum = (n * (n + 1)) / 2;\\n\\t\\tint totalTurnSum = closedSum;\\n\\t\\t// Getting total number of possible FULL turns\\n\\t\\twhile (candies - totalTurnSum >= 0) {\\n\\t\\t\\tcandies -= totalTurnSum;\\n\\t\\t\\t// Setting totalTurnSum for next turn\\n\\t\\t\\ttotalTurnSum = n * (++turns) * n + closedSum;\\n\\t\\t}\\n        // if we have at least 1 full turn\\n        if (turns > 0) {\\n            for (int i = 0; i < n; i++) {\\n                res[i] = n * (turns * (turns - 1)) / 2 +  (i + 1) * turns;\\n            }\\n        }\\n        // distributing the last incomplete turn\\n        int offset = turns * n + 1;\\n        for (int i = 0; i < n && candies > 0; i++) {\\n            res[i] += Math.min(candies, offset);\\n            candies -= offset++;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1369518,
                "title": "python3-very-easy-o-n",
                "content": "\\tclass Solution:\\n\\t\\tdef distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n\\t\\t\\tresult=[0]*num_people\\n\\t\\t\\tcurrentCandies=1\\n\\t\\t\\ti=0\\n\\t\\t\\twhile candies>0:\\n\\t\\t\\t\\tresult[i%num_people]+=min(candies,currentCandies)\\n\\t\\t\\t\\tcandies-=currentCandies\\n\\t\\t\\t\\tcurrentCandies+=1\\n\\t\\t\\t\\ti+=1\\n\\t\\t\\treturn result",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n\\t\\t\\tresult=[0]*num_people\\n\\t\\t\\tcurrentCandies=1\\n\\t\\t\\ti=0\\n\\t\\t\\twhile candies>0:\\n\\t\\t\\t\\tresult[i%num_people]+=min(candies,currentCandies)\\n\\t\\t\\t\\tcandies-=currentCandies\\n\\t\\t\\t\\tcurrentCandies+=1\\n\\t\\t\\t\\ti+=1\\n\\t\\t\\treturn result",
                "codeTag": "Java"
            },
            {
                "id": 464830,
                "title": "python-simplest-and-easiest-understand-way",
                "content": "```\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        \\n        ans = [0]* num_people\\n        cnt = 1\\n        \\n        while candies > 0:\\n\\n            for i in range(len(ans)):\\n\\n                if candies >= cnt:\\n                    ans[i] += cnt\\n                    candies -= cnt\\n                else:\\n                    ans[i] += candies\\n                    candies = 0\\n                cnt += 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        \\n        ans = [0]* num_people\\n        cnt = 1\\n        \\n        while candies > 0:\\n\\n            for i in range(len(ans)):\\n\\n                if candies >= cnt:\\n                    ans[i] += cnt\\n                    candies -= cnt\\n                else:\\n                    ans[i] += candies\\n                    candies = 0\\n                cnt += 1\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3405818,
                "title": "easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        lis=[0]*num_people\\n        i=1\\n        j=0\\n        while(candies):\\n            if(candies<i):\\n                lis[j%num_people]+=candies\\n                break\\n            if(candies>=i):\\n                lis[j%num_people]+=i\\n                candies-=i\\n                j+=1\\n                i+=1\\n            \\n        return(lis)\\n\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        lis=[0]*num_people\\n        i=1\\n        j=0\\n        while(candies):\\n            if(candies<i):\\n                lis[j%num_people]+=candies\\n                break\\n            if(candies>=i):\\n                lis[j%num_people]+=i\\n                candies-=i\\n                j+=1\\n                i+=1\\n            \\n        return(lis)\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739916,
                "title": "simple-beginner-friendly-approach-java",
                "content": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n       int[] ans = new int[num_people];\\n        int count = 1;\\n        int i = 0;\\n        while(candies>0){\\n            if(candies<count)\\n                ans[i]=ans[i]+candies;\\n            else\\n                ans[i]=ans[i]+count;\\n            i++;\\n            candies-=count;\\n            count++;\\n            if(i==ans.length)\\n                i=0;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n       int[] ans = new int[num_people];\\n        int count = 1;\\n        int i = 0;\\n        while(candies>0){\\n            if(candies<count)\\n                ans[i]=ans[i]+candies;\\n            else\\n                ans[i]=ans[i]+count;\\n            i++;\\n            candies-=count;\\n            count++;\\n            if(i==ans.length)\\n                i=0;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1424125,
                "title": "c-easy-to-understand-fast-and-efficient",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n       vector<int> ans(num_people);\\n        int loops=0,i=0,curr_candies;\\n       while(candies>0)\\n       {\\n           if(i==num_people)\\n           {\\n              loops++;\\n              i=0;\\n           }  \\n           curr_candies=loops*num_people+i+1;\\n           if(candies-curr_candies<0)\\n           {\\n              ans[i]+=candies;\\n           }\\n           else\\n           ans[i]+=curr_candies;\\n           candies-=curr_candies;\\n           i++;\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n       vector<int> ans(num_people);\\n        int loops=0,i=0,curr_candies;\\n       while(candies>0)\\n       {\\n           if(i==num_people)\\n           {\\n              loops++;\\n              i=0;\\n           }  \\n           curr_candies=loops*num_people+i+1;\\n           if(candies-curr_candies<0)\\n           {\\n              ans[i]+=candies;\\n           }\\n           else\\n           ans[i]+=curr_candies;\\n           candies-=curr_candies;\\n           i++;\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1402807,
                "title": "java-solution",
                "content": "class Solution {\\n    public int[] distributeCandies(int candies, int n) {\\n        \\n        int[]ans=new int[n];\\n        int i=0;\\n        while(candies>0){\\n            ans[i%n]+=Math.min(i+1,candies);    \\n\\t\\t\\t//doing i%n so that we can some back  again and give candies if there are any\\n            candies-=i+1;\\n            i++;\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] distributeCandies(int candies, int n) {\\n        \\n        int[]ans=new int[n];\\n        int i=0;\\n        while(candies>0){\\n            ans[i%n]+=Math.min(i+1,candies);    \\n\\t\\t\\t//doing i%n so that we can some back  again and give candies if there are any\\n            candies-=i+1;\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1088053,
                "title": "python-easy-understanding-solution",
                "content": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        res = [0] * num_people\\n        index = 0\\n        while candies > 0:\\n            res[index % num_people] += min(index + 1, candies)\\n            index += 1\\n            candies -= index\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        res = [0] * num_people\\n        index = 0\\n        while candies > 0:\\n            res[index % num_people] += min(index + 1, candies)\\n            index += 1\\n            candies -= index\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 797800,
                "title": "java-solution-beats-100-time",
                "content": "Given candies = 40 , num_people = 3.\\n\\nThe distrbution is like the following:\\n```\\n\\t\\t\\tpeople_0  people_1  people_2  \\nrow_0           1         2         3\\nrow_1           4         5         6\\nrow_2           7         8         (4)\\n```\\n\\nThe total number of candies ditrubuted to each people are:\\npeople_0: 1 + 4 + 7\\npeople_1: 2 + 5 + 8\\npeople_2: 3 + 6 + (4)\\n\\nIts indicated that the number of candies each person receives follows arithmetic sequence where the common difference is the 3 (num_people)\\n\\nSo the goals of the problem are to:\\n```\\n1) Find the last number of the distrubition without running out of candies. which is to find 8 in above case.\\n2) Calculate the total number of candies for each people. \\n3) Find the index of the last people who are given the remaining candies after 1), which is 8 % 3 = 2.\\n4) Calcute the number of remaining candies after 1), which is (4) in above case.  (40 - (1+2 ... +8) = 4)\\n```\\n\\nTo calucate 1) \\nWe have to find the max positive integer of N which satifies \\n(1 + N) * N / 2 <= candies   \\n--> \\nN2 + N - 2 * candies <= 0\\n\\nSo N = floor( ![image](https://assets.leetcode.com/users/images/cfcf8b6b-64d2-41b1-9078-adee03d4332f_1597709353.2275171.png)) \\n=  floor(![image](https://assets.leetcode.com/users/images/c6cdb2ef-df45-44f1-97a7-b06f89689cf5_1597709442.058968.png) )\\n=  floor(![image](https://assets.leetcode.com/users/images/b106ad98-d715-4e88-b08b-0d65eec92872_1597709484.9748318.png))\\n\\nTo calcaute 2)\\n```\\ntotal(people_i) = (first_time_candies_given + last_time_candies_given) * times_candies_given / 2;\\n\\n                = (i+1) + ((i+1) + (highest_row-1) * num_people)) * highest_row / 2;\\n\\nFor e.g. \\ntotal(people_0) = ((0+1) + (0+1) + (3-1) * 3)) * 3 /2\\n                = (1 + (1 + 2 * 3)) * 3 / 2 = 12\\n\\ntotal(people_2) = ((2+1) + (2+1) + (2-1) * 3)) * 3 /2\\n                = (3 + (3 + 1 * 3)) * 2 / 2 = 9\\n```\\nTo calcaulte 4) \\n```\\nrenaming_candies = candies - (1 + N) * N /2\\n```\\n```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        \\n        int N = (int) Math.floor(((Math.sqrt(1 + 8 * (long) candies) - 1) / 2));\\n        int[] ans = new int[num_people];\\n        int row = N / num_people;\\n\\t\\t\\n        for(int i = 0; i < N && i < num_people; i++) {\\n            if(i < N % num_people) {\\n                ans[i] = (2 * (i+1) + row * num_people) * (row + 1) / 2;\\n            }\\n            else {\\n                ans[i] = (2 * (i+1) + (row - 1) * num_people) * row / 2;\\n            }\\n        }\\n        \\n\\t\\t// add remaning candies to his total\\n        ans[N % num_people] += candies - N * (N + 1) /2;\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\nTime:O(n)     n->num_people\\nExtra space:O(1)",
                "solutionTags": [],
                "code": "```\\n\\t\\t\\tpeople_0  people_1  people_2  \\nrow_0           1         2         3\\nrow_1           4         5         6\\nrow_2           7         8         (4)\\n```\n```\\n1) Find the last number of the distrubition without running out of candies. which is to find 8 in above case.\\n2) Calculate the total number of candies for each people. \\n3) Find the index of the last people who are given the remaining candies after 1), which is 8 % 3 = 2.\\n4) Calcute the number of remaining candies after 1), which is (4) in above case.  (40 - (1+2 ... +8) = 4)\\n```\n```\\ntotal(people_i) = (first_time_candies_given + last_time_candies_given) * times_candies_given / 2;\\n\\n                = (i+1) + ((i+1) + (highest_row-1) * num_people)) * highest_row / 2;\\n\\nFor e.g. \\ntotal(people_0) = ((0+1) + (0+1) + (3-1) * 3)) * 3 /2\\n                = (1 + (1 + 2 * 3)) * 3 / 2 = 12\\n\\ntotal(people_2) = ((2+1) + (2+1) + (2-1) * 3)) * 3 /2\\n                = (3 + (3 + 1 * 3)) * 2 / 2 = 9\\n```\n```\\nrenaming_candies = candies - (1 + N) * N /2\\n```\n```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        \\n        int N = (int) Math.floor(((Math.sqrt(1 + 8 * (long) candies) - 1) / 2));\\n        int[] ans = new int[num_people];\\n        int row = N / num_people;\\n\\t\\t\\n        for(int i = 0; i < N && i < num_people; i++) {\\n            if(i < N % num_people) {\\n                ans[i] = (2 * (i+1) + row * num_people) * (row + 1) / 2;\\n            }\\n            else {\\n                ans[i] = (2 * (i+1) + (row - 1) * num_people) * row / 2;\\n            }\\n        }\\n        \\n\\t\\t// add remaning candies to his total\\n        ans[N % num_people] += candies - N * (N + 1) /2;\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 797248,
                "title": "python-easy-o-sqrt-candies-solution",
                "content": "The idea of my solution is super straightforward. We basically follow the task: we would add 1 to the first cell, 2 to the second, and so on. If we reach the end of the loop we subtracts the list length (=*num_people*) from the iteration counter and keep doing so. How long do we do it? As long as we have more candies than we have to add. So once *i* surpasses *candies* we exit the loop. After that we just have to add the remaining candies to the next cell and that would be it. \\n\\n```\\n        res = [0] * num_people\\n        i, j = 0, 0\\n        i = 0\\n        while candies > i:\\n            res[j] += i + 1\\n            j += 1\\n            i += 1\\n            candies -= i\\n            if j == num_people - 1: j -= num_people\\n        res[j] += candies\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n        res = [0] * num_people\\n        i, j = 0, 0\\n        i = 0\\n        while candies > i:\\n            res[j] += i + 1\\n            j += 1\\n            i += 1\\n            candies -= i\\n            if j == num_people - 1: j -= num_people\\n        res[j] += candies\\n        return res\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 796986,
                "title": "javascript-easy-solution",
                "content": "```\\nvar distributeCandies = function(candies, num_people) {\\n    let finalDistribution = new Array(num_people).fill(0) // [0,0,0,0] //candies=7\\n    let candy =1;\\n    let i = 0;\\n    while(candy < candies){\\n        if(i===num_people) i=0\\n        finalDistribution[i] = finalDistribution[i]+candy;\\n        candies = candies - candy;\\n        candy++;\\n        i++;\\n    }\\n    if(candies > 0){\\n        if(i===num_people) i=0;\\n        finalDistribution[i] = finalDistribution[i] + candies;\\n    }\\n    return finalDistribution\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar distributeCandies = function(candies, num_people) {\\n    let finalDistribution = new Array(num_people).fill(0) // [0,0,0,0] //candies=7\\n    let candy =1;\\n    let i = 0;\\n    while(candy < candies){\\n        if(i===num_people) i=0\\n        finalDistribution[i] = finalDistribution[i]+candy;\\n        candies = candies - candy;\\n        candy++;\\n        i++;\\n    }\\n    if(candies > 0){\\n        if(i===num_people) i=0;\\n        finalDistribution[i] = finalDistribution[i] + candies;\\n    }\\n    return finalDistribution\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3773227,
                "title": "faster-than-100-beats-java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int k) {\\n        int ary[]=new int[k];\\n        int val=1;\\n        int indexstore=0;\\n        int sum=0;\\n        int count=0;\\n  while(candies>0) // Travels ary Untile Your canie not finish\\n  {\\n      for(int i=0;i<k;i++)\\n      {\\n          candies-=val;\\n          if(candies>=0)\\n          {\\n          ary[i]+=val;\\n          if(candies==0) // If your candi finish stop and break loop\\n          {\\n              break;\\n\\n          }\\n          }\\n          else\\n          {\\n              ary[i]+=val+candies;\\n              indexstore=i;\\n              break;\\n          }\\n          val++;\\n      }\\n      count++;\\n  }\\n  if(indexstore!=0 && indexstore!=k-1 && count==0) // when your candi finish but pepole who have not even one canie give them o candie\\n  {\\n        for (int i = indexstore; i < k; i++) {\\n                ary[i] = 0;\\n            }\\n  }\\n  return ary;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int k) {\\n        int ary[]=new int[k];\\n        int val=1;\\n        int indexstore=0;\\n        int sum=0;\\n        int count=0;\\n  while(candies>0) // Travels ary Untile Your canie not finish\\n  {\\n      for(int i=0;i<k;i++)\\n      {\\n          candies-=val;\\n          if(candies>=0)\\n          {\\n          ary[i]+=val;\\n          if(candies==0) // If your candi finish stop and break loop\\n          {\\n              break;\\n\\n          }\\n          }\\n          else\\n          {\\n              ary[i]+=val+candies;\\n              indexstore=i;\\n              break;\\n          }\\n          val++;\\n      }\\n      count++;\\n  }\\n  if(indexstore!=0 && indexstore!=k-1 && count==0) // when your candi finish but pepole who have not even one canie give them o candie\\n  {\\n        for (int i = indexstore; i < k; i++) {\\n                ary[i] = 0;\\n            }\\n  }\\n  return ary;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2801400,
                "title": "js-o-n-beats-95-easy-to-read",
                "content": "# Intuition\\nIterate over the total amount of candies.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * @param {number} candies\\n * @param {number} num_people\\n * @return {number[]}\\n */\\nvar distributeCandies = function (c, n) {\\n  let j = 0;\\n  let left = c;\\n  const arr = [];\\n  for (let i = 0; i < n; i++) {\\n    arr[i] = 0;\\n  }\\n  for (let i = 1; i < c + 1; i++) {\\n    if (i > left) {\\n      arr[j] += left;\\n      break;\\n    }\\n    arr[j] += i;\\n    j++;\\n    if (j === n) {\\n      j = 0;\\n    }\\n    left -= i;\\n  }\\n  return arr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} candies\\n * @param {number} num_people\\n * @return {number[]}\\n */\\nvar distributeCandies = function (c, n) {\\n  let j = 0;\\n  let left = c;\\n  const arr = [];\\n  for (let i = 0; i < n; i++) {\\n    arr[i] = 0;\\n  }\\n  for (let i = 1; i < c + 1; i++) {\\n    if (i > left) {\\n      arr[j] += left;\\n      break;\\n    }\\n    arr[j] += i;\\n    j++;\\n    if (j === n) {\\n      j = 0;\\n    }\\n    left -= i;\\n  }\\n  return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2652771,
                "title": "c-super-easy-faster-than-100",
                "content": "class Solution {\\npublic:\\n\\n    vector<int> distributeCandies(int candies, int len) {\\n        int i=0;\\n        int a=1;\\n        vector<int>ans(len,0);\\n       while(1){  \\n           if(candies<a){\\n               ans[i]+=candies;\\n               break;\\n           } \\n           ans[i]+=a;\\n           candies-=a;\\n           i=(i+1)%len;\\n           a++;\\n       }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> distributeCandies(int candies, int len) {\\n        int i=0;\\n        int a=1;\\n        vector<int>ans(len,0);\\n       while(1){  \\n           if(candies<a){\\n               ans[i]+=candies;\\n               break;\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 2641832,
                "title": "js-very-easy-solution",
                "content": "```\\nvar distributeCandies = function(candies, num_people) {\\n    const output = new Array(num_people).fill(0);\\n    let cursor = 0;\\n    let count = 1;\\n    \\n    while (candies > 0) {\\n        output[cursor] += (count <= candies ? count : candies);\\n        candies -= count;\\n        count++;\\n        cursor++;\\n        if (cursor === num_people) {\\n            cursor = 0;\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar distributeCandies = function(candies, num_people) {\\n    const output = new Array(num_people).fill(0);\\n    let cursor = 0;\\n    let count = 1;\\n    \\n    while (candies > 0) {\\n        output[cursor] += (count <= candies ? count : candies);\\n        candies -= count;\\n        count++;\\n        cursor++;\\n        if (cursor === num_people) {\\n            cursor = 0;\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2501941,
                "title": "java-easy-code",
                "content": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int ans[]=new int[num_people];\\n        int ix=0, gift=1;\\n        while(candies>0){\\n            ix=ix%num_people;\\n            if(gift<=candies){\\n                ans[ix]+=gift;\\n            }else{\\n                ans[ix]+=candies;\\n            }\\n            candies-=gift;\\n            ix++;\\n            gift++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int ans[]=new int[num_people];\\n        int ix=0, gift=1;\\n        while(candies>0){\\n            ix=ix%num_people;\\n            if(gift<=candies){\\n                ans[ix]+=gift;\\n            }else{\\n                ans[ix]+=candies;\\n            }\\n            candies-=gift;\\n            ix++;\\n            gift++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2440921,
                "title": "easy-c-solution-simple-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> distributeCandies(int candies, int n) {\\n\\n\\t\\t\\tvector<int> ans(n, 0);\\n\\n\\t\\t\\tint i = 0, x = 1;\\n\\t\\t\\twhile(candies != 0){\\n\\n\\t\\t\\t\\tif(candies < x){\\n\\t\\t\\t\\t\\tans[i % n] += candies;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tans[i % n] += x;\\n\\t\\t\\t\\tcandies -= x;\\n\\n\\t\\t\\t\\tx++;\\n\\t\\t\\t\\ti++;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\nI hope that you\\'ve found the solution useful.\\nIn that case, please do upvote. Happy Coding :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> distributeCandies(int candies, int n) {\\n\\n\\t\\t\\tvector<int> ans(n, 0);\\n\\n\\t\\t\\tint i = 0, x = 1;\\n\\t\\t\\twhile(candies != 0){\\n\\n\\t\\t\\t\\tif(candies < x){\\n\\t\\t\\t\\t\\tans[i % n] += candies;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 985041,
                "title": "python-3-solution-28-36ms",
                "content": "The idea is that:\\n\\nthe candies are distributed as `1,2,3,4,...,n, candies-(n+1)*n/2`, thus we just need to find `n`. Then the problem is easy to deal with.\\n\\n```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        #\\n        res = [0]*num_people\\n        n = int(-1/2+sqrt(4*2*candies+1)/2)  # find n by Vieta\\'s formulas\\n        turns = n//num_people\\n        flattern = list(range(1,n+1))+[candies-n*(n+1)//2]\\n        flattern += (-len(flattern)+(turns+1)*num_people)*[0]\\n        for i in range(turns+1):\\n            res = [m+n for m,n in zip(res,flattern[i*num_people:(i+1)*num_people])]\\n        return res\\n```\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        #\\n        res = [0]*num_people\\n        n = int(-1/2+sqrt(4*2*candies+1)/2)  # find n by Vieta\\'s formulas\\n        turns = n//num_people\\n        flattern = list(range(1,n+1))+[candies-n*(n+1)//2]\\n        flattern += (-len(flattern)+(turns+1)*num_people)*[0]\\n        for i in range(turns+1):\\n            res = [m+n for m,n in zip(res,flattern[i*num_people:(i+1)*num_people])]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 797425,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        \\n        results=[0]*num_people \\n        give=0\\n        totalCandiesGiven=0\\n        left=candies-totalCandiesGiven\\n        \\n        while totalCandiesGiven<candies: \\n\\n            for i in range(len(results)): \\n                \\n                left=candies-totalCandiesGiven    \\n                give+=1\\n                \\n                results[i]= results[i]+give if left>=give else results[i]+left\\n                \\n\\n                totalCandiesGiven+=give\\n                \\n                if totalCandiesGiven>=candies:\\n                    break\\n                \\n                \\n        return results        \\n\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        \\n        results=[0]*num_people \\n        give=0\\n        totalCandiesGiven=0\\n        left=candies-totalCandiesGiven\\n        \\n        while totalCandiesGiven<candies: \\n\\n            for i in range(len(results)): \\n                \\n                left=candies-totalCandiesGiven    \\n                give+=1\\n                \\n                results[i]= results[i]+give if left>=give else results[i]+left\\n                \\n\\n                totalCandiesGiven+=give\\n                \\n                if totalCandiesGiven>=candies:\\n                    break\\n                \\n                \\n        return results        \\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 796845,
                "title": "distribute-candies-java-o-candies",
                "content": "```\\nclass Solution {\\n\\n    public int[] distributeCandies(int candies, int n) {\\n        int[] res = new int[n];\\n        int i = 0,j = 1;\\n        while( candies > 0 ){\\n            res[i%n] += j<candies?j:candies;\\n            candies -= j;\\n            j++; i++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    public int[] distributeCandies(int candies, int n) {\\n        int[] res = new int[n];\\n        int i = 0,j = 1;\\n        while( candies > 0 ){\\n            res[i%n] += j<candies?j:candies;\\n            candies -= j;\\n            j++; i++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796821,
                "title": "beating-100-simple-c-solution-p",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> ans;\\n        int i=1;\\n        while(candies -i>0 && ans.size()<num_people){\\n            ans.push_back(i);\\n            candies-=i;\\n            i++;\\n        }\\n        while(ans.size()<num_people){\\n            ans.push_back(candies);\\n            candies=0;\\n        }\\n        if(candies==0) return ans;\\n        int j=num_people+1;\\n        int k=0;\\n        while(candies>0){\\n            k=k% num_people;\\n            if(candies>j){\\n                ans[k]+=j;\\n                candies-=j;\\n            }\\n            else{\\n                ans[k]+=candies;\\n                break;\\n            }\\n            k++;\\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> ans;\\n        int i=1;\\n        while(candies -i>0 && ans.size()<num_people){\\n            ans.push_back(i);\\n            candies-=i;\\n            i++;\\n        }\\n        while(ans.size()<num_people){\\n            ans.push_back(candies);\\n            candies=0;\\n        }\\n        if(candies==0) return ans;\\n        int j=num_people+1;\\n        int k=0;\\n        while(candies>0){\\n            k=k% num_people;\\n            if(candies>j){\\n                ans[k]+=j;\\n                candies-=j;\\n            }\\n            else{\\n                ans[k]+=candies;\\n                break;\\n            }\\n            k++;\\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796777,
                "title": "typescript-solutions",
                "content": "// Runtime: 76 ms, faster than 48.28% of JavaScript online submissions for Distribute Candies to People.\\n// Memory Usage: 36.6 MB, less than 34.48% of JavaScript online submissions for Distribute Candies to People.\\n```\\nfunction distributeCandies(candies: number, num_people: number): number[] {\\n  const res: number[] = new Array(num_people).fill(0);\\n  let i = 1;\\n  while (candies > 0) {\\n    res[(i - 1) % num_people] += Math.min(i, candies);\\n    candies -= i;\\n    i++;\\n  }\\n  return res;\\n}\\n```\\n\\n// Generating an array with the distributions\\n// Runtime: 72 ms, faster than 68.10% of JavaScript online submissions for Distribute Candies to People.\\n// Memory Usage: 38.1 MB, less than 5.17% of JavaScript online submissions for Distribute Candies to People.\\n```\\nfunction distributeCandies(candies: number, num_people: number): number[] {\\n  const distributions: number[] = [];\\n  let x = 1;\\n  while (candies > 0) {\\n    if (candies >= x) {\\n      candies -= x;\\n      distributions.push(x);\\n    } else {\\n      distributions.push(candies);\\n      candies = 0;\\n    }\\n    x++;\\n  }\\n\\n  const res = new Array(num_people).fill(0);\\n\\n  for (let i = 0; i < num_people; i++) {\\n    for (let j = i; j < distributions.length; j += num_people) {\\n      res[i] += distributions[j];\\n    }\\n  }\\n\\n  return res;\\n}\\n```\\nMore leetcode TypeScript solutions at https://github.com/eddyhdzg/leetcode-typescript-solutions\\n",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction distributeCandies(candies: number, num_people: number): number[] {\\n  const res: number[] = new Array(num_people).fill(0);\\n  let i = 1;\\n  while (candies > 0) {\\n    res[(i - 1) % num_people] += Math.min(i, candies);\\n    candies -= i;\\n    i++;\\n  }\\n  return res;\\n}\\n```\n```\\nfunction distributeCandies(candies: number, num_people: number): number[] {\\n  const distributions: number[] = [];\\n  let x = 1;\\n  while (candies > 0) {\\n    if (candies >= x) {\\n      candies -= x;\\n      distributions.push(x);\\n    } else {\\n      distributions.push(candies);\\n      candies = 0;\\n    }\\n    x++;\\n  }\\n\\n  const res = new Array(num_people).fill(0);\\n\\n  for (let i = 0; i < num_people; i++) {\\n    for (let j = i; j < distributions.length; j += num_people) {\\n      res[i] += distributions[j];\\n    }\\n  }\\n\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 796562,
                "title": "java-think-like-a-human-easy-to-understand-with-explanation-pseudocode",
                "content": "## Analysis\\nThe basic idea is, every time, the number of candies we should distribute is incremented by 1. If we have enough candies, just give him the number he deserved. However, when we give him all we left. \\n\\nIt\\'s simply the same as what we human  deal with this prob.\\n## Explanation\\n- When we have adequate candies to distribute (in the while-loop)\\n\\t- Distribute normally\\n\\t\\t- `thisPpl` gets `thisPplGet` candies\\n\\t\\t- Find out how many candies were distributed in total\\n\\t\\t- Next people = `nextPpl()`\\n\\t\\t- Increment `thisPplGet` by 1\\n- If we don\\'t have enough candies fot `thisPpl`\\n\\t- Give him all we left, aka `candies - curDistributedTotal` candies\\n\\n```Java\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] res = new int[num_people];\\n        int curDistributedTotal = 0;\\n        int thisPplGet = 1;\\n        int thisPpl = 0;\\n        while(candies - curDistributedTotal >= thisPplGet) {\\n            res[thisPpl] += thisPplGet;\\n            curDistributedTotal += thisPplGet;\\n            thisPpl = nextPpl(num_people, thisPpl);\\n            thisPplGet += 1;\\n        }\\n        res[thisPpl] += candies - curDistributedTotal;\\n        return res;\\n    }\\n    \\n    private static int nextPpl(int num_people, int thisPpl) {\\n        if (thisPpl == num_people - 1) return 0;\\n        return thisPpl + 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Java\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] res = new int[num_people];\\n        int curDistributedTotal = 0;\\n        int thisPplGet = 1;\\n        int thisPpl = 0;\\n        while(candies - curDistributedTotal >= thisPplGet) {\\n            res[thisPpl] += thisPplGet;\\n            curDistributedTotal += thisPplGet;\\n            thisPpl = nextPpl(num_people, thisPpl);\\n            thisPplGet += 1;\\n        }\\n        res[thisPpl] += candies - curDistributedTotal;\\n        return res;\\n    }\\n    \\n    private static int nextPpl(int num_people, int thisPpl) {\\n        if (thisPpl == num_people - 1) return 0;\\n        return thisPpl + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796485,
                "title": "c-simple-clear-solution-100-faster-with-explanations",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) \\n    {\\n        vector<int> candiesDistributed(num_people, 0);\\n        int i = 0;\\n        \\n        //while there are still candies to give out\\n        while (candies > 0) \\n        {\\n            //give every person according to his turn (incremented by one every turn)\\n            candiesDistributed[i % num_people] += i + 1;\\n            //update number of candies left\\n            candies -= i + 1;\\n            i++;\\n        }\\n        \\n        //incase we gave an extra candy to last person (so if there are less than 0 candies left we decrement last person\\'s candies otherwise candies = 0 so nothing changes)\\n        candiesDistributed[(i - 1) % num_people] += candies;\\n        \\n        \\n        return candiesDistributed;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) \\n    {\\n        vector<int> candiesDistributed(num_people, 0);\\n        int i = 0;\\n        \\n        //while there are still candies to give out\\n        while (candies > 0) \\n        {\\n            //give every person according to his turn (incremented by one every turn)\\n            candiesDistributed[i % num_people] += i + 1;\\n            //update number of candies left\\n            candies -= i + 1;\\n            i++;\\n        }\\n        \\n        //incase we gave an extra candy to last person (so if there are less than 0 candies left we decrement last person\\'s candies otherwise candies = 0 so nothing changes)\\n        candiesDistributed[(i - 1) % num_people] += candies;\\n        \\n        \\n        return candiesDistributed;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796407,
                "title": "java-1ms-exactly-as-defined-in-problem-statement",
                "content": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int count = candies;\\n        int[] result = new int[num_people];\\n        int index = 0;\\n        int i = 1;\\n        while(count != 0){\\n            if(i > count){\\n                result[index] += count;\\n                count = 0;\\n            } else{\\n                result[index] += i;\\n                count -= i;\\n            }\\n            \\n            ++i;\\n            index = (index + 1) % num_people;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int count = candies;\\n        int[] result = new int[num_people];\\n        int index = 0;\\n        int i = 1;\\n        while(count != 0){\\n            if(i > count){\\n                result[index] += count;\\n                count = 0;\\n            } else{\\n                result[index] += i;\\n                count -= i;\\n            }\\n            \\n            ++i;\\n            index = (index + 1) % num_people;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 752712,
                "title": "c-100-fast",
                "content": "```\\n vector<int> v(num_people,0);\\n        int i=0;\\n        \\n        while(candies  > 0){\\n            \\n            v[i%num_people] += min(candies , i+1);\\n            candies -= i+1;\\n                \\n            i++;\\n        }\\n        \\n        return v;\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\n vector<int> v(num_people,0);\\n        int i=0;\\n        \\n        while(candies  > 0){\\n            \\n            v[i%num_people] += min(candies , i+1);\\n            candies -= i+1;\\n                \\n            i++;\\n        }\\n        \\n        return v;\\n\\t\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 749184,
                "title": "java-0ms-beats-100-math-with-explanation",
                "content": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int sum = (num_people + 1) * num_people / 2;\\n        int k = -1;\\n        int consume = 0;\\n        while (consume < candies) {\\n            k += 1;\\n            consume += k * num_people * num_people + sum;\\n        }\\n        k -= 1;\\n        int[] res = new int[num_people];\\n        int total_candies = candies;\\n        for (int i=1; i<=num_people; i++) {\\n            res[i-1] = (k + 1) * i + k * (k + 1) * num_people / 2;\\n            total_candies -= res[i-1];\\n        }\\n        int idx = 0;\\n        while (total_candies > 0) {\\n            int got = Math.min((k + 1) * num_people + idx + 1, total_candies);\\n            res[idx] += got;\\n            total_candies -= got;\\n            idx ++;\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nExplanation here:\\nSuppose we can write down the distribution in every round (number n people from 1 to n):\\n```\\n(P for person)\\nP1         P2        P3  ...  Pn\\n-----------------------------------\\n  1         2         3  ...   n\\nn+1       n+2       n+3      n+n\\n2n+1     2n+2      2n+3     2n+n\\n...\\nkn+1     kn+2      kn+3     kn+n\\n(k+1)n +1 ...  (k+1)n +j\\n```\\nHere `k` is the second last round, and we end in `k+1`th round at position `j` (j <= n).\\nSo How many candies does the 1st position get?\\nIt\\'s :\\n```\\nin previous round 0~k\\n(1) + (n + 1) + (2n+1) + ... (kn+1) \\n= (1 + n + 1 + 2n+1 + ... kn+1) \\n= k*(k+1)/2 *n + n * 1\\n\\ndon\\'t forget the last round, it\\'s:\\n(k+1)n +1\\n``` \\nFor other positions you can get similar results. And also you can calculate how many candies you need in each round, it\\'s:\\n```\\n(kn+1) + (kn+2) + ... (kn+n)\\n= k*n*n + (1 + 2 + .. n)\\n= k*n*n+n*(n+1)/2\\n```\\nfor round `k`.\\n\\nThen you can find `k`.\\nSo basically that\\'s all, I found `k` in my code at beginning. After that, I first add all round `0~k` in one loop and add the last round finally.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int sum = (num_people + 1) * num_people / 2;\\n        int k = -1;\\n        int consume = 0;\\n        while (consume < candies) {\\n            k += 1;\\n            consume += k * num_people * num_people + sum;\\n        }\\n        k -= 1;\\n        int[] res = new int[num_people];\\n        int total_candies = candies;\\n        for (int i=1; i<=num_people; i++) {\\n            res[i-1] = (k + 1) * i + k * (k + 1) * num_people / 2;\\n            total_candies -= res[i-1];\\n        }\\n        int idx = 0;\\n        while (total_candies > 0) {\\n            int got = Math.min((k + 1) * num_people + idx + 1, total_candies);\\n            res[idx] += got;\\n            total_candies -= got;\\n            idx ++;\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\n(P for person)\\nP1         P2        P3  ...  Pn\\n-----------------------------------\\n  1         2         3  ...   n\\nn+1       n+2       n+3      n+n\\n2n+1     2n+2      2n+3     2n+n\\n...\\nkn+1     kn+2      kn+3     kn+n\\n(k+1)n +1 ...  (k+1)n +j\\n```\n```\\nin previous round 0~k\\n(1) + (n + 1) + (2n+1) + ... (kn+1) \\n= (1 + n + 1 + 2n+1 + ... kn+1) \\n= k*(k+1)/2 *n + n * 1\\n\\ndon\\'t forget the last round, it\\'s:\\n(k+1)n +1\\n```\n```\\n(kn+1) + (kn+2) + ... (kn+n)\\n= k*n*n + (1 + 2 + .. n)\\n= k*n*n+n*(n+1)/2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 712708,
                "title": "java-clean-code-solution-1-ms-time-90-faster",
                "content": "```\\nclass Solution {\\n\\t\\n\\tpublic int[] distributeCandies (int candies, int num_people) {\\n \\n\\t\\tint[] ans = new int[num_people];\\n\\t\\t\\n\\t\\tfor (int i = 0, k = 0; candies != 0; i++) {\\n\\t\\t\\tif (k >= candies) {\\n\\t\\t\\t\\tans[i % num_people] += candies;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tans[i % num_people] += ++k;\\n\\t\\t\\tcandies -= k;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn ans;\\n\\t}\\n}\\n \\nTime Complexity: O(N) \\nwhere N = Number of Candies\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\t\\n\\tpublic int[] distributeCandies (int candies, int num_people) {\\n \\n\\t\\tint[] ans = new int[num_people];\\n\\t\\t\\n\\t\\tfor (int i = 0, k = 0; candies != 0; i++) {\\n\\t\\t\\tif (k >= candies) {\\n\\t\\t\\t\\tans[i % num_people] += candies;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tans[i % num_people] += ++k;\\n\\t\\t\\tcandies -= k;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn ans;\\n\\t}\\n}\\n \\nTime Complexity: O(N) \\nwhere N = Number of Candies\\n```",
                "codeTag": "Java"
            },
            {
                "id": 527087,
                "title": "java",
                "content": "```\\npublic int[] distributeCandies(int candies, int num_people) {\\n        int[] res = new int[num_people];\\n        \\n        int turn = 1;\\n        int index = 0;\\n        while(candies != 0)\\n        {\\n            int candiesToGive = Math.min(candies,turn++);\\n            res[index++%num_people] += candiesToGive;\\n            candies -= candiesToGive;\\n        }\\n        \\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic int[] distributeCandies(int candies, int num_people) {\\n        int[] res = new int[num_people];\\n        \\n        int turn = 1;\\n        int index = 0;\\n        while(candies != 0)\\n        {\\n            int candiesToGive = Math.min(candies,turn++);\\n            res[index++%num_people] += candiesToGive;\\n            candies -= candiesToGive;\\n        }\\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 502605,
                "title": "javascript-solution-48ms",
                "content": "```\\n/**\\n * @param {number} candies\\n * @param {number} num_people\\n * @return {number[]}\\n */\\nvar distributeCandies = function(candies, num_people) {\\n  let arr = new Array(num_people).fill(0);\\n  let countCycle = 0;\\n\\n  for (let i = 0; candies > 0; i++) {\\n    if (i === arr.length) {\\n      i = 0;\\n      countCycle += arr.length;\\n    }\\n    \\n    if (candies < (i + 1) + countCycle) {\\n      arr[i] += candies;\\n      break;\\n    }\\n    \\n    arr[i] += i + 1 + countCycle;\\n    candies -= (i + 1 + countCycle);\\n  }\\n  \\n  return arr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} candies\\n * @param {number} num_people\\n * @return {number[]}\\n */\\nvar distributeCandies = function(candies, num_people) {\\n  let arr = new Array(num_people).fill(0);\\n  let countCycle = 0;\\n\\n  for (let i = 0; candies > 0; i++) {\\n    if (i === arr.length) {\\n      i = 0;\\n      countCycle += arr.length;\\n    }\\n    \\n    if (candies < (i + 1) + countCycle) {\\n      arr[i] += candies;\\n      break;\\n    }\\n    \\n    arr[i] += i + 1 + countCycle;\\n    candies -= (i + 1 + countCycle);\\n  }\\n  \\n  return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 439535,
                "title": "java-mathematical-solution-beats-100-time-and-100-space",
                "content": "The initial while loop in the code can be avoided by solving a quadratic equation which will give you the number of rows where all the n people can get candies.\\n\\n```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int n) {\\n        \\n        int[] ans = new int[n];\\n        int i = 0;\\n        int sum = 0;\\n        \\n        while(true){\\n            int t = ((int)Math.pow(n, 2) * i) + (n * (n + 1))/2;\\n            if(sum + t > candies) break;\\n            sum += t;\\n            i++;\\n        }\\n        \\n        i--;\\n        \\n        for(int j = 0; j < n; j++){\\n            ans[j] = (i + 1) * (j + 1) + (i * n * (i + 1))/2; \\n        }\\n        \\n        i++;\\n        \\n        candies -= sum;\\n        int start = n * i + 1;\\n        int j = 0;\\n        while(candies >= start){\\n            ans[j] += start;\\n            candies -= start;\\n            start++;\\n            j++;\\n        }\\n        \\n        if(candies > 0) ans[j] += candies;\\n        \\n        return ans;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\n    public int[] distributeCandies(int candies, int n) {\\n        \\n        int[] ans = new int[n];\\n        int i = 0;\\n        int sum = 0;\\n        \\n        while(true){\\n            int t = ((int)Math.pow(n, 2) * i) + (n * (n + 1))/2;\\n            if(sum + t > candies) break;\\n            sum += t;\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 435169,
                "title": "java-0ms-100-solution-with-comments",
                "content": "Lets say we have x people, then distribution will look like:\\n1         2         3         4          ... x            total amount of candies is sum from 1 to x\\n1 + x   2 + x   3 + x   4 + x   ... x + x     \\n1 + 2x 2 + 2x 3 + 2x 4 + 2x ... x + 2x\\neach next round we are giving same amount of candies, from 1 to x, but + amount of candies we gave to last person in previous round, which is x for 1st round, which is equal to people amount. So we are giving addiotionally num_people candies num_people times comparing to previous round. It means we can cound how many candies we will distribute during full rounds!\\n\\n```class Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] result = new int[num_people];\\n        int amount = num_people * (num_people + 1) / 2; // sum from 1 to num_people, amount of candies for 1st round\\n        int rounds = 0;\\n        //counting rounds and amount of candies which left after all full rounds\\n        while(candies >= amount) {\\n            rounds++;\\n            candies -= amount;\\n            amount += num_people * num_people; //increase amount of candies, required for next round\\n        }\\n        \\n        for(int i = 0; i < num_people; i++) {\\n\\t\\t\\t//counting amount of candies, distributed to i-th person during full rounds. Lets say we have 4 rounds for 4 people. \\n\\t\\t\\t//1st will get 1 + 5 + 9 + 13, 2nd 2 + 6 + 10 + 14 and so on.\\n\\t\\t\\t//So its sum of N (which is rounds amount) numbers, statring from person number (i + 1) with step = num_people\\n\\t\\t\\t//Formula is  (2 * 1st + step * (N - 1) ) * N / 2\\n            result[i] = (2 * i + 2 + num_people * (rounds - 1)) * rounds / 2; \\n\\t\\t\\t\\n\\t\\t\\t//if we have more candies - counting how many we need to give to current person and taking this amount from candies \\n\\t\\t\\t//or all candies if we have not enough left\\n            if(candies > 0) {\\n                int n = 1 + i + num_people * rounds;\\n                n = candies < n ? candies : n;\\n                result[i] += n;\\n                candies -= n;\\n            }\\n        }\\n        return result;\\n    }\\n}```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```class Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] result = new int[num_people];\\n        int amount = num_people * (num_people + 1) / 2; // sum from 1 to num_people, amount of candies for 1st round\\n        int rounds = 0;\\n        //counting rounds and amount of candies which left after all full rounds\\n        while(candies >= amount) {\\n            rounds++;\\n            candies -= amount;\\n            amount += num_people * num_people; //increase amount of candies, required for next round\\n        }\\n        \\n        for(int i = 0; i < num_people; i++) {\\n\\t\\t\\t//counting amount of candies, distributed to i-th person during full rounds. Lets say we have 4 rounds for 4 people. \\n\\t\\t\\t//1st will get 1 + 5 + 9 + 13, 2nd 2 + 6 + 10 + 14 and so on.\\n\\t\\t\\t//So its sum of N (which is rounds amount) numbers, statring from person number (i + 1) with step = num_people\\n\\t\\t\\t//Formula is  (2 * 1st + step * (N - 1) ) * N / 2\\n            result[i] = (2 * i + 2 + num_people * (rounds - 1)) * rounds / 2; \\n\\t\\t\\t\\n\\t\\t\\t//if we have more candies - counting how many we need to give to current person and taking this amount from candies \\n\\t\\t\\t//or all candies if we have not enough left\\n            if(candies > 0) {\\n                int n = 1 + i + num_people * rounds;\\n                n = candies < n ? candies : n;\\n                result[i] += n;\\n                candies -= n;\\n            }\\n        }\\n        return result;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 431245,
                "title": "python3-simple-solution-no-modulo-beats-91",
                "content": "```class Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        distribution = num_people * [0]\\n        index = 0\\n        increment = 0\\n        \\n        while candies > 0:\\n            take_away = min(candies, increment + 1)\\n            \\n            distribution[index] += take_away\\n            \\n            candies -= take_away\\n            increment += 1\\n            index += 1\\n            \\n            if index == num_people:\\n                index = 0\\n        \\n        return distribution\\n```",
                "solutionTags": [],
                "code": "```class Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        distribution = num_people * [0]\\n        index = 0\\n        increment = 0\\n        \\n        while candies > 0:\\n            take_away = min(candies, increment + 1)\\n            \\n            distribution[index] += take_away\\n            \\n            candies -= take_away\\n            increment += 1\\n            index += 1\\n            \\n            if index == num_people:\\n                index = 0\\n        \\n        return distribution\\n```",
                "codeTag": "Java"
            },
            {
                "id": 416033,
                "title": "python3-3-solution-3-lines-99-16",
                "content": "**Method 1** A simulation-based solution is as below (21.55%), in which we assign candies to people according to the rule given by the problem and stop when we run out of candies. \\n```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        ans = [0]*num_people\\n        i = 0\\n        while candies > 0: \\n            i += 1\\n            ans[(i-1)%num_people] += min(i, candies)\\n            candies -= i\\n        return ans \\n```\\n**Method 2** The above simulation can be implemented in a more Pythonic fashion (3-line & 99.16%)\\n```\\nfrom math import sqrt \\n\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        n = int(0.5*(-1 + sqrt(1 + 8*candies)))\\n        numbers = list(range(1, n+1)) + [candies - n*(n+1)//2]\\n        return [sum(numbers[i::num_people]) for i in range(num_people)]\\n```\\n**Method 3** Mathematics (95.99%). Given number of candies and people, one can compute mathematically how many candies are assigned to each people. \\n```\\nfrom math import sqrt \\n\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        k = int(0.5*(-1 + sqrt(1 + 8*candies))) #length of arithmetic series\\n        m, n = divmod(k, num_people)\\n        \\n        ans = [0]*num_people \\n        for i in range(num_people):\\n            if i == n: m -= 1\\n            ans[i] = (m+1)*(i+1) + m*(m+1)*num_people//2\\n        ans[n] += candies - k*(k+1)//2\\n        return ans \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        ans = [0]*num_people\\n        i = 0\\n        while candies > 0: \\n            i += 1\\n            ans[(i-1)%num_people] += min(i, candies)\\n            candies -= i\\n        return ans \\n```\n```\\nfrom math import sqrt \\n\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        n = int(0.5*(-1 + sqrt(1 + 8*candies)))\\n        numbers = list(range(1, n+1)) + [candies - n*(n+1)//2]\\n        return [sum(numbers[i::num_people]) for i in range(num_people)]\\n```\n```\\nfrom math import sqrt \\n\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        k = int(0.5*(-1 + sqrt(1 + 8*candies))) #length of arithmetic series\\n        m, n = divmod(k, num_people)\\n        \\n        ans = [0]*num_people \\n        for i in range(num_people):\\n            if i == n: m -= 1\\n            ans[i] = (m+1)*(i+1) + m*(m+1)*num_people//2\\n        ans[n] += candies - k*(k+1)//2\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 326992,
                "title": "golang-simple-solution-with-self-explanation-beat-100",
                "content": "```\\nfunc distributeCandies(candies int, num_people int) []int {\\n\\tvar res []int = make([]int,num_people)\\n\\tvar cnt int = 1\\n\\tfor candies > cnt{\\n\\t\\tres[(cnt - 1) % num_people] += cnt\\n\\t\\tcandies -= cnt\\n\\t\\tcnt++\\n\\t}\\n\\tres[(cnt - 1) % num_people] += candies\\n\\treturn res\\n}",
                "solutionTags": [],
                "code": "```\\nfunc distributeCandies(candies int, num_people int) []int {\\n\\tvar res []int = make([]int,num_people)\\n\\tvar cnt int = 1\\n\\tfor candies > cnt{\\n\\t\\tres[(cnt - 1) % num_people] += cnt\\n\\t\\tcandies -= cnt\\n\\t\\tcnt++\\n\\t}\\n\\tres[(cnt - 1) % num_people] += candies\\n\\treturn res\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 325281,
                "title": "python-8-20ms-math-with-explanation",
                "content": "For each **full round**, we give candies to every person, it consumes:\\nn(n+1)/2 + 0nn *for the 1st round*\\nn(n+1)/2 + 1nn *for the 2nd round*\\nn(n+1)/2 + 2nn *for the 3rd round*\\n...\\nWe first count that for the given candies, how many **full rounds** we can do.\\nThen we do all the **full rounds** at one time:\\nFor the person with index i, it consumes:\\n(i+1 + 0) + (i+1 + n) + ... + (i+1+ (k-1)n) = (i+1)k + k(k-1)n/2\\n\\nAfter this, the candies left are not enough to do another **full round**. Then, we enter the new round with the first person receiving 1 + kn candies.\\nFrom here, we just distribute  i+1 + kn candies to person with index i when we have enough candies.\\n\\n```\\nclass Solution(object):\\n    def distributeCandies(self, candies, n):\\n        k, s, res = 0, 0, [0 for x in range(n)]\\n\\t\\t# count how many full rounds we can do\\n        while s + n*(n+1)/2 + k*n*n < candies:\\n            s += n*(n+1)/2 + k*n*n\\n            k += 1\\n\\t\\t# do all full rounds at one time\\n        if k > 0:\\n            for i in range(len(res)):\\n                res[i] = (i+1)*k + k*(k-1)*n/2\\n                candies -= res[i]\\n        i = 0\\n\\t\\t# distribute the candies left\\n        while candies > 0:\\n            if candies > i+1 + k*n:\\n                res[i] += i+1 + k*n\\n                candies -= i+1 + k*n\\n            else:\\n                res[i] += candies\\n                break\\n            i += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def distributeCandies(self, candies, n):\\n        k, s, res = 0, 0, [0 for x in range(n)]\\n\\t\\t# count how many full rounds we can do\\n        while s + n*(n+1)/2 + k*n*n < candies:\\n            s += n*(n+1)/2 + k*n*n\\n            k += 1\\n\\t\\t# do all full rounds at one time\\n        if k > 0:\\n            for i in range(len(res)):\\n                res[i] = (i+1)*k + k*(k-1)*n/2\\n                candies -= res[i]\\n        i = 0\\n\\t\\t# distribute the candies left\\n        while candies > 0:\\n            if candies > i+1 + k*n:\\n                res[i] += i+1 + k*n\\n                candies -= i+1 + k*n\\n            else:\\n                res[i] += candies\\n                break\\n            i += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 324809,
                "title": "java-1ms-solution",
                "content": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[]res=new int[num_people];\\n        int c=1;\\n        while (candies>0){\\n            for (int i=0;i<num_people;i++)\\n            {\\n                if (candies<c){\\n                    res[i]+=candies;\\n                    return res;\\n                } else {\\n\\t\\t\\t\\t\\tres[i]+=candies>c?c:candies;\\n\\t\\t\\t\\t\\tcandies-=c;\\n\\t\\t\\t\\t\\tc++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[]res=new int[num_people];\\n        int c=1;\\n        while (candies>0){\\n            for (int i=0;i<num_people;i++)\\n            {\\n                if (candies<c){\\n                    res[i]+=candies;\\n                    return res;\\n                } else {\\n\\t\\t\\t\\t\\tres[i]+=candies>c?c:candies;\\n\\t\\t\\t\\t\\tcandies-=c;\\n\\t\\t\\t\\t\\tc++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 324250,
                "title": "fastest-math-solution-in-python-o-num-people",
                "content": "1. Find the smallest `n` such that `n * (n + 1) / 2 >= candles`\\n2. Find how many rounds we need to loop through num_people\\n3. Find out what\\'s the last index to fill\\n4. Fill into the result array according to the rounds and start index\\n\\nReference: https://en.wikipedia.org/wiki/Arithmetic_progression#Sum\\n\\n```\\ndef distributeCandies(self, candies, num_people):\\n        res = [0] * num_people\\n\\t\\t\\n\\t\\t# Find the smallest n\\n        n = math.floor(math.sqrt(candies * 2))\\n        if n * (n + 1) < candies * 2:\\n            n += 1\\n\\t\\t\\n\\t\\t# How many rounds we need to loop through num_people\\n        if n % num_people == 0:\\n            rounds = n // num_people \\n        else:\\n            rounds = n // num_people + 1\\n\\t\\t\\n\\t\\t# The last index to fill\\n        last = int(n % num_people - 1)\\n        edge = last\\n        if edge < 0:\\n            edge += num_people\\n\\t\\t\\n        for i in range(edge):\\n            res[i] = int((2*i + 2 + num_people * rounds - num_people) * rounds / 2\\n            candies -= res[i]\\n        for i in range(edge + 1, len(res)):\\n            res[i] = int((2*i + 2 + num_people * (rounds - 1) - num_people) * (rounds - 1) / 2)\\n            candies -= res[i]\\n        res[last] = candies\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\ndef distributeCandies(self, candies, num_people):\\n        res = [0] * num_people\\n\\t\\t\\n\\t\\t# Find the smallest n\\n        n = math.floor(math.sqrt(candies * 2))\\n        if n * (n + 1) < candies * 2:\\n            n += 1\\n\\t\\t\\n\\t\\t# How many rounds we need to loop through num_people\\n        if n % num_people == 0:\\n            rounds = n // num_people \\n        else:\\n            rounds = n // num_people + 1\\n\\t\\t\\n\\t\\t# The last index to fill\\n        last = int(n % num_people - 1)\\n        edge = last\\n        if edge < 0:\\n            edge += num_people\\n\\t\\t\\n        for i in range(edge):\\n            res[i] = int((2*i + 2 + num_people * rounds - num_people) * rounds / 2\\n            candies -= res[i]\\n        for i in range(edge + 1, len(res)):\\n            res[i] = int((2*i + 2 + num_people * (rounds - 1) - num_people) * (rounds - 1) / 2)\\n            candies -= res[i]\\n        res[last] = candies\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 323409,
                "title": "javascript-python3-c-brute-force",
                "content": "**Synopsis:**\\n\\nLet `candy` be a monotonically increasing value, starting at `1` which denotes the maximum amount of candies we can currently take.  Take `candy` until all `k` candies have been exhausted.\\n\\n---\\n\\n*Javascript*\\n```\\nlet distributeCandies = (k, N, candy = 0) => {\\n    let ans = Array(N).fill(0);\\n    while (k) {\\n        for (let i = 0; i < N; ++i) {\\n            let take = Math.min(++candy, k);  // \\u2B50\\uFE0F take candy (not exceeding available k candies)\\n            ans[i] += take, k -= take;\\n        }\\n    }\\n    return ans;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def distributeCandies(self, k: int, N: int, candy = 1) -> List[int]:\\n        ans = [0] * N\\n        while k:\\n            for i in range(N):\\n                take = min(candy, k)  # \\u2B50\\uFE0F take candy (not exceeding available k candies)\\n                ans[i] += take\\n                k -= take\\n                candy += 1\\n        return ans\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector< int >;\\n    VI distributeCandies(int k, int N, int candy = 0){\\n        VI ans(N);\\n        while (k) {\\n            for (auto i{ 0 }; i < N; ++i) {\\n                auto take = min(++candy, k);  // \\u2B50\\uFE0F take candy (not exceeding available k candies)\\n                ans[i] += take, k -= take;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nlet distributeCandies = (k, N, candy = 0) => {\\n    let ans = Array(N).fill(0);\\n    while (k) {\\n        for (let i = 0; i < N; ++i) {\\n            let take = Math.min(++candy, k);  // \\u2B50\\uFE0F take candy (not exceeding available k candies)\\n            ans[i] += take, k -= take;\\n        }\\n    }\\n    return ans;\\n};\\n```\n```\\nclass Solution:\\n    def distributeCandies(self, k: int, N: int, candy = 1) -> List[int]:\\n        ans = [0] * N\\n        while k:\\n            for i in range(N):\\n                take = min(candy, k)  # \\u2B50\\uFE0F take candy (not exceeding available k candies)\\n                ans[i] += take\\n                k -= take\\n                candy += 1\\n        return ans\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector< int >;\\n    VI distributeCandies(int k, int N, int candy = 0){\\n        VI ans(N);\\n        while (k) {\\n            for (auto i{ 0 }; i < N; ++i) {\\n                auto take = min(++candy, k);  // \\u2B50\\uFE0F take candy (not exceeding available k candies)\\n                ans[i] += take, k -= take;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323313,
                "title": "c-brute-force-just-as-the-logic-asks-for-it",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int n) {\\n        vector<int> res(n, 0);\\n        int loop = 0; //use a loop variable to track the number of times it comes back to start\\n        while(candies > 0){\\n            for(int i=0; i<n; i++){\\n                int toGive = i+1 + loop*n;\\n                if(candies < toGive){\\n\\t\\t\\t\\t\\t// if not enough candies left then assign all of them to current person\\n                    res[i] += candies;\\n                    candies = 0;\\n                    break;\\n                }else{\\n                    res[i] += toGive;\\n                    candies -= toGive;\\n                }\\n            }\\n            loop++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int n) {\\n        vector<int> res(n, 0);\\n        int loop = 0; //use a loop variable to track the number of times it comes back to start\\n        while(candies > 0){\\n            for(int i=0; i<n; i++){\\n                int toGive = i+1 + loop*n;\\n                if(candies < toGive){\\n\\t\\t\\t\\t\\t// if not enough candies left then assign all of them to current person\\n                    res[i] += candies;\\n                    candies = 0;\\n                    break;\\n                }else{\\n                    res[i] += toGive;\\n                    candies -= toGive;\\n                }\\n            }\\n            loop++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773226,
                "title": "faster-than-100-beats-java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int k) {\\n        int ary[]=new int[k];\\n        int val=1;\\n        int indexstore=0;\\n        int sum=0;\\n        int count=0;\\n  while(candies>0) // Travels ary Untile Your canie not finish\\n  {\\n      for(int i=0;i<k;i++)\\n      {\\n          candies-=val;\\n          if(candies>=0)\\n          {\\n          ary[i]+=val;\\n          if(candies==0) // If your candi finish stop and break loop\\n          {\\n              break;\\n\\n          }\\n          }\\n          else\\n          {\\n              ary[i]+=val+candies;\\n              indexstore=i;\\n              break;\\n          }\\n          val++;\\n      }\\n      count++;\\n  }\\n  if(indexstore!=0 && indexstore!=k-1 && count==0) // when your candi finish but pepole who have not even one canie give them o candie\\n  {\\n        for (int i = indexstore; i < k; i++) {\\n                ary[i] = 0;\\n            }\\n  }\\n  return ary;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int k) {\\n        int ary[]=new int[k];\\n        int val=1;\\n        int indexstore=0;\\n        int sum=0;\\n        int count=0;\\n  while(candies>0) // Travels ary Untile Your canie not finish\\n  {\\n      for(int i=0;i<k;i++)\\n      {\\n          candies-=val;\\n          if(candies>=0)\\n          {\\n          ary[i]+=val;\\n          if(candies==0) // If your candi finish stop and break loop\\n          {\\n              break;\\n\\n          }\\n          }\\n          else\\n          {\\n              ary[i]+=val+candies;\\n              indexstore=i;\\n              break;\\n          }\\n          val++;\\n      }\\n      count++;\\n  }\\n  if(indexstore!=0 && indexstore!=k-1 && count==0) // when your candi finish but pepole who have not even one canie give them o candie\\n  {\\n        for (int i = indexstore; i < k; i++) {\\n                ary[i] = 0;\\n            }\\n  }\\n  return ary;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3439758,
                "title": "c-for-dumbs-100-faster",
                "content": "\\n\\n# Approach\\nInitially the program only wants to give some candy to each person, the website would inform the number of candiess to distribute and the number of people.\\n\\nIn the initial distribution the first person should receive only one candy, the second person should receive one more than the first one and after all the people have earned the candies, it would start another distribution loop in the same way until there is no more candies.\\n\\nThe last person would only receive all the candy avaliable in case there is no candy necessary to fulfill the formula. **n+1**\\n\\nin my solution the distributions will happen until there is no more candies\\n```\\nwhile(candies != 0){\\n        for(int i = 0; i < num_people;  i++){\\n            if(candies < y){\\n                y =  candies;\\n            }\\n            res[i] = res[i] + y;\\n            candies = candies - y;\\n            y++;\\n        }\\n```\\n**y** represents the number of candies to each pearson that would increase aways by one, in this way the number of candies will always  decrease too by **y** to analyse how many candies remain. And if there is no more candies to fulfill the formula, the last person will receive all the rest of the candies.\\n\\n**res**[0] represents the number of candies that the first person would receive and candies represents the total of cadies that remain to be destributed.\\n\\n**If you like please upvote**\\n\\n# Code\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\n#include <stdlib.h>\\n#include <stdio.h>\\nint* distributeCandies(int candies, int num_people, int* returnSize){\\n    *returnSize = num_people;\\n    int x[num_people];\\n    int y = 1;\\n    int *res=(int*)calloc(num_people,sizeof(int));\\n    while(candies != 0){\\n        for(int i = 0; i < num_people;  i++){\\n            if(candies < y){\\n                y =  candies;\\n            }\\n            res[i] = res[i] + y;\\n            candies = candies - y;\\n            y++;\\n        }\\n    }\\n    return res;\\n}\\n```\\n",
                "solutionTags": [
                    "C",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\nwhile(candies != 0){\\n        for(int i = 0; i < num_people;  i++){\\n            if(candies < y){\\n                y =  candies;\\n            }\\n            res[i] = res[i] + y;\\n            candies = candies - y;\\n            y++;\\n        }\\n```\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\n#include <stdlib.h>\\n#include <stdio.h>\\nint* distributeCandies(int candies, int num_people, int* returnSize){\\n    *returnSize = num_people;\\n    int x[num_people];\\n    int y = 1;\\n    int *res=(int*)calloc(num_people,sizeof(int));\\n    while(candies != 0){\\n        for(int i = 0; i < num_people;  i++){\\n            if(candies < y){\\n                y =  candies;\\n            }\\n            res[i] = res[i] + y;\\n            candies = candies - y;\\n            y++;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3159155,
                "title": "python3-easy-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        lis,i=num_people*[0],1\\n        while candies>=i:\\n            lis[(i-1)%num_people]+=i\\n            candies-=i\\n            i+=1\\n        if candies>0:    \\n            lis[(i-1)%num_people]+=candies\\n        return lis\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        lis,i=num_people*[0],1\\n        while candies>=i:\\n            lis[(i-1)%num_people]+=i\\n            candies-=i\\n            i+=1\\n        if candies>0:    \\n            lis[(i-1)%num_people]+=candies\\n        return lis\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3001605,
                "title": "python-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        arr = [0 for i in range(num_people)]\\n        i = 0\\n        j = 1\\n        while candies > 0:\\n            if i == len(arr):\\n                i = 0\\n            if candies >= j:\\n                arr[i] += j\\n                candies -= j\\n                j += 1\\n            else:\\n                arr[i] += candies\\n                break\\n            i += 1\\n        return arr\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        arr = [0 for i in range(num_people)]\\n        i = 0\\n        j = 1\\n        while candies > 0:\\n            if i == len(arr):\\n                i = 0\\n            if candies >= j:\\n                arr[i] += j\\n                candies -= j\\n                j += 1\\n            else:\\n                arr[i] += candies\\n                break\\n            i += 1\\n        return arr\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885846,
                "title": "java-runtime-1-ms-beats-97-31-memory-39-9-mb-beats-91-94",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] rs = new int[num_people];\\n        int index = 1;\\n        while (candies > 0) {\\n            for (int i = 0; i < num_people; i++) {\\n                if (candies == 0) break;\\n                index = candies > index ? index : candies;\\n                rs[i] += index;\\n                candies -= index++;\\n            }\\n        }\\n\\n        return rs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] rs = new int[num_people];\\n        int index = 1;\\n        while (candies > 0) {\\n            for (int i = 0; i < num_people; i++) {\\n                if (candies == 0) break;\\n                index = candies > index ? index : candies;\\n                rs[i] += index;\\n                candies -= index++;\\n            }\\n        }\\n\\n        return rs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2848458,
                "title": "java-code-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] arr = new int[num_people];\\n        \\n        int currCandyCount = 1;\\n        \\n        while(candies > 0) {\\n            for(int i = 0; i<num_people; i++) {\\n                if(candies >= currCandyCount) { // check if we have enough candies to distribute next\\n                    arr[i]+= currCandyCount;\\n                    candies -=currCandyCount;\\n                    currCandyCount++;\\n                } else { // we don\\'t have enough candies to distribute\\n                    arr[i] += candies; // distribute whatever is remaining\\n                    candies = 0; // set to 0 so it exits the while loop\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] arr = new int[num_people];\\n        \\n        int currCandyCount = 1;\\n        \\n        while(candies > 0) {\\n            for(int i = 0; i<num_people; i++) {\\n                if(candies >= currCandyCount) { // check if we have enough candies to distribute next\\n                    arr[i]+= currCandyCount;\\n                    candies -=currCandyCount;\\n                    currCandyCount++;\\n                } else { // we don\\'t have enough candies to distribute\\n                    arr[i] += candies; // distribute whatever is remaining\\n                    candies = 0; // set to 0 so it exits the while loop\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838299,
                "title": "java-brute-force-solution-explained",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] distributeCandies(int c, int n) {\\n        int[] arr = new int[n];\\n        int idx = 0;\\n        while (c > 0) {\\n            //[idx++ % n] - means that I find index of array to add\\n            //and then increment this index\\n            //Math.min(idx, c) - is used because in the end when we have candies left less than we need to add, then just add minimum number\\n            arr[idx++ % n] += Math.min(idx, c);\\n\\n            //during loop we need to substract given number of candies\\n            //above from all number of candies left\\n            //if this number is negative, then just 0 left.\\n            c = Math.max(c - idx, 0);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int c, int n) {\\n        int[] arr = new int[n];\\n        int idx = 0;\\n        while (c > 0) {\\n            //[idx++ % n] - means that I find index of array to add\\n            //and then increment this index\\n            //Math.min(idx, c) - is used because in the end when we have candies left less than we need to add, then just add minimum number\\n            arr[idx++ % n] += Math.min(idx, c);\\n\\n            //during loop we need to substract given number of candies\\n            //above from all number of candies left\\n            //if this number is negative, then just 0 left.\\n            c = Math.max(c - idx, 0);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780239,
                "title": "java-98-beats-just-one-while",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distributeCandies(int n, int num_people) {\\n        int[] nums = new int[num_people];\\n        int i=0;\\n        int givenCandies=0;\\n        int candies=1;\\n        while(true){\\n            if(i==num_people) i=0;\\n            if(givenCandies+candies<=n){\\n                nums[i++]+=candies++;\\n                givenCandies+=candies-1;\\n            }else{\\n                nums[i]+=n-givenCandies;\\n                break;\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int n, int num_people) {\\n        int[] nums = new int[num_people];\\n        int i=0;\\n        int givenCandies=0;\\n        int candies=1;\\n        while(true){\\n            if(i==num_people) i=0;\\n            if(givenCandies+candies<=n){\\n                nums[i++]+=candies++;\\n                givenCandies+=candies-1;\\n            }else{\\n                nums[i]+=n-givenCandies;\\n                break;\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2378857,
                "title": "java-faster-than-98-users",
                "content": "```\\nint ans[]=new int[people];\\n        int curr=1;\\n        int rem=candies;\\n        while(rem>0){\\n            for(int i=0;i<people;i=(i+1)%people){\\n                if(rem<=curr){\\n                    ans[i]+=rem;\\n                    rem=0;\\n                    break;\\n                }\\n                else{\\n                    ans[i]+=curr;\\n                    rem=rem-curr;\\n                    curr++;\\n                }\\n            }\\n        }\\n        return ans;```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nint ans[]=new int[people];\\n        int curr=1;\\n        int rem=candies;\\n        while(rem>0){\\n            for(int i=0;i<people;i=(i+1)%people){\\n                if(rem<=curr){\\n                    ans[i]+=rem;\\n                    rem=0;\\n                    break;\\n                }\\n                else{\\n                    ans[i]+=curr;\\n                    rem=rem-curr;\\n                    curr++;\\n                }\\n            }\\n        }\\n        return ans;```",
                "codeTag": "Unknown"
            },
            {
                "id": 2217899,
                "title": "c-easy-problem",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> distributeCandies(int t, int np) \\n\\t\\t{\\n\\t\\t\\tvector<int> ans(np,0);\\n\\t\\t\\tint i=1;\\n\\t\\t\\tfor(int j=0;j<np;j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(t<=i)  \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tans[j]+=t;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans[j]+=i;\\n\\t\\t\\t\\tt-=i;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tif(j==np-1) j=-1;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> distributeCandies(int t, int np) \\n\\t\\t{\\n\\t\\t\\tvector<int> ans(np,0);\\n\\t\\t\\tint i=1;\\n\\t\\t\\tfor(int j=0;j<np;j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(t<=i)  \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tans[j]+=t;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2114146,
                "title": "easy-java-2ms",
                "content": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] ans=new int[num_people];\\n        int k=0;\\n        while(candies>0){\\n            ans[k%num_people]+=Math.min(k+1,candies);\\n            candies-=Math.min(k+1,candies);\\n            k++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] ans=new int[num_people];\\n        int k=0;\\n        while(candies>0){\\n            ans[k%num_people]+=Math.min(k+1,candies);\\n            candies-=Math.min(k+1,candies);\\n            k++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2098819,
                "title": "c-0ms-beats-100",
                "content": "```\\nvector<int> distributeCandies(int candies, int num_people) {\\n        vector<int>ans(num_people,0);\\n        int k=0;\\n        while(candies)\\n        {\\n            ans[k%num_people]+=min(k+1,candies);\\n                candies-=min(k+1,candies);\\n            k++;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nvector<int> distributeCandies(int candies, int num_people) {\\n        vector<int>ans(num_people,0);\\n        int k=0;\\n        while(candies)\\n        {\\n            ans[k%num_people]+=min(k+1,candies);\\n                candies-=min(k+1,candies);\\n            k++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2081337,
                "title": "java-solution",
                "content": "```java \\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] a = new int[num_people];\\n        int i=0;\\n        int c=1;\\n        while(candies>0)\\n        {\\n            if(candies>=c)\\n            {\\n                candies-=c;\\n               a[i%a.length]+=c++;\\n            }\\n            else\\n            {\\n                a[i%a.length]+=candies;\\n                candies=0;\\n            }\\n            i++;\\n        }\\n        return a;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] a = new int[num_people];\\n        int i=0;\\n        int c=1;\\n        while(candies>0)\\n        {\\n            if(candies>=c)\\n            {\\n                candies-=c;\\n               a[i%a.length]+=c++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1966144,
                "title": "easy-java-solution-95-faster-easy-understanding-approach",
                "content": "# JAVA Solution | 95% faster | Easy friendly understanding :)\\n1. While we have given less candies than the ones we had at the beginning (`while(total < candies){}`)\\n2. Use `count % num_people == 0` to determine the current index of the people.\\n3. Remeber to leave a like! ;) \\n\\n\\n```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] res = new int[num_people];        //Initialize the array of people\\n        int toGiveCandie = 1, count = 0, total = 0;    \\n        while(total < candies){                 //While the total candies given is fewer than the candies we have...\\n            if(count % num_people == 0){        //This is to \\'reset\\' de counter to 0 when we reach the last person.\\n                count = 0;\\n            }\\n            if(total + toGiveCandie <= candies){  \\n                //If the number of candies we have already given plus the candies we are \\n                // going to give are less or equal than the total candies...\\n                res[count] += toGiveCandie;     //We add the candies to the array (give the candie to the person)\\n                total += toGiveCandie;          //We update the candies we have given\\n                toGiveCandie++;                 //To the next person we will give one more candie\\n            }else{\\n                //If we don\\'t have the enough candies, we just give the candies left\\n                res[count] += candies-total;    \\n                total += candies-total;\\n                toGiveCandie++;\\n            }\\n            count++;\\n        }\\n        return res;                            //We return the filled array\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] res = new int[num_people];        //Initialize the array of people\\n        int toGiveCandie = 1, count = 0, total = 0;    \\n        while(total < candies){                 //While the total candies given is fewer than the candies we have...\\n            if(count % num_people == 0){        //This is to \\'reset\\' de counter to 0 when we reach the last person.\\n                count = 0;\\n            }\\n            if(total + toGiveCandie <= candies){  \\n                //If the number of candies we have already given plus the candies we are \\n                // going to give are less or equal than the total candies...\\n                res[count] += toGiveCandie;     //We add the candies to the array (give the candie to the person)\\n                total += toGiveCandie;          //We update the candies we have given\\n                toGiveCandie++;                 //To the next person we will give one more candie\\n            }else{\\n                //If we don\\'t have the enough candies, we just give the candies left\\n                res[count] += candies-total;    \\n                total += candies-total;\\n                toGiveCandie++;\\n            }\\n            count++;\\n        }\\n        return res;                            //We return the filled array\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1944613,
                "title": "c-simple-solution-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int npeople) {\\n        vector<int>ans(npeople,0);\\n        int i=0,n=1;\\n        while(candies>0){\\n            i = i%npeople;\\n            ans[i]= ans[i]+min(candies,n);\\n            candies-=n;\\n            n++;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int npeople) {\\n        vector<int>ans(npeople,0);\\n        int i=0,n=1;\\n        while(candies>0){\\n            i = i%npeople;\\n            ans[i]= ans[i]+min(candies,n);\\n            candies-=n;\\n            n++;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1896445,
                "title": "python-easy-solution-beginner-friendly",
                "content": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        res = [0] * num_people\\n        dist = 1\\n        pos = 0\\n        while candies > 0:\\n            if pos == num_people:\\n                pos = 0\\n            if candies < dist:\\n                res[pos] += candies\\n                return res\\n            res[pos] += dist\\n            candies -= dist\\n            dist += 1\\n            pos += 1\\n        return res\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        res = [0] * num_people\\n        dist = 1\\n        pos = 0\\n        while candies > 0:\\n            if pos == num_people:\\n                pos = 0\\n            if candies < dist:\\n                res[pos] += candies\\n                return res\\n            res[pos] += dist\\n            candies -= dist\\n            dist += 1\\n            pos += 1\\n        return res\\n",
                "codeTag": "Java"
            },
            {
                "id": 1878038,
                "title": "easier-efficient-javascript-solution",
                "content": "/**\\n * @param {number} candies\\n * @param {number} num_people\\n * @return {number[]}\\n */\\nvar distributeCandies = function(candies, num_people) {\\n    let arr = new Array(num_people).fill(0), j = 1, sum = 1, i = 0;\\n    while (sum < candies) {\\n        i = i%num_people;\\n        arr[i] += j;\\n        i++;\\n        j++;\\n        sum += j;\\n    }\\n\\t//handling last remaining candy\\n    arr[i%num_people] += candies - (sum - j);\\n    return arr;\\n};",
                "solutionTags": [],
                "code": "/**\\n * @param {number} candies\\n * @param {number} num_people\\n * @return {number[]}\\n */\\nvar distributeCandies = function(candies, num_people) {\\n    let arr = new Array(num_people).fill(0), j = 1, sum = 1, i = 0;\\n    while (sum < candies) {\\n        i = i%num_people;\\n        arr[i] += j;\\n        i++;\\n        j++;\\n        sum += j;\\n    }\\n\\t//handling last remaining candy\\n    arr[i%num_people] += candies - (sum - j);\\n    return arr;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1827308,
                "title": "java-3-liner-explained",
                "content": "**Idea:** Keep distributing the candies in increment of 1 until they run out. Wrap around the array using `% numPeople` and take min to avoid giving more candies than left\\n>**T/S:** O(sqrt(candies))/O(numPeople)\\n```\\npublic int[] distributeCandies(int candies, int numPeople) {\\n\\tvar distribution = new int[numPeople];\\n\\tfor (var i = 0; candies > 0; candies -= ++i)\\n\\t\\tdistribution[i % numPeople] += Math.min(candies, i + 1);\\n\\treturn distribution;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] distributeCandies(int candies, int numPeople) {\\n\\tvar distribution = new int[numPeople];\\n\\tfor (var i = 0; candies > 0; candies -= ++i)\\n\\t\\tdistribution[i % numPeople] += Math.min(candies, i + 1);\\n\\treturn distribution;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1807566,
                "title": "c",
                "content": "**4 lines Code\\uD83D\\uDE2E:- \\n\\nstep 1: initalization index i=0, and add = every element adds to the next indexs 1 to n\\n\\nstep 2: iterate while --> cand is not equal to zero.\\n\\nstep  3:  every element is add to evry index by incrementing +1, and remove the elements from cand that are add to an array.\\n\\nstep 4: if iterator \\'i\\'==n them we need  to create circular array from like i=i%n;\\nfor eg: 0,1,2,3,4--->after 4 it again go near index i=0 --> 0,1,2,3,4,0,1,2,3,4.... so on.\\n\\n\\ncode: -\\n\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int cand, int n) {\\n        \\n        int i=0,add=1;\\n        vector<int> arr(n);\\n        while(cand>0){\\n            \\n            arr[i]+=min(add,cand);\\n            cand-=add;\\n            add+=1;\\n            i=(i+1)%n;  \\n        }\\n        return arr;\\n        \\n    }\\n};\\n\\n Thanks please Vote!!\\uD83D\\uDE43\\n",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> distributeCandies(int cand, int n) {\\n        \\n        int i=0,add=1;\\n        vector<int> arr(n);\\n        while(cand>0){\\n            \\n            arr[i]+=min(add,cand);\\n            cand-=add;\\n            add+=1;\\n            i=(i+1)%n;  \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1692289,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector <int> arr;\\n        for(int i=0; i<num_people;i++){\\n            arr.push_back(0);\\n        }\\n        int giv=1,i=0;\\n        while(candies!=0){\\n            if(giv>=candies){\\n                arr[i%num_people]+=candies;\\n                candies=0;\\n            }\\n            else{\\n                arr[i%num_people]+= giv;\\n                candies=candies-giv;\\n                giv=giv+ 1;                \\n            }\\n            i++;\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector <int> arr;\\n        for(int i=0; i<num_people;i++){\\n            arr.push_back(0);\\n        }\\n        int giv=1,i=0;\\n        while(candies!=0){\\n            if(giv>=candies){\\n                arr[i%num_people]+=candies;\\n                candies=0;\\n            }\\n            else{\\n                arr[i%num_people]+= giv;\\n                candies=candies-giv;\\n                giv=giv+ 1;                \\n            }\\n            i++;\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579712,
                "title": "python-3-solution",
                "content": "```python\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        res = [0] * num_people\\n        \\n        i, candy = 0, 1\\n        while candies > 0:\\n            res[i] += min(candies, candy)\\n            candies -= candy\\n            candy += 1\\n            i = (i + 1) % num_people\\n            \\n        return res\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        res = [0] * num_people\\n        \\n        i, candy = 0, 1\\n        while candies > 0:\\n            res[i] += min(candies, candy)\\n            candies -= candy\\n            candy += 1\\n            i = (i + 1) % num_people\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1481631,
                "title": "simple-solution-4-lines-without-break-statements",
                "content": "```\\nvar distributeCandies = function (candies, num_people) {\\n    let people = new Array(num_people).fill(0);\\n    for (let index = 0; candies > 0; index++) {\\n        const res = Math.min(index + 1, candies); // if candies is less take only rem ones\\n        people[index % people.length] += res // rotate array and add value to cureent array index\\n        candies = candies - res; //sub candies\\n    }\\n    return people;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar distributeCandies = function (candies, num_people) {\\n    let people = new Array(num_people).fill(0);\\n    for (let index = 0; candies > 0; index++) {\\n        const res = Math.min(index + 1, candies); // if candies is less take only rem ones\\n        people[index % people.length] += res // rotate array and add value to cureent array index\\n        candies = candies - res; //sub candies\\n    }\\n    return people;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1472818,
                "title": "python-easy-to-understand-code-o-n",
                "content": "**Time: O(N)\\nSpace: O(1)**\\n\\n\\n```\\nres=[0 for i in range (num_people)]\\n        val=1\\n        i=0\\n        while(candies>0):\\n            res[i]+=val\\n            i+=1\\n            candies-=val\\n            val+=1\\n            if i==(num_people):\\n                i=0\\n            if val>candies:\\n                val=candies\\n                res[i]+=val\\n                candies=0\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nres=[0 for i in range (num_people)]\\n        val=1\\n        i=0\\n        while(candies>0):\\n            res[i]+=val\\n            i+=1\\n            candies-=val\\n            val+=1\\n            if i==(num_people):\\n                i=0\\n            if val>candies:\\n                val=candies\\n                res[i]+=val\\n                candies=0\\n        return res\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1387311,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> ret;\\n        int j=1;\\n        for(int i=0;i<num_people;i++) {\\n            if(j<=candies) {\\n                ret.push_back(j);\\n                candies-=j;\\n                j++;\\n            }\\n            else  {\\n                ret.push_back(candies);\\n                candies=0;\\n            }\\n        }\\n        int i=0;\\n        while(candies>0) {\\n            if(j<=candies) {\\n                ret[i]+=j;\\n                candies-=j;\\n                i++;\\n                j++;\\n                if(i==num_people) i=0;\\n            }\\n            else {\\n                ret[i]+=candies;\\n                break;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> ret;\\n        int j=1;\\n        for(int i=0;i<num_people;i++) {\\n            if(j<=candies) {\\n                ret.push_back(j);\\n                candies-=j;\\n                j++;\\n            }\\n            else  {\\n                ret.push_back(candies);\\n                candies=0;\\n            }\\n        }\\n        int i=0;\\n        while(candies>0) {\\n            if(j<=candies) {\\n                ret[i]+=j;\\n                candies-=j;\\n                i++;\\n                j++;\\n                if(i==num_people) i=0;\\n            }\\n            else {\\n                ret[i]+=candies;\\n                break;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324110,
                "title": "simple-c-code-easy-to-understand-0ms-runtime-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> v(num_people,0);\\n        int j=1;\\n        while(candies>0){\\n                v[(j-1)%num_people]+=min(j,candies);\\n                candies-=j;\\n                j++;\\n        }\\n    return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> v(num_people,0);\\n        int j=1;\\n        while(candies>0){\\n                v[(j-1)%num_people]+=min(j,candies);\\n                candies-=j;\\n                j++;\\n        }\\n    return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1287989,
                "title": "easy-java-o-n-soln",
                "content": "Do give an upvote if you liked it!\\n```\\npublic int[] distributeCandies(int c, int p) {\\n        int arr[]=new int[p];\\n        int ind = 0;\\n        int k = 1;\\n        while(c>0){\\n            if(c>k)\\n                arr[ind%p]+=k;\\n            else\\n                arr[ind%p]+=c;\\n            ind++;\\n            c=c-k;\\n            k++;\\n        }\\n        return arr;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] distributeCandies(int c, int p) {\\n        int arr[]=new int[p];\\n        int ind = 0;\\n        int k = 1;\\n        while(c>0){\\n            if(c>k)\\n                arr[ind%p]+=k;\\n            else\\n                arr[ind%p]+=c;\\n            ind++;\\n            c=c-k;\\n            k++;\\n        }\\n        return arr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1264310,
                "title": "python-3-100-fast-used-math",
                "content": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        distribution = 0\\n        iteration = 0\\n        past_distribution = 0\\n        \\n        while distribution <= candies:\\n            past_distribution = distribution\\n            iteration += 1\\n            distribution = ((num_people*iteration)*(num_people * iteration + 1))//2\\n            \\n        candies -= past_distribution\\n        ans = []\\n        for i in range(num_people):\\n            x = iteration-1\\n            ith_candies = (i+1)*(x) + (num_people*x*(x-1))//2\\n            \\n            if candies > 0:\\n                new_candy = (i+1) + ((iteration-1)*num_people)\\n                new_candies = min(candies, new_candy)\\n                ith_candies += new_candies\\n                candies -= new_candies\\n            ans.append(ith_candies)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        distribution = 0\\n        iteration = 0\\n        past_distribution = 0\\n        \\n        while distribution <= candies:\\n            past_distribution = distribution\\n            iteration += 1\\n            distribution = ((num_people*iteration)*(num_people * iteration + 1))//2\\n            \\n        candies -= past_distribution\\n        ans = []\\n        for i in range(num_people):\\n            x = iteration-1\\n            ith_candies = (i+1)*(x) + (num_people*x*(x-1))//2\\n            \\n            if candies > 0:\\n                new_candy = (i+1) + ((iteration-1)*num_people)\\n                new_candies = min(candies, new_candy)\\n                ith_candies += new_candies\\n                candies -= new_candies\\n            ans.append(ith_candies)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1252681,
                "title": "easy-to-understand-javascript-solution",
                "content": "\\nvar distributeCandies = function(candies, num_people) {\\n  \\n   let res =Array(num_people).fill(0) ,i=0 , j =1;\\n \\n    while(candies>0)\\n    {    \\n        if(i==num_people)\\n        {\\n            i=0;\\n        }\\n        res[i]+=candies>=j? j :candies;\\n        candies-=j\\n        i++;   \\n        j++;\\n    }\\n    \\n    return res;\\n};",
                "solutionTags": [],
                "code": "\\nvar distributeCandies = function(candies, num_people) {\\n  \\n   let res =Array(num_people).fill(0) ,i=0 , j =1;\\n \\n    while(candies>0)\\n    {    \\n        if(i==num_people)\\n        {\\n            i=0;\\n        }\\n        res[i]+=candies>=j? j :candies;\\n        candies-=j\\n        i++;   \\n        j++;\\n    }\\n    \\n    return res;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1240670,
                "title": "java-bruteforce",
                "content": "```\\nclass Solution \\n{\\n    public int[] distributeCandies(int candies, int num_people) \\n    {\\n        int i = 0 , candy = 1 ;\\n        int[] a = new int[num_people] ;\\n        while( candies > 0 )\\n        {\\n            if( candy > candies )\\n            {\\n                a[i] += candies ;\\n            }\\n            else\\n            {\\n                a[i] += candy ;\\n                i++ ;\\n            }\\n            candies = candies - candy ;\\n            candy++ ;\\n            if( i == num_people )\\n            {\\n                i = 0 ;\\n            }\\n        }\\n        return a ;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public int[] distributeCandies(int candies, int num_people) \\n    {\\n        int i = 0 , candy = 1 ;\\n        int[] a = new int[num_people] ;\\n        while( candies > 0 )\\n        {\\n            if( candy > candies )\\n            {\\n                a[i] += candies ;\\n            }\\n            else\\n            {\\n                a[i] += candy ;\\n                i++ ;\\n            }\\n            candies = candies - candy ;\\n            candy++ ;\\n            if( i == num_people )\\n            {\\n                i = 0 ;\\n            }\\n        }\\n        return a ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1132765,
                "title": "c-o-n-100-fast-time-gauss-summation",
                "content": "```\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        auto iters = 0;  //count how many full cycles we can get\\n        auto sum = 0; //sum of each cycle\\n        auto count = 1; // start value of 1st human in cycle\\n        if(num_people == 1){\\n            return {candies}; \\n        }\\n        sum = (num_people*(count+num_people))/2; //compute first sum of candies for the 1st cycle\\n        while(candies >= sum){ // while we can give candies for each people in cycle, count it and residual of candies\\n            candies -= sum;\\n            count += num_people;\\n            sum = (num_people*(2*count+num_people-1))/2; // sum of all candies from count to N+count\\n            iters++; // if we in while loop, that means we can make a cycle\\n        }\\n        vector<int> res(num_people, 0); // create our final result vector\\n        auto extra = count; //last value for the fisrt human in cycle that we shoul bring\\n        for(auto i = 0; i < num_people; ++i){\\n            if(iters > 0) // if we have full cycles\\n                res[i] = ((i+1)*iters + num_people*(iters-1)*iters/2); //compute sum of all candies for Ith person that can be given from cycles\\n            if(candies >= (extra)){ //if we have extra candies after cycles computing, lets add them\\n                res[i] += extra;\\n                candies -= extra;\\n                ++extra;\\n                \\n            }\\n            else if(candies > 0){\\n                res[i] += candies;\\n                candies = 0;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        auto iters = 0;  //count how many full cycles we can get\\n        auto sum = 0; //sum of each cycle\\n        auto count = 1; // start value of 1st human in cycle\\n        if(num_people == 1){\\n            return {candies}; \\n        }\\n        sum = (num_people*(count+num_people))/2; //compute first sum of candies for the 1st cycle\\n        while(candies >= sum){ // while we can give candies for each people in cycle, count it and residual of candies\\n            candies -= sum;\\n            count += num_people;\\n            sum = (num_people*(2*count+num_people-1))/2; // sum of all candies from count to N+count\\n            iters++; // if we in while loop, that means we can make a cycle\\n        }\\n        vector<int> res(num_people, 0); // create our final result vector\\n        auto extra = count; //last value for the fisrt human in cycle that we shoul bring\\n        for(auto i = 0; i < num_people; ++i){\\n            if(iters > 0) // if we have full cycles\\n                res[i] = ((i+1)*iters + num_people*(iters-1)*iters/2); //compute sum of all candies for Ith person that can be given from cycles\\n            if(candies >= (extra)){ //if we have extra candies after cycles computing, lets add them\\n                res[i] += extra;\\n                candies -= extra;\\n                ++extra;\\n                \\n            }\\n            else if(candies > 0){\\n                res[i] += candies;\\n                candies = 0;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1132441,
                "title": "c-100-fast-intuitive-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num) {\\n        vector<int> arr(num,0);\\n        \\n        int i=0;\\n        int count=1;\\n\\n        while(candies>0){\\n               arr[i%num]+=min(count,candies);\\n               candies-=count;    \\n               count++;\\n               i++;\\n        }\\n        \\n        return arr;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num) {\\n        vector<int> arr(num,0);\\n        \\n        int i=0;\\n        int count=1;\\n\\n        while(candies>0){\\n               arr[i%num]+=min(count,candies);\\n               candies-=count;    \\n               count++;\\n               i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1063785,
                "title": "easy-brute-force-o-sqrt-n-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        int n = num_people;\\n        vector<int> ans(n,0);\\n        int i=0,j=1;\\n        while(candies > 0){\\n        \\n            if(candies > j)\\n                ans[(i+n)%n] += j;\\n            else\\n                ans[(i+n)%n] += candies;\\n                \\n            candies -= j;\\n            i++,j++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        int n = num_people;\\n        vector<int> ans(n,0);\\n        int i=0,j=1;\\n        while(candies > 0){\\n        \\n            if(candies > j)\\n                ans[(i+n)%n] += j;\\n            else\\n                ans[(i+n)%n] += candies;\\n                \\n            candies -= j;\\n            i++,j++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1041303,
                "title": "0ms-time-complexity-o-num-people-space-complexity-o-num-people",
                "content": "Brute force approach giving one candy to first position, two to second etc and looping around until you run out of candy is quick and easy to code but has complexity O(Sqrt(candies)). The limits suggest max number of people is 1000, but max number of candies can be 1,000,000,000 so potentially 30 times as much work! This makes an O(num_people) time algorithm attractive.\\nThe brute force algorithm will take O(Sqrt(candies)) time because there are a quadratic number of steps as explained in the O(num_people) based time.\\n\\nI noticed that the number of candies given out in X steps is given by the sum of the arithmetic progression - **Sum = (n/2)(a+l)**.\\nStep of progression is 1. First step is 1 and number of steps is steps and last value in progression is steps.\\nSo **total candies given out in steps = (steps/2)(1+steps)**.\\nThis gives a quadratic equation in terms of candies\\n**(steps^2)/2 + steps/2 - candies = 0**\\nGiven that we know candies we can solve for steps using general quadratic equation - **x = (-b+sqrt(b^2-4ac))/2a**.\\n**steps = (-(1/2) + sqrt((-1/2)^2-4(1/2)(-candies))/2(1/2)**\\nGiven the number of steps this gives the number of steps where all the candies were given out.\\nFrom this I can calculate the number of complete rounds where everybody got their full complement of candy.\\nFrom this I can calculate the number of candies for each person again based on sum of arithmetic progression (this time step is num_people and intial value is person number)\\nFinally I can calculate the number of candies not handed out in steps and this remainder will be added to the last person to receive candies.\\n\\n**Time Complexity is O(num_people)** and **Space Complexity is O(num_people)**\\n\\nHere is annotated code.\\n\\nIf this helps you please remember to upvote :-) Thank You!\\n\\n```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n\\t\\t// Space O(N)\\n        int[] result = new int[num_people];\\n        // Total candies given out for n steps = n/2(1+n) = (n^2+n)/2 <= candies\\n        // n^2/2+n/2-candies = 0;\\n        // Solving for n = (-1/2)+sqrt(1/4+2candies)\\n        int steps = (int)(Math.sqrt(2*candies+1/4) - 1.0/2);\\n        int rounds = (steps) / num_people;\\n        int partial = steps % num_people;\\n        // System.out.println(\"steps \"+steps);\\n        // System.out.println(\"rounds \"+rounds);\\n        // System.out.println(\"partial \"+partial);\\n        // System.out.println(\"given \"+(steps*(1+steps)/2));\\n\\t\\t// Tiem complexity O(N)\\n        for (int i=0; i<num_people; i++) {\\n            result[i] = rounds*(i+i+2+(rounds-1)*num_people)/2;\\n            if (i < partial)\\n                result[i] += rounds*num_people + i + 1;\\n            // System.out.printf(\"round[%d]=%d\\\\n\", i, result[i]);\\n            if (i == partial)\\n                result[i] += candies - steps*(1+steps)/2;\\n        }\\n        // Brute Force\\n        /*\\n        int share = 1;\\n        int n = 0;\\n        while (candies > 0) {\\n            int amount = Math.min(candies, share++);\\n            result[n++] += amount;\\n            candies -= amount;\\n            n %= num_people;\\n        }\\n        */\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n\\t\\t// Space O(N)\\n        int[] result = new int[num_people];\\n        // Total candies given out for n steps = n/2(1+n) = (n^2+n)/2 <= candies\\n        // n^2/2+n/2-candies = 0;\\n        // Solving for n = (-1/2)+sqrt(1/4+2candies)\\n        int steps = (int)(Math.sqrt(2*candies+1/4) - 1.0/2);\\n        int rounds = (steps) / num_people;\\n        int partial = steps % num_people;\\n        // System.out.println(\"steps \"+steps);\\n        // System.out.println(\"rounds \"+rounds);\\n        // System.out.println(\"partial \"+partial);\\n        // System.out.println(\"given \"+(steps*(1+steps)/2));\\n\\t\\t// Tiem complexity O(N)\\n        for (int i=0; i<num_people; i++) {\\n            result[i] = rounds*(i+i+2+(rounds-1)*num_people)/2;\\n            if (i < partial)\\n                result[i] += rounds*num_people + i + 1;\\n            // System.out.printf(\"round[%d]=%d\\\\n\", i, result[i]);\\n            if (i == partial)\\n                result[i] += candies - steps*(1+steps)/2;\\n        }\\n        // Brute Force\\n        /*\\n        int share = 1;\\n        int n = 0;\\n        while (candies > 0) {\\n            int amount = Math.min(candies, share++);\\n            result[n++] += amount;\\n            candies -= amount;\\n            n %= num_people;\\n        }\\n        */\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1038560,
                "title": "surprisingly-fast-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> ret(num_people);\\n        int candie = 1;\\n        auto guy = ret.begin();\\n        while(candies)\\n        {\\n            candie = min(candie, candies); // get at most whatever candie is left\\n            candies -= candie;  // take out candie\\n            *guy += candie; // give it to guy\\n            \\n            guy++; // go to next guy\\n            if (guy == ret.end()) guy = ret.begin();  // loop back if needed\\n            candie++; // increase amount by one\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> ret(num_people);\\n        int candie = 1;\\n        auto guy = ret.begin();\\n        while(candies)\\n        {\\n            candie = min(candie, candies); // get at most whatever candie is left\\n            candies -= candie;  // take out candie\\n            *guy += candie; // give it to guy\\n            \\n            guy++; // go to next guy\\n            if (guy == ret.end()) guy = ret.begin();  // loop back if needed\\n            candie++; // increase amount by one\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1000334,
                "title": "java-solution-faster-than-91-97-with-explanation",
                "content": "This is a pretty simple solution that checks whether the number of candies is greater than or equal to counter, if so then add that to the persons number of candies and subtract counter from candies to show how many candies are left. Else it adds the number of candies to the persons number of candies and makes candies equal to zero to break out of the loop and return.\\n\\n```\\npublic int[] distributeCandies(int candies, int num_people) {\\n\\tint[] numCandies = new int[num_people];\\n\\tint people  = 0;\\n\\tint counter = 1;\\n\\twhile (candies > 0){\\n\\t\\tif (candies >= counter){\\n\\t\\t\\tnumCandies[people] += counter;\\n\\t\\t\\tcandies -= counter;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tnumCandies[people] += candies;\\n\\t\\t\\tcandies = 0;\\n\\t\\t}\\n\\t\\tif (people == num_people - 1){\\n\\t\\t\\tpeople = -1;\\n\\t\\t}\\n\\t\\tpeople++;\\n\\t\\tcounter ++;\\n\\t}\\n\\treturn numCandies;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] distributeCandies(int candies, int num_people) {\\n\\tint[] numCandies = new int[num_people];\\n\\tint people  = 0;\\n\\tint counter = 1;\\n\\twhile (candies > 0){\\n\\t\\tif (candies >= counter){\\n\\t\\t\\tnumCandies[people] += counter;\\n\\t\\t\\tcandies -= counter;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tnumCandies[people] += candies;\\n\\t\\t\\tcandies = 0;\\n\\t\\t}\\n\\t\\tif (people == num_people - 1){\\n\\t\\t\\tpeople = -1;\\n\\t\\t}\\n\\t\\tpeople++;\\n\\t\\tcounter ++;\\n\\t}\\n\\treturn numCandies;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 979990,
                "title": "python-distribute-one-by-one",
                "content": "```\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        res = [0] * num_people\\n        cand = 1\\n        while candies > 0:\\n            for i in range(num_people):\\n                if cand >= candies:\\n                    res[i] += candies\\n                    candies = 0\\n                    break\\n                else:\\n                    res[i] += cand\\n                    candies -= cand\\n                    cand += 1\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        res = [0] * num_people\\n        cand = 1\\n        while candies > 0:\\n            for i in range(num_people):\\n                if cand >= candies:\\n                    res[i] += candies\\n                    candies = 0\\n                    break\\n                else:\\n                    res[i] += cand\\n                    candies -= cand\\n                    cand += 1\\n        \\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 949648,
                "title": "c-beats-100-using-ap-series",
                "content": "class Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> ans;\\n        \\n        int sum=0;\\n        int i=1;\\n        while(sum+i<=candies)\\n        {\\n            sum+=i;\\n            if(sum+i+1>candies)\\n                break;\\n            i++;\\n        }\\n       \\n        \\n        int row=i/num_people;\\n        \\n        int d=num_people;\\n        int l=0;\\n        int curr=0;\\n        for(int i=0;i<num_people;i++)\\n        {\\n            int a=i+1;\\n            l=a+(row-1)*d;\\n            int s=((a+l)*row)/2;\\n            ans.push_back(s);\\n            curr+=s;\\n            \\n        }\\n        \\n        if(curr<candies)\\n        {\\n            l++;\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(curr+l<=candies)\\n                {\\n                    ans[i]=ans[i]+l;\\n                    curr+=l;\\n                }\\n                else\\n                {\\n                    ans[i]=ans[i]+candies-curr;\\n                    break;\\n                }\\n                l++;\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> ans;\\n        \\n        int sum=0;\\n        int i=1;\\n        while(sum+i<=candies)\\n        {\\n            sum+=i;\\n            if(sum+i+1>candies)\\n                break;\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 929706,
                "title": "c-faster-than-100-people-neatly-written",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int>v(num_people);\\n        int cur=0,sum=0;\\n        for(int i=1;i!=0;i++){\\n            v[cur]+=i;\\n            sum+=i;\\n            if(sum==candies)\\n                break;\\n            else if(sum>candies){\\n                v[cur] -= i;\\n                sum-=i;\\n                v[cur]+=candies-sum;\\n                break;\\n            }\\n            cur++;\\n            cur = cur%num_people;\\n        }\\n        return v;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int>v(num_people);\\n        int cur=0,sum=0;\\n        for(int i=1;i!=0;i++){\\n            v[cur]+=i;\\n            sum+=i;\\n            if(sum==candies)\\n                break;\\n            else if(sum>candies){\\n                v[cur] -= i;\\n                sum-=i;\\n                v[cur]+=candies-sum;\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 926177,
                "title": "easy-python-3",
                "content": "\\tclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        ans=[0]*num_people\\n        i=0\\n        while candies>0:\\n            if candies>(i+1):\\n                ans[i%num_people]+=i+1\\n                         \\n            else:\\n                ans[i%num_people]+=candies\\n                \\n            candies-=(i+1)\\n            i+=1\\n            \\n        return ans",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        ans=[0]*num_people\\n        i=0\\n        while candies>0:\\n            if candies>(i+1):\\n                ans[i%num_people]+=i+1\\n                         \\n            else:\\n                ans[i%num_people]+=candies\\n                \\n            candies-=(i+1)\\n            i+=1\\n            \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 908015,
                "title": "easy-way-explanation-every-step",
                "content": "#  idea is  you increasing 1 candy for every person until nth person and when your reach last person comeback first.\\n# and put candy whatever gives last person +1 if not enough candy then gives whatever remaining\\n# if 4 person and candy 92\\n\\n# 1 + 2+ 3+  4     ---- first time\\n# 5 + 6+ 7+ 8----- second time\\n# 9 + 10+ 11+ 12  -----thrid time till here 91\\n# 13+1(this place he maximum can gets 14 but not enough canndy)\\n# ----- fourth time\\n# sum of all time candy gets one person  [(1+5+9+13),(2+6+10+1),(3+7+11+0)(4+8+12+0)]\\n# Explanation Bellow  another example example\\n```\\nYour input\\n100\\n8\\nstdout\\n(\\'person=\\', 1, \\'candies gets=\\', 1)\\n[1, 0, 0, 0, 0, 0, 0, 0]\\n\\n(\\'person=\\', 2, \\'candies gets=\\', 2)\\n[1, 2, 0, 0, 0, 0, 0, 0]\\n\\n(\\'person=\\', 3, \\'candies gets=\\', 3)\\n[1, 2, 3, 0, 0, 0, 0, 0]\\n\\n(\\'person=\\', 4, \\'candies gets=\\', 4)\\n[1, 2, 3, 4, 0, 0, 0, 0]\\n\\n(\\'person=\\', 5, \\'candies gets=\\', 5)\\n[1, 2, 3, 4, 5, 0, 0, 0]\\n\\n(\\'person=\\', 6, \\'candies gets=\\', 6)\\n[1, 2, 3, 4, 5, 6, 0, 0]\\n\\n(\\'person=\\', 7, \\'candies gets=\\', 7)\\n[1, 2, 3, 4, 5, 6, 7, 0]\\n\\n(\\'person=\\', 8, \\'candies gets=\\', 8)\\n[1, 2, 3, 4, 5, 6, 7, 8]\\n\\n(\\'person=\\', 1, \\'candies gets=\\', 9)\\n[10, 2, 3, 4, 5, 6, 7, 8]\\n\\n(\\'person=\\', 2, \\'candies gets=\\', 10)\\n[10, 12, 3, 4, 5, 6, 7, 8]\\n\\n(\\'person=\\', 3, \\'candies gets=\\', 11)\\n[10, 12, 14, 4, 5, 6, 7, 8]\\n\\n(\\'person=\\', 4, \\'candies gets=\\', 12)\\n[10, 12, 14, 16, 5, 6, 7, 8]\\n\\n(\\'person=\\', 5, \\'candies gets=\\', 13)\\n[10, 12, 14, 16, 18, 6, 7, 8]\\n\\n(\\'person=\\', 6, \\'candies gets=\\', 9)\\n[10, 12, 14, 16, 18, 15, 7, 8]\\n\\nOutput\\n[10,12,14,16,18,15,7,8]\\nExpected\\n[10,12,14,16,18,15,7,8]\\n\\n\\n\\n\\n```\\n```\\n\\nclass Solution(object):\\n    def distributeCandies(self, can, n):\\n        \"\"\"\\n        :type candies: int\\n        :type num_people: int\\n        :rtype: List[int]\\n        \"\"\"\\n        re=[0 for i in range(n)]\\n        i=1\\n        while can>0:\\n        \\n          re[(i-1)%n]+=min(i,can)\\n\\t\\t  \\n          can,i=can-i,i+1\\n          \\n        return re\\n      \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nYour input\\n100\\n8\\nstdout\\n(\\'person=\\', 1, \\'candies gets=\\', 1)\\n[1, 0, 0, 0, 0, 0, 0, 0]\\n\\n(\\'person=\\', 2, \\'candies gets=\\', 2)\\n[1, 2, 0, 0, 0, 0, 0, 0]\\n\\n(\\'person=\\', 3, \\'candies gets=\\', 3)\\n[1, 2, 3, 0, 0, 0, 0, 0]\\n\\n(\\'person=\\', 4, \\'candies gets=\\', 4)\\n[1, 2, 3, 4, 0, 0, 0, 0]\\n\\n(\\'person=\\', 5, \\'candies gets=\\', 5)\\n[1, 2, 3, 4, 5, 0, 0, 0]\\n\\n(\\'person=\\', 6, \\'candies gets=\\', 6)\\n[1, 2, 3, 4, 5, 6, 0, 0]\\n\\n(\\'person=\\', 7, \\'candies gets=\\', 7)\\n[1, 2, 3, 4, 5, 6, 7, 0]\\n\\n(\\'person=\\', 8, \\'candies gets=\\', 8)\\n[1, 2, 3, 4, 5, 6, 7, 8]\\n\\n(\\'person=\\', 1, \\'candies gets=\\', 9)\\n[10, 2, 3, 4, 5, 6, 7, 8]\\n\\n(\\'person=\\', 2, \\'candies gets=\\', 10)\\n[10, 12, 3, 4, 5, 6, 7, 8]\\n\\n(\\'person=\\', 3, \\'candies gets=\\', 11)\\n[10, 12, 14, 4, 5, 6, 7, 8]\\n\\n(\\'person=\\', 4, \\'candies gets=\\', 12)\\n[10, 12, 14, 16, 5, 6, 7, 8]\\n\\n(\\'person=\\', 5, \\'candies gets=\\', 13)\\n[10, 12, 14, 16, 18, 6, 7, 8]\\n\\n(\\'person=\\', 6, \\'candies gets=\\', 9)\\n[10, 12, 14, 16, 18, 15, 7, 8]\\n\\nOutput\\n[10,12,14,16,18,15,7,8]\\nExpected\\n[10,12,14,16,18,15,7,8]\\n\\n\\n\\n\\n```\n```\\n\\nclass Solution(object):\\n    def distributeCandies(self, can, n):\\n        \"\"\"\\n        :type candies: int\\n        :type num_people: int\\n        :rtype: List[int]\\n        \"\"\"\\n        re=[0 for i in range(n)]\\n        i=1\\n        while can>0:\\n        \\n          re[(i-1)%n]+=min(i,can)\\n\\t\\t  \\n          can,i=can-i,i+1\\n          \\n        return re\\n      \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 870584,
                "title": "simple-c-solution-100-faster",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> distributeCandies(int candies, int num_people) {\\n\\t\\t\\tvector<int> v(num_people,0);\\n\\t\\t\\tint i = 1;\\n\\t\\t\\tint j = 0;\\n\\t\\t\\twhile(candies > 0){\\n\\t\\t\\t\\tv[j%num_people] += min(candies,i);\\n\\t\\t\\t\\tcandies-=i;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n        \\n        return v;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> distributeCandies(int candies, int num_people) {\\n\\t\\t\\tvector<int> v(num_people,0);\\n\\t\\t\\tint i = 1;\\n\\t\\t\\tint j = 0;\\n\\t\\t\\twhile(candies > 0){\\n\\t\\t\\t\\tv[j%num_people] += min(candies,i);\\n\\t\\t\\t\\tcandies-=i;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 869907,
                "title": "swift-solution-readability-performance-92",
                "content": "I would prefer my solution for readability than those weird modulo formula. It\\'s dumb in my opinion to use the solution. Not everyone knows that.\\n\\n```\\nclass Solution {\\n    func distributeCandies(_ candies: Int, _ num_people: Int) -> [Int] {\\n        \\n        var result: [Int] = Array(repeating: 0, count: num_people)\\n        var candies = candies\\n        var currentIndex = 0\\n        var currentGive = 1\\n        \\n        while candies > 0 {\\n            if candies > currentGive {\\n                result[currentIndex] += currentGive\\n                candies -= currentGive\\n                currentGive += 1\\n            } else {\\n                result[currentIndex] += candies\\n                candies = 0\\n            }\\n            currentIndex = currentIndex < num_people - 1 ? currentIndex + 1 : 0\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func distributeCandies(_ candies: Int, _ num_people: Int) -> [Int] {\\n        \\n        var result: [Int] = Array(repeating: 0, count: num_people)\\n        var candies = candies\\n        var currentIndex = 0\\n        var currentGive = 1\\n        \\n        while candies > 0 {\\n            if candies > currentGive {\\n                result[currentIndex] += currentGive\\n                candies -= currentGive\\n                currentGive += 1\\n            } else {\\n                result[currentIndex] += candies\\n                candies = 0\\n            }\\n            currentIndex = currentIndex < num_people - 1 ? currentIndex + 1 : 0\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 839218,
                "title": "javascript-mathematical-solution",
                "content": "##### Amortized Analysis\\n\\nTIme Complexity: O(n)\\nSpace Complexity: O(1)\\n\\n---\\n##### Code\\n---\\n```\\n/**\\n * @param {number} candies\\n * @param {number} num_people\\n * @return {number[]}\\n */\\nconst seriesSum = n => (n * (n+1))/2;\\n\\nconst binarySearch = (low, high, candies) => {\\n  while(low < high) {\\n    let mid = (low + high) >> 1;\\n    let sum = seriesSum(mid);\\n    if( sum == candies ) {\\n      return mid;\\n    } else if (sum < candies) {\\n      low = mid + 1;\\n    } else {\\n      high = mid - 1;\\n    }\\n  }\\n  return high;\\n}\\nvar distributeCandies = function(candies, num_people) {\\n  // find how many time it is possible to circle back\\n  let round = binarySearch(0, 1e5, candies) / num_people >> 0;\\n  // find the extra andies\\n  let extra = candies - seriesSum(round * num_people);\\n  let answer = Array(num_people).fill(0); \\n  // first person will get  n * (r*(r+1))/2 + r + 1 candies, where n = num_people and r = round - 1\\n  answer[0] = Math.max(0, num_people * seriesSum(round - 1) + round);\\n  let candiesLeft = candies - answer[0];\\n  for(let i = 1; i < num_people; i++) {\\n\\t // every one will get exactly **r** candies more than the previous persion\\n    answer[i] = Math.min(answer[i - 1] + round, candiesLeft);\\n    candiesLeft -= answer[i];\\n  }\\n  // distribute the extra candies\\n  for(let i = 0; i < num_people && extra > 0; i++) {\\n\\t // everyone will get n * r + i + 1 extra candies. where n = num_people, r =round, i is the position of the persion (0 indexed)\\n    let exCandies = Math.min(num_people * round + i + 1 , extra);\\n    answer[i] += exCandies\\n    extra -= exCandies;\\n  }\\n  return answer;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} candies\\n * @param {number} num_people\\n * @return {number[]}\\n */\\nconst seriesSum = n => (n * (n+1))/2;\\n\\nconst binarySearch = (low, high, candies) => {\\n  while(low < high) {\\n    let mid = (low + high) >> 1;\\n    let sum = seriesSum(mid);\\n    if( sum == candies ) {\\n      return mid;\\n    } else if (sum < candies) {\\n      low = mid + 1;\\n    } else {\\n      high = mid - 1;\\n    }\\n  }\\n  return high;\\n}\\nvar distributeCandies = function(candies, num_people) {\\n  // find how many time it is possible to circle back\\n  let round = binarySearch(0, 1e5, candies) / num_people >> 0;\\n  // find the extra andies\\n  let extra = candies - seriesSum(round * num_people);\\n  let answer = Array(num_people).fill(0); \\n  // first person will get  n * (r*(r+1))/2 + r + 1 candies, where n = num_people and r = round - 1\\n  answer[0] = Math.max(0, num_people * seriesSum(round - 1) + round);\\n  let candiesLeft = candies - answer[0];\\n  for(let i = 1; i < num_people; i++) {\\n\\t // every one will get exactly **r** candies more than the previous persion\\n    answer[i] = Math.min(answer[i - 1] + round, candiesLeft);\\n    candiesLeft -= answer[i];\\n  }\\n  // distribute the extra candies\\n  for(let i = 0; i < num_people && extra > 0; i++) {\\n\\t // everyone will get n * r + i + 1 extra candies. where n = num_people, r =round, i is the position of the persion (0 indexed)\\n    let exCandies = Math.min(num_people * round + i + 1 , extra);\\n    answer[i] += exCandies\\n    extra -= exCandies;\\n  }\\n  return answer;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 798651,
                "title": "c-best-in-time-complexity-o-log-candies-simple-binary-search-easy-explain",
                "content": "**Binary Search**\\n* Apply simple binary search to  find the number of how many times candies can be distributed continuosly.\\n* \\n![image](https://assets.leetcode.com/users/images/9bdfc860-e8b2-45b2-a9df-d7177004c7fd_1597749409.8828528.png)\\n\\n```\\n#define pb push_back\\n\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        int n=num_people;\\n        vector<int> v(n);\\n     int left=1;\\n        int right=sqrt(INT_MAX)-1,mid;\\n      while(left<=right)\\n      {\\n            mid=(left+right)/2;\\n        if((mid*(mid+1))/2<candies)\\n        {\\n            left=mid+1;\\n            \\n        }\\n          else if((mid*(mid+1))/2> candies)\\n              right=mid-1;\\n          else\\n              break;\\n          \\n      }\\n     if((mid*(mid+1))/2>candies)\\n         mid--;\\n        \\n    int k=mid/n;\\n        candies-=(k*n*(k*n+1))/2;\\n        for(int i=0;i<n;i++)\\n        {\\n            v[i]=(i+1)*(k) + ((k-1)*(k)/2)*n+min(candies,k*n+i+1);\\n            candies-=min(candies,k*n+i+1);\\n        }\\n        \\n  //  v.pb(mid);\\n        return v;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define pb push_back\\n\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        int n=num_people;\\n        vector<int> v(n);\\n     int left=1;\\n        int right=sqrt(INT_MAX)-1,mid;\\n      while(left<=right)\\n      {\\n            mid=(left+right)/2;\\n        if((mid*(mid+1))/2<candies)\\n        {\\n            left=mid+1;\\n            \\n        }\\n          else if((mid*(mid+1))/2> candies)\\n              right=mid-1;\\n          else\\n              break;\\n          \\n      }\\n     if((mid*(mid+1))/2>candies)\\n         mid--;\\n        \\n    int k=mid/n;\\n        candies-=(k*n*(k*n+1))/2;\\n        for(int i=0;i<n;i++)\\n        {\\n            v[i]=(i+1)*(k) + ((k-1)*(k)/2)*n+min(candies,k*n+i+1);\\n            candies-=min(candies,k*n+i+1);\\n        }\\n        \\n  //  v.pb(mid);\\n        return v;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 798038,
                "title": "simple-c-solution",
                "content": "Please comment for any doubt\\n\\n```\\nvector<int> distributeCandies(int candies, int num_people) {\\n        if (num_people==0 or candies==0)\\n            return {};\\n        if(num_people==1)\\n            return {candies};\\n        vector<int> res(num_people,0);\\n        int i=1;\\n        int ind=0;\\n        while (candies>0)\\n        {\\n            res[ind]+=min(i,candies);\\n            candies-=i;\\n            i+=1;\\n            ind=(ind+1)%num_people;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> distributeCandies(int candies, int num_people) {\\n        if (num_people==0 or candies==0)\\n            return {};\\n        if(num_people==1)\\n            return {candies};\\n        vector<int> res(num_people,0);\\n        int i=1;\\n        int ind=0;\\n        while (candies>0)\\n        {\\n            res[ind]+=min(i,candies);\\n            candies-=i;\\n            i+=1;\\n            ind=(ind+1)%num_people;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 798037,
                "title": "distribute-candies-to-people-python-simplest-solution-28-ms-faster-than-98-59-of-python3",
                "content": "```\\ndef distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        counter  = 1\\n        result = [0] * num_people\\n        \\n        while candies :\\n            index = (counter - 1) % num_people\\n            if candies - counter >= 0:\\n                result[index] += counter\\n                candies -= counter\\n            else :\\n                result[index] += candies\\n                candies = 0\\n                \\n            counter += 1\\n        \\n        return result \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        counter  = 1\\n        result = [0] * num_people\\n        \\n        while candies :\\n            index = (counter - 1) % num_people\\n            if candies - counter >= 0:\\n                result[index] += counter\\n                candies -= counter\\n            else :\\n                result[index] += candies\\n                candies = 0\\n                \\n            counter += 1\\n        \\n        return result \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 797716,
                "title": "beats-100-using-formula-for-sum-of-series",
                "content": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int j = (int) ((-1 + Math.sqrt(1 + (long) 8 * candies)) / 2);\\n        \\n        int leftovercandies = candies - (j * (j + 1) / 2);\\n        \\n        int[] ans = new int[num_people];\\n        \\n        int r = j / num_people - 1;\\n        \\n        for (int i = 0; i < num_people; i++) {\\n            ans[i] = (r + 1) * (i + 1) + num_people * (r * (r + 1)) / 2;\\n        }\\n        \\n        for (int i = 0; i < j % num_people; i++) {\\n            ans[i] += (r + 1) * num_people + i + 1;\\n        }\\n        \\n        ans[j % num_people] += leftovercandies;\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\nUse quadratic formula to find mininum j such that j * (j + 1) / 2 = num_candies.\\n\\nCalculate leftover candies for last person (when no longer enough candy to continue pattern) using candies - j * (j + 1) / 2.\\n\\nCalculate r (number of full rounds of distributing candy), and subtract 1 to use 0 indexing.\\n\\nWrite out the numbers on a sheet of paper, and you can see that the numbers down each column (with each round on top of each other) and you see that the numbers down each column is also a series, so we can use a formula to directly calculate the candies after r full rounds for each person.\\n\\nAnother loop for the final, possible non-full round, (starts at index i and ends at j % num_people.\\n\\nAdd leftover candies to final person.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int j = (int) ((-1 + Math.sqrt(1 + (long) 8 * candies)) / 2);\\n        \\n        int leftovercandies = candies - (j * (j + 1) / 2);\\n        \\n        int[] ans = new int[num_people];\\n        \\n        int r = j / num_people - 1;\\n        \\n        for (int i = 0; i < num_people; i++) {\\n            ans[i] = (r + 1) * (i + 1) + num_people * (r * (r + 1)) / 2;\\n        }\\n        \\n        for (int i = 0; i < j % num_people; i++) {\\n            ans[i] += (r + 1) * num_people + i + 1;\\n        }\\n        \\n        ans[j % num_people] += leftovercandies;\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 797508,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int []res = new int[num_people];\\n        \\n        int counter = 1;\\n        int currentPerson = 0;\\n        while(candies >= 0) {\\n            res[currentPerson] += (counter < candies) ? counter: candies;\\n            candies -= counter++;\\n            currentPerson = (currentPerson + 1)%num_people;\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int []res = new int[num_people];\\n        \\n        int counter = 1;\\n        int currentPerson = 0;\\n        while(candies >= 0) {\\n            res[currentPerson] += (counter < candies) ? counter: candies;\\n            candies -= counter++;\\n            currentPerson = (currentPerson + 1)%num_people;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 797055,
                "title": "simple-loop-solution",
                "content": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] people = new int[num_people];\\n        int candyCount = 1;\\n        while(candies>0){\\n            \\n                for(int i = 0 ; i < num_people; ++i){\\n                    if(candyCount<=candies){\\n                        people[i]+=candyCount;\\n                        candies-=candyCount;\\n                        ++candyCount;\\n                    }else{\\n                        people[i]+=candies;\\n                        candies=0;\\n\\t\\t\\t\\t\\t\\tbreak;\\n                    }\\n                }\\n            \\n        }\\n        return people;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] people = new int[num_people];\\n        int candyCount = 1;\\n        while(candies>0){\\n            \\n                for(int i = 0 ; i < num_people; ++i){\\n                    if(candyCount<=candies){\\n                        people[i]+=candyCount;\\n                        candies-=candyCount;\\n                        ++candyCount;\\n                    }else{\\n                        people[i]+=candies;\\n                        candies=0;\\n\\t\\t\\t\\t\\t\\tbreak;\\n                    }\\n                }\\n            \\n        }\\n        return people;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796909,
                "title": "java-one-go-o-num-people-math",
                "content": "I have tried to represent the formula in hand-written.\\n**Caution : bad hand-writing ahead**\\n![image](https://assets.leetcode.com/users/images/61bfada6-bc5c-4a70-8dee-261a1afe598d_1597671597.664236.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/f8282f08-f5ba-4609-9c92-68f45751701f_1597671574.2589667.png)\\n\\n\\n```\\nclass Solution {\\n    public int[] distributeCandies(int c, int num_people) {\\n        int [] p = new int[num_people];\\n        int candiesRemaining = c;\\n        // x*(x+1)/2 = c\\n        double x = (-1 + Math.sqrt(1+(double)8*c))/2;\\n        // x = k*n + r;\\n        int k = ((int)x)/num_people;\\n        int r = ((int)x)%num_people;\\n        for(int i=0;i<num_people;i++){\\n            if(i<r){\\n                p[i] = (k+1)*(i+1) + num_people*(k)*(k+1)/2;\\n            }\\n            else{\\n                p[i] = (k)*(i+1) + num_people*(k)*(k-1)/2;\\n            }\\n            candiesRemaining-=p[i];\\n        }\\n        p[r] += candiesRemaining;\\n        return p;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int c, int num_people) {\\n        int [] p = new int[num_people];\\n        int candiesRemaining = c;\\n        // x*(x+1)/2 = c\\n        double x = (-1 + Math.sqrt(1+(double)8*c))/2;\\n        // x = k*n + r;\\n        int k = ((int)x)/num_people;\\n        int r = ((int)x)%num_people;\\n        for(int i=0;i<num_people;i++){\\n            if(i<r){\\n                p[i] = (k+1)*(i+1) + num_people*(k)*(k+1)/2;\\n            }\\n            else{\\n                p[i] = (k)*(i+1) + num_people*(k)*(k-1)/2;\\n            }\\n            candiesRemaining-=p[i];\\n        }\\n        p[r] += candiesRemaining;\\n        return p;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796903,
                "title": "single-pass-o-num-people-i-e-o-n-explained-java-beats-100-solutions-0ms",
                "content": "We can think of distributing candies to people standing in an infinite row and later arrange them in\\n\\nWe will first find out how many times we can give as many candies to people as many they can take at that particular chance. Lets denote this number as ```n```.\\n{For eg.- if there are 2 people and 9 candies, we can give required candies 3 times (so n=3). 1 candy to first person (1), then 2 candies to second person (2), then 3 candies to first person (3). Now we have 3 candies left (```extra```) but second person requires 4 candies.}\\n\\n```candies = n*(n+1)/2 + extra```\\n```candies - extra = n*(n+1)/2```\\ntherefore,``` n*n + n - 2*(candies -extra) = 0```\\nSolving this equation for n ( I am using [Quadratic Formula](https://en.wikipedia.org/wiki/Quadratic_formula) here) we can get n as:\\n```n = (-1 \\xB1 \\u221A(1-4 * (-2) * (candies-extra)) )/2```\\nWe can ignore the negative root, because the number of candies cannot be negative.\\nAlso, we are interested to find the maximum number for which candies are sufficient, so we can strike off extra. \\nThis gives us ```n = (-1 + \\u221A(1+(8 * candies)) )/2```\\nWe will use floor value (integer value) of n because number of candies cannot be a fraction here.\\n\\nLets represent number of passes in which everyone gets the maximum number of candies they can get as ```passes```, then:\\n```passes = n/num_people```  {passes = 1, in case of above example, because in second pass/iteration, second person could not get required number of candies}\\nNow, the candies remaining after ```passes``` passes/iteration , ```rem``` equals number of candies distributed in ```passes``` passes/iteration subtracte from total candies, ```candies```\\n```rem = candies - passes*num_people*(passes*num_people+1)/2```\\n\\nFor each person, we can get the number of candies that he/she receives as the sum of an Arithmetic Progression in ```passes``` iterations + the candies he/she will receive in the final iteration (if any).\\n\\n```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] res = new int[num_people];\\n        int n = ((int)Math.sqrt(1+8*(long)candies) - 1)/2;\\n        int passes = n/num_people;\\n        int rem = candies - passes*num_people*(passes*num_people+1)/2;\\n        for(int i=0; i<num_people; i++)\\n        {\\n            int remAdd = Math.min(rem, passes*num_people + i+1);\\n            rem -= remAdd;\\n            res[i] = passes*(2*(i+1) + (passes-1)*num_people)/2 + remAdd;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```n```\n```extra```\n```candies = n*(n+1)/2 + extra```\n```candies - extra = n*(n+1)/2```\n``` n*n + n - 2*(candies -extra) = 0```\n```n = (-1 \\xB1 \\u221A(1-4 * (-2) * (candies-extra)) )/2```\n```n = (-1 + \\u221A(1+(8 * candies)) )/2```\n```passes```\n```passes = n/num_people```\n```passes```\n```rem```\n```passes```\n```candies```\n```rem = candies - passes*num_people*(passes*num_people+1)/2```\n```passes```\n```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] res = new int[num_people];\\n        int n = ((int)Math.sqrt(1+8*(long)candies) - 1)/2;\\n        int passes = n/num_people;\\n        int rem = candies - passes*num_people*(passes*num_people+1)/2;\\n        for(int i=0; i<num_people; i++)\\n        {\\n            int remAdd = Math.min(rem, passes*num_people + i+1);\\n            rem -= remAdd;\\n            res[i] = passes*(2*(i+1) + (passes-1)*num_people)/2 + remAdd;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796823,
                "title": "java-distribute-candies-to-people-beats-100-time-o-n-space-o-1",
                "content": "```\\npublic class DistributeCandiestoPeople {\\n\\n    public int[] distributeCandies(int candies, int num_people) {\\n        long candiesLong=candies;\\n        // TO calculate nearest n for  the Summation of n natural number that is the candies\\n        //candies=n(n+1)/2\\n        double nearestSummation= ((Math.sqrt(((8*candiesLong)+1))-1)/2);\\n        //Levels are the levels downwards that need to be summed up vertically\\n        //if data is aligned vertically that is nearestSummation % num_people ==0 the data is summed up vertically for all the levels\\n        //if it is not then the levels summed up vertically is done till second last level after that\\n        //the data is added manually with left over candies and the n th addition to the n % num_people\\n        int levels;\\n\\n        if(Math.floor(nearestSummation)==nearestSummation)\\n            levels=  (((int)nearestSummation)/num_people);\\n        else {\\n            nearestSummation=Math.floor(nearestSummation);\\n            levels = (((int) nearestSummation ) / num_people);\\n        }\\n\\n        int sumbase=1;\\n        for(int i=1;i<=levels-1;i++){\\n            sumbase=sumbase+num_people*i+1;\\n        }\\n\\n        if(nearestSummation<num_people)\\n            levels=1;\\n        int[] arr =new int[num_people];\\n        for(int i=0;i<num_people && candies>0;i++){\\n            arr[i]=sumbase<candies?sumbase:candies;\\n            sumbase=sumbase+levels;\\n            candies-=arr[i];\\n        }\\n       //sumbase resetted as the n th addition on the array\\n        sumbase=num_people*levels+1;\\n        //n++ th addition for ever consecutive person till the candies run out and last person gets all the remaining candy\\n        levels=1;\\n        //Does not execute if candies are finished\\n        for(int i=0;i<num_people && candies>0;i++){\\n            int tempAlot=sumbase<candies?sumbase:candies;\\n            arr[i]+=tempAlot;\\n            sumbase=sumbase+levels;\\n            candies-=tempAlot;\\n        }\\n\\n        return arr;\\n    }\\n\\n    public static void main(String[] args) {\\n        DistributeCandiestoPeople distributeCandiestoPeople= new DistributeCandiestoPeople();\\n        int[] arr= distributeCandiestoPeople.distributeCandies(1000000000,1000);\\n        for(int x:arr)\\n            System.out.println(x);\\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class DistributeCandiestoPeople {\\n\\n    public int[] distributeCandies(int candies, int num_people) {\\n        long candiesLong=candies;\\n        // TO calculate nearest n for  the Summation of n natural number that is the candies\\n        //candies=n(n+1)/2\\n        double nearestSummation= ((Math.sqrt(((8*candiesLong)+1))-1)/2);\\n        //Levels are the levels downwards that need to be summed up vertically\\n        //if data is aligned vertically that is nearestSummation % num_people ==0 the data is summed up vertically for all the levels\\n        //if it is not then the levels summed up vertically is done till second last level after that\\n        //the data is added manually with left over candies and the n th addition to the n % num_people\\n        int levels;\\n\\n        if(Math.floor(nearestSummation)==nearestSummation)\\n            levels=  (((int)nearestSummation)/num_people);\\n        else {\\n            nearestSummation=Math.floor(nearestSummation);\\n            levels = (((int) nearestSummation ) / num_people);\\n        }\\n\\n        int sumbase=1;\\n        for(int i=1;i<=levels-1;i++){\\n            sumbase=sumbase+num_people*i+1;\\n        }\\n\\n        if(nearestSummation<num_people)\\n            levels=1;\\n        int[] arr =new int[num_people];\\n        for(int i=0;i<num_people && candies>0;i++){\\n            arr[i]=sumbase<candies?sumbase:candies;\\n            sumbase=sumbase+levels;\\n            candies-=arr[i];\\n        }\\n       //sumbase resetted as the n th addition on the array\\n        sumbase=num_people*levels+1;\\n        //n++ th addition for ever consecutive person till the candies run out and last person gets all the remaining candy\\n        levels=1;\\n        //Does not execute if candies are finished\\n        for(int i=0;i<num_people && candies>0;i++){\\n            int tempAlot=sumbase<candies?sumbase:candies;\\n            arr[i]+=tempAlot;\\n            sumbase=sumbase+levels;\\n            candies-=tempAlot;\\n        }\\n\\n        return arr;\\n    }\\n\\n    public static void main(String[] args) {\\n        DistributeCandiestoPeople distributeCandiestoPeople= new DistributeCandiestoPeople();\\n        int[] arr= distributeCandiestoPeople.distributeCandies(1000000000,1000);\\n        for(int x:arr)\\n            System.out.println(x);\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796753,
                "title": "my-o-sqrt-candies-solution-using-ap-formula-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n\\t/*\\n\\tget the last number of arithmetic progression (AP) that can be made by candies\\n\\te.g if candies = 7, n = 3, i.e AP will be 1 2 3\\n\\tthe equation to get n is => n/2 * (n + 1) = candies\\n\\t=> n * (n + 1) = 2 * candies\\n\\t=> n^2 + n = 2 * candies\\n\\t=> (n + 0.5)^2 - 0.25 = 2 * candies\\n\\t=> (n + 0.5)^2 = 2 * candies + 0.25\\n\\t=> n + 0.5 = sqrt(2 * candies + 0.25)\\n\\t=> n = sqrt(2 * candies + 0.25) - 0.5\\n\\tafter that we will distribute each number of the AP to the poeple till we reach last person, then we will give the last person the remainder of the candies \\n\\t*/\\n        int n = sqrt(2*candies + 0.25) - 0.5;\\n        vector<int> ans(num_people);\\n        \\n        int idx = 0;\\n\\t// loop on each number of AP and distribute it to the current person\\n        for (int i = 1; i <= n; i++) {\\n            ans[idx] += i;\\n            candies -= i;\\n\\t    /* make addition with mod to return to the first person in case of idx = num_people, i.e we reach after last person so we return back to first person\\n\\t    this is equal to => idx++; if (idx == num_people) idx = 0;\\n            */\\n            idx = (idx + 1) % num_people;\\n        }\\n\\t// give last person the remainder of candies if exists\\n        ans[idx] += candies;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n\\t/*\\n\\tget the last number of arithmetic progression (AP) that can be made by candies\\n\\te.g if candies = 7, n = 3, i.e AP will be 1 2 3\\n\\tthe equation to get n is => n/2 * (n + 1) = candies\\n\\t=> n * (n + 1) = 2 * candies\\n\\t=> n^2 + n = 2 * candies\\n\\t=> (n + 0.5)^2 - 0.25 = 2 * candies\\n\\t=> (n + 0.5)^2 = 2 * candies + 0.25\\n\\t=> n + 0.5 = sqrt(2 * candies + 0.25)\\n\\t=> n = sqrt(2 * candies + 0.25) - 0.5\\n\\tafter that we will distribute each number of the AP to the poeple till we reach last person, then we will give the last person the remainder of the candies \\n\\t*/\\n        int n = sqrt(2*candies + 0.25) - 0.5;\\n        vector<int> ans(num_people);\\n        \\n        int idx = 0;\\n\\t// loop on each number of AP and distribute it to the current person\\n        for (int i = 1; i <= n; i++) {\\n            ans[idx] += i;\\n            candies -= i;\\n\\t    /* make addition with mod to return to the first person in case of idx = num_people, i.e we reach after last person so we return back to first person\\n\\t    this is equal to => idx++; if (idx == num_people) idx = 0;\\n            */\\n            idx = (idx + 1) % num_people;\\n        }\\n\\t// give last person the remainder of candies if exists\\n        ans[idx] += candies;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796717,
                "title": "python-sol-by-simulation-w-comment",
                "content": "Python sol by simulation\\n\\n---\\n\\n**Implementation**:\\n\\n```\\nclass Solution(object):\\n    def distributeCandies(self, candies, num_people):\\n\\n\\n        n = num_people\\n        \\n        # candies distribution for each person\\n        result = [0] * n\\n         \\n        c = 0\\n        while candies > 0:\\n            \\n            # candies may be not enough on last round, therefore compute min(candies, c+1)\\n            result[c % n] += min(candies, c+1)\\n            \\n            # add one more candies for next person\\n            c += 1\\n            \\n            # update total number of candies\\n            candies -= c\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Simulation"
                ],
                "code": "```\\nclass Solution(object):\\n    def distributeCandies(self, candies, num_people):\\n\\n\\n        n = num_people\\n        \\n        # candies distribution for each person\\n        result = [0] * n\\n         \\n        c = 0\\n        while candies > 0:\\n            \\n            # candies may be not enough on last round, therefore compute min(candies, c+1)\\n            result[c % n] += min(candies, c+1)\\n            \\n            # add one more candies for next person\\n            c += 1\\n            \\n            # update total number of candies\\n            candies -= c\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796537,
                "title": "distribute-candies-c-clear-100",
                "content": "Maybe not the most concise, but very easy to understand.\\nJust do literally what the description says.\\n```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> distributed(num_people);\\n        int candiesToGive = 1, i = 0;\\n\\t\\t// While there are remaining candies, increment the number of candies to give\\n        while (candies > 0) {\\n            if (i >= num_people) i = 0; // Reset index when we pass the last person\\n            distributed[i++] += min(candiesToGive, candies); // The amount of candies for the next person. Min of remaining or required to give\\n            candies -= candiesToGive++; // Reduce remaining candies\\n        }\\n        return distributed;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> distributed(num_people);\\n        int candiesToGive = 1, i = 0;\\n\\t\\t// While there are remaining candies, increment the number of candies to give\\n        while (candies > 0) {\\n            if (i >= num_people) i = 0; // Reset index when we pass the last person\\n            distributed[i++] += min(candiesToGive, candies); // The amount of candies for the next person. Min of remaining or required to give\\n            candies -= candiesToGive++; // Reduce remaining candies\\n        }\\n        return distributed;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796449,
                "title": "simple-optimised-c-solution-with-o-num-people-complexity",
                "content": "/*this is the best solution with simple mathematics.\\nmake a matrix like this suppose three people and 28 candies\\n[1,2,3]\\n[4,5,6]\\n[7,0,0]\\nwill be distributed in this manner now to understand how we calcuate this sum 1+4+7 for people 1 and 2+5 for people 2 and 3+6 for people 3*/\\n/* the 1+4+7 notice it sum of first 3 terms with common difference as number of people and terms as t+rem if(rem!=0) for t and rem check the code how we calculate them and for sum of first t terms check the loop*/\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n       vector<int>ans(num_people,0);\\n        if(candies==0) return ans;\\n        int num=1,s=1;\\n        while(s<=candies){\\n            num++;\\n            s+=num;\\n        }\\n        num--;\\n        int t=num/num_people;\\n        int rem=num%num_people;\\n        int rem1=rem;\\n        for(int i=1;i<=num_people;i++){\\n            int no_of_terms=t;\\n            if(rem!=0){\\n                no_of_terms++;\\n                rem--;\\n            }\\n            int sum1=no_of_terms*(2*i+(no_of_terms-1)*num_people);\\n            sum1/=2;\\n            candies-=sum1;\\n            ans[i-1]=sum1;\\n        }\\n        /*this step is for suppose canidies instead of 28 they are 30 then remaining 2 candies will go to \\n        people 2 and sum will be 2+5+2 for people 2 as mentioned in question*/\\n        ans[rem1]+=candies;\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n       vector<int>ans(num_people,0);\\n        if(candies==0) return ans;\\n        int num=1,s=1;\\n        while(s<=candies){\\n            num++;\\n            s+=num;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 796441,
                "title": "c-intuitive-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> ans(num_people);\\n        \\n        for (int i = 0, round = 0; candies > 0;) {\\n            int distribute = round * num_people + i + 1;\\n            \\n            if (candies >= distribute) {\\n                candies -= distribute;\\n                ans[i] += distribute;\\n            } else {\\n                ans[i] += candies;\\n                candies = 0;\\n            }\\n            \\n            if (++i >= num_people) {\\n                i = 0;\\n                ++round;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> ans(num_people);\\n        \\n        for (int i = 0, round = 0; candies > 0;) {\\n            int distribute = round * num_people + i + 1;\\n            \\n            if (candies >= distribute) {\\n                candies -= distribute;\\n                ans[i] += distribute;\\n            } else {\\n                ans[i] += candies;\\n                candies = 0;\\n            }\\n            \\n            if (++i >= num_people) {\\n                i = 0;\\n                ++round;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796414,
                "title": "c-o-num-people-log-candies-solution",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(ll candies, ll num_people) {\\n        ll l = 0LL, r = 1e5 + 1LL, no_of_iterations = 0, ls_exp;\\n        while(l <= r){\\n            ll mid = (l + r) >> 1;\\n            ll exp = ((num_people * num_people * mid * (mid - 1LL)) + \\n                     (mid * num_people * (num_people + 1LL)) ) >> 1;\\n            if(exp <= candies){\\n                l = mid + 1LL;\\n                no_of_iterations = mid;\\n                ls_exp = exp;\\n            }\\n            else{\\n                r = mid - 1LL;\\n            }\\n        }\\n        vector<int> ans(num_people);\\n        candies -= ls_exp;\\n        ll com_term = (no_of_iterations * (no_of_iterations - 1LL) * num_people ) >> 1;\\n        for(ll i = 0LL; i < num_people; i ++){\\n            ll expected = ((no_of_iterations * num_people) + (i + 1LL)), add;\\n            if(expected <= candies){\\n                candies -= expected;\\n                add = expected;\\n            }\\n            else{\\n                add = candies;\\n                candies = 0LL;\\n            }\\n            ans[i] = com_term + (no_of_iterations * (i + 1LL)) + add;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(ll candies, ll num_people) {\\n        ll l = 0LL, r = 1e5 + 1LL, no_of_iterations = 0, ls_exp;\\n        while(l <= r){\\n            ll mid = (l + r) >> 1;\\n            ll exp = ((num_people * num_people * mid * (mid - 1LL)) + \\n                     (mid * num_people * (num_people + 1LL)) ) >> 1;\\n            if(exp <= candies){\\n                l = mid + 1LL;\\n                no_of_iterations = mid;\\n                ls_exp = exp;\\n            }\\n            else{\\n                r = mid - 1LL;\\n            }\\n        }\\n        vector<int> ans(num_people);\\n        candies -= ls_exp;\\n        ll com_term = (no_of_iterations * (no_of_iterations - 1LL) * num_people ) >> 1;\\n        for(ll i = 0LL; i < num_people; i ++){\\n            ll expected = ((no_of_iterations * num_people) + (i + 1LL)), add;\\n            if(expected <= candies){\\n                candies -= expected;\\n                add = expected;\\n            }\\n            else{\\n                add = candies;\\n                candies = 0LL;\\n            }\\n            ans[i] = com_term + (no_of_iterations * (i + 1LL)) + add;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796408,
                "title": "my-0ms-c-solution-easy-to-understand",
                "content": "```\\n    static vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> ans(num_people, 0);\\n        int i = 0;\\n        while (candies > 0) {\\n            ans[i % num_people] += i + 1;\\n            candies -= i + 1;\\n            ++i;\\n        }\\n        \\n        if (candies < 0) { //Fix for giving too many candies to last person\\n            ans[(i - 1) % num_people] += candies;\\n        }\\n        \\n        return ans;\\n    }\\n",
                "solutionTags": [],
                "code": "```\\n    static vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> ans(num_people, 0);\\n        int i = 0;\\n        while (candies > 0) {\\n            ans[i % num_people] += i + 1;\\n            candies -= i + 1;\\n            ++i;\\n        }\\n        \\n        if (candies < 0) { //Fix for giving too many candies to last person\\n            ans[(i - 1) % num_people] += candies;\\n        }\\n        \\n        return ans;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 796403,
                "title": "0-ms-c-solution-distribute-candies-to-people",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector <int> l;\\n        int turn=1;\\n        for(int i=0;i<num_people;i++){\\n            l.push_back(0);    \\n        }\\n        while(candies>0){\\n            for(int i=0;i<num_people;i++){\\n                if(turn<candies){\\n                    l[i]+=turn;\\n                    candies-=turn;\\n                    turn+=1;\\n                }\\n                else if(candies>0){\\n                    l[i]+=candies;\\n                    candies-=candies;\\n                    break;\\n                }                \\n            }\\n        }\\n    return(l);\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector <int> l;\\n        int turn=1;\\n        for(int i=0;i<num_people;i++){\\n            l.push_back(0);    \\n        }\\n        while(candies>0){\\n            for(int i=0;i<num_people;i++){\\n                if(turn<candies){\\n                    l[i]+=turn;\\n                    candies-=turn;\\n                    turn+=1;\\n                }\\n                else if(candies>0){\\n                    l[i]+=candies;\\n                    candies-=candies;\\n                    break;\\n                }                \\n            }\\n        }\\n    return(l);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 788026,
                "title": "ruby-solution-while-loop-and-get-index-of-person-by-modulo-operation",
                "content": "##### Leetcode: 1103. Distribute Candies to People.\\n\\nCreate loop that iterates until there more than zero candies and two variables amount of candies to give and index, index grows on each iteration and amount grows too. To get index of person to add amount of candies modulo operation could be implemented or rest of division index variable by number of people. In each iteration delete amount from candies. If there less candies than amount for gift give all the rest of candies to a person.\\n\\nRuby code:\\n```Ruby\\n# Leetcode: 1103. Distribute Candies to People.\\n# https://leetcode.com/problems/distribute-candies-to-people/\\n# Runtime: 36 ms, faster than 85.71% of Ruby online submissions for Distribute Candies to People.\\n# Memory Usage: 9.7 MB, less than 14.29% of Ruby online submissions for Distribute Candies to People.\\n# @param {Integer} candies\\n# @param {Integer} num_people\\n# @return {Integer[]}\\ndef distribute_candies(candies, num_people)\\n    arr = Array.new(num_people,0)\\n    i,amount = 0,1\\n    while candies > 0\\n        if amount <= candies\\n            arr[i%num_people] += amount\\n            candies -= amount\\n            amount += 1\\n        else\\n            arr[i%num_people] += candies\\n            candies = 0\\n        end\\n        i += 1\\n    end\\n    arr\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```Ruby\\n# Leetcode: 1103. Distribute Candies to People.\\n# https://leetcode.com/problems/distribute-candies-to-people/\\n# Runtime: 36 ms, faster than 85.71% of Ruby online submissions for Distribute Candies to People.\\n# Memory Usage: 9.7 MB, less than 14.29% of Ruby online submissions for Distribute Candies to People.\\n# @param {Integer} candies\\n# @param {Integer} num_people\\n# @return {Integer[]}\\ndef distribute_candies(candies, num_people)\\n    arr = Array.new(num_people,0)\\n    i,amount = 0,1\\n    while candies > 0\\n        if amount <= candies\\n            arr[i%num_people] += amount\\n            candies -= amount\\n            amount += 1\\n        else\\n            arr[i%num_people] += candies\\n            candies = 0\\n        end\\n        i += 1\\n    end\\n    arr\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 694657,
                "title": "rust-simulate-distribute-processing-0ms",
                "content": "```Rust\\nimpl Solution {\\n    pub fn distribute_candies(candies: i32, num_people: i32) -> Vec<i32> {\\n        let mut res = vec![0; num_people as usize];\\n        let mut i = 0;\\n        let mut candies = candies;\\n        \\'outer: loop {\\n            for x in res.iter_mut() {\\n                i += 1;\\n                if candies < i {\\n                    *x += candies;\\n                    break \\'outer;\\n                } else {\\n                    candies -= i;\\n                    *x += i\\n                }\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Rust\\nimpl Solution {\\n    pub fn distribute_candies(candies: i32, num_people: i32) -> Vec<i32> {\\n        let mut res = vec![0; num_people as usize];\\n        let mut i = 0;\\n        let mut candies = candies;\\n        \\'outer: loop {\\n            for x in res.iter_mut() {\\n                i += 1;\\n                if candies < i {\\n                    *x += candies;\\n                    break \\'outer;\\n                } else {\\n                    candies -= i;\\n                    *x += i\\n                }\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 670471,
                "title": "c-solution",
                "content": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* distributeCandies(int candies, int num_people, int* returnSize){\\nint* ret_array = malloc(num_people * sizeof(int));\\nint count, person;\\nfor (count=0; count<num_people; count++) ret_array[count]=0;\\ncount=1;\\nperson=0;\\n*returnSize = num_people;\\n    \\n// Loop until all candies gone, adding one to what\\'s given to each,\\n// and resetting person back to 0 when you\\'ve gone through all of them.\\nwhile (true) {\\n    if (candies<=0) return ret_array;\\n    if (count>candies) count=candies;\\n    ret_array[person++] += count;\\n    candies -= count++;\\n    if (person==num_people) person=0;\\n}\\nreturn -1; // We should never get here, though\\n}\\n",
                "solutionTags": [],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* distributeCandies(int candies, int num_people, int* returnSize){\\nint* ret_array = malloc(num_people * sizeof(int));\\nint count, person;\\nfor (count=0; count<num_people; count++) ret_array[count]=0;\\ncount=1;\\nperson=0;\\n*returnSize = num_people;\\n    \\n// Loop until all candies gone, adding one to what\\'s given to each,\\n// and resetting person back to 0 when you\\'ve gone through all of them.\\nwhile (true) {\\n    if (candies<=0) return ret_array;\\n    if (count>candies) count=candies;\\n    ret_array[person++] += count;\\n    candies -= count++;\\n    if (person==num_people) person=0;\\n}\\nreturn -1; // We should never get here, though\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 659367,
                "title": "python3-28ms-beats-98-easy-iteration-solution",
                "content": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        res = [0] * num_people\\n        num = 1\\n        while candies > 0:\\n        \\tfor i in range(num_people):\\n        \\t\\tres[i] += num\\n        \\t\\tcandies -= num\\n        \\t\\tif candies <= 0:\\n        \\t\\t\\tres[i] -= abs(candies)\\n        \\t\\t\\tbreak\\n        \\t\\tnum += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        res = [0] * num_people\\n        num = 1\\n        while candies > 0:\\n        \\tfor i in range(num_people):\\n        \\t\\tres[i] += num\\n        \\t\\tcandies -= num\\n        \\t\\tif candies <= 0:\\n        \\t\\t\\tres[i] -= abs(candies)\\n        \\t\\t\\tbreak\\n        \\t\\tnum += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 629995,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number} candies\\n * @param {number} num_people\\n * @return {number[]}\\n */\\nvar distributeCandies = function(candies, num_people) {\\n    let i = 0;\\n    let ans = new Array(num_people).fill(0);\\n    while(candies - i > 0) {\\n        ans[i % num_people] += i+1;\\n        i++;\\n        candies -= i;\\n    }\\n    ans[i % num_people] += candies;\\n    return ans;\\n};",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} candies\\n * @param {number} num_people\\n * @return {number[]}\\n */\\nvar distributeCandies = function(candies, num_people) {\\n    let i = 0;\\n    let ans = new Array(num_people).fill(0);\\n    while(candies - i > 0) {\\n        ans[i % num_people] += i+1;\\n        i++;\\n        candies -= i;\\n    }\\n    ans[i % num_people] += candies;\\n    return ans;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 585008,
                "title": "c-one-loop-100-time-100-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int c, int n) {\\n        vector<int> ans(n);\\n        for (int i=1; c > 0; ++i){\\n            ans[(i-1)%n] += min(i, c);\\n            c -= i;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> distributeCandies(int c, int n) {\\n        vector<int> ans(n);\\n        for (int i=1; c > 0; ++i){\\n            ans[(i-1)%n] += min(i, c);\\n            c -= i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 529674,
                "title": "python3-easy-to-understand-time-81-memory-100",
                "content": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        res = [0] * num_people\\n        n = 1\\n        while candies:\\n            for i in range(num_people):\\n                res[i] += n\\n                candies -= n\\n                if candies < 0:\\n                    res[i] -= n\\n                    res[i] += n + candies\\n                    return res\\n            \\n                n += 1\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        res = [0] * num_people\\n        n = 1\\n        while candies:\\n            for i in range(num_people):\\n                res[i] += n\\n                candies -= n\\n                if candies < 0:\\n                    res[i] -= n\\n                    res[i] += n + candies\\n                    return res\\n            \\n                n += 1\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 487953,
                "title": "python-3-purely-math-98-100-super-fast",
                "content": "The math algorithm is:\\n1, find how many rows are fully filled (1 row means rounds of having candies distributed for everyone)\\n2, distribute the residue candies in a round:\\ncompute how many people can still get routine number\\nthere is one guy who can\\'t get routine number\\nothers have no candies\\n```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        full_row = int((-1 + math.sqrt(8*candies+1))/2/num_people)\\n        res = candies - full_row*num_people*(1+full_row*num_people)//2\\n        out = [j * full_row + (full_row-1) * full_row // 2 * num_people for j in range(1,num_people+1)]\\n        if res:\\n            full_col = int((-2*num_people*full_row-1+math.sqrt((2*num_people*full_row+1)**2 + 8*res))/2)\\n            res = res - (1+full_col)*full_col//2 - num_people * full_row * full_col\\n            out = [out[j-1] + j+ full_row * num_people for j in range(1,full_col+1)] + \\\\\\n                    [out[full_col]+res] + out[full_col+1:]      \\n        return out\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        full_row = int((-1 + math.sqrt(8*candies+1))/2/num_people)\\n        res = candies - full_row*num_people*(1+full_row*num_people)//2\\n        out = [j * full_row + (full_row-1) * full_row // 2 * num_people for j in range(1,num_people+1)]\\n        if res:\\n            full_col = int((-2*num_people*full_row-1+math.sqrt((2*num_people*full_row+1)**2 + 8*res))/2)\\n            res = res - (1+full_col)*full_col//2 - num_people * full_row * full_col\\n            out = [out[j-1] + j+ full_row * num_people for j in range(1,full_col+1)] + \\\\\\n                    [out[full_col]+res] + out[full_col+1:]      \\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 487353,
                "title": "without-min",
                "content": "Brute force but without the `min` call in every iteration. Instead, add the final (non-positive) number of cookies to the last person who got some. So a little less brute :-)\\n```\\npublic int[] distributeCandies(int c, int n) {\\n    int[] p = new int[n];\\n    int i = 0;\\n    while (c > 0) {\\n        p[i % n] += ++i;\\n        c -= i;\\n    }\\n    p[--i % n] += c;\\n    return p;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] distributeCandies(int c, int n) {\\n    int[] p = new int[n];\\n    int i = 0;\\n    while (c > 0) {\\n        p[i % n] += ++i;\\n        c -= i;\\n    }\\n    p[--i % n] += c;\\n    return p;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 478235,
                "title": "easy-understandable-c-solution",
                "content": "class Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        \\n        long int sum=0;\\n        vector < int > v(num_people,0);\\n        bool status=1;\\n        int  count=1;\\n        \\n        while(status)\\n        {\\n            for(int i=0;i<v.size();i++)\\n            {\\n                \\n            if(count+sum>candies)\\n            {\\n                v[i]+=candies-sum;\\n                status=0;\\n                break;\\n            }\\n                \\n                v[i]+=count;\\n                sum+=count++;\\n                \\n            }      \\n        }\\n        \\n        \\n        return v;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        \\n        long int sum=0;\\n        vector < int > v(num_people,0);\\n        bool status=1;\\n        int  count=1;\\n        \\n        while(status)\\n        {\\n            for(int i=0;i<v.size();i++)\\n            {\\n                \\n            if(count+sum>candies)\\n            {\\n                v[i]+=candies-sum;\\n                status=0;\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 456045,
                "title": "c-time-o-n-space-o-n",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> distributeCandies(int candies, \\n                                  int num_people) \\n    {\\n        vector<int> result(num_people, 0);\\n        \\n        int index = 0;        \\n        int count = 1;\\n        int sum = 0;\\n\\n        while(true)\\n        {             \\n            result[index] += count;\\n            \\n            // Keep accumulating the sum with the current count,\\n            // then update the counter.\\n            sum += (count++);\\n            \\n            // rotate index.\\n            index = (index +1) %num_people;\\n            \\n            // current accumulated sum cannot be bigger than the total candies\\n            // after adding the next counter value. No more next round if it is bigger.\\n            if((sum +count) >candies)\\n            {\\n                break;\\n            }\\n        }\\n        \\n        // Add the remaining candies to the last person.\\n        result[index] += (candies -sum);\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> distributeCandies(int candies, \\n                                  int num_people) \\n    {\\n        vector<int> result(num_people, 0);\\n        \\n        int index = 0;        \\n        int count = 1;\\n        int sum = 0;\\n\\n        while(true)\\n        {             \\n            result[index] += count;\\n            \\n            // Keep accumulating the sum with the current count,\\n            // then update the counter.\\n            sum += (count++);\\n            \\n            // rotate index.\\n            index = (index +1) %num_people;\\n            \\n            // current accumulated sum cannot be bigger than the total candies\\n            // after adding the next counter value. No more next round if it is bigger.\\n            if((sum +count) >candies)\\n            {\\n                break;\\n            }\\n        }\\n        \\n        // Add the remaining candies to the last person.\\n        result[index] += (candies -sum);\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 440742,
                "title": "java-faster-than-92-solution-with-comments",
                "content": "```\\npublic int[] distributeCandies(int candies, int num_people) {\\n\\tint i = 0;\\n\\tint j = 1;\\n\\tint[] arr = new int[num_people];\\n\\n\\twhile (candies > 0) {\\n\\t\\t// distribute candies and update values\\n\\t\\tarr[i++] += j;\\n\\t\\tcandies -= j;\\n\\n\\t\\t// check if we need to start from the first\\n\\t\\tif (i > num_people - 1)\\n\\t\\t\\ti = 0;\\n\\n\\t\\t// check if we have enough candies to increment j\\n\\t\\t// otherwise, assign remaining candies to j\\n\\t\\tj = (j + 1 <= candies) ? j + 1 : candies;\\n\\t}\\n\\treturn arr;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] distributeCandies(int candies, int num_people) {\\n\\tint i = 0;\\n\\tint j = 1;\\n\\tint[] arr = new int[num_people];\\n\\n\\twhile (candies > 0) {\\n\\t\\t// distribute candies and update values\\n\\t\\tarr[i++] += j;\\n\\t\\tcandies -= j;\\n\\n\\t\\t// check if we need to start from the first\\n\\t\\tif (i > num_people - 1)\\n\\t\\t\\ti = 0;\\n\\n\\t\\t// check if we have enough candies to increment j\\n\\t\\t// otherwise, assign remaining candies to j\\n\\t\\tj = (j + 1 <= candies) ? j + 1 : candies;\\n\\t}\\n\\treturn arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 399925,
                "title": "c-4ms-faster-than-64-38-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> ret(num_people);\\n        int sum=0,i=1;\\n        while((sum+i)<=candies){\\n            ret[(i-1)%num_people] += i;\\n            sum+=i;\\n            ++i;\\n        }\\n        if(sum!=candies)\\n            ret[(i-1)%num_people]+= candies-sum;\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> ret(num_people);\\n        int sum=0,i=1;\\n        while((sum+i)<=candies){\\n            ret[(i-1)%num_people] += i;\\n            sum+=i;\\n            ++i;\\n        }\\n        if(sum!=candies)\\n            ret[(i-1)%num_people]+= candies-sum;\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 394765,
                "title": "javascript-simple-beats-86",
                "content": "```\\nlet op = new Array(num_people).fill(0), i = 0, c = 1\\n\\nwhile (candies > 0) {\\n\\tif (candies <= c) c = candies\\n\\top[i] += c\\n\\tcandies -= c\\n\\ti = (i + 1) % num_people\\n\\tc++\\n}\\n\\nreturn op\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet op = new Array(num_people).fill(0), i = 0, c = 1\\n\\nwhile (candies > 0) {\\n\\tif (candies <= c) c = candies\\n\\top[i] += c\\n\\tcandies -= c\\n\\ti = (i + 1) % num_people\\n\\tc++\\n}\\n\\nreturn op\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 383068,
                "title": "python-sum-of-n-numbers-with-binary-search-with-thought-process",
                "content": "So the idea is:\\n1. Find how many times we can distribute the candies to all `num_people` i.e.\\n\\t```python\\n\\tgc = 0 # Start with zeroth round\\n\\ttarget = (num_people * (num_people+1))//2 # Number of candies required for zeroth round \\n\\twhile target <= candies:\\n\\t\\tfor i in range(num_people):\\n\\t\\t\\tres[i] += (gc * num_people) + (i + 1)\\n\\n\\t\\tgc += 1\\n\\t\\tcandies -= target\\n\\t\\t# Now for next round the target will change e.g.\\n\\t\\t# For n = 3, for first round distribution, we need (n*(n+1))/2\\n\\t\\t# but for second round, every person will need n i.e. 3 extra candies, so overall n**2 extra candies\\n\\t\\ttarget += num_people ** 2\\n\\t```\\n2. Now, after step one, we will be left with candies which can\\'t be distributed equally to all n people, so the idea to to use binary search to find the index till when we can continue distributing the required amout of candies. Once we have that index, we can distribute the candies till `i`th person in required fashion and give remaining candies to the `(i+1)`th person. i.e.\\n\\t```\\n\\tif candies:\\n            offset = num_people * gc # We need this offset to indicated that we in some xth distribution round and we need this much extra candies for each person in comparison of zeroth round.\\n            r = binarySearch(0, num_people, candies, offset)\\n            for i in range(r):\\n                curr = offset + (i + 1)\\n                res[i] += curr\\n                candies -= curr\\n                \\n            if candies:\\n                res[i] += candies\\n\\t```\\n\\t\\nFull Soultion here:\\n```python\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        gc = 0\\n        res = [0] * num_people\\n        \\n        def binarySearch(l, r, candies, offset):\\n            while l <= r:\\n                mid = (l + r)//2\\n                \\n                n_sum = (mid * (mid+1))//2\\n                n_sum += offset * mid\\n                if n_sum == candies:\\n                    return mid\\n                elif n_sum < candies:\\n                    l = mid + 1\\n                else:\\n                    r = mid - 1\\n            \\n            return l\\n        \\n        target = (num_people * (num_people+1))//2 \\n        while target <= candies:\\n            for i in range(num_people):\\n                res[i] += (gc * num_people) + (i + 1)\\n                \\n            gc += 1\\n            candies -= target\\n            target += num_people * num_people\\n\\n        if candies:\\n            offset = num_people * gc\\n            r = binarySearch(0, num_people, candies, offset)\\n            for i in range(r):\\n                curr = offset + (i + 1)\\n                res[i] += curr\\n                candies -= curr\\n                \\n            if candies:\\n                res[i] += candies\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Math",
                    "Binary Search"
                ],
                "code": "```python\\n\\tgc = 0 # Start with zeroth round\\n\\ttarget = (num_people * (num_people+1))//2 # Number of candies required for zeroth round \\n\\twhile target <= candies:\\n\\t\\tfor i in range(num_people):\\n\\t\\t\\tres[i] += (gc * num_people) + (i + 1)\\n\\n\\t\\tgc += 1\\n\\t\\tcandies -= target\\n\\t\\t# Now for next round the target will change e.g.\\n\\t\\t# For n = 3, for first round distribution, we need (n*(n+1))/2\\n\\t\\t# but for second round, every person will need n i.e. 3 extra candies, so overall n**2 extra candies\\n\\t\\ttarget += num_people ** 2\\n\\t```\n```\\n\\tif candies:\\n            offset = num_people * gc # We need this offset to indicated that we in some xth distribution round and we need this much extra candies for each person in comparison of zeroth round.\\n            r = binarySearch(0, num_people, candies, offset)\\n            for i in range(r):\\n                curr = offset + (i + 1)\\n                res[i] += curr\\n                candies -= curr\\n                \\n            if candies:\\n                res[i] += candies\\n\\t```\n```python\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        gc = 0\\n        res = [0] * num_people\\n        \\n        def binarySearch(l, r, candies, offset):\\n            while l <= r:\\n                mid = (l + r)//2\\n                \\n                n_sum = (mid * (mid+1))//2\\n                n_sum += offset * mid\\n                if n_sum == candies:\\n                    return mid\\n                elif n_sum < candies:\\n                    l = mid + 1\\n                else:\\n                    r = mid - 1\\n            \\n            return l\\n        \\n        target = (num_people * (num_people+1))//2 \\n        while target <= candies:\\n            for i in range(num_people):\\n                res[i] += (gc * num_people) + (i + 1)\\n                \\n            gc += 1\\n            candies -= target\\n            target += num_people * num_people\\n\\n        if candies:\\n            offset = num_people * gc\\n            r = binarySearch(0, num_people, candies, offset)\\n            for i in range(r):\\n                curr = offset + (i + 1)\\n                res[i] += curr\\n                candies -= curr\\n                \\n            if candies:\\n                res[i] += candies\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 380564,
                "title": "easy-concise-c-solution-0ms-beats-100",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Distribute Candies to People.\\nMemory Usage: 8.5 MB, less than 100.00% of C++ online submissions for Distribute Candies to People.\\n\\n```\\nvector<int> distributeCandies(int candies, int num_people) {\\n        \\n        vector<int> res(num_people, 0);\\n        int i = 0;\\n        int k = 1;\\n        \\n        while(candies > 0)\\n        {\\n            if(candies < k)\\n            {\\n                res[i] += candies;\\n                break;\\n            }\\n            \\n            res[i] += k;\\n            candies -= k;\\n            \\n            if(i == num_people-1)\\n                i = 0;\\n            else\\n                i++;\\n            k++;\\n        }\\n        \\n        return res;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Distribute Candies to People.\\nMemory Usage: 8.5 MB, less than 100.00% of C++ online submissions for Distribute Candies to People.\\n\\n```\\nvector<int> distributeCandies(int candies, int num_people) {\\n        \\n        vector<int> res(num_people, 0);\\n        int i = 0;\\n        int k = 1;\\n        \\n        while(candies > 0)\\n        {\\n            if(candies < k)\\n            {\\n                res[i] += candies;\\n                break;\\n            }\\n            \\n            res[i] += k;\\n            candies -= k;\\n            \\n            if(i == num_people-1)\\n                i = 0;\\n            else\\n                i++;\\n            k++;\\n        }\\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 374940,
                "title": "java-1ms-quick-solution",
                "content": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] res = new int[num_people];\\n        int i = 0;\\n        int count = 1;\\n        while (candies > 0){\\n            res[i] += Math.min(count, candies);\\n            candies -= count;\\n            count++;\\n            i++;\\n            i = i % num_people;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] res = new int[num_people];\\n        int i = 0;\\n        int count = 1;\\n        while (candies > 0){\\n            res[i] += Math.min(count, candies);\\n            candies -= count;\\n            count++;\\n            i++;\\n            i = i % num_people;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361961,
                "title": "golang-beginner-solution",
                "content": "```\\nfunc distributeCandies(candies int, num_people int) []int {\\n\\tresult := make([]int, num_people)\\n\\tpidx := 0\\n\\tctr := 1\\n\\tfor candies > 0 {\\n\\t\\t// fmt.Println(pidx, candies, ctr)\\n\\t\\tif pidx == num_people {\\n\\t\\t\\tpidx = 0\\n\\t\\t}\\n\\t\\tif candies < ctr {\\n\\t\\t\\tresult[pidx] += candies\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tresult[pidx] += ctr\\n\\t\\tcandies -= ctr\\n\\t\\tctr++\\n\\t\\tpidx++\\n\\t}\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc distributeCandies(candies int, num_people int) []int {\\n\\tresult := make([]int, num_people)\\n\\tpidx := 0\\n\\tctr := 1\\n\\tfor candies > 0 {\\n\\t\\t// fmt.Println(pidx, candies, ctr)\\n\\t\\tif pidx == num_people {\\n\\t\\t\\tpidx = 0\\n\\t\\t}\\n\\t\\tif candies < ctr {\\n\\t\\t\\tresult[pidx] += candies\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tresult[pidx] += ctr\\n\\t\\tcandies -= ctr\\n\\t\\tctr++\\n\\t\\tpidx++\\n\\t}\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 358972,
                "title": "kotlin-runtime-148-ms-memory-usage-31-8-mb",
                "content": "```\\nfun distributeCandies(candies: Int, num_people: Int): IntArray {\\n    val distrArray = IntArray(num_people)\\n    var accumulator = 0 // candies accumulator per person\\n    var index = 0   // distribution index\\n    var mCandies = candies // val can\\'t be reassigned\\n\\n    while (mCandies > accumulator++) {\\n        distrArray[index++ % num_people] += accumulator // ensure index is in num_people scope using mod\\n        mCandies -= accumulator\\n    }\\n    return if (mCandies > 0) {\\n        distrArray[index % num_people] += mCandies\\n        distrArray\\n    } else distrArray\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfun distributeCandies(candies: Int, num_people: Int): IntArray {\\n    val distrArray = IntArray(num_people)\\n    var accumulator = 0 // candies accumulator per person\\n    var index = 0   // distribution index\\n    var mCandies = candies // val can\\'t be reassigned\\n\\n    while (mCandies > accumulator++) {\\n        distrArray[index++ % num_people] += accumulator // ensure index is in num_people scope using mod\\n        mCandies -= accumulator\\n    }\\n    return if (mCandies > 0) {\\n        distrArray[index % num_people] += mCandies\\n        distrArray\\n    } else distrArray\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 325796,
                "title": "javascript-solution-understandable",
                "content": "```\\nvar distributeCandies = function(candies, num_people) {\\n    let result = new Array(num_people).fill(0);\\n    for(let give=0; candies>0; candies-=give){\\n        result[give%num_people] += Math.min(candies, ++give);\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar distributeCandies = function(candies, num_people) {\\n    let result = new Array(num_people).fill(0);\\n    for(let give=0; candies>0; candies-=give){\\n        result[give%num_people] += Math.min(candies, ++give);\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 325345,
                "title": "two-python-solutions-brute-force-and-mathematical",
                "content": "Brute Force: just translate the problem into code\\n```\\nclass Solution:\\n    def distributeCandies(self, candies, num_people):\\n        idx, cur, total = 0, 1, 0;\\n        res = [0] * num_people;\\n        while(total + cur <= candies):\\n            res[idx] += cur;\\n            idx = (idx + 1) % num_people;\\n            total += cur;\\n            cur += 1;\\n        if(total != candies): res[idx] += (candies - total);\\n        return res;\\n```\\n\\nMathematical: calculate how many turns the index will be iterated through\\n```\\nimport math;\\nclass Solution:\\n    def distributeCandies(self, candies, num_people):\\n        res = [0] * num_people;\\n        tact_num = int((math.sqrt(1 + 8 * candies) - 1) / 2);\\n        tact_turn = tact_num // num_people;\\n        total = (1 + tact_num) * tact_num // 2;\\n        for i in range(num_people):\\n            turn = tact_turn + 1 if(tact_num % num_people > i) else tact_turn;\\n            res[i] = int((i + 1) * turn + 0.5 * turn * (turn - 1) * num_people);\\n        res[tact_num % num_people] += (candies - total);\\n        return res;\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies, num_people):\\n        idx, cur, total = 0, 1, 0;\\n        res = [0] * num_people;\\n        while(total + cur <= candies):\\n            res[idx] += cur;\\n            idx = (idx + 1) % num_people;\\n            total += cur;\\n            cur += 1;\\n        if(total != candies): res[idx] += (candies - total);\\n        return res;\\n```\n```\\nimport math;\\nclass Solution:\\n    def distributeCandies(self, candies, num_people):\\n        res = [0] * num_people;\\n        tact_num = int((math.sqrt(1 + 8 * candies) - 1) / 2);\\n        tact_turn = tact_num // num_people;\\n        total = (1 + tact_num) * tact_num // 2;\\n        for i in range(num_people):\\n            turn = tact_turn + 1 if(tact_num % num_people > i) else tact_turn;\\n            res[i] = int((i + 1) * turn + 0.5 * turn * (turn - 1) * num_people);\\n        res[tact_num % num_people] += (candies - total);\\n        return res;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 325108,
                "title": "java-0ms-o-n-solution-using-gauss-formula",
                "content": "Here is a solution that uses Gauss\\' formula for calculating sum of a series.\\nShould take O(2*num_people) time.\\n\\n```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] r = new int[num_people];\\n        \\n\\t\\t// find number of people that could get candies if just kept handing them over to new person each time\\n        int x = (int)Math.round((1. + Math.sqrt(1. + 4. * candies)) / 2.);\\n\\t\\t\\n\\t\\t// find number of full passes we can do over array of num_people\\n        int fullRows = x / num_people;\\n        \\n\\t\\t// for each person in the array give them all the candies they can get when only doing full array passes\\n        for (int i = 0; i < num_people; i++) {\\n            r[i] = (fullRows * (2 * (i + 1) + (fullRows - 1) * num_people)) / 2;\\n        }\\n        \\n\\t\\t// how many candie giving actions were just performed if we did those separately without summing\\n        int dist_pos = fullRows * num_people;\\n        \\n\\t\\t// calculate remaining candies to be distributed\\n        candies -= dist_pos*(dist_pos + 1) / 2;\\n        \\n\\t\\t// figure out the number of candies that we gave to last person\\n        int last = fullRows > 0 ? (r[num_people - 1] - ((fullRows - 1) * (2 * (num_people) + (fullRows - 2) * num_people)) / 2) : 0;\\n\\n\\t\\t// distribute all the remaining candies\\n\\t\\t// need while here because there can be less candies than we would usually give to a person\\n        while (candies > 0) {\\n            for (int i = 0; i < num_people; i++) {\\n                int n = Math.min(candies, last + 1);\\n\\n                if (n == 0) {\\n                    break;\\n                }\\n\\n                candies -= n;\\n                r[i] += n;\\n                last++;\\n            }\\n        }\\n\\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] r = new int[num_people];\\n        \\n\\t\\t// find number of people that could get candies if just kept handing them over to new person each time\\n        int x = (int)Math.round((1. + Math.sqrt(1. + 4. * candies)) / 2.);\\n\\t\\t\\n\\t\\t// find number of full passes we can do over array of num_people\\n        int fullRows = x / num_people;\\n        \\n\\t\\t// for each person in the array give them all the candies they can get when only doing full array passes\\n        for (int i = 0; i < num_people; i++) {\\n            r[i] = (fullRows * (2 * (i + 1) + (fullRows - 1) * num_people)) / 2;\\n        }\\n        \\n\\t\\t// how many candie giving actions were just performed if we did those separately without summing\\n        int dist_pos = fullRows * num_people;\\n        \\n\\t\\t// calculate remaining candies to be distributed\\n        candies -= dist_pos*(dist_pos + 1) / 2;\\n        \\n\\t\\t// figure out the number of candies that we gave to last person\\n        int last = fullRows > 0 ? (r[num_people - 1] - ((fullRows - 1) * (2 * (num_people) + (fullRows - 2) * num_people)) / 2) : 0;\\n\\n\\t\\t// distribute all the remaining candies\\n\\t\\t// need while here because there can be less candies than we would usually give to a person\\n        while (candies > 0) {\\n            for (int i = 0; i < num_people; i++) {\\n                int n = Math.min(candies, last + 1);\\n\\n                if (n == 0) {\\n                    break;\\n                }\\n\\n                candies -= n;\\n                r[i] += n;\\n                last++;\\n            }\\n        }\\n\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 324770,
                "title": "python-3",
                "content": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, n: int) -> List[int]:\\n        li, i = [0] * n, 1\\n        while candies > 0: \\n            li[(i-1)%n] += min(i, candies)\\n            candies, i = candies-i, i+1\\n        return li\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, n: int) -> List[int]:\\n        li, i = [0] * n, 1\\n        while candies > 0: \\n            li[(i-1)%n] += min(i, candies)\\n            candies, i = candies-i, i+1\\n        return li\\n```",
                "codeTag": "Java"
            },
            {
                "id": 324101,
                "title": "faster-than-100-and-memory-less-than-100-python-simple-solution",
                "content": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        \\n        ans = [0]*num_people\\n        i = 0\\n        k = 1\\n        while True:\\n        \\n            if candies-k <= 0:\\n                ans[i] += candies\\n                break\\n            else:\\n                ans[i] += k\\n                candies -= k\\n                k+=1\\n                i+=1\\n                if i == num_people:\\n                    i = 0\\n                    \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        \\n        ans = [0]*num_people\\n        i = 0\\n        k = 1\\n        while True:\\n        \\n            if candies-k <= 0:\\n                ans[i] += candies\\n                break\\n            else:\\n                ans[i] += k\\n                candies -= k\\n                k+=1\\n                i+=1\\n                if i == num_people:\\n                    i = 0\\n                    \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 324057,
                "title": "java-simulation-o-sqrt-n-beats-100",
                "content": "We are simulating each step of distribution. For each iteration increment the number of candies to give to a next person and also calculate the index of that person in the array. Lastly decrement number of candies left by number of candies we gave.\\nComplexities: time is O(sqrt(candies)) - on each step the number of candies left will be decreasing proportional to sqrt(). Space - O(1) - just few state variables, am excluding resulting array from analysis. \\n```\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] res = new int[num_people];\\n        int idx = 0;\\n        int c = 1;\\n        \\n        while(candies > 0) {\\n            //num of candies to distribute on this step. Need to check if we have enough, otherwise\\n            //use the remainder of candies\\n            res[idx] += (c < candies) ? c : candies;\\n            //next person - need to start from 0 if it was a last one\\n            idx = (idx == num_people - 1) ? 0 : idx + 1;\\n            //decrement number of candies left\\n            candies -= c++;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Simulation"
                ],
                "code": "```\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] res = new int[num_people];\\n        int idx = 0;\\n        int c = 1;\\n        \\n        while(candies > 0) {\\n            //num of candies to distribute on this step. Need to check if we have enough, otherwise\\n            //use the remainder of candies\\n            res[idx] += (c < candies) ? c : candies;\\n            //next person - need to start from 0 if it was a last one\\n            idx = (idx == num_people - 1) ? 0 : idx + 1;\\n            //decrement number of candies left\\n            candies -= c++;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 324015,
                "title": "simple-and-and-efficient-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {        \\n        int[] distribution = new int[num_people];\\n        int current = 1;\\n        while(candies > 0){\\n            for(int i = 0; i < num_people; i++){\\n                if(candies - current >= 0){\\n                    distribution[i] += current;\\n                    candies = candies - current;\\n                    current += 1;\\n                }\\n                else if(candies > 0){\\n                    distribution[i] += candies;\\n                    candies -= candies;                    \\n                }\\n                else break;                \\n            }                \\n        }\\n        return distribution;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {        \\n        int[] distribution = new int[num_people];\\n        int current = 1;\\n        while(candies > 0){\\n            for(int i = 0; i < num_people; i++){\\n                if(candies - current >= 0){\\n                    distribution[i] += current;\\n                    candies = candies - current;\\n                    current += 1;\\n                }\\n                else if(candies > 0){\\n                    distribution[i] += candies;\\n                    candies -= candies;                    \\n                }\\n                else break;                \\n            }                \\n        }\\n        return distribution;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323872,
                "title": "0ms-go-solution",
                "content": "func distributeCandies(candies int, num_people int) []int {\\n\\tif num_people <= 0 {\\n\\t\\treturn []int{}\\n\\t}\\n\\n\\tvar out = make([]int, num_people)\\n\\n\\tif candies <= 0 {\\n\\t\\treturn out\\n\\t}\\n\\n\\tvar equ bool\\n\\tvar N = num_people\\n\\tvar count = 1\\n\\tvar flag = 1\\n\\tvar a, b int\\n\\tfor {\\n\\t\\tfmt.Println((N + count) * num_people / 2)\\n\\t\\tif (N+count)*num_people/2 > candies {\\n\\t\\t\\tequ = false\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tif (N+count)*num_people/2 == candies {\\n\\t\\t\\tequ = true\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tflag++\\n\\t\\ta, b = count, N\\n\\t\\tcount = count + (flag-1)*num_people + 1\\n\\t\\tN = N + (flag-1)*num_people + num_people\\n\\t}\\n\\n\\tif !equ && a != 0 {\\n\\t\\tflag--\\n\\t}\\n\\tif a == 0 || equ {\\n\\t\\ta, b = count, N\\n\\t}\\n\\n\\tvar can = candies\\n\\tvar i = 0\\n\\tvar k = a\\n\\n\\tfor i < num_people {\\n\\t\\tif k <= can {\\n\\t\\t\\tout[i] = k\\n\\t\\t}\\n\\t\\tif k > can {\\n\\t\\t\\tout[i] = can\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tcan -= k\\n\\t\\tk += flag\\n\\t\\ti++\\n\\t}\\n\\n\\tif can <= 0 && (equ == true || flag == 1) {\\n\\t\\tfmt.Println(out)\\n\\t\\treturn out\\n\\t}\\n\\n\\tcan = candies - (a+b)*num_people/2\\n\\ti = 0\\n\\n\\tci := count - out[0]\\n\\tfor can >= 0 {\\n\\t\\tif can <= ci {\\n\\t\\t\\tout[i] += can\\n\\t\\t}\\n\\t\\tif can > ci {\\n\\t\\t\\tout[i] += ci\\n\\t\\t}\\n\\t\\ti++\\n\\t\\tcan -= ci\\n\\t\\tci++\\n\\t}\\n\\n\\tfmt.Println(out)\\n\\treturn out\\n}",
                "solutionTags": [],
                "code": "func distributeCandies(candies int, num_people int) []int {\\n\\tif num_people <= 0 {\\n\\t\\treturn []int{}\\n\\t}\\n\\n\\tvar out = make([]int, num_people)\\n\\n\\tif candies <= 0 {\\n\\t\\treturn out\\n\\t}\\n\\n\\tvar equ bool\\n\\tvar N = num_people\\n\\tvar count = 1\\n\\tvar flag = 1\\n\\tvar a, b int\\n\\tfor {\\n\\t\\tfmt.Println((N + count) * num_people / 2)\\n\\t\\tif (N+count)*num_people/2 > candies {\\n\\t\\t\\tequ = false\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tif (N+count)*num_people/2 == candies {\\n\\t\\t\\tequ = true\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tflag++\\n\\t\\ta, b = count, N\\n\\t\\tcount = count + (flag-1)*num_people + 1\\n\\t\\tN = N + (flag-1)*num_people + num_people\\n\\t}\\n\\n\\tif !equ && a != 0 {\\n\\t\\tflag--\\n\\t}\\n\\tif a == 0 || equ {\\n\\t\\ta, b = count, N\\n\\t}\\n\\n\\tvar can = candies\\n\\tvar i = 0\\n\\tvar k = a\\n\\n\\tfor i < num_people {\\n\\t\\tif k <= can {\\n\\t\\t\\tout[i] = k\\n\\t\\t}\\n\\t\\tif k > can {\\n\\t\\t\\tout[i] = can\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tcan -= k\\n\\t\\tk += flag\\n\\t\\ti++\\n\\t}\\n\\n\\tif can <= 0 && (equ == true || flag == 1) {\\n\\t\\tfmt.Println(out)\\n\\t\\treturn out\\n\\t}\\n\\n\\tcan = candies - (a+b)*num_people/2\\n\\ti = 0\\n\\n\\tci := count - out[0]\\n\\tfor can >= 0 {\\n\\t\\tif can <= ci {\\n\\t\\t\\tout[i] += can\\n\\t\\t}\\n\\t\\tif can > ci {\\n\\t\\t\\tout[i] += ci\\n\\t\\t}\\n\\t\\ti++\\n\\t\\tcan -= ci\\n\\t\\tci++\\n\\t}\\n\\n\\tfmt.Println(out)\\n\\treturn out\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 323722,
                "title": "javascript-100-time-100-space-not-brute-force",
                "content": "This approach attempts to reduce the number of iterations required by brute force for large candy counts. I\\'d like to compare the complexity with the brute froce approach, but I\\'m not certain what the complexity of this algorithm is due to the first loop - it depends on the ratio of candies to people. The last two loops are O(people).\\n\\n```javascript\\n/**\\n * @param {number} candies The number of candies to distribute.\\n * @param {number} p The number of people to receive candies.\\n * @return {number[]}\\n */\\nvar distributeCandies = function(candies, p) {\\n  let numFullRows = 0;\\n  \\n  /**\\n   * Determine the number of full rows. This is\\n   * done by calculating the number of candies\\n   * required by n rows. When the required number\\n   * of candies is greater than the number of\\n   * candies we have, the loop is exited and we\\n   * know the number of full rows is one less than\\n   * the number of full rows from the last\\n   * iteration of the loop (hence --numFullRows).\\n   */\\n  let max = 0;\\n  let k = 0;\\n  while (max <= candies) {\\n    ++numFullRows;\\n    max = p * k * p + numFullRows * ((p * (p + 1)) / 2);\\n    k += numFullRows;\\n  }\\n  --numFullRows;\\n  \\n  /**\\n   * Now that the number of full rows is known,\\n   * it can be calculated that each person is\\n   * guaranteed to receive a certain number of\\n   * candies. I\\'ll call this amount \"base\".\\n   * Calculating it now, instead of for every\\n   * person, will save a little time in the next\\n   * loop.\\n   */\\n  let base = 0;\\n  for (let i = 1; i < numFullRows; ++i) {\\n    base += i * p;\\n  }\\n  \\n  /**\\n   * Initialize the result array with all\\n   * completed rows. For each i = 1 ... p,\\n   * this is: base + i * numFullRows.\\n   *\\n   * This loop is not combined with the last loop\\n   * because the last loop needs an accurate count\\n   * of remaining candies for the (potentially)\\n   * partial last row.\\n   */\\n  let result = [];\\n  for (let i = 1; i <= p; ++i) {\\n    let count = base + i * numFullRows;\\n    candies -= count;\\n    result.push(count);\\n  }\\n  \\n  /**\\n   * Fill in the remaining number of candies\\n   * from left to right. The number of candies\\n   * to give the i-th person during the n-th\\n   * pass is: 1 + (p * (n - 1)) + i. numFullRows\\n   * already represents n - 1, so we use it\\n   * instead.\\n   */\\n  let i = 0;\\n  while (candies > 0) {\\n    let top = 1 + (p * numFullRows) + i;\\n    if (top > candies) top = candies;\\n    result[i++] += top;\\n    candies -= top;\\n  }\\n  \\n  return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\n/**\\n * @param {number} candies The number of candies to distribute.\\n * @param {number} p The number of people to receive candies.\\n * @return {number[]}\\n */\\nvar distributeCandies = function(candies, p) {\\n  let numFullRows = 0;\\n  \\n  /**\\n   * Determine the number of full rows. This is\\n   * done by calculating the number of candies\\n   * required by n rows. When the required number\\n   * of candies is greater than the number of\\n   * candies we have, the loop is exited and we\\n   * know the number of full rows is one less than\\n   * the number of full rows from the last\\n   * iteration of the loop (hence --numFullRows).\\n   */\\n  let max = 0;\\n  let k = 0;\\n  while (max <= candies) {\\n    ++numFullRows;\\n    max = p * k * p + numFullRows * ((p * (p + 1)) / 2);\\n    k += numFullRows;\\n  }\\n  --numFullRows;\\n  \\n  /**\\n   * Now that the number of full rows is known,\\n   * it can be calculated that each person is\\n   * guaranteed to receive a certain number of\\n   * candies. I\\'ll call this amount \"base\".\\n   * Calculating it now, instead of for every\\n   * person, will save a little time in the next\\n   * loop.\\n   */\\n  let base = 0;\\n  for (let i = 1; i < numFullRows; ++i) {\\n    base += i * p;\\n  }\\n  \\n  /**\\n   * Initialize the result array with all\\n   * completed rows. For each i = 1 ... p,\\n   * this is: base + i * numFullRows.\\n   *\\n   * This loop is not combined with the last loop\\n   * because the last loop needs an accurate count\\n   * of remaining candies for the (potentially)\\n   * partial last row.\\n   */\\n  let result = [];\\n  for (let i = 1; i <= p; ++i) {\\n    let count = base + i * numFullRows;\\n    candies -= count;\\n    result.push(count);\\n  }\\n  \\n  /**\\n   * Fill in the remaining number of candies\\n   * from left to right. The number of candies\\n   * to give the i-th person during the n-th\\n   * pass is: 1 + (p * (n - 1)) + i. numFullRows\\n   * already represents n - 1, so we use it\\n   * instead.\\n   */\\n  let i = 0;\\n  while (candies > 0) {\\n    let top = 1 + (p * numFullRows) + i;\\n    if (top > candies) top = candies;\\n    result[i++] += top;\\n    candies -= top;\\n  }\\n  \\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 323534,
                "title": "c-binary-search-solution-0-ms-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> res(num_people);\\n        if(candies < 0 || num_people<=0){\\n            return res;\\n        }\\n        long long int l = 0, r = 100000;\\n        long long int ans=0;\\n        while(l<=r){\\n            long long int m = (l+r)/2;\\n            long long int sum = m*num_people;\\n            sum=sum*(sum+1)/2;\\n            if(sum>candies){\\n                r=m-1;\\n            }\\n            else{\\n                ans=m;\\n                l=m+1;\\n            }\\n        }\\n        for(int i=0;i<num_people;i++){\\n            long long int temp = ans*(2*(i+1)+(ans-1)*num_people)/2;\\n            res[i]=temp;\\n        }\\n        long long int rem = ans*num_people;\\n        rem = rem*(rem+1)/2;\\n        rem = candies - rem;\\n        for(int i=0;i<num_people and rem>0;i++){\\n            res[i] += min((ans)*num_people+(i+1), rem);\\n            rem-=(ans)*num_people+(i+1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> res(num_people);\\n        if(candies < 0 || num_people<=0){\\n            return res;\\n        }\\n        long long int l = 0, r = 100000;\\n        long long int ans=0;\\n        while(l<=r){\\n            long long int m = (l+r)/2;\\n            long long int sum = m*num_people;\\n            sum=sum*(sum+1)/2;\\n            if(sum>candies){\\n                r=m-1;\\n            }\\n            else{\\n                ans=m;\\n                l=m+1;\\n            }\\n        }\\n        for(int i=0;i<num_people;i++){\\n            long long int temp = ans*(2*(i+1)+(ans-1)*num_people)/2;\\n            res[i]=temp;\\n        }\\n        long long int rem = ans*num_people;\\n        rem = rem*(rem+1)/2;\\n        rem = candies - rem;\\n        for(int i=0;i<num_people and rem>0;i++){\\n            res[i] += min((ans)*num_people+(i+1), rem);\\n            rem-=(ans)*num_people+(i+1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323384,
                "title": "straightforward-python-solution",
                "content": "```\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        arr = num_people * [0]\\n        i = 0\\n        while candies > 0:\\n            if candies >= i + 1:\\n                arr[i % num_people] += i + 1\\n                candies -= i + 1\\n            else:\\n                arr[i % num_people] += candies\\n                break\\n            i += 1\\n        return arr\\n```",
                "solutionTags": [],
                "code": "```\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        arr = num_people * [0]\\n        i = 0\\n        while candies > 0:\\n            if candies >= i + 1:\\n                arr[i % num_people] += i + 1\\n                candies -= i + 1\\n            else:\\n                arr[i % num_people] += candies\\n                break\\n            i += 1\\n        return arr\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 323319,
                "title": "python-math-faster-than-brute-force-and-sqrt-candies",
                "content": "We first calculate how many (maximum) `turns` can we hand out candies such that every people get candies in this turn.\\nThen if we still have candies, give them out starting from the first person.\\n\\nThe time complexity is faster than brute force.\\n`T(brute_force) = O(#gives_out) = O(#people * #turns)`\\n`T(math_solution) = O(#turns + #people) > T(brute_force)`\\n\\nThe time complexity of brute force can also be denoted as `sqrt(#candies)` because `O(#candies) = O(1 + 2 + ... + #gives_out) = O(#gives_out^2)`.\\n\\n```\\nclass Solution(object):\\n    def distributeCandies(self, candies, n):\\n        res = [0] * n\\n        base = (1 + n) * n / 2\\n        total = turns = 0\\n        while total + base < candies:\\n            total += base\\n            base += n * n\\n            turns += 1\\n\\t\\tfor i in xrange(len(res)):\\n\\t\\t\\tres[i] = turns * (i + 1) + n * (turns - 1) * turns / 2\\n        k = turns * n\\n        i = 0\\n        distributed = sum(res)\\n        while distributed < candies:\\n            k += 1\\n            res[i] += min(k, candies - distributed)\\n            distributed += k\\n            i += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def distributeCandies(self, candies, n):\\n        res = [0] * n\\n        base = (1 + n) * n / 2\\n        total = turns = 0\\n        while total + base < candies:\\n            total += base\\n            base += n * n\\n            turns += 1\\n\\t\\tfor i in xrange(len(res)):\\n\\t\\t\\tres[i] = turns * (i + 1) + n * (turns - 1) * turns / 2\\n        k = turns * n\\n        i = 0\\n        distributed = sum(res)\\n        while distributed < candies:\\n            k += 1\\n            res[i] += min(k, candies - distributed)\\n            distributed += k\\n            i += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323316,
                "title": "c-share-my-solution-time-complexity-is-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> r(num_people,0);\\n        int idx=0;\\n        while(candies>0){\\n            if(candies-idx-1<0)\\n                r[idx%num_people]+=candies,candies=0;\\n            else\\n                r[idx%num_people]+=idx+1,candies-=idx+1;\\n            idx++;\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> r(num_people,0);\\n        int idx=0;\\n        while(candies>0){\\n            if(candies-idx-1<0)\\n                r[idx%num_people]+=candies,candies=0;\\n            else\\n                r[idx%num_people]+=idx+1,candies-=idx+1;\\n            idx++;\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323296,
                "title": "python-brute-force-simulation",
                "content": "In a brute force way, distribute the candies to each person in round robin fashion.\\n\\n```\\n    def distributeCandies(self, candies: int, n: int) -> List[int]:\\n        res = [0] * n\\n        i = 0\\n        cur = 1\\n        while candies >= cur:\\n            res[i] += cur\\n            candies -= cur\\n            cur += 1\\n            i = (i + 1) % n\\n        res[i] += candies\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def distributeCandies(self, candies: int, n: int) -> List[int]:\\n        res = [0] * n\\n        i = 0\\n        cur = 1\\n        while candies >= cur:\\n            res[i] += cur\\n            candies -= cur\\n            cur += 1\\n            i = (i + 1) % n\\n        res[i] += candies\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4096589,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] DistributeCandies(int candies, int num_people) {\\n        int i=1,k=0,j=0;\\n        int[] result=new int[num_people];\\n        while(k+i<candies){\\n            for(j=0;(k+i)<candies && j<num_people;j++){\\n                result[j]+= i;\\n                k+=i;\\n                i++;\\n            }\\n        }\\n        if(j==num_people)\\n            j=0;\\n\\n        result[j] += candies-k;\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] DistributeCandies(int candies, int num_people) {\\n        int i=1,k=0,j=0;\\n        int[] result=new int[num_people];\\n        while(k+i<candies){\\n            for(j=0;(k+i)<candies && j<num_people;j++){\\n                result[j]+= i;\\n                k+=i;\\n                i++;\\n            }\\n        }\\n        if(j==num_people)\\n            j=0;\\n\\n        result[j] += candies-k;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4096283,
                "title": "beats-99-8-percent-in-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        child = [0]*num_people\\n        index = 0\\n        candy = 1\\n        while candies >0:\\n            if candies < candy :\\n                candy = candies\\n            child[index] += candy \\n            candies -= candy\\n            candy +=1\\n            index +=1\\n            if index  == num_people:\\n                index = 0\\n        return child\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        child = [0]*num_people\\n        index = 0\\n        candy = 1\\n        while candies >0:\\n            if candies < candy :\\n                candy = candies\\n            child[index] += candy \\n            candies -= candy\\n            candy +=1\\n            index +=1\\n            if index  == num_people:\\n                index = 0\\n        return child\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1572836,
                "content": [
                    {
                        "username": "Han6431",
                        "content": "**Pure math problem. If we get the math behind, we get the solution.**\\n1) By the total number of candies, we know how many distributions of candices we will have for people: 1 + 2 + 3 + ... = number of candies. Here, the number of distributions is the number of natural numbers on the left of the equation. (Use the formula (1+n)*n/2 = number of candies. The n might not be an integer. If so, it means there are remain candies for the last person. Let m be the floor number of n, and we can use m and the total number of candies to calculate the remain candies for the last person.)\\n2) With the number of distributions, we can calculate how many rounds we will have. (Each round means going through all people once). Use integer division of number of distributions on number of people, we have the number of rounds.\\n3) Use mode calculation we can get the number of distributions for the last incomplete round. \\n4) Don\\'t forget to add the remain candies to the last person.\\n\\nWith these numbers calculated, for each person in the list, we can directly calculate the number of candies there."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tresult = [0] * num_people\\n\\ti = 0\\n\\twhile candies >= 0:\\n\\t\\tresult[i % num_people] += min(i + 1, candies)\\n\\t\\ti += 1\\n\\t\\tcandies -= i\\n\\treturn result"
                    }
                ]
            },
            {
                "id": 1574846,
                "content": [
                    {
                        "username": "Han6431",
                        "content": "**Pure math problem. If we get the math behind, we get the solution.**\\n1) By the total number of candies, we know how many distributions of candices we will have for people: 1 + 2 + 3 + ... = number of candies. Here, the number of distributions is the number of natural numbers on the left of the equation. (Use the formula (1+n)*n/2 = number of candies. The n might not be an integer. If so, it means there are remain candies for the last person. Let m be the floor number of n, and we can use m and the total number of candies to calculate the remain candies for the last person.)\\n2) With the number of distributions, we can calculate how many rounds we will have. (Each round means going through all people once). Use integer division of number of distributions on number of people, we have the number of rounds.\\n3) Use mode calculation we can get the number of distributions for the last incomplete round. \\n4) Don\\'t forget to add the remain candies to the last person.\\n\\nWith these numbers calculated, for each person in the list, we can directly calculate the number of candies there."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tresult = [0] * num_people\\n\\ti = 0\\n\\twhile candies >= 0:\\n\\t\\tresult[i % num_people] += min(i + 1, candies)\\n\\t\\ti += 1\\n\\t\\tcandies -= i\\n\\treturn result"
                    }
                ]
            }
        ]
    },
    {
        "title": "Count Unhappy Friends",
        "question_content": "<p>You are given a list of&nbsp;<code>preferences</code>&nbsp;for&nbsp;<code>n</code>&nbsp;friends, where <code>n</code> is always <strong>even</strong>.</p>\n\n<p>For each person <code>i</code>,&nbsp;<code>preferences[i]</code>&nbsp;contains&nbsp;a list of friends&nbsp;<strong>sorted</strong> in the <strong>order of preference</strong>. In other words, a friend earlier in the list is more preferred than a friend later in the list.&nbsp;Friends in&nbsp;each list are&nbsp;denoted by integers from <code>0</code> to <code>n-1</code>.</p>\n\n<p>All the friends are divided into pairs.&nbsp;The pairings are&nbsp;given in a list&nbsp;<code>pairs</code>,&nbsp;where <code>pairs[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> denotes <code>x<sub>i</sub></code>&nbsp;is paired with <code>y<sub>i</sub></code> and <code>y<sub>i</sub></code> is paired with <code>x<sub>i</sub></code>.</p>\n\n<p>However, this pairing may cause some of the friends to be unhappy.&nbsp;A friend <code>x</code>&nbsp;is unhappy if <code>x</code>&nbsp;is paired with <code>y</code>&nbsp;and there exists a friend <code>u</code>&nbsp;who&nbsp;is paired with <code>v</code>&nbsp;but:</p>\n\n<ul>\n\t<li><code>x</code>&nbsp;prefers <code>u</code>&nbsp;over <code>y</code>,&nbsp;and</li>\n\t<li><code>u</code>&nbsp;prefers <code>x</code>&nbsp;over <code>v</code>.</li>\n</ul>\n\n<p>Return <em>the number of unhappy friends</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 4, preferences = [[1, 2, 3], [3, 2, 0], [3, 1, 0], [1, 2, 0]], pairs = [[0, 1], [2, 3]]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong>\nFriend 1 is unhappy because:\n- 1 is paired with 0 but prefers 3 over 0, and\n- 3 prefers 1 over 2.\nFriend 3 is unhappy because:\n- 3 is paired with 2 but prefers 1 over 2, and\n- 1 prefers 3 over 0.\nFriends 0 and 2 are happy.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2, preferences = [[1], [0]], pairs = [[1, 0]]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> Both friends 0 and 1 are happy.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 4, preferences = [[1, 3, 2], [2, 3, 0], [1, 3, 0], [0, 2, 1]], pairs = [[1, 3], [0, 2]]\n<strong>Output:</strong> 4\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 500</code></li>\n\t<li><code>n</code>&nbsp;is even.</li>\n\t<li><code>preferences.length&nbsp;== n</code></li>\n\t<li><code>preferences[i].length&nbsp;== n - 1</code></li>\n\t<li><code>0 &lt;= preferences[i][j] &lt;= n - 1</code></li>\n\t<li><code>preferences[i]</code>&nbsp;does not contain <code>i</code>.</li>\n\t<li>All values in&nbsp;<code>preferences[i]</code>&nbsp;are unique.</li>\n\t<li><code>pairs.length&nbsp;== n/2</code></li>\n\t<li><code>pairs[i].length&nbsp;== 2</code></li>\n\t<li><code>x<sub>i</sub> != y<sub>i</sub></code></li>\n\t<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub>&nbsp;&lt;= n - 1</code></li>\n\t<li>Each person is contained in <strong>exactly one</strong> pair.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 843929,
                "title": "what-a-bad-question",
                "content": "First of all, it took me a long long time to understand the question, I think Leetcode should hire a better problem writer! \\n\\nSecondly, even you figured out what to do, it pretty much feels like \"**if you try to solve this by a fantasy algorithm, then you will fail this. Because the most time efficient way is brutal force. (BEEP)**\"\\n\\nLast but not least, **I am definitely an \"unhappy friend\" with this question.** Does anyone feel the same?\\n\\n```\\npublic int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int[] map = new int[n];\\n        for(int[] pair: pairs){ // Keep record of current matches.\\n            map[pair[0]] = pair[1];\\n            map[pair[1]] = pair[0];\\n        }\\n        int res = 0;\\n\\t\\t\\n        Map<Integer, Integer>[] prefer = new Map[n]; // O(1) to fetch the index from the preference array. \\n         \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n-1; j++){\\n                if(prefer[i] == null) prefer[i] = new HashMap<>();\\n                prefer[i].put(preferences[i][j], j);\\n            }\\n        }\\n\\n        for(int i = 0; i < n; i++){\\n            for(int j : preferences[i]){\\n                if(prefer[j].get(i) < prefer[j].get(map[j]) \\n\\t\\t\\t\\t\\t&& prefer[i].get(map[i]) > prefer[i].get(j)){ // Based on the definition of \"unhappy\"...\\n                    res++;\\n                    break;\\n                }\\n            }\\n        }\\n\\t    return res;\\n```",
                "solutionTags": [],
                "code": "```\\npublic int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int[] map = new int[n];\\n        for(int[] pair: pairs){ // Keep record of current matches.\\n            map[pair[0]] = pair[1];\\n            map[pair[1]] = pair[0];\\n        }\\n        int res = 0;\\n\\t\\t\\n        Map<Integer, Integer>[] prefer = new Map[n]; // O(1) to fetch the index from the preference array. \\n         \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n-1; j++){\\n                if(prefer[i] == null) prefer[i] = new HashMap<>();\\n                prefer[i].put(preferences[i][j], j);\\n            }\\n        }\\n\\n        for(int i = 0; i < n; i++){\\n            for(int j : preferences[i]){\\n                if(prefer[j].get(i) < prefer[j].get(map[j]) \\n\\t\\t\\t\\t\\t&& prefer[i].get(map[i]) > prefer[i].get(j)){ // Based on the definition of \"unhappy\"...\\n                    res++;\\n                    break;\\n                }\\n            }\\n        }\\n\\t    return res;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 844105,
                "title": "python-clean-solution",
                "content": "Create dictionary using each friend as keys and a list of people they are closer to than the person they are paired with as values. This can be done using index.\\n\\nThen use nested for loop to find when people are on each other\\'s list.\\n\\n```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        \\n        dd = {}\\n        \\n        for i,x in pairs:\\n            dd[i] = preferences[i][:preferences[i].index(x)]\\n            dd[x] = preferences[x][:preferences[x].index(i)]\\n        \\n        ans = 0\\n            \\n        for i in dd:\\n            for x in dd[i]:\\n                if i in dd[x]:\\n                    ans += 1\\n                    break\\n        \\n        return ans\\n                            \\n                            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        \\n        dd = {}\\n        \\n        for i,x in pairs:\\n            dd[i] = preferences[i][:preferences[i].index(x)]\\n            dd[x] = preferences[x][:preferences[x].index(i)]\\n        \\n        ans = 0\\n            \\n        for i in dd:\\n            for x in dd[i]:\\n                if i in dd[x]:\\n                    ans += 1\\n                    break\\n        \\n        return ans\\n                            \\n                            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 843928,
                "title": "o-n-2-store-preferences-at-the-beginning",
                "content": "Well, I understand the frustration. The problem could have been certainly be worded better.\\n\\nImportant thing to note:\\n**When**\\n`x` prefers `u` over `y`, and\\n`u` prefers `x` over `v`,\\n**Then**\\nBoth `x` and `u` are unhappy.\\nNOT just `x`.\\n\\nThe problem statement mentions that `x` is unhappy. We have to figure out that `u` is also unhappy.\\n\\n--\\n\\nYou have to try each pair with every other pair to identify the unhappiness. That leads to O(n^2) complexity already. So how do we optimize the inner operation to constant time so that the overall complexity remains O(n^2)?\\n\\nTo know whether `x` prefers `y` over `z`, we need to know their positions in `x`s list.\\nIf you want to find the position of `y` in `x`s list, you might have to search the entire list and get the index. Similarly for `z`.\\nThis would be O(n) and solution will become O(n^3) which will lead to TLE.\\n\\nHence, we first store the position of each friend in every other friends\\' list, in a map at the beginning.\\n\\n\\n```\\nclass Solution {\\n\\n    // To efficiently know whether a person x prefers a person y or a person z, wouldn\\'t \\n    // it be better to have that information ready?\\n    // We store the index of each person in every other person\\'s list in a map at the beginning.\\n    \\n    // `positions[i][j]` should be read as position of i in the list of j is positions[i][j].\\n    unordered_map<int, unordered_map<int, int>> positions;\\n    \\n    unordered_set<int> unhappy; // Stores unhappy people. In the end, we will return it\\'s size.\\npublic:\\n    void checkHappiness(int x, int y, int u, int v) {\\n        if (positions[u][x] < positions[y][x] &&\\n            positions[x][u] < positions[v][u]) {\\n            unhappy.insert(x);\\n            unhappy.insert(u);\\n        }\\n    }\\n    \\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        for (int i=0; i<n; i++) {\\n            for (int j=0; j<n-1; j++) {\\n                positions[preferences[i][j]][i] = j;\\n            }\\n        }\\n        int n = pairs.size();\\n        for (int i=0; i<n-1; i++) {\\n            for (int j=i+1; j<n; j++) {\\n                int x = pairs[i][0], y = pairs[i][1], u = pairs[j][0], v = pairs[j][1];\\n                checkHappiness(x, y, u, v); // If x prefers u over y,  and u prefers x over v\\n                checkHappiness(x, y, v, u); // If x prefers v over y,  and v prefers x over u\\n                checkHappiness(y, x, u, v); // If y prefers u over x,  and u prefers y over v\\n                checkHappiness(y, x, v, u); // If y prefers v over x,  and v prefers y over u\\n            }\\n        }\\n        \\n        return unhappy.size();\\n    }\\n};\\n```\\n\\n**Some of my other posts**\\n1. Leetcode 1584: https://leetcode.com/problems/min-cost-to-connect-all-points/discuss/844270\\n2. Leetcode 1583: https://leetcode.com/problems/count-unhappy-friends/discuss/843928\\n3. Leetcode 1579: https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/discuss/831506\\n4. Leetcode 1578: https://leetcode.com/problems/minimum-deletion-cost-to-avoid-repeating-letters/discuss/831533\\n5. Leetcode 1577: https://leetcode.com/problems/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers/discuss/831548\\n6. Leetcode 1553: https://leetcode.com/problems/minimum-number-of-days-to-eat-n-oranges/discuss/794075\\n7. Leetcode 1545: https://leetcode.com/problems/find-kth-bit-in-nth-binary-string/discuss/781105\\n8. Leetcode 1536: https://leetcode.com/problems/minimum-swaps-to-arrange-a-binary-grid/discuss/768076\\n9. Leetcode 1535: https://leetcode.com/problems/find-the-winner-of-an-array-game/discuss/767958\\n10. Leetcode 1534: https://leetcode.com/problems/count-good-triplets/discuss/768170\\n11. Leetcode 1529: https://leetcode.com/problems/bulb-switcher-iv/discuss/755939\\n12. Leetcode 1503: https://leetcode.com/problems/last-moment-before-all-ants-fall-out-of-a-plank/discuss/720313\\n13. Leetcode 1488: https://leetcode.com/problems/avoid-flood-in-the-city/discuss/697687\\n14. Leetcode 1487: https://leetcode.com/problems/making-file-names-unique/discuss/719962\\n15. Leetcode 1472: https://leetcode.com/problems/design-browser-history/discuss/674486\\n16. Leetcode 1471: https://leetcode.com/problems/the-k-strongest-values-in-an-array/discuss/674346\\n17. Leetcode 1466: https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/discuss/661710\\n18. Leetcode 1465: https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/discuss/661995\\n19. Leetcode 1458: https://leetcode.com/problems/max-dot-product-of-two-subsequences/discuss/648528\\n20. Leetcode 1443: https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/discuss/623673\\n21. Leetcode 1436: https://leetcode.com/problems/destination-city/discuss/609874\\n22. Leetcode 1424: https://leetcode.com/problems/diagonal-traverse-ii/discuss/597741\\n23. Leetcode 1423: https://leetcode.com/problems/maximum-points-you-can-obtain-from-cards/discuss/597825\\n24. Leetcode 1419: https://leetcode.com/problems/minimum-number-of-frogs-croaking/discuss/586653",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    // To efficiently know whether a person x prefers a person y or a person z, wouldn\\'t \\n    // it be better to have that information ready?\\n    // We store the index of each person in every other person\\'s list in a map at the beginning.\\n    \\n    // `positions[i][j]` should be read as position of i in the list of j is positions[i][j].\\n    unordered_map<int, unordered_map<int, int>> positions;\\n    \\n    unordered_set<int> unhappy; // Stores unhappy people. In the end, we will return it\\'s size.\\npublic:\\n    void checkHappiness(int x, int y, int u, int v) {\\n        if (positions[u][x] < positions[y][x] &&\\n            positions[x][u] < positions[v][u]) {\\n            unhappy.insert(x);\\n            unhappy.insert(u);\\n        }\\n    }\\n    \\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        for (int i=0; i<n; i++) {\\n            for (int j=0; j<n-1; j++) {\\n                positions[preferences[i][j]][i] = j;\\n            }\\n        }\\n        int n = pairs.size();\\n        for (int i=0; i<n-1; i++) {\\n            for (int j=i+1; j<n; j++) {\\n                int x = pairs[i][0], y = pairs[i][1], u = pairs[j][0], v = pairs[j][1];\\n                checkHappiness(x, y, u, v); // If x prefers u over y,  and u prefers x over v\\n                checkHappiness(x, y, v, u); // If x prefers v over y,  and v prefers x over u\\n                checkHappiness(y, x, u, v); // If y prefers u over x,  and u prefers y over v\\n                checkHappiness(y, x, v, u); // If y prefers v over x,  and v prefers y over u\\n            }\\n        }\\n        \\n        return unhappy.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844089,
                "title": "c-easy-explanation-for-a-bad-framed-question",
                "content": "The question was framed a little unclear for most of us to understand but here we go.\\n\\nExaplaination of the question\\n\\n\\tFollowing statement of question can be explained better.\\n\\tHowever, this pairing may cause some of the friends to be unhappy. \\n\\tA friend x is unhappy if x is paired with y and there exists a friend \\n\\tu who is paired with v but:\\n\\n\\tx prefers u over y, and\\n\\tu prefers x over v.\\n\\t\\n\\tTake Example as :\\n\\t\\n\\tn = 4, preferences = [[1, 3, 2], [2, 3, 0], [1, 3, 0], [0, 2, 1]], pairs = [[1, 3], [0, 2]]\\n\\t\\n\\t\\n\\tTake pair [0,2]\\n\\tx-y == 0-2\\n\\t\\n\\t0 prefers 1 and 3 over 2 (YES WE NEED TO CONSIDER 1 AND 3 BOTH :) )\\n\\tNow check for 1 as well as 3\\n\\tNow if any of 1 or 3 preferes 0 over 2 then we have a unhappy friend.\\n\\tsince 3 prefers 0 over two we have a unhappy friend\\n\\tthough we see 1 prefers 2 over zero\\n\\tPS: most of us thought just to check for 1st preference of 0 and there is where this\\'\\n\\tquestions explanation was misunderstood.\\'\\n\\t\\n\\t\\n\\tIf you still have any doubt please raise them in comment section I will do my best to make the question clear.\\n\\t\\nBelow is the exaplantion of code:\\n\\t\\t\\n\\tFor every friend map his/her preferences\\n\\tNow calculate the distance between the pairs that are made.\\n\\t\\n\\tNow main code:\\n\\tLoop over every friend\\n\\t1. Check if matched prefrence is lower\\n\\t2. If not then loop over thier preferences and see if the any his/her higher preference is \\n\\talso matched to some lower preference, If yes increment the count unhappy.\\n\\t\\nHere is the code for refrence:\\nHappy Coding :)\\n\\n```\\nint unhappyFriends(int n, vector<vector<int>> &pref, vector<vector<int>> &pairs)\\n{\\n    vector<unordered_map<int, int>> mp(n);\\n    vector<int> distance(n);\\n    for (int i = 0; i < n; ++i)\\n    {\\n        int prefsize = pref[i].size();\\n        for (int j = 0; j < prefsize; ++j)\\n            mp[i][pref[i][j]] = j;\\n    }\\n\\n    for (auto &p : pairs)\\n    {\\n        distance[p[0]] = mp[p[0]][p[1]];\\n        distance[p[1]] = mp[p[1]][p[0]];\\n    }\\n    int unhappy = 0;\\n    for (int i = 0; i < n; ++i)\\n    {\\n        for (int j = 0; j < distance[i]; ++j)\\n        {\\n            int x = pref[i][j];\\n            for (int k = 0; k < distance[x]; ++k)\\n            {\\n                if (i == pref[x][k])\\n                {\\n                    unhappy++;\\n                    j = k = n;\\n                }\\n            }\\n        }\\n    }\\n    return unhappy;\\n}\\n```\\n\\nComplexity Analysis\\n\\t\\t\\n\\tTime : O(n^3)\\n\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint unhappyFriends(int n, vector<vector<int>> &pref, vector<vector<int>> &pairs)\\n{\\n    vector<unordered_map<int, int>> mp(n);\\n    vector<int> distance(n);\\n    for (int i = 0; i < n; ++i)\\n    {\\n        int prefsize = pref[i].size();\\n        for (int j = 0; j < prefsize; ++j)\\n            mp[i][pref[i][j]] = j;\\n    }\\n\\n    for (auto &p : pairs)\\n    {\\n        distance[p[0]] = mp[p[0]][p[1]];\\n        distance[p[1]] = mp[p[1]][p[0]];\\n    }\\n    int unhappy = 0;\\n    for (int i = 0; i < n; ++i)\\n    {\\n        for (int j = 0; j < distance[i]; ++j)\\n        {\\n            int x = pref[i][j];\\n            for (int k = 0; k < distance[x]; ++k)\\n            {\\n                if (i == pref[x][k])\\n                {\\n                    unhappy++;\\n                    j = k = n;\\n                }\\n            }\\n        }\\n    }\\n    return unhappy;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 843967,
                "title": "java-brutal-force-loops",
                "content": "```\\n    public int unhappyFriends(int n, int[][] ps, int[][] pairs) {\\n        int res = 0, pair[] = new int[n];\\n        Set<Integer> set = new HashSet<>();\\n        for (int[] p : pairs) {\\n            pair[p[0]] = p[1];\\n            pair[p[1]] = p[0];\\n        }\\n        for (int[] p : pairs) {\\n            for (int x : p) {\\n                for (int u : ps[x]) {\\n                    if (u == pair[x]) break; // count before y;\\n                    for (int x0 : ps[u]) {\\n                        if (x0 == pair[u]) break; // count before v;\\n                        if (x0 == x) {   // find x;\\n                            set.add(x);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int unhappyFriends(int n, int[][] ps, int[][] pairs) {\\n        int res = 0, pair[] = new int[n];\\n        Set<Integer> set = new HashSet<>();\\n        for (int[] p : pairs) {\\n            pair[p[0]] = p[1];\\n            pair[p[1]] = p[0];\\n        }\\n        for (int[] p : pairs) {\\n            for (int x : p) {\\n                for (int u : ps[x]) {\\n                    if (u == pair[x]) break; // count before y;\\n                    for (int x0 : ps[u]) {\\n                        if (x0 == pair[u]) break; // count before v;\\n                        if (x0 == x) {   // find x;\\n                            set.add(x);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 843963,
                "title": "c-friend-distance",
                "content": "For each person, calculate the \"friend distance\" - how far the person he or she is paired with in the friend list.\\n\\nThen, you can go through each person, and all friends that are closer (compared to the \"friend distance\").\\n\\n```cpp\\nint unhappyFriends(int n, vector<vector<int>>& pref, vector<vector<int>>& pairs) {\\n    vector<unordered_map<int, int>> m(n);\\n    vector<int> dist(n);\\n    for (int i = 0; i < n; ++i) {\\n        for (int j = 0; j < pref[i].size(); ++j)\\n            m[i][pref[i][j]] = j;\\n    }\\n    for (auto &p : pairs) {\\n        dist[p[0]] = m[p[0]][p[1]];\\n        dist[p[1]] = m[p[1]][p[0]];\\n    }\\n    int res = 0;\\n    for (int i = 0; i < n; ++i) {\\n        for (int d = 0; d < dist[i]; ++d) {\\n            int j = pref[i][d];\\n            for (int d1 = 0; d1 < dist[j]; ++d1) {\\n                if (i == pref[j][d1]) {\\n                    ++res;\\n                    d = d1 = n;\\n                }\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint unhappyFriends(int n, vector<vector<int>>& pref, vector<vector<int>>& pairs) {\\n    vector<unordered_map<int, int>> m(n);\\n    vector<int> dist(n);\\n    for (int i = 0; i < n; ++i) {\\n        for (int j = 0; j < pref[i].size(); ++j)\\n            m[i][pref[i][j]] = j;\\n    }\\n    for (auto &p : pairs) {\\n        dist[p[0]] = m[p[0]][p[1]];\\n        dist[p[1]] = m[p[1]][p[0]];\\n    }\\n    int res = 0;\\n    for (int i = 0; i < n; ++i) {\\n        for (int d = 0; d < dist[i]; ++d) {\\n            int j = pref[i][d];\\n            for (int d1 = 0; d1 < dist[j]; ++d1) {\\n                if (i == pref[j][d1]) {\\n                    ++res;\\n                    d = d1 = n;\\n                }\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1890091,
                "title": "python-make-you-happy-with-clean-and-concise-solution",
                "content": "The problem description is not very clear. Please find below clean, concise and self explanatory code. \\nTime Complexity: O(n^2). Space Complexity: O(n^2)\\nIncluding comments in the code for better understanding. Kindly upvote if you like the solution.\\n\\n\\t\\t#Map to get pair mapping\\n        pairMap = defaultdict(int)\\n        #To get preference of person i with person j in O(1)\\n        prefer = {}\\n        \\n        #Populating pairMap\\n        for p1,p2 in pairs:\\n            pairMap[p1] = p2\\n            pairMap[p2] = p1\\n        \\n         #Populating prefer Map\\n        for i in range(len(preferences)):\\n            for j in range(n-1):\\n                if i not in prefer:\\n                    prefer[i] = {}\\n                prefer[i][preferences[i][j]] = j\\n        \\n        #Looping through preferences again to find if person i is unhappy\\n        res = 0\\n        for i in range(len(preferences)):\\n            for j in range(n-1):\\n                x = i\\n                y = pairMap[x]\\n                u = preferences[x][j]\\n                v = pairMap[u]\\n                if prefer[x][u] < prefer[x][y] and prefer[u][x] < prefer[u][v]:\\n                    res+=1\\n                    break\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "The problem description is not very clear. Please find below clean, concise and self explanatory code. \\nTime Complexity: O(n^2). Space Complexity: O(n^2)\\nIncluding comments in the code for better understanding. Kindly upvote if you like the solution.\\n\\n\\t\\t#Map to get pair mapping\\n        pairMap = defaultdict(int)\\n        #To get preference of person i with person j in O(1)\\n        prefer = {}\\n        \\n        #Populating pairMap\\n        for p1,p2 in pairs:\\n            pairMap[p1] = p2\\n            pairMap[p2] = p1\\n        \\n         #Populating prefer Map\\n        for i in range(len(preferences)):\\n            for j in range(n-1):\\n                if i not in prefer:\\n                    prefer[i] = {}\\n                prefer[i][preferences[i][j]] = j\\n        \\n        #Looping through preferences again to find if person i is unhappy\\n        res = 0\\n        for i in range(len(preferences)):\\n            for j in range(n-1):\\n                x = i\\n                y = pairMap[x]\\n                u = preferences[x][j]\\n                v = pairMap[u]\\n                if prefer[x][u] < prefer[x][y] and prefer[u][x] < prefer[u][v]:\\n                    res+=1\\n                    break\\n        return res",
                "codeTag": "Unknown"
            },
            {
                "id": 843968,
                "title": "java-1-ms-faster-than-100-00-stable-matching-code-with-explanation-supper-easy-to-understand",
                "content": "\\t/*\\n    idea:\\n        1. for each person in the pair, check this person\\'s prefered mate \"a\", and \"a\"\\'s priority\\n    */\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int res=0;\\n        HashMap<Integer, Integer> map = buildHashMap(pairs);\\n        for(int[] pair : pairs){\\n            //check both people in pair\\n            if(isHappy(pair[0], pair[1], preferences, map)!=-1){\\n                res+=1; //unhappy pair\\n            }\\n            if(isHappy(pair[1], pair[0], preferences, map)!=-1){\\n                res+=1; //unhappy pair\\n            }            \\n        }\\n        return res;\\n    }\\n    \\n    //check if this person is happy\\n    //happy returns -1; unhappy return pair\\'s ID\\n    /*\\n    unhappy:\\n        x prefers u over y, and\\n        u prefers x over v.\\n    */\\n    private int isHappy(int person, int curMate, int[][] preferences, HashMap<Integer, Integer> map){\\n        \\n        //sorted mates: \\n        for(int mate : preferences[person]){            \\n            if(mate == curMate) return -1; //best it can be for this person\\n            //x prefers u over y: check this mate\\'s preference\\n            //Now: check if: u prefers x over v.\\n            int matesCurMate = map.get(mate);\\n            for(int matesMate : preferences[mate]){\\n                if(matesMate==person){\\n                    //unstable matching\\n                    return mate;\\n                }else if(matesMate == matesCurMate){\\n                    //stable matching for this mate\\n                    break;\\n                }\\n            }\\n        }\\n        //happy as it is\\n        return -1;\\n    }\\n    \\n    //helper to build bijection mapping\\n    private HashMap<Integer, Integer> buildHashMap(int[][] pairs){\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int[] pair : pairs){\\n            map.put(pair[0],pair[1]);\\n            map.put(pair[1],pair[0]);\\n        }\\n        return map;\\n    }",
                "solutionTags": [],
                "code": "\\t/*\\n    idea:\\n        1. for each person in the pair, check this person\\'s prefered mate \"a\", and \"a\"\\'s priority\\n    */\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int res=0;\\n        HashMap<Integer, Integer> map = buildHashMap(pairs);\\n        for(int[] pair : pairs){\\n            //check both people in pair\\n            if(isHappy(pair[0], pair[1], preferences, map)!=-1){\\n                res+=1; //unhappy pair\\n            }\\n            if(isHappy(pair[1], pair[0], preferences, map)!=-1){\\n                res+=1; //unhappy pair\\n            }            \\n        }\\n        return res;\\n    }\\n    \\n    //check if this person is happy\\n    //happy returns -1; unhappy return pair\\'s ID\\n    /*\\n    unhappy:\\n        x prefers u over y, and\\n        u prefers x over v.\\n    */\\n    private int isHappy(int person, int curMate, int[][] preferences, HashMap<Integer, Integer> map){\\n        \\n        //sorted mates: \\n        for(int mate : preferences[person]){            \\n            if(mate == curMate) return -1; //best it can be for this person\\n            //x prefers u over y: check this mate\\'s preference\\n            //Now: check if: u prefers x over v.\\n            int matesCurMate = map.get(mate);\\n            for(int matesMate : preferences[mate]){\\n                if(matesMate==person){\\n                    //unstable matching\\n                    return mate;\\n                }else if(matesMate == matesCurMate){\\n                    //stable matching for this mate\\n                    break;\\n                }\\n            }\\n        }\\n        //happy as it is\\n        return -1;\\n    }\\n    \\n    //helper to build bijection mapping\\n    private HashMap<Integer, Integer> buildHashMap(int[][] pairs){\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int[] pair : pairs){\\n            map.put(pair[0],pair[1]);\\n            map.put(pair[1],pair[0]);\\n        }\\n        return map;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 844024,
                "title": "c-best-solution-beats-100-runtime-75-less-space-self-explanatory",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>> &p, vector<vector<int>> &pairs)\\n    {\\n        int res = 0, d,v, count;\\n        vector<int> pairing(n);\\n        vector<vector<int>> friends(n, vector<int>(n));\\n\\t\\t\\n        for (int i = 0; i < p.size(); ++i)\\n            for (int j = 0; j < p[i].size(); ++j)\\n                friends[i][p[i][j]] = j;\\n\\n        for (auto &it : pairs)\\n            pairing[it[0]] = it[1], pairing[it[1]] = it[0];\\n\\n        for (int i = 0; i < n; ++i)\\n        {\\n            count = 0;\\n            for (int j = 0; j < n; ++j)\\n                if (j != i && j != pairing[i])\\n                {\\n                    d = pairing[i], v = pairing[j];\\n                    if (friends[i][j] < friends[i][d] && friends[j][i] < friends[j][v])\\n                        count = 1;\\n                }\\n            res += count;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>> &p, vector<vector<int>> &pairs)\\n    {\\n        int res = 0, d,v, count;\\n        vector<int> pairing(n);\\n        vector<vector<int>> friends(n, vector<int>(n));\\n\\t\\t\\n        for (int i = 0; i < p.size(); ++i)\\n            for (int j = 0; j < p[i].size(); ++j)\\n                friends[i][p[i][j]] = j;\\n\\n        for (auto &it : pairs)\\n            pairing[it[0]] = it[1], pairing[it[1]] = it[0];\\n\\n        for (int i = 0; i < n; ++i)\\n        {\\n            count = 0;\\n            for (int j = 0; j < n; ++j)\\n                if (j != i && j != pairing[i])\\n                {\\n                    d = pairing[i], v = pairing[j];\\n                    if (friends[i][j] < friends[i][d] && friends[j][i] < friends[j][v])\\n                        count = 1;\\n                }\\n            res += count;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844348,
                "title": "simple-c-solution-100-time-efficient-100-memory-efficent-explained-commented",
                "content": "consider example-->\\n n = 4, preferences = [[1, 2, 3], [3, 2, 0], [3, 1, 0], [1, 2, 0]], pairs = [[0, 1], [2, 3]]\\n \\n consider for 0->\\niterate through its pref until we reach its current assigned pair i.e. [ ] (to iterate)\\nas we see see 0 is set with its first pref no need to check further;\\n\\nconsider 1->\\n->iterate through its pref ,[3, 2, 0], until we reach its current assigned pair i.e. [3, 2],  (to iterate)\\n->check for value in this such that if there exist a pair  such that it is pair with some one else but has 1 as pref ;\\n->so lets start with 3 its pref are [1, 2, 0],iterate through it until we reach 3\\'s assigned pair i.e. [1] (to iterate)\\n\\nnow you may see that 3 is paired with 2 but we can be set with 1(current i) for better happiness.\\n\\nconsider->2\\n2 is set with 3 and its his first pref so no iteration.\\n\\nconsider 3->\\n->iterate through its pref ,[1, 2, 0], until we reach its current assigned pair i.e. [1],  (to iterate)\\n->check for value in this such that if there exist a pair  such that it is pair with with some one else but has 3 as pref ;\\n->so lets start with 1 its pref are [3,2,0],iterate through it until we reach 1\\'s assigned pair i.e. [3] (to iterate)\\n\\nnow you may see that 1 is paired with 0 but we  can  set with 3(current i) for better happiness.\\n\\n\\n \\n \\n\\n```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& pref, vector<vector<int>>& prs) {\\n        vector<int>v(n);\\n        for(vector<int>vx:prs)//store the current assigned pair\\n        {\\n            v[vx[0]]=vx[1];\\n            v[vx[1]]=vx[0];\\n        }\\n        int res=0;  //to store result\\n        for(int i=0;i<n;i++)    //start from 0 iterate through every point\\n        {\\n            int x=0;\\n            for(int j=0;j<pref[i].size();j++)    // iterate through its pref.\\n            {\\n                if(pref[i][j]==v[i])break; // if we reach current assigned value then i is happy no need to check further\\n                \\n                for(int k=0;k<pref[pref[i][j]].size();k++)  //iterate through pref. of pref[i][j] to check if we reach i before reaching assigned value of pref[i][j]  \\n                {\\n                    if(pref[pref[i][j]][k]==i) // if we reach i for any value in pref list before its assigned we find its unhappy couple.  \\n                    {x++;break;}\\n                    if(pref[pref[i][j]][k]==v[pref[i][j]]) // if we reach assigned pair before reaching i the this value in pref of i is happy \\n                        break;\\n                }\\n                if(x)break;  //we find a pair for i no need to check further\\n            }\\n             res+=x; // increment the result \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& pref, vector<vector<int>>& prs) {\\n        vector<int>v(n);\\n        for(vector<int>vx:prs)//store the current assigned pair\\n        {\\n            v[vx[0]]=vx[1];\\n            v[vx[1]]=vx[0];\\n        }\\n        int res=0;  //to store result\\n        for(int i=0;i<n;i++)    //start from 0 iterate through every point\\n        {\\n            int x=0;\\n            for(int j=0;j<pref[i].size();j++)    // iterate through its pref.\\n            {\\n                if(pref[i][j]==v[i])break; // if we reach current assigned value then i is happy no need to check further\\n                \\n                for(int k=0;k<pref[pref[i][j]].size();k++)  //iterate through pref. of pref[i][j] to check if we reach i before reaching assigned value of pref[i][j]  \\n                {\\n                    if(pref[pref[i][j]][k]==i) // if we reach i for any value in pref list before its assigned we find its unhappy couple.  \\n                    {x++;break;}\\n                    if(pref[pref[i][j]][k]==v[pref[i][j]]) // if we reach assigned pair before reaching i the this value in pref of i is happy \\n                        break;\\n                }\\n                if(x)break;  //we find a pair for i no need to check further\\n            }\\n             res+=x; // increment the result \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843947,
                "title": "javascript-hashmap",
                "content": "1. build the happyMap the record the rank of happiness\\nex: \\nInput: `n = 4`, preferences = `[[1, 2, 3], [3, 2, 0], [3, 1, 0], [1, 2, 0]]`, pairs = `[[0, 1], [2, 3]]`\\nOutput: 2\\n`p1 - p2 - rank`\\n`0 - 1 - 0`\\n`1 - 0 - 2`\\n`2 - 3 - 0`\\n`3 - 2 - 1`\\n`==> happyMap: [0, 2, 0, 1]`\\n\\n2. Check each person. If there is one higher rank person who prefer to be partnered with him/her, `unhappy++`\\n\\n```\\nvar unhappyFriends = function(n, preferences, pairs) {\\n    let happyMap = new Array(n);\\n    for (let [i, j] of pairs) {\\n        happyMap[i] = preferences[i].indexOf(j);\\n        happyMap[j] = preferences[j].indexOf(i);\\n    }\\n    \\n    let unhappy = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < happyMap[i]; j++) {\\n            let partner = preferences[i][j];\\n            if (preferences[partner].indexOf(i) < happyMap[partner]) {\\n                unhappy++;\\n                break;\\n            }\\n        }\\n    }\\n    \\n    return unhappy;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "1. build the happyMap the record the rank of happiness\\nex: \\nInput: `n = 4`, preferences = `[[1, 2, 3], [3, 2, 0], [3, 1, 0], [1, 2, 0]]`, pairs = `[[0, 1], [2, 3]]`\\nOutput: 2\\n`p1 - p2 - rank`\\n`0 - 1 - 0`\\n`1 - 0 - 2`\\n`2 - 3 - 0`\\n`3 - 2 - 1`\\n`==> happyMap: [0, 2, 0, 1]`\\n\\n2. Check each person. If there is one higher rank person who prefer to be partnered with him/her, `unhappy++`\\n\\n```\\nvar unhappyFriends = function(n, preferences, pairs) {\\n    let happyMap = new Array(n);\\n    for (let [i, j] of pairs) {\\n        happyMap[i] = preferences[i].indexOf(j);\\n        happyMap[j] = preferences[j].indexOf(i);\\n    }\\n    \\n    let unhappy = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < happyMap[i]; j++) {\\n            let partner = preferences[i][j];\\n            if (preferences[partner].indexOf(i) < happyMap[partner]) {\\n                unhappy++;\\n                break;\\n            }\\n        }\\n    }\\n    \\n    return unhappy;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 844542,
                "title": "4ms-java-solution",
                "content": "Looks like the fastest java solution according to the submissions page. Did a simple optimization -\\nReduce the number of compares by starting the second loop from i+1 instead of 0(like in the other solutions) because according to the unhappy friend definition, friends will be unhappy in pairs.\\n\\nBelow is the code. Do comment if you find any issues with the code.\\n\\n```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int[][] prefMap = new int[n][n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n-1; j++) {\\n                prefMap[i][preferences[i][j]] = j;\\n            }\\n        }\\n        \\n        int a,b,prefA,prefB,prefEle1,prefEle2,ele1,ele2;\\n        int count = 0;\\n        boolean[] flags = new boolean[n];\\n        for (int i = 0; i < pairs.length; i++) {\\n            a = pairs[i][0];\\n            b = pairs[i][1];\\n            prefB = prefMap[a][b];\\n            prefA = prefMap[b][a];\\n            for (int j = i+1; j < pairs.length; j++) {\\n                ele1 = pairs[j][0];\\n                ele2 = pairs[j][1];\\n                prefEle2 = prefMap[ele1][ele2];\\n                prefEle1 = prefMap[ele2][ele1];\\n      \\n                if (prefB > prefMap[a][ele1] && prefEle2 > prefMap[ele1][a]) {\\n                    flags[a] = true;\\n                    flags[ele1] = true;\\n                }\\n                if (prefB > prefMap[a][ele2] && prefEle1 > prefMap[ele2][a]) {\\n                    flags[a] = true;\\n                    flags[ele2] = true;\\n                }\\n                \\n                if (prefA > prefMap[b][ele1] && prefEle2 > prefMap[ele1][b]) {\\n                    flags[b] = true;\\n                    flags[ele1] = true;\\n                }\\n                if (prefA > prefMap[b][ele2] && prefEle1 > prefMap[ele2][b]) {\\n                    flags[b] = true;\\n                    flags[ele2] = true;\\n                }\\n            }\\n            \\n        }\\n        \\n        for (boolean flag : flags) {\\n            if (flag) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int[][] prefMap = new int[n][n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n-1; j++) {\\n                prefMap[i][preferences[i][j]] = j;\\n            }\\n        }\\n        \\n        int a,b,prefA,prefB,prefEle1,prefEle2,ele1,ele2;\\n        int count = 0;\\n        boolean[] flags = new boolean[n];\\n        for (int i = 0; i < pairs.length; i++) {\\n            a = pairs[i][0];\\n            b = pairs[i][1];\\n            prefB = prefMap[a][b];\\n            prefA = prefMap[b][a];\\n            for (int j = i+1; j < pairs.length; j++) {\\n                ele1 = pairs[j][0];\\n                ele2 = pairs[j][1];\\n                prefEle2 = prefMap[ele1][ele2];\\n                prefEle1 = prefMap[ele2][ele1];\\n      \\n                if (prefB > prefMap[a][ele1] && prefEle2 > prefMap[ele1][a]) {\\n                    flags[a] = true;\\n                    flags[ele1] = true;\\n                }\\n                if (prefB > prefMap[a][ele2] && prefEle1 > prefMap[ele2][a]) {\\n                    flags[a] = true;\\n                    flags[ele2] = true;\\n                }\\n                \\n                if (prefA > prefMap[b][ele1] && prefEle2 > prefMap[ele1][b]) {\\n                    flags[b] = true;\\n                    flags[ele1] = true;\\n                }\\n                if (prefA > prefMap[b][ele2] && prefEle1 > prefMap[ele2][b]) {\\n                    flags[b] = true;\\n                    flags[ele2] = true;\\n                }\\n            }\\n            \\n        }\\n        \\n        for (boolean flag : flags) {\\n            if (flag) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843937,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(int n, vector<vector<int>>& preferences, vector<int> pairht, int f, int you){\\n        bool isTrue=false;\\n        \\n        for(int i=0; i<n-1; i++){\\n            if(preferences[you][i]==pairht[you]) break;\\n            \\n            if(preferences[you][i]==f)\\n                isTrue=true;\\n        }\\n        \\n        return isTrue;\\n    }\\n    \\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        vector<int> pairht(n);\\n        for(vector<int> pair : pairs){\\n            pairht[pair[0]]=pair[1];\\n            pairht[pair[1]]=pair[0];\\n        }\\n        \\n        int result=0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n-1; j++){\\n                if(preferences[i][j]==pairht[i]) break;\\n                \\n                if(check(n, preferences, pairht, i, preferences[i][j])){\\n                    result++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\nI appreciate your upvote !!",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int n, vector<vector<int>>& preferences, vector<int> pairht, int f, int you){\\n        bool isTrue=false;\\n        \\n        for(int i=0; i<n-1; i++){\\n            if(preferences[you][i]==pairht[you]) break;\\n            \\n            if(preferences[you][i]==f)\\n                isTrue=true;\\n        }\\n        \\n        return isTrue;\\n    }\\n    \\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        vector<int> pairht(n);\\n        for(vector<int> pair : pairs){\\n            pairht[pair[0]]=pair[1];\\n            pairht[pair[1]]=pair[0];\\n        }\\n        \\n        int result=0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n-1; j++){\\n                if(preferences[i][j]==pairht[i]) break;\\n                \\n                if(check(n, preferences, pairht, i, preferences[i][j])){\\n                    result++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2004812,
                "title": "easiest-solution-dictionary-and-array",
                "content": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        \\n        d = {}\\n        count = 0\\n        \\n        for x,y in pairs:\\n            d[x] = list(preferences[x][:preferences[x].index(y)])\\n            d[y] = list(preferences[y][:preferences[y].index(x)])\\n            \\n       \\n        for x, arr in d.items():\\n            for z in arr:\\n                if x in d[z]:\\n                    count+=1\\n                    break\\n                    \\n        return count\\n            \\n            \\n                \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        \\n        d = {}\\n        count = 0\\n        \\n        for x,y in pairs:\\n            d[x] = list(preferences[x][:preferences[x].index(y)])\\n            d[y] = list(preferences[y][:preferences[y].index(x)])\\n            \\n       \\n        for x, arr in d.items():\\n            for z in arr:\\n                if x in d[z]:\\n                    count+=1\\n                    break\\n                    \\n        return count\\n            \\n            \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 847400,
                "title": "java-simple-o-n-solution",
                "content": "We do not need to construct graph. Just iterate input `pairs` array and do what is asked in the problem. To simplify lookup we can store data in `Adjacency matrix`. This implies O(n\\xB2) time complexity and O(n\\xB2) space. We can reduce space to O(n) and use O(n\\xB3) time\\n\\n```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int[][] matrix = new int[n][n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n - 1; j++) {\\n                matrix[i][preferences[i][j]] = j;\\n            }\\n        }\\n        \\n        boolean[] unhappy = new boolean[n];\\n        for (int i = 0; i + i < n; i++) {\\n            int x = pairs[i][0], y = pairs[i][1];\\n            \\n            for (int j = 0; j + j < n; j++) {\\n                if (i == j) continue;\\n                \\n                int u = pairs[j][0], v = pairs[j][1];\\n                if (matrix[x][u] < matrix[x][y] && matrix[u][x] < matrix[u][v]\\n                 || matrix[x][v] < matrix[x][y] && matrix[v][x] < matrix[v][u]) unhappy[x] = true;\\n                if (matrix[y][u] < matrix[y][x] && matrix[u][y] < matrix[u][v]\\n                 || matrix[y][v] < matrix[y][x] && matrix[v][y] < matrix[v][u]) unhappy[y] = true;\\n            }\\n        }\\n        \\n        int answer = 0;\\n        for (int i = 0; i < n; i++) if (unhappy[i]) answer++;\\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int[][] matrix = new int[n][n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n - 1; j++) {\\n                matrix[i][preferences[i][j]] = j;\\n            }\\n        }\\n        \\n        boolean[] unhappy = new boolean[n];\\n        for (int i = 0; i + i < n; i++) {\\n            int x = pairs[i][0], y = pairs[i][1];\\n            \\n            for (int j = 0; j + j < n; j++) {\\n                if (i == j) continue;\\n                \\n                int u = pairs[j][0], v = pairs[j][1];\\n                if (matrix[x][u] < matrix[x][y] && matrix[u][x] < matrix[u][v]\\n                 || matrix[x][v] < matrix[x][y] && matrix[v][x] < matrix[v][u]) unhappy[x] = true;\\n                if (matrix[y][u] < matrix[y][x] && matrix[u][y] < matrix[u][v]\\n                 || matrix[y][v] < matrix[y][x] && matrix[v][y] < matrix[v][u]) unhappy[y] = true;\\n            }\\n        }\\n        \\n        int answer = 0;\\n        for (int i = 0; i < n; i++) if (unhappy[i]) answer++;\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844244,
                "title": "python-short-fast-98-easy-to-understand",
                "content": "In the first step, we form list of sets *better*: for each person, who is better than the current friend in the pair.\\nIn the second step, we go over all pairs of the people to see if they are simultaneously better than their current friends in the pair.\\n\\nThat is it.\\n\\n```\\nclass Solution:\\n    def unhappyFriends(self, n: int, pref: List[List[int]], pairs: List[List[int]]) -> int:\\n        \\n        better=[set() for i in range(n)]\\n        for p1, p2 in pairs:\\n            better[p1]=set(pref[p1][:pref[p1].index(p2)])     \\n            better[p2]=set(pref[p2][:pref[p2].index(p1)])\\n            \\n        unhappy=0\\n        for i in range(n):\\n            if any(i in better[j] for j in better[i]): unhappy += 1\\n                \\n        return unhappy\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, pref: List[List[int]], pairs: List[List[int]]) -> int:\\n        \\n        better=[set() for i in range(n)]\\n        for p1, p2 in pairs:\\n            better[p1]=set(pref[p1][:pref[p1].index(p2)])     \\n            better[p2]=set(pref[p2][:pref[p2].index(p1)])\\n            \\n        unhappy=0\\n        for i in range(n):\\n            if any(i in better[j] for j in better[i]): unhappy += 1\\n                \\n        return unhappy\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1831941,
                "title": "python-solution-easy-to-read-logic-in-the-question",
                "content": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        # Do I prefer someone over you? \\n        # Do they prefer me back over thier person?\\n        # check who my partner is \\n        # Check where I ranked them \\n        # for anyone who ranked earlier than my current partner \\n        # did they rank me earlier than thier current partner? if so I am unhappy\\n        \\n        pairingDict = {}\\n        for i in pairs:\\n            pairingDict[i[0]] = i[1]\\n            pairingDict[i[1]] = i[0]\\n        \\n        def unhappy(main,partner):\\n            #checks if main is unhappy with partner\\n            partnerIndex = preferences[main].index(partner)\\n            if partnerIndex == 0: \\n                return False\\n            partnerIndex -= 1\\n            while partnerIndex >= 0:\\n                better = preferences[main][partnerIndex]\\n                betterPartner = pairingDict[better]\\n                #does better rank me higher then thier current partner? \\n                if preferences[better].index(betterPartner) > preferences[better].index(main):\\n                    return True\\n                partnerIndex -= 1\\n                   \\n        unhappyCount = 0\\n        if len(pairs) == 1:\\n            return 0 \\n        for i in pairs:\\n            # is i[0] unhappy?\\n            if unhappy(i[0],i[1]):\\n                unhappyCount +=1 \\n            if unhappy(i[1],i[0]):\\n                unhappyCount +=1 \\n        return unhappyCount\\n            \\n            \\n            \\n            \\n            \\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        # Do I prefer someone over you? \\n        # Do they prefer me back over thier person?\\n        # check who my partner is \\n        # Check where I ranked them \\n        # for anyone who ranked earlier than my current partner \\n        # did they rank me earlier than thier current partner? if so I am unhappy\\n        \\n        pairingDict = {}\\n        for i in pairs:\\n            pairingDict[i[0]] = i[1]\\n            pairingDict[i[1]] = i[0]\\n        \\n        def unhappy(main,partner):\\n            #checks if main is unhappy with partner\\n            partnerIndex = preferences[main].index(partner)\\n            if partnerIndex == 0: \\n                return False\\n            partnerIndex -= 1\\n            while partnerIndex >= 0:\\n                better = preferences[main][partnerIndex]\\n                betterPartner = pairingDict[better]\\n                #does better rank me higher then thier current partner? \\n                if preferences[better].index(betterPartner) > preferences[better].index(main):\\n                    return True\\n                partnerIndex -= 1\\n                   \\n        unhappyCount = 0\\n        if len(pairs) == 1:\\n            return 0 \\n        for i in pairs:\\n            # is i[0] unhappy?\\n            if unhappy(i[0],i[1]):\\n                unhappyCount +=1 \\n            if unhappy(i[1],i[0]):\\n                unhappyCount +=1 \\n        return unhappyCount\\n            \\n            \\n            \\n            \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 844016,
                "title": "python-simple-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n\\t\\t\\tif n==2:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\thash={}\\n\\t\\t\\tunhappy=0\\n\\t\\t\\tfor i in pairs:\\n\\t\\t\\t\\thash[i[0]]=i[1]\\n\\t\\t\\t\\thash[i[1]]=i[0]\\n\\t\\t\\tfor i in range(len(preferences)):\\n\\t\\t\\t\\tpairedwith=hash[i]\\n\\t\\t\\t\\ttemp=preferences[i][:preferences[i].index(pairedwith)]\\n\\t\\t\\t\\tif len(temp)==0:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tfor j in temp:\\n\\t\\t\\t\\t\\tif preferences[j].index(i)<preferences[j].index(hash[j]):\\n\\t\\t\\t\\t\\t\\tunhappy+=1\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\treturn unhappy",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n\\t\\tdef unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n\\t\\t\\tif n==2:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\thash={}",
                "codeTag": "Java"
            },
            {
                "id": 843939,
                "title": "a-few-solutions",
                "content": "We can use a `\\uD83D\\uDDFA` map `m` to store the `k`<sup>th</sup> preference per `i`<sup>th</sup> friend for O(1) lookups per comparison, ie. the `i`<sup>th</sup> friends\\'s preference for the `j`<sup>th</sup> friend is stored in `m[i][j]`.  And we can use another `\\uD83D\\uDDFA` map `adj` to store adjacent pairs.  Increment the count `cnt` each time we find an `i`,`j` pair where the `i`<sup>th</sup> friend prefers the `j`<sup>th</sup> friend over the `i`<sup>th</sup> friend\\'s adjacent pair and the `j`<sup>th</sup> friend prefers the `i`<sup>th</sup> friend over the `j`<sup>th</sup> friend\\'s adjacent pair.\\n\\n**Note:** Thanks to @andrewquartey for the optimization to make this code more concise \\n\\n---\\n\\n*Javascript*\\n```\\nlet unhappyFriends = (N, pref, pairs, adj = new Map(), cnt = 0) => {\\n    pairs.forEach(([i, j]) => {\\n        adj.set(i, j);\\n        adj.set(j, i);\\n    });\\n    let m = [...Array(N)].map(_ => Array(N).fill(0));\\n    for (let i = 0; i < N; ++i)\\n        for (let j = 0, k = N; j < pref[i].length; ++j, --k)\\n            m[i][pref[i][j]] = k;                     // k-th order of preference (highest preference on the left, lowest preference on the right)\\n    for (let i = 0; i < N; ++i) {\\n        for (let j = 0; j < N; ++j) {\\n            if (i == j)\\n                continue;\\n            if (m[i][j] > m[i][adj.get(i)] &&         // i prefers j over i\\'s adjacent pair\\n                m[j][i] > m[j][adj.get(j)]) {         // j prefers i over j\\'s adjacent pair\\n                ++cnt;\\n                break;                                // \\uD83C\\uDFAF i-th unhappy friend found\\n            }\\n        }\\n    }\\n    return cnt;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def unhappyFriends(self, N: int, pref: List[List[int]], pairs: List[List[int]], cnt = 0) -> int:\\n        adj = {}\\n        for i, j in pairs:\\n            adj[i] = j\\n            adj[j] = i\\n        m = [[0] * N for _ in range(N)]\\n        for i in range(N):\\n            k = N\\n            for j in range(len(pref[i])):\\n                m[i][pref[i][j]] = k; k -= 1   # k-th order of preference (highest preference on the left, lowest preference on the right)\\n        for i in range(N):\\n            for j in range(N):\\n                if i == j:\\n                    continue\\n                if m[i][j] > m[i][adj[i]] and m[j][i] > m[j][adj[j]]:  # i prefers j over i\\'s adjacent pair and j prefers i over j\\'s adjacent pair\\n                    cnt += 1\\n                    break                      # \\uD83C\\uDFAF i-th unhappy friend found\\n        return cnt\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Map = unordered_map<int, int>;\\n    int unhappyFriends(int N, VVI& pref, VVI& pairs, Map adj = {}, int cnt = 0) {\\n        for (auto& pair: pairs) {\\n            auto [i, j] = tie(pair[0], pair[1]);\\n            adj[i] = j;\\n            adj[j] = i;\\n        }\\n        VVI m(N, VI(N));\\n        for (auto i{ 0 }; i < pref.size(); ++i)\\n            for (auto j{ 0 }, k{ N }; j < pref[i].size(); ++j, --k)\\n                m[i][pref[i][j]] = k;                 // k-th order of preference (highest preference on the left, lowest preference on the right)\\n        for (auto i{ 0 }; i < N; ++i) {\\n            for (auto j{ 0 }; j < N; ++j) {\\n                if (i == j)\\n                    continue;\\n                if (m[i][j] > m[i][adj[i]] &&         // i prefers j over i\\'s adjacent pair\\n                    m[j][i] > m[j][adj[j]]) {         // j prefers i over j\\'s adjacent pair\\n                    ++cnt;\\n                    break;                            // \\uD83C\\uDFAF i-th unhappy friend found\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet unhappyFriends = (N, pref, pairs, adj = new Map(), cnt = 0) => {\\n    pairs.forEach(([i, j]) => {\\n        adj.set(i, j);\\n        adj.set(j, i);\\n    });\\n    let m = [...Array(N)].map(_ => Array(N).fill(0));\\n    for (let i = 0; i < N; ++i)\\n        for (let j = 0, k = N; j < pref[i].length; ++j, --k)\\n            m[i][pref[i][j]] = k;                     // k-th order of preference (highest preference on the left, lowest preference on the right)\\n    for (let i = 0; i < N; ++i) {\\n        for (let j = 0; j < N; ++j) {\\n            if (i == j)\\n                continue;\\n            if (m[i][j] > m[i][adj.get(i)] &&         // i prefers j over i\\'s adjacent pair\\n                m[j][i] > m[j][adj.get(j)]) {         // j prefers i over j\\'s adjacent pair\\n                ++cnt;\\n                break;                                // \\uD83C\\uDFAF i-th unhappy friend found\\n            }\\n        }\\n    }\\n    return cnt;\\n};\\n```\n```\\nclass Solution:\\n    def unhappyFriends(self, N: int, pref: List[List[int]], pairs: List[List[int]], cnt = 0) -> int:\\n        adj = {}\\n        for i, j in pairs:\\n            adj[i] = j\\n            adj[j] = i\\n        m = [[0] * N for _ in range(N)]\\n        for i in range(N):\\n            k = N\\n            for j in range(len(pref[i])):\\n                m[i][pref[i][j]] = k; k -= 1   # k-th order of preference (highest preference on the left, lowest preference on the right)\\n        for i in range(N):\\n            for j in range(N):\\n                if i == j:\\n                    continue\\n                if m[i][j] > m[i][adj[i]] and m[j][i] > m[j][adj[j]]:  # i prefers j over i\\'s adjacent pair and j prefers i over j\\'s adjacent pair\\n                    cnt += 1\\n                    break                      # \\uD83C\\uDFAF i-th unhappy friend found\\n        return cnt\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Map = unordered_map<int, int>;\\n    int unhappyFriends(int N, VVI& pref, VVI& pairs, Map adj = {}, int cnt = 0) {\\n        for (auto& pair: pairs) {\\n            auto [i, j] = tie(pair[0], pair[1]);\\n            adj[i] = j;\\n            adj[j] = i;\\n        }\\n        VVI m(N, VI(N));\\n        for (auto i{ 0 }; i < pref.size(); ++i)\\n            for (auto j{ 0 }, k{ N }; j < pref[i].size(); ++j, --k)\\n                m[i][pref[i][j]] = k;                 // k-th order of preference (highest preference on the left, lowest preference on the right)\\n        for (auto i{ 0 }; i < N; ++i) {\\n            for (auto j{ 0 }; j < N; ++j) {\\n                if (i == j)\\n                    continue;\\n                if (m[i][j] > m[i][adj[i]] &&         // i prefers j over i\\'s adjacent pair\\n                    m[j][i] > m[j][adj[j]]) {         // j prefers i over j\\'s adjacent pair\\n                    ++cnt;\\n                    break;                            // \\uD83C\\uDFAF i-th unhappy friend found\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766612,
                "title": "python-3-4-lines-w-explanation-t-m-95-71",
                "content": "Here\\'s how the code works:\\n\\nWe initialize a defaultdict`sc`, which will store the preferred friends for each pair `u` and friend `v` in the pairs.\\n\\nWe iterate [u, v] in the pairs list. For each pair in`pairs`, we assign the preferred friends before`u`and `v` to `sc[u]` and `sc[v]` respectively. The preferred friends are determined by taking a slice of the preferences list for the respective friend up to the index where the other friend is found. This allows easy comparison of preferences.\\n\\nAfter processing all pairs, we iterate over each friend `u`, checking whether there exists a friend `v` in `sc[u]` (i.e., `u` prefers `v`) such that `u` is also present in the preferred friends of `v` (i.e., v`prefers `u` over their current pairing). We check whether any friend in `sc[u]` satisfies this condition.\\n\\nWe return the count of`True`values, which represents the number of unhappy friends.  --*ChatGPT*\\n```\\nclass Solution:\\n\\tdef unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n\\n\\t\\tsc = defaultdict()\\n\\n\\t\\tfor u,v in pairs:\\n\\t\\t\\t\\n\\t\\t\\tsc[u],sc[v] = (preferences[u][:preferences[u].index(v)],\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t preferences[v][:preferences[v].index(u)])\\n\\t\\t\\t\\n\\t\\treturn sum(any(u in sc[v] for v in sc[u]) for u in range(n))\\n```\\n[https://leetcode.com/problems/count-unhappy-friends/submissions/994728034/](http://)\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*^2) and space complexity is *O*(*N*), in which *N* ~`n`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\tdef unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n\\n\\t\\tsc = defaultdict()\\n\\n\\t\\tfor u,v in pairs:\\n\\t\\t\\t\\n\\t\\t\\tsc[u],sc[v] = (preferences[u][:preferences[u].index(v)],\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t preferences[v][:preferences[v].index(u)])\\n\\t\\t\\t\\n\\t\\treturn sum(any(u in sc[v] for v in sc[u]) for u in range(n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693627,
                "title": "easy-c-solution-simple-explanation-only-array-concepts-used",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isUnhappy(int n, vector<vector<int>>& pref, vector<int> pairing, int f, int person){\\n        bool isTrue=false;\\n        for(int i=0; i<n-1; i++){ \\n            if(pref[person][i]==pairing[person])   break;\\n            if(pref[person][i]==f)     isTrue=true;\\n        }\\n        return isTrue;\\n    }\\n    \\n    int unhappyFriends(int n, vector<vector<int>>& pref, vector<vector<int>>& pairs) {\\n        vector<int> pairing(n); \\n        for(vector<int> pair : pairs){ // Pair the friend with their given paired person\\n            pairing[pair[0]]=pair[1];\\n            pairing[pair[1]]=pair[0];\\n        }\\n        int ans=0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n-1; j++){\\n                if(pref[i][j]==pairing[i])   break; // If the friend is paired with their prefered person then break since they are not unhappy\\n                if(isUnhappy(n, pref, pairing, i, pref[i][j])){ // If friend is not paired with their most prefered person, check if they are unhappy\\n                    ans++; // If unhappy then increment ans\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isUnhappy(int n, vector<vector<int>>& pref, vector<int> pairing, int f, int person){\\n        bool isTrue=false;\\n        for(int i=0; i<n-1; i++){ \\n            if(pref[person][i]==pairing[person])   break;\\n            if(pref[person][i]==f)     isTrue=true;\\n        }\\n        return isTrue;\\n    }\\n    \\n    int unhappyFriends(int n, vector<vector<int>>& pref, vector<vector<int>>& pairs) {\\n        vector<int> pairing(n); \\n        for(vector<int> pair : pairs){ // Pair the friend with their given paired person\\n            pairing[pair[0]]=pair[1];\\n            pairing[pair[1]]=pair[0];\\n        }\\n        int ans=0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n-1; j++){\\n                if(pref[i][j]==pairing[i])   break; // If the friend is paired with their prefered person then break since they are not unhappy\\n                if(isUnhappy(n, pref, pairing, i, pref[i][j])){ // If friend is not paired with their most prefered person, check if they are unhappy\\n                    ans++; // If unhappy then increment ans\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780521,
                "title": "python-easy-explained-99-fast",
                "content": "As per the explanation we got to understand that we first have to make somthing that holds people with their priorities and whats better than a DICT to do so . \\nSo we can say as per the first example friend have a preferece:\\n0 : 1,2,3\\n1 : 3,2,0\\n2 : 3,1,0\\n3 : 1,2,0\\n\\nAnd given pairs are  = [[0, 1], [2, 3]]\\n0 is happy, because 1 is the first preferece\\n1 is unhappy, because 3 is its prior preference,\\n2 is happy because 3 is its first preference\\n3 is also unhappy because 1 is its preferece ans\\n\\nSo the total count of unhappy friends are 2\\n\\nStep1: for each, we should check wehther they have a prior preference than the current pair\\n        use a dictionary:\\n        {\\n            0: [ ],1: [3],2: [ ],3: [1]\\n        }\\n  Step2:  then we start the iteration, for each key, if the key appear in the dict[value],\\n        which suggest, the key and the value all have an another prefered choice, then we should\\n        add the result by 1 at last just return res\\n```\\n\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        priority = {}\\n\\t\\t#making priority dictonary\\n        for p1, p2 in pairs:\\n            priority[p1] = preferences[p1][:preferences[p1].index(p2)]\\n            priority[p2] = preferences[p2][:preferences[p2].index(p1)]\\n        #start the iteration\\n        res = 0 #act as a counter for unhappy friends\\n        for p1 in priority:\\n            for p2 in priority[p1]:\\n                if p1 in priority[p2]:\\n                    res += 1\\n                    break\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        priority = {}\\n\\t\\t#making priority dictonary\\n        for p1, p2 in pairs:\\n            priority[p1] = preferences[p1][:preferences[p1].index(p2)]\\n            priority[p2] = preferences[p2][:preferences[p2].index(p1)]\\n        #start the iteration\\n        res = 0 #act as a counter for unhappy friends\\n        for p1 in priority:\\n            for p2 in priority[p1]:\\n                if p1 in priority[p2]:\\n                    res += 1\\n                    break\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2345920,
                "title": "success-details-runtime-394-ms-faster-than-99-40-of-python3-online-submissions-vimla-kushwaha",
                "content": "![image](https://assets.leetcode.com/users/images/7907ab0b-1d01-44a1-96ad-cf5e1009cf74_1659012539.3602684.png)\\n**Best possible solution from me**\\nif you found any doubt .., feel free to ask in comment section\\nkeep smiling seep learning\\n```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        dd = {}\\n        \\n        for i,x in pairs:\\n            dd[i] = preferences[i][:preferences[i].index(x)]\\n            dd[x] = preferences[x][:preferences[x].index(i)]\\n        \\n        ans = 0\\n            \\n        for i in dd:\\n            for x in dd[i]:\\n                if i in dd[x]:\\n                    ans += 1\\n                    break\\n        \\n        return ans\\n```\\n**upote** if it helped you out somehow !1",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        dd = {}\\n        \\n        for i,x in pairs:\\n            dd[i] = preferences[i][:preferences[i].index(x)]\\n            dd[x] = preferences[x][:preferences[x].index(i)]\\n        \\n        ans = 0\\n            \\n        for i in dd:\\n            for x in dd[i]:\\n                if i in dd[x]:\\n                    ans += 1\\n                    break\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2095791,
                "title": "java-o-n-2-with-explanation",
                "content": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        // Store each person\\'s pairing at first. (quickly check in next step) \\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < pairs.length; i++) {\\n            map.put(pairs[i][0], pairs[i][1]);\\n            map.put(pairs[i][1], pairs[i][0]);\\n        }\\n        \\n        int unhappy = 0;\\n        // traverse from the first person\\n        for (int i = 0; i < n; i++) {\\n            \\n            // find x who this person paired with and what\\'s this person\\'s preference\\n            int pairedWith = map.get(i);\\n            int[] preferedList = preferences[i];\\n            \\n\\t\\t\\tfor (int j = 0; j < preferedList.length; j++) {\\n\\t\\t\\t\\tif (preferedList[j] == pairedWith) break;\\n\\n\\t\\t\\t\\t// find the better choice for x and who this better choice paired.\\n\\t\\t\\t\\tint betterChoice = preferedList[j];\\n\\t\\t\\t\\tint betterChoicePaired = map.get(betterChoice);\\n\\n\\t\\t\\t\\t// compare the priority between this better choice paired person and the person i.\\n\\t\\t\\t\\tint btcPairedIndex = 0;\\n\\t\\t\\t\\tint iIndex = 0;\\n\\t\\t\\t\\tfor (int k = 0; k < preferences[betterChoice].length; k++) {\\n\\t\\t\\t\\t\\tif (preferences[betterChoice][k] == betterChoicePaired) {\\n\\t\\t\\t\\t\\t\\tbtcPairedIndex = k;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (preferences[betterChoice][k] == i) {\\n\\t\\t\\t\\t\\t\\tiIndex = k;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// if we find person i has high priority than this better choice paired, this person i is unhappy and continue with the next person.\\n\\t\\t\\t\\tif (iIndex < btcPairedIndex) {\\n\\t\\t\\t\\t\\tunhappy += 1;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n            \\n        }\\n        return unhappy;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        // Store each person\\'s pairing at first. (quickly check in next step) \\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < pairs.length; i++) {\\n            map.put(pairs[i][0], pairs[i][1]);\\n            map.put(pairs[i][1], pairs[i][0]);\\n        }\\n        \\n        int unhappy = 0;\\n        // traverse from the first person\\n        for (int i = 0; i < n; i++) {\\n            \\n            // find x who this person paired with and what\\'s this person\\'s preference\\n            int pairedWith = map.get(i);\\n            int[] preferedList = preferences[i];\\n            \\n\\t\\t\\tfor (int j = 0; j < preferedList.length; j++) {\\n\\t\\t\\t\\tif (preferedList[j] == pairedWith) break;\\n\\n\\t\\t\\t\\t// find the better choice for x and who this better choice paired.\\n\\t\\t\\t\\tint betterChoice = preferedList[j];\\n\\t\\t\\t\\tint betterChoicePaired = map.get(betterChoice);\\n\\n\\t\\t\\t\\t// compare the priority between this better choice paired person and the person i.\\n\\t\\t\\t\\tint btcPairedIndex = 0;\\n\\t\\t\\t\\tint iIndex = 0;\\n\\t\\t\\t\\tfor (int k = 0; k < preferences[betterChoice].length; k++) {\\n\\t\\t\\t\\t\\tif (preferences[betterChoice][k] == betterChoicePaired) {\\n\\t\\t\\t\\t\\t\\tbtcPairedIndex = k;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (preferences[betterChoice][k] == i) {\\n\\t\\t\\t\\t\\t\\tiIndex = k;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// if we find person i has high priority than this better choice paired, this person i is unhappy and continue with the next person.\\n\\t\\t\\t\\tif (iIndex < btcPairedIndex) {\\n\\t\\t\\t\\t\\tunhappy += 1;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n            \\n        }\\n        return unhappy;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247070,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& p,vector<vector<int>>& pairs)\\n    {\\n         vector<vector<int> >map(n+1,vector<int>(n+1,0));\\n         for(int i=0;i<p.size();i++)\\n         {\\n             for(int j=0;j<p[i].size();j++)\\n             {\\n                 map[i][p[i][j]]=n-j;\\n             }\\n         }\\n         \\n        int size=pairs.size();\\n        for(int i=0;i<size;i++)\\n        {\\n            pairs.push_back({pairs[i][1],pairs[i][0]});\\n        }\\n        \\n        vector<int>happy(n+1,1);\\n        \\n        for(int i=0;i<pairs.size()-1;i++)\\n        {\\n            for(int j=i+1;j<pairs.size();j++)\\n            {\\n                      \\n                int x=pairs[i][0];\\n                int y=pairs[i][1];\\n                int u=pairs[j][0];\\n                int v=pairs[j][1];\\n            \\n                if(map[x][u]>map[x][y]&&map[u][x]>map[u][v])\\n                {\\n                    happy[x]=0;\\n                    happy[u]=0;\\n                }\\n            }\\n        }\\n        int count=0;\\n        for(int i=0;i<=n;i++)\\n        {\\n            if(happy[i]==0)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& p,vector<vector<int>>& pairs)\\n    {\\n         vector<vector<int> >map(n+1,vector<int>(n+1,0));\\n         for(int i=0;i<p.size();i++)\\n         {\\n             for(int j=0;j<p[i].size();j++)\\n             {\\n                 map[i][p[i][j]]=n-j;\\n             }\\n         }\\n         \\n        int size=pairs.size();\\n        for(int i=0;i<size;i++)\\n        {\\n            pairs.push_back({pairs[i][1],pairs[i][0]});\\n        }\\n        \\n        vector<int>happy(n+1,1);\\n        \\n        for(int i=0;i<pairs.size()-1;i++)\\n        {\\n            for(int j=i+1;j<pairs.size();j++)\\n            {\\n                      \\n                int x=pairs[i][0];\\n                int y=pairs[i][1];\\n                int u=pairs[j][0];\\n                int v=pairs[j][1];\\n            \\n                if(map[x][u]>map[x][y]&&map[u][x]>map[u][v])\\n                {\\n                    happy[x]=0;\\n                    happy[u]=0;\\n                }\\n            }\\n        }\\n        int count=0;\\n        for(int i=0;i<=n;i++)\\n        {\\n            if(happy[i]==0)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119675,
                "title": "c-short-solution-with-a-story-to-explain",
                "content": "**The love story:**\\n* Didn\\'t play any smart tricks.\\n* Only added a linear storage to make it easier to find everybody\\'s partner. Look up in county record office to find out who is married to who is way too painful. We just want everybody tell us who they married.\\n* After that it is pretty much textbook story: a grumpy husband found out his dream lover actually loves him better than her husband. This make the him very unhappy.\\n* Be careful if the grumpy husband got several dream lovers who loves him more. Even though he is unhappier, we still count him once. We got to break two level loops as soon as we found out he is unhappy.\\n* I suppose we could build a look up map of prefered lovers (before spouse) using unordered_set for everybody. That makes the look up step faster but will definitely use more memory.\\n```\\n  int unhappyFriends(int n, const vector<vector<int>> & preferences, const vector<vector<int>> & pairs) {\\n    vector<int> partner(n);\\n    for (const auto & vec : pairs) {\\n      partner[vec[0]] = vec[1];\\n      partner[vec[1]] = vec[0];\\n    }\\n\\n    int ret = 0;\\n    for (int i=0; i<n; ++i) {\\n      for (const int & pref : preferences[i]) {\\n        bool unhappy = false;\\n        if (pref == partner[i])\\n          break;\\n        for (const int & prefPref : preferences[pref]) {\\n          if (prefPref == i) {\\n            unhappy = true;\\n            break;\\n          }\\n          if (prefPref == partner[pref])\\n            break;\\n        }\\n        if (unhappy) {\\n          ++ret;\\n          break;\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n  int unhappyFriends(int n, const vector<vector<int>> & preferences, const vector<vector<int>> & pairs) {\\n    vector<int> partner(n);\\n    for (const auto & vec : pairs) {\\n      partner[vec[0]] = vec[1];\\n      partner[vec[1]] = vec[0];\\n    }\\n\\n    int ret = 0;\\n    for (int i=0; i<n; ++i) {\\n      for (const int & pref : preferences[i]) {\\n        bool unhappy = false;\\n        if (pref == partner[i])\\n          break;\\n        for (const int & prefPref : preferences[pref]) {\\n          if (prefPref == i) {\\n            unhappy = true;\\n            break;\\n          }\\n          if (prefPref == partner[pref])\\n            break;\\n        }\\n        if (unhappy) {\\n          ++ret;\\n          break;\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1103620,
                "title": "readable-python-solution",
                "content": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n\\n        def find_preferred_friends(x: int) -> List[int]:\\n            \"\"\"\\n            Returns friends of x that have a higher preference than partner.\\n            \"\"\"\\n\\t\\t\\tpartner = partners[x]  # Find the partner of x.\\n            x_friends = friend_prefs[x]  # Find all the friends of x.\\n            partner_ranking = x_friends[partner]  # Get the partner\\'s ranking amongst those friends.\\n            return list(x_friends)[:partner_ranking]  # Return all friends with a preferred lower ranking.\\n\\n        def is_unhappy(x: int) -> bool:\\n            \"\"\"\\n            Returns True if person x is unhappy, otherwise False.\\n            \"\"\"\\n            # Find the partner for person x.\\n            partner = partners[x]  \\n            # Find the friends that person x prefers more than this partner.\\n            preferred_friends = find_preferred_friends(x)  \\n            # A friend is unhappy with their partner if there is another friend with a higher preference \\n            # and that friend prefers them over their partner.\\n            return any(friend_prefs[friend][x] <= friend_prefs[friend][partners[friend]] \\n                       for friend in preferred_friends)\\n\\n        # Create dictionary to lookup friend preference for any person.\\n        friend_prefs = {\\n            person: {friend: pref for pref, friend in enumerate(friends)}\\n            for person, friends in enumerate(preferences)\\n        }\\n\\t\\t# Example:\\n\\t\\t# {0: {1: 0, 3: 1, 2: 2},\\n\\t    #  1: {2: 0, 3: 1, 0: 2},\\n\\t    #  2: {1: 0, 3: 1, 0: 2},\\n\\t    #  3: {0: 0, 2: 1, 1: 2}}\\n \\n        # Create dictionary to find anyone\\'s partner.\\n        partners = {}\\n        for x, y in pairs:\\n            partners[x] = y\\n            partners[y] = x\\n        \\n\\t\\t# Count and return the number of unhappy people.\\n        return sum(is_unhappy(person) for person in range(n))\\n```\\n\\t\\t\\nI used a nested dictionary comprehension to easily find the preference order of any person\\'s friend in `O(1)` time. The solution itself has `O(n^2)` time complexity, because one first iterates over every person and then iterates over that person\\'s friends.  Space complexity is also `O(n^2)` in the worst case where each person is friends with everyone else (`n` people, each with `n - 1` friends).\\n\\nSimilarly, a dictionary is created to easily find a person\\'s partner.\\n\\nThe function `find_preferred_friends` will, for any given person, return a list of all friends preferred to their partner.\\n\\nThe function `is_unhappy` determines if there is any friend with a higher preference (higher preference meaning a lower ranking) who prefers them over that friend\\'s partner.\\n<ul><li> `friend_prefs[friend][x]` returns how `x` is ranked by their friend in terms of preference.</li>\\n<li> `friend_prefs[friend][partners[friend]]` returns the ranking of that friend\\'s partner.</li></ul>\\n\\n\\nThese two rankings are then compared.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n\\n        def find_preferred_friends(x: int) -> List[int]:\\n            \"\"\"\\n            Returns friends of x that have a higher preference than partner.\\n            \"\"\"\\n\\t\\t\\tpartner = partners[x]  # Find the partner of x.\\n            x_friends = friend_prefs[x]  # Find all the friends of x.\\n            partner_ranking = x_friends[partner]  # Get the partner\\'s ranking amongst those friends.\\n            return list(x_friends)[:partner_ranking]  # Return all friends with a preferred lower ranking.\\n\\n        def is_unhappy(x: int) -> bool:\\n            \"\"\"\\n            Returns True if person x is unhappy, otherwise False.\\n            \"\"\"\\n            # Find the partner for person x.\\n            partner = partners[x]  \\n            # Find the friends that person x prefers more than this partner.\\n            preferred_friends = find_preferred_friends(x)  \\n            # A friend is unhappy with their partner if there is another friend with a higher preference \\n            # and that friend prefers them over their partner.\\n            return any(friend_prefs[friend][x] <= friend_prefs[friend][partners[friend]] \\n                       for friend in preferred_friends)\\n\\n        # Create dictionary to lookup friend preference for any person.\\n        friend_prefs = {\\n            person: {friend: pref for pref, friend in enumerate(friends)}\\n            for person, friends in enumerate(preferences)\\n        }\\n\\t\\t# Example:\\n\\t\\t# {0: {1: 0, 3: 1, 2: 2},\\n\\t    #  1: {2: 0, 3: 1, 0: 2},\\n\\t    #  2: {1: 0, 3: 1, 0: 2},\\n\\t    #  3: {0: 0, 2: 1, 1: 2}}\\n \\n        # Create dictionary to find anyone\\'s partner.\\n        partners = {}\\n        for x, y in pairs:\\n            partners[x] = y\\n            partners[y] = x\\n        \\n\\t\\t# Count and return the number of unhappy people.\\n        return sum(is_unhappy(person) for person in range(n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1010654,
                "title": "java-using-hashmap-with-explanation",
                "content": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        \\n        /*  \\n            create a two way mapping for pairs for quick lookup\\n            create a map of preferences\\n            for each friend check if unhappy\\n        */\\n        final Map<Integer, Integer> pairMap = new HashMap<>();\\n        final Map<Integer, Map<Integer, Integer>> preferenceMap = new HashMap<>();\\n        \\n        for(int[] pair : pairs) {\\n            pairMap.put(pair[0], pair[1]);\\n            pairMap.put(pair[1], pair[0]);\\n        }\\n        \\n        for(int i = 0; i < preferences.length; i++) {\\n            preferenceMap.put(i, new HashMap<>());\\n            for(int j = 0; j < preferences[0].length; j++) {\\n                preferenceMap.get(i).put(preferences[i][j], j);\\n            }        \\n        }\\n        int unHappyCount = 0;\\n        for(int[] pair : pairs) {\\n            int p1 = pair[0];\\n            int p2 = pair[1];\\n            \\n            if( ! isHappy(p1, p2, preferences, pairMap, preferenceMap)) {\\n                unHappyCount++;\\n            }\\n            if( ! isHappy(p2, p1, preferences, pairMap, preferenceMap)) {\\n                unHappyCount++;\\n            }\\n        }\\n        return unHappyCount;\\n    }\\n    \\n    private boolean isHappy(int p1, int p2, int[][] preferences, Map<Integer, Integer> pairs, \\n                            Map<Integer, Map<Integer, Integer>> preferenceMap) {\\n        \\n        int[] pref = preferences[p1];\\n        if(pref[0] != p2) {\\n            \\n            int index = preferenceMap.get(p1).get(p2);\\n            /* \\n                for all the friends that are more preferred than the current paired friend\\n                see if there is any friend that prefers p1 over his pair\\n            */\\n            for(int i = 0; i < index; i++) {\\n                int friend = pref[i];    \\n                int friendPair = pairs.get(friend);\\n                 \\n                if(preferenceMap.get(p1).get(friend) < preferenceMap.get(p1).get(p2)\\n                    && preferenceMap.get(friend).get(p1) < preferenceMap.get(friend).get(friendPair)) {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        \\n        /*  \\n            create a two way mapping for pairs for quick lookup\\n            create a map of preferences\\n            for each friend check if unhappy\\n        */\\n        final Map<Integer, Integer> pairMap = new HashMap<>();\\n        final Map<Integer, Map<Integer, Integer>> preferenceMap = new HashMap<>();\\n        \\n        for(int[] pair : pairs) {\\n            pairMap.put(pair[0], pair[1]);\\n            pairMap.put(pair[1], pair[0]);\\n        }\\n        \\n        for(int i = 0; i < preferences.length; i++) {\\n            preferenceMap.put(i, new HashMap<>());\\n            for(int j = 0; j < preferences[0].length; j++) {\\n                preferenceMap.get(i).put(preferences[i][j], j);\\n            }        \\n        }\\n        int unHappyCount = 0;\\n        for(int[] pair : pairs) {\\n            int p1 = pair[0];\\n            int p2 = pair[1];\\n            \\n            if( ! isHappy(p1, p2, preferences, pairMap, preferenceMap)) {\\n                unHappyCount++;\\n            }\\n            if( ! isHappy(p2, p1, preferences, pairMap, preferenceMap)) {\\n                unHappyCount++;\\n            }\\n        }\\n        return unHappyCount;\\n    }\\n    \\n    private boolean isHappy(int p1, int p2, int[][] preferences, Map<Integer, Integer> pairs, \\n                            Map<Integer, Map<Integer, Integer>> preferenceMap) {\\n        \\n        int[] pref = preferences[p1];\\n        if(pref[0] != p2) {\\n            \\n            int index = preferenceMap.get(p1).get(p2);\\n            /* \\n                for all the friends that are more preferred than the current paired friend\\n                see if there is any friend that prefers p1 over his pair\\n            */\\n            for(int i = 0; i < index; i++) {\\n                int friend = pref[i];    \\n                int friendPair = pairs.get(friend);\\n                 \\n                if(preferenceMap.get(p1).get(friend) < preferenceMap.get(p1).get(p2)\\n                    && preferenceMap.get(friend).get(p1) < preferenceMap.get(friend).get(friendPair)) {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 992926,
                "title": "directed-graph-visual-explanation-python",
                "content": "\\n***TL;DR***  build a directed graph of unhappy pairings and then count number of vertices that have bidirectional paths. This count is the number of unhappy friends.\\n\\n(expalantion + visual below) \\n\\n```python\\ndef unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n\\t# build directed graph of unhappy pairs\\n\\tgraph = defaultdict(set)\\n\\tfor (u, v) in pairs:\\n\\t\\tfor pref in preferences[u]:\\n\\t\\t\\tif pref == v:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tgraph[u].add(pref)\\n\\n\\t\\tfor pref in preferences[v]:\\n\\t\\t\\tif pref == u:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tgraph[v].add(pref)\\n\\n\\tunhappy = 0\\n\\t# counts vertices that have a bidirectional path \\n\\tfor node in list(graph.keys()):\\n\\t\\tfor pref in list(graph[node]):\\n\\t\\t\\tif node in graph[pref]:\\n\\t\\t\\t\\tunhappy += 1\\n\\t\\t\\t\\tbreak\\n\\treturn unhappy        \\n```\\n### Overview \\n\\nAn unhappy friend is defined as a friend that cannot be paired with some desired friend. The goal is to count the number of unhappy friends.\\n\\n***Given Input***\\n* a list of desired pairings ```pairs``` of friends i\\n* a list of friends ```preferences``` along with predefined ordering in which friend ```i``` must be paired ```peferences[i]```\\n\\ninitially it seems (from the examples given) that trying all pairs and seeing if they match the predefined ordering is sufficient. \\n\\n```\\nInput: n = 4, \\npreferences = [[1, 2, 3], [3, 2, 0], [3, 1, 0], [1, 2, 0]], \\npairs = [[0, 1], [2, 3]]\\noutput: 2 \\n```\\n\\n***Figure 1***\\n\\n![image](https://assets.leetcode.com/users/images/a07e581a-93eb-443d-8f74-a73b4d6d40fa_1609273549.5380957.png)\\n\\nwalking through all given examples it would seem that, we have found a valid solution. the code would be trivial. \\n\\n```python\\ndef unhappy(n, pairs, preferences):\\n\\tunhappy = 0\\n\\tfor i, j in enumerate(preferences):\\n\\t\\tif preferences[i][0] != j: unhappy += 1 \\n\\t\\tif preferences[j][0] != i: unhappy += 1 \\n\\t\\t\\n\\treturn unhappy \\n``` \\nhowever the given examples are misleading. Observe for a pair ```(u, v)```\\n```\\nn = 4 \\npreferences = [[1,3,2],[2,3,0],[1,0,3],[1,0,2]] \\npairs = [[2,1],[3,0]]\\noutput: 0 \\n```\\n***Figure 2***\\n![image](https://assets.leetcode.com/users/images/940b083d-4b6e-4a05-957d-bf216adafef8_1609273959.3754416.png)\\n\\n\\nour previous logic has failed us. This is because, after forming a happy pair with a friend ```i``` , friend ```i``` and its counter part friend ```j``` are no longer in consideration, because each friend can only be paired once.  \\n\\nnotice the only avenue to a correct solution is the following \\n\\n\\n***Figure 3***\\n![image](https://assets.leetcode.com/users/images/773a63ca-2b7e-425e-a022-a92bc45458fb_1609273607.48063.png)\\n\\n\\nNotice that by removing a friend from consideration (like in the diagram above) makes it possible for other happy pairs to be formed. \\n\\n* However there could be ***any number of friends*** in the way of forming a happy pair and it is impossible to know this in advance with the current approach\\n\\n* Additionally it may be the case that friends in the way of a happy pairing are not removed from consideration  (imagine if friend ```1``` in diagram did not have a happy pairing) \\n\\nThus a different approach is needed. \\n\\nif we construct a directed graph of friends that are blocking us from forming happy pairings we get a birds eye of view of the obstacles in the way of forming happy pairs.\\n\\n![image](https://assets.leetcode.com/users/images/ff71dbb7-b8c8-4c4f-bf33-adcb9e352497_1609212681.0740116.png)\\n\\nrecall in ***Figures 2 & 3*** friend ```1``` was in the way of forming the happy pair (3,0) for both friend ```3``` and friend ```0```. thus the graph has directed edges from ```0 to 1``` and ```3 to 1```.\\n\\n### Counting Unhappy Friends\\n\\nFor a ***happy pair*** ```(u, v)```  a friend ```u``` ***can*** be paired with a friend ```t``` in the predefined ordering for ```u``` that is equivalent to ```v```  ***or*** a friend ```v``` ***can*** be paired with a friend ```s``` in the predefined ordering for ```v``` that is equivalent to ```u```. either way a happy pair has been formed. the order in which this happy pair is formed is irrelevalnt. \\n \\nGiven a ***happy pair*** ```(t, u)``` an ***unhappy pair*** ```(t, s)```,  is defined as, the following. a  friend ```t``` is  be paired with a friend ```s``` in the predefined ordering for ```t``` that is ***not*** equivalent to ```u```  ***and*** a friend ```s``` is  be paired with friend ```t``` that also exists in the predefined ordering for ```s```.  \\n\\nthe key insight is ```t``` fails to form a ***happy pair*** with ```s``` and ```s``` fails to form a ***happy pair*** with ```t```\\n\\nwe record failed friend pair orderings as directed edges between verticies (friends) in a graph. According to the above logic if a directed edge exists from ```t``` to``` s```and a directed edge exists from ```s``` to ```t``` (forming a bidirectional path between ```t``` and ```s```) then friend ```t``` and friend ```s```  are ***unhappy***.\\n\\n\\ntherefore count the number of bidirectional paths in the directed graph just construted to get the number of unhappy friends, \\n\\n```\\nInput: n = 4\\npreferences = [[1, 3, 2], [2, 3, 0], [1, 3, 0], [0, 2, 1]]\\npairs = [[1, 3], [0, 2]]\\nOutput: 4\\n```\\n\\n![image](https://assets.leetcode.com/users/images/8dbdc348-1a6c-4a0b-8496-1c710d42e991_1609278893.1305532.png)\\n\\n\\nnotice that ```4``` different vertices have bi-directional paths to another vertex. if we count all these verticies we get the number of unhappy friends.\\n\\n### Additional Thoughts \\n\\ni wrote this post as i had a very difficult time understanding the why behind any solutions in the disscussion section. i could understand the code, but i had no idea why it was correct. my hopes with this post was to provide readers with the why and make up for the lack of an official leetcode solution article. \\n\\nAdditionally this question is ***hard to read*** and the examples given in the problem statement are misleading. \\n\\n* Adding this example to the problem statement would greatly improve the readability of this question. \\n\\n```\\nn = 4 \\npreferences = [[1,3,2],[2,3,0],[1,0,3],[1,0,2]] \\npairs = [[2,1],[3,0]]\\noutput: 0 \\n```\\nlastly in my opinion, this question should be labeled as ***Hard***, the solution itself is not difficult to implement, but the reasoning required to get a valid solution is rather difficult.\\n\\n[code courtesy of OldeElk](https://leetcode.com/problems/count-unhappy-friends/discuss/855428/Python-Directed-graph-linking-nodes-with-unmatched-preferred-friends-then-count-bi-directions)\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Graph"
                ],
                "code": "```python\\ndef unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n\\t# build directed graph of unhappy pairs\\n\\tgraph = defaultdict(set)\\n\\tfor (u, v) in pairs:\\n\\t\\tfor pref in preferences[u]:\\n\\t\\t\\tif pref == v:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tgraph[u].add(pref)\\n\\n\\t\\tfor pref in preferences[v]:\\n\\t\\t\\tif pref == u:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tgraph[v].add(pref)\\n\\n\\tunhappy = 0\\n\\t# counts vertices that have a bidirectional path \\n\\tfor node in list(graph.keys()):\\n\\t\\tfor pref in list(graph[node]):\\n\\t\\t\\tif node in graph[pref]:\\n\\t\\t\\t\\tunhappy += 1\\n\\t\\t\\t\\tbreak\\n\\treturn unhappy        \\n```\n```pairs```\n```preferences```\n```i```\n```peferences[i]```\n```\\nInput: n = 4, \\npreferences = [[1, 2, 3], [3, 2, 0], [3, 1, 0], [1, 2, 0]], \\npairs = [[0, 1], [2, 3]]\\noutput: 2 \\n```\n```python\\ndef unhappy(n, pairs, preferences):\\n\\tunhappy = 0\\n\\tfor i, j in enumerate(preferences):\\n\\t\\tif preferences[i][0] != j: unhappy += 1 \\n\\t\\tif preferences[j][0] != i: unhappy += 1 \\n\\t\\t\\n\\treturn unhappy \\n```\n```(u, v)```\n```\\nn = 4 \\npreferences = [[1,3,2],[2,3,0],[1,0,3],[1,0,2]] \\npairs = [[2,1],[3,0]]\\noutput: 0 \\n```\n```i```\n```i```\n```j```\n```1```\n```1```\n```3```\n```0```\n```0 to 1```\n```3 to 1```\n```(u, v)```\n```u```\n```t```\n```u```\n```v```\n```v```\n```s```\n```v```\n```u```\n```(t, u)```\n```(t, s)```\n```t```\n```s```\n```t```\n```u```\n```s```\n```t```\n```s```\n```t```\n```s```\n```s```\n```t```\n```t```\n``` s```\n```s```\n```t```\n```t```\n```s```\n```t```\n```s```\n```\\nInput: n = 4\\npreferences = [[1, 3, 2], [2, 3, 0], [1, 3, 0], [0, 2, 1]]\\npairs = [[1, 3], [0, 2]]\\nOutput: 4\\n```\n```4```\n```\\nn = 4 \\npreferences = [[1,3,2],[2,3,0],[1,0,3],[1,0,2]] \\npairs = [[2,1],[3,0]]\\noutput: 0 \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 845417,
                "title": "nobel-prize-winning-stable-marriage-problem-simpler-code-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& p, vector<vector<int>>& pairs) {\\n        unordered_map<int, int> m;\\n        vector<vector<int>> pref(n, vector<int>(n, 0));\\n        //.  x has a better choice in u and u has a better choice in x\\n        //   [------------------Stable Marriage Problem --------------]\\n        //    u |         |\\n        //   ---|         | x\\n        //.   * |         |----    \\n        //   ---|         | *\\n        //    y | x       | *\\n        //   -------  ---------\\n        //      |       u | v \\n        //      |         |\\n        for (int i = 0; i < pairs.size(); i++) {\\n            m[pairs[i][0]] = pairs[i][1];\\n            m[pairs[i][1]] = pairs[i][0];\\n        }\\n        for (int x = 0; x < n; x++) {\\n            for (int pos = 0; pos < p[x].size(); pos++) {\\n                int u = p[x][pos];\\n                pref[x][u] = pos;\\n            }\\n        }\\n        set<int> res;\\n        for (auto &pr: m) {\\n            int x = pr.first, y = pr.second;\\n            // for u, a pref of x ahead of y, is there a pref x ahead of it\\'s pair, v?\\n            for (int i = 0; i < pref[x][y]; i++) {\\n                int u = p[x][i], v = m[u];\\n                if (pref[u][x] < pref[u][v]) {\\n                    res.insert(u); res.insert(x);\\n                }\\n            }\\n        }\\n        return res.size();\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& p, vector<vector<int>>& pairs) {\\n        unordered_map<int, int> m;\\n        vector<vector<int>> pref(n, vector<int>(n, 0));\\n        //.  x has a better choice in u and u has a better choice in x\\n        //   [------------------Stable Marriage Problem --------------]\\n        //    u |         |\\n        //   ---|         | x\\n        //.   * |         |----    \\n        //   ---|         | *\\n        //    y | x       | *\\n        //   -------  ---------\\n        //      |       u | v \\n        //      |         |\\n        for (int i = 0; i < pairs.size(); i++) {\\n            m[pairs[i][0]] = pairs[i][1];\\n            m[pairs[i][1]] = pairs[i][0];\\n        }\\n        for (int x = 0; x < n; x++) {\\n            for (int pos = 0; pos < p[x].size(); pos++) {\\n                int u = p[x][pos];\\n                pref[x][u] = pos;\\n            }\\n        }\\n        set<int> res;\\n        for (auto &pr: m) {\\n            int x = pr.first, y = pr.second;\\n            // for u, a pref of x ahead of y, is there a pref x ahead of it\\'s pair, v?\\n            for (int i = 0; i < pref[x][y]; i++) {\\n                int u = p[x][i], v = m[u];\\n                if (pref[u][x] < pref[u][v]) {\\n                    res.insert(u); res.insert(x);\\n                }\\n            }\\n        }\\n        return res.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793465,
                "title": "python3-using-dictionary-of-sets",
                "content": "class Solution:\\n\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        maps = {}\\n        for x,y in pairs:\\n            maps[x] = set(preferences[x][:preferences[x].index(y)])\\n            maps[y] = set(preferences[y][:preferences[y].index(x)])\\n            \\n        res = 0\\n        \\n        for x in maps:\\n            for y in maps[x]:\\n                if x in maps[y]:\\n                    res+=1\\n                    break\\n                    \\n        return res",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        maps = {}",
                "codeTag": "Java"
            },
            {
                "id": 1917128,
                "title": "java-solution",
                "content": "STEP 1: store current assigned partners in array\\n\\nSTEP 2: store in hashmap for each person, the partners they PREFERRED over their assigned partner. For example, if person 1 has a preference list of (2,5,3) and was ASSIGNED 3, then they prefer 2 and 5 over 3. Therefore, we store 1 as the key and <2,5> as the value in our hashmap.\\n\\nSTEP3: A person is unhappy if they prefer someone else and that someone else ALSO prefers them. We can count this quantity by iterating over each person in the hashmap which represented the people they prefer over their asigned and check if they also prefer them. By the example above, we\\'ll look at person 1 who prefers <2,5> over their current partner, iterate over person 2 and 5 to check if they also prefer person 1. If so, increment number of unhappy people and break to continue onto the next person.\\n\\n```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        // fill assigned O(N)\\n        int[] assigned = new int[n];\\n        for (int[] p : pairs) {\\n            assigned[p[0]] = p[1];\\n            assigned[p[1]] = p[0];\\n        }\\n        \\n        // store preferred over current\\n        Map<Integer,Set<Integer>> preferred = new HashMap<>();\\n        for (int i=0; i<n; i++) {\\n            Set<Integer> before = new HashSet<>();\\n            int currPartner = assigned[i];\\n            for (int p : preferences[i]) {\\n                if (p == currPartner) {\\n                    break;\\n                }\\n                before.add(p);\\n            }\\n            preferred.put(i, before);\\n        }\\n        \\n        // count unhappy\\n        int unhappy = 0;\\n        for (int i=0; i<n; i++) {\\n            for (int p : preferred.get(i)) {\\n                if (preferred.get(p).contains(i)) {\\n                    unhappy++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return unhappy;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        // fill assigned O(N)\\n        int[] assigned = new int[n];\\n        for (int[] p : pairs) {\\n            assigned[p[0]] = p[1];\\n            assigned[p[1]] = p[0];\\n        }\\n        \\n        // store preferred over current\\n        Map<Integer,Set<Integer>> preferred = new HashMap<>();\\n        for (int i=0; i<n; i++) {\\n            Set<Integer> before = new HashSet<>();\\n            int currPartner = assigned[i];\\n            for (int p : preferences[i]) {\\n                if (p == currPartner) {\\n                    break;\\n                }\\n                before.add(p);\\n            }\\n            preferred.put(i, before);\\n        }\\n        \\n        // count unhappy\\n        int unhappy = 0;\\n        for (int i=0; i<n; i++) {\\n            for (int p : preferred.get(i)) {\\n                if (preferred.get(p).contains(i)) {\\n                    unhappy++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return unhappy;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1163188,
                "title": "javascript-hashmap",
                "content": "```\\nvar unhappyFriends = function(n, preferences, pairs) {\\n    /*\\n        create a hashMap with the preferences for a faster look ups,\\n        traverse through pairs and compare, increment the count if current\\n        friend ranks some other friend higher than his pair and that other friend\\n        ranks current higher than his pair\\n    */\\n    let happyMap = new Map();\\n    for (let pair of pairs) {\\n        happyMap.set(pair[0], pair[1]);\\n        happyMap.set(pair[1], pair[0]);\\n    }\\n    \\n    let ranks = new Map();\\n    for (let i = 0; i < n; i ++) {\\n        ranks.set(i, new Map());\\n        for (let j = 0; j < n - 1; j ++) {\\n            ranks.get(i).set(preferences[i][j], j);\\n        }\\n    }\\n    \\n    let unhappy = 0;\\n    for (let i = 0; i < n; i ++) {\\n        let pair = happyMap.get(i);\\n        let preference = ranks.get(i).get(pair);\\n        if (preference === 0) continue;\\n        for (let j = 0; j < n - 1; j ++) {\\n            let currFriend = preferences[i][j];\\n            let friendPair = happyMap.get(currFriend);\\n            let friendPreference = ranks.get(currFriend).get(friendPair);\\n            if (ranks.get(i).get(currFriend) < preference &&\\n                ranks.get(currFriend).get(i) < friendPreference) {\\n                unhappy ++;\\n                break;\\n            }\\n        }\\n    }\\n    \\n    return unhappy;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar unhappyFriends = function(n, preferences, pairs) {\\n    /*\\n        create a hashMap with the preferences for a faster look ups,\\n        traverse through pairs and compare, increment the count if current\\n        friend ranks some other friend higher than his pair and that other friend\\n        ranks current higher than his pair\\n    */\\n    let happyMap = new Map();\\n    for (let pair of pairs) {\\n        happyMap.set(pair[0], pair[1]);\\n        happyMap.set(pair[1], pair[0]);\\n    }\\n    \\n    let ranks = new Map();\\n    for (let i = 0; i < n; i ++) {\\n        ranks.set(i, new Map());\\n        for (let j = 0; j < n - 1; j ++) {\\n            ranks.get(i).set(preferences[i][j], j);\\n        }\\n    }\\n    \\n    let unhappy = 0;\\n    for (let i = 0; i < n; i ++) {\\n        let pair = happyMap.get(i);\\n        let preference = ranks.get(i).get(pair);\\n        if (preference === 0) continue;\\n        for (let j = 0; j < n - 1; j ++) {\\n            let currFriend = preferences[i][j];\\n            let friendPair = happyMap.get(currFriend);\\n            let friendPreference = ranks.get(currFriend).get(friendPair);\\n            if (ranks.get(i).get(currFriend) < preference &&\\n                ranks.get(currFriend).get(i) < friendPreference) {\\n                unhappy ++;\\n                break;\\n            }\\n        }\\n    }\\n    \\n    return unhappy;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1073085,
                "title": "c-i-m-unhappy-if-my-gf-loves-me-more-than-her-bf",
                "content": "Suppose Amy loves me more than her boyfriend. Amy is not with me and I love Amy than my girlfriend. So I am unhappy:(\\n* All we have to do is to check the If the girls I love more than my current girlfriend love me more than their boyfriend.\\n* If there is any girl loves me more than her mate ( It is technically impossible for me:/ ) I would be unhappy:(\\n* Assuming unordered_map provides constant time access, my solution is O(n^2) since we are checking preferences array for each n person [n*(n-1) in worst case].\\n\\n```\\nclass Solution {\\npublic:\\n    bool isHappy(int curr,vector<int>&mates,vector<unordered_map<int,int>>&dudes,vector<vector<int>>&preferences,int n){\\n        int i = 0;\\n        while(preferences[curr][i]!=mates[curr]){\\n            int lovedMore = preferences[curr][i];\\n            if(dudes[lovedMore][curr]>dudes[lovedMore][mates[lovedMore]]){\\n                return false;\\n            }\\n            i++;\\n        }\\n        return true;\\n    }\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>&pairs){\\n        int result = 0;\\n        vector<unordered_map<int,int>>dudes(n);\\n        vector<int>mates(n);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n-1;j++){\\n                dudes[i][preferences[i][j]] = n-j;\\n            }\\n        }\\n        for(int i=0;i<n/2;i++){\\n            mates[pairs[i][0]] = pairs[i][1];\\n            mates[pairs[i][1]] = pairs[i][0];\\n        }\\n        for(int i=0;i<n/2;i++){\\n            if(isHappy(pairs[i][0],mates,dudes,preferences,n)==false){result++;}\\n            if(isHappy(pairs[i][1],mates,dudes,preferences,n)==false){result++;}\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isHappy(int curr,vector<int>&mates,vector<unordered_map<int,int>>&dudes,vector<vector<int>>&preferences,int n){\\n        int i = 0;\\n        while(preferences[curr][i]!=mates[curr]){\\n            int lovedMore = preferences[curr][i];\\n            if(dudes[lovedMore][curr]>dudes[lovedMore][mates[lovedMore]]){\\n                return false;\\n            }\\n            i++;\\n        }\\n        return true;\\n    }\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>&pairs){\\n        int result = 0;\\n        vector<unordered_map<int,int>>dudes(n);\\n        vector<int>mates(n);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n-1;j++){\\n                dudes[i][preferences[i][j]] = n-j;\\n            }\\n        }\\n        for(int i=0;i<n/2;i++){\\n            mates[pairs[i][0]] = pairs[i][1];\\n            mates[pairs[i][1]] = pairs[i][0];\\n        }\\n        for(int i=0;i<n/2;i++){\\n            if(isHappy(pairs[i][0],mates,dudes,preferences,n)==false){result++;}\\n            if(isHappy(pairs[i][1],mates,dudes,preferences,n)==false){result++;}\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887100,
                "title": "python3-straightforward-solution-count-unhappy-friends",
                "content": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        ranks = {}\\n        for person, pref in enumerate(preferences):\\n            ranks[person] = defaultdict(lambda: n)\\n            for rank, peer in enumerate(pref):\\n                ranks[person][peer] = rank\\n        partner = {}        \\n        for p1, p2 in pairs:\\n            partner[p1] = p2\\n            partner[p2] = p1\\n        ans = 0\\n        for p1, p2 in pairs:\\n            for peer in preferences[p1]:\\n                if (ranks[p1][peer] < ranks[p1][p2] and\\n                    ranks[peer][p1] < ranks[peer][partner[peer]]):\\n                    ans += 1\\n                    break\\n            for peer in preferences[p2]:\\n                if (ranks[p2][peer] < ranks[p2][p1] and\\n                    ranks[peer][p2] < ranks[peer][partner[peer]]):\\n                    ans += 1\\n                    break\\n        return ans  \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        ranks = {}\\n        for person, pref in enumerate(preferences):\\n            ranks[person] = defaultdict(lambda: n)\\n            for rank, peer in enumerate(pref):\\n                ranks[person][peer] = rank\\n        partner = {}        \\n        for p1, p2 in pairs:\\n            partner[p1] = p2\\n            partner[p2] = p1\\n        ans = 0\\n        for p1, p2 in pairs:\\n            for peer in preferences[p1]:\\n                if (ranks[p1][peer] < ranks[p1][p2] and\\n                    ranks[peer][p1] < ranks[peer][partner[peer]]):\\n                    ans += 1\\n                    break\\n            for peer in preferences[p2]:\\n                if (ranks[p2][peer] < ranks[p2][p1] and\\n                    ranks[peer][p2] < ranks[peer][partner[peer]]):\\n                    ans += 1\\n                    break\\n        return ans  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 855428,
                "title": "python-directed-graph-linking-nodes-with-unmatched-preferred-friends-then-count-bi-directions",
                "content": "Construct a directed graph linking the node with their unmatched preferred friends, then count nodes with bi-connections.\\n\\nNote that we are counting the # of unhappy nodes, but not # of unhappy pairs. So that even one node can be paired with multiple others to be unhappy, we only count them once.\\n```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def unhappyFriends(self, n, preferences, pairs):\\n        \"\"\"\\n        :type n: int\\n        :type preferences: List[List[int]]\\n        :type pairs: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        graph = defaultdict(set)\\n        for (u, v) in pairs:\\n            for pref in preferences[u]:\\n                if pref == v:\\n                    break\\n                graph[u].add(pref)\\n            for pref in preferences[v]:\\n                if pref == u:\\n                    break\\n                graph[v].add(pref)\\n        \\n        rst = 0\\n        for node in graph.keys():\\n            for pref in list(graph[node]):\\n                if node in graph[pref]:\\n                    rst += 1\\n                    break\\n        return rst\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def unhappyFriends(self, n, preferences, pairs):\\n        \"\"\"\\n        :type n: int\\n        :type preferences: List[List[int]]\\n        :type pairs: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        graph = defaultdict(set)\\n        for (u, v) in pairs:\\n            for pref in preferences[u]:\\n                if pref == v:\\n                    break\\n                graph[u].add(pref)\\n            for pref in preferences[v]:\\n                if pref == u:\\n                    break\\n                graph[v].add(pref)\\n        \\n        rst = 0\\n        for node in graph.keys():\\n            for pref in list(graph[node]):\\n                if node in graph[pref]:\\n                    rst += 1\\n                    break\\n        return rst\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844264,
                "title": "python3-n-2-time-straight-forward-mapping-and-comparing",
                "content": "```\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:      \\n        r=[[None]*n for _ in range(n)]\\n        # r[a][b]: for a, the rank of b\\n        for a,others_for_a in enumerate(preferences):\\n            for rank,b in enumerate(others_for_a):\\n                r[a][b]=rank\\n        unhappy_people=set()        \\n        def unhappy(a,b,c,d):\\n            if r[a][c]<r[a][b] and r[c][a]<r[c][d]:\\n                unhappy_people.add(a)\\n                unhappy_people.add(c)\\n        for i,pair1 in enumerate(pairs):\\n            for pair2 in pairs[i+1::]:\\n                a,b=pair1\\n                c,d=pair2\\n                unhappy(a,b,c,d)\\n                unhappy(b,a,c,d)\\n                unhappy(a,b,d,c)\\n                unhappy(b,a,d,c)\\n        return len(unhappy_people)\\n```",
                "solutionTags": [],
                "code": "```\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:      \\n        r=[[None]*n for _ in range(n)]\\n        # r[a][b]: for a, the rank of b\\n        for a,others_for_a in enumerate(preferences):\\n            for rank,b in enumerate(others_for_a):\\n                r[a][b]=rank\\n        unhappy_people=set()        \\n        def unhappy(a,b,c,d):\\n            if r[a][c]<r[a][b] and r[c][a]<r[c][d]:\\n                unhappy_people.add(a)\\n                unhappy_people.add(c)\\n        for i,pair1 in enumerate(pairs):\\n            for pair2 in pairs[i+1::]:\\n                a,b=pair1\\n                c,d=pair2\\n                unhappy(a,b,c,d)\\n                unhappy(b,a,c,d)\\n                unhappy(a,b,d,c)\\n                unhappy(b,a,d,c)\\n        return len(unhappy_people)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 844207,
                "title": "c-simple-fast-worst-case-o-n-2-100-84ms-24mb-using-bitset",
                "content": "The theory is simple:\\nfor each person `x`, we mark [all friends in his preferences list that prior to the person actually paired] in the check list, so later the friends will check if they prefer `x` than the person they are paired. If they do, we mark both people unhappy.\\n\\n```cpp\\nint unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n    bitset<500> unhappy{0};\\n    vector<bitset<500>> checkList(n);\\n    array<pair<int, int>, 2> thisPair;\\n    for (auto &p : pairs) {\\n        thisPair[0] = {p[0], p[1]}, thisPair[1] = {p[1], p[0]};\\n        for (auto [a, b] : thisPair) {\\n            for (int f : preferences[a]) {\\n                if (f == b) break;\\n                checkList[f].set(a);\\n                if (checkList[a][f])\\n                    unhappy.set(a), unhappy.set(f);\\n            }\\n        }\\n    }\\n    return unhappy.count();\\n}\\n```\\n\\nTime complexity:\\nFor each person (n people), we check his preference list (lenghth n) until the paired person, so the worst case is O(n<sup>2</sup>)\\nSpace:\\nIt looks like O(n), but since n <= 500, it\\'s actually >= O(n<sup>2</sup>) (but much less than other solutions, bitset<500> is only 64 bytes)\\nIf we can use something like `boost::dynamic_bitset`, then O(n<sup>2</sup>)\\n",
                "solutionTags": [],
                "code": "```cpp\\nint unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n    bitset<500> unhappy{0};\\n    vector<bitset<500>> checkList(n);\\n    array<pair<int, int>, 2> thisPair;\\n    for (auto &p : pairs) {\\n        thisPair[0] = {p[0], p[1]}, thisPair[1] = {p[1], p[0]};\\n        for (auto [a, b] : thisPair) {\\n            for (int f : preferences[a]) {\\n                if (f == b) break;\\n                checkList[f].set(a);\\n                if (checkList[a][f])\\n                    unhappy.set(a), unhappy.set(f);\\n            }\\n        }\\n    }\\n    return unhappy.count();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 844051,
                "title": "python3-brute-force-solution",
                "content": "Spent more time in understanding question instead of coding.\\n> Each person is contained in exactly one pair. \\n\\nis important.\\n> A friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\\nx prefers u over y, and\\nu prefers x over v.\\n\\nfor each person x, he has only one pair y. So we can get y from f that is a dict record pairs.\\n\\'x prefers u over y\\' means u is in preferences[x] before y.\\nwe get u, and we get v from `f[u]`,\\nthen we judge whether x before v in preferences[u].\\n\\n```python\\n    def unhappyFriends(self, n: int, pres: List[List[int]], pairs: List[List[int]]) -> int:\\n        f = collections.defaultdict(int)\\n        ans = 0\\n        for u, v in pairs:\\n            f[u] = v\\n            f[v] = u\\n        \\n        def count(x):\\n            y = f[x]\\n            for u in pres[x]:\\n                if u == y:\\n                    break\\n                for pre in pres[u]:\\n                    if pre == f[u]:\\n                        break\\n                    if pre == x:\\n                        return 1\\n            return 0\\n        \\n        return sum(count(i) for i in range(n))\\n```",
                "solutionTags": [],
                "code": "```python\\n    def unhappyFriends(self, n: int, pres: List[List[int]], pairs: List[List[int]]) -> int:\\n        f = collections.defaultdict(int)\\n        ans = 0\\n        for u, v in pairs:\\n            f[u] = v\\n            f[v] = u\\n        \\n        def count(x):\\n            y = f[x]\\n            for u in pres[x]:\\n                if u == y:\\n                    break\\n                for pre in pres[u]:\\n                    if pre == f[u]:\\n                        break\\n                    if pre == x:\\n                        return 1\\n            return 0\\n        \\n        return sum(count(i) for i in range(n))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 844034,
                "title": "python-3-brutal-force-hash-table-o-n-2-explanations",
                "content": "### Explanation\\n- Given (a, b) & (c, d) there are only for possibilities, simply list them all\\n\\t- a & c prefer each other\\n\\t- a & d prefer each other\\n\\t- b & c prefer each other\\n\\t- b & d prefer each other\\n- Since we need to check index of each other to find out the preference, it\\'s better to use a **hash table** to store these information. I used a `defaultdict of defaultdict`, you can use matrix I believe.\\n- Assuming everyone is happy initially, if we found out someone is not happy, mark it\\n- At the very end, sum up all unhappy person\\n### Implementation\\n```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        idx_table = collections.defaultdict(lambda: collections.defaultdict(int))\\n        for i in range(n):\\n            for idx, person in enumerate(preferences[i]): idx_table[i][person] = idx\\n                \\n        unhappy = [0] * n\\n        for i in range(n//2):\\n            a, b = pairs[i]\\n            b_a_idx, a_b_idx = idx_table[b][a], idx_table[a][b]\\n            for j in range(i+1, n//2):\\n                c, d = pairs[j]\\n                \\n                c_a_idx = idx_table[c][a]\\n                c_b_idx = idx_table[c][b]\\n                c_d_idx = idx_table[c][d]\\n                \\n                d_a_idx = idx_table[d][a] \\n                d_b_idx = idx_table[d][b] \\n                d_c_idx = idx_table[d][c] \\n                \\n                a_c_idx = idx_table[a][c] \\n                a_d_idx = idx_table[a][d] \\n                \\n                b_c_idx = idx_table[b][c] \\n                b_d_idx = idx_table[b][d] \\n                \\n                if c_a_idx < c_d_idx and a_c_idx < a_b_idx: unhappy[a] = unhappy[c] = 1 # a & c prefer each other\\n                if d_a_idx < d_c_idx and a_d_idx < a_b_idx: unhappy[a] = unhappy[d] = 1 # a & d prefer each other\\n                if c_b_idx < c_d_idx and b_c_idx < b_a_idx: unhappy[b] = unhappy[c] = 1 # b & c prefer each other\\n                if d_b_idx < d_c_idx and b_d_idx < b_a_idx: unhappy[b] = unhappy[d] = 1 # b & d prefer each other\\n        return sum(unhappy)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        idx_table = collections.defaultdict(lambda: collections.defaultdict(int))\\n        for i in range(n):\\n            for idx, person in enumerate(preferences[i]): idx_table[i][person] = idx\\n                \\n        unhappy = [0] * n\\n        for i in range(n//2):\\n            a, b = pairs[i]\\n            b_a_idx, a_b_idx = idx_table[b][a], idx_table[a][b]\\n            for j in range(i+1, n//2):\\n                c, d = pairs[j]\\n                \\n                c_a_idx = idx_table[c][a]\\n                c_b_idx = idx_table[c][b]\\n                c_d_idx = idx_table[c][d]\\n                \\n                d_a_idx = idx_table[d][a] \\n                d_b_idx = idx_table[d][b] \\n                d_c_idx = idx_table[d][c] \\n                \\n                a_c_idx = idx_table[a][c] \\n                a_d_idx = idx_table[a][d] \\n                \\n                b_c_idx = idx_table[b][c] \\n                b_d_idx = idx_table[b][d] \\n                \\n                if c_a_idx < c_d_idx and a_c_idx < a_b_idx: unhappy[a] = unhappy[c] = 1 # a & c prefer each other\\n                if d_a_idx < d_c_idx and a_d_idx < a_b_idx: unhappy[a] = unhappy[d] = 1 # a & d prefer each other\\n                if c_b_idx < c_d_idx and b_c_idx < b_a_idx: unhappy[b] = unhappy[c] = 1 # b & c prefer each other\\n                if d_b_idx < d_c_idx and b_d_idx < b_a_idx: unhappy[b] = unhappy[d] = 1 # b & d prefer each other\\n        return sum(unhappy)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3127271,
                "title": "optimal-rust-approach",
                "content": "# Complexity\\n- Time complexity: $$O(n ^ 2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$ ?\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn unhappy_friends(n: i32, prefs: Vec<Vec<i32>>, pairs: Vec<Vec<i32>>) -> i32 {\\n        let n = n as usize;\\n        let (prefs, pairs) = (Self::pref_up(&prefs, n), Self::pair_up(pairs, n));\\n        let mut ans = 0;\\n        // If x prefers u over y and u prefers x over v\\n        for a in 0..n {\\n            // a lovers\\n            if (0..n).any(|v| prefs[a][v] < prefs[a][pairs[a]] && prefs[v][a] < prefs[v][pairs[v]])\\n            {\\n                ans += 1;\\n            }\\n        }\\n        ans\\n    }\\n\\n    fn pref_up(prefs: &Vec<Vec<i32>>, n: usize) -> Vec<Vec<usize>> {\\n        let mut ans = vec![vec![n; n]; n];\\n        for (num, pref) in prefs.into_iter().enumerate() {\\n            for (pos, &fav) in pref.into_iter().enumerate() {\\n                ans[num][fav as usize] = pos;\\n            }\\n        }\\n        ans\\n    }\\n\\n    fn pair_up(pairs: Vec<Vec<i32>>, n: usize) -> Vec<usize> {\\n        let mut ans = vec![n; n];\\n        for pair in pairs {\\n            let (a, b) = (pair[0] as usize, pair[1] as usize);\\n            ans[a] = b;\\n            ans[b] = a;\\n        }\\n        ans\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn unhappy_friends(n: i32, prefs: Vec<Vec<i32>>, pairs: Vec<Vec<i32>>) -> i32 {\\n        let n = n as usize;\\n        let (prefs, pairs) = (Self::pref_up(&prefs, n), Self::pair_up(pairs, n));\\n        let mut ans = 0;\\n        // If x prefers u over y and u prefers x over v\\n        for a in 0..n {\\n            // a lovers\\n            if (0..n).any(|v| prefs[a][v] < prefs[a][pairs[a]] && prefs[v][a] < prefs[v][pairs[v]])\\n            {\\n                ans += 1;\\n            }\\n        }\\n        ans\\n    }\\n\\n    fn pref_up(prefs: &Vec<Vec<i32>>, n: usize) -> Vec<Vec<usize>> {\\n        let mut ans = vec![vec![n; n]; n];\\n        for (num, pref) in prefs.into_iter().enumerate() {\\n            for (pos, &fav) in pref.into_iter().enumerate() {\\n                ans[num][fav as usize] = pos;\\n            }\\n        }\\n        ans\\n    }\\n\\n    fn pair_up(pairs: Vec<Vec<i32>>, n: usize) -> Vec<usize> {\\n        let mut ans = vec![n; n];\\n        for pair in pairs {\\n            let (a, b) = (pair[0] as usize, pair[1] as usize);\\n            ans[a] = b;\\n            ans[b] = a;\\n        }\\n        ans\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2145532,
                "title": "python3-adjacency-matrix-o-n-2-time-o-n-2-space",
                "content": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        \\n        adjMat = [[None] * n for _ in range(n)]\\n        prs = [None]*n\\n        unhappy = 0\\n        \\n        for f1, prefs in enumerate(preferences):\\n            for rank, f2 in enumerate(prefs):\\n                adjMat[f1][f2] = rank\\n                \\n        for f1,f2 in pairs:\\n            prs[f1], prs[f2] = f2, f1\\n            \\n        for f1 in range(n):\\n            for f3 in preferences[f1][:adjMat[f1][prs[f1]]]:\\n                if adjMat[f3][f1] < adjMat[f3][prs[f3]]:\\n                    unhappy += 1\\n                    break\\n                    \\n        return unhappy\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        \\n        adjMat = [[None] * n for _ in range(n)]\\n        prs = [None]*n\\n        unhappy = 0\\n        \\n        for f1, prefs in enumerate(preferences):\\n            for rank, f2 in enumerate(prefs):\\n                adjMat[f1][f2] = rank\\n                \\n        for f1,f2 in pairs:\\n            prs[f1], prs[f2] = f2, f1\\n            \\n        for f1 in range(n):\\n            for f3 in preferences[f1][:adjMat[f1][prs[f1]]]:\\n                if adjMat[f3][f1] < adjMat[f3][prs[f3]]:\\n                    unhappy += 1\\n                    break\\n                    \\n        return unhappy\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100360,
                "title": "java-solution-3ms",
                "content": "Time: O(n\\xB2) Space: O(n\\xB2)\\n```\\nclass Solution {\\n  public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n    int[][] rankings = new int[n][n]; // smaller the value, higher the preference\\n    int[] pairedWith = new int[n];\\n    for (int i = 0; i < n; i++) {\\n      for (int rank = 0; rank < n - 1; rank++) {\\n        int j = preferences[i][rank];\\n        rankings[i][j] = rank; // person \"i\" views person \"j\" with rank\\n      }\\n    }\\n    int unhappy = 0;\\n    for (int[] pair : pairs) {\\n      int a = pair[0], b = pair[1];\\n      pairedWith[a] = b;\\n      pairedWith[b] = a;\\n    }\\n    for (int a = 0; a < n; a++) {\\n      // \"a\" prefers someone else\\n      if (rankings[a][pairedWith[a]] != 0) {\\n        for (int b = 0; b < n; b++) {\\n          // \"b\" prefers to be with \"a\" over their current partner\\n          // \"a\" prefers to be with \"b\" over their current partner\\n          if (b != a\\n              && rankings[b][a] < rankings[b][pairedWith[b]]\\n              && rankings[a][b] < rankings[a][pairedWith[a]]) {\\n            unhappy++;\\n            break;\\n          }\\n        }\\n      }\\n    }\\n    return unhappy;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n    int[][] rankings = new int[n][n]; // smaller the value, higher the preference\\n    int[] pairedWith = new int[n];\\n    for (int i = 0; i < n; i++) {\\n      for (int rank = 0; rank < n - 1; rank++) {\\n        int j = preferences[i][rank];\\n        rankings[i][j] = rank; // person \"i\" views person \"j\" with rank\\n      }\\n    }\\n    int unhappy = 0;\\n    for (int[] pair : pairs) {\\n      int a = pair[0], b = pair[1];\\n      pairedWith[a] = b;\\n      pairedWith[b] = a;\\n    }\\n    for (int a = 0; a < n; a++) {\\n      // \"a\" prefers someone else\\n      if (rankings[a][pairedWith[a]] != 0) {\\n        for (int b = 0; b < n; b++) {\\n          // \"b\" prefers to be with \"a\" over their current partner\\n          // \"a\" prefers to be with \"b\" over their current partner\\n          if (b != a\\n              && rankings[b][a] < rankings[b][pairedWith[b]]\\n              && rankings[a][b] < rankings[a][pairedWith[a]]) {\\n            unhappy++;\\n            break;\\n          }\\n        }\\n      }\\n    }\\n    return unhappy;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866713,
                "title": "count-unhappy-friends-tc-o-n-2",
                "content": "The Solution is bit unconventional but it works.It took me a while to understand this question and solve it so here how it goes.\\n* I use list and hashMap to get the quick index of the value presenent preference that we are searching for.\\n* we need to find wheather a person in the pair is happy or not. so for that we need to get the index of the rank of his partner in his preference `int subIdx = list.get(main).indexOf(sub); ` this line bascially does that.\\n* once we get the index of his partner then we need to go from his `partner index - 1` to 0 to search an value such that the rank of person that we are searching for should be less then the that values pair\\'s rank and below code does that.\\n```\\n            int pairIdx = list.get(pat).indexOf(patPair);\\n            int mainIdx = list.get(pat).indexOf(main);\\n            \\n            if(mainIdx < pairIdx)\\n                return true;\\n```\\n\\nI know this seems confusing .. just give it some time and think about it.\\n\\n**Full Solution**\\n```\\nclass Solution {\\n    List<List<Integer>> list;\\n    HashMap<Integer,Integer> map;\\n    \\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        list = new ArrayList<>();\\n        map = new HashMap<>();\\n        int count = 0;\\n        \\n        for(int i[] : preferences){\\n            List<Integer> temp = new ArrayList<>();\\n            for(int j : i)\\n                temp.add(j);\\n            list.add(temp);\\n        }\\n        \\n        for(int i[] : pairs) {\\n            map.put(i[0],i[1]);\\n            map.put(i[1],i[0]);\\n        }\\n        \\n        for(int i[] : pairs){\\n            if(isUnhappy(i[0],i[1]))\\n                count++;\\n            if(isUnhappy(i[1],i[0]))\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n    \\n    public boolean isUnhappy(int main,int sub){\\n        int subIdx = list.get(main).indexOf(sub);\\n        if(subIdx == 0)\\n            return false;\\n        \\n        subIdx -= 1;\\n        \\n        while(subIdx >= 0) {\\n            int pat = list.get(main).get(subIdx);\\n            int patPair = map.get(pat);\\n            \\n            int pairIdx = list.get(pat).indexOf(patPair);\\n            int mainIdx = list.get(pat).indexOf(main);\\n            \\n            if(mainIdx < pairIdx)\\n                return true;\\n            subIdx--;\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\nsolution inspired from - https://leetcode.com/problems/count-unhappy-friends/discuss/1831941/Python-Solution-Easy-to-Read-logic-in-the-question",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n            int pairIdx = list.get(pat).indexOf(patPair);\\n            int mainIdx = list.get(pat).indexOf(main);\\n            \\n            if(mainIdx < pairIdx)\\n                return true;\\n```\n```\\nclass Solution {\\n    List<List<Integer>> list;\\n    HashMap<Integer,Integer> map;\\n    \\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        list = new ArrayList<>();\\n        map = new HashMap<>();\\n        int count = 0;\\n        \\n        for(int i[] : preferences){\\n            List<Integer> temp = new ArrayList<>();\\n            for(int j : i)\\n                temp.add(j);\\n            list.add(temp);\\n        }\\n        \\n        for(int i[] : pairs) {\\n            map.put(i[0],i[1]);\\n            map.put(i[1],i[0]);\\n        }\\n        \\n        for(int i[] : pairs){\\n            if(isUnhappy(i[0],i[1]))\\n                count++;\\n            if(isUnhappy(i[1],i[0]))\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n    \\n    public boolean isUnhappy(int main,int sub){\\n        int subIdx = list.get(main).indexOf(sub);\\n        if(subIdx == 0)\\n            return false;\\n        \\n        subIdx -= 1;\\n        \\n        while(subIdx >= 0) {\\n            int pat = list.get(main).get(subIdx);\\n            int patPair = map.get(pat);\\n            \\n            int pairIdx = list.get(pat).indexOf(patPair);\\n            int mainIdx = list.get(pat).indexOf(main);\\n            \\n            if(mainIdx < pairIdx)\\n                return true;\\n            subIdx--;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1665119,
                "title": "java-2-solutions-both-o-n-2-but-one-sol-is-better-than-other-in-run-time-explained",
                "content": "Solution 1: \\n// We create a map of mapping between each person \\'i\\' and his/her preferences so that look up becomes O(1)\\n// Then we go through all the all the persons preferences and find if they are paired with whom they wanted or not\\n\\n// TC : O(N^2)\\n// SC : O(N ^ 2)\\n```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n       int[] givenPairing = new int[n];\\n        for(int[] pair: pairs) { // Keep record of current matches.\\n            givenPairing[pair[0]] = pair[1];\\n            givenPairing[pair[1]] = pair[0];\\n        }\\n        int res = 0;\\n\\t\\t\\n        // key -> person i; value -> map(key -> person j, value -> importance of person j for i (lesser is more important))\\n        Map<Integer, Integer>[] prefer = new Map[n]; // O(1) to fetch the index from the preference array. \\n         \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n-1; j++){\\n                if(prefer[i] == null) prefer[i] = new HashMap<>();\\n                prefer[i].put(preferences[i][j], j); // \\'i\\' prefers \\'j\\' and preference value of \\'j\\' for \\'i\\' is \\'j\\'\\n            }\\n        }\\n\\n        // The \\'if\\' condition checks 2 things\\n        // 1. if preference of \\'i\\' for \\'j\\' is lower value (meaning higher) than the preference of given pairing for \\'j\\'\\n        // 2. if preference of \\'j\\' for \\'i\\' is lower value (meaning higher) than the preference of given pairing for \\'i\\'\\n        // If above 2 conditions are true, it means that the friends are unhappy\\n        for(int i = 0; i < n; i++) { // read for all persons \\'i\\'\\n            for(int j : preferences[i]) { // given preferences for \\'i\\'(in order)\\n                if(prefer[j].get(i) < prefer[j].get(givenPairing[j]) \\n\\t\\t\\t\\t\\t&& prefer[i].get(j) < prefer[i].get(givenPairing[i])) { // Based on the definition of \"unhappy\"...\\n                    res++;\\n                    break;\\n                }\\n            }\\n        }\\n\\t    return res; \\n    }\\n}\\n```\\nSolution 2 : This has better run time time Solution 1\\n// TC : O(N^2)\\n// SC : O(N^2)\\n```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int[][] close = new int[n][n]; // 2D mapping for person \\'i\\' preferences (lower is better)\\n        for (int i = 0; i < preferences.length; i++) {\\n            for (int j = 0; j < preferences[i].length; j++) {\\n                close[i][preferences[i][j]] = j; // \\'i\\' prefers \\'j\\' with preference value \\'j\\' (lower is better)\\n            }\\n        }\\n        \\n        int[] mates = new int[n];\\n        for (int[] pair : pairs) {\\n            mates[pair[0]] = pair[1];\\n            mates[pair[1]] = pair[0];\\n        }\\n        \\n        int ans = 0;\\n        for (int x = 0; x < n; x++) { // for all persons \\'i\\'\\n            int y = mates[x]; // find given mate for \\'x\\'\\n            \\n            for (int u : preferences[x]) { // find preferences for \\'x\\'\\n                if (y == u) break; // if the mate for \\'x\\' is same its preference, x is HAPPY so break (no need to look further)\\n                \\n                int v = mates[u]; // find given mate for x\\'s preferences\\n                if (close[u][x] < close[u][v]) { // if the person \\'u\\' prefers \\'x\\' but is paired with \\'v\\' then he is UNHAPPY\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n       int[] givenPairing = new int[n];\\n        for(int[] pair: pairs) { // Keep record of current matches.\\n            givenPairing[pair[0]] = pair[1];\\n            givenPairing[pair[1]] = pair[0];\\n        }\\n        int res = 0;\\n\\t\\t\\n        // key -> person i; value -> map(key -> person j, value -> importance of person j for i (lesser is more important))\\n        Map<Integer, Integer>[] prefer = new Map[n]; // O(1) to fetch the index from the preference array. \\n         \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n-1; j++){\\n                if(prefer[i] == null) prefer[i] = new HashMap<>();\\n                prefer[i].put(preferences[i][j], j); // \\'i\\' prefers \\'j\\' and preference value of \\'j\\' for \\'i\\' is \\'j\\'\\n            }\\n        }\\n\\n        // The \\'if\\' condition checks 2 things\\n        // 1. if preference of \\'i\\' for \\'j\\' is lower value (meaning higher) than the preference of given pairing for \\'j\\'\\n        // 2. if preference of \\'j\\' for \\'i\\' is lower value (meaning higher) than the preference of given pairing for \\'i\\'\\n        // If above 2 conditions are true, it means that the friends are unhappy\\n        for(int i = 0; i < n; i++) { // read for all persons \\'i\\'\\n            for(int j : preferences[i]) { // given preferences for \\'i\\'(in order)\\n                if(prefer[j].get(i) < prefer[j].get(givenPairing[j]) \\n\\t\\t\\t\\t\\t&& prefer[i].get(j) < prefer[i].get(givenPairing[i])) { // Based on the definition of \"unhappy\"...\\n                    res++;\\n                    break;\\n                }\\n            }\\n        }\\n\\t    return res; \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int[][] close = new int[n][n]; // 2D mapping for person \\'i\\' preferences (lower is better)\\n        for (int i = 0; i < preferences.length; i++) {\\n            for (int j = 0; j < preferences[i].length; j++) {\\n                close[i][preferences[i][j]] = j; // \\'i\\' prefers \\'j\\' with preference value \\'j\\' (lower is better)\\n            }\\n        }\\n        \\n        int[] mates = new int[n];\\n        for (int[] pair : pairs) {\\n            mates[pair[0]] = pair[1];\\n            mates[pair[1]] = pair[0];\\n        }\\n        \\n        int ans = 0;\\n        for (int x = 0; x < n; x++) { // for all persons \\'i\\'\\n            int y = mates[x]; // find given mate for \\'x\\'\\n            \\n            for (int u : preferences[x]) { // find preferences for \\'x\\'\\n                if (y == u) break; // if the mate for \\'x\\' is same its preference, x is HAPPY so break (no need to look further)\\n                \\n                int v = mates[u]; // find given mate for x\\'s preferences\\n                if (close[u][x] < close[u][v]) { // if the person \\'u\\' prefers \\'x\\' but is paired with \\'v\\' then he is UNHAPPY\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610975,
                "title": "python-concise-answer",
                "content": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        rank = [[0 for _ in range(n)] for _ in range(n)]\\n        for i in range(n):\\n            rank[i][i] = float(\\'inf\\')\\n            for dist, j in enumerate(preferences[i]):\\n                rank[i][j] = dist + 1\\n               \\n        adjList = collections.defaultdict()\\n        for x, y in pairs:\\n            adjList[x] = y\\n            adjList[y] = x\\n            \\n        unhappy = 0\\n        for x, y in adjList.items():\\n            if rank[x][y] == 1:\\n                continue\\n                \\n            chosen = y\\n\\t\\t\\t# iterate only for all preferences before y\\n\\t\\t\\tend = preferences[x].index(y)\\n            for u in preferences[x][:end]:\\n                if rank[u][x] < rank[u][adjList[u]]:\\n                    chosen = u\\n                    break\\n            if chosen != y:\\n                unhappy += 1\\n        return unhappy\\n                \\n                    \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        rank = [[0 for _ in range(n)] for _ in range(n)]\\n        for i in range(n):\\n            rank[i][i] = float(\\'inf\\')\\n            for dist, j in enumerate(preferences[i]):\\n                rank[i][j] = dist + 1\\n               \\n        adjList = collections.defaultdict()\\n        for x, y in pairs:\\n            adjList[x] = y\\n            adjList[y] = x\\n            \\n        unhappy = 0\\n        for x, y in adjList.items():\\n            if rank[x][y] == 1:\\n                continue\\n                \\n            chosen = y\\n\\t\\t\\t# iterate only for all preferences before y\\n\\t\\t\\tend = preferences[x].index(y)\\n            for u in preferences[x][:end]:\\n                if rank[u][x] < rank[u][adjList[u]]:\\n                    chosen = u\\n                    break\\n            if chosen != y:\\n                unhappy += 1\\n        return unhappy\\n                \\n                    \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1572444,
                "title": "o-n-2-python-verbose",
                "content": "https://github.com/paulonteri/data-structures-and-algorithms\\n\\n---\\n\\nRead through the actual code to understand better\\n\\n```\\n\"\"\" \\nn - even\\n[\\n0 [1, 3, 2], u\\n1 [2, 3, 0],\\n2 [1, 3, 0],\\n3 [0, 2, 1]\\n], \\n \\npairs = [[1, 3], [0, 2]]\\n\\n{ \\n1:3,\\n3:1,\\n0:2,\\n2:0\\n}\\n\\n\\n# # x unhappy\\n\\tx -> y\\n\\tu -> v\\nif there exists such a condition\\n\\tx -> u (x prefers u than what it currently has)\\n\\tu -> x (prefers x than what it has)\\n\\n\\n- count = 0\\n- store the preferences in a dict/list:\\n    { \\n    x1: { u1: pref_u1, u2: pref_u2 }\\n    x2: { u1: pref_u1, u2: pref_u2 }\\n    }\\n- store the friendships in a dict/list:\\n    {\\n    x1:u1,\\n    u1:x1\\n    }\\n- for each x in the pairings:\\n    - if not with the highest priority friend\\n        - if can_get_higher_prio(x):\\n            count += 1\\n\\n            \\ncan_get_higher_prio(x):\\n    - check if for all the higher priority friends u1, u2, u2\\n        - any of them is matched with a friend they prefer less than x \\n\\nhttps://www.notion.so/paulonteri/_Object-Oriented-Analysis-and-Design-1a01887a9271475da7b3cd3f4efc9e0d#3b876eef896b482ea279ebdfbd918590\\n\"\"\"\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]):\\n        count = 0\\n\\n        pref_lookup = [{} for _ in range(n)]\\n        friendships_lookup = [-1 for _ in range(n)]\\n\\n        # store the preferences in a dict\\n        for person, preferences_list in enumerate(preferences):\\n            for priority, other_person in enumerate(preferences_list):\\n                pref_lookup[person][other_person] = priority\\n        # store the friendships in a dict\\n        for x, y in pairs:\\n            friendships_lookup[x] = y\\n            friendships_lookup[y] = x\\n\\n        for person, paired_with in enumerate(friendships_lookup):\\n            if pref_lookup[person][paired_with] == 0:\\n                continue\\n            if self.can_get_higher_prio(pref_lookup, friendships_lookup, person, paired_with):\\n                count += 1\\n\\n        return count\\n\\n    def can_get_higher_prio(self, pref_lookup, friendships_lookup, person, paired_with):\\n        \"\"\" \\n        - check if for all the higher priority friends u1, u2, u2 of person\\n            - if any of them is matched with a friend they prefer less than x:\\n                - return True\\n        - return False\\n        \"\"\"\\n\\n        for other_friend in pref_lookup[person]:\\n            # other_friend is of a lower priority\\n            if pref_lookup[person][other_friend] > pref_lookup[person][paired_with]:\\n                continue\\n            # person is not under other_friend\\'s priorities\\n            if person not in pref_lookup[other_friend]:\\n                continue\\n\\n            # check other_friend\\'s preference with person vs preference with who they were paired with\\n            pref_w_person = pref_lookup[other_friend][person]\\n            pref_w_paired_with = pref_lookup[other_friend][friendships_lookup[other_friend]]\\n\\n            if pref_w_paired_with > pref_w_person:\\n                return True\\n\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\"\"\" \\nn - even\\n[\\n0 [1, 3, 2], u\\n1 [2, 3, 0],\\n2 [1, 3, 0],\\n3 [0, 2, 1]\\n], \\n \\npairs = [[1, 3], [0, 2]]\\n\\n{ \\n1:3,\\n3:1,\\n0:2,\\n2:0\\n}\\n\\n\\n# # x unhappy\\n\\tx -> y\\n\\tu -> v\\nif there exists such a condition\\n\\tx -> u (x prefers u than what it currently has)\\n\\tu -> x (prefers x than what it has)\\n\\n\\n- count = 0\\n- store the preferences in a dict/list:\\n    { \\n    x1: { u1: pref_u1, u2: pref_u2 }\\n    x2: { u1: pref_u1, u2: pref_u2 }\\n    }\\n- store the friendships in a dict/list:\\n    {\\n    x1:u1,\\n    u1:x1\\n    }\\n- for each x in the pairings:\\n    - if not with the highest priority friend\\n        - if can_get_higher_prio(x):\\n            count += 1\\n\\n            \\ncan_get_higher_prio(x):\\n    - check if for all the higher priority friends u1, u2, u2\\n        - any of them is matched with a friend they prefer less than x \\n\\nhttps://www.notion.so/paulonteri/_Object-Oriented-Analysis-and-Design-1a01887a9271475da7b3cd3f4efc9e0d#3b876eef896b482ea279ebdfbd918590\\n\"\"\"\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]):\\n        count = 0\\n\\n        pref_lookup = [{} for _ in range(n)]\\n        friendships_lookup = [-1 for _ in range(n)]\\n\\n        # store the preferences in a dict\\n        for person, preferences_list in enumerate(preferences):\\n            for priority, other_person in enumerate(preferences_list):\\n                pref_lookup[person][other_person] = priority\\n        # store the friendships in a dict\\n        for x, y in pairs:\\n            friendships_lookup[x] = y\\n            friendships_lookup[y] = x\\n\\n        for person, paired_with in enumerate(friendships_lookup):\\n            if pref_lookup[person][paired_with] == 0:\\n                continue\\n            if self.can_get_higher_prio(pref_lookup, friendships_lookup, person, paired_with):\\n                count += 1\\n\\n        return count\\n\\n    def can_get_higher_prio(self, pref_lookup, friendships_lookup, person, paired_with):\\n        \"\"\" \\n        - check if for all the higher priority friends u1, u2, u2 of person\\n            - if any of them is matched with a friend they prefer less than x:\\n                - return True\\n        - return False\\n        \"\"\"\\n\\n        for other_friend in pref_lookup[person]:\\n            # other_friend is of a lower priority\\n            if pref_lookup[person][other_friend] > pref_lookup[person][paired_with]:\\n                continue\\n            # person is not under other_friend\\'s priorities\\n            if person not in pref_lookup[other_friend]:\\n                continue\\n\\n            # check other_friend\\'s preference with person vs preference with who they were paired with\\n            pref_w_person = pref_lookup[other_friend][person]\\n            pref_w_paired_with = pref_lookup[other_friend][friendships_lookup[other_friend]]\\n\\n            if pref_w_paired_with > pref_w_person:\\n                return True\\n\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1507697,
                "title": "nice-question-c-is-this-question-used-for-testing-english-reading",
                "content": "I think this questions is like:\\n\"x and u are real love. They prefered each other than thier current wife or husband, but they have to marry another man/woman, who is y and v.\"\\n\\n```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        unordered_map<int, unordered_map<int, int>> maps;\\n        for(int i = 0;i<preferences.size();i++)\\n        {\\n            for(int j = 0;j<preferences[i].size();j++)\\n            {\\n\\t\\t\\t// preferences[i].size() - j means preference\\n                maps[i][preferences[i][j]] = preferences[i].size() - j;\\n            }\\n        }\\n        int res = 0;\\n        unordered_map<int, int> dist;\\n        for(int i = 0;i<pairs.size();i++)\\n        {\\n            dist[pairs[i][0]] = pairs[i][1]; \\n            dist[pairs[i][1]] = pairs[i][0]; \\n        }\\n        for(int i = 0;i<n;i++){\\n            int x = i, y = dist[i];\\n            for(int j = 0;j<n;j++)\\n            {\\n                if(j == x || j == y) continue;\\n                int u = j, v = dist[u];\\n\\t\\t\\t\\t// Don\\'t try to understand the question, just do what it asked......\\n                if(maps[x][u] > maps[x][y]&&maps[u][x] > maps[u][v]) \\n                {\\n                    res++;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        unordered_map<int, unordered_map<int, int>> maps;\\n        for(int i = 0;i<preferences.size();i++)\\n        {\\n            for(int j = 0;j<preferences[i].size();j++)\\n            {\\n\\t\\t\\t// preferences[i].size() - j means preference\\n                maps[i][preferences[i][j]] = preferences[i].size() - j;\\n            }\\n        }\\n        int res = 0;\\n        unordered_map<int, int> dist;\\n        for(int i = 0;i<pairs.size();i++)\\n        {\\n            dist[pairs[i][0]] = pairs[i][1]; \\n            dist[pairs[i][1]] = pairs[i][0]; \\n        }\\n        for(int i = 0;i<n;i++){\\n            int x = i, y = dist[i];\\n            for(int j = 0;j<n;j++)\\n            {\\n                if(j == x || j == y) continue;\\n                int u = j, v = dist[u];\\n\\t\\t\\t\\t// Don\\'t try to understand the question, just do what it asked......\\n                if(maps[x][u] > maps[x][y]&&maps[u][x] > maps[u][v]) \\n                {\\n                    res++;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1353615,
                "title": "c-beats-100-explained-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        unordered_map<int, unordered_set<int>> morePreferred;\\n        \\n        //Adding all friends a person prefers more than their pair\\n        for(int i=0; i<pairs.size(); i++)\\n        {\\n            int first = pairs[i][0], second = pairs[i][1];\\n            \\n            //adding all friends that occur before alloted pair in preference list\\n            for(int j=0; j<preferences[first].size(); j++)\\n            {\\n                if(preferences[first][j] == second)\\n                    break;\\n                morePreferred[first].insert(preferences[first][j]);\\n            }\\n            \\n            for(int j=0; j<preferences[second].size(); j++)\\n            {\\n                if(preferences[second][j] == first)\\n                    break;\\n                morePreferred[second].insert(preferences[second][j]);\\n            }\\n        }\\n        \\n        int unhappy = 0;\\n        \\n        for(auto it = morePreferred.begin(); it != morePreferred.end(); it++)\\n        {\\n            unordered_set<int> morePref = it->second;\\n            \\n            //traversing all more preffered friends for a person\\n            for(auto it1 = morePref.begin(); it1 != morePref.end(); it1++)\\n            {\\n                //cout<<*it1<<endl;\\n                if(morePreferred.find(*it1) == morePreferred.end())\\n                    continue;\\n                //if their more preferred person also prefers them more than their partner\\n                if(morePreferred[*it1].find(it->first) != morePreferred[*it1].end())\\n                {\\n                    unhappy++;\\n                    break; // count unhappy person only once\\n                }\\n            }\\n        }\\n        \\n        return unhappy;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        unordered_map<int, unordered_set<int>> morePreferred;\\n        \\n        //Adding all friends a person prefers more than their pair\\n        for(int i=0; i<pairs.size(); i++)\\n        {\\n            int first = pairs[i][0], second = pairs[i][1];\\n            \\n            //adding all friends that occur before alloted pair in preference list\\n            for(int j=0; j<preferences[first].size(); j++)\\n            {\\n                if(preferences[first][j] == second)\\n                    break;\\n                morePreferred[first].insert(preferences[first][j]);\\n            }\\n            \\n            for(int j=0; j<preferences[second].size(); j++)\\n            {\\n                if(preferences[second][j] == first)\\n                    break;\\n                morePreferred[second].insert(preferences[second][j]);\\n            }\\n        }\\n        \\n        int unhappy = 0;\\n        \\n        for(auto it = morePreferred.begin(); it != morePreferred.end(); it++)\\n        {\\n            unordered_set<int> morePref = it->second;\\n            \\n            //traversing all more preffered friends for a person\\n            for(auto it1 = morePref.begin(); it1 != morePref.end(); it1++)\\n            {\\n                //cout<<*it1<<endl;\\n                if(morePreferred.find(*it1) == morePreferred.end())\\n                    continue;\\n                //if their more preferred person also prefers them more than their partner\\n                if(morePreferred[*it1].find(it->first) != morePreferred[*it1].end())\\n                {\\n                    unhappy++;\\n                    break; // count unhappy person only once\\n                }\\n            }\\n        }\\n        \\n        return unhappy;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1325617,
                "title": "13-line-simple-clean-python",
                "content": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        likemore = {}\\n        for a,b in pairs:\\n            likemore[a] = set(preferences[a][:preferences[a].index(b)])\\n            likemore[b] = set(preferences[b][:preferences[b].index(a)])\\n        unhappy = set()\\n        for i in range(n):\\n            for j in range(i):\\n                if(i in likemore[j] and j in likemore[i]):\\n                    unhappy.add(i)\\n                    unhappy.add(j)\\n        return len(unhappy)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        likemore = {}\\n        for a,b in pairs:\\n            likemore[a] = set(preferences[a][:preferences[a].index(b)])\\n            likemore[b] = set(preferences[b][:preferences[b].index(a)])\\n        unhappy = set()\\n        for i in range(n):\\n            for j in range(i):\\n                if(i in likemore[j] and j in likemore[i]):\\n                    unhappy.add(i)\\n                    unhappy.add(j)\\n        return len(unhappy)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1229402,
                "title": "c-o-n-2-solution-using-map-and-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        \\n        //Logic: make an unordered_map of people who I prefer over my partner(make sure not to include the current partner)\\n        //Unhappy when : I\\'m in someone\\'s preference set and also that someone is in my preference set, so we both are unhappy\\n        \\n        if(preferences.empty() || pairs.empty())return 0;\\n        \\n        unordered_map <int, unordered_set<int>> preferenceMap;\\n        \\n        for(auto p : pairs)\\n        {\\n            int x = p[0];\\n            int y = p[1];\\n            unordered_set<int> subVec;\\n            \\n            for(int i =0; i < preferences[x].size(); i++)\\n            {\\n                if(preferences[x][i] == y)break;\\n                subVec.insert(preferences[x][i]);\\n            }\\n            \\n            preferenceMap[x] = subVec;\\n            \\n            unordered_set<int> subVec1;\\n            \\n             for(int i =0; i < preferences[y].size(); i++)\\n            {\\n                if(preferences[y][i] == x)break;\\n                subVec1.insert(preferences[y][i]);\\n            }\\n            \\n            preferenceMap[y] = subVec1;\\n            \\n        }\\n        \\n        int res = 0;\\n        for(auto x : preferenceMap)\\n        {\\n            for(auto y : x.second)\\n            {\\n                if(preferenceMap[y].find(x.first) != preferenceMap[y].end())\\n                {\\n                    res++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        \\n        //Logic: make an unordered_map of people who I prefer over my partner(make sure not to include the current partner)\\n        //Unhappy when : I\\'m in someone\\'s preference set and also that someone is in my preference set, so we both are unhappy\\n        \\n        if(preferences.empty() || pairs.empty())return 0;\\n        \\n        unordered_map <int, unordered_set<int>> preferenceMap;\\n        \\n        for(auto p : pairs)\\n        {\\n            int x = p[0];\\n            int y = p[1];\\n            unordered_set<int> subVec;\\n            \\n            for(int i =0; i < preferences[x].size(); i++)\\n            {\\n                if(preferences[x][i] == y)break;\\n                subVec.insert(preferences[x][i]);\\n            }\\n            \\n            preferenceMap[x] = subVec;\\n            \\n            unordered_set<int> subVec1;\\n            \\n             for(int i =0; i < preferences[y].size(); i++)\\n            {\\n                if(preferences[y][i] == x)break;\\n                subVec1.insert(preferences[y][i]);\\n            }\\n            \\n            preferenceMap[y] = subVec1;\\n            \\n        }\\n        \\n        int res = 0;\\n        for(auto x : preferenceMap)\\n        {\\n            for(auto y : x.second)\\n            {\\n                if(preferenceMap[y].find(x.first) != preferenceMap[y].end())\\n                {\\n                    res++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1077300,
                "title": "c-create-preference-matrix-and-pair-array-first",
                "content": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        int res = 0;\\n        // mat[i][j]: for friend i, the preference level of friend j, i.e. the index of j in preferences[i]\\n        // use mat to check preference (index) between i&j and use preferences to check friends\\n        vector<vector<int>> mat(n, vector<int>(n));\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n - 1; ++j) {\\n                int p = preferences[i][j];\\n                mat[i][p] = j;\\n            }\\n        }\\n        // pairsVec[i]: the paired friend of friend i\\n        vector<int> pairsVec(n);\\n        for (int i = 0; i < pairs.size(); ++i) {\\n            int x = pairs[i][0], y = pairs[i][1];\\n            pairsVec[x] = y;\\n            pairsVec[y] = x;\\n        }\\n        // iterate all the friends of x with preference higher than y, to check if any of them also has higher preference for x\\n        for (int i = 0; i < pairs.size(); ++i) {\\n            for (int j = 0; j < 2; ++j) {\\n                int x = pairs[i][j], y = pairs[i][1 - j];\\n                int xPref = mat[x][y];\\n                for (int k = 0; k < xPref; ++k) {\\n                    int u = preferences[x][k], v = pairsVec[u];\\n                    if (mat[u][x] < mat[u][v]) {\\n                        res++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n// T: O(N^2)\\n// S: O(N^2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        int res = 0;\\n        // mat[i][j]: for friend i, the preference level of friend j, i.e. the index of j in preferences[i]\\n        // use mat to check preference (index) between i&j and use preferences to check friends\\n        vector<vector<int>> mat(n, vector<int>(n));\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n - 1; ++j) {\\n                int p = preferences[i][j];\\n                mat[i][p] = j;\\n            }\\n        }\\n        // pairsVec[i]: the paired friend of friend i\\n        vector<int> pairsVec(n);\\n        for (int i = 0; i < pairs.size(); ++i) {\\n            int x = pairs[i][0], y = pairs[i][1];\\n            pairsVec[x] = y;\\n            pairsVec[y] = x;\\n        }\\n        // iterate all the friends of x with preference higher than y, to check if any of them also has higher preference for x\\n        for (int i = 0; i < pairs.size(); ++i) {\\n            for (int j = 0; j < 2; ++j) {\\n                int x = pairs[i][j], y = pairs[i][1 - j];\\n                int xPref = mat[x][y];\\n                for (int k = 0; k < xPref; ++k) {\\n                    int u = preferences[x][k], v = pairsVec[u];\\n                    if (mat[u][x] < mat[u][v]) {\\n                        res++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n// T: O(N^2)\\n// S: O(N^2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1076202,
                "title": "c-easy-self-explanatory-solution-beats-99",
                "content": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) \\n    {\\n        if(!n)\\n            return 0;\\n     \\n        int prefMap[n][n];\\n        int pairMap[n];\\n        \\n        //what is the preference value of j\\'th person wrt i\\'th person\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<n-1; j++)\\n            {\\n                prefMap[i][preferences[i][j]] = j;\\n            }\\n        }\\n        \\n        //who is paired with whom\\n        for(int i=0; i<n/2; i++)\\n        {\\n            pairMap[pairs[i][0]] = pairs[i][1];\\n            pairMap[pairs[i][1]] = pairs[i][0];\\n        }\\n        \\n        bool unhappy[n];\\n        memset(unhappy, false, sizeof(unhappy));\\n        \\n        //Check each person if he is unhappy\\n        for(int i=0; i<n; i++)\\n        {\\n            if(unhappy[i]) continue;\\n            \\n            int currPerson = i;\\n            int pairedPerson = pairMap[currPerson];\\n            int pairedPersonPref = prefMap[currPerson][pairedPerson];\\n            \\n            for(int j=0; j<n; j++)\\n            {\\n                if(currPerson!=j && pairedPerson!=j)\\n                {\\n                    int possiblePerson = j;\\n                    int possiblePref = prefMap[currPerson][j];\\n                    \\n                    if(possiblePref < pairedPersonPref)\\n                    {\\n                        int possiblePairedPerson = pairMap[possiblePerson];\\n                        int possiblePairedPersonPref = prefMap[possiblePerson][possiblePairedPerson];\\n                        \\n                        if(possiblePairedPersonPref>prefMap[possiblePerson][currPerson])\\n                        {\\n                            unhappy[currPerson] = unhappy[possiblePerson] = true;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int count = 0;\\n        \\n        for(bool unhappyPerson : unhappy)\\n            count+=(unhappyPerson ? 1 : 0);\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) \\n    {\\n        if(!n)\\n            return 0;\\n     \\n        int prefMap[n][n];\\n        int pairMap[n];\\n        \\n        //what is the preference value of j\\'th person wrt i\\'th person\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<n-1; j++)\\n            {\\n                prefMap[i][preferences[i][j]] = j;\\n            }\\n        }\\n        \\n        //who is paired with whom\\n        for(int i=0; i<n/2; i++)\\n        {\\n            pairMap[pairs[i][0]] = pairs[i][1];\\n            pairMap[pairs[i][1]] = pairs[i][0];\\n        }\\n        \\n        bool unhappy[n];\\n        memset(unhappy, false, sizeof(unhappy));\\n        \\n        //Check each person if he is unhappy\\n        for(int i=0; i<n; i++)\\n        {\\n            if(unhappy[i]) continue;\\n            \\n            int currPerson = i;\\n            int pairedPerson = pairMap[currPerson];\\n            int pairedPersonPref = prefMap[currPerson][pairedPerson];\\n            \\n            for(int j=0; j<n; j++)\\n            {\\n                if(currPerson!=j && pairedPerson!=j)\\n                {\\n                    int possiblePerson = j;\\n                    int possiblePref = prefMap[currPerson][j];\\n                    \\n                    if(possiblePref < pairedPersonPref)\\n                    {\\n                        int possiblePairedPerson = pairMap[possiblePerson];\\n                        int possiblePairedPersonPref = prefMap[possiblePerson][possiblePairedPerson];\\n                        \\n                        if(possiblePairedPersonPref>prefMap[possiblePerson][currPerson])\\n                        {\\n                            unhappy[currPerson] = unhappy[possiblePerson] = true;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int count = 0;\\n        \\n        for(bool unhappyPerson : unhappy)\\n            count+=(unhappyPerson ? 1 : 0);\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 967317,
                "title": "python-easy-to-understand-w-explanation",
                "content": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        \"\"\"\\n        72% faster O(n^2), 44% less mem O(n) - 12/10/20\\n        \"\"\"\\n        # keep track of people & their paired partner\\n        seen_pairs = {}\\n        for pair in pairs:\\n            seen_pairs[pair[0]] = pair[1]\\n            seen_pairs[pair[1]] = pair[0]\\n        \\n        # keep track of people that would rather prefer someone else over their current partner\\n        more_preferred = {}\\n        for i in range(len(preferences)):\\n            for preference in preferences[i]:\\n                if preference == seen_pairs[i]:\\n                    break\\n                if i not in more_preferred:\\n                    more_preferred[i] = []\\n                more_preferred[i].append(preference)\\n        \\n        # if both person in more_preferred feel same way abt each other, increment unhappy\\n        unhappy = 0 \\n        for person, preferences in more_preferred.items():\\n            for friend in preferences:\\n                if friend in more_preferred and person in more_preferred[friend]:\\n                    unhappy += 1\\n                    # don\\'t remove anything, just keep for next check\\n                    break\\n                    \\n        return unhappy\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        \"\"\"\\n        72% faster O(n^2), 44% less mem O(n) - 12/10/20\\n        \"\"\"\\n        # keep track of people & their paired partner\\n        seen_pairs = {}\\n        for pair in pairs:\\n            seen_pairs[pair[0]] = pair[1]\\n            seen_pairs[pair[1]] = pair[0]\\n        \\n        # keep track of people that would rather prefer someone else over their current partner\\n        more_preferred = {}\\n        for i in range(len(preferences)):\\n            for preference in preferences[i]:\\n                if preference == seen_pairs[i]:\\n                    break\\n                if i not in more_preferred:\\n                    more_preferred[i] = []\\n                more_preferred[i].append(preference)\\n        \\n        # if both person in more_preferred feel same way abt each other, increment unhappy\\n        unhappy = 0 \\n        for person, preferences in more_preferred.items():\\n            for friend in preferences:\\n                if friend in more_preferred and person in more_preferred[friend]:\\n                    unhappy += 1\\n                    # don\\'t remove anything, just keep for next check\\n                    break\\n                    \\n        return unhappy\\n```",
                "codeTag": "Java"
            },
            {
                "id": 939392,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int count = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int[] pair : pairs){\\n            map.put(pair[0], pair[1]);\\n            map.put(pair[1], pair[0]);\\n        }\\n        for(Map.Entry<Integer,Integer> entry : map.entrySet()){\\n            int x = entry.getKey();\\n            int y = entry.getValue();\\n            if(unhappy(preferences, x, y, map)){\\n                count++;\\n            }\\n            \\n            \\n        }\\n        return count;\\n    }\\n    \\n    private boolean unhappy(int[][] preference, int x, int y, Map<Integer, Integer> map){\\n        //base case\\n       if(preference[x][0] == y){\\n           return false;\\n       }\\n        List<Integer> list = new ArrayList<>();\\n        for(int i = 0; i < preference[x].length; i++){\\n            if(preference[x][i] == y){\\n                break;\\n            }\\n            list.add(preference[x][i]);\\n        }\\n        //get list of prefer\\n        for(int u : list){\\n            int v = map.get(u);\\n            int index1 = -1;\\n            int index2 = -1;\\n            for(int i = 0; i < preference[u].length; i++){\\n                if(preference[u][i] == v){\\n                    index1 = i;\\n                }\\n                if(preference[u][i] == x){\\n                    index2 = i;\\n                }\\n                if(index1 !=- 1 && index2 != -1){\\n                    break;\\n                }\\n            }\\n            \\n            if(index1 >=0 && index2 >= 0 && index1 > index2){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int count = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int[] pair : pairs){\\n            map.put(pair[0], pair[1]);\\n            map.put(pair[1], pair[0]);\\n        }\\n        for(Map.Entry<Integer,Integer> entry : map.entrySet()){\\n            int x = entry.getKey();\\n            int y = entry.getValue();\\n            if(unhappy(preferences, x, y, map)){\\n                count++;\\n            }\\n            \\n            \\n        }\\n        return count;\\n    }\\n    \\n    private boolean unhappy(int[][] preference, int x, int y, Map<Integer, Integer> map){\\n        //base case\\n       if(preference[x][0] == y){\\n           return false;\\n       }\\n        List<Integer> list = new ArrayList<>();\\n        for(int i = 0; i < preference[x].length; i++){\\n            if(preference[x][i] == y){\\n                break;\\n            }\\n            list.add(preference[x][i]);\\n        }\\n        //get list of prefer\\n        for(int u : list){\\n            int v = map.get(u);\\n            int index1 = -1;\\n            int index2 = -1;\\n            for(int i = 0; i < preference[u].length; i++){\\n                if(preference[u][i] == v){\\n                    index1 = i;\\n                }\\n                if(preference[u][i] == x){\\n                    index2 = i;\\n                }\\n                if(index1 !=- 1 && index2 != -1){\\n                    break;\\n                }\\n            }\\n            \\n            if(index1 >=0 && index2 >= 0 && index1 > index2){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937234,
                "title": "3-line-python",
                "content": "I guess the point is seeing the time complexity is at least N square, so settle for brutal force.\\n\\n```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        paired = {u:v for x, y in pairs for u, v in [[x,y],[y,x]]}\\n        betterPair = {i:set(preferences[i][:preferences[i].index(paired[i])]) for i in range(n)}\\n        return sum(int(any(x in betterPair[y] for y in betterPair[x])) for x in range(n))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        paired = {u:v for x, y in pairs for u, v in [[x,y],[y,x]]}\\n        betterPair = {i:set(preferences[i][:preferences[i].index(paired[i])]) for i in range(n)}\\n        return sum(int(any(x in betterPair[y] for y in betterPair[x])) for x in range(n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 918243,
                "title": "c-simple-o-n-2-solution",
                "content": "```\\n\\tint unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        \\n        int like[n][n];\\n        int partner[n];\\n        \\n        for(int x=0;x<n;x++){\\n            for(int i=0;i+1<n;i++){\\n                like[x][preferences[x][i]]=i;\\n            }\\n        }\\n        \\n        for(auto& i:pairs){\\n            partner[i[0]]=i[1];\\n            partner[i[1]]=i[0];\\n        }\\n        \\n        int ans=0;\\n        for(int x=0;x<n;x++){\\n            \\n            bool happy=true;\\n            for(int i=0;happy&&i+1<n&&preferences[x][i]!=partner[x];i++){\\n                int u=preferences[x][i];                \\n                if(like[u][x] < like[u][partner[u]]){\\n                    \\n                    ans++;\\n                    happy=false;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tint unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        \\n        int like[n][n];\\n        int partner[n];\\n        \\n        for(int x=0;x<n;x++){\\n            for(int i=0;i+1<n;i++){\\n                like[x][preferences[x][i]]=i;\\n            }\\n        }\\n        \\n        for(auto& i:pairs){\\n            partner[i[0]]=i[1];\\n            partner[i[1]]=i[0];\\n        }\\n        \\n        int ans=0;\\n        for(int x=0;x<n;x++){\\n            \\n            bool happy=true;\\n            for(int i=0;happy&&i+1<n&&preferences[x][i]!=partner[x];i++){\\n                int u=preferences[x][i];                \\n                if(like[u][x] < like[u][partner[u]]){\\n                    \\n                    ans++;\\n                    happy=false;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 896429,
                "title": "python-clear-explanation-for-fast-and-pythonic-solution",
                "content": "The approach is as follows:\\n1. Go through the pairs and find the `wanted_friends` based on the given preferences. This is done in linear fashion\\n2. Go through each person if `wanted_friends` and check if the curr person is wanted as well.\\n\\nNote: I consider this pythonic because i use `takewhile` which is a very useful function (along with `dropwhile`) that you can find in itertools. \\n\\n```python\\nimport collections, itertools\\nclass Solution:\\n    # 364 ms, 99.79%. Time: O(N^2). Space: O(N^2)\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        \\n        wanted_friends = collections.defaultdict(set)\\n        for p1, p2 in pairs:\\n\\t\\t\\t# in Layman\\'s terms, take every number until we find p in the preferences (linear fashion)\\n            wanted_friends[p1] = set(itertools.takewhile(lambda p: p!=p2 , preferences[p1]))\\n            wanted_friends[p2] = set(itertools.takewhile(lambda p: p!=p1 , preferences[p2]))\\n        \\n\\t\\t# For the given example, we will have wanted_friends as follows:\\n\\t\\t# {0: set(), 1: {2, 3}, 2: set(), 3: {1}}\\n\\t\\t# This means, 0 and 2 are happy, 1 wants 2 or 3, and 3 wants 1. \\n\\t\\t\\n        unhappy_friends = 0\\n        for curr, people in wanted_friends.items():\\n            if any(curr in wanted_friends[person] for person in people):\\n                unhappy_friends += 1\\n        return unhappy_friends\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nimport collections, itertools\\nclass Solution:\\n    # 364 ms, 99.79%. Time: O(N^2). Space: O(N^2)\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        \\n        wanted_friends = collections.defaultdict(set)\\n        for p1, p2 in pairs:\\n\\t\\t\\t# in Layman\\'s terms, take every number until we find p in the preferences (linear fashion)\\n            wanted_friends[p1] = set(itertools.takewhile(lambda p: p!=p2 , preferences[p1]))\\n            wanted_friends[p2] = set(itertools.takewhile(lambda p: p!=p1 , preferences[p2]))\\n        \\n\\t\\t# For the given example, we will have wanted_friends as follows:\\n\\t\\t# {0: set(), 1: {2, 3}, 2: set(), 3: {1}}\\n\\t\\t# This means, 0 and 2 are happy, 1 wants 2 or 3, and 3 wants 1. \\n\\t\\t\\n        unhappy_friends = 0\\n        for curr, people in wanted_friends.items():\\n            if any(curr in wanted_friends[person] for person in people):\\n                unhappy_friends += 1\\n        return unhappy_friends\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887810,
                "title": "java-standard-solution-with-rank-matrix-and-hashmap-for-pairs",
                "content": "Runtime: **3 ms**, faster than **85.34%** of Java online submissions for Count Unhappy Friends.\\nMemory Usage: **59.2 MB**, less than **5.40%** of Java online submissions for Count Unhappy Friends.\\n```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        //Prepare matrix ranks: n - max, n-2 - min\\n        int[][] rank=new int[n][n];\\n        for(int i=0;i<n;i++){\\n            int[] pref=preferences[i];\\n            for(int j=0;j<n-1;j++){\\n                rank[i][pref[j]]=n-j;\\n            }//~~\\n        }//~\\n        \\n        //Prepare pMap - map of pairs\\n        HashMap<Integer,Integer> pMap=new HashMap<Integer,Integer>();\\n        \\n        for(int[] p:pairs){\\n            pMap.put(p[0],p[1]);\\n            pMap.put(p[1],p[0]);\\n        }//~\\n        \\n        //Search and count unhappy\\n        int count=0;\\n        \\n        for(int[] p:pairs){\\n            boolean wasP0=false,wasP1=false;\\n            for(int j=0;j<n;j++){\\n                //By p[0]\\n                if(rank[p[0]][j]>rank[p[0]][p[1]]&&!wasP0){\\n                   int k=pMap.get(j); \\n                   wasP0=rank[j][k]<rank[j][p[0]]; \\n                   count=wasP0?count+1:count; \\n                }\\n                //By p[1]\\n                if(rank[p[1]][j]>rank[p[1]][p[0]]&&!wasP1){\\n                   int k=pMap.get(j); \\n                   wasP1=rank[j][k]<rank[j][p[1]]; \\n                   count=wasP1?count+1:count; \\n                }\\n                if(wasP0&&wasP1)\\n                   break; \\n            }//~~          \\n        }//~\\n                \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        //Prepare matrix ranks: n - max, n-2 - min\\n        int[][] rank=new int[n][n];\\n        for(int i=0;i<n;i++){\\n            int[] pref=preferences[i];\\n            for(int j=0;j<n-1;j++){\\n                rank[i][pref[j]]=n-j;\\n            }//~~\\n        }//~\\n        \\n        //Prepare pMap - map of pairs\\n        HashMap<Integer,Integer> pMap=new HashMap<Integer,Integer>();\\n        \\n        for(int[] p:pairs){\\n            pMap.put(p[0],p[1]);\\n            pMap.put(p[1],p[0]);\\n        }//~\\n        \\n        //Search and count unhappy\\n        int count=0;\\n        \\n        for(int[] p:pairs){\\n            boolean wasP0=false,wasP1=false;\\n            for(int j=0;j<n;j++){\\n                //By p[0]\\n                if(rank[p[0]][j]>rank[p[0]][p[1]]&&!wasP0){\\n                   int k=pMap.get(j); \\n                   wasP0=rank[j][k]<rank[j][p[0]]; \\n                   count=wasP0?count+1:count; \\n                }\\n                //By p[1]\\n                if(rank[p[1]][j]>rank[p[1]][p[0]]&&!wasP1){\\n                   int k=pMap.get(j); \\n                   wasP1=rank[j][k]<rank[j][p[1]]; \\n                   count=wasP1?count+1:count; \\n                }\\n                if(wasP0&&wasP1)\\n                   break; \\n            }//~~          \\n        }//~\\n                \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874309,
                "title": "c-concise",
                "content": "```\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        vector<vector<int>> vv;\\n        vector<bool> vUnhappy(n);\\n        for(auto& v:preferences){\\n            vector<int> dis(n,0);\\n            for(int i=0;i<v.size();i++) dis[v[i]] = i+1;\\n            vv.emplace_back(move(dis));\\n        }\\n        \\n        auto countUnhappy = [&](int x, int y, int u, int v){\\n            if(vv[x][y] > vv[x][u] && vv[u][v] > vv[u][x]) vUnhappy[x] = vUnhappy[u] = true;};\\n        \\n        \\n        for(int i=0;i<pairs.size();i++) for(int j=0;j<i;j++){\\n            int x=pairs[i][0], y=pairs[i][1], u=pairs[j][0], v=pairs[j][1];\\n            countUnhappy(x,y,u,v);\\n            countUnhappy(y,x,u,v);\\n            countUnhappy(x,y,v,u);\\n            countUnhappy(y,x,v,u);            \\n        }\\n        return count(vUnhappy.begin(), vUnhappy.end(), true);\\n    }",
                "solutionTags": [],
                "code": "```\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        vector<vector<int>> vv;\\n        vector<bool> vUnhappy(n);\\n        for(auto& v:preferences){\\n            vector<int> dis(n,0);\\n            for(int i=0;i<v.size();i++) dis[v[i]] = i+1;\\n            vv.emplace_back(move(dis));\\n        }\\n        \\n        auto countUnhappy = [&](int x, int y, int u, int v){\\n            if(vv[x][y] > vv[x][u] && vv[u][v] > vv[u][x]) vUnhappy[x] = vUnhappy[u] = true;};\\n        \\n        \\n        for(int i=0;i<pairs.size();i++) for(int j=0;j<i;j++){\\n            int x=pairs[i][0], y=pairs[i][1], u=pairs[j][0], v=pairs[j][1];\\n            countUnhappy(x,y,u,v);\\n            countUnhappy(y,x,u,v);\\n            countUnhappy(x,y,v,u);\\n            countUnhappy(y,x,v,u);            \\n        }\\n        return count(vUnhappy.begin(), vUnhappy.end(), true);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 845690,
                "title": "java-brute-force-3ms",
                "content": "```\\nclass Solution {\\n    int length;\\n    public boolean isUnhappy(int num,Map<Integer, Integer>m,int[][] preferences){\\n        int fri = m.get(num); int index = -1; int pref = -1;int a = -1, b = -1;\\n        for(int i = length-2; i >= 0; i--){\\n            if(preferences[num][i] == fri && i == 0){return false;}\\n            else if(preferences[num][i] == fri){\\n                index = i; break;\\n            }\\n        }\\n        for(int i = index-1; i >= 0; i--){\\n            a = -1; b = -1;\\n            pref = preferences[num][i];\\n            int tmp = m.get(pref);\\n            for(int j = length-2; j >=0; j--){\\n                if(preferences[pref][j] == tmp){\\n                    a = j;\\n                }\\n                else if(preferences[pref][j] == num){\\n                    b = j;\\n                }\\n                if(b < a){return true;}\\n            }\\n        }\\n        return false;\\n    }\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        length = n;\\n        Map<Integer, Integer> m = new HashMap<>();\\n        int res = 0;\\n        for(int[] a : pairs){\\n            m.put(a[0],a[1]);\\n            m.put(a[1],a[0]);\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(isUnhappy(i,m,preferences)) res++;\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int length;\\n    public boolean isUnhappy(int num,Map<Integer, Integer>m,int[][] preferences){\\n        int fri = m.get(num); int index = -1; int pref = -1;int a = -1, b = -1;\\n        for(int i = length-2; i >= 0; i--){\\n            if(preferences[num][i] == fri && i == 0){return false;}",
                "codeTag": "Java"
            },
            {
                "id": 845503,
                "title": "easy-to-understand-quadratic-solution-with-comments",
                "content": "Use a two-dimensional array `rank` to look up how people rank each other in terms of their preferences.\\n\\n```\\nclass Solution {  \\npublic:\\n  // quadratic in n\\n  int unhappyFriends(int n, vector<vector<int>>& preferences, \\n                     vector<vector<int>>& pairs) {\\n    int ans = 0, rank[n][n], pair[n];\\n\\t\\n\\t// initialize rank array\\n    for (int x = 0; x < n; x++) {\\n      for (int i = 0; i < preferences[x].size(); i++) \\n        rank[x][preferences[x][i]] = n - i;  \\n\\t\\t// because preferences[x][i] ranks higher than \\n\\t\\t// preferences[x][i+1] as per the problem statement\\n    }\\n\\t\\n\\t// initialize pair array\\n    for (auto& v : pairs) {\\n      pair[v[0]] = v[1];\\n      pair[v[1]] = v[0];\\n    }\\n\\t\\n\\t// check if there exists a person u which person x prefers to his pair y, \\n\\t// and which prefers x to his pair\\n    for (int x = 0; x < n; x++) {\\n      int y = pair[x];\\n      for (auto it = begin(preferences[x]); *it != y; it++) {\\n        int u = *it;\\n        if (rank[u][x] > rank[u][pair[u]]) {\\n          ans++;\\n          break;\\n        }\\n      }\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {  \\npublic:\\n  // quadratic in n\\n  int unhappyFriends(int n, vector<vector<int>>& preferences, \\n                     vector<vector<int>>& pairs) {\\n    int ans = 0, rank[n][n], pair[n];\\n\\t\\n\\t// initialize rank array\\n    for (int x = 0; x < n; x++) {\\n      for (int i = 0; i < preferences[x].size(); i++) \\n        rank[x][preferences[x][i]] = n - i;  \\n\\t\\t// because preferences[x][i] ranks higher than \\n\\t\\t// preferences[x][i+1] as per the problem statement\\n    }\\n\\t\\n\\t// initialize pair array\\n    for (auto& v : pairs) {\\n      pair[v[0]] = v[1];\\n      pair[v[1]] = v[0];\\n    }\\n\\t\\n\\t// check if there exists a person u which person x prefers to his pair y, \\n\\t// and which prefers x to his pair\\n    for (int x = 0; x < n; x++) {\\n      int y = pair[x];\\n      for (auto it = begin(preferences[x]); *it != y; it++) {\\n        int u = *it;\\n        if (rank[u][x] > rank[u][pair[u]]) {\\n          ans++;\\n          break;\\n        }\\n      }\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 845420,
                "title": "create-matrix-for-mutual-likes",
                "content": "```\\npublic int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        // First need to create a matrix or list of map to demonstrate \\n        // how they like each other in terms of friend priority\\n        int[][] mat = new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n - 1; j++) {\\n                mat[i][preferences[i][j]] = j;\\n            }\\n        }\\n        //System.out.println(Arrays.deepToString(mat));\\n        \\n        \\n        // the current pair mapping\\n        int[] curmap = new int[n];\\n        for (int[] pair : pairs) {\\n            curmap[pair[0]] = pair[1];\\n            curmap[pair[1]] = pair[0];\\n        }\\n        \\n        int res = 0;\\n        Set<Integer> set = new HashSet<>(); // Can be redundant.\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i == j) continue;\\n                // how i likes j VS how i likes current match\\n                // how j likes i VS how j likes current match\\n                if (mat[i][j] < mat[i][curmap[i]] &&\\n                    mat[j][i] < mat[j][curmap[j]] ) {\\n                    set.add(i);\\n                    set.add(j);\\n                }\\n            }\\n        }\\n        \\n        return set.size();\\n    }\\n\\t\\n// \\u6211\\u53F8\\u7684\\u9898\\u76EE\\u4ECE\\u6765\\u4E0D\\u8003graph\\u91CC\\u7684fancy\\u7B97\\u6CD5\\uFF0C\\u4F46\\u7279\\u522B\\u559C\\u6B22\\u8003\\u7C7B\\u4F3C\\u8FD9\\u9898\\u8FD9\\u79CD\\u590D\\u6742\\u7684\\u76F8\\u4E92\\u7ED5\\u6765\\u7ED5\\u53BB\\u7684array, list, map\\u57FA\\u7840\\u6570\\u636E\\u7ED3\\u6784\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        // First need to create a matrix or list of map to demonstrate \\n        // how they like each other in terms of friend priority\\n        int[][] mat = new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n - 1; j++) {\\n                mat[i][preferences[i][j]] = j;\\n            }\\n        }\\n        //System.out.println(Arrays.deepToString(mat));\\n        \\n        \\n        // the current pair mapping\\n        int[] curmap = new int[n];\\n        for (int[] pair : pairs) {\\n            curmap[pair[0]] = pair[1];\\n            curmap[pair[1]] = pair[0];\\n        }\\n        \\n        int res = 0;\\n        Set<Integer> set = new HashSet<>(); // Can be redundant.\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i == j) continue;\\n                // how i likes j VS how i likes current match\\n                // how j likes i VS how j likes current match\\n                if (mat[i][j] < mat[i][curmap[i]] &&\\n                    mat[j][i] < mat[j][curmap[j]] ) {\\n                    set.add(i);\\n                    set.add(j);\\n                }\\n            }\\n        }\\n        \\n        return set.size();\\n    }\\n\\t\\n// \\u6211\\u53F8\\u7684\\u9898\\u76EE\\u4ECE\\u6765\\u4E0D\\u8003graph\\u91CC\\u7684fancy\\u7B97\\u6CD5\\uFF0C\\u4F46\\u7279\\u522B\\u559C\\u6B22\\u8003\\u7C7B\\u4F3C\\u8FD9\\u9898\\u8FD9\\u79CD\\u590D\\u6742\\u7684\\u76F8\\u4E92\\u7ED5\\u6765\\u7ED5\\u53BB\\u7684array, list, map\\u57FA\\u7840\\u6570\\u636E\\u7ED3\\u6784\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 844827,
                "title": "python-solution-with-comments",
                "content": "\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        ans = 0\\n        d ={}\\n\\t\\t#pair map for easy reference to the member in the same pair\\n        for pair in pairs:\\n            d[pair[0]]=d.get(pair[0],pair[1])\\n            d[pair[1]]=d.get(pair[1],pair[0])\\n            \\n        for p in range(n): \\n\\t\\t#iterate each person(p)\\n            t = d[p]\\n            t_idx = preferences[p].index(t)\\n            for other in preferences[p][:t_idx]:\\n\\t\\t\\t#iterate every other(other) on person(p)\\'s preference list in front of team/pair member(t)\\n                if preferences[other].index(p)<preferences[other].index(d[other]):\\n\\t\\t\\t\\t#compare the preference ranking of p and other\\'s current pairing(d[other]) on other\\'s preference list\\n                    ans +=1\\n                    break\\n        return ans\\n                \\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        ans = 0\\n        d ={}\\n\\t\\t#pair map for easy reference to the member in the same pair\\n        for pair in pairs:\\n            d[pair[0]]=d.get(pair[0],pair[1])\\n            d[pair[1]]=d.get(pair[1],pair[0])\\n            \\n        for p in range(n): \\n\\t\\t#iterate each person(p)\\n            t = d[p]\\n            t_idx = preferences[p].index(t)\\n            for other in preferences[p][:t_idx]:\\n\\t\\t\\t#iterate every other(other) on person(p)\\'s preference list in front of team/pair member(t)\\n                if preferences[other].index(p)<preferences[other].index(d[other]):\\n\\t\\t\\t\\t#compare the preference ranking of p and other\\'s current pairing(d[other]) on other\\'s preference list\\n                    ans +=1\\n                    break\\n        return ans\\n                \\n\\n",
                "codeTag": "Python3"
            },
            {
                "id": 844692,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        cand = defaultdict(int)\\n        for i in range(len(pairs)):\\n            pair = pairs[i]\\n            x = 1\\n            for p in pair:\\n                prefOfP = preferences[p]\\n                if(pair[x]!=prefOfP[0]):\\n                    cand[p] = pair[x]\\n                x = 0\\n        res = 0\\n        unhappyFraands = set()\\n        for pers in cand.keys():\\n            if(pers not in unhappyFraands):\\n                prefOfPers =  preferences[pers]\\n                currFrnd = cand[pers]\\n                i = 0\\n                found = False\\n                while(prefOfPers[i]!=currFrnd and found==False):\\n                    possFrnd = prefOfPers[i]\\n                    if(possFrnd in cand):\\n                        possFrndPref = preferences[possFrnd]\\n                        currFrndOfPossFrnd = cand[possFrnd]\\n                        j = 0\\n                        while(possFrndPref[j]!=currFrndOfPossFrnd):\\n                            if(possFrndPref[j] == pers):\\n                                if(possFrnd not in unhappyFraands):\\n                                    res+=2\\n                                else:\\n                                    res+=1\\n                                unhappyFraands.add(possFrnd)\\n                                unhappyFraands.add(pers)\\n                                found = True\\n                                break\\n                            j+=1\\n                    i+=1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        cand = defaultdict(int)\\n        for i in range(len(pairs)):\\n            pair = pairs[i]\\n            x = 1\\n            for p in pair:\\n                prefOfP = preferences[p]\\n                if(pair[x]!=prefOfP[0]):\\n                    cand[p] = pair[x]\\n                x = 0\\n        res = 0\\n        unhappyFraands = set()\\n        for pers in cand.keys():\\n            if(pers not in unhappyFraands):\\n                prefOfPers =  preferences[pers]\\n                currFrnd = cand[pers]\\n                i = 0\\n                found = False\\n                while(prefOfPers[i]!=currFrnd and found==False):\\n                    possFrnd = prefOfPers[i]\\n                    if(possFrnd in cand):\\n                        possFrndPref = preferences[possFrnd]\\n                        currFrndOfPossFrnd = cand[possFrnd]\\n                        j = 0\\n                        while(possFrndPref[j]!=currFrndOfPossFrnd):\\n                            if(possFrndPref[j] == pers):\\n                                if(possFrnd not in unhappyFraands):\\n                                    res+=2\\n                                else:\\n                                    res+=1\\n                                unhappyFraands.add(possFrnd)\\n                                unhappyFraands.add(pers)\\n                                found = True\\n                                break\\n                            j+=1\\n                    i+=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844668,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, pref: List[List[int]], pairs: List[List[int]]) -> int:\\n        res = set()\\n        \\n\\t\\t# helper function to check for happiness\\n        def checkHappiness(x,y,u,v):\\n             if rank[x][u] < rank[x][y] and rank[u][x] < rank[u][v]:\\n                res.add(x)\\n                res.add(u)\\n\\t\\t\\t\\t\\n\\t\\t# store the pref with index accordingly in map\\n        rank = [{v:i for i,v in enumerate(row)} for row in pref] \\n        \\n        for i in range(n//2):\\n            x, y = pairs[i]\\n            for j in range(i+1, n//2):\\n                    u,v = pairs[j]\\n\\t\\t\\t\\t\\t# loop through permutations of pairs\\n                    checkHappiness(x, y, u, v)\\n                    checkHappiness(y, x, u, v)\\n                    checkHappiness(x, y, v, u)\\n                    checkHappiness(y, x, v, u)\\n                    \\n        return len(res)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, pref: List[List[int]], pairs: List[List[int]]) -> int:\\n        res = set()\\n        \\n\\t\\t# helper function to check for happiness\\n        def checkHappiness(x,y,u,v):\\n             if rank[x][u] < rank[x][y] and rank[u][x] < rank[u][v]:\\n                res.add(x)\\n                res.add(u)\\n\\t\\t\\t\\t\\n\\t\\t# store the pref with index accordingly in map\\n        rank = [{v:i for i,v in enumerate(row)} for row in pref] \\n        \\n        for i in range(n//2):\\n            x, y = pairs[i]\\n            for j in range(i+1, n//2):\\n                    u,v = pairs[j]\\n\\t\\t\\t\\t\\t# loop through permutations of pairs\\n                    checkHappiness(x, y, u, v)\\n                    checkHappiness(y, x, u, v)\\n                    checkHappiness(x, y, v, u)\\n                    checkHappiness(y, x, v, u)\\n                    \\n        return len(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844579,
                "title": "1ms-100-faster-java-solution-brute-force-using-hashmap-well-commented-easy-to-understand",
                "content": "Runtime: 1 ms, faster than 100.00% of Java online submissions for Count Unhappy Friends.\\nMemory Usage: 60.2 MB, less than 80.00% of Java online submissions for Count Unhappy Friends.\\n\\nLet me know in the comment if you are having any doubts.\\n\\n```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int count=0;\\n        HashMap<Integer,Integer> pmap=new HashMap<>();\\n        \\n        // make hashmap for pair\\n        for(int i=0;i<pairs.length;i++){\\n            pmap.put(pairs[i][0],pairs[i][1]);\\n            pmap.put(pairs[i][1],pairs[i][0]);\\n        }\\n        \\n        // loop on all the elements and check if its Unhappy\\n        for(int i=0;i<n;i++){\\n                if(isUnhappy(i,pmap,preferences))\\n                    count++;\\n        }\\n        \\n        return count;\\n    }\\n    \\n    private boolean isUnhappy(int n,HashMap<Integer,Integer> pmap,int[][] preferences){\\n        //pair\\n        int p=pmap.get(n);\\n        //arr\\n        int[] arr=preferences[n];\\n        //index of pair element in the array\\n        int pp=index(arr,p);\\n        \\n        if(pp==0) return false;\\n        \\n        // loop on all the favourable elements\\n        for(int i=0;i<pp;i++){\\n            \\n            //favourable to given no \\n            int fav=arr[i];\\n            \\n            // pair of favourable element\\n            int fp=pmap.get(fav);\\n            \\n            // arr of favourable element\\n            int[] fa = preferences[fav];\\n            \\n            //index of pair of favourable element in the favourable array\\n            int fpp = index(fa,fp);\\n            \\n            //index of curr element in the favourable array\\n            int fcp = index(fa,n);\\n            \\n            // if curr index< index of pair of favourable : curr is unhappy\\n            if(fcp<fpp){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private int index(int[] pref,int val){\\n        for(int i=0;i<pref.length;i++){\\n            if(pref[i]==val){\\n                return i;\\n            }\\n        }\\n        return Integer.MAX_VALUE;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int count=0;\\n        HashMap<Integer,Integer> pmap=new HashMap<>();\\n        \\n        // make hashmap for pair\\n        for(int i=0;i<pairs.length;i++){\\n            pmap.put(pairs[i][0],pairs[i][1]);\\n            pmap.put(pairs[i][1],pairs[i][0]);\\n        }\\n        \\n        // loop on all the elements and check if its Unhappy\\n        for(int i=0;i<n;i++){\\n                if(isUnhappy(i,pmap,preferences))\\n                    count++;\\n        }\\n        \\n        return count;\\n    }\\n    \\n    private boolean isUnhappy(int n,HashMap<Integer,Integer> pmap,int[][] preferences){\\n        //pair\\n        int p=pmap.get(n);\\n        //arr\\n        int[] arr=preferences[n];\\n        //index of pair element in the array\\n        int pp=index(arr,p);\\n        \\n        if(pp==0) return false;\\n        \\n        // loop on all the favourable elements\\n        for(int i=0;i<pp;i++){\\n            \\n            //favourable to given no \\n            int fav=arr[i];\\n            \\n            // pair of favourable element\\n            int fp=pmap.get(fav);\\n            \\n            // arr of favourable element\\n            int[] fa = preferences[fav];\\n            \\n            //index of pair of favourable element in the favourable array\\n            int fpp = index(fa,fp);\\n            \\n            //index of curr element in the favourable array\\n            int fcp = index(fa,n);\\n            \\n            // if curr index< index of pair of favourable : curr is unhappy\\n            if(fcp<fpp){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private int index(int[] pref,int val){\\n        for(int i=0;i<pref.length;i++){\\n            if(pref[i]==val){\\n                return i;\\n            }\\n        }\\n        return Integer.MAX_VALUE;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844275,
                "title": "c-100-faster-o-n-2-time",
                "content": "Current pair [x, y]\\n\\nlet say preferences for **x** is [...**u**...**y**...]  so check for all possible **u** before **y** which are preferable than **y**.\\n\\nNow for each **u** check for pair [u, v] where preferences for **u** is [...**x**...**v**...]  so check does x comes before (more preferable than) v in O(1) time.\\n\\n\\nDo the same for y by just replacing y with x.\\n\\n```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        \\n        vector<vector<int>> prefer(n, vector<int>(n, 0));\\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<preferences[i].size(); ++j){\\n                prefer[i][preferences[i][j]] = j;\\n            }\\n        }\\n        \\n        vector<int> map(n, 0);\\n        for(auto &p : pairs){\\n            map[p[0]] = p[1];\\n            map[p[1]] = p[0];\\n        }\\n        \\n        int unhappy = 0;\\n        \\n        for(auto &p : pairs){\\n            int x = p[0], y = p[1];\\n            \\n            // check for x\\n            for(int i=0; i<preferences[x].size(); ++i){\\n                int u = preferences[x][i];\\n                int v = map[u];\\n                \\n                if(u == y) break;\\n                if(prefer[u][x] < prefer[u][v]) {\\n                    ++unhappy;\\n                    break;\\n                }\\n            }\\n            \\n            // Same check for y (just replace x with y in previous for loop)\\n            for(int i=0; i<preferences[y].size(); ++i){\\n                int u = preferences[y][i];\\n                int v = map[u];\\n                \\n                if(u == x) break;\\n                if(prefer[u][y] < prefer[u][v]) {\\n                    ++unhappy;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return unhappy;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        \\n        vector<vector<int>> prefer(n, vector<int>(n, 0));\\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<preferences[i].size(); ++j){\\n                prefer[i][preferences[i][j]] = j;\\n            }\\n        }\\n        \\n        vector<int> map(n, 0);\\n        for(auto &p : pairs){\\n            map[p[0]] = p[1];\\n            map[p[1]] = p[0];\\n        }\\n        \\n        int unhappy = 0;\\n        \\n        for(auto &p : pairs){\\n            int x = p[0], y = p[1];\\n            \\n            // check for x\\n            for(int i=0; i<preferences[x].size(); ++i){\\n                int u = preferences[x][i];\\n                int v = map[u];\\n                \\n                if(u == y) break;\\n                if(prefer[u][x] < prefer[u][v]) {\\n                    ++unhappy;\\n                    break;\\n                }\\n            }\\n            \\n            // Same check for y (just replace x with y in previous for loop)\\n            for(int i=0; i<preferences[y].size(); ++i){\\n                int u = preferences[y][i];\\n                int v = map[u];\\n                \\n                if(u == x) break;\\n                if(prefer[u][y] < prefer[u][v]) {\\n                    ++unhappy;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return unhappy;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844176,
                "title": "working-java-solution-shows-faster-than-100",
                "content": "```\\nclass Solution {\\n    \\n    // check whether the current element has more priority in the \"in\" subarray. If any other case return true\\n    boolean check(int[][] preferences,HashMap<Integer,Integer> hm,int cur,int in){\\n        int inPair = hm.get(in); \\n        for(int i=0;i<preferences[in].length;i++){\\n            int a = preferences[in][i];\\n            if(a == cur){\\n                return false;\\n            }else if(a == inPair){\\n                return true;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int count = 0;\\n       \\n        //Keep all the mappings in a hashMap\\n        HashMap<Integer,Integer> hm = new HashMap<>(); \\n        for(int i=0;i<pairs.length;i++){\\n          hm.put(pairs[i][0],pairs[i][1]);\\n          hm.put(pairs[i][1],pairs[i][0]);\\n        }\\n        \\n        //iterate through all hashmap entries. equivalent to checking each of entries in pairs\\n        for(int i : hm.keySet()){\\n            int givenPair = hm.get(i);\\n            int wantedPair = preferences[i][0];\\n            //If it is not paired with top priority choice, check whether it has got best priority pair possible, if not then increment count\\n            if(wantedPair != givenPair){\\n                for(int j=0; preferences[i][j]!=givenPair;j++){\\n                   boolean b = check(preferences,hm,i,preferences[i][j]); \\n                                    \\n                   if(!b){\\n                     count++;\\n                     break;  \\n                   } \\n                }\\n            }\\n            \\n            \\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    // check whether the current element has more priority in the \"in\" subarray. If any other case return true\\n    boolean check(int[][] preferences,HashMap<Integer,Integer> hm,int cur,int in){\\n        int inPair = hm.get(in); \\n        for(int i=0;i<preferences[in].length;i++){\\n            int a = preferences[in][i];\\n            if(a == cur){\\n                return false;\\n            }else if(a == inPair){\\n                return true;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int count = 0;\\n       \\n        //Keep all the mappings in a hashMap\\n        HashMap<Integer,Integer> hm = new HashMap<>(); \\n        for(int i=0;i<pairs.length;i++){\\n          hm.put(pairs[i][0],pairs[i][1]);\\n          hm.put(pairs[i][1],pairs[i][0]);\\n        }\\n        \\n        //iterate through all hashmap entries. equivalent to checking each of entries in pairs\\n        for(int i : hm.keySet()){\\n            int givenPair = hm.get(i);\\n            int wantedPair = preferences[i][0];\\n            //If it is not paired with top priority choice, check whether it has got best priority pair possible, if not then increment count\\n            if(wantedPair != givenPair){\\n                for(int j=0; preferences[i][j]!=givenPair;j++){\\n                   boolean b = check(preferences,hm,i,preferences[i][j]); \\n                                    \\n                   if(!b){\\n                     count++;\\n                     break;  \\n                   } \\n                }\\n            }\\n            \\n            \\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844147,
                "title": "easy-understand-java-o-n-2-with-thought-process",
                "content": "The Key is  how to check \"x prefers u over y\" for each x from 0 to n-1;\\n\\nI need know y, so I need a hashmap; (x ,y)\\nI need know for x, If u is before y in preferences[x], so I need a matrix which rank[x][u] means index of u in preferences[x]\\nthen, x prefers u over y --->  rank[x][u]< rank[x][y]\\n\\nnow, I am happy.\\n\\n```\\npublic int unhappyFriends(int n, int[][] prefs, int[][] pairs) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int[][] rank = new int[n][n]; \\n        for(int[] p : pairs){\\n            int p1 =p[0];\\n            int p2 =p[1];\\n            for(int i =0; i<n-1; ++i){\\n                int fri1 = prefs[p1][i];\\n                int fri2 = prefs[p2][i];\\n                rank[p1][fri1]=i;\\n                rank[p2][fri2]=i;\\n            }\\n            map.put(p1, p2);\\n            map.put(p2, p1);\\n        }\\n        int ans =0;\\n        for(int i=0; i<n;++i){\\n            if(!isHappy(prefs, map, i, rank)) ++ans;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private boolean isHappy(int[][] prefs, HashMap<Integer, Integer> map, int x, int[][] rank){\\n\\n        int y = map.get(x);\\n        for(int u : prefs[x]){\\n            if(u ==y) break; // if meet pair friend, end check\\n            else{\\n\\t\\t\\t\\t// definition of unhappy\\n                int v = map.get(u);\\n                if(rank[x][u]<rank[x][y] && rank[u][x]<rank[u][v])\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int unhappyFriends(int n, int[][] prefs, int[][] pairs) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int[][] rank = new int[n][n]; \\n        for(int[] p : pairs){\\n            int p1 =p[0];\\n            int p2 =p[1];\\n            for(int i =0; i<n-1; ++i){\\n                int fri1 = prefs[p1][i];\\n                int fri2 = prefs[p2][i];\\n                rank[p1][fri1]=i;\\n                rank[p2][fri2]=i;\\n            }\\n            map.put(p1, p2);\\n            map.put(p2, p1);\\n        }\\n        int ans =0;\\n        for(int i=0; i<n;++i){\\n            if(!isHappy(prefs, map, i, rank)) ++ans;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private boolean isHappy(int[][] prefs, HashMap<Integer, Integer> map, int x, int[][] rank){\\n\\n        int y = map.get(x);\\n        for(int u : prefs[x]){\\n            if(u ==y) break; // if meet pair friend, end check\\n            else{\\n\\t\\t\\t\\t// definition of unhappy\\n                int v = map.get(u);\\n                if(rank[x][u]<rank[x][y] && rank[u][x]<rank[u][v])\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4036487,
                "title": "c-distance-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        unordered_map<int, int> pair_map;\\n        int res = 0;\\n        for(auto p: pairs) {\\n            pair_map[p[0]] = p[1];\\n            pair_map[p[1]] = p[0];\\n        }\\n        unordered_map<string, int> distmap;\\n        for(int i = 0 ; i < preferences.size(); i++) {\\n            for(int j = 0 ; j < preferences[i].size(); j++) {\\n                distmap[to_string(i)+\"_\"+to_string(preferences[i][j])] = j;\\n            }\\n        }\\n        for(int x = 0 ; x < n; x++) {\\n            int y = pair_map[x];\\n            for(int u = 0; u < n; u++) {\\n                if(x == u )\\n                    continue;\\n                int v = pair_map[u];\\n                string dist1  = to_string(x)+\"_\"+to_string(y);\\n                string dist2  = to_string(x)+\"_\"+to_string(u);\\n                string dist3  = to_string(u)+\"_\"+to_string(v);\\n                string dist4  = to_string(u)+\"_\"+to_string(x);\\n                if(distmap[dist1] > distmap[dist2] and distmap[dist3] > distmap[dist4]) {\\n                    res++;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        unordered_map<int, int> pair_map;\\n        int res = 0;\\n        for(auto p: pairs) {\\n            pair_map[p[0]] = p[1];\\n            pair_map[p[1]] = p[0];\\n        }\\n        unordered_map<string, int> distmap;\\n        for(int i = 0 ; i < preferences.size(); i++) {\\n            for(int j = 0 ; j < preferences[i].size(); j++) {\\n                distmap[to_string(i)+\"_\"+to_string(preferences[i][j])] = j;\\n            }\\n        }\\n        for(int x = 0 ; x < n; x++) {\\n            int y = pair_map[x];\\n            for(int u = 0; u < n; u++) {\\n                if(x == u )\\n                    continue;\\n                int v = pair_map[u];\\n                string dist1  = to_string(x)+\"_\"+to_string(y);\\n                string dist2  = to_string(x)+\"_\"+to_string(u);\\n                string dist3  = to_string(u)+\"_\"+to_string(v);\\n                string dist4  = to_string(u)+\"_\"+to_string(x);\\n                if(distmap[dist1] > distmap[dist2] and distmap[dist3] > distmap[dist4]) {\\n                    res++;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007424,
                "title": "easy-to-understand-c-solution",
                "content": "# Intuition\\nfor two pair (a,b) and (c,d) there can be four posibilities a prefers c (vise-versa) or a prefers d (vise-versa) or b prefers c (vise-versa) or b prefers d.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncheck for each possible combinations of pair.\\n\\n# Complexity\\n- Time complexity:\\ncomplexity will be O(n(n-1))=O(n^2)\\n\\n- Space complexity:\\n  O(n(n-1))=O(n^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n     vector<vector<int>>pref(n,vector<int>(n,0));\\n     for(int i=0;i<n;i++){\\n         for(int j=0;j<n-1;j++){\\n             int k=preferences[i][j];\\n             pref[i][k]=j;\\n         }\\n     }\\n     \\n     vector<int> dp(n,0);\\n     for(int i=0;i<pairs.size();i++){\\n         int a=pairs[i][0],b=pairs[i][1];\\n        for(int j=i+1;j<pairs.size();j++){\\n            int c=pairs[j][0],d=pairs[j][1];\\n            // a prefers c over b and c prefers a over d add a,c\\n            if(pref[a][c]< pref[a][b] && pref[c][a]<pref[c][d]){\\n                dp[a]=1;\\n                dp[c]=1;\\n            }\\n            // a prefers d over c and d prefers a over c add a,d\\n             if(pref[a][d]< pref[a][b] && pref[d][a]<pref[d][c]){\\n               dp[a]=1;\\n               dp[d]=1;\\n            }\\n            // b prefers c over a and c prefers b over d add b,c\\n             if(pref[b][c]< pref[b][a] && pref[c][b]<pref[c][d]){\\n                dp[b]=1;\\n                dp[c]=1;\\n            }\\n            // b prefers d over a and d prefers b over c add b,d\\n             if(pref[b][d]< pref[b][a] && pref[d][b]<pref[d][c]){\\n                dp[b]=1;\\n                dp[d]=1;\\n            }\\n\\n        }\\n     } \\n<!-- count no of unhappy friends -->\\n     int count=0;\\n     for(int i : dp)count+=i;\\n     return count;  \\n     \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n     vector<vector<int>>pref(n,vector<int>(n,0));\\n     for(int i=0;i<n;i++){\\n         for(int j=0;j<n-1;j++){\\n             int k=preferences[i][j];\\n             pref[i][k]=j;\\n         }\\n     }\\n     \\n     vector<int> dp(n,0);\\n     for(int i=0;i<pairs.size();i++){\\n         int a=pairs[i][0],b=pairs[i][1];\\n        for(int j=i+1;j<pairs.size();j++){\\n            int c=pairs[j][0],d=pairs[j][1];\\n            // a prefers c over b and c prefers a over d add a,c\\n            if(pref[a][c]< pref[a][b] && pref[c][a]<pref[c][d]){\\n                dp[a]=1;\\n                dp[c]=1;\\n            }\\n            // a prefers d over c and d prefers a over c add a,d\\n             if(pref[a][d]< pref[a][b] && pref[d][a]<pref[d][c]){\\n               dp[a]=1;\\n               dp[d]=1;\\n            }\\n            // b prefers c over a and c prefers b over d add b,c\\n             if(pref[b][c]< pref[b][a] && pref[c][b]<pref[c][d]){\\n                dp[b]=1;\\n                dp[c]=1;\\n            }\\n            // b prefers d over a and d prefers b over c add b,d\\n             if(pref[b][d]< pref[b][a] && pref[d][b]<pref[d][c]){\\n                dp[b]=1;\\n                dp[d]=1;\\n            }\\n\\n        }\\n     } \\n<!-- count no of unhappy friends -->\\n     int count=0;\\n     for(int i : dp)count+=i;\\n     return count;  \\n     \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973072,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        /**\\n        Create a prefMap that contains pref matrix, which is the friendship relationship\\n        Create an array which the index and value has mapping relationship for pairs\\n        From the relationship we can find that, the \"u\" is the key to connect relationship with x, y, and v\\n        Therefore, we iterate from 0 to N(i), assume each value from prefMap is \"u\", and if we are able to find a real \"u\", means i is unhappy, if not, means i is happy.\\n         */\\n        if (preferences == null || pairs == null) {\\n            return 0;\\n        }\\n\\n        Map<Integer, Map<Integer, Integer>> prefMap = new HashMap<>();\\n        for (int i = 0 ; i < n; i++) {\\n            prefMap.putIfAbsent(i, new HashMap<>());\\n            for (int j = 0; j < n - 1; j++) {\\n                prefMap.get(i).put(preferences[i][j], j);\\n            }\\n        }\\n\\n        int[] pairArr = new int[n];\\n        for (int[] pair : pairs) {\\n            pairArr[pair[0]] = pair[1];\\n            pairArr[pair[1]] = pair[0];\\n        }\\n\\n        int count = 0;\\n        for (int x = 0; x < n; x++) {\\n            int y = pairArr[x];\\n\\n            for (int u : preferences[x]) {\\n                int yIndex = prefMap.get(x).get(y);\\n                int uIndex = prefMap.get(x).get(u);\\n                int xIndex = prefMap.get(u).get(x);\\n                int vIndex = prefMap.get(u).get(pairArr[u]);\\n                if (uIndex < yIndex && xIndex < vIndex) {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        /**\\n        Create a prefMap that contains pref matrix, which is the friendship relationship\\n        Create an array which the index and value has mapping relationship for pairs\\n        From the relationship we can find that, the \"u\" is the key to connect relationship with x, y, and v\\n        Therefore, we iterate from 0 to N(i), assume each value from prefMap is \"u\", and if we are able to find a real \"u\", means i is unhappy, if not, means i is happy.\\n         */\\n        if (preferences == null || pairs == null) {\\n            return 0;\\n        }\\n\\n        Map<Integer, Map<Integer, Integer>> prefMap = new HashMap<>();\\n        for (int i = 0 ; i < n; i++) {\\n            prefMap.putIfAbsent(i, new HashMap<>());\\n            for (int j = 0; j < n - 1; j++) {\\n                prefMap.get(i).put(preferences[i][j], j);\\n            }\\n        }\\n\\n        int[] pairArr = new int[n];\\n        for (int[] pair : pairs) {\\n            pairArr[pair[0]] = pair[1];\\n            pairArr[pair[1]] = pair[0];\\n        }\\n\\n        int count = 0;\\n        for (int x = 0; x < n; x++) {\\n            int y = pairArr[x];\\n\\n            for (int u : preferences[x]) {\\n                int yIndex = prefMap.get(x).get(y);\\n                int uIndex = prefMap.get(x).get(u);\\n                int xIndex = prefMap.get(u).get(x);\\n                int vIndex = prefMap.get(u).get(pairArr[u]);\\n                if (uIndex < yIndex && xIndex < vIndex) {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966166,
                "title": "easy-to-understand-javascript-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nvar unhappyFriends = function(n, preferences, pairs) {\\n    const preferencesMap = pairs.reduce((map, [x, y]) => {\\n        map.set(x, preferences[x].indexOf(y));\\n        map.set(y, preferences[y].indexOf(x));\\n        return map;\\n    }, new Map());\\n    let result = 0;\\n\\n    for (let friend = 0; friend < n; friend++) {\\n        const preference = preferencesMap.get(friend);\\n\\n        for (let index = 0; index < preference; index++) {\\n            const partner = preferences[friend][index];\\n\\n            if (preferences[partner].indexOf(friend) < preferencesMap.get(partner)) {\\n                result += 1;\\n                break;\\n            }\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar unhappyFriends = function(n, preferences, pairs) {\\n    const preferencesMap = pairs.reduce((map, [x, y]) => {\\n        map.set(x, preferences[x].indexOf(y));\\n        map.set(y, preferences[y].indexOf(x));\\n        return map;\\n    }, new Map());\\n    let result = 0;\\n\\n    for (let friend = 0; friend < n; friend++) {\\n        const preference = preferencesMap.get(friend);\\n\\n        for (let index = 0; index < preference; index++) {\\n            const partner = preferences[friend][index];\\n\\n            if (preferences[partner].indexOf(friend) < preferencesMap.get(partner)) {\\n                result += 1;\\n                break;\\n            }\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3850217,
                "title": "a-linear-time-space-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere are two observations:\\n1) Mapping friends to preference levels allows us to quickly answer for each person A and friends B and C - does A prefer B to C?\\n2) Given a person A and its mate B, we know which of A\\' friends could potentially cause it to be unhappy - the ones appearing before B in the preference order (i.e., the ones that A preferes to B). From this point, it\\'s a straightforward check for those friends, their mates, and their mates preference level, compared to A\\'s.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$, since the first and second loops iterate over the arguments and construct alternative representation for fast access, employing constant-time mapping. The third loop essentially scans the preference data again and uses constant time mappings to check whether a violation of the happiness criterion occurrs.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$, since the maps essentially duplicate the data in the inputs arguments, representing it in a way that allows fast access.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        // For each person, maintain a preference level (number between 0 and n-1) for each of its friends.\\n        // A lower number means it is preferred more.\\n        unordered_map<int, vector<int>> person_to_friend_preferences;\\n        for (int person = 0; person < preferences.size(); ++person) {\\n            const vector<int>& friends = preferences[person];\\n            vector<int>& friend_to_pref = person_to_friend_preferences[person];\\n            if (friend_to_pref.size() == 0) {\\n                friend_to_pref.resize(n);\\n            }\\n            for (int preference = 0; preference < friends.size(); ++preference) {\\n                friend_to_pref[friends[preference]] = preference;\\n            }            \\n        }\\n        // Remember who is paired with whom.\\n        vector<int> paired_with(preferences.size());\\n        for (vector<int>& pair : pairs) {\\n            paired_with[pair[0]] = pair[1];\\n            paired_with[pair[1]] = pair[0];\\n        }\\n\\n        int unhappy = 0;\\n        // Check whether a person is unhappy.\\n        for (int person = 0; person < preferences.size(); ++person) {\\n            const int mate = paired_with[person];\\n            const int mate_pref = person_to_friend_preferences[person][mate];\\n            // Scan the person\\'s friends who it prefers better that the one she is paired with (mate),\\n            // since those are the only ones who may cause it to be unhappy (depending on their mating).\\n            const vector<int>& friends = preferences[person];\\n            for (int friend_pref = 0; friend_pref < mate_pref; ++friend_pref) {\\n                const int person_friend = friends[friend_pref];\\n                const int friends_mate = paired_with[person_friend];\\n                // If that friend\\'s mate it prefers less than \\'person\\', we found a violating pair.\\n                if (person_to_friend_preferences[person_friend][person] < person_to_friend_preferences[person_friend][friends_mate]) {\\n                    ++unhappy;\\n                    break; // One evidence of unhappiness is enough.\\n                }\\n            }\\n        }\\n        return unhappy;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        // For each person, maintain a preference level (number between 0 and n-1) for each of its friends.\\n        // A lower number means it is preferred more.\\n        unordered_map<int, vector<int>> person_to_friend_preferences;\\n        for (int person = 0; person < preferences.size(); ++person) {\\n            const vector<int>& friends = preferences[person];\\n            vector<int>& friend_to_pref = person_to_friend_preferences[person];\\n            if (friend_to_pref.size() == 0) {\\n                friend_to_pref.resize(n);\\n            }\\n            for (int preference = 0; preference < friends.size(); ++preference) {\\n                friend_to_pref[friends[preference]] = preference;\\n            }            \\n        }\\n        // Remember who is paired with whom.\\n        vector<int> paired_with(preferences.size());\\n        for (vector<int>& pair : pairs) {\\n            paired_with[pair[0]] = pair[1];\\n            paired_with[pair[1]] = pair[0];\\n        }\\n\\n        int unhappy = 0;\\n        // Check whether a person is unhappy.\\n        for (int person = 0; person < preferences.size(); ++person) {\\n            const int mate = paired_with[person];\\n            const int mate_pref = person_to_friend_preferences[person][mate];\\n            // Scan the person\\'s friends who it prefers better that the one she is paired with (mate),\\n            // since those are the only ones who may cause it to be unhappy (depending on their mating).\\n            const vector<int>& friends = preferences[person];\\n            for (int friend_pref = 0; friend_pref < mate_pref; ++friend_pref) {\\n                const int person_friend = friends[friend_pref];\\n                const int friends_mate = paired_with[person_friend];\\n                // If that friend\\'s mate it prefers less than \\'person\\', we found a violating pair.\\n                if (person_to_friend_preferences[person_friend][person] < person_to_friend_preferences[person_friend][friends_mate]) {\\n                    ++unhappy;\\n                    break; // One evidence of unhappiness is enough.\\n                }\\n            }\\n        }\\n        return unhappy;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3836507,
                "title": "python3-simulation",
                "content": "# Code\\n```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        d = {}\\n        p = {}\\n        for idx,e in enumerate(preferences):\\n            d[idx] = e\\n        c = set()\\n        for x,y in pairs:\\n            p[x] = y\\n            p[y] = x\\n        for i in range(n):\\n            team = p[i]\\n            temp = []\\n            for m in d[i]:\\n                if m == team:\\n                    break\\n                temp.append(m)\\n            for k in temp:\\n                if d[k].index(i) < d[k].index(p[k]):\\n                    c.add(i)\\n\\n        return len(c)\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        d = {}\\n        p = {}\\n        for idx,e in enumerate(preferences):\\n            d[idx] = e\\n        c = set()\\n        for x,y in pairs:\\n            p[x] = y\\n            p[y] = x\\n        for i in range(n):\\n            team = p[i]\\n            temp = []\\n            for m in d[i]:\\n                if m == team:\\n                    break\\n                temp.append(m)\\n            for k in temp:\\n                if d[k].index(i) < d[k].index(p[k]):\\n                    c.add(i)\\n\\n        return len(c)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3804003,
                "title": "unhappy-friends-t-o-n-2-s-o-n-2",
                "content": "# Intuition\\n#iterate over pairs (partners)\\n#identify the list of friends that each person prefers over their partner\\n#check whether the prefered person also prefers me backwards\\n#if yes, increment the count as I am unhappy\\n#break the inner loop to avoid double counting my unhappiness\\n\\n# Complexity\\n#T=O(n^2),S=O(n^2)\\n\\n# Code\\n```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        d, p = {}, preferences\\n        #T=O(n^2),S=O(n^2) in thw worst case\\n        for x,y in pairs:\\n            d[x] = set(p[x][:p[x].index(y)])\\n            d[y] = set(p[y][:p[y].index(x)])\\n        \\n        res = 0\\n        #T=O(n^2) because dict lookups are O(1)\\n        for x in d:\\n            for y in d[x]:\\n                if x in d[y]:\\n                    res += 1\\n                    break\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        d, p = {}, preferences\\n        #T=O(n^2),S=O(n^2) in thw worst case\\n        for x,y in pairs:\\n            d[x] = set(p[x][:p[x].index(y)])\\n            d[y] = set(p[y][:p[y].index(x)])\\n        \\n        res = 0\\n        #T=O(n^2) because dict lookups are O(1)\\n        for x in d:\\n            for y in d[x]:\\n                if x in d[y]:\\n                    res += 1\\n                    break\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601613,
                "title": "python-intuitive",
                "content": "# Code\\n```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n\\n        partner = {}\\n\\n        for a, b in pairs:\\n            partner[a] = b\\n            partner[b] = a\\n\\n        table = collections.defaultdict(dict)\\n\\n        for person, p in enumerate(preferences):\\n            for rank, friend in enumerate(p):\\n                table[person][friend] = rank\\n\\n\\n        sad = collections.defaultdict(bool)\\n\\n\\n        for person in range(n):\\n            for other in range(person + 1, n):\\n                if partner[person] == other:\\n                    continue\\n                \\n                if table[person][other] < table[person][partner[person]] and table[other][person] < table[other][partner[other]]:\\n                    sad[person] = True\\n                    sad[other] = True\\n        print(sad)\\n\\n        return sum([1 for b in sad.values() if b == True])\\n        \\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n\\n        partner = {}\\n\\n        for a, b in pairs:\\n            partner[a] = b\\n            partner[b] = a\\n\\n        table = collections.defaultdict(dict)\\n\\n        for person, p in enumerate(preferences):\\n            for rank, friend in enumerate(p):\\n                table[person][friend] = rank\\n\\n\\n        sad = collections.defaultdict(bool)\\n\\n\\n        for person in range(n):\\n            for other in range(person + 1, n):\\n                if partner[person] == other:\\n                    continue\\n                \\n                if table[person][other] < table[person][partner[person]] and table[other][person] < table[other][partner[other]]:\\n                    sad[person] = True\\n                    sad[other] = True\\n        print(sad)\\n\\n        return sum([1 for b in sad.values() if b == True])\\n        \\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590869,
                "title": "js-code-with-heavy-commenting",
                "content": "This problem gives me a headache\\n\\n\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} preferences\\n * @param {number[][]} pairs\\n * @return {number}\\n */\\n\\n// N is always even. Number of friends.\\n// Preferences is a list sorted in order of preference. \\n// friends are repped from 0 to n-1\\n// ------- UNHAPPY FRIENDS ------\\n// A person is unhappy if there is a friend in a different pairing\\n// AND that friend has to prefer them back over the person they are paired with.\\n// If the feeling isn\\'t mutual, then it wont be considered a un happy friend\\n\\nvar unhappyFriends = function(n, preferences, pairs) {\\n   \\n\\n    // We create a hashMap to map out every person as the key and their current partner as the value.\\n    let pairedWith = {}\\n\\n\\n    // We loop through the pairings Array to fill in our hashMap.\\n    // We use deconstruction to access the elements in each sub array.\\n    for (let [i, j] of pairs) {\\n        pairedWith[i] = j\\n        pairedWith[j] = i\\n    }\\n    // After the above code, our hashMap looks something like this:\\n    // pairedWith = {  \\n    //                  person: partner\\n    //                  0 : 1\\n    //                  1 : 0\\n    //                  2 : 3\\n    //                  3 : 2\\n    //                          }\\n\\n\\n    // Create a unhappy counter that we increment when finding friends that wanted each other but got other people.\\n    let unhappyCount = 0\\n\\n\\n    // Now we iterate through each \\'person\\' in n.\\n    for (let person = 0; person < n; person++) {\\n        // We want to search through each person\\'s preference list to view missed opportunities of more favorible pairings.\\n        // Our iteration begins at index 0 of their preferrence list. AKA we start with each person MOST preferred friend.\\n        // We want to stop iterating before the index of the person they are already partnered with!\\n        // This is because everyone after our current partner is assumed to be less favorable. Lists are sorted per description!!!!\\n        for (let prefIndex = 0; prefIndex < preferences[person].indexOf(pairedWith[person]); prefIndex++) {\\n            // We create a variable to store the current more preferred partner that we are evaluating.\\n            // Notice here we key into our preferences list, then key into our person\\'s list (that is...the person from our outter for loop).\\n            // Then we use the \\'prefIndex\\' to key into the more preferred partner.\\n            let morePreferredPartner = preferences[person][prefIndex]\\n\\n\\n            // We want to see how our more preferred partner feels (or \\'ranks\\' I guess you could say) about us in comparison with their current\\n            // partners ranking!\\n            // Comparison Logic: A lower index on a preferred list is a more favorible person.\\n            // If our index on a more preferred partner\\'s list is LOWER/LESS THAN their current partners index. They preferred us and are unhappy\\n            // that they did not get us. Obviously the feeling is mutual because if we didn\\'t prefer them over our current partner, we wouldn\\'t be\\n            // evaluating them right now. Thus that makes us both unhappy\\n            if (preferences[morePreferredPartner].indexOf(person) < preferences[morePreferredPartner].indexOf(pairedWith[morePreferredPartner])) {\\n                // Since we are iterating over each person, we only increment unhappy by one. \\\\\\n                // When we begin to evaluate our more preferred partner, the code will show that we were also favored them and thus increase the\\n                // unhappy count again then.\\n                unhappyCount++\\n\\n\\n                // It is very important that we add this break to prevent duplicate increments!!!!!!\\n                break;\\n            }\\n\\n\\n        }\\n    }\\n\\n\\n    // Return count\\n    return unhappyCount\\n\\n\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} preferences\\n * @param {number[][]} pairs\\n * @return {number}\\n */\\n\\n// N is always even. Number of friends.\\n// Preferences is a list sorted in order of preference. \\n// friends are repped from 0 to n-1\\n// ------- UNHAPPY FRIENDS ------\\n// A person is unhappy if there is a friend in a different pairing\\n// AND that friend has to prefer them back over the person they are paired with.\\n// If the feeling isn\\'t mutual, then it wont be considered a un happy friend\\n\\nvar unhappyFriends = function(n, preferences, pairs) {\\n   \\n\\n    // We create a hashMap to map out every person as the key and their current partner as the value.\\n    let pairedWith = {}\\n\\n\\n    // We loop through the pairings Array to fill in our hashMap.\\n    // We use deconstruction to access the elements in each sub array.\\n    for (let [i, j] of pairs) {\\n        pairedWith[i] = j\\n        pairedWith[j] = i\\n    }\\n    // After the above code, our hashMap looks something like this:\\n    // pairedWith = {  \\n    //                  person: partner\\n    //                  0 : 1\\n    //                  1 : 0\\n    //                  2 : 3\\n    //                  3 : 2\\n    //                          }\\n\\n\\n    // Create a unhappy counter that we increment when finding friends that wanted each other but got other people.\\n    let unhappyCount = 0\\n\\n\\n    // Now we iterate through each \\'person\\' in n.\\n    for (let person = 0; person < n; person++) {\\n        // We want to search through each person\\'s preference list to view missed opportunities of more favorible pairings.\\n        // Our iteration begins at index 0 of their preferrence list. AKA we start with each person MOST preferred friend.\\n        // We want to stop iterating before the index of the person they are already partnered with!\\n        // This is because everyone after our current partner is assumed to be less favorable. Lists are sorted per description!!!!\\n        for (let prefIndex = 0; prefIndex < preferences[person].indexOf(pairedWith[person]); prefIndex++) {\\n            // We create a variable to store the current more preferred partner that we are evaluating.\\n            // Notice here we key into our preferences list, then key into our person\\'s list (that is...the person from our outter for loop).\\n            // Then we use the \\'prefIndex\\' to key into the more preferred partner.\\n            let morePreferredPartner = preferences[person][prefIndex]\\n\\n\\n            // We want to see how our more preferred partner feels (or \\'ranks\\' I guess you could say) about us in comparison with their current\\n            // partners ranking!\\n            // Comparison Logic: A lower index on a preferred list is a more favorible person.\\n            // If our index on a more preferred partner\\'s list is LOWER/LESS THAN their current partners index. They preferred us and are unhappy\\n            // that they did not get us. Obviously the feeling is mutual because if we didn\\'t prefer them over our current partner, we wouldn\\'t be\\n            // evaluating them right now. Thus that makes us both unhappy\\n            if (preferences[morePreferredPartner].indexOf(person) < preferences[morePreferredPartner].indexOf(pairedWith[morePreferredPartner])) {\\n                // Since we are iterating over each person, we only increment unhappy by one. \\\\\\n                // When we begin to evaluate our more preferred partner, the code will show that we were also favored them and thus increase the\\n                // unhappy count again then.\\n                unhappyCount++\\n\\n\\n                // It is very important that we add this break to prevent duplicate increments!!!!!!\\n                break;\\n            }\\n\\n\\n        }\\n    }\\n\\n\\n    // Return count\\n    return unhappyCount\\n\\n\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3563112,
                "title": "easy-o-n-2-optimal-solution-simple-and-concise-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we look through the preference list of `x` and find its pair `y`, then all elements *before* `y` is considered `more_preferred` by `x`.\\n\\nUse $x \\\\rightarrow y$ to represent that `y` is `more_preferred` by `x` then we have:\\n$$x \\\\rightarrow y \\\\land y \\\\rightarrow x \\\\Rightarrow\\n x \\\\in U \\\\land y \\\\in U$$ where $U$ is the set of unhappy friends.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe build the set of `more_preferred` for everyone and then check whether each person is unhappy.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(N^2)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(N^2)$$\\n\\n# Code\\n```\\nbool Contains(const unordered_set<int>& s, int x) {\\n  return s.find(x) != s.end();\\n}\\n\\nclass Solution {\\npublic:\\n  int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n    vector<unordered_set<int>> more_preferred(n);\\n    for (const vector<int>& pair : pairs) {\\n      int x = pair[0];\\n      int y = pair[1];\\n      const vector<int>& px = preferences[x];\\n      const vector<int>& py = preferences[y];\\n      more_preferred[x].insert(px.begin(), std::find(px.begin(), px.end(), y));\\n      more_preferred[y].insert(py.begin(), std::find(py.begin(), py.end(), x));\\n    }\\n    int count = 0;\\n    for (int i = 0; i < n; ++i) {\\n      for (int j : more_preferred[i]) {\\n        if (Contains(more_preferred[j], i)) {\\n          ++count;\\n          break;\\n        }\\n      }\\n    }\\n    return count;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nbool Contains(const unordered_set<int>& s, int x) {\\n  return s.find(x) != s.end();\\n}\\n\\nclass Solution {\\npublic:\\n  int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n    vector<unordered_set<int>> more_preferred(n);\\n    for (const vector<int>& pair : pairs) {\\n      int x = pair[0];\\n      int y = pair[1];\\n      const vector<int>& px = preferences[x];\\n      const vector<int>& py = preferences[y];\\n      more_preferred[x].insert(px.begin(), std::find(px.begin(), px.end(), y));\\n      more_preferred[y].insert(py.begin(), std::find(py.begin(), py.end(), x));\\n    }\\n    int count = 0;\\n    for (int i = 0; i < n; ++i) {\\n      for (int j : more_preferred[i]) {\\n        if (Contains(more_preferred[j], i)) {\\n          ++count;\\n          break;\\n        }\\n      }\\n    }\\n    return count;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464060,
                "title": "easy-to-understand-java-solution-with-hashset-and-hashmap",
                "content": "# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n\\n    private int findIndex(int[] arr, int elem) {\\n        for(int i = 0; i < arr.length; ++i) {\\n            if(arr[i] == elem)\\n                return i;\\n        }\\n        return -1; //shouldnt happen as we have full pref list for each person\\n    }\\n\\n    private boolean isPersonHighPri(int[] prefsFOP, int pairedWith, int person) {\\n        for(int friend : prefsFOP) {\\n            if(friend == person)\\n                return true;\\n            else if (friend == pairedWith)\\n                return false; \\n        }    \\n            return true; //shouldnt happen as we have full pref list for each person\\n    }\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        Map<Integer, Integer> pM = new HashMap<>();\\n        Set<Integer> unHappy = new HashSet<>();\\n        for (int[] pair : pairs) {\\n            pM.put(pair[0], pair[1]);\\n            pM.put(pair[1], pair[0]);\\n        }  \\n        for(int person : pM.keySet()) {\\n            if(unHappy.contains(person))\\n                continue;\\n            int other = pM.get(person);\\n            int[] prefsPerson = preferences[person];\\n            int idxOther = findIndex(prefsPerson, other);\\n            if(idxOther == 0) { //means person\\'s first choice, person is happy\\n                continue;\\n            }\\n            else { //go from 0 to idxOther-1, and for each \"other\", check if 1. friend is in their list && they are paired with someone whos priority is less than friend\\'s\\'\\n                for (int i = 0; i < idxOther; ++i) {\\n                    int friendOfPerson = prefsPerson[i];\\n                    int[] prefsFOP = preferences[friendOfPerson];\\n                    int pairedWith = pM.get(friendOfPerson);\\n                    boolean personIsHighPri = isPersonHighPri(prefsFOP, pairedWith, person);\\n                    if(personIsHighPri) {\\n                        unHappy.add(person);\\n                        unHappy.add(friendOfPerson);\\n                        break;\\n                    }\\n                } \\n            }\\n        }  \\n        return unHappy.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    private int findIndex(int[] arr, int elem) {\\n        for(int i = 0; i < arr.length; ++i) {\\n            if(arr[i] == elem)\\n                return i;\\n        }\\n        return -1; //shouldnt happen as we have full pref list for each person\\n    }\\n\\n    private boolean isPersonHighPri(int[] prefsFOP, int pairedWith, int person) {\\n        for(int friend : prefsFOP) {\\n            if(friend == person)\\n                return true;\\n            else if (friend == pairedWith)\\n                return false; \\n        }    \\n            return true; //shouldnt happen as we have full pref list for each person\\n    }\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        Map<Integer, Integer> pM = new HashMap<>();\\n        Set<Integer> unHappy = new HashSet<>();\\n        for (int[] pair : pairs) {\\n            pM.put(pair[0], pair[1]);\\n            pM.put(pair[1], pair[0]);\\n        }  \\n        for(int person : pM.keySet()) {\\n            if(unHappy.contains(person))\\n                continue;\\n            int other = pM.get(person);\\n            int[] prefsPerson = preferences[person];\\n            int idxOther = findIndex(prefsPerson, other);\\n            if(idxOther == 0) { //means person\\'s first choice, person is happy\\n                continue;\\n            }\\n            else { //go from 0 to idxOther-1, and for each \"other\", check if 1. friend is in their list && they are paired with someone whos priority is less than friend\\'s\\'\\n                for (int i = 0; i < idxOther; ++i) {\\n                    int friendOfPerson = prefsPerson[i];\\n                    int[] prefsFOP = preferences[friendOfPerson];\\n                    int pairedWith = pM.get(friendOfPerson);\\n                    boolean personIsHighPri = isPersonHighPri(prefsFOP, pairedWith, person);\\n                    if(personIsHighPri) {\\n                        unHappy.add(person);\\n                        unHappy.add(friendOfPerson);\\n                        break;\\n                    }\\n                } \\n            }\\n        }  \\n        return unHappy.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454050,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(int n, vector<vector<int>>& preferences, vector<int> pairht, int f, int you){\\n        bool isTrue=false;\\n        \\n        for(int i=0; i<n-1; i++){\\n            if(preferences[you][i]==pairht[you]) break;\\n            \\n            if(preferences[you][i]==f)\\n                isTrue=true;\\n        }\\n        \\n        return isTrue;\\n    }\\n    \\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        vector<int> pairht(n);\\n        for(vector<int> pair : pairs){\\n            pairht[pair[0]]=pair[1];\\n            pairht[pair[1]]=pair[0];\\n        }\\n        \\n        int result=0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n-1; j++){\\n                if(preferences[i][j]==pairht[i]) break;\\n                \\n                if(check(n, preferences, pairht, i, preferences[i][j])){\\n                    result++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int n, vector<vector<int>>& preferences, vector<int> pairht, int f, int you){\\n        bool isTrue=false;\\n        \\n        for(int i=0; i<n-1; i++){\\n            if(preferences[you][i]==pairht[you]) break;\\n            \\n            if(preferences[you][i]==f)\\n                isTrue=true;\\n        }\\n        \\n        return isTrue;\\n    }\\n    \\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        vector<int> pairht(n);\\n        for(vector<int> pair : pairs){\\n            pairht[pair[0]]=pair[1];\\n            pairht[pair[1]]=pair[0];\\n        }\\n        \\n        int result=0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n-1; j++){\\n                if(preferences[i][j]==pairht[i]) break;\\n                \\n                if(check(n, preferences, pairht, i, preferences[i][j])){\\n                    result++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406485,
                "title": "java-soln-detailed-description",
                "content": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int numUnHappyFriends = 0;\\n        int[][] rank = new int[n][n];\\n        // rank[i][j] holds how highly friend \\u2018i\\' views \\u2018j\\u2019. \\n        // 0 -> highest, n - 1 -> lowest\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < n - 1; j++) {\\n                rank[i][preferences[i][j]] = j; \\n            }\\n        }\\n        \\n        for(int i = 0; i < n/2; i++) {\\n            // A friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\\n            int x = pairs[i][0], y = pairs[i][1];\\n            for(int j = 0; j < n/2; j++) {\\n                // x prefers u over y, and\\n                // u prefers x over v.\\n                int u = pairs[j][0], v = pairs[j][1];\\n                if(x != u && rank[x][u] < rank[x][y] && rank[u][x] < rank[u][v]) {\\n                    numUnHappyFriends++;\\n                    break;\\n                }\\n                \\n                // x prefers v over y, and\\n                // v prefers x over u.\\n                if(x != v && rank[x][v] < rank[x][y] && rank[v][x] < rank[v][u]) {\\n                    numUnHappyFriends++;\\n                    break;\\n                }\\n            }\\n            \\n            for(int j = 0; j < n/2; j++) {\\n                // y prefers u over x, and\\n                // u prefers y over v.\\n                int u = pairs[j][0], v = pairs[j][1];\\n                if(y != u && rank[y][u] < rank[y][x] && rank[u][y] < rank[u][v]) {\\n                    numUnHappyFriends++;\\n                    break;\\n                }\\n                \\n                // y prefers v over x, and\\n                // v prefers y over u.\\n                if(y != v && rank[y][v] < rank[y][x] && rank[v][y] < rank[v][u]) {\\n                    numUnHappyFriends++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return numUnHappyFriends;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int numUnHappyFriends = 0;\\n        int[][] rank = new int[n][n];\\n        // rank[i][j] holds how highly friend \\u2018i\\' views \\u2018j\\u2019. \\n        // 0 -> highest, n - 1 -> lowest\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < n - 1; j++) {\\n                rank[i][preferences[i][j]] = j; \\n            }\\n        }\\n        \\n        for(int i = 0; i < n/2; i++) {\\n            // A friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\\n            int x = pairs[i][0], y = pairs[i][1];\\n            for(int j = 0; j < n/2; j++) {\\n                // x prefers u over y, and\\n                // u prefers x over v.\\n                int u = pairs[j][0], v = pairs[j][1];\\n                if(x != u && rank[x][u] < rank[x][y] && rank[u][x] < rank[u][v]) {\\n                    numUnHappyFriends++;\\n                    break;\\n                }\\n                \\n                // x prefers v over y, and\\n                // v prefers x over u.\\n                if(x != v && rank[x][v] < rank[x][y] && rank[v][x] < rank[v][u]) {\\n                    numUnHappyFriends++;\\n                    break;\\n                }\\n            }\\n            \\n            for(int j = 0; j < n/2; j++) {\\n                // y prefers u over x, and\\n                // u prefers y over v.\\n                int u = pairs[j][0], v = pairs[j][1];\\n                if(y != u && rank[y][u] < rank[y][x] && rank[u][y] < rank[u][v]) {\\n                    numUnHappyFriends++;\\n                    break;\\n                }\\n                \\n                // y prefers v over x, and\\n                // v prefers y over u.\\n                if(y != v && rank[y][v] < rank[y][x] && rank[v][y] < rank[v][u]) {\\n                    numUnHappyFriends++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return numUnHappyFriends;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391260,
                "title": "javascript-solution-with-diagrams",
                "content": "# The graph is always greener...\\n\\nThe problem can be simplified by describing an \"unhappy friend\" as a friend who prefers a friend who mutually prefers them. We can simplify this problem with a weighted, undirected graph representation of all friends. The weights represent the \"ranks\" each friend gives the other friend, from 0 to n - 1. \\n\\nBy coloring each paired edge red, relatively more expensive edges blue, and cheaper edges green, we can find that the answer is simplified to the number of mutually green edges (both friends rank each other higher than their current pairing).\\n\\nBy creating a map containing all friends with cheaper edges than their current pairing, we can easily identify unhappy friends as friends that both have each other as one of their \"better matches\".\\n\\nFriend Ranks\\n![preferences](https://assets.leetcode.com/users/images/12854c6b-4c38-4f39-81d9-a50ad1d2811f_1680888286.31621.png)\\nFriend Graph\\n![friend-graph](https://assets.leetcode.com/users/images/9736068f-168c-4d76-a2e7-21b5fa22e446_1680889475.8226116.png)\\n\\n\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} preferences\\n * @param {number[][]} pairs\\n * @return {number}\\n */\\n \\nconst unhappyFriends = function(n, preferences, pairs) {\\n  const map = new Array(n);\\n  const unhappyFriends = new Set();\\n  // create map of [friend] : [better matches]\\n  for (const [ friendA, friendB ] of pairs) {\\n      findBetterMatches(friendA, friendB, preferences[friendA]);\\n      findBetterMatches(friendB, friendA, preferences[friendB]);\\n  }\\n  // if two friends are mutually better matches for each other, both are unhappy\\n  for (const [friend, betterMatches] of map.entries()) {\\n    for (const match of betterMatches.values()) {\\n      if (map[match].has(friend)) {\\n        unhappyFriends.add(friend);\\n        unhappyFriends.add(match);\\n      }\\n    }\\n  }\\n  return unhappyFriends.size;\\n\\n  function findBetterMatches(friend, pairedFriend, friendPrefs) {\\n    const betterMatches = new Set();\\n    for (let rank = 0; rank < friendPrefs.length; rank++) {\\n      // create set of friends preferred over paired friend\\n      if (friendPrefs[rank] === pairedFriend) break;\\n      betterMatches.add(friendPrefs[rank]);\\n    };\\n    map[friend] = betterMatches;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} preferences\\n * @param {number[][]} pairs\\n * @return {number}\\n */\\n \\nconst unhappyFriends = function(n, preferences, pairs) {\\n  const map = new Array(n);\\n  const unhappyFriends = new Set();\\n  // create map of [friend] : [better matches]\\n  for (const [ friendA, friendB ] of pairs) {\\n      findBetterMatches(friendA, friendB, preferences[friendA]);\\n      findBetterMatches(friendB, friendA, preferences[friendB]);\\n  }\\n  // if two friends are mutually better matches for each other, both are unhappy\\n  for (const [friend, betterMatches] of map.entries()) {\\n    for (const match of betterMatches.values()) {\\n      if (map[match].has(friend)) {\\n        unhappyFriends.add(friend);\\n        unhappyFriends.add(match);\\n      }\\n    }\\n  }\\n  return unhappyFriends.size;\\n\\n  function findBetterMatches(friend, pairedFriend, friendPrefs) {\\n    const betterMatches = new Set();\\n    for (let rank = 0; rank < friendPrefs.length; rank++) {\\n      // create set of friends preferred over paired friend\\n      if (friendPrefs[rank] === pairedFriend) break;\\n      betterMatches.add(friendPrefs[rank]);\\n    };\\n    map[friend] = betterMatches;\\n  }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3382024,
                "title": "brute-force-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n^2)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int UnhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        if (n ==2)\\n            return 0;\\n        int[][] prefMap = new int[n][];\\n        int[] map = new int[n];\\n        for(int i = 0; i < n;i++){\\n            prefMap[i] = new int[n];\\n            for(int j =0; j < n - 1; j++){\\n                prefMap[i][preferences[i][j]] = j;\\n            }\\n        }\\n        int count = 0;\\n\\n        foreach(int[] pair in pairs){\\n            map[pair[0]] = pair[1];\\n            map[pair[1]] = pair[0];\\n        }\\n\\n        for(int i = 0; i < n;i++){\\n            if(prefMap[i][map[i]] != 0){\\n                for(int j = 0; j < n; j++){\\n                    if(i != j && prefMap[i][j] < prefMap[i][map[i]] && prefMap[j][i] < prefMap[j][map[j]]){\\n                        count++;\\n                        break; // break out since we know i is unhappy\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int UnhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        if (n ==2)\\n            return 0;\\n        int[][] prefMap = new int[n][];\\n        int[] map = new int[n];\\n        for(int i = 0; i < n;i++){\\n            prefMap[i] = new int[n];\\n            for(int j =0; j < n - 1; j++){\\n                prefMap[i][preferences[i][j]] = j;\\n            }\\n        }\\n        int count = 0;\\n\\n        foreach(int[] pair in pairs){\\n            map[pair[0]] = pair[1];\\n            map[pair[1]] = pair[0];\\n        }\\n\\n        for(int i = 0; i < n;i++){\\n            if(prefMap[i][map[i]] != 0){\\n                for(int j = 0; j < n; j++){\\n                    if(i != j && prefMap[i][j] < prefMap[i][map[i]] && prefMap[j][i] < prefMap[j][map[j]]){\\n                        count++;\\n                        break; // break out since we know i is unhappy\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363549,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nOnce you figure out what the question is asking and how to organize the pairings inside of a map its pretty straightforward, otherwise this question can be very confusing. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int count = 0;\\n        int[] pairings = new int[n];\\n        for(int[] pair : pairs){\\n            pairings[pair[0]] = pair[1];\\n            pairings[pair[1]] = pair[0];\\n        }\\n        HashMap<Integer,HashMap<Integer,Integer>> prefers = new HashMap<>();\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n - 1; j++){\\n                int friend = preferences[i][j];\\n                prefers.putIfAbsent(i,new HashMap<>());\\n                prefers.get(i).put(friend,j);\\n            }\\n        }\\n        for(int i = 0; i < n; i++){\\n            for(int j : preferences[i]){\\n                if(prefers.get(i).get(j) < prefers.get(i).get(pairings[i]) && prefers.get(j).get(i) < prefers.get(j).get(pairings[j])){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int count = 0;\\n        int[] pairings = new int[n];\\n        for(int[] pair : pairs){\\n            pairings[pair[0]] = pair[1];\\n            pairings[pair[1]] = pair[0];\\n        }\\n        HashMap<Integer,HashMap<Integer,Integer>> prefers = new HashMap<>();\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n - 1; j++){\\n                int friend = preferences[i][j];\\n                prefers.putIfAbsent(i,new HashMap<>());\\n                prefers.get(i).put(friend,j);\\n            }\\n        }\\n        for(int i = 0; i < n; i++){\\n            for(int j : preferences[i]){\\n                if(prefers.get(i).get(j) < prefers.get(i).get(pairings[i]) && prefers.get(j).get(i) < prefers.get(j).get(pairings[j])){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362669,
                "title": "hashing-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) \\n    {\\n        int p=pairs.size();\\n        map<int,int> m;\\n        for(int x=0; x<p; x++)\\n        {\\n            m[pairs[x][0]]=pairs[x][1];\\n            m[pairs[x][1]]=pairs[x][0];\\n        }\\n        int unhappy=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            vector<int> p=preferences[x]; // 1 2 0\\n            int pairedWith=m[x]; // 2\\n            int u=0;\\n            for(auto it: p)\\n            {\\n                if(it==pairedWith) break;\\n                vector<int> p2=preferences[it]; // 3 2 0\\n                int pairedWith2=m[it]; // 0\\n                for(auto it2: p2)\\n                {\\n                    if(it2==pairedWith2) break;\\n                    if(it2==x)\\n                    {\\n                        u=1;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(u) unhappy++;\\n        }\\n        return unhappy;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) \\n    {\\n        int p=pairs.size();\\n        map<int,int> m;\\n        for(int x=0; x<p; x++)\\n        {\\n            m[pairs[x][0]]=pairs[x][1];\\n            m[pairs[x][1]]=pairs[x][0];\\n        }\\n        int unhappy=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            vector<int> p=preferences[x]; // 1 2 0\\n            int pairedWith=m[x]; // 2\\n            int u=0;\\n            for(auto it: p)\\n            {\\n                if(it==pairedWith) break;\\n                vector<int> p2=preferences[it]; // 3 2 0\\n                int pairedWith2=m[it]; // 0\\n                for(auto it2: p2)\\n                {\\n                    if(it2==pairedWith2) break;\\n                    if(it2==x)\\n                    {\\n                        u=1;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(u) unhappy++;\\n        }\\n        return unhappy;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361126,
                "title": "java-solution-let-s-simply-translate-the-question-into-if-x-u-x-y-u-x-u-v",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDirect translation from problem description to code.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n```\\nif (x[u] < x[y] && u[x] < u[v]) {\\n  unhappy[x] = true;\\n  unhappy[u] = true;\\n}\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N^2)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N^2)$$\\n# Code\\n```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int[][] friend = new int[n][n]; // build friend mapping: f[i] -> [f1_v, f2_v, ... fn-1_v]\\n        for (int i = 0; i < n; i++) {\\n            int[] value = friend[i];\\n            // the smaller a friend\\'s value, the more this friend is prefered\\n            for (int k = 0; k < n - 1; k++) {\\n                value[preferences[i][k]] = k + 1;\\n            }\\n        }\\n\\n        boolean[] unhappy = new boolean[n];\\n        for (int i = 0; i < n / 2; i++) {\\n            int x = pairs[i][0], y = pairs[i][1];\\n\\n            for (int j = i + 1; j < n / 2; j++) {\\n                int u = pairs[j][0], v = pairs[j][1];\\n                if (unhappy[x] && unhappy[y] && unhappy[u] && unhappy[v]) {\\n                    continue;\\n                }\\n\\n                if (friend[x][u] < friend[x][y] && friend[u][x] < friend[u][v]) {\\n                    unhappy[x] = true;\\n                    unhappy[u] = true;\\n                }\\n\\n                if (friend[x][v] < friend[x][y] && friend[v][x] < friend[v][u]) {\\n                    unhappy[x] = true;\\n                    unhappy[v] = true;\\n                }\\n\\n                if (friend[y][u] < friend[y][x] && friend[u][y] < friend[u][v]) {\\n                    unhappy[y] = true;\\n                    unhappy[u] = true;\\n                }\\n\\n                if (friend[y][v] < friend[y][x] && friend[v][y] < friend[v][u]) {\\n                    unhappy[y] = true;\\n                    unhappy[v] = true;\\n                }\\n            }\\n        }\\n\\n        int count = 0;\\n        for (boolean b : unhappy) {\\n            if (b) count++;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nif (x[u] < x[y] && u[x] < u[v]) {\\n  unhappy[x] = true;\\n  unhappy[u] = true;\\n}\\n```\n```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int[][] friend = new int[n][n]; // build friend mapping: f[i] -> [f1_v, f2_v, ... fn-1_v]\\n        for (int i = 0; i < n; i++) {\\n            int[] value = friend[i];\\n            // the smaller a friend\\'s value, the more this friend is prefered\\n            for (int k = 0; k < n - 1; k++) {\\n                value[preferences[i][k]] = k + 1;\\n            }\\n        }\\n\\n        boolean[] unhappy = new boolean[n];\\n        for (int i = 0; i < n / 2; i++) {\\n            int x = pairs[i][0], y = pairs[i][1];\\n\\n            for (int j = i + 1; j < n / 2; j++) {\\n                int u = pairs[j][0], v = pairs[j][1];\\n                if (unhappy[x] && unhappy[y] && unhappy[u] && unhappy[v]) {\\n                    continue;\\n                }\\n\\n                if (friend[x][u] < friend[x][y] && friend[u][x] < friend[u][v]) {\\n                    unhappy[x] = true;\\n                    unhappy[u] = true;\\n                }\\n\\n                if (friend[x][v] < friend[x][y] && friend[v][x] < friend[v][u]) {\\n                    unhappy[x] = true;\\n                    unhappy[v] = true;\\n                }\\n\\n                if (friend[y][u] < friend[y][x] && friend[u][y] < friend[u][v]) {\\n                    unhappy[y] = true;\\n                    unhappy[u] = true;\\n                }\\n\\n                if (friend[y][v] < friend[y][x] && friend[v][y] < friend[v][u]) {\\n                    unhappy[y] = true;\\n                    unhappy[v] = true;\\n                }\\n            }\\n        }\\n\\n        int count = 0;\\n        for (boolean b : unhappy) {\\n            if (b) count++;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3338333,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        int ret = 0 ;\\n        unordered_map<int, int>match ; //mathch\\n        vector<vector<int>>score(n, vector<int>(n)) ;\\n        for(auto p : pairs){\\n            match[p[0]] = p[1] ;\\n            match[p[1]] = p[0] ;\\n        }\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0 ; j <n-1; j++){\\n                int nxt = preferences[i][j] ;\\n                score[i][nxt] = n-j ;\\n            }\\n        }\\n\\n        for(int x = 0; x < n; x++){\\n            int y = match[x] ;\\n            for(int j =0; j < n-1; j++){\\n                if(preferences[x][j] == y)\\n                    break ;\\n                int u = preferences[x][j] ;\\n                int v= match[u] ;\\n                if(score[u][x] > score[u][v]){\\n                    ret ++;\\n                    break ;\\n                }                    \\n            }\\n\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        int ret = 0 ;\\n        unordered_map<int, int>match ; //mathch\\n        vector<vector<int>>score(n, vector<int>(n)) ;\\n        for(auto p : pairs){\\n            match[p[0]] = p[1] ;\\n            match[p[1]] = p[0] ;\\n        }\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0 ; j <n-1; j++){\\n                int nxt = preferences[i][j] ;\\n                score[i][nxt] = n-j ;\\n            }\\n        }\\n\\n        for(int x = 0; x < n; x++){\\n            int y = match[x] ;\\n            for(int j =0; j < n-1; j++){\\n                if(preferences[x][j] == y)\\n                    break ;\\n                int u = preferences[x][j] ;\\n                int v= match[u] ;\\n                if(score[u][x] > score[u][v]){\\n                    ret ++;\\n                    break ;\\n                }                    \\n            }\\n\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293667,
                "title": "c-just-check-if-a-friend-prefers-someone-else-than-the-paired-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI get stuck when an interviewer asks about the $$O(N^2)$$. Denying the possibility that interviewer wouldn\\'t ask me $$O(N^2)$$ and there must be faster solution and that\\'s the key to win the interview, but can not find better solution.\\n\\nAnyways, it\\'s about simply checking the condition the problem states.\\n\\nThe \\'prefersOver\\' function here does that. It checks if the friend \\'f\\' prefers \\'f1\\' rather than (expected, paired) \\'f2\\'.\\n\\nJust to speed up checking if the preference for a given friend, I use the sorted table \\'orderedpreferences\\'.\\n\\nThat\\'s it.\\n\\nI found that most of friends here tried this approach. \\nI hope someone give better than $$O(N^2)$$ approach.\\n\\nThis maybe a good question to check how soon an interviewee come back from freeze state and have balls to write N^2 approach.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N^2)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N^2)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool prefersOver(vector<vector<int>> &orderedpreferences, \\n        int f, int f1, int f2){\\n        int pref1 = orderedpreferences[f][f1];\\n        int pref2 = orderedpreferences[f][f2];\\n        return pref1<pref2;\\n    }\\n\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        vector<int> paired(n);\\n        vector<vector<int>> orderedpreferences(n, vector<int>(n, -1));\\n        for(auto &p : pairs){\\n            paired[p[0]]=p[1];\\n            paired[p[1]]=p[0];\\n        }\\n        for(int i=0; i<n; i++)\\n            for(int j=0; j<preferences[i].size(); j++)\\n                orderedpreferences[i][ preferences[i][j] ] = j;\\n\\n        vector<bool> unhappy(n);\\n        for(int fr=0; fr<n; fr++){\\n            for(int f2 : preferences[fr]){\\n                if(f2==paired[fr]) break;\\n                if(prefersOver(orderedpreferences, f2, fr, paired[f2]))\\n                    unhappy[fr]=true;\\n            }\\n        }\\n        int count=0;\\n        for(bool b : unhappy) count+=b;\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool prefersOver(vector<vector<int>> &orderedpreferences, \\n        int f, int f1, int f2){\\n        int pref1 = orderedpreferences[f][f1];\\n        int pref2 = orderedpreferences[f][f2];\\n        return pref1<pref2;\\n    }\\n\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        vector<int> paired(n);\\n        vector<vector<int>> orderedpreferences(n, vector<int>(n, -1));\\n        for(auto &p : pairs){\\n            paired[p[0]]=p[1];\\n            paired[p[1]]=p[0];\\n        }\\n        for(int i=0; i<n; i++)\\n            for(int j=0; j<preferences[i].size(); j++)\\n                orderedpreferences[i][ preferences[i][j] ] = j;\\n\\n        vector<bool> unhappy(n);\\n        for(int fr=0; fr<n; fr++){\\n            for(int f2 : preferences[fr]){\\n                if(f2==paired[fr]) break;\\n                if(prefersOver(orderedpreferences, f2, fr, paired[f2]))\\n                    unhappy[fr]=true;\\n            }\\n        }\\n        int count=0;\\n        for(bool b : unhappy) count+=b;\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261646,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func unhappyFriends(_ n: Int, _ pr: [[Int]], _ pa: [[Int]]) -> Int {\\n        \\n        var ws = Array(repeating: Array(repeating: Int.max, count: n), count: n)\\n        var res = 0\\n\\n        let ps = pa.reduce(into: Array(repeating: 0, count: n)) {\\n            $0[$1[0]] = $1[1]\\n            $0[$1[1]] = $1[0]\\n        }\\n\\n        func check(_ x: Int, _ y: Int) -> Bool {\\n            for u in ws[x].indices\\n                where ws[x][u] < ws[x][y] {\\n                    guard ws[u][x] > ws[u][ps[u]] else { return true }\\n                }\\n            return false\\n        }\\n\\n        for i in pr.indices {\\n            for j in pr[i].indices {\\n                ws[i][pr[i][j]] = j\\n            }\\n        }\\n\\n        for p in pa {\\n            if check(p[0], p[1]) { res += 1 }\\n            if check(p[1], p[0]) { res += 1 }\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func unhappyFriends(_ n: Int, _ pr: [[Int]], _ pa: [[Int]]) -> Int {\\n        \\n        var ws = Array(repeating: Array(repeating: Int.max, count: n), count: n)\\n        var res = 0\\n\\n        let ps = pa.reduce(into: Array(repeating: 0, count: n)) {\\n            $0[$1[0]] = $1[1]\\n            $0[$1[1]] = $1[0]\\n        }\\n\\n        func check(_ x: Int, _ y: Int) -> Bool {\\n            for u in ws[x].indices\\n                where ws[x][u] < ws[x][y] {\\n                    guard ws[u][x] > ws[u][ps[u]] else { return true }\\n                }\\n            return false\\n        }\\n\\n        for i in pr.indices {\\n            for j in pr[i].indices {\\n                ws[i][pr[i][j]] = j\\n            }\\n        }\\n\\n        for p in pa {\\n            if check(p[0], p[1]) { res += 1 }\\n            if check(p[1], p[0]) { res += 1 }\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232253,
                "title": "python-slower-but-easier-to-understand-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        lookup = defaultdict(dict)\\n        for idx, preference in enumerate(preferences):\\n            for idx2, friend in enumerate(preference):\\n                lookup[idx][friend] = idx2\\n\\n        unhappy = set()\\n\\n        for (x, y), (u, v) in itertools.combinations(pairs, 2):\\n            if lookup[x][u] < lookup[x][y] and lookup[u][x] < lookup[u][v]:\\n                unhappy.add(x)\\n                unhappy.add(u)\\n\\n            if lookup[x][v] < lookup[x][y] and lookup[v][x] < lookup[v][u]:\\n                unhappy.add(x)\\n                unhappy.add(v)\\n\\n            if lookup[y][v] < lookup[y][x] and lookup[v][y] < lookup[v][u]:\\n                unhappy.add(y)\\n                unhappy.add(v)\\n\\n            if lookup[y][u] < lookup[y][x] and lookup[u][y] < lookup[u][v]:\\n                unhappy.add(y)\\n                unhappy.add(u)\\n\\n        return len(unhappy)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        lookup = defaultdict(dict)\\n        for idx, preference in enumerate(preferences):\\n            for idx2, friend in enumerate(preference):\\n                lookup[idx][friend] = idx2\\n\\n        unhappy = set()\\n\\n        for (x, y), (u, v) in itertools.combinations(pairs, 2):\\n            if lookup[x][u] < lookup[x][y] and lookup[u][x] < lookup[u][v]:\\n                unhappy.add(x)\\n                unhappy.add(u)\\n\\n            if lookup[x][v] < lookup[x][y] and lookup[v][x] < lookup[v][u]:\\n                unhappy.add(x)\\n                unhappy.add(v)\\n\\n            if lookup[y][v] < lookup[y][x] and lookup[v][y] < lookup[v][u]:\\n                unhappy.add(y)\\n                unhappy.add(v)\\n\\n            if lookup[y][u] < lookup[y][x] and lookup[u][y] < lookup[u][v]:\\n                unhappy.add(y)\\n                unhappy.add(u)\\n\\n        return len(unhappy)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228704,
                "title": "java-1ms-beats-100-uses-hashmap-to-store-pairs",
                "content": "# Intuition\\nStores pair of friends in a hashMap and calculates for each friend if they are unhappy  \\n\\n# Approach\\nSelf-explanatory - follow comments\\n\\n# Complexity\\n- Time complexity:\\nGoes through prefernces array for each friend - O(n^2)\\n\\n- Space complexity:\\nMap storing friendship for each friend - O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    Map<Integer, Integer> pairMap;\\n    int[][] preferences;\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        this.preferences = preferences;\\n        this.pairMap = new HashMap<>();\\n\\n        int unhappy = 0;\\n\\n        for (int[] pair: pairs) {\\n            // Add each pair of frienship to map\\n            pairMap.put(pair[0], pair[1]);\\n            pairMap.put(pair[1], pair[0]);\\n        }\\n\\n        for (int[] pair: pairs) {\\n            int x = pair[0];\\n            int y = pair[1];   \\n\\n            // for each pair x-y check if x is unhappy and if y is unhappy\\n            if (isUnhappy(x, preferences[x])) {\\n                unhappy++;\\n            }\\n            if (isUnhappy(y, preferences[y])) {\\n                unhappy++;\\n            }\\n        }\\n\\n        return unhappy;\\n        \\n    }\\n\\n    private boolean isUnhappy(int x, int[] prefx) {\\n        boolean unhappy = false;\\n        int y = pairMap.get(x);\\n\\n        /**\\n        * (1st condition)\\n        * Iterates through preferences array of x till it finds y\\n        * Friends after y are not to be considered since they have\\n        * low preference than orginal pairing i.e. x is happy with y\\n        */\\n    \\n        for (int u: prefx) {\\n            if (u != y && !unhappy) {\\n\\n                /**\\n                * (2nd condition)\\n                * For each u (friend with higher preference than y)\\n                * checks if v (the friend u is paired with) has higher\\n                * index than x in preference array of u which means\\n                * u prefers x over v\\n                */\\n \\n                if (indexOf(preferences[u], x) < indexOf(preferences[u], pairMap.get(u))) {\\n                    unhappy = true;\\n                }\\n            } else {\\n                break;\\n            }\\n        }\\n        return unhappy;\\n    }\\n\\n    // Gets index of value in arr\\n    private int indexOf(int[] arr, int value) {\\n        for (int i=0 ; i<arr.length ; i++) {\\n            if (arr[i] == value) {\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Map<Integer, Integer> pairMap;\\n    int[][] preferences;\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        this.preferences = preferences;\\n        this.pairMap = new HashMap<>();\\n\\n        int unhappy = 0;\\n\\n        for (int[] pair: pairs) {\\n            // Add each pair of frienship to map\\n            pairMap.put(pair[0], pair[1]);\\n            pairMap.put(pair[1], pair[0]);\\n        }\\n\\n        for (int[] pair: pairs) {\\n            int x = pair[0];\\n            int y = pair[1];   \\n\\n            // for each pair x-y check if x is unhappy and if y is unhappy\\n            if (isUnhappy(x, preferences[x])) {\\n                unhappy++;\\n            }\\n            if (isUnhappy(y, preferences[y])) {\\n                unhappy++;\\n            }\\n        }\\n\\n        return unhappy;\\n        \\n    }\\n\\n    private boolean isUnhappy(int x, int[] prefx) {\\n        boolean unhappy = false;\\n        int y = pairMap.get(x);\\n\\n        /**\\n        * (1st condition)\\n        * Iterates through preferences array of x till it finds y\\n        * Friends after y are not to be considered since they have\\n        * low preference than orginal pairing i.e. x is happy with y\\n        */\\n    \\n        for (int u: prefx) {\\n            if (u != y && !unhappy) {\\n\\n                /**\\n                * (2nd condition)\\n                * For each u (friend with higher preference than y)\\n                * checks if v (the friend u is paired with) has higher\\n                * index than x in preference array of u which means\\n                * u prefers x over v\\n                */\\n \\n                if (indexOf(preferences[u], x) < indexOf(preferences[u], pairMap.get(u))) {\\n                    unhappy = true;\\n                }\\n            } else {\\n                break;\\n            }\\n        }\\n        return unhappy;\\n    }\\n\\n    // Gets index of value in arr\\n    private int indexOf(int[] arr, int value) {\\n        for (int i=0 ; i<arr.length ; i++) {\\n            if (arr[i] == value) {\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3221869,
                "title": "simple-c-solution-time-waste-qn-leetcode-must-be-on-w-ed",
                "content": "// These Type Of Qn Are Just Time Waste... I\\'ll Not Suggest Anyone To Waste Too Much Time On These Qustions //\\n\\n# Code 1 (98% Beat In RunTime And 100% Beat In Space)\\n```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        unordered_map<int, int> m;\\n        for(int i=0;i<pairs.size();i++){\\n            m[pairs[i][0]]=pairs[i][1];\\n            m[pairs[i][1]]=pairs[i][0];\\n        }\\n        int ans=0;\\n        for(auto x: m){\\n            bool fl=false;\\n            for(auto y: preferences[x.first]){\\n                if(y==x.second) break;\\n                if(m.find(y)!=m.end()){\\n                    for(auto z: preferences[y]){\\n                        if(z==m[y]) break;\\n                        if(z==x.first){\\n                            ans++;\\n                            fl=true;\\n                            // cout<<x.first<<\" \"<<y<<\"/\";\\n                            break;\\n                        }\\n                    }\\n                    if(fl) break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Code 2 (89% Beat In RunTime And 96% Beat In Space)\\n```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        unordered_map<int, int> m;\\n        for(auto x: pairs){\\n            m[x[0]]=x[1];\\n            m[x[1]]=x[0];\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            bool fl=false;\\n            for(auto x: preferences[i]){\\n                if(x==m[i]) break;\\n                for(auto y: preferences[x]){\\n                    if(y==m[x]) break;\\n                    if(y==i){\\n                        ans++;\\n                        fl=true;\\n                        // cout<<i<<\" \"<<x<<\"/\";\\n                        break;\\n                    }\\n                }\\n                if(fl) break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        unordered_map<int, int> m;\\n        for(int i=0;i<pairs.size();i++){\\n            m[pairs[i][0]]=pairs[i][1];\\n            m[pairs[i][1]]=pairs[i][0];\\n        }\\n        int ans=0;\\n        for(auto x: m){\\n            bool fl=false;\\n            for(auto y: preferences[x.first]){\\n                if(y==x.second) break;\\n                if(m.find(y)!=m.end()){\\n                    for(auto z: preferences[y]){\\n                        if(z==m[y]) break;\\n                        if(z==x.first){\\n                            ans++;\\n                            fl=true;\\n                            // cout<<x.first<<\" \"<<y<<\"/\";\\n                            break;\\n                        }\\n                    }\\n                    if(fl) break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        unordered_map<int, int> m;\\n        for(auto x: pairs){\\n            m[x[0]]=x[1];\\n            m[x[1]]=x[0];\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            bool fl=false;\\n            for(auto x: preferences[i]){\\n                if(x==m[i]) break;\\n                for(auto y: preferences[x]){\\n                    if(y==m[x]) break;\\n                    if(y==i){\\n                        ans++;\\n                        fl=true;\\n                        // cout<<i<<\" \"<<x<<\"/\";\\n                        break;\\n                    }\\n                }\\n                if(fl) break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3215802,
                "title": "beats-100-easy-java-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n\\n      int count=0;\\n\\n      boolean func2(int number1,int number2,HashMap<Integer,Integer>mp,int[][]preferences){\\n\\n      int num=mp.get(number1);\\n\\n      for(int i=0;i<preferences[number1].length;i++){\\n          if(num==preferences[number1][i])return false;\\n          else if(number2==preferences[number1][i])return true;\\n      }\\n\\n      return true;\\n\\n      }\\n\\n    void func1(int num,int end,HashMap<Integer,Integer>mp,int[][]preferences,int[][]pairs){\\n\\n    int[]temp=preferences[num];\\n\\n    for(int i=0;i<temp.length&&temp[i]!=end;i++){\\n    if(func2(temp[i],num,mp,preferences)){\\n        count++;\\n        return;\\n    }\\n    }\\n\\n    }\\n\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n    HashMap<Integer,Integer>mp=new HashMap<>();\\n    for(int i=0;i<pairs.length;i++){\\n    mp.put(pairs[i][0],pairs[i][1]);\\n    mp.put(pairs[i][1],pairs[i][0]);\\n    }\\n    for(int i=0;i<pairs.length;i++){\\n    func1(pairs[i][0],pairs[i][1],mp,preferences,pairs);\\n    func1(pairs[i][1],pairs[i][0],mp,preferences,pairs);\\n    }\\n    return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n\\n      int count=0;\\n\\n      boolean func2(int number1,int number2,HashMap<Integer,Integer>mp,int[][]preferences){\\n\\n      int num=mp.get(number1);\\n\\n      for(int i=0;i<preferences[number1].length;i++){\\n          if(num==preferences[number1][i])return false;\\n          else if(number2==preferences[number1][i])return true;\\n      }\\n\\n      return true;\\n\\n      }\\n\\n    void func1(int num,int end,HashMap<Integer,Integer>mp,int[][]preferences,int[][]pairs){\\n\\n    int[]temp=preferences[num];\\n\\n    for(int i=0;i<temp.length&&temp[i]!=end;i++){\\n    if(func2(temp[i],num,mp,preferences)){\\n        count++;\\n        return;\\n    }\\n    }\\n\\n    }\\n\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n    HashMap<Integer,Integer>mp=new HashMap<>();\\n    for(int i=0;i<pairs.length;i++){\\n    mp.put(pairs[i][0],pairs[i][1]);\\n    mp.put(pairs[i][1],pairs[i][0]);\\n    }\\n    for(int i=0;i<pairs.length;i++){\\n    func1(pairs[i][0],pairs[i][1],mp,preferences,pairs);\\n    func1(pairs[i][1],pairs[i][0],mp,preferences,pairs);\\n    }\\n    return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207831,
                "title": "clear-python-solution",
                "content": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        ranking = defaultdict(lambda: defaultdict(int))\\n        \\n        for x, friends in enumerate(preferences):\\n            for rank, u in enumerate(friends):\\n                ranking[x][u] = rank\\n        \\n        pairmap = {}\\n        for x, y in pairs:\\n            pairmap[x] = y\\n            pairmap[y] = x\\n        \\n        res = 0\\n        for x, friends in enumerate(preferences):\\n            y = pairmap[x]\\n            for u in friends:\\n                v = pairmap[u]\\n                if ranking[x][u] < ranking[x][y] and ranking[u][x] < ranking[u][v]:\\n                    res += 1\\n                    break\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        ranking = defaultdict(lambda: defaultdict(int))\\n        \\n        for x, friends in enumerate(preferences):\\n            for rank, u in enumerate(friends):\\n                ranking[x][u] = rank\\n        \\n        pairmap = {}\\n        for x, y in pairs:\\n            pairmap[x] = y\\n            pairmap[y] = x\\n        \\n        res = 0\\n        for x, friends in enumerate(preferences):\\n            y = pairmap[x]\\n            for u in friends:\\n                v = pairmap[u]\\n                if ranking[x][u] < ranking[x][y] and ranking[u][x] < ranking[u][v]:\\n                    res += 1\\n                    break\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3168108,
                "title": "swift",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    var dict: [Int: Int] = [:]\\n    var distances: [[Int]: Int] = [:]\\n\\n    var unhappy: Set<Int> = []\\n\\n    func unhappyFriends(_ n: Int, _ preferences: [[Int]], _ pairs: [[Int]]) -> Int {\\n\\n        for i in 0..<n {\\n            let person = i\\n            let personIPreferences = preferences[i]\\n            for j in 0..<personIPreferences.count {\\n                distances[[i, personIPreferences[j]]] = j\\n            }\\n        }\\n        \\n        for pair in pairs {\\n            let x = pair[0]\\n            let y = pair[1]\\n            dict[x, default: 0] = y\\n            dict[y, default: 0] = x\\n        }\\n\\n        for pair in pairs {\\n            checkPair(pair[0], pair[1], preferences, pairs)\\n            checkPair(pair[1], pair[0], preferences, pairs)\\n        }\\n\\n        return unhappy.count\\n    }\\n\\n    func checkPair(_ x: Int, _ y: Int, _ preferences: [[Int]], _ pairs: [[Int]])  {\\n\\n        let preferencesX = preferences[x]\\n            for u in preferencesX {\\n                if distances[[x, u]]! < distances[[x, y]]! {\\n                    let v = dict[u, default: 0]\\n                    let preferencesU = preferences[u]\\n                    \\n                    // potentialy check in loop\\n                    if distances[[u, x]]! < distances[[u, v]]!  { // check disatnce between two\\n                        unhappy.insert(x)\\n                    }\\n                }\\n        }  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n\\n    var dict: [Int: Int] = [:]\\n    var distances: [[Int]: Int] = [:]\\n\\n    var unhappy: Set<Int> = []\\n\\n    func unhappyFriends(_ n: Int, _ preferences: [[Int]], _ pairs: [[Int]]) -> Int {\\n\\n        for i in 0..<n {\\n            let person = i\\n            let personIPreferences = preferences[i]\\n            for j in 0..<personIPreferences.count {\\n                distances[[i, personIPreferences[j]]] = j\\n            }\\n        }\\n        \\n        for pair in pairs {\\n            let x = pair[0]\\n            let y = pair[1]\\n            dict[x, default: 0] = y\\n            dict[y, default: 0] = x\\n        }\\n\\n        for pair in pairs {\\n            checkPair(pair[0], pair[1], preferences, pairs)\\n            checkPair(pair[1], pair[0], preferences, pairs)\\n        }\\n\\n        return unhappy.count\\n    }\\n\\n    func checkPair(_ x: Int, _ y: Int, _ preferences: [[Int]], _ pairs: [[Int]])  {\\n\\n        let preferencesX = preferences[x]\\n            for u in preferencesX {\\n                if distances[[x, u]]! < distances[[x, y]]! {\\n                    let v = dict[u, default: 0]\\n                    let preferencesU = preferences[u]\\n                    \\n                    // potentialy check in loop\\n                    if distances[[u, x]]! < distances[[u, v]]!  { // check disatnce between two\\n                        unhappy.insert(x)\\n                    }\\n                }\\n        }  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148056,
                "title": "using-index-and-dictionary-to-solve-python3",
                "content": "# Intuition\\nUsing index to find the unhappy and dictionary to solve\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        if n == 2:\\n            return 0\\n        unhappy = 0\\n        pair = {}\\n\\n        for i in pairs:\\n            pair[i[0]] = i[1]\\n            pair[i[1]] = i[0]\\n        \\n        for person in pair.keys():\\n            curr_pair = pair[person] #0\\n            pref = preferences[person] #[3,2,0]\\n            currp_index = pref.index(curr_pair) #0 ->2\\n            if currp_index != 0:\\n                for i in range(currp_index): #loop through [3,2,0]\\n                    temp_pref= pref[i] #3\\n                    temp_pair = pair[temp_pref] #2\\n                    index_temp_pair = preferences[temp_pref].index(temp_pair) #index of 2 -> 1\\n                    person_index = preferences[temp_pref].index(person) #index of 1 -> 0\\n                    if person_index < index_temp_pair:\\n                        unhappy +=1\\n                        break \\n        return unhappy\\n                    \\n\\n\\n                \\n            \\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        if n == 2:\\n            return 0\\n        unhappy = 0\\n        pair = {}\\n\\n        for i in pairs:\\n            pair[i[0]] = i[1]\\n            pair[i[1]] = i[0]\\n        \\n        for person in pair.keys():\\n            curr_pair = pair[person] #0\\n            pref = preferences[person] #[3,2,0]\\n            currp_index = pref.index(curr_pair) #0 ->2\\n            if currp_index != 0:\\n                for i in range(currp_index): #loop through [3,2,0]\\n                    temp_pref= pref[i] #3\\n                    temp_pair = pair[temp_pref] #2\\n                    index_temp_pair = preferences[temp_pref].index(temp_pair) #index of 2 -> 1\\n                    person_index = preferences[temp_pref].index(person) #index of 1 -> 0\\n                    if person_index < index_temp_pair:\\n                        unhappy +=1\\n                        break \\n        return unhappy\\n                    \\n\\n\\n                \\n            \\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3124257,
                "title": "40ms-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nuse a topological sort approach. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo solve this problem, I will use a topological sort approach. This approach involves creating a directed graph of the friends, where each node is a friend and each edge is a preference. Then, the problem can be solved by looping through each friend and checking if any of their more preferred friends have a partner who is less preferred than them. If so, the friend is unhappy and can be added to the unhappy count.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#pragma GCC optimize(\"Ofast\",\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\",\"f16c\")\\nstatic const auto fast = []() { ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); return 0; } ();\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        vector<vector<int>> order(n, vector<int>(n));\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n - 1; ++j) {\\n                order[i][preferences[i][j]] = j;\\n            }\\n        }\\n        vector<int> pairings(n);\\n        for (auto& pair : pairs) {\\n            pairings[pair[0]] = pair[1];\\n            pairings[pair[1]] = pair[0];\\n        }\\n        int unhappy = 0;\\n        for (int x = 0; x < n; ++x) {\\n            int y = pairings[x];\\n            int index = order[x][y];\\n            for (int i = 0; i < index; ++i) {\\n                int u = preferences[x][i];\\n                int v = pairings[u];\\n                if (order[u][x] < order[u][v]) {\\n                    ++unhappy;\\n                    break;\\n                }\\n            }\\n        }\\n        return unhappy;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#pragma GCC optimize(\"Ofast\",\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\",\"f16c\")\\nstatic const auto fast = []() { ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); return 0; } ();\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        vector<vector<int>> order(n, vector<int>(n));\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n - 1; ++j) {\\n                order[i][preferences[i][j]] = j;\\n            }\\n        }\\n        vector<int> pairings(n);\\n        for (auto& pair : pairs) {\\n            pairings[pair[0]] = pair[1];\\n            pairings[pair[1]] = pair[0];\\n        }\\n        int unhappy = 0;\\n        for (int x = 0; x < n; ++x) {\\n            int y = pairings[x];\\n            int index = order[x][y];\\n            for (int i = 0; i < index; ++i) {\\n                int u = preferences[x][i];\\n                int v = pairings[u];\\n                if (order[u][x] < order[u][v]) {\\n                    ++unhappy;\\n                    break;\\n                }\\n            }\\n        }\\n        return unhappy;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3124255,
                "title": "python3-solution-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this problem is to find the number of unhappy friends in a given group. The two main parameters we have to consider are the preferences and the pairings of the friends. We need to find out which pairings make the friends unhappy. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nA brute force approach to this problem would be to compare each pair of friends with each other and check if they are unhappy with their current pairing. However, this would have a time complexity of $$O(n^2)$$ and is not optimal. \\n\\nA better approach would be to create an order of preference for each friend, using the given preferences. Then, we can iterate through each pair of friends and compare their current pairing with the order of preference. If the current pairing is not lower in the order of preference than any other friend, then the pair is happy. Otherwise, the pair is unhappy and we can increment the count of unhappy friends. This approach has a time complexity of $$O(n)$$ and a space complexity of $$O(n^2)$$.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        order = [[0] * n for _ in range(n)]\\n        for i in range(n):\\n            for j in range(n - 1):\\n                order[i][preferences[i][j]] = j\\n                \\n        pairings = [0] * n\\n        for x, y in pairs:\\n            pairings[x] = y\\n            pairings[y] = x\\n            \\n        unhappy = 0\\n        for x in range(n):\\n            y = pairings[x]\\n            index = order[x][y]\\n            for i in range(index):\\n                u = preferences[x][i]\\n                v = pairings[u]\\n                if order[u][x] < order[u][v]:\\n                    unhappy += 1\\n                    break\\n                    \\n        return unhappy\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        order = [[0] * n for _ in range(n)]\\n        for i in range(n):\\n            for j in range(n - 1):\\n                order[i][preferences[i][j]] = j\\n                \\n        pairings = [0] * n\\n        for x, y in pairs:\\n            pairings[x] = y\\n            pairings[y] = x\\n            \\n        unhappy = 0\\n        for x in range(n):\\n            y = pairings[x]\\n            index = order[x][y]\\n            for i in range(index):\\n                u = preferences[x][i]\\n                v = pairings[u]\\n                if order[u][x] < order[u][v]:\\n                    unhappy += 1\\n                    break\\n                    \\n        return unhappy\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3123422,
                "title": "c-short-easy-understand-time-fast-than-95-space-smaller-than-90",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        unordered_map<int, int> rec;\\n        int res = 0;\\n        for(auto it:pairs){\\n            rec[it[0]] = it[1];\\n            rec[it[1]] = it[0];\\n        }\\n        for(int i=0;i<n;i++){\\n            int index = find(preferences[i].begin(), preferences[i].end(), rec[i]) - preferences[i].begin();\\n            for(int j=0;j<index;j++){\\n                int pair_index = find(preferences[preferences[i][j]].begin(), preferences[preferences[i][j]].end(), rec[preferences[i][j]]) - preferences[preferences[i][j]].begin();\\n                int comp_index = find(preferences[preferences[i][j]].begin(), preferences[preferences[i][j]].end(), i) - preferences[preferences[i][j]].begin();\\n                if(comp_index < pair_index){\\n                    res += 1;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        unordered_map<int, int> rec;\\n        int res = 0;\\n        for(auto it:pairs){\\n            rec[it[0]] = it[1];\\n            rec[it[1]] = it[0];\\n        }\\n        for(int i=0;i<n;i++){\\n            int index = find(preferences[i].begin(), preferences[i].end(), rec[i]) - preferences[i].begin();\\n            for(int j=0;j<index;j++){\\n                int pair_index = find(preferences[preferences[i][j]].begin(), preferences[preferences[i][j]].end(), rec[preferences[i][j]]) - preferences[preferences[i][j]].begin();\\n                int comp_index = find(preferences[preferences[i][j]].begin(), preferences[preferences[i][j]].end(), i) - preferences[preferences[i][j]].begin();\\n                if(comp_index < pair_index){\\n                    res += 1;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112093,
                "title": "python-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        \"\"\"\\n        for every number `x`, find its pair numbers\\' preference list and see if there are elements with the higher priority than the number `x` itself; \\n        if yes, we need to further check the preference list of those numbers and see if `x` is in it\\n\\n        # example 1:\\n        {\\n            0: []\\n            1: [3, 2]\\n            2: []\\n            3: [1]\\n        }\\n        \"\"\"\\n        hmap = {}\\n        for n1, n2 in pairs:\\n            hmap[n1] = preferences[n1][:preferences[n1].index(n2)]\\n            hmap[n2] = preferences[n2][:preferences[n2].index(n1)]\\n\\n        res = 0\\n        for k in hmap:\\n            for pref_before_parnter in hmap[k]:\\n                if k in hmap[pref_before_parnter]:\\n                    res += 1\\n                    break\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        \"\"\"\\n        for every number `x`, find its pair numbers\\' preference list and see if there are elements with the higher priority than the number `x` itself; \\n        if yes, we need to further check the preference list of those numbers and see if `x` is in it\\n\\n        # example 1:\\n        {\\n            0: []\\n            1: [3, 2]\\n            2: []\\n            3: [1]\\n        }\\n        \"\"\"\\n        hmap = {}\\n        for n1, n2 in pairs:\\n            hmap[n1] = preferences[n1][:preferences[n1].index(n2)]\\n            hmap[n2] = preferences[n2][:preferences[n2].index(n1)]\\n\\n        res = 0\\n        for k in hmap:\\n            for pref_before_parnter in hmap[k]:\\n                if k in hmap[pref_before_parnter]:\\n                    res += 1\\n                    break\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066039,
                "title": "easy-to-understand-c-o-n-2-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBuild a pref_vec that holds the order of preference for each person.\\nBuild a partners vector that holds each person\\'s partner.\\n\\nLoop through the pairs list to examine each person\\'s preference and use the \"unhappy\" logic to find out the result.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        // A 2D list that holds the preference order of between friends\\n        vector<vector<int>> pref_vec(n, vector<int>(n, n));\\n        // A 1D list that holds partner pairs\\n        vector<int> partners(n, -1);\\n\\n        // Build the pref_vec by inserting the order number,\\n        // smaller the number is, the more preferable\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n-1; j++) {\\n                int pref_friend = preferences[i][j];\\n                pref_vec[i][pref_friend] = j;\\n            }\\n        }\\n\\n        // Build the partners vector\\n        for (auto& pair_ : pairs) {\\n            partners[pair_[0]] = pair_[1];\\n            partners[pair_[1]] = pair_[0];\\n        }\\n\\n        int ans = 0;\\n        // Loop through each pair and check the preferences\\n        for (auto& pair_ : pairs) {\\n            int f1 = pair_[0], f2 = pair_[1];\\n\\n            // Friend preference for f1:\\n            for (int f_ : preferences[f1]) {\\n                int f_partner = partners[f_];\\n                // The logic explained in this question:\\n                // If f1 prefers f_ more than f2, and f_ prefers f1 more than f_\\'s partner,\\n                // then ans++\\n                if (pref_vec[f1][f_] < pref_vec[f1][f2] && pref_vec[f_][f1] < pref_vec[f_][f_partner]) {\\n                    ans++;\\n                    break;\\n                } else if (f_ == f2) {\\n                    break;\\n                }\\n            }\\n\\n            // Friend preference for f2:\\n            for (int f_ : preferences[f2]) {\\n                int f_partner = partners[f_];\\n                // The logic explained in this question:\\n                // If f2 prefers f_ more than f1, and f_ prefers f2 more than f_\\'s partner,\\n                // then ans++\\n                if (pref_vec[f2][f_] < pref_vec[f2][f1] && pref_vec[f_][f2] < pref_vec[f_][f_partner]) {\\n                    ans++;\\n                    break;\\n                } else if (f_ == f1) {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity: O(n^2), a nested for loop is required\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2), size of pref_vec is n x n.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        // A 2D list that holds the preference order of between friends\\n        vector<vector<int>> pref_vec(n, vector<int>(n, n));\\n        // A 1D list that holds partner pairs\\n        vector<int> partners(n, -1);\\n\\n        // Build the pref_vec by inserting the order number,\\n        // smaller the number is, the more preferable\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n-1; j++) {\\n                int pref_friend = preferences[i][j];\\n                pref_vec[i][pref_friend] = j;\\n            }\\n        }\\n\\n        // Build the partners vector\\n        for (auto& pair_ : pairs) {\\n            partners[pair_[0]] = pair_[1];\\n            partners[pair_[1]] = pair_[0];\\n        }\\n\\n        int ans = 0;\\n        // Loop through each pair and check the preferences\\n        for (auto& pair_ : pairs) {\\n            int f1 = pair_[0], f2 = pair_[1];\\n\\n            // Friend preference for f1:\\n            for (int f_ : preferences[f1]) {\\n                int f_partner = partners[f_];\\n                // The logic explained in this question:\\n                // If f1 prefers f_ more than f2, and f_ prefers f1 more than f_\\'s partner,\\n                // then ans++\\n                if (pref_vec[f1][f_] < pref_vec[f1][f2] && pref_vec[f_][f1] < pref_vec[f_][f_partner]) {\\n                    ans++;\\n                    break;\\n                } else if (f_ == f2) {\\n                    break;\\n                }\\n            }\\n\\n            // Friend preference for f2:\\n            for (int f_ : preferences[f2]) {\\n                int f_partner = partners[f_];\\n                // The logic explained in this question:\\n                // If f2 prefers f_ more than f1, and f_ prefers f2 more than f_\\'s partner,\\n                // then ans++\\n                if (pref_vec[f2][f_] < pref_vec[f2][f1] && pref_vec[f_][f2] < pref_vec[f_][f_partner]) {\\n                    ans++;\\n                    break;\\n                } else if (f_ == f1) {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017641,
                "title": "c-beats-95-n-2-solution-tough-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    // Claryfing Questions:\\n    //  If someone is paired with a \\'neutrel\\' friend , is that person still unhappy?\\n    //  Does it make someone happy only if they are paired with their favorite person?\\n    //  What is one person is paired with their favorite person, but that fav person doesnt see\\n    //  the other person as their favorite person.\\n    bool check_if_unhappy(const vector<vector<int>>& preferences, const std::vector<int> lookup_table,int mate, int me)\\n    {\\n        for(int curr_pref = 0; curr_pref < preferences.size(); curr_pref++)\\n        {\\n            if(preferences[me][curr_pref] == lookup_table[me]) break;\\n            \\n            if(preferences[me][curr_pref] == mate) return true;\\n         \\n        }\\n\\n\\n       return false;\\n    }\\n\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        \\n    int num_of_unhappy_friends = 0;\\n    vector<int> match_lookup(n);\\n\\n    // This shows who got paired up with who.\\n    // easily indexed into for later. (inverse lookup table)\\n    for (const auto pair : pairs) {\\n      const int x = pair[0];\\n      const int y = pair[1];\\n      match_lookup[x] = y;\\n      match_lookup[y] = x;\\n    }\\n\\n    // Go over ever persons preferences\\n    for(int  i = 0 ; i < preferences.size(); i++)\\n    {\\n      for(int j = 0 ; j < preferences[0].size(); j++)\\n      {\\n          // if the current element in preferences list \\n          //  has a matching preference in the lookup table\\n          // this friend is not unhappy.\\n          if(preferences[i][j] == match_lookup[i]) break;\\n\\n          // If not then we have to check to see if we are really unhappy.\\n          if(check_if_unhappy(preferences, match_lookup, i, preferences[i][j]))\\n          {\\n            num_of_unhappy_friends++;\\n            break;\\n          }\\n\\n      }\\n    }\\n\\n  \\n    return num_of_unhappy_friends;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // Claryfing Questions:\\n    //  If someone is paired with a \\'neutrel\\' friend , is that person still unhappy?\\n    //  Does it make someone happy only if they are paired with their favorite person?\\n    //  What is one person is paired with their favorite person, but that fav person doesnt see\\n    //  the other person as their favorite person.\\n    bool check_if_unhappy(const vector<vector<int>>& preferences, const std::vector<int> lookup_table,int mate, int me)\\n    {\\n        for(int curr_pref = 0; curr_pref < preferences.size(); curr_pref++)\\n        {\\n            if(preferences[me][curr_pref] == lookup_table[me]) break;\\n            \\n            if(preferences[me][curr_pref] == mate) return true;\\n         \\n        }\\n\\n\\n       return false;\\n    }\\n\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        \\n    int num_of_unhappy_friends = 0;\\n    vector<int> match_lookup(n);\\n\\n    // This shows who got paired up with who.\\n    // easily indexed into for later. (inverse lookup table)\\n    for (const auto pair : pairs) {\\n      const int x = pair[0];\\n      const int y = pair[1];\\n      match_lookup[x] = y;\\n      match_lookup[y] = x;\\n    }\\n\\n    // Go over ever persons preferences\\n    for(int  i = 0 ; i < preferences.size(); i++)\\n    {\\n      for(int j = 0 ; j < preferences[0].size(); j++)\\n      {\\n          // if the current element in preferences list \\n          //  has a matching preference in the lookup table\\n          // this friend is not unhappy.\\n          if(preferences[i][j] == match_lookup[i]) break;\\n\\n          // If not then we have to check to see if we are really unhappy.\\n          if(check_if_unhappy(preferences, match_lookup, i, preferences[i][j]))\\n          {\\n            num_of_unhappy_friends++;\\n            break;\\n          }\\n\\n      }\\n    }\\n\\n  \\n    return num_of_unhappy_friends;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017640,
                "title": "c-beats-95-n-2-solution-tough-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    // Claryfing Questions:\\n    //  If someone is paired with a \\'neutrel\\' friend , is that person still unhappy?\\n    //  Does it make someone happy only if they are paired with their favorite person?\\n    //  What is one person is paired with their favorite person, but that fav person doesnt see\\n    //  the other person as their favorite person.\\n    bool check_if_unhappy(const vector<vector<int>>& preferences, const std::vector<int> lookup_table,int mate, int me)\\n    {\\n        for(int curr_pref = 0; curr_pref < preferences.size(); curr_pref++)\\n        {\\n            if(preferences[me][curr_pref] == lookup_table[me]) break;\\n            \\n            if(preferences[me][curr_pref] == mate) return true;\\n         \\n        }\\n\\n\\n       return false;\\n    }\\n\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        \\n    int num_of_unhappy_friends = 0;\\n    vector<int> match_lookup(n);\\n\\n    // This shows who got paired up with who.\\n    // easily indexed into for later. (inverse lookup table)\\n    for (const auto pair : pairs) {\\n      const int x = pair[0];\\n      const int y = pair[1];\\n      match_lookup[x] = y;\\n      match_lookup[y] = x;\\n    }\\n\\n    // Go over ever persons preferences\\n    for(int  i = 0 ; i < preferences.size(); i++)\\n    {\\n      for(int j = 0 ; j < preferences[0].size(); j++)\\n      {\\n          // if the current element in preferences list \\n          //  has a matching preference in the lookup table\\n          // this friend is not unhappy.\\n          if(preferences[i][j] == match_lookup[i]) break;\\n\\n          // If not then we have to check to see if we are really unhappy.\\n          if(check_if_unhappy(preferences, match_lookup, i, preferences[i][j]))\\n          {\\n            num_of_unhappy_friends++;\\n            break;\\n          }\\n\\n      }\\n    }\\n\\n  \\n    return num_of_unhappy_friends;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // Claryfing Questions:\\n    //  If someone is paired with a \\'neutrel\\' friend , is that person still unhappy?\\n    //  Does it make someone happy only if they are paired with their favorite person?\\n    //  What is one person is paired with their favorite person, but that fav person doesnt see\\n    //  the other person as their favorite person.\\n    bool check_if_unhappy(const vector<vector<int>>& preferences, const std::vector<int> lookup_table,int mate, int me)\\n    {\\n        for(int curr_pref = 0; curr_pref < preferences.size(); curr_pref++)\\n        {\\n            if(preferences[me][curr_pref] == lookup_table[me]) break;\\n            \\n            if(preferences[me][curr_pref] == mate) return true;\\n         \\n        }\\n\\n\\n       return false;\\n    }\\n\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        \\n    int num_of_unhappy_friends = 0;\\n    vector<int> match_lookup(n);\\n\\n    // This shows who got paired up with who.\\n    // easily indexed into for later. (inverse lookup table)\\n    for (const auto pair : pairs) {\\n      const int x = pair[0];\\n      const int y = pair[1];\\n      match_lookup[x] = y;\\n      match_lookup[y] = x;\\n    }\\n\\n    // Go over ever persons preferences\\n    for(int  i = 0 ; i < preferences.size(); i++)\\n    {\\n      for(int j = 0 ; j < preferences[0].size(); j++)\\n      {\\n          // if the current element in preferences list \\n          //  has a matching preference in the lookup table\\n          // this friend is not unhappy.\\n          if(preferences[i][j] == match_lookup[i]) break;\\n\\n          // If not then we have to check to see if we are really unhappy.\\n          if(check_if_unhappy(preferences, match_lookup, i, preferences[i][j]))\\n          {\\n            num_of_unhappy_friends++;\\n            break;\\n          }\\n\\n      }\\n    }\\n\\n  \\n    return num_of_unhappy_friends;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2972055,
                "title": "python-3-beats-88-n-2-ish",
                "content": "\\n```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n\\n        #Mark preferce of parters #O(n^2)\\n        prefs = {}\\n        for pair in pairs: #O(n)\\n            #find index/pref of partner; O(n)\\n            x = pair[0]\\n            y = pair[1]\\n\\n            xpref = preferences[x].index(y)\\n            ypref = preferences[y].index(x)\\n            #Save prefence of partner\\n            #Save all freinds with a higher prefrence than partner\\n            prefs[x] = (xpref,  preferences[x][:xpref])\\n            prefs[y] = (ypref, preferences[y][:ypref])\\n\\n\\n        #Sort highest first (meaning the most dissatisfied are first) #O(Nlogn)\\n        prefs = dict(sorted(prefs.items(), reverse=True,  key=lambda item: item[1][0])) \\n\\n        #list of friends from most to least disasisfied\\n        unclassified = list(map(lambda x: x[0], prefs.items()))\\n        unhappy = set({})\\n\\n        #repeat until all freinds are classified #O(n^3)\\n        while len(unclassified)>0: #O(n)\\n            x = unclassified[0]\\n            search = prefs[x][1]\\n            xpref = prefs[x][0]\\n            # for each friend that is higher ranking than current partner\\n            for y in search: #O(n)\\n                ypref = prefs[y][0]\\n                ysearch = prefs[y][1]\\n            # if x is also higher ranking than current partner both are unhappy\\n                if x in ysearch: #O(n)\\n                    unhappy.add(x)\\n                    unhappy.add(y)\\n                    if y in unclassified: #O(n)\\n                        unclassified.remove(y)\\n            unclassified.remove(x)\\n        return len(unhappy)\\n                \\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n\\n        #Mark preferce of parters #O(n^2)\\n        prefs = {}\\n        for pair in pairs: #O(n)\\n            #find index/pref of partner; O(n)\\n            x = pair[0]\\n            y = pair[1]\\n\\n            xpref = preferences[x].index(y)\\n            ypref = preferences[y].index(x)\\n            #Save prefence of partner\\n            #Save all freinds with a higher prefrence than partner\\n            prefs[x] = (xpref,  preferences[x][:xpref])\\n            prefs[y] = (ypref, preferences[y][:ypref])\\n\\n\\n        #Sort highest first (meaning the most dissatisfied are first) #O(Nlogn)\\n        prefs = dict(sorted(prefs.items(), reverse=True,  key=lambda item: item[1][0])) \\n\\n        #list of friends from most to least disasisfied\\n        unclassified = list(map(lambda x: x[0], prefs.items()))\\n        unhappy = set({})\\n\\n        #repeat until all freinds are classified #O(n^3)\\n        while len(unclassified)>0: #O(n)\\n            x = unclassified[0]\\n            search = prefs[x][1]\\n            xpref = prefs[x][0]\\n            # for each friend that is higher ranking than current partner\\n            for y in search: #O(n)\\n                ypref = prefs[y][0]\\n                ysearch = prefs[y][1]\\n            # if x is also higher ranking than current partner both are unhappy\\n                if x in ysearch: #O(n)\\n                    unhappy.add(x)\\n                    unhappy.add(y)\\n                    if y in unclassified: #O(n)\\n                        unclassified.remove(y)\\n            unclassified.remove(x)\\n        return len(unhappy)\\n                \\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2943733,
                "title": "c-solution-straightforward-and-readable",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    std::vector<int> GetHappier(vector<int> &pref, int paired) {\\n        return {pref.begin(), std::find(pref.begin(), pref.end(), paired)};\\n    }\\n\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n\\n        int nFriends = preferences.size();\\n\\n        int countUnhappy = 0;\\n\\n        vector<int> mHappier[nFriends];\\n\\n        // Identify and limit to preferences that would make each friend happier\\n        for( auto pair : pairs) { \\n            int p1 = pair.at(0), p2 = pair.at(1);\\n\\n            mHappier[p1] = GetHappier(preferences.at(p1), p2);\\n            mHappier[p2] = GetHappier(preferences.at(p2), p1);\\n        }\\n\\n        // For each friend, see if other friend also would prefer this friend\\n        for( int i = 0; i < nFriends; ++i) {\\n            for( int &o : mHappier[i]){\\n                auto &other = mHappier[o];\\n                if( std::find(other.begin(), other.end(), i) != other.end() ) {\\n                    ++countUnhappy;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return countUnhappy;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    std::vector<int> GetHappier(vector<int> &pref, int paired) {\\n        return {pref.begin(), std::find(pref.begin(), pref.end(), paired)};\\n    }\\n\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n\\n        int nFriends = preferences.size();\\n\\n        int countUnhappy = 0;\\n\\n        vector<int> mHappier[nFriends];\\n\\n        // Identify and limit to preferences that would make each friend happier\\n        for( auto pair : pairs) { \\n            int p1 = pair.at(0), p2 = pair.at(1);\\n\\n            mHappier[p1] = GetHappier(preferences.at(p1), p2);\\n            mHappier[p2] = GetHappier(preferences.at(p2), p1);\\n        }\\n\\n        // For each friend, see if other friend also would prefer this friend\\n        for( int i = 0; i < nFriends; ++i) {\\n            for( int &o : mHappier[i]){\\n                auto &other = mHappier[o];\\n                if( std::find(other.begin(), other.end(), i) != other.end() ) {\\n                    ++countUnhappy;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return countUnhappy;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2880611,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        d = [defaultdict(lambda:float(\\'inf\\')) for _ in range(n)]\\n        for i in range(n):\\n            for k, j in enumerate(preferences[i]):\\n                d[i][j] = k\\n        def prefer(c, a, b):\\n            return d[c][a] < d[c][b]\\n        res = 0\\n        for x,y in pairs:\\n            for u,v in pairs:\\n                if prefer(x, u, y) and prefer(u, x, v) or prefer(x, v, y) and prefer(v, x, u):\\n                    res += 1\\n                    break\\n            for u,v in pairs:\\n                if prefer(y, v, x) and prefer(v, y, u) or prefer(y, u, x) and prefer(u, y, v):\\n                    res += 1\\n                    break\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        d = [defaultdict(lambda:float(\\'inf\\')) for _ in range(n)]\\n        for i in range(n):\\n            for k, j in enumerate(preferences[i]):\\n                d[i][j] = k\\n        def prefer(c, a, b):\\n            return d[c][a] < d[c][b]\\n        res = 0\\n        for x,y in pairs:\\n            for u,v in pairs:\\n                if prefer(x, u, y) and prefer(u, x, v) or prefer(x, v, y) and prefer(v, x, u):\\n                    res += 1\\n                    break\\n            for u,v in pairs:\\n                if prefer(y, v, x) and prefer(v, y, u) or prefer(y, u, x) and prefer(u, y, v):\\n                    res += 1\\n                    break\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2871115,
                "title": "java-solution-a-funny-explanation-of-the-problem",
                "content": "A funny explanation of the problem: \\n\\nHow to decide the happiness of yourself and your pair:\\n\\nIf you end up with your best friend as your partner, you are happy, end of story. \\n\\nIf not, your current partner is not your best friend, you then go exam what other possible partner you can have.\\nYou go through your preference list [f1, f2, f3, f4, f5...]. You want f1, but f1 don\\'t want you, she has a partner better than you (earlier in her preference list); then you check f2, f2 don\\'t want you too... finally, you either find someone prefer you better than her current partner then be unhappy; or you find your current partner is your best choice and be happy.\\n\\nYour partner do the same exam for her preference list. \\n\\n```\\n//O(nn), O(n)\\nclass Solution {\\n    Map<Integer, Integer> partner = null;\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        Set<Integer> unhappy = new HashSet<>();\\n        partner = new HashMap<>();\\n        for(int[] pair : pairs) {\\n            partner.put(pair[0], pair[1]);\\n            partner.put(pair[1], pair[0]);\\n        }\\n        \\n        for(int[] pair : pairs) {\\n            int a = pair[0];\\n            int b = pair[1];\\n            \\n            if(!isHappy(preferences, a, b)) {\\n                unhappy.add(a);\\n            }\\n            \\n            if(!isHappy(preferences, b, a)) {\\n                unhappy.add(b);\\n            }\\n        }\\n        return unhappy.size();\\n        \\n    }\\n    \\n    boolean isHappy(int[][] preferences, int a, int b) {\\n        int bestFriend = preferences[a][0];\\n        if(bestFriend != b) {\\n            for(int lover : preferences[a]) {\\n                if(lover == b) {\\n                    return true;\\n                } \\n                if(!isLoverHappy(preferences[lover], a, partner.get(lover))) {\\n                    return false;\\n                } \\n            }\\n        }\\n        return true;\\n    }\\n    \\n    boolean isLoverHappy(int[] pref, int me, int he) {\\n        for(int friend : pref) {\\n            if(friend == me) {\\n                return false;\\n            }\\n            if(friend == he) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n//O(nn), O(n)\\nclass Solution {\\n    Map<Integer, Integer> partner = null;\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        Set<Integer> unhappy = new HashSet<>();\\n        partner = new HashMap<>();\\n        for(int[] pair : pairs) {\\n            partner.put(pair[0], pair[1]);\\n            partner.put(pair[1], pair[0]);\\n        }\\n        \\n        for(int[] pair : pairs) {\\n            int a = pair[0];\\n            int b = pair[1];\\n            \\n            if(!isHappy(preferences, a, b)) {\\n                unhappy.add(a);\\n            }\\n            \\n            if(!isHappy(preferences, b, a)) {\\n                unhappy.add(b);\\n            }\\n        }\\n        return unhappy.size();\\n        \\n    }\\n    \\n    boolean isHappy(int[][] preferences, int a, int b) {\\n        int bestFriend = preferences[a][0];\\n        if(bestFriend != b) {\\n            for(int lover : preferences[a]) {\\n                if(lover == b) {\\n                    return true;\\n                } \\n                if(!isLoverHappy(preferences[lover], a, partner.get(lover))) {\\n                    return false;\\n                } \\n            }\\n        }\\n        return true;\\n    }\\n    \\n    boolean isLoverHappy(int[] pref, int me, int he) {\\n        for(int friend : pref) {\\n            if(friend == me) {\\n                return false;\\n            }\\n            if(friend == he) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2867840,
                "title": "daily-leetcode-challenge-day-28",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    thoughts:\\n    the questions is not very clear, \\n    We have a bunch of people here, and the preferences[i] tells\\n    me who this i-th person connected, and its in order of \\n    preference.\\n    [[friend_2_idx, firend_3_idx...], [friend_1_idx,...],...]\\n        ^                                 ^\\n    friend_1\\'s circle,                  friend_2\\'s circle\\n    And since we all have our own preferences, their might be\\n    unhappiness between friends because\\n    firend1 and friend_2 are pairs, while friend_10, and friend_5\\n    are pairs\\n    that firend_1 prefers firend_10 over friend_2\\n    while firend_10 prefers friend_1 over friend_5\\n    Oh ok it feels like a relationship problem.\\n    since it sounds like a graph of paired ones and we need to \\n    visit all of their connected nodes. I want to create \\n    it with a adj_list using dictionary.\\n\\n    Then we put in the preference order for the paired ones\\n    So later when we compare we can have direct access.\\n    preference_map[i][j] means the preference order of i toward j\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        \"\"\"\\n        \\n        \"\"\"\\n        adj = {}\\n        for i, j in pairs:\\n            adj[i] = j\\n            adj[j] = i\\n        preference_map = [[0] * n for _ in range(n)]\\n        for i in range(n):\\n            k = n\\n            for j in range(len(preferences[i])):\\n                preference_map[i][preferences[i][j]] = k; \\n                k -= 1   # k-th order of preference (highest preference on the left, lowest preference on the right)\\n        count = 0\\n        for i in range(n):\\n            for j in range(n):\\n                if i == j:\\n                    continue\\n                if preference_map[i][j] > preference_map[i][adj[i]] and preference_map[j][i] > preference_map[j][adj[j]]:  # i prefers j over i\\'s adjacent pair and j prefers i over j\\'s adjacent pair\\n                    count += 1\\n                    break                      # \\\\U0001f3af i-th unhappy friend found\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        \"\"\"\\n        \\n        \"\"\"\\n        adj = {}\\n        for i, j in pairs:\\n            adj[i] = j\\n            adj[j] = i\\n        preference_map = [[0] * n for _ in range(n)]\\n        for i in range(n):\\n            k = n\\n            for j in range(len(preferences[i])):\\n                preference_map[i][preferences[i][j]] = k; \\n                k -= 1   # k-th order of preference (highest preference on the left, lowest preference on the right)\\n        count = 0\\n        for i in range(n):\\n            for j in range(n):\\n                if i == j:\\n                    continue\\n                if preference_map[i][j] > preference_map[i][adj[i]] and preference_map[j][i] > preference_map[j][adj[j]]:  # i prefers j over i\\'s adjacent pair and j prefers i over j\\'s adjacent pair\\n                    count += 1\\n                    break                      # \\\\U0001f3af i-th unhappy friend found\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2867248,
                "title": "c-brute-force-friend-checks",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    //returns true if the you does not have pairing as preferred\\n    bool check(int n, vector<vector<int>>& preferences, vector<int> pairMap, int f, int you){\\n        for(int j=0; j < n-1; j++){\\n\\n            if(preferences[you][j] == pairMap[you])\\n                break;\\n            \\n             if(preferences[you][j] == f)\\n                return true;\\n        }\\n\\n        return false;\\n    }\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        int unhappy = 0;\\n        \\n        vector<int> pairMap(n, -1); //pairing map\\n        for(auto p: pairs){\\n            pairMap[p[0]] = p[1];\\n            pairMap[p[1]] = p[0];\\n        }\\n\\n        //loop over each person and within .. loop over the preferences\\n        //In each case until the preference is not pairing, then check the same for the pairing\\n        //In check, we see if the pairing has same situation as this friend.\\n        for(int i=0; i < n; ++i){\\n\\n            for(int j=0; j < n-1; j++){\\n\\n                if(preferences[i][j] == pairMap[i])\\n                    break;\\n\\n                if(check(n, preferences, pairMap, i, preferences[i][j])){\\n                    unhappy++;\\n                    break;\\n                }\\n            }\\n\\n\\n        }\\n       \\n        \\n\\n        return unhappy;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\n    //returns true if the you does not have pairing as preferred\\n    bool check(int n, vector<vector<int>>& preferences, vector<int> pairMap, int f, int you){\\n        for(int j=0; j < n-1; j++){\\n\\n            if(preferences[you][j] == pairMap[you])\\n                break;\\n            \\n             if(preferences[you][j] == f)\\n                return true;\\n        }\\n\\n        return false;\\n    }\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        int unhappy = 0;\\n        \\n        vector<int> pairMap(n, -1); //pairing map\\n        for(auto p: pairs){\\n            pairMap[p[0]] = p[1];\\n            pairMap[p[1]] = p[0];\\n        }\\n\\n        //loop over each person and within .. loop over the preferences\\n        //In each case until the preference is not pairing, then check the same for the pairing\\n        //In check, we see if the pairing has same situation as this friend.\\n        for(int i=0; i < n; ++i){\\n\\n            for(int j=0; j < n-1; j++){\\n\\n                if(preferences[i][j] == pairMap[i])\\n                    break;\\n\\n                if(check(n, preferences, pairMap, i, preferences[i][j])){\\n                    unhappy++;\\n                    break;\\n                }\\n            }\\n\\n\\n        }\\n       \\n        \\n\\n        return unhappy;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851864,
                "title": "python-solution-o-n2",
                "content": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        hashmap = {}\\n        for pair in pairs:\\n            person_one = pair[0]\\n            person_two = pair[1]\\n            pref_one = preferences[person_one]\\n            i = 0\\n            person_one_preferee = []\\n            while i < len(pref_one) and pref_one[i] != person_two:\\n                person_one_preferee.append(pref_one[i])\\n                i += 1\\n            hashmap[person_one] = person_one_preferee\\n            \\n            pref_two = preferences[person_two]\\n            i = 0\\n            person_two_preferee = []\\n            while i < len(pref_two) and pref_two[i] != person_one:\\n                person_two_preferee.append(pref_two[i])\\n                i += 1\\n            hashmap[person_two] = person_two_preferee\\n        print(hashmap)\\n        \\n        count = 0\\n        for person, preferee_list in hashmap.items():\\n            for preferee in preferee_list:\\n                if person in hashmap[preferee]:\\n                    count += 1\\n                    break\\n        return count",
                "solutionTags": [],
                "code": "class Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        hashmap = {}",
                "codeTag": "Java"
            },
            {
                "id": 2851810,
                "title": "golang-map-better-candidates-and-check-condition",
                "content": "```go\\nfunc unhappyFriends(n int, preferences [][]int, pairs [][]int) int {\\n  // Let\\'s make a pair map for easier access of pairs\\n  pairMap := make(map[int]int)\\n  for _, pair := range pairs {\\n    pairMap[pair[0]] = pair[1]\\n    pairMap[pair[1]] = pair[0]\\n  }\\n  // Let\\'s compute the better candidates for each person than their current pair\\n  better := make([]map[int]bool, n)\\n  for i := 0; i < n; i++ {\\n    better[i] = make(map[int]bool)\\n    for j := 0; j < len(preferences[i]) && preferences[i][j] != pairMap[i]; j++ {\\n      better[i][preferences[i][j]] = true\\n    }\\n  }\\n  var res int\\n  // Now we\\'ll go through everyone and find if any of them are unhappy\\n  for i := 0; i < n; i++ {\\n    for b := range better[i] {\\n      // i prefers b over his current pair and b prefers i over his current pair\\n      if better[b][i] {\\n        res++\\n        break\\n      }     \\n    }\\n  }\\n  return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc unhappyFriends(n int, preferences [][]int, pairs [][]int) int {\\n  // Let\\'s make a pair map for easier access of pairs\\n  pairMap := make(map[int]int)\\n  for _, pair := range pairs {\\n    pairMap[pair[0]] = pair[1]\\n    pairMap[pair[1]] = pair[0]\\n  }\\n  // Let\\'s compute the better candidates for each person than their current pair\\n  better := make([]map[int]bool, n)\\n  for i := 0; i < n; i++ {\\n    better[i] = make(map[int]bool)\\n    for j := 0; j < len(preferences[i]) && preferences[i][j] != pairMap[i]; j++ {\\n      better[i][preferences[i][j]] = true\\n    }\\n  }\\n  var res int\\n  // Now we\\'ll go through everyone and find if any of them are unhappy\\n  for i := 0; i < n; i++ {\\n    for b := range better[i] {\\n      // i prefers b over his current pair and b prefers i over his current pair\\n      if better[b][i] {\\n        res++\\n        break\\n      }     \\n    }\\n  }\\n  return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2845736,
                "title": "python-o-n-3-follow-the-rules-word-by-word",
                "content": "# Intuition\\nThere is a O(n^2) solution but I want to show this intuitive O(n^3) solution by just following the rules stated in the question.\\n# Approach\\nCreate a dictionary of pairs for easy lookup. Then follow the question logic word by word.\\n# Complexity\\n- Time complexity:\\nO(n * m^2) where n is the number of people and m is the max length of betterFriends per person. In otherwords (n^3).\\n\\n- Space complexity:\\nO(n) for the dictionary\\n\\n# Code\\n```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        # iterate through the pairs\\n        # add pairs to d: d[x] = y, d[y] = x\\n        # check each pair x, y in preferences to see if\\n        # for friends in preferences[x][:indexy]:\\n        #    check the condition\\n\\n        pd = {}\\n        for x, y in pairs:\\n            pd[x] = y\\n            pd[y] = x\\n\\n        unhappy = 0\\n        for x in pd.keys():\\n            y = pd[x]\\n            indexy = preferences[x].index(y)\\n            betterFriends = preferences[x][:indexy]\\n\\n            for u in betterFriends:\\n                v = pd[u]\\n                indexv = preferences[u].index(v)\\n\\n                if x in preferences[u][:indexv]:\\n                    unhappy += 1\\n                    break\\n\\n        return unhappy\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        # iterate through the pairs\\n        # add pairs to d: d[x] = y, d[y] = x\\n        # check each pair x, y in preferences to see if\\n        # for friends in preferences[x][:indexy]:\\n        #    check the condition\\n\\n        pd = {}\\n        for x, y in pairs:\\n            pd[x] = y\\n            pd[y] = x\\n\\n        unhappy = 0\\n        for x in pd.keys():\\n            y = pd[x]\\n            indexy = preferences[x].index(y)\\n            betterFriends = preferences[x][:indexy]\\n\\n            for u in betterFriends:\\n                v = pd[u]\\n                indexv = preferences[u].index(v)\\n\\n                if x in preferences[u][:indexv]:\\n                    unhappy += 1\\n                    break\\n\\n        return unhappy\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843519,
                "title": "java-easy-solution-with-a-pair-map-and-array-of-preferences-map",
                "content": "Prepare a pairmap to chek if a value exist as a pair for easy look up. \\nCreate array of maps to store preferences array with their index as key for easy order look up.  \\n```\\npublic int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        Map<Integer, Integer> pairMap = new HashMap<>();\\n        List<Map<Integer, Integer>> preMap = new ArrayList<>();\\n        for(int[] pair: pairs){\\n            pairMap.put(pair[0], pair[1]);\\n            pairMap.put(pair[1], pair[0]);\\n        }\\n        for(int[] pref: preferences){\\n            Map<Integer, Integer> map = new HashMap<>();\\n            for(int i=0;i<pref.length;i++){\\n                map.put(pref[i], i);\\n            }\\n            preMap.add(map);\\n        }\\n        int result = 0;\\n        for(int[] pair : pairs){\\n            int x = pair[0];\\n            int y = pair[1];\\n            \\n            if(preferences[x][0] !=y){\\n                if(unhappy(preferences[x], x,y, pairMap, preMap)) result++;\\n            }\\n            \\n            if(preferences[y][0] !=x){\\n                if(unhappy(preferences[y], y,x, pairMap, preMap)) result++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    boolean unhappy(int[] preference, int x, int y, Map<Integer, Integer> pairMap, List<Map<Integer, Integer>> preMap){\\n        for(int i=0;i<preMap.get(x).get(y);i++){ //3,2\\n            //preference[i] 3,2\\n            //pairMap.get(preference[i] [1,2,0] and [3,1,0]\\n            if(pairMap.containsKey(preference[i])){ // 3, 2\\n                Map<Integer, Integer> temp = preMap.get(preference[i]); //1,2,0\\n                if(temp.containsKey(x) &&\\n                   temp.containsKey(pairMap.get(preference[i])) &&\\n                   temp.get(x)<temp.get(pairMap.get(preference[i]))\\n                  )\\n                \\n                return true;\\n            }  \\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        Map<Integer, Integer> pairMap = new HashMap<>();\\n        List<Map<Integer, Integer>> preMap = new ArrayList<>();\\n        for(int[] pair: pairs){\\n            pairMap.put(pair[0], pair[1]);\\n            pairMap.put(pair[1], pair[0]);\\n        }\\n        for(int[] pref: preferences){\\n            Map<Integer, Integer> map = new HashMap<>();\\n            for(int i=0;i<pref.length;i++){\\n                map.put(pref[i], i);\\n            }\\n            preMap.add(map);\\n        }\\n        int result = 0;\\n        for(int[] pair : pairs){\\n            int x = pair[0];\\n            int y = pair[1];\\n            \\n            if(preferences[x][0] !=y){\\n                if(unhappy(preferences[x], x,y, pairMap, preMap)) result++;\\n            }\\n            \\n            if(preferences[y][0] !=x){\\n                if(unhappy(preferences[y], y,x, pairMap, preMap)) result++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    boolean unhappy(int[] preference, int x, int y, Map<Integer, Integer> pairMap, List<Map<Integer, Integer>> preMap){\\n        for(int i=0;i<preMap.get(x).get(y);i++){ //3,2\\n            //preference[i] 3,2\\n            //pairMap.get(preference[i] [1,2,0] and [3,1,0]\\n            if(pairMap.containsKey(preference[i])){ // 3, 2\\n                Map<Integer, Integer> temp = preMap.get(preference[i]); //1,2,0\\n                if(temp.containsKey(x) &&\\n                   temp.containsKey(pairMap.get(preference[i])) &&\\n                   temp.get(x)<temp.get(pairMap.get(preference[i]))\\n                  )\\n                \\n                return true;\\n            }  \\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2808618,
                "title": "java-solution-easy-to-understand",
                "content": "# Intuition\\nSince n is small, we can use a solution with time complexity of O(n^3) to solve this problem. Therefore, we just need to solve it manually by:\\n- Check if there is any i exisitng such that i stand before y in preferences[x], if not, ignore and check the next one\\n- Check if x stand before iPair (current partner of i) in preferences[u]\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^3)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        HashMap<Integer, Integer> pairMap = new HashMap<>();\\n        for(int[] pair : pairs){\\n            pairMap.put(pair[0], pair[1]);\\n            pairMap.put(pair[1], pair[0]);\\n        }\\n        int result = 0;\\n        for(int[] pair : pairs){\\n            if(isUnhappy(pair[0], pairMap, preferences, n)){\\n                result++;\\n            }\\n            if(isUnhappy(pair[1], pairMap, preferences, n)){\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n    public boolean isUnhappy(int curr, HashMap<Integer, Integer> pairMap, int[][] preferences, int n){\\n        // Condition 1: u stand before y in preferences[x]\\n        // Condition 2: x stand before v in preferecens[u]\\n        int currPair = pairMap.get(curr);\\n        for(int i = 0; i < n; i++){\\n            if(i == curr || i == currPair){\\n                continue;\\n            }\\n            // Consider i, whether or not i stand before currPair\\n            int index1 = -1; //Index of i\\n            int index2 = -1; //Index of currPair\\n            for(int j = 0; j < n - 1; j++){\\n                if(preferences[curr][j] == i){\\n                    index1 = j;\\n                }\\n                if(preferences[curr][j] == currPair){\\n                    index2 = j;\\n                }\\n            }\\n            // There is no other person that curr prefer than the current one\\n            // Curr prefer currPair over i\\n            if(index1 > index2){\\n                continue;\\n            }\\n            // Continue if index1 > index2\\n            // Check if index of curr  > index of iPair\\n            int index3 = -1; //Index of curr\\n            int index4 = -1; //Index of iPair\\n            int iPair = pairMap.get(i);\\n            \\n            for(int j = 0; j < n - 1; j++){\\n                if(preferences[i][j] == curr){\\n                    index3 = j;\\n                }\\n                if(preferences[i][j] == iPair){\\n                    index4 = j;\\n                }\\n            }\\n            // i prefer iPair over curr\\n            if(index3 > index4){\\n                continue;\\n            }\\n            // Found a pair that index3 < index4 && index1 < index2\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        HashMap<Integer, Integer> pairMap = new HashMap<>();\\n        for(int[] pair : pairs){\\n            pairMap.put(pair[0], pair[1]);\\n            pairMap.put(pair[1], pair[0]);\\n        }\\n        int result = 0;\\n        for(int[] pair : pairs){\\n            if(isUnhappy(pair[0], pairMap, preferences, n)){\\n                result++;\\n            }\\n            if(isUnhappy(pair[1], pairMap, preferences, n)){\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n    public boolean isUnhappy(int curr, HashMap<Integer, Integer> pairMap, int[][] preferences, int n){\\n        // Condition 1: u stand before y in preferences[x]\\n        // Condition 2: x stand before v in preferecens[u]\\n        int currPair = pairMap.get(curr);\\n        for(int i = 0; i < n; i++){\\n            if(i == curr || i == currPair){\\n                continue;\\n            }\\n            // Consider i, whether or not i stand before currPair\\n            int index1 = -1; //Index of i\\n            int index2 = -1; //Index of currPair\\n            for(int j = 0; j < n - 1; j++){\\n                if(preferences[curr][j] == i){\\n                    index1 = j;\\n                }\\n                if(preferences[curr][j] == currPair){\\n                    index2 = j;\\n                }\\n            }\\n            // There is no other person that curr prefer than the current one\\n            // Curr prefer currPair over i\\n            if(index1 > index2){\\n                continue;\\n            }\\n            // Continue if index1 > index2\\n            // Check if index of curr  > index of iPair\\n            int index3 = -1; //Index of curr\\n            int index4 = -1; //Index of iPair\\n            int iPair = pairMap.get(i);\\n            \\n            for(int j = 0; j < n - 1; j++){\\n                if(preferences[i][j] == curr){\\n                    index3 = j;\\n                }\\n                if(preferences[i][j] == iPair){\\n                    index4 = j;\\n                }\\n            }\\n            // i prefer iPair over curr\\n            if(index3 > index4){\\n                continue;\\n            }\\n            // Found a pair that index3 < index4 && index1 < index2\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776531,
                "title": "java-with-comments-to-help-the-logic",
                "content": "```\\n\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        \\n        //build given matching from pairs\\n        int matching[] = new int[n];\\n        for (int[] pair : pairs){\\n            matching[pair[0]] = pair[1];\\n            matching[pair[1]] = pair[0];\\n        }\\n        \\n        //mapping preferences to order\\n        int order[][] = new int[n][n];\\n        for (int i = 0; i < n; i++){\\n            for (int j =0; j < n - 1; j++){\\n                // no self preference hence j runs to n -1\\n                int pref = preferences[i][j];\\n                order[i][pref] = j;\\n            }\\n        }\\n        \\n        \\n        int unHappyCount = 0;\\n        \\n        for (int x = 0; x < n; x++){\\n            //get x\\'s match say y\\n            int y = matching[x];\\n            //get x pref to y from order\\n            int idx = order[x][y];\\n            \\n            //for each u before y from x preference list,\\n            \\n            for (int i = 0; i < idx; i++){\\n                int u = preferences[x][i];\\n                //get u\\'s current matching\\n                int v = matching[u];\\n                // check u, v order is higher that u,x order.\\n                // preference with x.\\n                if (order[u][v] > order[u][x]){\\n                    unHappyCount+=1;\\n                    break;\\n                }\\n            }\\n        }\\n        return unHappyCount;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        \\n        //build given matching from pairs\\n        int matching[] = new int[n];\\n        for (int[] pair : pairs){\\n            matching[pair[0]] = pair[1];\\n            matching[pair[1]] = pair[0];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2761202,
                "title": "java-clean-code-w-named-variables-to-represent-friends-i-e-alice-bob",
                "content": "# Code\\n```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int numUnhappy = 0;\\n        HashMap<Integer,int[]> friendMap = new HashMap<>();\\n        HashMap<Integer,Integer> pair = new HashMap<>();\\n        for(int i = 0; i<preferences.length; i++){\\n            int[] rankings = new int[n];\\n            int counter = n;\\n            for(int friend : preferences[i]){\\n                rankings[friend] = counter;\\n                counter--;\\n            }\\n            friendMap.put(i,rankings);\\n        }\\n        for(int[] i : pairs){\\n            pair.put(i[0],i[1]);\\n            pair.put(i[1],i[0]);\\n        }\\n        \\n\\n        //System.out.println(pair.toString());\\n        for(int alice : pair.keySet()){\\n            int bob = pair.get(alice);\\n            int aRateB = friendMap.get(alice)[bob];\\n            for(int eve = 0; eve<friendMap.get(alice).length; eve++){\\n                int aRateE = friendMap.get(alice)[eve];\\n                if(aRateE>aRateB){\\n                    int john = pair.get(eve);\\n                    int eRateJ = friendMap.get(eve)[john];\\n                    int eRateA = friendMap.get(eve)[alice];\\n                    if(eRateA>eRateJ){\\n                        numUnhappy+=1;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return numUnhappy;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int numUnhappy = 0;\\n        HashMap<Integer,int[]> friendMap = new HashMap<>();\\n        HashMap<Integer,Integer> pair = new HashMap<>();\\n        for(int i = 0; i<preferences.length; i++){\\n            int[] rankings = new int[n];\\n            int counter = n;\\n            for(int friend : preferences[i]){\\n                rankings[friend] = counter;\\n                counter--;\\n            }\\n            friendMap.put(i,rankings);\\n        }\\n        for(int[] i : pairs){\\n            pair.put(i[0],i[1]);\\n            pair.put(i[1],i[0]);\\n        }\\n        \\n\\n        //System.out.println(pair.toString());\\n        for(int alice : pair.keySet()){\\n            int bob = pair.get(alice);\\n            int aRateB = friendMap.get(alice)[bob];\\n            for(int eve = 0; eve<friendMap.get(alice).length; eve++){\\n                int aRateE = friendMap.get(alice)[eve];\\n                if(aRateE>aRateB){\\n                    int john = pair.get(eve);\\n                    int eRateJ = friendMap.get(eve)[john];\\n                    int eRateA = friendMap.get(eve)[alice];\\n                    if(eRateA>eRateJ){\\n                        numUnhappy+=1;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return numUnhappy;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2747479,
                "title": "clean-code-python-o-n-2",
                "content": "\\n```\\nclass Solution:\\n    def unhappyFriends(self, n: int, pref: List[List[int]], prs: List[List[int]]) -> int:\\n        \\n        \\n        result = 0\\n        \\n        preferences = defaultdict(list)\\n        pairs = defaultdict(int)\\n        \\n        for index,value in enumerate(pref):\\n            preferences[index] = value\\n            \\n        for a,b in prs:\\n            pairs[a] = b\\n            pairs[b] = a\\n        \\n        for key,value in preferences.items():\\n            \\n            for char in value:\\n                if pairs[key] == char:\\n                    break\\n                    \\n                indexOfKey = preferences[char].index(key)\\n                indexOfPair = preferences[char].index(pairs[char])\\n                \\n                if indexOfPair > indexOfKey:\\n                    result += 1\\n                    break\\n                    \\n        return result\\n```\\nThe above solution is O(N^3),  to replace the O(N) extra time and make it O(N^2) we can just build a hasmap to get the index. (Since it\\'s the .index() functions thats causing the O(N) extra time)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, pref: List[List[int]], prs: List[List[int]]) -> int:\\n        \\n        \\n        result = 0\\n        \\n        preferences = defaultdict(list)\\n        pairs = defaultdict(int)\\n        \\n        for index,value in enumerate(pref):\\n            preferences[index] = value\\n            \\n        for a,b in prs:\\n            pairs[a] = b\\n            pairs[b] = a\\n        \\n        for key,value in preferences.items():\\n            \\n            for char in value:\\n                if pairs[key] == char:\\n                    break\\n                    \\n                indexOfKey = preferences[char].index(key)\\n                indexOfPair = preferences[char].index(pairs[char])\\n                \\n                if indexOfPair > indexOfKey:\\n                    result += 1\\n                    break\\n                    \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2703808,
                "title": "python-solution",
                "content": "```\\ndef unhappyFriends(self, n: int, pres: List[List[int]], pairs: List[List[int]]) -> int:\\n\\tscore, ans = {}, 0\\n\\tfor u,v in pairs:\\n\\t\\ti = pres[u].index(v)\\n\\t\\tscore[u] = set(pres[u][:i])\\n\\t\\ti = pres[v].index(u)\\n\\t\\tscore[v] = set(pres[v][:i])\\n\\tfor u in score:\\n\\t\\tans += any(u in score[v] for v in score[u])\\n\\treturn ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef unhappyFriends(self, n: int, pres: List[List[int]], pairs: List[List[int]]) -> int:\\n\\tscore, ans = {}, 0\\n\\tfor u,v in pairs:\\n\\t\\ti = pres[u].index(v)\\n\\t\\tscore[u] = set(pres[u][:i])\\n\\t\\ti = pres[v].index(u)\\n\\t\\tscore[v] = set(pres[v][:i])\\n\\tfor u in score:\\n\\t\\tans += any(u in score[v] for v in score[u])\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2697873,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn unhappy_friends(n: i32, preferences: Vec<Vec<i32>>, pairs: Vec<Vec<i32>>) -> i32 {\\n        let n = n as usize;    \\n        let mut memo = vec![0;n];\\n        for arr in &pairs {\\n            let a = arr[0] as usize;\\n            let b = arr[1] as usize;\\n            memo[a] = b;\\n            memo[b] = a;\\n        }\\n\\n        let mut result = 0;\\n        for arr in pairs {\\n            let a = arr[0] as usize;\\n            let b = arr[1] as usize;\\n            \\n            let mut flag = false;\\n            for &u in &preferences[a] {\\n                let u = u as usize;\\n                if u == b { break }\\n\\n                let v = memo[u];\\n                for &candidate in &preferences[u] {\\n                    let candidate = candidate as usize;\\n                    if candidate == a {\\n                        flag = true;\\n                        break\\n                    } else if candidate == v {\\n                        break\\n                    }\\n                }\\n\\n                if flag {\\n                    result += 1;\\n                    break\\n                }\\n            }\\n\\n            let mut flag = false;\\n            for &u in &preferences[b] {\\n                let u = u as usize;\\n                if u == a { break }\\n\\n                let v = memo[u];\\n                for &candidate in &preferences[u] {\\n                    let candidate = candidate as usize;\\n                    if candidate == b {\\n                        flag = true;\\n                        break\\n                    } else if candidate == v {\\n                        break\\n                    }\\n                }\\n\\n                if flag {\\n                    result += 1;\\n                    break\\n                }\\n            }\\n        }\\n        result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn unhappy_friends(n: i32, preferences: Vec<Vec<i32>>, pairs: Vec<Vec<i32>>) -> i32 {\\n        let n = n as usize;    \\n        let mut memo = vec![0;n];\\n        for arr in &pairs {\\n            let a = arr[0] as usize;\\n            let b = arr[1] as usize;\\n            memo[a] = b;\\n            memo[b] = a;\\n        }\\n\\n        let mut result = 0;\\n        for arr in pairs {\\n            let a = arr[0] as usize;\\n            let b = arr[1] as usize;\\n            \\n            let mut flag = false;\\n            for &u in &preferences[a] {\\n                let u = u as usize;\\n                if u == b { break }\\n\\n                let v = memo[u];\\n                for &candidate in &preferences[u] {\\n                    let candidate = candidate as usize;\\n                    if candidate == a {\\n                        flag = true;\\n                        break\\n                    } else if candidate == v {\\n                        break\\n                    }\\n                }\\n\\n                if flag {\\n                    result += 1;\\n                    break\\n                }\\n            }\\n\\n            let mut flag = false;\\n            for &u in &preferences[b] {\\n                let u = u as usize;\\n                if u == a { break }\\n\\n                let v = memo[u];\\n                for &candidate in &preferences[u] {\\n                    let candidate = candidate as usize;\\n                    if candidate == b {\\n                        flag = true;\\n                        break\\n                    } else if candidate == v {\\n                        break\\n                    }\\n                }\\n\\n                if flag {\\n                    result += 1;\\n                    break\\n                }\\n            }\\n        }\\n        result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2687726,
                "title": "python-easy-explanantion",
                "content": "Reference to `@rahulanandydav2000` with more explanation.\\n```\\n\"\"\"\\nfriend have a preferece:\\n0 : 1,2,3\\n1 : 3,2,0\\n2 : 3,1,0\\n3 : 1,2,0\\n\\npairs = [[0, 1], [2, 3]]\\n0 is happy, because 1 is the first preferece\\n1 is unhappy, because 3 is its prior preference, and 3 is also unhappy because 1 is its preferece\\n\\nAlgorithm:\\n    -> for each, we should check wehther they have a prior preference than the current pair\\n    -> if yes, then what they are? \\n        use a dictionary:\\n        {\\n            0: []\\n            1: [3]\\n            2: []\\n            3: [1]\\n        }\\n    -> then we start the iteration, for each key, if the key appear in the dict[value],\\n        which suggest, the key and the value all have an another prefered choice, then we should\\n        add the result by 1\\n    -> retutn res\\n\"\"\"\\n\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        # check whether there is a prior preference\\n        prior_preference = {}\\n        for p1, p2 in pairs:\\n            prior_preference[p1] = preferences[p1][:preferences[p1].index(p2)]\\n            prior_preference[p2] = preferences[p2][:preferences[p2].index(p1)]\\n        # start the iteration:\\n        res = 0\\n        for p1 in prior_preference:\\n            for p2 in prior_preference[p1]:\\n                if p1 in prior_preference[p2]:\\n                    res += 1\\n                    break\\n        return res\\n        \\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\"\"\"\\nfriend have a preferece:\\n0 : 1,2,3\\n1 : 3,2,0\\n2 : 3,1,0\\n3 : 1,2,0\\n\\npairs = [[0, 1], [2, 3]]\\n0 is happy, because 1 is the first preferece\\n1 is unhappy, because 3 is its prior preference, and 3 is also unhappy because 1 is its preferece\\n\\nAlgorithm:\\n    -> for each, we should check wehther they have a prior preference than the current pair\\n    -> if yes, then what they are? \\n        use a dictionary:\\n        {\\n            0: []\\n            1: [3]\\n            2: []\\n            3: [1]\\n        }\\n    -> then we start the iteration, for each key, if the key appear in the dict[value],\\n        which suggest, the key and the value all have an another prefered choice, then we should\\n        add the result by 1\\n    -> retutn res\\n\"\"\"\\n\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        # check whether there is a prior preference\\n        prior_preference = {}\\n        for p1, p2 in pairs:\\n            prior_preference[p1] = preferences[p1][:preferences[p1].index(p2)]\\n            prior_preference[p2] = preferences[p2][:preferences[p2].index(p1)]\\n        # start the iteration:\\n        res = 0\\n        for p1 in prior_preference:\\n            for p2 in prior_preference[p1]:\\n                if p1 in prior_preference[p2]:\\n                    res += 1\\n                    break\\n        return res\\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2625036,
                "title": "",
                "content": "x prefers u over y, and\\nu prefers x over v.\\n\\n\\u5927\\u610F\\u5C31\\u662F\\uFF1A\\nx \\u6CA1 pair \\u5230\\u4ED6\\u4F18\\u5148\\u60F3 pair \\u7684 (x \\u5374 pair \\u5230\\u4E86\\u4E0D\\u4F18\\u5148\\u7684)\\nx \\u4F18\\u5148\\u60F3 pair \\u7684\\u4E5F pair\\u4E86\\u6BD4 x \\u5DEE\\u7684\\n\\nx \\u5F88\\u96BE\\u53D7\\uFF0C\\u56E0\\u4E3A x \\u7231\\u7684 u \\u6CA1\\u548C\\u4ED6 pair\\nu \\u4E5F\\u5F88\\u96BE\\u53D7\\uFF0C\\u56E0\\u4E3A u \\u60F3\\u548C x pair\\uFF0C\\u4F46\\u5374\\u548C v pair\\u4E86\\n\\n\\u6240\\u4EE5 x \\u4E0D\\u9AD8\\u5174\\n```\\nif orders[x][u] < orders[x][y] && orders[u][x] < orders[u][v]\\nthen x is unhappy\\norders[i][j] \\u4EE3\\u8868i\\u5BF9j\\u7684prefer\\u7A0B\\u5EA6\\uFF08\\u8D8A\\u5C0F\\u8D8Aprefer\\uFF09\\n```\\n",
                "solutionTags": [],
                "code": "```\\nif orders[x][u] < orders[x][y] && orders[u][x] < orders[u][v]\\nthen x is unhappy\\norders[i][j] \\u4EE3\\u8868i\\u5BF9j\\u7684prefer\\u7A0B\\u5EA6\\uFF08\\u8D8A\\u5C0F\\u8D8Aprefer\\uFF09\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2580540,
                "title": "why-so-many-dislikes-c-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& p, vector<vector<int>>& pairs) {\\n        \\n        vector<vector<int>> rev(n,vector<int>(n,-1));\\n        \\n        for(int i=0;i<p.size();i++)\\n        {\\n            for(int j=0;j<p[i].size();j++)\\n            {\\n                rev[i][p[i][j]]=j;\\n            }\\n        }\\n        \\n        unordered_set<int> unhappy;\\n        \\n        int res=0;\\n        for(int i=0;i<pairs.size();i++)\\n        {\\n            int x=pairs[i][0];\\n            int y=pairs[i][1];\\n            \\n            for(int j=0;j<pairs.size();j++)\\n            {\\n                if(i==j)\\n                    continue;\\n            \\n                int u=pairs[j][0];\\n                int v=pairs[j][1];\\n                \\n                //Assume x is unhappy \\n                    \\n                if(rev[x][u]<rev[x][y] && rev[u][x] < rev[u][v]  || rev[x][v]<rev[x][y] && rev[v][x]<rev[v][u])\\n                   unhappy.insert(x);\\n                \\n                 if(rev[y][u]<rev[y][x] && rev[u][y] < rev[u][v]  || rev[y][v]<rev[y][x] && rev[v][y]<rev[v][u])\\n                   unhappy.insert(y);\\n                    \\n                \\n            }\\n        }\\n        \\n        return unhappy.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& p, vector<vector<int>>& pairs) {\\n        \\n        vector<vector<int>> rev(n,vector<int>(n,-1));\\n        \\n        for(int i=0;i<p.size();i++)\\n        {\\n            for(int j=0;j<p[i].size();j++)\\n            {\\n                rev[i][p[i][j]]=j;\\n            }\\n        }\\n        \\n        unordered_set<int> unhappy;\\n        \\n        int res=0;\\n        for(int i=0;i<pairs.size();i++)\\n        {\\n            int x=pairs[i][0];\\n            int y=pairs[i][1];\\n            \\n            for(int j=0;j<pairs.size();j++)\\n            {\\n                if(i==j)\\n                    continue;\\n            \\n                int u=pairs[j][0];\\n                int v=pairs[j][1];\\n                \\n                //Assume x is unhappy \\n                    \\n                if(rev[x][u]<rev[x][y] && rev[u][x] < rev[u][v]  || rev[x][v]<rev[x][y] && rev[v][x]<rev[v][u])\\n                   unhappy.insert(x);\\n                \\n                 if(rev[y][u]<rev[y][x] && rev[u][y] < rev[u][v]  || rev[y][v]<rev[y][x] && rev[v][y]<rev[v][u])\\n                   unhappy.insert(y);\\n                    \\n                \\n            }\\n        }\\n        \\n        return unhappy.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2562780,
                "title": "java-solution-faster-than-97-with-less-memory-usage",
                "content": "\\n```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int count = 0;\\n        int[] pairArr = new int[n];\\n        int[] prefPriority = new int[n];\\n        // make candidate and its pair\\n        for (int[] pair : pairs){\\n            pairArr[pair[0]] = pair[1];\\n            pairArr[pair[1]] = pair[0];\\n        }\\n        \\n        for (int currCandidate = 0; currCandidate < n; currCandidate++){\\n            int[] candidatePref = preferences[currCandidate];\\n            prefPriority[currCandidate] = findPriority(candidatePref, pairArr[currCandidate]);\\n        }\\n        \\n        for (int i = 0; i < n; i++){\\n            if (prefPriority[i] > 0 && candidateIsUnhappy(preferences, i, prefPriority[i], prefPriority)){\\n                count++;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n    public int findPriority (int[] candidatePref, int candidate){\\n\\n        for (int i = 0; i < candidatePref.length - 1; i++){\\n            if (candidatePref[i] == candidate){\\n                return i;\\n            }\\n        }\\n        return candidatePref.length - 1;\\n    }\\n    // those who enter this check are potentially unhappy\\n    public boolean candidateIsUnhappy(int[][] preferences, int candidate, int priority, int[] prefPriority){\\n        int[] candidatePref = preferences[candidate];\\n        for (int i = 0; i < priority; i++){\\n            int checkCandidate = candidatePref[i];\\n            // if checkCandidate is matched with less preferred candidate, means both candidates are unhappy, return true\\n            if (findPriority(preferences[checkCandidate], candidate) < prefPriority[checkCandidate]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int count = 0;\\n        int[] pairArr = new int[n];\\n        int[] prefPriority = new int[n];\\n        // make candidate and its pair\\n        for (int[] pair : pairs){\\n            pairArr[pair[0]] = pair[1];\\n            pairArr[pair[1]] = pair[0];\\n        }\\n        \\n        for (int currCandidate = 0; currCandidate < n; currCandidate++){\\n            int[] candidatePref = preferences[currCandidate];\\n            prefPriority[currCandidate] = findPriority(candidatePref, pairArr[currCandidate]);\\n        }\\n        \\n        for (int i = 0; i < n; i++){\\n            if (prefPriority[i] > 0 && candidateIsUnhappy(preferences, i, prefPriority[i], prefPriority)){\\n                count++;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n    public int findPriority (int[] candidatePref, int candidate){\\n\\n        for (int i = 0; i < candidatePref.length - 1; i++){\\n            if (candidatePref[i] == candidate){\\n                return i;\\n            }\\n        }\\n        return candidatePref.length - 1;\\n    }\\n    // those who enter this check are potentially unhappy\\n    public boolean candidateIsUnhappy(int[][] preferences, int candidate, int priority, int[] prefPriority){\\n        int[] candidatePref = preferences[candidate];\\n        for (int i = 0; i < priority; i++){\\n            int checkCandidate = candidatePref[i];\\n            // if checkCandidate is matched with less preferred candidate, means both candidates are unhappy, return true\\n            if (findPriority(preferences[checkCandidate], candidate) < prefPriority[checkCandidate]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560529,
                "title": "java-solution-faster-than-70",
                "content": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        \\n        HashMap<Integer, Integer> pairing = new HashMap<>();\\n        int[][] rank = new int[n][n];\\n        for (int[] pair: pairs){\\n            pairing.put(pair[0], pair[1]);\\n            pairing.put(pair[1], pair[0]);\\n        }\\n        \\n        for (int i=0; i<preferences.length; ++i){\\n            int[] friends = preferences[i];\\n            \\n            for (int j=0; j<friends.length; ++j){\\n                int friend = friends[j];\\n                if (i == friend){\\n                    rank[i][friend] = Integer.MAX_VALUE;\\n                    continue;\\n                }\\n                \\n                rank[i][friend] = j;\\n            }\\n        }\\n        \\n        int cnt = 0;\\n        for (int key: pairing.keySet()){\\n            int currentRank = rank[key][pairing.get(key)];\\n            if (currentRank == 0) continue;\\n            int[] friends = preferences[key];\\n            \\n            for (int friend:friends){\\n                if (pairing.get(key) == friend) break;\\n                \\n                if (!pairing.containsKey(friend)) continue;\\n                \\n                int aff1 = rank[friend][key];\\n                int aff2 = rank[friend][pairing.get(friend)];\\n                \\n                if (aff1 < aff2){\\n                    cnt++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        \\n        HashMap<Integer, Integer> pairing = new HashMap<>();\\n        int[][] rank = new int[n][n];\\n        for (int[] pair: pairs){\\n            pairing.put(pair[0], pair[1]);\\n            pairing.put(pair[1], pair[0]);\\n        }\\n        \\n        for (int i=0; i<preferences.length; ++i){\\n            int[] friends = preferences[i];\\n            \\n            for (int j=0; j<friends.length; ++j){\\n                int friend = friends[j];\\n                if (i == friend){\\n                    rank[i][friend] = Integer.MAX_VALUE;\\n                    continue;\\n                }\\n                \\n                rank[i][friend] = j;\\n            }\\n        }\\n        \\n        int cnt = 0;\\n        for (int key: pairing.keySet()){\\n            int currentRank = rank[key][pairing.get(key)];\\n            if (currentRank == 0) continue;\\n            int[] friends = preferences[key];\\n            \\n            for (int friend:friends){\\n                if (pairing.get(key) == friend) break;\\n                \\n                if (!pairing.containsKey(friend)) continue;\\n                \\n                int aff1 = rank[friend][key];\\n                int aff2 = rank[friend][pairing.get(friend)];\\n                \\n                if (aff1 < aff2){\\n                    cnt++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2554651,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        for a, b in pairs:\\n            i, j = preferences[a].index(b), preferences[b].index(a)\\n            preferences[a], preferences[b] = set(preferences[a][:i]), set(preferences[b][:j])\\n        res = 0\\n        for i, p in enumerate(preferences):\\n            if any(i in preferences[j] for j in p):\\n                res += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        for a, b in pairs:\\n            i, j = preferences[a].index(b), preferences[b].index(a)\\n            preferences[a], preferences[b] = set(preferences[a][:i]), set(preferences[b][:j])\\n        res = 0\\n        for i, p in enumerate(preferences):\\n            if any(i in preferences[j] for j in p):\\n                res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527657,
                "title": "javascript-solution",
                "content": "```javascript\\n/**\\n * @param {number} n\\n * @param {number[][]} preferences\\n * @param {number[][]} pairs\\n * @return {number}\\n */\\nvar unhappyFriends = function(n, preferences, pairs) {\\n    const matrix = new Array(n);\\n    for (let i = 0; i < n; i++) {\\n        matrix[i] = new Array(n);\\n        matrix[i][i] = null;\\n        preferences[i].map((y, rank) => matrix[i][y] = rank);\\n        \\n    }\\n    \\n    let pairData = {};\\n    for (const [x,y] of pairs) {\\n        pairData[x] = y;\\n        pairData[y] = x;\\n    }\\n    \\n    const unhappy = new Set();\\n    \\n    \\n    for (let x = 0; x < n; x++) {\\n        if (unhappy.has(x)) {\\n            continue;\\n        }\\n        const y = pairData[x];\\n        \\n        for (const u of preferences[x]) {\\n            if (u === y) {\\n                break;\\n            }\\n            \\n            // x prefers u over y\\n            \\n            let uPreferX = false;\\n            for (const v of preferences[u]) {\\n                if (v === pairData[u]) {\\n                    break;\\n                }\\n                if (v === x) {\\n                    // u prefers x over v\\n                    unhappy.add(x);\\n                    unhappy.add(u);\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n    return unhappy.size;\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\n/**\\n * @param {number} n\\n * @param {number[][]} preferences\\n * @param {number[][]} pairs\\n * @return {number}\\n */\\nvar unhappyFriends = function(n, preferences, pairs) {\\n    const matrix = new Array(n);\\n    for (let i = 0; i < n; i++) {\\n        matrix[i] = new Array(n);\\n        matrix[i][i] = null;\\n        preferences[i].map((y, rank) => matrix[i][y] = rank);\\n        \\n    }\\n    \\n    let pairData = {};\\n    for (const [x,y] of pairs) {\\n        pairData[x] = y;\\n        pairData[y] = x;\\n    }\\n    \\n    const unhappy = new Set();\\n    \\n    \\n    for (let x = 0; x < n; x++) {\\n        if (unhappy.has(x)) {\\n            continue;\\n        }\\n        const y = pairData[x];\\n        \\n        for (const u of preferences[x]) {\\n            if (u === y) {\\n                break;\\n            }\\n            \\n            // x prefers u over y\\n            \\n            let uPreferX = false;\\n            for (const v of preferences[u]) {\\n                if (v === pairData[u]) {\\n                    break;\\n                }\\n                if (v === x) {\\n                    // u prefers x over v\\n                    unhappy.add(x);\\n                    unhappy.add(u);\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n    return unhappy.size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2519329,
                "title": "well-written-codes-can-run-faster-c-50-70ms",
                "content": "```\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        vector<int> v(n);\\n        for(vector<int> &p : pairs){\\n            v[p[0]] = p[1];\\n            v[p[1]] = p[0];\\n        }\\n        int res = 0;\\n        for(int i = 0; i < n; i++){\\n            int x = 0;\\n            for(int j : preferences[i]){\\n                if(j == v[i]) break;\\n                for(int k : preferences[j]){\\n                    if(k == i){\\n                        x++;\\n                        break;\\n                    }\\n                    if(k == v[j]) break;\\n                }\\n                if(x) break;\\n            }\\n            res += x;\\n        }\\n        return res;\\n    }\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        vector<int> v(n);\\n        for(vector<int> &p : pairs){\\n            v[p[0]] = p[1];\\n            v[p[1]] = p[0];\\n        }\\n        int res = 0;\\n        for(int i = 0; i < n; i++){\\n            int x = 0;\\n            for(int j : preferences[i]){\\n                if(j == v[i]) break;\\n                for(int k : preferences[j]){\\n                    if(k == i){\\n                        x++;\\n                        break;\\n                    }\\n                    if(k == v[j]) break;\\n                }\\n                if(x) break;\\n            }\\n            res += x;\\n        }\\n        return res;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2481647,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        HashMap<Integer,Integer> h=new HashMap<Integer,Integer>();\\n        int count=0;\\n        for(int i=0;i<pairs.length;i++)\\n        {\\n            h.put(pairs[i][0],pairs[i][1]);\\n            h.put(pairs[i][1],pairs[i][0]);\\n            \\n        }\\n        for(int i=0;i<pairs.length;i++)\\n        {\\n            int x=pairs[i][0];\\n            int y=pairs[i][1];\\n            for(int j=0;j<preferences[x].length;j++)\\n            {\\n                if(preferences[x][j]==y)\\n                {\\n                    break;\\n                }\\n                else\\n                {\\n                    int flag=0;\\n                    int u=preferences[x][j];\\n                    int v=h.get(u);\\n                    for(int k=0;k<preferences[u].length;k++)\\n                    {\\n                        if(preferences[u][k]==v)\\n                        {\\n                            break;\\n                        }\\n                        else if(preferences[u][k]==x)\\n                        {\\n                            flag=1;\\n                            count++;\\n                            break;\\n                        }\\n                    }\\n                    if(flag==1)\\n                    {\\n                        break;\\n                    }\\n                }\\n            }\\n            /*****************************************************/\\n             x=pairs[i][1];\\n             y=pairs[i][0];\\n            for(int j=0;j<preferences[x].length;j++)\\n            {\\n                if(preferences[x][j]==y)\\n                {\\n                    break;\\n                }\\n                else\\n                {\\n                    int flag=0;\\n                    int u=preferences[x][j];\\n                    int v=h.get(u);\\n                    for(int k=0;k<preferences[u].length;k++)\\n                    {\\n                        if(preferences[u][k]==v)\\n                        {\\n                            break;\\n                        }\\n                        else if(preferences[u][k]==x)\\n                        {\\n                            flag=1;\\n                            count++;\\n                            break;\\n                        }\\n                    }\\n                    if(flag==1)\\n                    {\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        HashMap<Integer,Integer> h=new HashMap<Integer,Integer>();\\n        int count=0;\\n        for(int i=0;i<pairs.length;i++)\\n        {\\n            h.put(pairs[i][0],pairs[i][1]);\\n            h.put(pairs[i][1],pairs[i][0]);\\n            \\n        }\\n        for(int i=0;i<pairs.length;i++)\\n        {\\n            int x=pairs[i][0];\\n            int y=pairs[i][1];\\n            for(int j=0;j<preferences[x].length;j++)\\n            {\\n                if(preferences[x][j]==y)\\n                {\\n                    break;\\n                }\\n                else\\n                {\\n                    int flag=0;\\n                    int u=preferences[x][j];\\n                    int v=h.get(u);\\n                    for(int k=0;k<preferences[u].length;k++)\\n                    {\\n                        if(preferences[u][k]==v)\\n                        {\\n                            break;\\n                        }\\n                        else if(preferences[u][k]==x)\\n                        {\\n                            flag=1;\\n                            count++;\\n                            break;\\n                        }\\n                    }\\n                    if(flag==1)\\n                    {\\n                        break;\\n                    }\\n                }\\n            }\\n            /*****************************************************/\\n             x=pairs[i][1];\\n             y=pairs[i][0];\\n            for(int j=0;j<preferences[x].length;j++)\\n            {\\n                if(preferences[x][j]==y)\\n                {\\n                    break;\\n                }\\n                else\\n                {\\n                    int flag=0;\\n                    int u=preferences[x][j];\\n                    int v=h.get(u);\\n                    for(int k=0;k<preferences[u].length;k++)\\n                    {\\n                        if(preferences[u][k]==v)\\n                        {\\n                            break;\\n                        }\\n                        else if(preferences[u][k]==x)\\n                        {\\n                            flag=1;\\n                            count++;\\n                            break;\\n                        }\\n                    }\\n                    if(flag==1)\\n                    {\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458292,
                "title": "javascript-readable-and-efficient-solution-with-comment",
                "content": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} preferences\\n * @param {number[][]} pairs\\n * @return {number}\\n */\\nvar unhappyFriends = function(n, preferences, pairs) {\\n    let pairedWith = {}\\n    let unhappy = 0\\n    // let\\'s use a map to quickly check for paired people\\n    for (let p of pairs) {\\n        pairedWith[p[0]] = p[1]\\n        pairedWith[p[1]] = p[0]\\n    }\\n    for (let person = 0; person < n; person++) {\\n        // a for loop to check every people\\n        for (let index = 0; index < preferences[person].indexOf(pairedWith[person]); index++) {\\n            // for Mike, we go through everyone that Mike prefers more\\n            let morePrefered = preferences[person][index]\\n             // check if Joey also prefer Mike more than her current pair\\n            if (preferences[morePrefered].indexOf(person) < preferences[morePrefered].indexOf(pairedWith[morePrefered])) {\\n                unhappy++\\n                // found one, break to avoid duplication\\n                break\\n            }\\n        }\\n    }\\n    return unhappy\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} preferences\\n * @param {number[][]} pairs\\n * @return {number}\\n */\\nvar unhappyFriends = function(n, preferences, pairs) {\\n    let pairedWith = {}\\n    let unhappy = 0\\n    // let\\'s use a map to quickly check for paired people\\n    for (let p of pairs) {\\n        pairedWith[p[0]] = p[1]\\n        pairedWith[p[1]] = p[0]\\n    }\\n    for (let person = 0; person < n; person++) {\\n        // a for loop to check every people\\n        for (let index = 0; index < preferences[person].indexOf(pairedWith[person]); index++) {\\n            // for Mike, we go through everyone that Mike prefers more\\n            let morePrefered = preferences[person][index]\\n             // check if Joey also prefer Mike more than her current pair\\n            if (preferences[morePrefered].indexOf(person) < preferences[morePrefered].indexOf(pairedWith[morePrefered])) {\\n                unhappy++\\n                // found one, break to avoid duplication\\n                break\\n            }\\n        }\\n    }\\n    return unhappy\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2426529,
                "title": "python-easy-to-read-and-organized",
                "content": "```\\n def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        pairsDict = {}\\n        for f1, f2 in pairs:\\n            pairsDict[f1] = f2\\n            pairsDict[f2] = f1\\n        \\n        pref = [n*[0] for _ in range(n)]\\n        for i in range(n):\\n            for j in range(n):\\n                if j in preferences[i]:\\n                    pref[i][j] = preferences[i].index(j)\\n                else:\\n                    pref[i][j] = inf\\n\\n        count = 0\\n        for i in range(n):\\n            for j in range(n):\\n                x = i\\n                y = pairsDict[x]\\n                u = j \\n                v = pairsDict[u]\\n                if pref[x][u] < pref[x][y] and pref[u][x] < pref[u][v]:                    \\n                    count+=1\\n                    break\\n        \\n        return count\\n",
                "solutionTags": [],
                "code": "```\\n def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        pairsDict = {}\\n        for f1, f2 in pairs:\\n            pairsDict[f1] = f2\\n            pairsDict[f2] = f1\\n        \\n        pref = [n*[0] for _ in range(n)]\\n        for i in range(n):\\n            for j in range(n):\\n                if j in preferences[i]:\\n                    pref[i][j] = preferences[i].index(j)\\n                else:\\n                    pref[i][j] = inf\\n\\n        count = 0\\n        for i in range(n):\\n            for j in range(n):\\n                x = i\\n                y = pairsDict[x]\\n                u = j \\n                v = pairsDict[u]\\n                if pref[x][u] < pref[x][y] and pref[u][x] < pref[u][v]:                    \\n                    count+=1\\n                    break\\n        \\n        return count\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2416879,
                "title": "java-time-o-n-2-space-o-n",
                "content": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int[] lookup = toLookup(n, pairs);\\n        sortInPlace(n, preferences, lookup);\\n        return solve(n, preferences);        \\n    }\\n    \\n    private int solve(int n, int[][] preferences) {\\n        int[] counters = new int[n];\\n        int ans = 0;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; preferences[i][j] < Integer.MAX_VALUE; ++j) {\\n                int k = preferences[i][j]; // the other friend\\n                while (preferences[k][counters[k]] < i) {\\n                    ++counters[k];\\n                }\\n                if (preferences[k][counters[k]] == i) {\\n                    ++ans;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    private void sortInPlace(int n, int[][] preferences, int[] lookup) {\\n        for (int i = 0; i < n; ++i) {\\n            boolean[] buckets = new boolean[n];\\n            for (int k = 0; preferences[i][k] != lookup[i]; ++k) {\\n                buckets[preferences[i][k]] = true;\\n            }\\n            int j = 0;\\n            for (int k = 0;  k < n; ++k) {\\n                if (buckets[k]) {\\n                    preferences[i][j++] = k;\\n                }\\n            }\\n            preferences[i][j] = Integer.MAX_VALUE;\\n        }\\n    }\\n    \\n    private int[] toLookup(int n, int[][] pairs) {\\n        int[] lookup = new int[n];\\n        for (int i = 0; i < pairs.length; ++i) {\\n            lookup[pairs[i][0]] = pairs[i][1];\\n            lookup[pairs[i][1]] = pairs[i][0];\\n        }\\n        return lookup;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int[] lookup = toLookup(n, pairs);\\n        sortInPlace(n, preferences, lookup);\\n        return solve(n, preferences);        \\n    }\\n    \\n    private int solve(int n, int[][] preferences) {\\n        int[] counters = new int[n];\\n        int ans = 0;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; preferences[i][j] < Integer.MAX_VALUE; ++j) {\\n                int k = preferences[i][j]; // the other friend\\n                while (preferences[k][counters[k]] < i) {\\n                    ++counters[k];\\n                }\\n                if (preferences[k][counters[k]] == i) {\\n                    ++ans;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    private void sortInPlace(int n, int[][] preferences, int[] lookup) {\\n        for (int i = 0; i < n; ++i) {\\n            boolean[] buckets = new boolean[n];\\n            for (int k = 0; preferences[i][k] != lookup[i]; ++k) {\\n                buckets[preferences[i][k]] = true;\\n            }\\n            int j = 0;\\n            for (int k = 0;  k < n; ++k) {\\n                if (buckets[k]) {\\n                    preferences[i][j++] = k;\\n                }\\n            }\\n            preferences[i][j] = Integer.MAX_VALUE;\\n        }\\n    }\\n    \\n    private int[] toLookup(int n, int[][] pairs) {\\n        int[] lookup = new int[n];\\n        for (int i = 0; i < pairs.length; ++i) {\\n            lookup[pairs[i][0]] = pairs[i][1];\\n            lookup[pairs[i][1]] = pairs[i][0];\\n        }\\n        return lookup;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2337741,
                "title": "python-3-o-n-2-brute-force-intuitive",
                "content": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        hashmap = {}\\n        for i in range(len(preferences)):\\n            hashmap[i] = {}\\n            for j in range(len(preferences[i])):\\n                hashmap[i][preferences[i][j]]= j\\n        \\n        print(hashmap)\\n        unhappy = set()\\n        for i in range(len(pairs)):\\n            x = pairs[i][0]\\n            y = pairs[i][1]\\n            for j in range(i+1,len(pairs)):\\n               \\n                a = pairs[j][0] \\n                b= pairs[j][1]\\n                if (hashmap[x][y]>hashmap[x][a] and hashmap[a][b]>hashmap[a][x]):\\n                    unhappy.add(x)\\n                    unhappy.add(a)\\n                if (hashmap[x][y]>hashmap[x][b] and hashmap[b][a]>hashmap[b][x]):\\n                    unhappy.add(x)\\n                    unhappy.add(b)\\n                \\n                if (hashmap[y][x]>hashmap[y][a] and hashmap[a][b]>hashmap[a][y]):\\n                    unhappy.add(y)\\n                    unhappy.add(a)\\n                \\n                if (hashmap[y][x]>hashmap[y][b] and hashmap[b][a] > hashmap[b][y]):\\n                    unhappy.add(y)\\n                    unhappy.add(b)\\n        return len(unhappy)             \\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        hashmap = {}\\n        for i in range(len(preferences)):\\n            hashmap[i] = {}\\n            for j in range(len(preferences[i])):\\n                hashmap[i][preferences[i][j]]= j\\n        \\n        print(hashmap)\\n        unhappy = set()\\n        for i in range(len(pairs)):\\n            x = pairs[i][0]\\n            y = pairs[i][1]\\n            for j in range(i+1,len(pairs)):\\n               \\n                a = pairs[j][0] \\n                b= pairs[j][1]\\n                if (hashmap[x][y]>hashmap[x][a] and hashmap[a][b]>hashmap[a][x]):\\n                    unhappy.add(x)\\n                    unhappy.add(a)\\n                if (hashmap[x][y]>hashmap[x][b] and hashmap[b][a]>hashmap[b][x]):\\n                    unhappy.add(x)\\n                    unhappy.add(b)\\n                \\n                if (hashmap[y][x]>hashmap[y][a] and hashmap[a][b]>hashmap[a][y]):\\n                    unhappy.add(y)\\n                    unhappy.add(a)\\n                \\n                if (hashmap[y][x]>hashmap[y][b] and hashmap[b][a] > hashmap[b][y]):\\n                    unhappy.add(y)\\n                    unhappy.add(b)\\n        return len(unhappy)             \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2253782,
                "title": "c-brute-force",
                "content": "* Run time is pretty high as it is pure Brute Force But it is accepted by leetcode.\\n\\n![image](https://assets.leetcode.com/users/images/0e0b6fd7-59eb-4fcf-af11-296d738f3d7d_1657264714.2963495.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool check(int x , int y , int u , int v ,int n , vector<vector<int>>& pref){\\n        int id_x = 0 , id_y = 0 , id_u = 0  , id_v = 0 ;\\n        //check indices of (y and u) in pref[x] ;\\n        for(int i = 0 ; i < n - 1; ++i ){\\n            if(pref[x][i] == y) id_y = i ;\\n            if(pref[x][i] == u) id_u = i ;\\n        }\\n        \\n        //check indices of (v and x) in pref[u] ;\\n        for(int i = 0 ; i < n - 1 ; ++i ){\\n            if(pref[u][i] == v) id_v = i ;\\n            if(pref[u][i] == x) id_x = i ;\\n        }\\n        \\n        return (id_x < id_v and id_u < id_y) ;\\n    }\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        unordered_set<int> unhappy ;\\n        for(int i = 0 ; i < pairs.size() ; ++i ){\\n            for(int j = i + 1; j < pairs.size() ; ++j){\\n                int x = pairs[i][0] , y = pairs[i][1] , u = pairs[j][0] , v = pairs[j][1] ;\\n                // x prefers u over y and u preferes x over v \\n                if(check(x,y,u,v,n,preferences)) unhappy.insert(x), unhappy.insert(u) ;\\n                // x prefers v over y and v prefers x over u \\n                if(check(x,y,v,u,n,preferences)) unhappy.insert(x) , unhappy.insert(v) ;\\n                // y prefers u over x and u prefers y over v\\n                if(check(y,x,u,v,n,preferences)) unhappy.insert(y) , unhappy.insert(u) ;\\n                // y prefers v over x and v prefers y over u \\n                if(check(y,x,v,u,n,preferences)) unhappy.insert(y) , unhappy.insert(v) ;\\n            }\\n        }\\n        return unhappy.size() ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int x , int y , int u , int v ,int n , vector<vector<int>>& pref){\\n        int id_x = 0 , id_y = 0 , id_u = 0  , id_v = 0 ;\\n        //check indices of (y and u) in pref[x] ;\\n        for(int i = 0 ; i < n - 1; ++i ){\\n            if(pref[x][i] == y) id_y = i ;\\n            if(pref[x][i] == u) id_u = i ;\\n        }\\n        \\n        //check indices of (v and x) in pref[u] ;\\n        for(int i = 0 ; i < n - 1 ; ++i ){\\n            if(pref[u][i] == v) id_v = i ;\\n            if(pref[u][i] == x) id_x = i ;\\n        }\\n        \\n        return (id_x < id_v and id_u < id_y) ;\\n    }\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        unordered_set<int> unhappy ;\\n        for(int i = 0 ; i < pairs.size() ; ++i ){\\n            for(int j = i + 1; j < pairs.size() ; ++j){\\n                int x = pairs[i][0] , y = pairs[i][1] , u = pairs[j][0] , v = pairs[j][1] ;\\n                // x prefers u over y and u preferes x over v \\n                if(check(x,y,u,v,n,preferences)) unhappy.insert(x), unhappy.insert(u) ;\\n                // x prefers v over y and v prefers x over u \\n                if(check(x,y,v,u,n,preferences)) unhappy.insert(x) , unhappy.insert(v) ;\\n                // y prefers u over x and u prefers y over v\\n                if(check(y,x,u,v,n,preferences)) unhappy.insert(y) , unhappy.insert(u) ;\\n                // y prefers v over x and v prefers y over u \\n                if(check(y,x,v,u,n,preferences)) unhappy.insert(y) , unhappy.insert(v) ;\\n            }\\n        }\\n        return unhappy.size() ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2002608,
                "title": "javascript-hashmap-mock-graph-211ms",
                "content": "problems not hard, the tricky thing is to make sure what is x, y, u, v, and the relationship between these, and use index compare to check over\\n```\\nconst initializeGraphSet = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push(new Set()); } return g; };\\nconst packUG_Set = (g, edges) => { for (const [u, v] of edges) { g[u].add(v); g[v].add(u); } };\\nconst counter_ui = (a_or_s) => { let m = new Map(); for (let i = 0; i < a_or_s.length; i++) m.set(a_or_s[i], i); return m; }\\n\\nconst unhappyFriends = (n, preferences, pairs) => {\\n    // happy array to record the state of each node[0, n - 1], pair graph used to find u and v paired\\n    let happy = Array(n).fill(true), pairG = initializeGraphSet(n);\\n    packUG_Set(pairG, pairs);\\n    preferences = preferences.map(a => counter_ui(a)) // convert each preference from array to {node: index} for easier checking over, just index smaller\\n    for (const [x, y] of pairs) {\\n        checkUnhappy(happy, preferences, pairG, x, y); // check if x is unhappy\\n        checkUnhappy(happy, preferences, pairG, y, x); // check if y is unhappy\\n    }\\n    return happy.filter(h => !h).length; // get unhappy count\\n};\\n\\nconst checkUnhappy = (happy, preferences, pairG, x, y) => {\\n    let mx = preferences[x];\\n    for (const [u, iu] of mx) {\\n        if (mx.has(y)) { // x has u and y\\n            if (iu < mx.get(y)) { // u over y\\n                let mu = preferences[u];\\n                if (mu.has(x)) {\\n                    for (const v of pairG[u]) { // u pair with v\\n                        if (mu.has(v) && mu.get(x) < mu.get(v)) { // u has x and v, x over v\\n                            happy[x] = false;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Graph"
                ],
                "code": "```\\nconst initializeGraphSet = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push(new Set()); } return g; };\\nconst packUG_Set = (g, edges) => { for (const [u, v] of edges) { g[u].add(v); g[v].add(u); } };\\nconst counter_ui = (a_or_s) => { let m = new Map(); for (let i = 0; i < a_or_s.length; i++) m.set(a_or_s[i], i); return m; }\\n\\nconst unhappyFriends = (n, preferences, pairs) => {\\n    // happy array to record the state of each node[0, n - 1], pair graph used to find u and v paired\\n    let happy = Array(n).fill(true), pairG = initializeGraphSet(n);\\n    packUG_Set(pairG, pairs);\\n    preferences = preferences.map(a => counter_ui(a)) // convert each preference from array to {node: index} for easier checking over, just index smaller\\n    for (const [x, y] of pairs) {\\n        checkUnhappy(happy, preferences, pairG, x, y); // check if x is unhappy\\n        checkUnhappy(happy, preferences, pairG, y, x); // check if y is unhappy\\n    }\\n    return happy.filter(h => !h).length; // get unhappy count\\n};\\n\\nconst checkUnhappy = (happy, preferences, pairG, x, y) => {\\n    let mx = preferences[x];\\n    for (const [u, iu] of mx) {\\n        if (mx.has(y)) { // x has u and y\\n            if (iu < mx.get(y)) { // u over y\\n                let mu = preferences[u];\\n                if (mu.has(x)) {\\n                    for (const v of pairG[u]) { // u pair with v\\n                        if (mu.has(v) && mu.get(x) < mu.get(v)) { // u has x and v, x over v\\n                            happy[x] = false;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1929789,
                "title": "easy-and-readable-javascript",
                "content": "pseudocode:\\n```\\nfor each x (0..n):\\n\\tget their preferences (xPrefs) before the one they are assigned to (assigned[x])\\n\\tfor each xPref:\\n\\t\\tget their preferences (uPrefs) before the one they are assigned to (assigned[u])\\n\\t\\t\\tif x does not exist in this list:\\n\\t\\t\\t\\tcount += 1 (x is unhappy)\\n```\\n\\t\\njavascript:\\n```\\nvar unhappyFriends = function(n, preferences, pairs) {\\n    let assigned = {}\\n    let count = 0\\n    \\n    for(let pair of pairs){\\n        let [x, y] = pair\\n        assigned[x] = y\\n        assigned[y] = x\\n    }\\n    \\n    for(let x=0; x<n; x++){\\n        let xLimit = preferences[x].indexOf(assigned[x.toString()])\\n        let xPrefs = preferences[x].slice(0, xLimit)\\n        \\n        for(let u of xPrefs){\\n            let uLimit = preferences[u].indexOf(assigned[u.toString()])\\n            let uPrefs = preferences[u].slice(0, uLimit)\\n            \\n            if(uPrefs.includes(x)){\\n                count += 1\\n                break\\n            }\\n        }\\n    }\\n    \\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfor each x (0..n):\\n\\tget their preferences (xPrefs) before the one they are assigned to (assigned[x])\\n\\tfor each xPref:\\n\\t\\tget their preferences (uPrefs) before the one they are assigned to (assigned[u])\\n\\t\\t\\tif x does not exist in this list:\\n\\t\\t\\t\\tcount += 1 (x is unhappy)\\n```\n```\\nvar unhappyFriends = function(n, preferences, pairs) {\\n    let assigned = {}\\n    let count = 0\\n    \\n    for(let pair of pairs){\\n        let [x, y] = pair\\n        assigned[x] = y\\n        assigned[y] = x\\n    }\\n    \\n    for(let x=0; x<n; x++){\\n        let xLimit = preferences[x].indexOf(assigned[x.toString()])\\n        let xPrefs = preferences[x].slice(0, xLimit)\\n        \\n        for(let u of xPrefs){\\n            let uLimit = preferences[u].indexOf(assigned[u.toString()])\\n            let uPrefs = preferences[u].slice(0, uLimit)\\n            \\n            if(uPrefs.includes(x)){\\n                count += 1\\n                break\\n            }\\n        }\\n    }\\n    \\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1916026,
                "title": "c-fast-and-memory-efficient-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& pre, vector<vector<int>>& pairs) {\\n        vector<vector<int>> v(n,vector<int>(n));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n-1;j++){\\n                v[i][pre[i][j]] = n-1-j;\\n            }\\n        }\\n        int ans = 0;\\n        vector<int> mp(n);\\n        for(auto p:pairs){\\n            mp[p[0]] = p[1];\\n            mp[p[1]] = p[0];\\n        }\\n        for(auto p:pairs){\\n            int x = p[0], y = p[1];\\n            int z = v[x][y];\\n            for(int i=0;i<n;i++) {\\n                if(v[x][i]>z){\\n                    int pp = mp[i];\\n                    if(v[i][x]>v[i][pp]) {\\n                        ans++;\\n                        break;\\n                    }\\n                }\\n            }\\n            z = v[y][x];\\n            for(int i=0;i<n;i++) {\\n                if(v[y][i]>z){\\n                    int pp = mp[i];\\n                    if(v[i][y]>v[i][pp]) {\\n                        ans++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& pre, vector<vector<int>>& pairs) {\\n        vector<vector<int>> v(n,vector<int>(n));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n-1;j++){\\n                v[i][pre[i][j]] = n-1-j;\\n            }\\n        }\\n        int ans = 0;\\n        vector<int> mp(n);\\n        for(auto p:pairs){\\n            mp[p[0]] = p[1];\\n            mp[p[1]] = p[0];\\n        }\\n        for(auto p:pairs){\\n            int x = p[0], y = p[1];\\n            int z = v[x][y];\\n            for(int i=0;i<n;i++) {\\n                if(v[x][i]>z){\\n                    int pp = mp[i];\\n                    if(v[i][x]>v[i][pp]) {\\n                        ans++;\\n                        break;\\n                    }\\n                }\\n            }\\n            z = v[y][x];\\n            for(int i=0;i<n;i++) {\\n                if(v[y][i]>z){\\n                    int pp = mp[i];\\n                    if(v[i][y]>v[i][pp]) {\\n                        ans++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1877380,
                "title": "java-concise-bruteforce-o-n-2",
                "content": "1. Transform the preferences information into rank so that we can query how much x likes y by checking `rank[x][y]`.\\n2. Use bitset or hashset or mark unhappy people. \\n\\n**Solution**\\n```Java\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int[][] rank = new int[n][n];\\n        for (int i = 0; i < n; i++){\\n            for (int j = 0; j < n - 1; j++){\\n                rank[i][preferences[i][j]] = j;\\n            }\\n        }\\n\\n        BitSet bit = new BitSet(n);\\n        for (int i = 0; i < n / 2; i++){\\n            for (int j = 0; j < n / 2; j++){\\n                for (int k = 0; k < 2 && i != j; k++){\\n                    for (int w = 0; w < 2; w++){\\n                        int xy = rank[pairs[i][k]][pairs[i][1 - k]];\\n                        int xu = rank[pairs[i][k]][pairs[j][w]];\\n                        int uv = rank[pairs[j][w]][pairs[j][1 - w]];\\n                        int ux = rank[pairs[j][w]][pairs[i][k]];\\n                        if (xu < xy && ux < uv){ // condition required.\\n                            bit.set(pairs[i][k]);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return bit.cardinality();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int[][] rank = new int[n][n];\\n        for (int i = 0; i < n; i++){\\n            for (int j = 0; j < n - 1; j++){\\n                rank[i][preferences[i][j]] = j;\\n            }\\n        }\\n\\n        BitSet bit = new BitSet(n);\\n        for (int i = 0; i < n / 2; i++){\\n            for (int j = 0; j < n / 2; j++){\\n                for (int k = 0; k < 2 && i != j; k++){\\n                    for (int w = 0; w < 2; w++){\\n                        int xy = rank[pairs[i][k]][pairs[i][1 - k]];\\n                        int xu = rank[pairs[i][k]][pairs[j][w]];\\n                        int uv = rank[pairs[j][w]][pairs[j][1 - w]];\\n                        int ux = rank[pairs[j][w]][pairs[i][k]];\\n                        if (xu < xy && ux < uv){ // condition required.\\n                            bit.set(pairs[i][k]);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return bit.cardinality();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1852946,
                "title": "best-map-solution-o-n-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isUn(int x,int y,int u,int v, unordered_map<int,unordered_map<int,int>> &mp)\\n    {\\n                int x_u = mp[x][u];\\n                if(x_u==0) x_u = INT_MAX;\\n                \\n                int x_y = mp[x][y];\\n                if(x_y==0) x_y = INT_MAX;\\n                \\n                int u_x = mp[u][x];\\n                if(u_x==0) u_x = INT_MAX;\\n                \\n                int u_v = mp[u][v];\\n                if(u_v==0) u_v = INT_MAX;\\n                \\n                return (x_u < x_y && u_x < u_v);         \\n    }\\n    int unhappyFriends(int n, vector<vector<int>> &pref, vector<vector<int>> &p) {\\n        \\n        unordered_map<int,unordered_map<int,int>> mp;    // man -> { friend -> pref_no }\\n        for(int i = 0;i<pref.size();i++)            \\n        {            \\n            for(int j = 0;j<pref[i].size();j++)\\n            {\\n                int frd = pref[i][j];\\n                mp[i][frd] = j+1;       \\n            }\\n        }\\n        for(int i = 0;i<p.size();i++)      // store the pair-mate using {idx=-1} saved space\\n        {\\n            int x = p[i][0];\\n            int y = p[i][1];\\n            mp[x][-1] = y;\\n            mp[y][-1] = x;\\n        }\\n        int ct = 0;\\n        for(int x = 0;x<n;x++)              //  O(n*n) time complexity\\n        {\\n            bool isU = false;            \\n            int y = mp[x][-1];                \\n            for(auto it1:mp[x])  // scan past friends of x \\n            {\\n                int u = it1.first;                \\n                int v = mp[u][-1];\\n                if(isUn(x,y,u,v,mp))\\n                {       \\n                    isU = true;break;\\n                }\\n            }\\n            if(isU) ct++;\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isUn(int x,int y,int u,int v, unordered_map<int,unordered_map<int,int>> &mp)\\n    {\\n                int x_u = mp[x][u];\\n                if(x_u==0) x_u = INT_MAX;\\n                \\n                int x_y = mp[x][y];\\n                if(x_y==0) x_y = INT_MAX;\\n                \\n                int u_x = mp[u][x];\\n                if(u_x==0) u_x = INT_MAX;\\n                \\n                int u_v = mp[u][v];\\n                if(u_v==0) u_v = INT_MAX;\\n                \\n                return (x_u < x_y && u_x < u_v);         \\n    }\\n    int unhappyFriends(int n, vector<vector<int>> &pref, vector<vector<int>> &p) {\\n        \\n        unordered_map<int,unordered_map<int,int>> mp;    // man -> { friend -> pref_no }\\n        for(int i = 0;i<pref.size();i++)            \\n        {            \\n            for(int j = 0;j<pref[i].size();j++)\\n            {\\n                int frd = pref[i][j];\\n                mp[i][frd] = j+1;       \\n            }\\n        }\\n        for(int i = 0;i<p.size();i++)      // store the pair-mate using {idx=-1} saved space\\n        {\\n            int x = p[i][0];\\n            int y = p[i][1];\\n            mp[x][-1] = y;\\n            mp[y][-1] = x;\\n        }\\n        int ct = 0;\\n        for(int x = 0;x<n;x++)              //  O(n*n) time complexity\\n        {\\n            bool isU = false;            \\n            int y = mp[x][-1];                \\n            for(auto it1:mp[x])  // scan past friends of x \\n            {\\n                int u = it1.first;                \\n                int v = mp[u][-1];\\n                if(isUn(x,y,u,v,mp))\\n                {       \\n                    isU = true;break;\\n                }\\n            }\\n            if(isU) ct++;\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1843125,
                "title": "simple-java-solution",
                "content": "class Solution {\\n    \\n\\tpublic int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        \\n        HashMap<Integer,Integer>map=new HashMap<>();\\n        \\n        for(int [] e: pairs){\\n            \\n            int x=e[0];\\n            int y=e[1];\\n            \\n            map.put(x,y);\\n            map.put(y,x);\\n            \\n        }\\n        \\n        int count=0;\\n        \\n        for(int []e: pairs){\\n            \\n           \\n            for(int x: e){\\n                int g=count;\\n                for(int j=0;j<preferences[x].length;j++){\\n                    if(preferences[x][j]==map.get(x)){\\n                        break;\\n                    }\\n\\n                    int u=preferences[x][j];\\n\\n                    if(map.containsKey(u)){\\n\\n                        for(int k=0;k<preferences[u].length;k++){\\n                            if(preferences[u][k]==x){\\n                                count++;\\n                                break;\\n                            }\\n                            if(preferences[u][k]==map.get(u))\\n                                break;\\n                        }\\n\\n                    }\\n                    \\n                    if(g<count)\\n                        break;\\n                }\\n            }           \\n        }\\n \\n        return count;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n\\tpublic int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        \\n        HashMap<Integer,Integer>map=new HashMap<>();\\n        \\n        for(int [] e: pairs){\\n            \\n            int x=e[0];\\n            int y=e[1];\\n            \\n            map.put(x,y);\\n            map.put(y,x);\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1835975,
                "title": "what-s-wrong-in-this",
                "content": "Can anyone help me out finding out what is the error in this?\\nwhy it\\'s failing for the follwing test case:\\n\\n**14\\n[[10,9,2,11,1,8,12,4,3,13,6,7,5],[8,12,6,10,9,3,7,13,0,5,4,2,11],[0,11,10,9,4,8,3,12,1,6,5,13,7],[12,10,7,11,4,5,8,2,6,9,0,13,1],[7,0,9,5,12,13,1,2,10,6,11,3,8],[8,12,7,13,10,6,4,3,2,11,0,1,9],[13,5,11,8,7,1,4,12,9,10,3,2,0],[11,12,3,13,4,5,6,9,1,8,2,0,10],[5,1,2,6,13,3,7,11,4,9,10,12,0],[10,11,1,3,12,2,8,7,4,5,6,0,13],[5,4,12,11,7,3,13,1,2,9,8,0,6],[2,4,3,8,5,0,7,12,13,9,6,1,10],[11,0,6,10,9,3,1,4,2,8,7,13,5],[0,4,11,8,6,9,2,12,1,7,10,3,5]]\\n[[11,8],[7,2],[1,9],[10,4],[5,12],[0,13],[3,6]]**\\n\\n```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& pref, vector<vector<int>>& pairs) {\\n        unordered_map<int, vector<int>> umap;\\n        int res = 0;\\n        \\n        for(auto pair : pairs) {\\n            int x = pair[0], y = pair[1];\\n            for(int u : pref[x]) {\\n                if(u == y)\\n                    break;\\n                umap[x].push_back(u);\\n            }\\n            \\n            x = pair[1], y = pair[0];\\n            for(int u : pref[x]) {\\n                if(u == y)\\n                    break;\\n                umap[x].push_back(u);\\n            }\\n        }\\n        \\n        for(auto it = umap.begin(); it != umap.end(); ++it) {\\n            int me = it->first;\\n            vector<int> prefrees = it->second;\\n            \\n            for(int p : prefrees) {\\n                vector<int> v = umap[p];\\n                if(find(v.begin(), v.end(), me) != v.end()) {\\n                    res++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& pref, vector<vector<int>>& pairs) {\\n        unordered_map<int, vector<int>> umap;\\n        int res = 0;\\n        \\n        for(auto pair : pairs) {\\n            int x = pair[0], y = pair[1];\\n            for(int u : pref[x]) {\\n                if(u == y)\\n                    break;\\n                umap[x].push_back(u);\\n            }\\n            \\n            x = pair[1], y = pair[0];\\n            for(int u : pref[x]) {\\n                if(u == y)\\n                    break;\\n                umap[x].push_back(u);\\n            }\\n        }\\n        \\n        for(auto it = umap.begin(); it != umap.end(); ++it) {\\n            int me = it->first;\\n            vector<int> prefrees = it->second;\\n            \\n            for(int p : prefrees) {\\n                vector<int> v = umap[p];\\n                if(find(v.begin(), v.end(), me) != v.end()) {\\n                    res++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825049,
                "title": "o-n-2-or-o-n-m-solution-using-arrays-and-hashset",
                "content": "- This approach is similar to brute force approach but I tried to improve it by storing preferences in beginning.\\n- Please read comments in code to understance code\\n- Time Time Complexity :-  O(n * (m + m)) \\u21D2 O(n*m) (where n is number of friends and m is more preferred friends over friend2) (m can be n-2 at max) **(Please suggest if calculation is not correct)**\\n- Space Complexity :-  O(n*n) + O(n) \\u21D2 O(n*n)\\n- please suggest corrections if any\\n\\n```\\nclass Solution {\\n    //In this code => x = friend1\\n    //and y = friend2\\n    \\n    //This will store [i,j] => k, for friend i, jth preference will be k\\n    int[][] friendPreference = null;\\n    \\n    //This will store index of pair in which ith friend is present\\n    int[] presentInPair = null;\\n    \\n    public int unhappyFriends(int numberOfFriends, int[][] preferences, int[][] pairs) {\\n        presentInPair = new int[numberOfFriends];\\n        for(int i=0;i<pairs.length;i++){\\n            presentInPair[pairs[i][0]] = i;\\n            presentInPair[pairs[i][1]] = i;\\n        }\\n        \\n        friendPreference = new int[numberOfFriends][numberOfFriends];\\n        for(int i=0;i<numberOfFriends;i++){\\n            int[] oneFriendPreference = preferences[i];\\n            int j=0;\\n            for(int friend : oneFriendPreference){\\n                friendPreference[i][friend] = j;\\n                j++;\\n            }\\n        }\\n        \\n        Set<Integer> unHappySet = new HashSet<>();\\n        \\n        for(int i=0;i<pairs.length;i++){\\n            int friend1 = pairs[i][0];\\n            int friend2 = pairs[i][1];\\n            \\n            //for 0th element => This code block will check if friend1 prefers any friend u over friend2 and also we need to check u prefers friend1 over v\\n            if(!unHappySet.contains(friend1)){\\n                int indexIffriend1unhappy = isFriendUnHappy(friend1,friend2,preferences,pairs);\\n                if(indexIffriend1unhappy != -1)\\n                {\\n                    //Both friends are unhappy so add both in set\\n                    unHappySet.add(friend1);\\n                    unHappySet.add(indexIffriend1unhappy);\\n                }\\n            }\\n            \\n            \\n            //for 0th element => This code block will check if friend2 prefers any friend u over friend1 and also we need to check u prefers friend2 over v\\n            if(!unHappySet.contains(friend2)){\\n                    int indexIffriend2unhappy = isFriendUnHappy(friend2,friend1,preferences,pairs);\\n            if(indexIffriend2unhappy != -1)\\n            {\\n                //Both friends are unhappy so add both in set\\n                unHappySet.add(friend2);\\n                unHappySet.add(indexIffriend2unhappy);\\n            }   \\n            }\\n            \\n        }\\n        \\n        return unHappySet.size();\\n    }\\n    \\n    private int isFriendUnHappy(int friend1, int friend2,int[][] preferences, int[][] pairs){\\n            //preference index of friend1 & friend2\\n            int prefrenceIndex = friendPreference[friend1][friend2];\\n        \\n            //friend1\\'s all preferences\\n            int[] friend1preferences = preferences[friend1];\\n        \\n            if(prefrenceIndex != 0){\\n                //check for all prefernces where preference < prefrenceIndex(preference of friend2)\\n                for(int i=0;i<prefrenceIndex;i++){\\n                    //index of friend which is at ith preference for friend1\\n                    int u = friend1preferences[i];\\n                    \\n                    //find pair in which above friend is present\\n                    int pairIndexOfFriendAtI = presentInPair[u];\\n                    int[] pairFriendAtI = pairs[pairIndexOfFriendAtI];\\n                    \\n                    //Find corresponding friend in pair of u\\n                    int v = pairFriendAtI[0] != u ? pairFriendAtI[0] : pairFriendAtI[1];\\n\\n                    //u should prefer friend1 over v(preference value should be lower)\\n                    if(friendPreference[u][v] >\\n                       friendPreference[u][friend1])\\n                        //return u that means friend1 prefers u over friend2 and u preferes friend1 over v\\n                        return u;\\n                    \\n                }\\n            }\\n            \\n            return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    //In this code => x = friend1\\n    //and y = friend2\\n    \\n    //This will store [i,j] => k, for friend i, jth preference will be k\\n    int[][] friendPreference = null;\\n    \\n    //This will store index of pair in which ith friend is present\\n    int[] presentInPair = null;\\n    \\n    public int unhappyFriends(int numberOfFriends, int[][] preferences, int[][] pairs) {\\n        presentInPair = new int[numberOfFriends];\\n        for(int i=0;i<pairs.length;i++){\\n            presentInPair[pairs[i][0]] = i;\\n            presentInPair[pairs[i][1]] = i;\\n        }\\n        \\n        friendPreference = new int[numberOfFriends][numberOfFriends];\\n        for(int i=0;i<numberOfFriends;i++){\\n            int[] oneFriendPreference = preferences[i];\\n            int j=0;\\n            for(int friend : oneFriendPreference){\\n                friendPreference[i][friend] = j;\\n                j++;\\n            }\\n        }\\n        \\n        Set<Integer> unHappySet = new HashSet<>();\\n        \\n        for(int i=0;i<pairs.length;i++){\\n            int friend1 = pairs[i][0];\\n            int friend2 = pairs[i][1];\\n            \\n            //for 0th element => This code block will check if friend1 prefers any friend u over friend2 and also we need to check u prefers friend1 over v\\n            if(!unHappySet.contains(friend1)){\\n                int indexIffriend1unhappy = isFriendUnHappy(friend1,friend2,preferences,pairs);\\n                if(indexIffriend1unhappy != -1)\\n                {\\n                    //Both friends are unhappy so add both in set\\n                    unHappySet.add(friend1);\\n                    unHappySet.add(indexIffriend1unhappy);\\n                }\\n            }\\n            \\n            \\n            //for 0th element => This code block will check if friend2 prefers any friend u over friend1 and also we need to check u prefers friend2 over v\\n            if(!unHappySet.contains(friend2)){\\n                    int indexIffriend2unhappy = isFriendUnHappy(friend2,friend1,preferences,pairs);\\n            if(indexIffriend2unhappy != -1)\\n            {\\n                //Both friends are unhappy so add both in set\\n                unHappySet.add(friend2);\\n                unHappySet.add(indexIffriend2unhappy);\\n            }   \\n            }\\n            \\n        }\\n        \\n        return unHappySet.size();\\n    }\\n    \\n    private int isFriendUnHappy(int friend1, int friend2,int[][] preferences, int[][] pairs){\\n            //preference index of friend1 & friend2\\n            int prefrenceIndex = friendPreference[friend1][friend2];\\n        \\n            //friend1\\'s all preferences\\n            int[] friend1preferences = preferences[friend1];\\n        \\n            if(prefrenceIndex != 0){\\n                //check for all prefernces where preference < prefrenceIndex(preference of friend2)\\n                for(int i=0;i<prefrenceIndex;i++){\\n                    //index of friend which is at ith preference for friend1\\n                    int u = friend1preferences[i];\\n                    \\n                    //find pair in which above friend is present\\n                    int pairIndexOfFriendAtI = presentInPair[u];\\n                    int[] pairFriendAtI = pairs[pairIndexOfFriendAtI];\\n                    \\n                    //Find corresponding friend in pair of u\\n                    int v = pairFriendAtI[0] != u ? pairFriendAtI[0] : pairFriendAtI[1];\\n\\n                    //u should prefer friend1 over v(preference value should be lower)\\n                    if(friendPreference[u][v] >\\n                       friendPreference[u][friend1])\\n                        //return u that means friend1 prefers u over friend2 and u preferes friend1 over v\\n                        return u;\\n                    \\n                }\\n            }\\n            \\n            return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1818918,
                "title": "c-o-n-2-easiest-solution-no-confusion",
                "content": "```\\nint unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n\\tvector<int> pair(n); // pair[i] = Friend with which \\'i\\'th friend has been paired \\n\\tvector<vector<int>> pref(n, vector<int>(n, 0)); //pref[i][j] = Preference of \\'j\\'th friend for ith friend\\n\\tfor(auto &x : pairs) {\\n\\t\\tpair[x[0]] = x[1];\\n\\t\\tpair[x[1]] = x[0];\\n\\t}\\n\\tfor(int i = 0; i<n; i++) {\\n\\t\\tfor(int j = 0; j<n-1; j++) {\\n\\t\\t\\tpref[i][preferences[i][j]] = n-j;\\n\\t\\t}\\n\\t}\\n\\n\\tint res = 0;\\n\\t// For each friend \\'i\\', check if another friend \\'j\\' satisfies the condition for him (i) being unhappy\\n\\tfor(int i = 0; i<n; i++) {\\n\\t\\tbool flag = false;\\n\\t\\tfor(int j = 0; j<n && !flag; j++) {\\n\\t\\t\\tif(j == i) continue;\\n\\t\\t\\tif(pref[i][pair[i]] < pref[i][j] && pref[j][pair[j]] < pref[j][i]) flag = true; \\n\\t\\t}\\n\\t\\tif(flag) res++; // If, for any friend \\'j\\', the condition satisfies => \\'i\\'th friend is unhappy\\n\\t}\\n\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n\\tvector<int> pair(n); // pair[i] = Friend with which \\'i\\'th friend has been paired \\n\\tvector<vector<int>> pref(n, vector<int>(n, 0)); //pref[i][j] = Preference of \\'j\\'th friend for ith friend\\n\\tfor(auto &x : pairs) {\\n\\t\\tpair[x[0]] = x[1];\\n\\t\\tpair[x[1]] = x[0];\\n\\t}\\n\\tfor(int i = 0; i<n; i++) {\\n\\t\\tfor(int j = 0; j<n-1; j++) {\\n\\t\\t\\tpref[i][preferences[i][j]] = n-j;\\n\\t\\t}\\n\\t}\\n\\n\\tint res = 0;\\n\\t// For each friend \\'i\\', check if another friend \\'j\\' satisfies the condition for him (i) being unhappy\\n\\tfor(int i = 0; i<n; i++) {\\n\\t\\tbool flag = false;\\n\\t\\tfor(int j = 0; j<n && !flag; j++) {\\n\\t\\t\\tif(j == i) continue;\\n\\t\\t\\tif(pref[i][pair[i]] < pref[i][j] && pref[j][pair[j]] < pref[j][i]) flag = true; \\n\\t\\t}\\n\\t\\tif(flag) res++; // If, for any friend \\'j\\', the condition satisfies => \\'i\\'th friend is unhappy\\n\\t}\\n\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1769658,
                "title": "straight-forward-python-just-following-the-logic-in-question",
                "content": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        pairs_dict = {}\\n        for p in pairs:\\n            pairs_dict[p[0]] = p[1]\\n            pairs_dict[p[1]] = p[0]\\n        result = 0\\n        for x in range(n):\\n            y = pairs_dict[x]\\n            for u in range(n):\\n                if x == u:\\n                    continue\\n                v = pairs_dict[u]\\n                if preferences[x].index(u) < preferences[x].index(y) and preferences[u].index(x) < preferences[u].index(v):\\n                    result += 1\\n                    break\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        pairs_dict = {}\\n        for p in pairs:\\n            pairs_dict[p[0]] = p[1]\\n            pairs_dict[p[1]] = p[0]\\n        result = 0\\n        for x in range(n):\\n            y = pairs_dict[x]\\n            for u in range(n):\\n                if x == u:\\n                    continue\\n                v = pairs_dict[u]\\n                if preferences[x].index(u) < preferences[x].index(y) and preferences[u].index(x) < preferences[u].index(v):\\n                    result += 1\\n                    break\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1759999,
                "title": "simple-c-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preference, vector<vector<int>>& pair) {\\n     unordered_map<int,vector<int>>mp;                    // hashing to access prefernce value of each friend for any person x in O(1)\\n        vector<int>t(n,0);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n-1;j++){\\n                t[preference[i][j]]=j;\\n            }\\n            mp[i]=t;\\n        }\\n        unordered_map<int,int> paired_friend;                 // hashing to access paired friend in O(1);\\n        for(int i=0;i<n/2;i++){\\n            paired_friend[pair[i][0]]=pair[i][1];\\n            paired_friend[pair[i][1]]=pair[i][0];\\n        }\\n        \\n        vector<int>person_state(n,0);\\n        int ans=0;\\n        for(auto it: paired_friend){\\n            int a=it.first, b=it.second, b_prefrence_for_a=mp[a][b];\\n            if(person_state[a]==0){                          //if person is unhappy no need to check\\n                for(int i=b_prefrence_for_a-1;i>=0;i--){    \\n// if we find lower preference friend for person \\'a\\' who also paired\\n//with  higher preference friend than person \\'a\\', then both unhappy\\n                    int x=preference[a][i];\\n                    int x_pair=paired_friend[x];\\n                    if(mp[x][a]<mp[x][x_pair]){\\n                    person_state[x]=1;person_state[a]=1;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            ans+=person_state[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preference, vector<vector<int>>& pair) {\\n     unordered_map<int,vector<int>>mp;                    // hashing to access prefernce value of each friend for any person x in O(1)\\n        vector<int>t(n,0);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n-1;j++){\\n                t[preference[i][j]]=j;\\n            }\\n            mp[i]=t;\\n        }\\n        unordered_map<int,int> paired_friend;                 // hashing to access paired friend in O(1);\\n        for(int i=0;i<n/2;i++){\\n            paired_friend[pair[i][0]]=pair[i][1];\\n            paired_friend[pair[i][1]]=pair[i][0];\\n        }\\n        \\n        vector<int>person_state(n,0);\\n        int ans=0;\\n        for(auto it: paired_friend){\\n            int a=it.first, b=it.second, b_prefrence_for_a=mp[a][b];\\n            if(person_state[a]==0){                          //if person is unhappy no need to check\\n                for(int i=b_prefrence_for_a-1;i>=0;i--){    \\n// if we find lower preference friend for person \\'a\\' who also paired\\n//with  higher preference friend than person \\'a\\', then both unhappy\\n                    int x=preference[a][i];\\n                    int x_pair=paired_friend[x];\\n                    if(mp[x][a]<mp[x][x_pair]){\\n                    person_state[x]=1;person_state[a]=1;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            ans+=person_state[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1752609,
                "title": "c-tc-n-2-mc-n-2-easy-to-understand-intuitive",
                "content": "```\\nclass Solution {\\nprivate:\\n    // MC: O(n^2) => In the worst case, everyfriend will be in the prior preferences set.\\n    int numOfFriends;\\n    vector<set<int>> priorPrefSet;\\n    vector<vector<int>> preferences;\\n    vector<vector<int>> pairs;\\n    \\npublic:\\n    // TC: O(n^2) => for each person, we traverse its friend list\\n    void createPriorPrefSet() {\\n        priorPrefSet.resize(numOfFriends);\\n        for (auto pair: pairs) {\\n            int first = pair[0];\\n            int second = pair[1];\\n            for (int i = 0; i < preferences[first].size(); i++) {\\n                if (preferences[first][i] == second)   \\n                    break;\\n                priorPrefSet[first].insert(preferences[first][i]);\\n            }\\n            for (int i = 0; i < preferences[second].size(); i++) {\\n                if (preferences[second][i] == first)\\n                    break;\\n                priorPrefSet[second].insert(preferences[second][i]);\\n            }\\n        }\\n    }\\n    \\n    // TC: O(n^2) => for each person, we traverse its prior preferences set\\n    int countUnhappyFriends() {\\n        int cnt = 0;\\n        for (int i = 0; i < numOfFriends; i++) {\\n            for (auto priorFriend: priorPrefSet[i]) {\\n                if (priorPrefSet[priorFriend].count(i) > 0) {\\n                    cnt++;\\n                    break;  // Finding one is enough\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    /* Main idea is that for each person, we create a set that contain person\\'s friends whose\\n    priority is over the person\\'s current pair. Then for each such friends we check\\n    whether they also includdes current person. If so, there is a new unhappy friends.\\n    */\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        this->numOfFriends = n;\\n        this->preferences = preferences;\\n        this->pairs = pairs;\\n        \\n        createPriorPrefSet();\\n        return countUnhappyFriends();\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    // MC: O(n^2) => In the worst case, everyfriend will be in the prior preferences set.\\n    int numOfFriends;\\n    vector<set<int>> priorPrefSet;\\n    vector<vector<int>> preferences;\\n    vector<vector<int>> pairs;\\n    \\npublic:\\n    // TC: O(n^2) => for each person, we traverse its friend list\\n    void createPriorPrefSet() {\\n        priorPrefSet.resize(numOfFriends);\\n        for (auto pair: pairs) {\\n            int first = pair[0];\\n            int second = pair[1];\\n            for (int i = 0; i < preferences[first].size(); i++) {\\n                if (preferences[first][i] == second)   \\n                    break;\\n                priorPrefSet[first].insert(preferences[first][i]);\\n            }\\n            for (int i = 0; i < preferences[second].size(); i++) {\\n                if (preferences[second][i] == first)\\n                    break;\\n                priorPrefSet[second].insert(preferences[second][i]);\\n            }\\n        }\\n    }\\n    \\n    // TC: O(n^2) => for each person, we traverse its prior preferences set\\n    int countUnhappyFriends() {\\n        int cnt = 0;\\n        for (int i = 0; i < numOfFriends; i++) {\\n            for (auto priorFriend: priorPrefSet[i]) {\\n                if (priorPrefSet[priorFriend].count(i) > 0) {\\n                    cnt++;\\n                    break;  // Finding one is enough\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    /* Main idea is that for each person, we create a set that contain person\\'s friends whose\\n    priority is over the person\\'s current pair. Then for each such friends we check\\n    whether they also includdes current person. If so, there is a new unhappy friends.\\n    */\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        this->numOfFriends = n;\\n        this->preferences = preferences;\\n        this->pairs = pairs;\\n        \\n        createPriorPrefSet();\\n        return countUnhappyFriends();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1740295,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func unhappyFriends(_ n: Int, _ preferences: [[Int]], _ pairs: [[Int]]) -> Int {\\n        var preferenceTable = Array(repeating: Array(repeating: 0, count: n), count: n)\\n\\n        for (row, preference) in preferences.enumerated() {\\n            for (prefrenceId, col) in preference.enumerated() {\\n                preferenceTable[row][col] = prefrenceId + 1\\n            }\\n        }\\n\\n        var result = Set<Int>()\\n\\n        for firstPair in pairs {\\n            let (x, y) = (firstPair[0], firstPair[1])\\n\\n            for secPair in pairs {\\n                if firstPair != secPair {\\n                    let (u, v) = (secPair[0], secPair[1])\\n\\n                    if preferenceTable[x][u] < preferenceTable[x][y]\\n                        && preferenceTable[u][x] < preferenceTable[u][v]\\n                        || preferenceTable[x][v] < preferenceTable[x][y]\\n                        && preferenceTable[v][x] < preferenceTable[v][u]{\\n                        result.insert(x)\\n                    }\\n\\n                    if preferenceTable[y][u] < preferenceTable[y][x]\\n                        && preferenceTable[u][y] < preferenceTable[u][v]\\n                        || preferenceTable[y][v] < preferenceTable[y][x]\\n                        && preferenceTable[v][y] < preferenceTable[v][u]{\\n                        result.insert(y)\\n                    }\\n                }\\n            }\\n        }\\n\\n        return result.count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func unhappyFriends(_ n: Int, _ preferences: [[Int]], _ pairs: [[Int]]) -> Int {\\n        var preferenceTable = Array(repeating: Array(repeating: 0, count: n), count: n)\\n\\n        for (row, preference) in preferences.enumerated() {\\n            for (prefrenceId, col) in preference.enumerated() {\\n                preferenceTable[row][col] = prefrenceId + 1\\n            }\\n        }\\n\\n        var result = Set<Int>()\\n\\n        for firstPair in pairs {\\n            let (x, y) = (firstPair[0], firstPair[1])\\n\\n            for secPair in pairs {\\n                if firstPair != secPair {\\n                    let (u, v) = (secPair[0], secPair[1])\\n\\n                    if preferenceTable[x][u] < preferenceTable[x][y]\\n                        && preferenceTable[u][x] < preferenceTable[u][v]\\n                        || preferenceTable[x][v] < preferenceTable[x][y]\\n                        && preferenceTable[v][x] < preferenceTable[v][u]{\\n                        result.insert(x)\\n                    }\\n\\n                    if preferenceTable[y][u] < preferenceTable[y][x]\\n                        && preferenceTable[u][y] < preferenceTable[u][v]\\n                        || preferenceTable[y][v] < preferenceTable[y][x]\\n                        && preferenceTable[v][y] < preferenceTable[v][u]{\\n                        result.insert(y)\\n                    }\\n                }\\n            }\\n        }\\n\\n        return result.count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1738947,
                "title": "c-solution-using-dictionary",
                "content": "```\\npublic class Solution {\\n    public int UnhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int uh = 0;\\n        Dictionary<int,int> paired = new Dictionary<int,int>();\\n        \\n        foreach(var pair in pairs)\\n        {\\n            paired.Add(pair[0], pair[1]);\\n            paired.Add(pair[1], pair[0]);\\n        }\\n        foreach(var pair in pairs)\\n        {\\n            int[] first = preferences[pair[0]];\\n            int[] second = preferences[pair[1]];\\n            \\n            int i = 0;\\n            while(first[i] != pair[1])\\n            {\\n                if(PrefersSameWay(preferences[first[i]], pair[0], paired[first[i]]))\\n                {\\n                    uh++;\\n                    break;\\n                }\\n                i++;\\n            }\\n            i = 0;\\n            while(second[i] != pair[0])\\n            {\\n                if(PrefersSameWay(preferences[second[i]], pair[1], paired[second[i]]))\\n                {\\n                    uh++;\\n                    break;\\n                }\\n                i++;\\n            }\\n        }\\n        \\n        return uh;\\n    }\\n    \\n    private bool PrefersSameWay(int[] arr, int a, int b)\\n    {\\n        foreach(int i in arr)\\n        {\\n            if(i == a)\\n                return true;\\n            if(i == b)\\n                return false;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int UnhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int uh = 0;\\n        Dictionary<int,int> paired = new Dictionary<int,int>();\\n        \\n        foreach(var pair in pairs)\\n        {\\n            paired.Add(pair[0], pair[1]);\\n            paired.Add(pair[1], pair[0]);\\n        }\\n        foreach(var pair in pairs)\\n        {\\n            int[] first = preferences[pair[0]];\\n            int[] second = preferences[pair[1]];\\n            \\n            int i = 0;\\n            while(first[i] != pair[1])\\n            {\\n                if(PrefersSameWay(preferences[first[i]], pair[0], paired[first[i]]))\\n                {\\n                    uh++;\\n                    break;\\n                }\\n                i++;\\n            }\\n            i = 0;\\n            while(second[i] != pair[0])\\n            {\\n                if(PrefersSameWay(preferences[second[i]], pair[1], paired[second[i]]))\\n                {\\n                    uh++;\\n                    break;\\n                }\\n                i++;\\n            }\\n        }\\n        \\n        return uh;\\n    }\\n    \\n    private bool PrefersSameWay(int[] arr, int a, int b)\\n    {\\n        foreach(int i in arr)\\n        {\\n            if(i == a)\\n                return true;\\n            if(i == b)\\n                return false;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1698547,
                "title": "python-hashmap",
                "content": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        #convert pairs in undirected graph\\n        #mapping any of A to B with the preference ranking\\n        #for each pair, find another pair meet the conditions, add it to the result and continue with next pair\\n\\t\\t#O(n^2) time and space\\n        \\n        \\n        pairsmap = {}\\n        for x, y in pairs:\\n            pairsmap[x] = y\\n            pairsmap[y] = x\\n            \\n        rank = defaultdict(lambda: defaultdict(int))\\n        for i in range(n):\\n            for j in range(len(preferences[i])):\\n                rank[i][preferences[i][j]] = j\\n        \\n        res = 0\\n        for x, y in pairsmap.items():\\n            for u in range(n):\\n                v = pairsmap[u]\\n                if u == x:\\n                    continue\\n                if rank[x][u] < rank[x][y] and rank[u][x] < rank[u][v]:\\n                    res += 1\\n                    break\\n        \\n        return res\\n            \\n            \\n                \\n        \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        #convert pairs in undirected graph\\n        #mapping any of A to B with the preference ranking\\n        #for each pair, find another pair meet the conditions, add it to the result and continue with next pair\\n\\t\\t#O(n^2) time and space\\n        \\n        \\n        pairsmap = {}\\n        for x, y in pairs:\\n            pairsmap[x] = y\\n            pairsmap[y] = x\\n            \\n        rank = defaultdict(lambda: defaultdict(int))\\n        for i in range(n):\\n            for j in range(len(preferences[i])):\\n                rank[i][preferences[i][j]] = j\\n        \\n        res = 0\\n        for x, y in pairsmap.items():\\n            for u in range(n):\\n                v = pairsmap[u]\\n                if u == x:\\n                    continue\\n                if rank[x][u] < rank[x][y] and rank[u][x] < rank[u][v]:\\n                    res += 1\\n                    break\\n        \\n        return res\\n            \\n            \\n                \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567600,
                "content": [
                    {
                        "username": "strommj",
                        "content": "It says the output should be 0, but it is 2."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "how?"
                    },
                    {
                        "username": "jingjing_334",
                        "content": "Had to use failed test case to reverse engineer the problem description. It\\'s a waste of time."
                    },
                    {
                        "username": "aakash_abhishek",
                        "content": "Why Bloomberg tagged questions are so hard to understand"
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "because their goal is to confuse you, not test your knowledge of coding!!!"
                    },
                    {
                        "username": "mo1ok",
                        "content": "I have no idea how the preference array works in this question. Are these preferences for individual friends, or are the preferences supposed to be aggregrated on the whole?\n\nIn the first example, there are two preference arrays:\n[1, 2, 3]\n[3, 2, 0]\n\nSo is 3 a preferred to 2, or is 3 inferior to 2? It makes no sense. Who ever wrote this question needs to get their head checked.\n\n\nEdit: after struggling with it, not mentioned in the problem is that the index of the preference list is relevant. So The preferences are the indivdual preferences of the friends - [1, 2, 3] at index 0 is the preference of friend 0."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Bad mood, bad problem. :("
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "language is too much confusing."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain this question?"
                    },
                    {
                        "username": "matthanwork",
                        "content": "You are given pairs of people. Each person has preferences as to who they would want to be partnered with. \\nPerson1 is paired with Person2. Person1 is unhappy if he prefers someone more than Person2 AND another person that he prefers more than Person2 is paired with someone who likes Person1 more than their current partner"
                    },
                    {
                        "username": "hammeramr",
                        "content": "I don't understand all the hate - the description was extremely clear - dense but clear - just read this line a few timea thats all you need\n\n```\nA friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\n\nx prefers u over y\nu prefers x over v\n```\n\nAnother way to think of it is\n\n\"X is unhappy if x is not paired with their first preference AND there exists another person who was not paired with x but prefers x over their current pairing\""
                    },
                    {
                        "username": "Lewis0511",
                        "content": "Here comes another unhappy friend. "
                    }
                ]
            },
            {
                "id": 1574398,
                "content": [
                    {
                        "username": "strommj",
                        "content": "It says the output should be 0, but it is 2."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "how?"
                    },
                    {
                        "username": "jingjing_334",
                        "content": "Had to use failed test case to reverse engineer the problem description. It\\'s a waste of time."
                    },
                    {
                        "username": "aakash_abhishek",
                        "content": "Why Bloomberg tagged questions are so hard to understand"
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "because their goal is to confuse you, not test your knowledge of coding!!!"
                    },
                    {
                        "username": "mo1ok",
                        "content": "I have no idea how the preference array works in this question. Are these preferences for individual friends, or are the preferences supposed to be aggregrated on the whole?\n\nIn the first example, there are two preference arrays:\n[1, 2, 3]\n[3, 2, 0]\n\nSo is 3 a preferred to 2, or is 3 inferior to 2? It makes no sense. Who ever wrote this question needs to get their head checked.\n\n\nEdit: after struggling with it, not mentioned in the problem is that the index of the preference list is relevant. So The preferences are the indivdual preferences of the friends - [1, 2, 3] at index 0 is the preference of friend 0."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Bad mood, bad problem. :("
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "language is too much confusing."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain this question?"
                    },
                    {
                        "username": "matthanwork",
                        "content": "You are given pairs of people. Each person has preferences as to who they would want to be partnered with. \\nPerson1 is paired with Person2. Person1 is unhappy if he prefers someone more than Person2 AND another person that he prefers more than Person2 is paired with someone who likes Person1 more than their current partner"
                    },
                    {
                        "username": "hammeramr",
                        "content": "I don't understand all the hate - the description was extremely clear - dense but clear - just read this line a few timea thats all you need\n\n```\nA friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\n\nx prefers u over y\nu prefers x over v\n```\n\nAnother way to think of it is\n\n\"X is unhappy if x is not paired with their first preference AND there exists another person who was not paired with x but prefers x over their current pairing\""
                    },
                    {
                        "username": "Lewis0511",
                        "content": "Here comes another unhappy friend. "
                    }
                ]
            },
            {
                "id": 1765280,
                "content": [
                    {
                        "username": "strommj",
                        "content": "It says the output should be 0, but it is 2."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "how?"
                    },
                    {
                        "username": "jingjing_334",
                        "content": "Had to use failed test case to reverse engineer the problem description. It\\'s a waste of time."
                    },
                    {
                        "username": "aakash_abhishek",
                        "content": "Why Bloomberg tagged questions are so hard to understand"
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "because their goal is to confuse you, not test your knowledge of coding!!!"
                    },
                    {
                        "username": "mo1ok",
                        "content": "I have no idea how the preference array works in this question. Are these preferences for individual friends, or are the preferences supposed to be aggregrated on the whole?\n\nIn the first example, there are two preference arrays:\n[1, 2, 3]\n[3, 2, 0]\n\nSo is 3 a preferred to 2, or is 3 inferior to 2? It makes no sense. Who ever wrote this question needs to get their head checked.\n\n\nEdit: after struggling with it, not mentioned in the problem is that the index of the preference list is relevant. So The preferences are the indivdual preferences of the friends - [1, 2, 3] at index 0 is the preference of friend 0."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Bad mood, bad problem. :("
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "language is too much confusing."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain this question?"
                    },
                    {
                        "username": "matthanwork",
                        "content": "You are given pairs of people. Each person has preferences as to who they would want to be partnered with. \\nPerson1 is paired with Person2. Person1 is unhappy if he prefers someone more than Person2 AND another person that he prefers more than Person2 is paired with someone who likes Person1 more than their current partner"
                    },
                    {
                        "username": "hammeramr",
                        "content": "I don't understand all the hate - the description was extremely clear - dense but clear - just read this line a few timea thats all you need\n\n```\nA friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\n\nx prefers u over y\nu prefers x over v\n```\n\nAnother way to think of it is\n\n\"X is unhappy if x is not paired with their first preference AND there exists another person who was not paired with x but prefers x over their current pairing\""
                    },
                    {
                        "username": "Lewis0511",
                        "content": "Here comes another unhappy friend. "
                    }
                ]
            },
            {
                "id": 1901501,
                "content": [
                    {
                        "username": "strommj",
                        "content": "It says the output should be 0, but it is 2."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "how?"
                    },
                    {
                        "username": "jingjing_334",
                        "content": "Had to use failed test case to reverse engineer the problem description. It\\'s a waste of time."
                    },
                    {
                        "username": "aakash_abhishek",
                        "content": "Why Bloomberg tagged questions are so hard to understand"
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "because their goal is to confuse you, not test your knowledge of coding!!!"
                    },
                    {
                        "username": "mo1ok",
                        "content": "I have no idea how the preference array works in this question. Are these preferences for individual friends, or are the preferences supposed to be aggregrated on the whole?\n\nIn the first example, there are two preference arrays:\n[1, 2, 3]\n[3, 2, 0]\n\nSo is 3 a preferred to 2, or is 3 inferior to 2? It makes no sense. Who ever wrote this question needs to get their head checked.\n\n\nEdit: after struggling with it, not mentioned in the problem is that the index of the preference list is relevant. So The preferences are the indivdual preferences of the friends - [1, 2, 3] at index 0 is the preference of friend 0."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Bad mood, bad problem. :("
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "language is too much confusing."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain this question?"
                    },
                    {
                        "username": "matthanwork",
                        "content": "You are given pairs of people. Each person has preferences as to who they would want to be partnered with. \\nPerson1 is paired with Person2. Person1 is unhappy if he prefers someone more than Person2 AND another person that he prefers more than Person2 is paired with someone who likes Person1 more than their current partner"
                    },
                    {
                        "username": "hammeramr",
                        "content": "I don't understand all the hate - the description was extremely clear - dense but clear - just read this line a few timea thats all you need\n\n```\nA friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\n\nx prefers u over y\nu prefers x over v\n```\n\nAnother way to think of it is\n\n\"X is unhappy if x is not paired with their first preference AND there exists another person who was not paired with x but prefers x over their current pairing\""
                    },
                    {
                        "username": "Lewis0511",
                        "content": "Here comes another unhappy friend. "
                    }
                ]
            },
            {
                "id": 1875276,
                "content": [
                    {
                        "username": "strommj",
                        "content": "It says the output should be 0, but it is 2."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "how?"
                    },
                    {
                        "username": "jingjing_334",
                        "content": "Had to use failed test case to reverse engineer the problem description. It\\'s a waste of time."
                    },
                    {
                        "username": "aakash_abhishek",
                        "content": "Why Bloomberg tagged questions are so hard to understand"
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "because their goal is to confuse you, not test your knowledge of coding!!!"
                    },
                    {
                        "username": "mo1ok",
                        "content": "I have no idea how the preference array works in this question. Are these preferences for individual friends, or are the preferences supposed to be aggregrated on the whole?\n\nIn the first example, there are two preference arrays:\n[1, 2, 3]\n[3, 2, 0]\n\nSo is 3 a preferred to 2, or is 3 inferior to 2? It makes no sense. Who ever wrote this question needs to get their head checked.\n\n\nEdit: after struggling with it, not mentioned in the problem is that the index of the preference list is relevant. So The preferences are the indivdual preferences of the friends - [1, 2, 3] at index 0 is the preference of friend 0."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Bad mood, bad problem. :("
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "language is too much confusing."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain this question?"
                    },
                    {
                        "username": "matthanwork",
                        "content": "You are given pairs of people. Each person has preferences as to who they would want to be partnered with. \\nPerson1 is paired with Person2. Person1 is unhappy if he prefers someone more than Person2 AND another person that he prefers more than Person2 is paired with someone who likes Person1 more than their current partner"
                    },
                    {
                        "username": "hammeramr",
                        "content": "I don't understand all the hate - the description was extremely clear - dense but clear - just read this line a few timea thats all you need\n\n```\nA friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\n\nx prefers u over y\nu prefers x over v\n```\n\nAnother way to think of it is\n\n\"X is unhappy if x is not paired with their first preference AND there exists another person who was not paired with x but prefers x over their current pairing\""
                    },
                    {
                        "username": "Lewis0511",
                        "content": "Here comes another unhappy friend. "
                    }
                ]
            },
            {
                "id": 1761121,
                "content": [
                    {
                        "username": "strommj",
                        "content": "It says the output should be 0, but it is 2."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "how?"
                    },
                    {
                        "username": "jingjing_334",
                        "content": "Had to use failed test case to reverse engineer the problem description. It\\'s a waste of time."
                    },
                    {
                        "username": "aakash_abhishek",
                        "content": "Why Bloomberg tagged questions are so hard to understand"
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "because their goal is to confuse you, not test your knowledge of coding!!!"
                    },
                    {
                        "username": "mo1ok",
                        "content": "I have no idea how the preference array works in this question. Are these preferences for individual friends, or are the preferences supposed to be aggregrated on the whole?\n\nIn the first example, there are two preference arrays:\n[1, 2, 3]\n[3, 2, 0]\n\nSo is 3 a preferred to 2, or is 3 inferior to 2? It makes no sense. Who ever wrote this question needs to get their head checked.\n\n\nEdit: after struggling with it, not mentioned in the problem is that the index of the preference list is relevant. So The preferences are the indivdual preferences of the friends - [1, 2, 3] at index 0 is the preference of friend 0."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Bad mood, bad problem. :("
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "language is too much confusing."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain this question?"
                    },
                    {
                        "username": "matthanwork",
                        "content": "You are given pairs of people. Each person has preferences as to who they would want to be partnered with. \\nPerson1 is paired with Person2. Person1 is unhappy if he prefers someone more than Person2 AND another person that he prefers more than Person2 is paired with someone who likes Person1 more than their current partner"
                    },
                    {
                        "username": "hammeramr",
                        "content": "I don't understand all the hate - the description was extremely clear - dense but clear - just read this line a few timea thats all you need\n\n```\nA friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\n\nx prefers u over y\nu prefers x over v\n```\n\nAnother way to think of it is\n\n\"X is unhappy if x is not paired with their first preference AND there exists another person who was not paired with x but prefers x over their current pairing\""
                    },
                    {
                        "username": "Lewis0511",
                        "content": "Here comes another unhappy friend. "
                    }
                ]
            },
            {
                "id": 1978112,
                "content": [
                    {
                        "username": "strommj",
                        "content": "It says the output should be 0, but it is 2."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "how?"
                    },
                    {
                        "username": "jingjing_334",
                        "content": "Had to use failed test case to reverse engineer the problem description. It\\'s a waste of time."
                    },
                    {
                        "username": "aakash_abhishek",
                        "content": "Why Bloomberg tagged questions are so hard to understand"
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "because their goal is to confuse you, not test your knowledge of coding!!!"
                    },
                    {
                        "username": "mo1ok",
                        "content": "I have no idea how the preference array works in this question. Are these preferences for individual friends, or are the preferences supposed to be aggregrated on the whole?\n\nIn the first example, there are two preference arrays:\n[1, 2, 3]\n[3, 2, 0]\n\nSo is 3 a preferred to 2, or is 3 inferior to 2? It makes no sense. Who ever wrote this question needs to get their head checked.\n\n\nEdit: after struggling with it, not mentioned in the problem is that the index of the preference list is relevant. So The preferences are the indivdual preferences of the friends - [1, 2, 3] at index 0 is the preference of friend 0."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Bad mood, bad problem. :("
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "language is too much confusing."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain this question?"
                    },
                    {
                        "username": "matthanwork",
                        "content": "You are given pairs of people. Each person has preferences as to who they would want to be partnered with. \\nPerson1 is paired with Person2. Person1 is unhappy if he prefers someone more than Person2 AND another person that he prefers more than Person2 is paired with someone who likes Person1 more than their current partner"
                    },
                    {
                        "username": "hammeramr",
                        "content": "I don't understand all the hate - the description was extremely clear - dense but clear - just read this line a few timea thats all you need\n\n```\nA friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\n\nx prefers u over y\nu prefers x over v\n```\n\nAnother way to think of it is\n\n\"X is unhappy if x is not paired with their first preference AND there exists another person who was not paired with x but prefers x over their current pairing\""
                    },
                    {
                        "username": "Lewis0511",
                        "content": "Here comes another unhappy friend. "
                    }
                ]
            },
            {
                "id": 1710995,
                "content": [
                    {
                        "username": "strommj",
                        "content": "It says the output should be 0, but it is 2."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "how?"
                    },
                    {
                        "username": "jingjing_334",
                        "content": "Had to use failed test case to reverse engineer the problem description. It\\'s a waste of time."
                    },
                    {
                        "username": "aakash_abhishek",
                        "content": "Why Bloomberg tagged questions are so hard to understand"
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "because their goal is to confuse you, not test your knowledge of coding!!!"
                    },
                    {
                        "username": "mo1ok",
                        "content": "I have no idea how the preference array works in this question. Are these preferences for individual friends, or are the preferences supposed to be aggregrated on the whole?\n\nIn the first example, there are two preference arrays:\n[1, 2, 3]\n[3, 2, 0]\n\nSo is 3 a preferred to 2, or is 3 inferior to 2? It makes no sense. Who ever wrote this question needs to get their head checked.\n\n\nEdit: after struggling with it, not mentioned in the problem is that the index of the preference list is relevant. So The preferences are the indivdual preferences of the friends - [1, 2, 3] at index 0 is the preference of friend 0."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Bad mood, bad problem. :("
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "language is too much confusing."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain this question?"
                    },
                    {
                        "username": "matthanwork",
                        "content": "You are given pairs of people. Each person has preferences as to who they would want to be partnered with. \\nPerson1 is paired with Person2. Person1 is unhappy if he prefers someone more than Person2 AND another person that he prefers more than Person2 is paired with someone who likes Person1 more than their current partner"
                    },
                    {
                        "username": "hammeramr",
                        "content": "I don't understand all the hate - the description was extremely clear - dense but clear - just read this line a few timea thats all you need\n\n```\nA friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\n\nx prefers u over y\nu prefers x over v\n```\n\nAnother way to think of it is\n\n\"X is unhappy if x is not paired with their first preference AND there exists another person who was not paired with x but prefers x over their current pairing\""
                    },
                    {
                        "username": "Lewis0511",
                        "content": "Here comes another unhappy friend. "
                    }
                ]
            },
            {
                "id": 2058569,
                "content": [
                    {
                        "username": "strommj",
                        "content": "It says the output should be 0, but it is 2."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "how?"
                    },
                    {
                        "username": "jingjing_334",
                        "content": "Had to use failed test case to reverse engineer the problem description. It\\'s a waste of time."
                    },
                    {
                        "username": "aakash_abhishek",
                        "content": "Why Bloomberg tagged questions are so hard to understand"
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "because their goal is to confuse you, not test your knowledge of coding!!!"
                    },
                    {
                        "username": "mo1ok",
                        "content": "I have no idea how the preference array works in this question. Are these preferences for individual friends, or are the preferences supposed to be aggregrated on the whole?\n\nIn the first example, there are two preference arrays:\n[1, 2, 3]\n[3, 2, 0]\n\nSo is 3 a preferred to 2, or is 3 inferior to 2? It makes no sense. Who ever wrote this question needs to get their head checked.\n\n\nEdit: after struggling with it, not mentioned in the problem is that the index of the preference list is relevant. So The preferences are the indivdual preferences of the friends - [1, 2, 3] at index 0 is the preference of friend 0."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Bad mood, bad problem. :("
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "language is too much confusing."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain this question?"
                    },
                    {
                        "username": "matthanwork",
                        "content": "You are given pairs of people. Each person has preferences as to who they would want to be partnered with. \\nPerson1 is paired with Person2. Person1 is unhappy if he prefers someone more than Person2 AND another person that he prefers more than Person2 is paired with someone who likes Person1 more than their current partner"
                    },
                    {
                        "username": "hammeramr",
                        "content": "I don't understand all the hate - the description was extremely clear - dense but clear - just read this line a few timea thats all you need\n\n```\nA friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\n\nx prefers u over y\nu prefers x over v\n```\n\nAnother way to think of it is\n\n\"X is unhappy if x is not paired with their first preference AND there exists another person who was not paired with x but prefers x over their current pairing\""
                    },
                    {
                        "username": "Lewis0511",
                        "content": "Here comes another unhappy friend. "
                    }
                ]
            },
            {
                "id": 2058286,
                "content": [
                    {
                        "username": "strommj",
                        "content": "It says the output should be 0, but it is 2."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "how?"
                    },
                    {
                        "username": "jingjing_334",
                        "content": "Had to use failed test case to reverse engineer the problem description. It\\'s a waste of time."
                    },
                    {
                        "username": "aakash_abhishek",
                        "content": "Why Bloomberg tagged questions are so hard to understand"
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "because their goal is to confuse you, not test your knowledge of coding!!!"
                    },
                    {
                        "username": "mo1ok",
                        "content": "I have no idea how the preference array works in this question. Are these preferences for individual friends, or are the preferences supposed to be aggregrated on the whole?\n\nIn the first example, there are two preference arrays:\n[1, 2, 3]\n[3, 2, 0]\n\nSo is 3 a preferred to 2, or is 3 inferior to 2? It makes no sense. Who ever wrote this question needs to get their head checked.\n\n\nEdit: after struggling with it, not mentioned in the problem is that the index of the preference list is relevant. So The preferences are the indivdual preferences of the friends - [1, 2, 3] at index 0 is the preference of friend 0."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Bad mood, bad problem. :("
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "language is too much confusing."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain this question?"
                    },
                    {
                        "username": "matthanwork",
                        "content": "You are given pairs of people. Each person has preferences as to who they would want to be partnered with. \\nPerson1 is paired with Person2. Person1 is unhappy if he prefers someone more than Person2 AND another person that he prefers more than Person2 is paired with someone who likes Person1 more than their current partner"
                    },
                    {
                        "username": "hammeramr",
                        "content": "I don't understand all the hate - the description was extremely clear - dense but clear - just read this line a few timea thats all you need\n\n```\nA friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\n\nx prefers u over y\nu prefers x over v\n```\n\nAnother way to think of it is\n\n\"X is unhappy if x is not paired with their first preference AND there exists another person who was not paired with x but prefers x over their current pairing\""
                    },
                    {
                        "username": "Lewis0511",
                        "content": "Here comes another unhappy friend. "
                    }
                ]
            },
            {
                "id": 1567600,
                "content": [
                    {
                        "username": "strommj",
                        "content": "It says the output should be 0, but it is 2."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "how?"
                    },
                    {
                        "username": "jingjing_334",
                        "content": "Had to use failed test case to reverse engineer the problem description. It\\'s a waste of time."
                    },
                    {
                        "username": "aakash_abhishek",
                        "content": "Why Bloomberg tagged questions are so hard to understand"
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "because their goal is to confuse you, not test your knowledge of coding!!!"
                    },
                    {
                        "username": "mo1ok",
                        "content": "I have no idea how the preference array works in this question. Are these preferences for individual friends, or are the preferences supposed to be aggregrated on the whole?\n\nIn the first example, there are two preference arrays:\n[1, 2, 3]\n[3, 2, 0]\n\nSo is 3 a preferred to 2, or is 3 inferior to 2? It makes no sense. Who ever wrote this question needs to get their head checked.\n\n\nEdit: after struggling with it, not mentioned in the problem is that the index of the preference list is relevant. So The preferences are the indivdual preferences of the friends - [1, 2, 3] at index 0 is the preference of friend 0."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Bad mood, bad problem. :("
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "language is too much confusing."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain this question?"
                    },
                    {
                        "username": "matthanwork",
                        "content": "You are given pairs of people. Each person has preferences as to who they would want to be partnered with. \\nPerson1 is paired with Person2. Person1 is unhappy if he prefers someone more than Person2 AND another person that he prefers more than Person2 is paired with someone who likes Person1 more than their current partner"
                    },
                    {
                        "username": "hammeramr",
                        "content": "I don't understand all the hate - the description was extremely clear - dense but clear - just read this line a few timea thats all you need\n\n```\nA friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\n\nx prefers u over y\nu prefers x over v\n```\n\nAnother way to think of it is\n\n\"X is unhappy if x is not paired with their first preference AND there exists another person who was not paired with x but prefers x over their current pairing\""
                    },
                    {
                        "username": "Lewis0511",
                        "content": "Here comes another unhappy friend. "
                    }
                ]
            },
            {
                "id": 1574398,
                "content": [
                    {
                        "username": "strommj",
                        "content": "It says the output should be 0, but it is 2."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "how?"
                    },
                    {
                        "username": "jingjing_334",
                        "content": "Had to use failed test case to reverse engineer the problem description. It\\'s a waste of time."
                    },
                    {
                        "username": "aakash_abhishek",
                        "content": "Why Bloomberg tagged questions are so hard to understand"
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "because their goal is to confuse you, not test your knowledge of coding!!!"
                    },
                    {
                        "username": "mo1ok",
                        "content": "I have no idea how the preference array works in this question. Are these preferences for individual friends, or are the preferences supposed to be aggregrated on the whole?\n\nIn the first example, there are two preference arrays:\n[1, 2, 3]\n[3, 2, 0]\n\nSo is 3 a preferred to 2, or is 3 inferior to 2? It makes no sense. Who ever wrote this question needs to get their head checked.\n\n\nEdit: after struggling with it, not mentioned in the problem is that the index of the preference list is relevant. So The preferences are the indivdual preferences of the friends - [1, 2, 3] at index 0 is the preference of friend 0."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Bad mood, bad problem. :("
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "language is too much confusing."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain this question?"
                    },
                    {
                        "username": "matthanwork",
                        "content": "You are given pairs of people. Each person has preferences as to who they would want to be partnered with. \\nPerson1 is paired with Person2. Person1 is unhappy if he prefers someone more than Person2 AND another person that he prefers more than Person2 is paired with someone who likes Person1 more than their current partner"
                    },
                    {
                        "username": "hammeramr",
                        "content": "I don't understand all the hate - the description was extremely clear - dense but clear - just read this line a few timea thats all you need\n\n```\nA friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\n\nx prefers u over y\nu prefers x over v\n```\n\nAnother way to think of it is\n\n\"X is unhappy if x is not paired with their first preference AND there exists another person who was not paired with x but prefers x over their current pairing\""
                    },
                    {
                        "username": "Lewis0511",
                        "content": "Here comes another unhappy friend. "
                    }
                ]
            },
            {
                "id": 1765280,
                "content": [
                    {
                        "username": "strommj",
                        "content": "It says the output should be 0, but it is 2."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "how?"
                    },
                    {
                        "username": "jingjing_334",
                        "content": "Had to use failed test case to reverse engineer the problem description. It\\'s a waste of time."
                    },
                    {
                        "username": "aakash_abhishek",
                        "content": "Why Bloomberg tagged questions are so hard to understand"
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "because their goal is to confuse you, not test your knowledge of coding!!!"
                    },
                    {
                        "username": "mo1ok",
                        "content": "I have no idea how the preference array works in this question. Are these preferences for individual friends, or are the preferences supposed to be aggregrated on the whole?\n\nIn the first example, there are two preference arrays:\n[1, 2, 3]\n[3, 2, 0]\n\nSo is 3 a preferred to 2, or is 3 inferior to 2? It makes no sense. Who ever wrote this question needs to get their head checked.\n\n\nEdit: after struggling with it, not mentioned in the problem is that the index of the preference list is relevant. So The preferences are the indivdual preferences of the friends - [1, 2, 3] at index 0 is the preference of friend 0."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Bad mood, bad problem. :("
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "language is too much confusing."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain this question?"
                    },
                    {
                        "username": "matthanwork",
                        "content": "You are given pairs of people. Each person has preferences as to who they would want to be partnered with. \\nPerson1 is paired with Person2. Person1 is unhappy if he prefers someone more than Person2 AND another person that he prefers more than Person2 is paired with someone who likes Person1 more than their current partner"
                    },
                    {
                        "username": "hammeramr",
                        "content": "I don't understand all the hate - the description was extremely clear - dense but clear - just read this line a few timea thats all you need\n\n```\nA friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\n\nx prefers u over y\nu prefers x over v\n```\n\nAnother way to think of it is\n\n\"X is unhappy if x is not paired with their first preference AND there exists another person who was not paired with x but prefers x over their current pairing\""
                    },
                    {
                        "username": "Lewis0511",
                        "content": "Here comes another unhappy friend. "
                    }
                ]
            },
            {
                "id": 1901501,
                "content": [
                    {
                        "username": "strommj",
                        "content": "It says the output should be 0, but it is 2."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "how?"
                    },
                    {
                        "username": "jingjing_334",
                        "content": "Had to use failed test case to reverse engineer the problem description. It\\'s a waste of time."
                    },
                    {
                        "username": "aakash_abhishek",
                        "content": "Why Bloomberg tagged questions are so hard to understand"
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "because their goal is to confuse you, not test your knowledge of coding!!!"
                    },
                    {
                        "username": "mo1ok",
                        "content": "I have no idea how the preference array works in this question. Are these preferences for individual friends, or are the preferences supposed to be aggregrated on the whole?\n\nIn the first example, there are two preference arrays:\n[1, 2, 3]\n[3, 2, 0]\n\nSo is 3 a preferred to 2, or is 3 inferior to 2? It makes no sense. Who ever wrote this question needs to get their head checked.\n\n\nEdit: after struggling with it, not mentioned in the problem is that the index of the preference list is relevant. So The preferences are the indivdual preferences of the friends - [1, 2, 3] at index 0 is the preference of friend 0."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Bad mood, bad problem. :("
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "language is too much confusing."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain this question?"
                    },
                    {
                        "username": "matthanwork",
                        "content": "You are given pairs of people. Each person has preferences as to who they would want to be partnered with. \\nPerson1 is paired with Person2. Person1 is unhappy if he prefers someone more than Person2 AND another person that he prefers more than Person2 is paired with someone who likes Person1 more than their current partner"
                    },
                    {
                        "username": "hammeramr",
                        "content": "I don't understand all the hate - the description was extremely clear - dense but clear - just read this line a few timea thats all you need\n\n```\nA friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\n\nx prefers u over y\nu prefers x over v\n```\n\nAnother way to think of it is\n\n\"X is unhappy if x is not paired with their first preference AND there exists another person who was not paired with x but prefers x over their current pairing\""
                    },
                    {
                        "username": "Lewis0511",
                        "content": "Here comes another unhappy friend. "
                    }
                ]
            },
            {
                "id": 1875276,
                "content": [
                    {
                        "username": "strommj",
                        "content": "It says the output should be 0, but it is 2."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "how?"
                    },
                    {
                        "username": "jingjing_334",
                        "content": "Had to use failed test case to reverse engineer the problem description. It\\'s a waste of time."
                    },
                    {
                        "username": "aakash_abhishek",
                        "content": "Why Bloomberg tagged questions are so hard to understand"
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "because their goal is to confuse you, not test your knowledge of coding!!!"
                    },
                    {
                        "username": "mo1ok",
                        "content": "I have no idea how the preference array works in this question. Are these preferences for individual friends, or are the preferences supposed to be aggregrated on the whole?\n\nIn the first example, there are two preference arrays:\n[1, 2, 3]\n[3, 2, 0]\n\nSo is 3 a preferred to 2, or is 3 inferior to 2? It makes no sense. Who ever wrote this question needs to get their head checked.\n\n\nEdit: after struggling with it, not mentioned in the problem is that the index of the preference list is relevant. So The preferences are the indivdual preferences of the friends - [1, 2, 3] at index 0 is the preference of friend 0."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Bad mood, bad problem. :("
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "language is too much confusing."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain this question?"
                    },
                    {
                        "username": "matthanwork",
                        "content": "You are given pairs of people. Each person has preferences as to who they would want to be partnered with. \\nPerson1 is paired with Person2. Person1 is unhappy if he prefers someone more than Person2 AND another person that he prefers more than Person2 is paired with someone who likes Person1 more than their current partner"
                    },
                    {
                        "username": "hammeramr",
                        "content": "I don't understand all the hate - the description was extremely clear - dense but clear - just read this line a few timea thats all you need\n\n```\nA friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\n\nx prefers u over y\nu prefers x over v\n```\n\nAnother way to think of it is\n\n\"X is unhappy if x is not paired with their first preference AND there exists another person who was not paired with x but prefers x over their current pairing\""
                    },
                    {
                        "username": "Lewis0511",
                        "content": "Here comes another unhappy friend. "
                    }
                ]
            },
            {
                "id": 1761121,
                "content": [
                    {
                        "username": "strommj",
                        "content": "It says the output should be 0, but it is 2."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "how?"
                    },
                    {
                        "username": "jingjing_334",
                        "content": "Had to use failed test case to reverse engineer the problem description. It\\'s a waste of time."
                    },
                    {
                        "username": "aakash_abhishek",
                        "content": "Why Bloomberg tagged questions are so hard to understand"
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "because their goal is to confuse you, not test your knowledge of coding!!!"
                    },
                    {
                        "username": "mo1ok",
                        "content": "I have no idea how the preference array works in this question. Are these preferences for individual friends, or are the preferences supposed to be aggregrated on the whole?\n\nIn the first example, there are two preference arrays:\n[1, 2, 3]\n[3, 2, 0]\n\nSo is 3 a preferred to 2, or is 3 inferior to 2? It makes no sense. Who ever wrote this question needs to get their head checked.\n\n\nEdit: after struggling with it, not mentioned in the problem is that the index of the preference list is relevant. So The preferences are the indivdual preferences of the friends - [1, 2, 3] at index 0 is the preference of friend 0."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Bad mood, bad problem. :("
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "language is too much confusing."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain this question?"
                    },
                    {
                        "username": "matthanwork",
                        "content": "You are given pairs of people. Each person has preferences as to who they would want to be partnered with. \\nPerson1 is paired with Person2. Person1 is unhappy if he prefers someone more than Person2 AND another person that he prefers more than Person2 is paired with someone who likes Person1 more than their current partner"
                    },
                    {
                        "username": "hammeramr",
                        "content": "I don't understand all the hate - the description was extremely clear - dense but clear - just read this line a few timea thats all you need\n\n```\nA friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\n\nx prefers u over y\nu prefers x over v\n```\n\nAnother way to think of it is\n\n\"X is unhappy if x is not paired with their first preference AND there exists another person who was not paired with x but prefers x over their current pairing\""
                    },
                    {
                        "username": "Lewis0511",
                        "content": "Here comes another unhappy friend. "
                    }
                ]
            },
            {
                "id": 1978112,
                "content": [
                    {
                        "username": "strommj",
                        "content": "It says the output should be 0, but it is 2."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "how?"
                    },
                    {
                        "username": "jingjing_334",
                        "content": "Had to use failed test case to reverse engineer the problem description. It\\'s a waste of time."
                    },
                    {
                        "username": "aakash_abhishek",
                        "content": "Why Bloomberg tagged questions are so hard to understand"
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "because their goal is to confuse you, not test your knowledge of coding!!!"
                    },
                    {
                        "username": "mo1ok",
                        "content": "I have no idea how the preference array works in this question. Are these preferences for individual friends, or are the preferences supposed to be aggregrated on the whole?\n\nIn the first example, there are two preference arrays:\n[1, 2, 3]\n[3, 2, 0]\n\nSo is 3 a preferred to 2, or is 3 inferior to 2? It makes no sense. Who ever wrote this question needs to get their head checked.\n\n\nEdit: after struggling with it, not mentioned in the problem is that the index of the preference list is relevant. So The preferences are the indivdual preferences of the friends - [1, 2, 3] at index 0 is the preference of friend 0."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Bad mood, bad problem. :("
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "language is too much confusing."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain this question?"
                    },
                    {
                        "username": "matthanwork",
                        "content": "You are given pairs of people. Each person has preferences as to who they would want to be partnered with. \\nPerson1 is paired with Person2. Person1 is unhappy if he prefers someone more than Person2 AND another person that he prefers more than Person2 is paired with someone who likes Person1 more than their current partner"
                    },
                    {
                        "username": "hammeramr",
                        "content": "I don't understand all the hate - the description was extremely clear - dense but clear - just read this line a few timea thats all you need\n\n```\nA friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\n\nx prefers u over y\nu prefers x over v\n```\n\nAnother way to think of it is\n\n\"X is unhappy if x is not paired with their first preference AND there exists another person who was not paired with x but prefers x over their current pairing\""
                    },
                    {
                        "username": "Lewis0511",
                        "content": "Here comes another unhappy friend. "
                    }
                ]
            },
            {
                "id": 1710995,
                "content": [
                    {
                        "username": "strommj",
                        "content": "It says the output should be 0, but it is 2."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "how?"
                    },
                    {
                        "username": "jingjing_334",
                        "content": "Had to use failed test case to reverse engineer the problem description. It\\'s a waste of time."
                    },
                    {
                        "username": "aakash_abhishek",
                        "content": "Why Bloomberg tagged questions are so hard to understand"
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "because their goal is to confuse you, not test your knowledge of coding!!!"
                    },
                    {
                        "username": "mo1ok",
                        "content": "I have no idea how the preference array works in this question. Are these preferences for individual friends, or are the preferences supposed to be aggregrated on the whole?\n\nIn the first example, there are two preference arrays:\n[1, 2, 3]\n[3, 2, 0]\n\nSo is 3 a preferred to 2, or is 3 inferior to 2? It makes no sense. Who ever wrote this question needs to get their head checked.\n\n\nEdit: after struggling with it, not mentioned in the problem is that the index of the preference list is relevant. So The preferences are the indivdual preferences of the friends - [1, 2, 3] at index 0 is the preference of friend 0."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Bad mood, bad problem. :("
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "language is too much confusing."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain this question?"
                    },
                    {
                        "username": "matthanwork",
                        "content": "You are given pairs of people. Each person has preferences as to who they would want to be partnered with. \\nPerson1 is paired with Person2. Person1 is unhappy if he prefers someone more than Person2 AND another person that he prefers more than Person2 is paired with someone who likes Person1 more than their current partner"
                    },
                    {
                        "username": "hammeramr",
                        "content": "I don't understand all the hate - the description was extremely clear - dense but clear - just read this line a few timea thats all you need\n\n```\nA friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\n\nx prefers u over y\nu prefers x over v\n```\n\nAnother way to think of it is\n\n\"X is unhappy if x is not paired with their first preference AND there exists another person who was not paired with x but prefers x over their current pairing\""
                    },
                    {
                        "username": "Lewis0511",
                        "content": "Here comes another unhappy friend. "
                    }
                ]
            },
            {
                "id": 2058569,
                "content": [
                    {
                        "username": "strommj",
                        "content": "It says the output should be 0, but it is 2."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "how?"
                    },
                    {
                        "username": "jingjing_334",
                        "content": "Had to use failed test case to reverse engineer the problem description. It\\'s a waste of time."
                    },
                    {
                        "username": "aakash_abhishek",
                        "content": "Why Bloomberg tagged questions are so hard to understand"
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "because their goal is to confuse you, not test your knowledge of coding!!!"
                    },
                    {
                        "username": "mo1ok",
                        "content": "I have no idea how the preference array works in this question. Are these preferences for individual friends, or are the preferences supposed to be aggregrated on the whole?\n\nIn the first example, there are two preference arrays:\n[1, 2, 3]\n[3, 2, 0]\n\nSo is 3 a preferred to 2, or is 3 inferior to 2? It makes no sense. Who ever wrote this question needs to get their head checked.\n\n\nEdit: after struggling with it, not mentioned in the problem is that the index of the preference list is relevant. So The preferences are the indivdual preferences of the friends - [1, 2, 3] at index 0 is the preference of friend 0."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Bad mood, bad problem. :("
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "language is too much confusing."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain this question?"
                    },
                    {
                        "username": "matthanwork",
                        "content": "You are given pairs of people. Each person has preferences as to who they would want to be partnered with. \\nPerson1 is paired with Person2. Person1 is unhappy if he prefers someone more than Person2 AND another person that he prefers more than Person2 is paired with someone who likes Person1 more than their current partner"
                    },
                    {
                        "username": "hammeramr",
                        "content": "I don't understand all the hate - the description was extremely clear - dense but clear - just read this line a few timea thats all you need\n\n```\nA friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\n\nx prefers u over y\nu prefers x over v\n```\n\nAnother way to think of it is\n\n\"X is unhappy if x is not paired with their first preference AND there exists another person who was not paired with x but prefers x over their current pairing\""
                    },
                    {
                        "username": "Lewis0511",
                        "content": "Here comes another unhappy friend. "
                    }
                ]
            },
            {
                "id": 2058286,
                "content": [
                    {
                        "username": "strommj",
                        "content": "It says the output should be 0, but it is 2."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "how?"
                    },
                    {
                        "username": "jingjing_334",
                        "content": "Had to use failed test case to reverse engineer the problem description. It\\'s a waste of time."
                    },
                    {
                        "username": "aakash_abhishek",
                        "content": "Why Bloomberg tagged questions are so hard to understand"
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "because their goal is to confuse you, not test your knowledge of coding!!!"
                    },
                    {
                        "username": "mo1ok",
                        "content": "I have no idea how the preference array works in this question. Are these preferences for individual friends, or are the preferences supposed to be aggregrated on the whole?\n\nIn the first example, there are two preference arrays:\n[1, 2, 3]\n[3, 2, 0]\n\nSo is 3 a preferred to 2, or is 3 inferior to 2? It makes no sense. Who ever wrote this question needs to get their head checked.\n\n\nEdit: after struggling with it, not mentioned in the problem is that the index of the preference list is relevant. So The preferences are the indivdual preferences of the friends - [1, 2, 3] at index 0 is the preference of friend 0."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Bad mood, bad problem. :("
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "language is too much confusing."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain this question?"
                    },
                    {
                        "username": "matthanwork",
                        "content": "You are given pairs of people. Each person has preferences as to who they would want to be partnered with. \\nPerson1 is paired with Person2. Person1 is unhappy if he prefers someone more than Person2 AND another person that he prefers more than Person2 is paired with someone who likes Person1 more than their current partner"
                    },
                    {
                        "username": "hammeramr",
                        "content": "I don't understand all the hate - the description was extremely clear - dense but clear - just read this line a few timea thats all you need\n\n```\nA friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\n\nx prefers u over y\nu prefers x over v\n```\n\nAnother way to think of it is\n\n\"X is unhappy if x is not paired with their first preference AND there exists another person who was not paired with x but prefers x over their current pairing\""
                    },
                    {
                        "username": "Lewis0511",
                        "content": "Here comes another unhappy friend. "
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Alternating Subsequence Sum",
        "question_content": "<p>The <strong>alternating sum</strong> of a <strong>0-indexed</strong> array is defined as the <strong>sum</strong> of the elements at <strong>even</strong> indices <strong>minus</strong> the <strong>sum</strong> of the elements at <strong>odd</strong> indices.</p>\r\n\r\n<ul>\r\n\t<li>For example, the alternating sum of <code>[4,2,5,3]</code> is <code>(4 + 5) - (2 + 3) = 4</code>.</li>\r\n</ul>\r\n\r\n<p>Given an array <code>nums</code>, return <em>the <strong>maximum alternating sum</strong> of any subsequence of </em><code>nums</code><em> (after <strong>reindexing</strong> the elements of the subsequence)</em>.</p>\r\n\r\n<ul>\r\n</ul>\r\n\r\n<p>A <strong>subsequence</strong> of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements&#39; relative order. For example, <code>[2,7,4]</code> is a subsequence of <code>[4,<u>2</u>,3,<u>7</u>,2,1,<u>4</u>]</code> (the underlined elements), while <code>[2,4,2]</code> is not.</p>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong class=\"example\">Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [<u>4</u>,<u>2</u>,<u>5</u>,3]\r\n<strong>Output:</strong> 7\r\n<strong>Explanation:</strong> It is optimal to choose the subsequence [4,2,5] with alternating sum (4 + 5) - 2 = 7.\r\n</pre>\r\n\r\n<p><strong class=\"example\">Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [5,6,7,<u>8</u>]\r\n<strong>Output:</strong> 8\r\n<strong>Explanation:</strong> It is optimal to choose the subsequence [8] with alternating sum 8.\r\n</pre>\r\n\r\n<p><strong class=\"example\">Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [<u>6</u>,2,<u>1</u>,2,4,<u>5</u>]\r\n<strong>Output:</strong> 10\r\n<strong>Explanation:</strong> It is optimal to choose the subsequence [6,1,5] with alternating sum (6 + 5) - 1 = 10.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Constraints:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\r\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\r\n</ul>",
        "solutions": [
            {
                "id": 1298499,
                "title": "java-c-python-best-time-to-buy-and-sell-stock",
                "content": "# **Solution 1: DP**\\nIt\\'s dp-like problem,\\nwe need to iterate the input `A`,\\nand keep two variable `odd` and `even`.\\n`even` means the maximum alternating sum ending with a even index\\n`odd` means the maximum alternating sum ending with a odd index\\n\\nFor each element `a` in `A`,\\nwe can update `even` from `odd + a`\\n`even = max(even, odd + a)`,\\nand the same we can update `odd` from `even - a`.\\n\\nNote that `even` ends with a positive,\\n`odd` end with a negative,\\nso we always have `even >= odd`\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public long maxAlternatingSum(int[] A) {\\n        long odd = 0, even = 0;\\n        for (int a: A) {\\n            even = Math.max(even, odd + a);\\n            odd = even - a;\\n        }\\n        return even;\\n    }\\n```\\n**C++**\\n```cpp\\n    long long maxAlternatingSum(vector<int>& A) {\\n        long long odd = 0, even = 0;\\n        for (int& a: A)\\n            even = max(even, odd + a),\\n            odd = even - a;\\n        return even;\\n    }\\n```\\n**Python**\\n```py\\n    def maxAlternatingSum(self, A):\\n        odd = even = 0\\n        for a in A:\\n            odd, even = [max(odd, even - a), max(even, odd + a)]\\n        return even\\n```\\n<br>\\n\\n# **Solution 2: Best Time to Buy and Sell Stock LEE**\\nImagin there is a digital coin, let\\'s say lee coin.\\nIf you continue reading to this line,\\nlee215 give you one for free.\\nThe contraint is that everyone can only hold at most 1 coin.\\n\\nNow we know that the input `A` is the prices\\nfor this coin in the future.\\nYou want to maximize you profit.\\n\\nYou want to sell at the most high point\\nand then buy in at a low price today.\\n\\nThis is almost exactly same the easy tag problem:\\n[122. Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/discuss/1298585/JavaC%2B%2BPython-Easy-and-Concise)\\n\\nTime `O(n)`, Space `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public long maxAlternatingSum(int[] A) {\\n        long res = A[0];\\n        for (int i = 1; i < A.length; ++i)\\n            res += Math.max(A[i] - A[i-1], 0);\\n        return res;\\n    }\\n```\\n**C++**\\n```cpp\\n    long long maxAlternatingSum(vector<int>& A) {\\n        long res = A[0];\\n        for (int i = 1; i < A.size(); ++i)\\n            res += max(A[i] - A[i-1], 0);\\n        return res;\\n    }\\n```\\n**Python**\\n```py\\n    def maxAlternatingSum(self, A):\\n        return sum(max(A[i] - A[i - 1], 0) for i in xrange(1, len(A))) + A[0]\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public long maxAlternatingSum(int[] A) {\\n        long odd = 0, even = 0;\\n        for (int a: A) {\\n            even = Math.max(even, odd + a);\\n            odd = even - a;\\n        }\\n        return even;\\n    }\\n```\n```cpp\\n    long long maxAlternatingSum(vector<int>& A) {\\n        long long odd = 0, even = 0;\\n        for (int& a: A)\\n            even = max(even, odd + a),\\n            odd = even - a;\\n        return even;\\n    }\\n```\n```py\\n    def maxAlternatingSum(self, A):\\n        odd = even = 0\\n        for a in A:\\n            odd, even = [max(odd, even - a), max(even, odd + a)]\\n        return even\\n```\n```java\\n    public long maxAlternatingSum(int[] A) {\\n        long res = A[0];\\n        for (int i = 1; i < A.length; ++i)\\n            res += Math.max(A[i] - A[i-1], 0);\\n        return res;\\n    }\\n```\n```cpp\\n    long long maxAlternatingSum(vector<int>& A) {\\n        long res = A[0];\\n        for (int i = 1; i < A.size(); ++i)\\n            res += max(A[i] - A[i-1], 0);\\n        return res;\\n    }\\n```\n```py\\n    def maxAlternatingSum(self, A):\\n        return sum(max(A[i] - A[i - 1], 0) for i in xrange(1, len(A))) + A[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1298610,
                "title": "intitutive-and-easy-recursion-memoization-solution-detailed-explanation",
                "content": "1. **Recursive Intuition**\\n\\t* At a each given index, we can either **choose this** element and call the next index with an opposite sign.\\n\\t* Or we can **not choose** this element and call the next index with the same sign as the one which was passed to current index.\\n\\t* The answer now will simply be the max of these returned two values.\\n\\t* We use **isPos** to signify isPositive sign, which, if false, will mean that sign is **negative.**  \\n2. **Adding Memoization**\\n\\t* We observe that in each function call, only two variables change: **isPos** & the index **i**.\\n\\t* Hence, as we\\'re making choices at each step, which can end up leading to the same subproblem in further steps, we must optimize our approach by maintaining a **2-D** DP table of dimensions `2, (nums).size`, which at max, can be 10^5.\\n\\t* Thus, we now simply add memoization with the traditional `intial value = -1` approach.\\n```\\nclass Solution {\\npublic:\\n    long long dp[2][100001];\\n    long long util(int i, vector<int>&nums, bool isPos){\\n        if(i>=nums.size())return 0;\\n        if(dp[isPos][i]!=-1)return dp[isPos][i];\\n        long long curr = (isPos?nums[i]:-1*nums[i]);\\n        return dp[isPos][i] = max(curr + util(i+1, nums, !isPos), util(i+1, nums, isPos));\\n    }\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        memset(dp, -1, sizeof(dp));\\n        return util(0, nums, true);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[2][100001];\\n    long long util(int i, vector<int>&nums, bool isPos){\\n        if(i>=nums.size())return 0;\\n        if(dp[isPos][i]!=-1)return dp[isPos][i];\\n        long long curr = (isPos?nums[i]:-1*nums[i]);\\n        return dp[isPos][i] = max(curr + util(i+1, nums, !isPos), util(i+1, nums, isPos));\\n    }\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        memset(dp, -1, sizeof(dp));\\n        return util(0, nums, true);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298450,
                "title": "c-dp-o-n-time-o-1-space",
                "content": "## Solution 1. DP\\n\\n**Intuition**: The brute force way is enumerating all the `2^N` subsequences which has lots of repetitive computation. Given the first `i + 1` elements `A[0...i]`, the greatest alternating subsequence sum is a fixed value, we can memoize it and keep extending `i`. So we should use Dynamic Programming.\\n\\n**Algorithm**:\\n\\nLet `dp[i+1][0]` and `dp[i+1][1]` be the maximum alternating subsequence sum of the first `i + 1` elements `A[0...i]` where the last element in the subsequence is even-indexed and odd-indexed, respectively.\\n\\n```\\ndp[i+1][0] = max(\\n                    dp[i][1] + A[i],  // if we pick A[i] as the last even-indexed number\\n                    dp[i][0]          // otherwise\\n                )\\ndp[i+1][1] = max(\\n                    dp[i][0] - A[i],  // if we pick A[i] as the last odd-indexed number\\n                    dp[i][1]          // otherwise\\n                )\\n\\ndp[0][0] = dp[0][1] = 0\\n```\\n\\nThe answer must has odd number of elements, so must be `dp[N][0]`.\\n\\nSince `dp[i+1][?]` is only dependent on `dp[i][?]`, instead of using an `N x 2` array, we can simply using a `1 x 2` array to store the DP values.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/biweekly-contest-55/problems/maximum-alternating-subsequence-sum/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\n    typedef long long LL;\\npublic:\\n    long long maxAlternatingSum(vector<int>& A) {\\n        LL N = A.size(), dp[2] = {};\\n        for (int i = 0; i < N; ++i) {\\n            LL next[2] = {};\\n            next[0] = max(dp[1] + A[i], dp[0]);\\n            next[1] = max(dp[0] - A[i], dp[1]);\\n            swap(next, dp);\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ndp[i+1][0] = max(\\n                    dp[i][1] + A[i],  // if we pick A[i] as the last even-indexed number\\n                    dp[i][0]          // otherwise\\n                )\\ndp[i+1][1] = max(\\n                    dp[i][0] - A[i],  // if we pick A[i] as the last odd-indexed number\\n                    dp[i][1]          // otherwise\\n                )\\n\\ndp[0][0] = dp[0][1] = 0\\n```\n```cpp\\n// OJ: https://leetcode.com/contest/biweekly-contest-55/problems/maximum-alternating-subsequence-sum/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\n    typedef long long LL;\\npublic:\\n    long long maxAlternatingSum(vector<int>& A) {\\n        LL N = A.size(), dp[2] = {};\\n        for (int i = 0; i < N; ++i) {\\n            LL next[2] = {};\\n            next[0] = max(dp[1] + A[i], dp[0]);\\n            next[1] = max(dp[0] - A[i], dp[1]);\\n            swap(next, dp);\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298466,
                "title": "python-short-and-easy-dp-explained",
                "content": "This is nice and easy dynamic programming problem. Let `dp1[k]` be the maximum Alternating Subsequence Sum if we reached element with index `i` and the last element we taken was with negative sign. `dp2[k]` means that last element we taken was with positive sign. Then to update elements we have two options:\\n1. For `dp1[k]` we need to check `dp1[k-1]` and `dp2[k-1] - nums[k]`, because last sign was `+` and if we take `nums[k]`, we need to take it with minus sign.\\n2. For `dp2[k]` we need to check `dp2[k-1]` and `dp1[k-1] + nums[k]`, because last sign was `-` and if we take `nums[k]`, we need to take it with plus sign.\\n\\n#### Complexity\\nTime complexity is `O(n)`, space complexity as well. Note, that space complexity can be reduced to `O(1)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def maxAlternatingSum(self, nums):\\n        n = len(nums)\\n        dp1, dp2 = [0]*(n+1), [0]*(n+1)\\n\\n        for k in range(n):\\n            dp1[k] = max(dp2[k-1] - nums[k], dp1[k-1])\\n            dp2[k] = max(dp1[k-1] + nums[k], dp2[k-1])\\n        \\n        return max(dp1[-2], dp2[-2])\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def maxAlternatingSum(self, nums):\\n        n = len(nums)\\n        dp1, dp2 = [0]*(n+1), [0]*(n+1)\\n\\n        for k in range(n):\\n            dp1[k] = max(dp2[k-1] - nums[k], dp1[k-1])\\n            dp2[k] = max(dp1[k-1] + nums[k], dp2[k-1])\\n        \\n        return max(dp1[-2], dp2[-2])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298431,
                "title": "greedy-vs-dp",
                "content": "I felt this can be solved using DP, but it somehow was easier for me to worn on a greedy approach. A benefit of this solution is that it tells you which elements to pick, and result in the smallest resulting array.\\n\\nThen, I realized that odd/even positions are only there to obstruct the idea that we just need to pick up all slack between any two elements. This is similar to [Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/); we just need to do the oposite (sell highs then buy lows), and we do not need to buy in the end.\\n\\n#### Approach 1: Greedy\\nWe pick the largest available number is the odd position, and then smallest available - in the even position.\\n\\n**C++**\\n```cpp\\nlong long maxAlternatingSum(vector<int>& nums) {\\n    vector<int> p{nums[0]}, n;\\n    for (int i = 1; i < nums.size(); ++i) {\\n        if (p.size() > n.size()) {\\n            if (p.back() <= nums[i])\\n                p.back() = nums[i];\\n            else\\n                n.push_back(nums[i]);\\n        }\\n        else {\\n            if (n.back() >= nums[i])\\n                n.back() = nums[i];\\n            else\\n                p.push_back(nums[i]);\\n        }\\n    }\\n    return accumulate(begin(p), end(p), 0ll) - accumulate(begin(n), end(n) - (p.size() == n.size()), 0ll);\\n}\\n```\\n#### Approach 2: Best Time to Buy and Sell Stock II\\n**C++**\\n```cpp\\nlong long maxAlternatingSum(vector<int>& n) {\\n  long long res = 0;\\n  for (int i = 1; i < n.size(); ++i) \\n      res += max(0, n[i - 1] - n[i]);\\n  return res + n.back();\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nlong long maxAlternatingSum(vector<int>& nums) {\\n    vector<int> p{nums[0]}, n;\\n    for (int i = 1; i < nums.size(); ++i) {\\n        if (p.size() > n.size()) {\\n            if (p.back() <= nums[i])\\n                p.back() = nums[i];\\n            else\\n                n.push_back(nums[i]);\\n        }\\n        else {\\n            if (n.back() >= nums[i])\\n                n.back() = nums[i];\\n            else\\n                p.push_back(nums[i]);\\n        }\\n    }\\n    return accumulate(begin(p), end(p), 0ll) - accumulate(begin(n), end(n) - (p.size() == n.size()), 0ll);\\n}\\n```\n```cpp\\nlong long maxAlternatingSum(vector<int>& n) {\\n  long long res = 0;\\n  for (int i = 1; i < n.size(); ++i) \\n      res += max(0, n[i - 1] - n[i]);\\n  return res + n.back();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1298606,
                "title": "python-easy-to-understand-explained-o-n-time-and-o-1-space",
                "content": "![image](https://assets.leetcode.com/users/images/cb103d5d-7499-4702-845d-ba5fc7652430_1624724089.8218975.png)\\n\\n```\\nclass Solution:\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\n        ans = 0\\n        direction = \\'down\\'\\n        n = len(nums)\\n        for i in range(n-1):\\n            if direction == \\'down\\' and nums[i] >= nums[i+1]:\\n                ans += nums[i]\\n                direction = \\'up\\'\\n            elif direction == \\'up\\' and nums[i] <= nums[i+1]:\\n                ans -= nums[i]\\n                direction = \\'down\\'\\n        if direction == \\'up\\':\\n            return ans\\n        return ans + nums[-1]\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\n        ans = 0\\n        direction = \\'down\\'\\n        n = len(nums)\\n        for i in range(n-1):\\n            if direction == \\'down\\' and nums[i] >= nums[i+1]:\\n                ans += nums[i]\\n                direction = \\'up\\'\\n            elif direction == \\'up\\' and nums[i] <= nums[i+1]:\\n                ans -= nums[i]\\n                direction = \\'down\\'\\n        if direction == \\'up\\':\\n            return ans\\n        return ans + nums[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298455,
                "title": "c-easy-greedy-solution-w-explanation-o-n-o-1-complexity",
                "content": "\\u2714\\uFE0F ***Solution - I (Pick Local Maxima)***\\n\\nWe can pick all the elements which are local maxima, meaning both its adjacent elements are smaller or equal to  itself. We will pick whichever is the minimum element between two local maximas. We can observe that this process will always pick an element at its highest point and sell at the lowest point between two maximums.\\n\\n```\\nlong long maxAlternatingSum(vector<int>& nums) {\\n\\tlong long ans = 0, MIN=0;\\n\\tnums.insert(begin(nums), -1e6); nums.push_back(-1e6);  // add elements at start and end to avoid bounds checks\\n\\tfor(int i = 1; i < size(nums)-1; i++, MIN=min(int(MIN), nums[i])) \\n\\t\\tif(nums[i] >= nums[i-1] and nums[i] >= nums[i+1])  // local maxima\\n\\t\\t\\tans += nums[i]-MIN, MIN = 1e6;                 // pick the element and reset MIN\\n\\treturn ans;\\n}\\n```\\t\\n\\n***Time Complexity :*** **`O(n)`**\\n***Space Complexity :*** **`O(1)`**\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nlong long maxAlternatingSum(vector<int>& nums) {\\n\\tlong long ans = 0, MIN=0;\\n\\tnums.insert(begin(nums), -1e6); nums.push_back(-1e6);  // add elements at start and end to avoid bounds checks\\n\\tfor(int i = 1; i < size(nums)-1; i++, MIN=min(int(MIN), nums[i])) \\n\\t\\tif(nums[i] >= nums[i-1] and nums[i] >= nums[i+1])  // local maxima\\n\\t\\t\\tans += nums[i]-MIN, MIN = 1e6;                 // pick the element and reset MIN\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1945208,
                "title": "very-easy-c-intuitive-solution-develop-intuition-linear-time-constant-space",
                "content": "# **INTUITION ALERT!!** Get the best answer till previous index and compute answer to your current index, Bingo!!\\n\\n* In most of the questions where we work on all the sub-sequences of the array or string, try getting the best answer for all possible options till previous index and using it compute the  answer for current index.\\n* Like in this question, best answer is maximum possible alternating sum and possible options are that the sequence can be of odd or even length.\\n* So we compute max possible alternating sum for even length subsequence till prev index ( `prevMaxEven`) and max possible alternating sum for even length subsequence till prev index (`prevMaxOdd` ).\\n* To find answer for current index **USE YOUR BRAIN !! I have given you the intuition :)**\\n* Also the fact that at each index we are not neccesarily including element at that index in our best sub-sequence makes us explore all possible subsequence. It took me time to get over the fact that no subsequence gets missed which is more evident in non-optimal recursive approach. This line of code does that : (`prevMaxOdd = max(prevMaxOdd, prevMaxEven + nums[i]); prevMaxEven = max(prevMaxEven, temp - nums[i]);)` \\n\\n\\n```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        \\n        long long int prevMaxOdd = 0, prevMaxEven = 0, temp;\\n        \\n        int n = nums.size();\\n        \\n        prevMaxOdd = nums[0];\\n        \\n        for(int i = 1; i < n ; i++){\\n            \\n            temp = prevMaxOdd;\\n            \\n            prevMaxOdd = max(prevMaxOdd, prevMaxEven + nums[i]);\\n            \\n            prevMaxEven = max(prevMaxEven, temp - nums[i]);\\n            \\n        }\\n        \\n        return prevMaxOdd);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        \\n        long long int prevMaxOdd = 0, prevMaxEven = 0, temp;\\n        \\n        int n = nums.size();\\n        \\n        prevMaxOdd = nums[0];\\n        \\n        for(int i = 1; i < n ; i++){\\n            \\n            temp = prevMaxOdd;\\n            \\n            prevMaxOdd = max(prevMaxOdd, prevMaxEven + nums[i]);\\n            \\n            prevMaxEven = max(prevMaxEven, temp - nums[i]);\\n            \\n        }\\n        \\n        return prevMaxOdd);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298652,
                "title": "c-easy-solution-maintain-min-max-heaps",
                "content": "Explanation:\\nFor an element at index i we will store min possible answer we can get by including that element and maximum possible answer we can get including that element.\\nWe know that,\\nfor j= i+1 to n\\nmin_answer[i]=min(nums[i],nums[i]-max_answer[j])\\nfor j=i+1 to n\\nmax_answer[i]=max(nums[i],nums[i]-min_answer[j])\\n\\nif we traverse from back, we can keep track of min(min_answer(from i+1 to n)) and max(max_answer(from i+1 to n)) by maintaing max and min heaps respectively ( priority_queue data structure in c++).\\n\\nImplementation:\\n\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        priority_queue<ll>a; \\n         priority_queue<ll, vector<ll>, greater<ll> > b;\\n        a.push(nums.back());\\n        b.push(nums.back());//max and min answers that can be achieved by last element will be element itself\\n        for(int i=nums.size()-2;i>=0;i--)\\n        {\\n            ll x=nums[i]-b.top(); //current element - minimum answer till now\\n            ll y=nums[i]-a.top(); // current element - maximum answer till now\\n            a.push(max(x,(ll)nums[i]));\\n            b.push(min(y,(ll)nums[i]));\\n        }\\n        return a.top(); // maximum after at end of traversal\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        priority_queue<ll>a; \\n         priority_queue<ll, vector<ll>, greater<ll> > b;\\n        a.push(nums.back());\\n        b.push(nums.back());//max and min answers that can be achieved by last element will be element itself\\n        for(int i=nums.size()-2;i>=0;i--)\\n        {\\n            ll x=nums[i]-b.top(); //current element - minimum answer till now\\n            ll y=nums[i]-a.top(); // current element - maximum answer till now\\n            a.push(max(x,(ll)nums[i]));\\n            b.push(min(y,(ll)nums[i]));\\n        }\\n        return a.top(); // maximum after at end of traversal\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298562,
                "title": "dp-is-easy-c-beginner-approach",
                "content": "**WARNING**: This will not be a tabulated, perfectly optimized DP solution. We have enough of those.\\n\\n**Inspiration**: (Optional) Go through this to get idea of approach [Target Sum discussion](https://leetcode.com/problems/target-sum/discuss/455024/DP-IS-EASY!-5-Steps-to-Think-Through-DP-Questions)\\n\\n**Algorithm**\\n1. We start at position 0 in ```nums```.\\n2. At each position we may ```choose``` or ```notchoose``` the number at that position.\\n3. We also maintain an ```iseven``` flag which signifies if the current position in our subsequence is even or not (i.e odd).\\n4. If current position is even we can either ```choose``` the number like this ```nums[pos] + help(pos+1, false)``` (notice how we set ```iseven = false``` to signify next step (i.e pos+1) will be an odd position) or ```notchoose``` the number like this ```help(pos+1, true)```. In both cases we go to the next position using pos+1 and set iseven accordingly.\\n5. If current position is odd we can either ```choose``` the number like this ```-nums[pos] + help(pos+1, true)``` or ```notchoose``` the number like this ```help(pos+1, false)```. In both cases we go to the next position using pos+1 and set iseven accordingly.\\n6. We take maximum of ```choose``` and ```notchoose```\\n\\n**Code**\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> a;\\n    vector<vector<ll>> dp;\\n    ll maxAlternatingSum(vector<int>& nums) {\\n        n = nums.size();\\n        a = nums;\\n        dp = vector<vector<ll>>(n, vector<ll>(2, -1));\\n        ll ans = help(0, true);\\n        return ans;\\n    }\\n    \\n    ll help(int pos, bool iseven){\\n        if(pos == n){\\n            return 0;\\n        }\\n        \\n        if(dp[pos][iseven] != -1){\\n            return dp[pos][iseven];\\n        }\\n        \\n        ll ans = 0;\\n        if(iseven){\\n            ll choose = (ll) a[pos] + help(pos+1, false);\\n            ll notchoose = help(pos+1, true);\\n            ans = max(choose, notchoose);\\n        }\\n        else{\\n            ll choose = (ll)-a[pos] + help(pos+1, true);\\n            ll notchoose = help(pos+1, false);\\n            ans = max(choose, notchoose);\\n        }\\n        \\n        return dp[pos][iseven] = ans;\\n    }\\n};\\n```\\n\\nPlease stop posting 4-5 lines of tabulated solutions **without explanations**.\\nThanks",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```nums```\n```choose```\n```notchoose```\n```iseven```\n```choose```\n```nums[pos] + help(pos+1, false)```\n```iseven = false```\n```notchoose```\n```help(pos+1, true)```\n```choose```\n```-nums[pos] + help(pos+1, true)```\n```notchoose```\n```help(pos+1, false)```\n```choose```\n```notchoose```\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> a;\\n    vector<vector<ll>> dp;\\n    ll maxAlternatingSum(vector<int>& nums) {\\n        n = nums.size();\\n        a = nums;\\n        dp = vector<vector<ll>>(n, vector<ll>(2, -1));\\n        ll ans = help(0, true);\\n        return ans;\\n    }\\n    \\n    ll help(int pos, bool iseven){\\n        if(pos == n){\\n            return 0;\\n        }\\n        \\n        if(dp[pos][iseven] != -1){\\n            return dp[pos][iseven];\\n        }\\n        \\n        ll ans = 0;\\n        if(iseven){\\n            ll choose = (ll) a[pos] + help(pos+1, false);\\n            ll notchoose = help(pos+1, true);\\n            ans = max(choose, notchoose);\\n        }\\n        else{\\n            ll choose = (ll)-a[pos] + help(pos+1, true);\\n            ll notchoose = help(pos+1, false);\\n            ans = max(choose, notchoose);\\n        }\\n        \\n        return dp[pos][iseven] = ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298878,
                "title": "c-recursion-memoization-explained",
                "content": "In this question at every element we have a choice of whether to include that element or not, if we decide to include it we\\'ll also have to see at which position we are entering it, even or odd, to keep that track I\\'m using chance variable. \\n\\nIt is also evident that there will be repeating sub-structures which forms the basis of dynamic programming. We are only changing variable i and variable chance so 2 dimensional DP would suffice.\\n```\\nclass Solution {\\npublic:\\n    long long int calc(vector<int>&nums, int i,int chance,vector<vector<long long int>>&dp)\\n    {\\n        if(i==nums.size())\\n            return 0;\\n        if(dp[i][chance]!=-1)\\n            return dp[i][chance];\\n        if(chance==1)\\n        {\\n            long long int a=nums[i]+calc(nums,i+1,0,dp);\\n            long long int b=calc(nums,i+1,chance,dp);\\n            return dp[i][chance]=max(a,b);\\n        }\\n        long long int a=calc(nums,i+1,1,dp)-nums[i];\\n        long long int b=calc(nums,i+1,chance,dp);\\n        return dp[i][chance]=max(a,b);\\n    }\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        vector<vector<long long int>>dp(nums.size()+2,vector<long long int>(2,-1));\\n        return calc(nums,0,1,dp);\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long int calc(vector<int>&nums, int i,int chance,vector<vector<long long int>>&dp)\\n    {\\n        if(i==nums.size())\\n            return 0;\\n        if(dp[i][chance]!=-1)\\n            return dp[i][chance];\\n        if(chance==1)\\n        {\\n            long long int a=nums[i]+calc(nums,i+1,0,dp);\\n            long long int b=calc(nums,i+1,chance,dp);\\n            return dp[i][chance]=max(a,b);\\n        }\\n        long long int a=calc(nums,i+1,1,dp)-nums[i];\\n        long long int b=calc(nums,i+1,chance,dp);\\n        return dp[i][chance]=max(a,b);\\n    }\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        vector<vector<long long int>>dp(nums.size()+2,vector<long long int>(2,-1));\\n        return calc(nums,0,1,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298626,
                "title": "simple-java-solution-explained",
                "content": "Find the maximum alternating sum of a subsequence in a given array of positive elements.\\n\\nThe idea here is to find the difference of local maxima (sum of peaks) and the local mimima (sum of lows) at every point.\\nTo obtain the maximum difference between the sum of alteranting numbers, the following input array can be visulalized as,\\n\\narr = [4,2,5,3]\\n```\\n|                              5\\n|        4                    /\\\\\\n|       /\\\\                  /   \\\\         3\\n|     /   \\\\        2      /      \\\\       /\\\\\\n|   /       \\\\     /\\\\    /         \\\\    /   \\\\\\n| /           \\\\ /    \\\\/             \\\\/      \\\\\\n--------------------------------------------------\\n\\nThe possible subsequences are,\\n\\n\\tSUM           SEQUENCE\\n\\t4        \\t   4\\n\\t2\\t\\t       4-2\\n\\t7\\t\\t       4-2+5\\n\\t4\\t\\t       4-2+5-3\\n```\\n\\nThe time complexity for this solution is O(N) and the space complexity is O(1)\\n\\n```\\npublic long maxAlternatingSum(int[] nums) {\\n        long peak = 0;\\n        long low = 0;\\n        long ans = 0;\\n\\t\\t\\n        for(int i=0; i<nums.length-1;) {            \\n            while(i<nums.length-1 && nums[i] <= nums[i+1]) {\\n                i++;\\n            }\\n\\t\\t\\t// Found peak\\n            peak += nums[i];\\n            ans = Math.max(ans, peak - low);\\n\\t\\t\\t\\n            int j=i;\\n            while(j<nums.length-1 && nums[j] >= nums[j+1]) {\\n                j++;\\n            }\\n            \\n            if(i != j) {\\n                // Found low\\n                low += nums[j];\\n                i = j;\\n            }\\n            \\n            ans = Math.max(ans, peak - low);\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n|                              5\\n|        4                    /\\\\\\n|       /\\\\                  /   \\\\         3\\n|     /   \\\\        2      /      \\\\       /\\\\\\n|   /       \\\\     /\\\\    /         \\\\    /   \\\\\\n| /           \\\\ /    \\\\/             \\\\/      \\\\\\n--------------------------------------------------\\n\\nThe possible subsequences are,\\n\\n\\tSUM           SEQUENCE\\n\\t4        \\t   4\\n\\t2\\t\\t       4-2\\n\\t7\\t\\t       4-2+5\\n\\t4\\t\\t       4-2+5-3\\n```\n```\\npublic long maxAlternatingSum(int[] nums) {\\n        long peak = 0;\\n        long low = 0;\\n        long ans = 0;\\n\\t\\t\\n        for(int i=0; i<nums.length-1;) {            \\n            while(i<nums.length-1 && nums[i] <= nums[i+1]) {\\n                i++;\\n            }\\n\\t\\t\\t// Found peak\\n            peak += nums[i];\\n            ans = Math.max(ans, peak - low);\\n\\t\\t\\t\\n            int j=i;\\n            while(j<nums.length-1 && nums[j] >= nums[j+1]) {\\n                j++;\\n            }\\n            \\n            if(i != j) {\\n                // Found low\\n                low += nums[j];\\n                i = j;\\n            }\\n            \\n            ans = Math.max(ans, peak - low);\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2167909,
                "title": "dp-and-dfs-very-clearly-explained-o-n-time",
                "content": "***Solution 1: Dynamic Programming***\\n\\n**Intuition**\\nWe can use DP (dynamic programming) to loop through nums and find the biggest alternating subsequence num.\\n\\n**Algorithm**\\nWe first initialize a `n` by `2` matrix where `n = len(nums)`. In a supposed index of `dp[i][j]`, `i` stands for the index of `dp` based on the such index of `nums` given from the input, while `j` stands for whether we add or subtract a number for the last value. If `j == 0`, then we add, if `j==1`, then we subtract. This means `dp[i][0]` means that we have a plus for the last value, while `dp[i][1]` means we have a minus for the last value. Before we start the iteration, we need to pre-define `dp[0][0]` as `nums[0]` as the index is both `0`. We also need to pre-define `dp[0][1]` as `0` since we have to start by adding given the question, thus we put 0.\\n\\nNext, we iterate through `nums` in a range for loop from index `1` to `n`, we start on index `1` instead of `0` because index `0` is already pre-defined. Each iteration, we try either to choose (meaning we choose to go or continue to add/subtract) or not choose (meaning we continue iterating through the array without making an alternating subsequence) for when the last value is plus (`dp[i][0]`) and when the last value is minus. (`dp[i][1]`) We take the max of whether to choose or not choose for both when the last value is plus and when the last value is minus.\\n\\nAfter we finish iterating, max of `dp[-1]` is the result, meaning we find the maximum number between when the last value is plus and when the last value is minus.\\n\\n```\\nclass Solution:\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\n        n = len(nums)   \\n        dp = [[0,0] for _ in range(n)] # initialize dp\\n        dp[0][0] = nums[0] # pre-define\\n        dp[0][1] = 0 # pre-define\\n\\n        for i in range(1, n): # iterate through nums starting from index 1\\n            dp[i][0] = max(nums[i] + dp[i-1][1], dp[i-1][0]) # find which value is higher between choosing or not choosing when the last value is plus.\\n            dp[i][1] = max(-nums[i] + dp[i-1][0], dp[i-1][1]) # find which value is higher between choosing or not choosing when the last value is minus.\\n        \\n        return max(dp[-1]) # find the maximum of the last array of dp of whether the last value is plus or minus, this will be our answer.\\n```\\n\\n***Solution 2: DFS with Memoization***\\n\\n**Intuition**\\nWe can combine DFS with memoization to find all the paths and narrow it down as we go.\\n\\n**Algorithm**\\nStart a dfs function, it terminates when `i`, the index, reaches the length of nums, or `n` in this case. We also keep track of another variable `p`, which determines whether we add or subtract. Next, similar to solution 1, we either choose (to start or continue the existing alternating subsequence) or not choose (move on to the next element of nums without doing anything). This will give us the answer.\\n```\\nclass Solution:\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\n\\t\\tn = len(nums)   \\n        @cache\\n        def dfs(i: int, p: bool) -> int:\\n            if i>=n:\\n                return 0 \\n\\t\\t\\t\\n\\t\\t\\t# if choose\\n            num = nums[i] if p else -nums[i]\\n            choose = num + dfs(i+1, not p)\\n\\n            # if not choose\\n            not_choose = dfs(i+1, p)\\n            return max(choose, not_choose)\\n\\n        return dfs(0, True)\\n```\\n\\n**Please consider upvoting if these solutions helped you. Good luck!**\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\n        n = len(nums)   \\n        dp = [[0,0] for _ in range(n)] # initialize dp\\n        dp[0][0] = nums[0] # pre-define\\n        dp[0][1] = 0 # pre-define\\n\\n        for i in range(1, n): # iterate through nums starting from index 1\\n            dp[i][0] = max(nums[i] + dp[i-1][1], dp[i-1][0]) # find which value is higher between choosing or not choosing when the last value is plus.\\n            dp[i][1] = max(-nums[i] + dp[i-1][0], dp[i-1][1]) # find which value is higher between choosing or not choosing when the last value is minus.\\n        \\n        return max(dp[-1]) # find the maximum of the last array of dp of whether the last value is plus or minus, this will be our answer.\\n```\n```\\nclass Solution:\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\n\\t\\tn = len(nums)   \\n        @cache\\n        def dfs(i: int, p: bool) -> int:\\n            if i>=n:\\n                return 0 \\n\\t\\t\\t\\n\\t\\t\\t# if choose\\n            num = nums[i] if p else -nums[i]\\n            choose = num + dfs(i+1, not p)\\n\\n            # if not choose\\n            not_choose = dfs(i+1, p)\\n            return max(choose, not_choose)\\n\\n        return dfs(0, True)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298531,
                "title": "4-lines-96-faster-easy-approach",
                "content": "## IDEA:\\n\\uD83D\\uDC49 Maximize the max_diff.\\n\\uD83D\\uDC49 Minimize the min_diff.\\nGiven an alternating sequence (a0, a1... ak), the change in value after appending an element x depends only on whether we have an even or odd number of elements so far:\\n\\nIf we have even # of elements, we add x; otherwise, we subtract x. So, tracking the best subsequences of odd and even sizes gives an extremely simple update formula.\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\n        \\n        ma=0\\n        mi=0\\n        for num in nums:\\n            ma=max(ma,num-mi)\\n            mi=min(mi,num-ma)\\n            \\n        return ma",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "## IDEA:\\n\\uD83D\\uDC49 Maximize the max_diff.\\n\\uD83D\\uDC49 Minimize the min_diff.\\nGiven an alternating sequence (a0, a1... ak), the change in value after appending an element x depends only on whether we have an even or odd number of elements so far:\\n\\nIf we have even # of elements, we add x; otherwise, we subtract x. So, tracking the best subsequences of odd and even sizes gives an extremely simple update formula.\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\n        \\n        ma=0\\n        mi=0\\n        for num in nums:\\n            ma=max(ma,num-mi)\\n            mi=min(mi,num-ma)\\n            \\n        return ma",
                "codeTag": "Java"
            },
            {
                "id": 1298549,
                "title": "simple-dp-memoization-c",
                "content": "**Similar to buy/sell stock:**\\n```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    ll dp[100003][2];\\n    long long solve(vector<int> &nums,int idx,int subidx)\\n    {\\n        if(idx>=nums.size())\\n            return 0;\\n        if(dp[idx][subidx]!=-1)\\n            return dp[idx][subidx];\\n        if(subidx)\\n        {\\n            return dp[idx][subidx]=max(solve(nums,idx+1,0)-nums[idx],solve(nums,idx+1,1));\\n        }\\n        else\\n        {\\n            return dp[idx][subidx]=max(nums[idx]+solve(nums,idx+1,1),solve(nums,idx+1,0));\\n        }\\n    }\\n    long long maxAlternatingSum(vector<int>& nums) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(nums,0,0);   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    ll dp[100003][2];\\n    long long solve(vector<int> &nums,int idx,int subidx)\\n    {\\n        if(idx>=nums.size())\\n            return 0;\\n        if(dp[idx][subidx]!=-1)\\n            return dp[idx][subidx];\\n        if(subidx)\\n        {\\n            return dp[idx][subidx]=max(solve(nums,idx+1,0)-nums[idx],solve(nums,idx+1,1));\\n        }\\n        else\\n        {\\n            return dp[idx][subidx]=max(nums[idx]+solve(nums,idx+1,1),solve(nums,idx+1,0));\\n        }\\n    }\\n    long long maxAlternatingSum(vector<int>& nums) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(nums,0,0);   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1300950,
                "title": "8-line-solution-dynamic-programming",
                "content": "```\\nclass Solution {\\n    public long maxAlternatingSum(int[] nums) {\\n        int n = nums.length;\\n        long dp[][] = new long[n][2];\\n        dp[0][0] = nums[0];\\n        for(int i=1;i<n;i++){\\n            dp[i][0] = Math.max(dp[i-1][0] , Math.max(dp[i-1][1]+nums[i] , nums[i]));\\n            dp[i][1] = Math.max(dp[i-1][1] , Math.max(dp[i-1][0]-nums[i] , 0));\\n        }\\n        return Math.max(dp[n-1][0] , dp[n-1][1]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public long maxAlternatingSum(int[] nums) {\\n        int n = nums.length;\\n        long dp[][] = new long[n][2];\\n        dp[0][0] = nums[0];\\n        for(int i=1;i<n;i++){\\n            dp[i][0] = Math.max(dp[i-1][0] , Math.max(dp[i-1][1]+nums[i] , nums[i]));\\n            dp[i][1] = Math.max(dp[i-1][1] , Math.max(dp[i-1][0]-nums[i] , 0));\\n        }\\n        return Math.max(dp[n-1][0] , dp[n-1][1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298460,
                "title": "c-easy-to-understand-o-n-solution",
                "content": "**EXPLANATION**\\n\\nI will pick seperately and simultaneously for both even and odd positions.\\n1. While picking for even position (that will increase our sum) - If the next number is smaller than current then we can surely pick current number otherwise we will go to next number.\\n2. While picking for odd position (this will decrease our sum) - If the next number is greater than current then we will pick current (as next will be favourable for even position and taking both overall increases the sum) otherwise we will go to next number.\\n\\n**SOLUTION**\\n```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        long long ans=0;\\n        int n=nums.size();\\n        int j=0;\\n        for(int i=0;i<n;i++){\\n            if(j==0){           //j=0 means we are at even position of resulatant subsequence\\n                if(i+1<n && nums[i+1]<nums[i]) ans+=nums[i],j=1;    //if next number is less than current than add current to answer \\n                else if(i+1==n) ans+=nums[i];       //we will always add last number if at even postion\\n            }\\n            else{\\n                if(i+1<n && nums[i+1]>nums[i]) ans-=nums[i],j=0;  //if (curr<next) then pick current as next-curr>0 and increase the answer.\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Time Complexity : O(n)**\\n**Space : O(1)**\\n*I tried my best to explain but if you are able to explain more clearly then please comment I will edit it.*\\nThank you",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        long long ans=0;\\n        int n=nums.size();\\n        int j=0;\\n        for(int i=0;i<n;i++){\\n            if(j==0){           //j=0 means we are at even position of resulatant subsequence\\n                if(i+1<n && nums[i+1]<nums[i]) ans+=nums[i],j=1;    //if next number is less than current than add current to answer \\n                else if(i+1==n) ans+=nums[i];       //we will always add last number if at even postion\\n            }\\n            else{\\n                if(i+1<n && nums[i+1]>nums[i]) ans-=nums[i],j=0;  //if (curr<next) then pick current as next-curr>0 and increase the answer.\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2506115,
                "title": "cpp-easy-solution-using-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    long long func(int i,int j,vector<int>&nums,vector<vector<long long>>&dp){\\n        if(i==nums.size())return 0;\\n        \\n        if(dp[i][j]!=-1)return dp[i][j];\\n        \\n        if(j){\\n            return dp[i][j]=max(nums[i]+func(i+1,0,nums,dp),func(i+1,1,nums,dp));\\n        }\\n        \\n        return dp[i][j]=max(-nums[i]+func(i+1,1,nums,dp),func(i+1,0,nums,dp));\\n    }\\n    \\n    long long maxAlternatingSum(vector<int>& nums) {\\n        \\n        vector<vector<long long>>dp(nums.size(),vector<long long>(2,-1));\\n        return func(0,1,nums,dp);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    long long func(int i,int j,vector<int>&nums,vector<vector<long long>>&dp){\\n        if(i==nums.size())return 0;\\n        \\n        if(dp[i][j]!=-1)return dp[i][j];\\n        \\n        if(j){\\n            return dp[i][j]=max(nums[i]+func(i+1,0,nums,dp),func(i+1,1,nums,dp));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1539208,
                "title": "python-3-dp-o-n-explanation",
                "content": "### Explanation\\n- Only 2 different states: even sum or odd sum\\n- Like the `hint` section, you can keep 2 variables and track the mamimum along the way\\n- See below for more explanation\\n### Implementation\\n```\\nclass Solution:\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\n        # even: max alternating sum of an even-length subsequence\\n        # odd: max alternating sum of an odd-length subsequence\\n        even = odd = 0      \\n        for num in nums:\\n            even, odd = max(even, odd-num), max(odd, even+num)\\n        return max(even, odd)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\n        # even: max alternating sum of an even-length subsequence\\n        # odd: max alternating sum of an odd-length subsequence\\n        even = odd = 0      \\n        for num in nums:\\n            even, odd = max(even, odd-num), max(odd, even+num)\\n        return max(even, odd)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1313126,
                "title": "java-recursion-memoization-bottom-up-bottom-up-space-efficient",
                "content": "\\n\\t// Recursion\\n\\t// O(2^n) O(n)\\n\\tpublic long maxAlternatingSum1(int[] nums) {\\n\\t\\treturn maxAlternatingSum1(nums, 0, true, nums.length);\\n\\t}\\n\\n\\t// Recursion\\n\\t// O(2^n) O(n)\\n\\tpublic long maxAlternatingSum1(int[] nums, int idx, boolean even, int len) {\\n\\n\\t\\tif (idx == len)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tlong yes = maxAlternatingSum1(nums, idx + 1, !even, len) + ((even) ? nums[idx] : -nums[idx]);\\n\\t\\tlong no = maxAlternatingSum1(nums, idx + 1, even, len);\\n\\n\\t\\treturn Math.max(yes, no);\\n\\t}\\n\\n\\t// Memoization\\n\\t// O(n) O(n)\\n\\tpublic long maxAlternatingSum2(int[] nums) {\\n\\n\\t\\tint len = nums.length;\\n\\t\\tLong[][] memo = new Long[len][2];\\n\\t\\treturn maxAlternatingSum2(nums, 0, 0, len, memo);\\n\\t}\\n\\n\\t// Memoization\\n\\t// O(n) O(n)\\n\\tpublic long maxAlternatingSum2(int[] nums, int idx, int even, int len, Long[][] memo) {\\n\\n\\t\\tif (idx == len)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tif (memo[idx][even] != null)\\n\\t\\t\\treturn memo[idx][even];\\n\\n\\t\\tlong yes = maxAlternatingSum2(nums, idx + 1, even ^ 1, len, memo) + ((even == 0) ? nums[idx] : -nums[idx]);\\n\\t\\tlong no = maxAlternatingSum2(nums, idx + 1, even, len, memo);\\n\\n\\t\\tlong ans = Math.max(yes, no);\\n\\t\\tmemo[idx][even] = ans;\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// Bottom Up\\n\\t// O(n) O(n)\\n\\tpublic long maxAlternatingSum3(int[] nums) {\\n\\n\\t\\tint len = nums.length;\\n\\t\\tlong[][] dp = new long[len + 1][2];\\n\\n\\t\\tfor (int i = len - 1; i >= 0; i--) {\\n\\t\\t\\tdp[i][0] = Math.max(dp[i + 1][1] + nums[i], dp[i + 1][0]);\\n\\t\\t\\tdp[i][1] = Math.max(dp[i + 1][0] - nums[i], dp[i + 1][1]);\\n\\t\\t}\\n\\n\\t\\treturn dp[0][0];\\n\\t}\\n\\n\\t// Bottom Up Space Efficient\\n\\t// O(n) O(1)\\n\\tpublic long maxAlternatingSum4(int[] nums) {\\n\\n\\t\\tint len = nums.length;\\n\\t\\tlong left = 0, right = 0;\\n\\n\\t\\tfor (int i = len - 1; i >= 0; i--) {\\n\\n\\t\\t\\tlong nleft = Math.max(right + nums[i], left);\\n\\t\\t\\tlong nright = Math.max(left - nums[i], right);\\n\\n\\t\\t\\tleft = nleft;\\n\\t\\t\\tright = nright;\\n\\t\\t}\\n\\n\\t\\treturn left;\\n\\t}",
                "solutionTags": [],
                "code": "\\n\\t// Recursion\\n\\t// O(2^n) O(n)\\n\\tpublic long maxAlternatingSum1(int[] nums) {\\n\\t\\treturn maxAlternatingSum1(nums, 0, true, nums.length);\\n\\t}\\n\\n\\t// Recursion\\n\\t// O(2^n) O(n)\\n\\tpublic long maxAlternatingSum1(int[] nums, int idx, boolean even, int len) {\\n\\n\\t\\tif (idx == len)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tlong yes = maxAlternatingSum1(nums, idx + 1, !even, len) + ((even) ? nums[idx] : -nums[idx]);\\n\\t\\tlong no = maxAlternatingSum1(nums, idx + 1, even, len);\\n\\n\\t\\treturn Math.max(yes, no);\\n\\t}\\n\\n\\t// Memoization\\n\\t// O(n) O(n)\\n\\tpublic long maxAlternatingSum2(int[] nums) {\\n\\n\\t\\tint len = nums.length;\\n\\t\\tLong[][] memo = new Long[len][2];\\n\\t\\treturn maxAlternatingSum2(nums, 0, 0, len, memo);\\n\\t}\\n\\n\\t// Memoization\\n\\t// O(n) O(n)\\n\\tpublic long maxAlternatingSum2(int[] nums, int idx, int even, int len, Long[][] memo) {\\n\\n\\t\\tif (idx == len)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tif (memo[idx][even] != null)\\n\\t\\t\\treturn memo[idx][even];\\n\\n\\t\\tlong yes = maxAlternatingSum2(nums, idx + 1, even ^ 1, len, memo) + ((even == 0) ? nums[idx] : -nums[idx]);\\n\\t\\tlong no = maxAlternatingSum2(nums, idx + 1, even, len, memo);\\n\\n\\t\\tlong ans = Math.max(yes, no);\\n\\t\\tmemo[idx][even] = ans;\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// Bottom Up\\n\\t// O(n) O(n)\\n\\tpublic long maxAlternatingSum3(int[] nums) {\\n\\n\\t\\tint len = nums.length;\\n\\t\\tlong[][] dp = new long[len + 1][2];\\n\\n\\t\\tfor (int i = len - 1; i >= 0; i--) {\\n\\t\\t\\tdp[i][0] = Math.max(dp[i + 1][1] + nums[i], dp[i + 1][0]);\\n\\t\\t\\tdp[i][1] = Math.max(dp[i + 1][0] - nums[i], dp[i + 1][1]);\\n\\t\\t}\\n\\n\\t\\treturn dp[0][0];\\n\\t}\\n\\n\\t// Bottom Up Space Efficient\\n\\t// O(n) O(1)\\n\\tpublic long maxAlternatingSum4(int[] nums) {\\n\\n\\t\\tint len = nums.length;\\n\\t\\tlong left = 0, right = 0;\\n\\n\\t\\tfor (int i = len - 1; i >= 0; i--) {\\n\\n\\t\\t\\tlong nleft = Math.max(right + nums[i], left);\\n\\t\\t\\tlong nright = Math.max(left - nums[i], right);\\n\\n\\t\\t\\tleft = nleft;\\n\\t\\t\\tright = nright;\\n\\t\\t}\\n\\n\\t\\treturn left;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1298605,
                "title": "javascript-solution-easy-to-understand",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst maxAlternatingSum = (nums) => {\\n    let oddSum = 0;\\n    let evenSum = 0;\\n\\n    for (const number of nums) {\\n        oddSum = Math.max(oddSum, evenSum + number);\\n        evenSum = Math.max(evenSum, oddSum - number);\\n    }\\n\\n    return Math.max(oddSum, evenSum);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst maxAlternatingSum = (nums) => {\\n    let oddSum = 0;\\n    let evenSum = 0;\\n\\n    for (const number of nums) {\\n        oddSum = Math.max(oddSum, evenSum + number);\\n        evenSum = Math.max(evenSum, oddSum - number);\\n    }\\n\\n    return Math.max(oddSum, evenSum);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2421835,
                "title": "c-easy-to-understand-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        vector<long long> up,down;\\n        \\n        int n=nums.size();\\n        \\n        vector<int> v;\\n        v.push_back(nums[0]);\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]!=nums[i-1]) v.push_back(nums[i]);\\n        }\\n        \\n        // 5 5 5 4 4 4 6 6 6 -> 5 4 6\\n        // converting nums vector like this\\n        \\n        \\n        nums=v;\\n        n=nums.size();\\n        \\n        if(n==1) return nums[0];// if only one element exist return that\\n        \\n        \\n        if(n>1 && nums[0]>nums[1]) up.push_back(nums[0]);\\n        if(n>1 && nums[n-1]>nums[n-2]) up.push_back(nums[n-1]);\\n        \\n        for(int i=1;i<n-1;i++)\\n        {\\n            if(nums[i-1]>nums[i] && nums[i]<nums[i+1])\\n            {\\n                down.push_back(nums[i]);\\n            }\\n            if(nums[i-1]<nums[i] && nums[i]>nums[i+1])\\n            {\\n                up.push_back(nums[i]);\\n            }\\n        }\\n        // saved every peak in up vector and down one in down vector\\n        // 1 2 3 6 3 2 7 8 9 5 2 1 4\\n        // 6 2 9 1 4\\n        // this is my maximum alternating sum subsequence\\n        // up  -> 6 9 4\\n        // down-> 2 1\\n        \\n        // ans= sum(up)-sum(down);\\n        \\n        \\n        \\n        long long res=0;\\n        for(int i=0;i<up.size();i++)res+=up[i];\\n        for(int i=0;i<down.size();i++) res-=down[i];\\n        \\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        vector<long long> up,down;\\n        \\n        int n=nums.size();\\n        \\n        vector<int> v;\\n        v.push_back(nums[0]);\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]!=nums[i-1]) v.push_back(nums[i]);\\n        }\\n        \\n        // 5 5 5 4 4 4 6 6 6 -> 5 4 6\\n        // converting nums vector like this\\n        \\n        \\n        nums=v;\\n        n=nums.size();\\n        \\n        if(n==1) return nums[0];// if only one element exist return that\\n        \\n        \\n        if(n>1 && nums[0]>nums[1]) up.push_back(nums[0]);\\n        if(n>1 && nums[n-1]>nums[n-2]) up.push_back(nums[n-1]);\\n        \\n        for(int i=1;i<n-1;i++)\\n        {\\n            if(nums[i-1]>nums[i] && nums[i]<nums[i+1])\\n            {\\n                down.push_back(nums[i]);\\n            }\\n            if(nums[i-1]<nums[i] && nums[i]>nums[i+1])\\n            {\\n                up.push_back(nums[i]);\\n            }\\n        }\\n        // saved every peak in up vector and down one in down vector\\n        // 1 2 3 6 3 2 7 8 9 5 2 1 4\\n        // 6 2 9 1 4\\n        // this is my maximum alternating sum subsequence\\n        // up  -> 6 9 4\\n        // down-> 2 1\\n        \\n        // ans= sum(up)-sum(down);\\n        \\n        \\n        \\n        long long res=0;\\n        for(int i=0;i<up.size();i++)res+=up[i];\\n        for(int i=0;i<down.size();i++) res-=down[i];\\n        \\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1782221,
                "title": "2-choices-clean-topdown-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<long long>> dp;\\n    \\n    long long solve(vector<int>& arr,int ind,bool f){\\n        if(ind==arr.size()) return 0 ;\\n        \\n        if(dp[ind][f]!=-1) return dp[ind][f];\\n        \\n        long long choice1 = 0,choice2 = 0;\\n        \\n        if(f==1) choice1 =    arr[ind] + solve(arr,ind+1,0);//add cur elem\\n        else     choice1 = -1*arr[ind] + solve(arr,ind+1,1);//subtract cur elem\\n        \\n        choice2 = solve(arr,ind+1,f);//ignore cur elem\\n        \\n        return dp[ind][f] = max(choice1,choice2);\\n    }\\n    \\n    long long maxAlternatingSum(vector<int>& nums) {\\n        dp.resize(nums.size(),vector<long long>(2,-1));\\n        return solve(nums,0,1); \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<long long>> dp;\\n    \\n    long long solve(vector<int>& arr,int ind,bool f){\\n        if(ind==arr.size()) return 0 ;\\n        \\n        if(dp[ind][f]!=-1) return dp[ind][f];\\n        \\n        long long choice1 = 0,choice2 = 0;\\n        \\n        if(f==1) choice1 =    arr[ind] + solve(arr,ind+1,0);//add cur elem\\n        else     choice1 = -1*arr[ind] + solve(arr,ind+1,1);//subtract cur elem\\n        \\n        choice2 = solve(arr,ind+1,f);//ignore cur elem\\n        \\n        return dp[ind][f] = max(choice1,choice2);\\n    }\\n    \\n    long long maxAlternatingSum(vector<int>& nums) {\\n        dp.resize(nums.size(),vector<long long>(2,-1));\\n        return solve(nums,0,1); \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1299881,
                "title": "java-memoization",
                "content": "```\\nclass Solution {\\n    public long maxAlternatingSum(int[] nums) {\\n        int n = nums.length;\\n        //0 means add and 1 means subtract\\n        //i.e 0 signifies the odd index and 1 signifies even index(i.e in  1 indexing)\\n        long dp[][] = new long[n+1][2];\\n        for(long ar[]:dp){Arrays.fill(ar,-1);}\\n        return solve(nums,dp,0,0);\\n    }\\n    public static long solve(int nums[],long dp[][],int index,int state){\\n        \\n        if(index == nums.length){\\n            return 0l;\\n        }\\n        \\n        long ans = Long.MIN_VALUE;\\n        \\n        if(dp[index][state] != -1l){return dp[index][state];}\\n        \\n        //not include the curr element\\n        long op1 = solve(nums,dp,index+1,state);\\n        \\n        //include the curr element and flip the state\\n        long op2 = (state==0?1:-1)*nums[index] + solve(nums,dp,index+1,state^1);\\n        \\n        dp[index][state] = Math.max(op1,op2);\\n        \\n        return dp[index][state];\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public long maxAlternatingSum(int[] nums) {\\n        int n = nums.length;\\n        //0 means add and 1 means subtract\\n        //i.e 0 signifies the odd index and 1 signifies even index(i.e in  1 indexing)\\n        long dp[][] = new long[n+1][2];\\n        for(long ar[]:dp){Arrays.fill(ar,-1);}\\n        return solve(nums,dp,0,0);\\n    }\\n    public static long solve(int nums[],long dp[][],int index,int state){\\n        \\n        if(index == nums.length){\\n            return 0l;\\n        }\\n        \\n        long ans = Long.MIN_VALUE;\\n        \\n        if(dp[index][state] != -1l){return dp[index][state];}\\n        \\n        //not include the curr element\\n        long op1 = solve(nums,dp,index+1,state);\\n        \\n        //include the curr element and flip the state\\n        long op2 = (state==0?1:-1)*nums[index] + solve(nums,dp,index+1,state^1);\\n        \\n        dp[index][state] = Math.max(op1,op2);\\n        \\n        return dp[index][state];\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1299245,
                "title": "c-o-1-space-very-intuitive-solution-similar-to-buy-and-sell-stock-infinite-times-o-n-time",
                "content": "Similar to https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/\\nCode for Buy and Sell Stock ii:\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int ma = 0;\\n        int n = prices.size();\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(prices[i]<prices[i+1])\\n                ma = ma + prices[i+1]-prices[i];\\n        }\\n        return ma;\\n    }\\n};\\n```\\n* The first observation in our question is that the **subsequence we choose will never be of even size**, since you can always remove the last element and increase your sum.\\n* Now lets\\' say the array is [10,7,3,2,   16,8,5,   11....], we\\'ll keep on checking if **nums[i] > nums[i+1]** and if yes we\\'ll include both of them, so we\\'ll be doing this till we reach (10-7) + (7-3) +(3-2) = 10 - 2 = 8, which means we are ultimately choosing only 10 and 2, 16 and 5 and so on.\\nBy doing this we are making an array of even number of elements, but we know that we can do better either by removing the last included element, or adding an element after the last included element. We also know that the array after the last included element is always increasing.\\nSo if the last included element is the last element of the array, we\\'ll be removing that, thereby increasing sum by nums[n-1], if the last included element is not the last element of the array, then we want to include the max value after the last element, which will be the last value in the array, also nums[n-1].\\n\\n**C++ Code :**\\n```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        int n = nums.size();\\n        long long ans = 0;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(nums[i]>nums[i+1])\\n            {\\n                ans = ans + nums[i]-nums[i+1];\\n            }\\n        }\\n        ans = ans + nums[n-1];\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int ma = 0;\\n        int n = prices.size();\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(prices[i]<prices[i+1])\\n                ma = ma + prices[i+1]-prices[i];\\n        }\\n        return ma;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        int n = nums.size();\\n        long long ans = 0;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(nums[i]>nums[i+1])\\n            {\\n                ans = ans + nums[i]-nums[i+1];\\n            }\\n        }\\n        ans = ans + nums[n-1];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298474,
                "title": "python3-alternating-peaks-valleys",
                "content": "\\n```\\nclass Solution:\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\n        vals = []\\n        for x in nums: \\n            if not vals or vals[-1] != x: \\n                vals.append(x)\\n                \\n        peaks, valleys = [], []\\n        for i in range(len(vals)): \\n            if (-inf if i == 0 else vals[i-1]) < vals[i] > (-inf if i+1 == len(vals) else vals[i+1]): peaks.append(vals[i])\\n            if 0 < i < len(vals)-1 and vals[i-1] > vals[i] < vals[i+1]: valleys.append(vals[i])\\n        if len(peaks) == len(valleys): valleys.pop()\\n        return sum(peaks) - sum(valleys)\\n```\\n\\n```\\nclass Solution:\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\n        return sum(max(0, nums[i-1] - nums[i]) for i in range(1, len(nums))) + nums[-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\n        vals = []\\n        for x in nums: \\n            if not vals or vals[-1] != x: \\n                vals.append(x)\\n                \\n        peaks, valleys = [], []\\n        for i in range(len(vals)): \\n            if (-inf if i == 0 else vals[i-1]) < vals[i] > (-inf if i+1 == len(vals) else vals[i+1]): peaks.append(vals[i])\\n            if 0 < i < len(vals)-1 and vals[i-1] > vals[i] < vals[i+1]: valleys.append(vals[i])\\n        if len(peaks) == len(valleys): valleys.pop()\\n        return sum(peaks) - sum(valleys)\\n```\n```\\nclass Solution:\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\n        return sum(max(0, nums[i-1] - nums[i]) for i in range(1, len(nums))) + nums[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298441,
                "title": "python-dp-o-n",
                "content": "On every step we re-calculate 2 values:                                                                  \\n                                                                                                         \\n* currently max alternating sum with even number of elements up to a current element;                    \\n* currently max alternating sum with odd number of elements up to a current element.                     \\n                                                                                                         \\nThe value above for even variant can be calculated as maximum of:                                        \\n                                                                                                         \\n* we do not use the current element (just get previous maximum);                                         \\n* we use the current element, thus we subtract its value from previous odd maximum.                      \\n                                                                                                         \\nThe value above for odd variant can be calculated as maximum of:                                         \\n                                                                                                         \\n* we do not use the current element (just get previous maximum);                                         \\n* we use the current element, thus we add its value to previous even maximum;                            \\n* or we start new sequence from the current element (just the current element value).                    \\n\\nAn initial value for odd maximum is -inf because we can\\'t build anything for even on the very first step.\\n                                                                                                         \\n```                                                                                                      \\nclass Solution:                                                                                          \\n    def maxAlternatingSum(self, nums: List[int]) -> int:                                                 \\n        dpEven, dpOdd = 0, -float(\\'inf\\')                                                                 \\n        for num in nums:\\n            dpEven, dpOdd = max(dpEven, dpOdd-num), max(dpOdd, dpEven+num, num)                          \\n        return max(dpEven, dpOdd)                                                                        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```                                                                                                      \\nclass Solution:                                                                                          \\n    def maxAlternatingSum(self, nums: List[int]) -> int:                                                 \\n        dpEven, dpOdd = 0, -float(\\'inf\\')                                                                 \\n        for num in nums:\\n            dpEven, dpOdd = max(dpEven, dpOdd-num), max(dpOdd, dpEven+num, num)                          \\n        return max(dpEven, dpOdd)                                                                        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795162,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     long long maxAlternatingSum(vector<int>& A) {\\n        long long odd = 0, even = 0;\\n        for (int& a: A)\\n            even = max(even, odd + a),\\n            odd = even - a;\\n        return even;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     long long maxAlternatingSum(vector<int>& A) {\\n        long long odd = 0, even = 0;\\n        for (int& a: A)\\n            even = max(even, odd + a),\\n            odd = even - a;\\n        return even;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2702063,
                "title": "java-easy-solution",
                "content": "\\'\\'\\'class Solution {\\n    public long maxAlternatingSum(int[] nums) {\\n\\t// 2 columns for even and odd indeces\\n        long dp[][] = new long[nums.length + 1][2];\\n        \\n        for(int i = 0; i<nums.length ; i++){\\n\\t\\t\\n\\t\\t\\t//Max(pick current element, not pick current element)\\n            long even = Math.max(dp[i][1] + nums[i], dp[i][0]); // if the current elements is on even index in subsequence\\n            long odd = Math.max(dp[i][0] - nums[i], dp[i][1]);// if the current elements is on odd index in subsequence\\n            \\n\\t\\t\\t//update in dp matrix\\n            dp[i+1][0] = even;\\n            dp[i+1][1] = odd;\\n        }\\n        \\n        return Math.max(dp[nums.length][0],dp[nums.length][1]);\\n    }\\n}\\'\\'\\'",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public long maxAlternatingSum(int[] nums) {\\n\\t// 2 columns for even and odd indeces\\n        long dp[][] = new long[nums.length + 1][2];\\n        \\n        for(int i = 0; i<nums.length ; i++){\\n\\t\\t\\n\\t\\t\\t//Max(pick current element, not pick current element)\\n            long even = Math.max(dp[i][1] + nums[i], dp[i][0]); // if the current elements is on even index in subsequence\\n            long odd = Math.max(dp[i][0] - nums[i], dp[i][1]);// if the current elements is on odd index in subsequence\\n            \\n\\t\\t\\t//update in dp matrix\\n            dp[i+1][0] = even;\\n            dp[i+1][1] = odd;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2501978,
                "title": "c-4-cases-no-dp-or-recursion-just-look-at-last-element",
                "content": "We only need to maintain the last element and whether the next element we add will be positive or negative. There are 4 cases when we consider adding an element to our sum: \\nCase 1: If our last number was negative, then if the current number is lower, we will replace our last number with it.\\nCase 2: If our last number was positive, then if the current number is higher, we will replace our last number with it.\\nIf neither of these cases are met, then we add or subtract the element.\\nCase 3: If our last number was negative, add the current element\\nCase 4: If our last number was positive, subtract the current element.\\n\\n```\\nlong long maxAlternatingSum(vector<int>& nums) {\\n        long long ans = 0;\\n        long long cur = 0;\\n        bool pos = true;\\n        long long last = 0;\\n        \\n        for(int i = 0; i < nums.size(); i++){\\n            if(pos && nums[i] < last){\\n                cur += last-nums[i];\\n                last = nums[i];\\n            }\\n            else if(!pos && nums[i] > last){\\n                cur += nums[i] - last;\\n                last = nums[i];\\n            }\\n            else if(pos){\\n                cur += nums[i];\\n                last = nums[i];\\n                pos = false;\\n            }\\n            else if(!pos){\\n                cur -= nums[i];\\n                last = nums[i];\\n                pos = true;\\n            }\\n            ans = max(cur, ans);\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "We only need to maintain the last element and whether the next element we add will be positive or negative. There are 4 cases when we consider adding an element to our sum: \\nCase 1: If our last number was negative, then if the current number is lower, we will replace our last number with it.\\nCase 2: If our last number was positive, then if the current number is higher, we will replace our last number with it.\\nIf neither of these cases are met, then we add or subtract the element.\\nCase 3: If our last number was negative, add the current element\\nCase 4: If our last number was positive, subtract the current element.\\n\\n```\\nlong long maxAlternatingSum(vector<int>& nums) {\\n        long long ans = 0;\\n        long long cur = 0;\\n        bool pos = true;\\n        long long last = 0;\\n        \\n        for(int i = 0; i < nums.size(); i++){\\n            if(pos && nums[i] < last){\\n                cur += last-nums[i];\\n                last = nums[i];\\n            }\\n            else if(!pos && nums[i] > last){\\n                cur += nums[i] - last;\\n                last = nums[i];\\n            }\\n            else if(pos){\\n                cur += nums[i];\\n                last = nums[i];\\n                pos = false;\\n            }\\n            else if(!pos){\\n                cur -= nums[i];\\n                last = nums[i];\\n                pos = true;\\n            }\\n            ans = max(cur, ans);\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2421113,
                "title": "c-explained-solution-with-picture-time-o-n-space-o-1",
                "content": "**Approach -**\\n\\nMake a line graph of the given array (for understanding the approach easily).\\n\\nSteps -\\xA0\\nTraverse the array from start to finish.\\nAdd the local maximum to the answer and subtract the local minimum from the answer.\\nNote - If local maximum does not exist after local minimum, do not subtract it from the answer.\\n\\n**One Example-**\\n\\nArr -> [6,4,2,5,3,6,8,4,2]\\n\\nLine graph - \\n\\n![image](https://assets.leetcode.com/users/images/6f6867bf-5ddb-40fb-a262-6be62e16191b_1660416466.0897508.png)\\n\\nans = 0\\n\\nlocal max -> 6 \\nans += 6 => 6\\n\\nlocal min -> 2\\nans -= 2 => 4\\n\\nlocal max -> 5\\nans += 5 => 9\\n\\nlocal min -> 3\\nans -= 3 => 6\\n\\nlocal max -> 8\\nans += 8 => 14\\n\\n**Output - 14**\\n\\n```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& a) {\\n        \\n        ll n= a.size() , flag  =0, ans =0, val = a[0], cur ;\\n        // flag = 0 -> In search of local max\\n\\t\\t// flag = 1 -> In search of local min\\n        for(int i=1;i<n;i++){\\n            if(a[i]==a[i-1])    // If the values are the same, there is no need to do anything because it will not help in determining the local maximum or minimum.\\n                continue;\\n            if(flag==0){        // In search of local max\\n                if(a[i]>val)     // Maximise the val\\n                   val = a[i];\\n                else{\\n                    ans += val;  // Add local max to ans\\n                    val = a[i];  \\n                    flag = 1;    // Turn flag 1 because now we will be in search of local min.\\n                } \\n            }\\n            else{                // In search of local min\\n                if(a[i]<val)    // Minimise the val\\n                    val = a[i];\\n                else{\\n                    ans -= val; // Sub from ans\\n                    val = a[i];\\n                    flag = 0;   // Turn flag 0 because we will now be looking for local max.\\n                }\\n            }\\n        }\\n        \\n        if(flag==0)           // If last search for local max then add it to ans\\n            ans += val;\\n        return ans;\\n    }\\n};\\n```\\n\\n**Time complexity - O(N)**  -> N is length of array\\n**Space complexity - O(1)**\\n\\n**Upvote if you like it !!**\\n",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& a) {\\n        \\n        ll n= a.size() , flag  =0, ans =0, val = a[0], cur ;\\n        // flag = 0 -> In search of local max\\n\\t\\t// flag = 1 -> In search of local min\\n        for(int i=1;i<n;i++){\\n            if(a[i]==a[i-1])    // If the values are the same, there is no need to do anything because it will not help in determining the local maximum or minimum.\\n                continue;\\n            if(flag==0){        // In search of local max\\n                if(a[i]>val)     // Maximise the val\\n                   val = a[i];\\n                else{\\n                    ans += val;  // Add local max to ans\\n                    val = a[i];  \\n                    flag = 1;    // Turn flag 1 because now we will be in search of local min.\\n                } \\n            }\\n            else{                // In search of local min\\n                if(a[i]<val)    // Minimise the val\\n                    val = a[i];\\n                else{\\n                    ans -= val; // Sub from ans\\n                    val = a[i];\\n                    flag = 0;   // Turn flag 0 because we will now be looking for local max.\\n                }\\n            }\\n        }\\n        \\n        if(flag==0)           // If last search for local max then add it to ans\\n            ans += val;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326595,
                "title": "c-simple-solution",
                "content": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    ll f1(vector<int>& nums,int i,int f,vector<vector<ll>>&dp)\\n    { \\n        if(i==nums.size())\\n            return 0;\\n        ll take=0,nottake=0;\\n        if(dp[i][f]!=-1)\\n            return dp[i][f];\\n        if(f)\\n            take+=nums[i]+f1(nums,i+1,1-f,dp);\\n        else\\n            take+=-1*nums[i]+f1(nums,i+1,1-f,dp);\\n        nottake=f1(nums,i+1,f,dp);\\n        return dp[i][f]=max(nottake,take);     \\n    }\\n    long long maxAlternatingSum(vector<int>& nums) {\\n         vector<vector<ll>>dp(nums.size()+1,vector<ll>(3,-1));\\n        return f1(nums,0,1,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    ll f1(vector<int>& nums,int i,int f,vector<vector<ll>>&dp)\\n    { \\n        if(i==nums.size())\\n            return 0;\\n        ll take=0,nottake=0;\\n        if(dp[i][f]!=-1)\\n            return dp[i][f];\\n        if(f)\\n            take+=nums[i]+f1(nums,i+1,1-f,dp);\\n        else\\n            take+=-1*nums[i]+f1(nums,i+1,1-f,dp);\\n        nottake=f1(nums,i+1,f,dp);\\n        return dp[i][f]=max(nottake,take);     \\n    }\\n    long long maxAlternatingSum(vector<int>& nums) {\\n         vector<vector<ll>>dp(nums.size()+1,vector<ll>(3,-1));\\n        return f1(nums,0,1,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2294320,
                "title": "maximum-alternating-subsequence-sum-java-dp-2-methods-memoization-tabulation",
                "content": "```\\nclass Solution {\\n    public long maxAlternatingSum(int[] nums) {\\n        int n=nums.length;\\n        \\n        long oddEven=0;\\n        long evenOdd=0;\\n        \\n        oddEven=nums[0];\\n        \\n        for(int i=1;i<n;i++){\\n            long noe=0;\\n            long neo=0;\\n            \\n            noe=Math.max(oddEven, evenOdd+nums[i]);\\n            neo=Math.max(evenOdd, oddEven-nums[i]);\\n            \\n            oddEven=noe;\\n            evenOdd=neo;\\n        }\\n        \\n        return Math.max(oddEven,evenOdd);\\n    }\\n}\\n\\n//------------------------------------------------------------------------------------------------------------\\n\\nclass Solution {\\n    \\n    long [][]dp;\\n    public long maxAlternatingSum(int[] nums) {\\n        int n=nums.length;\\n        \\n        dp=new long[n][2];\\n        \\n        for(int i=0;i<n;i++){\\n            Arrays.fill(dp[i],-1);\\n        }\\n        \\n        return helper(nums,0,0);\\n    }\\n    \\n    public long helper(int []nums, int p, int idx){\\n        if(idx>=nums.length){\\n            return 0;\\n        }\\n        \\n        if(dp[idx][p]!=-1){\\n            return dp[idx][p];\\n        }\\n        \\n        long max=0;\\n        if(p%2==0){\\n            max=helper(nums,1,idx+1)+nums[idx];\\n        }else{\\n            max=helper(nums,0,idx+1)-nums[idx];\\n        }\\n        \\n        max=Math.max(max,helper(nums,p,idx+1));\\n        \\n        dp[idx][p]=max;\\n        \\n        return dp[idx][p];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public long maxAlternatingSum(int[] nums) {\\n        int n=nums.length;\\n        \\n        long oddEven=0;\\n        long evenOdd=0;\\n        \\n        oddEven=nums[0];\\n        \\n        for(int i=1;i<n;i++){\\n            long noe=0;\\n            long neo=0;\\n            \\n            noe=Math.max(oddEven, evenOdd+nums[i]);\\n            neo=Math.max(evenOdd, oddEven-nums[i]);\\n            \\n            oddEven=noe;\\n            evenOdd=neo;\\n        }\\n        \\n        return Math.max(oddEven,evenOdd);\\n    }\\n}\\n\\n//------------------------------------------------------------------------------------------------------------\\n\\nclass Solution {\\n    \\n    long [][]dp;\\n    public long maxAlternatingSum(int[] nums) {\\n        int n=nums.length;\\n        \\n        dp=new long[n][2];\\n        \\n        for(int i=0;i<n;i++){\\n            Arrays.fill(dp[i],-1);\\n        }\\n        \\n        return helper(nums,0,0);\\n    }\\n    \\n    public long helper(int []nums, int p, int idx){\\n        if(idx>=nums.length){\\n            return 0;\\n        }\\n        \\n        if(dp[idx][p]!=-1){\\n            return dp[idx][p];\\n        }\\n        \\n        long max=0;\\n        if(p%2==0){\\n            max=helper(nums,1,idx+1)+nums[idx];\\n        }else{\\n            max=helper(nums,0,idx+1)-nums[idx];\\n        }\\n        \\n        max=Math.max(max,helper(nums,p,idx+1));\\n        \\n        dp[idx][p]=max;\\n        \\n        return dp[idx][p];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2209135,
                "title": "c-memoization-tabulation-space-optimization-easy-to-understand",
                "content": "**1. Memoization**\\n```\\nclass Solution {\\n    long long solve(vector<int> &nums, int i, int isPositive, vector<vector<long long> > &dp){\\n        if(i>=nums.size()) return 0; \\n        if(dp[i][isPositive] != -1) return dp[i][isPositive];\\n        \\n        int curr = isPositive ? nums[i] : -1*nums[i];\\n        return dp[i][isPositive] = max(solve(nums, i+1, isPositive, dp), curr + solve(nums, i+1, !isPositive, dp));\\n    }\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        vector<vector<long long> > dp(nums.size(), vector<long long>(2, -1));\\n        return solve(nums, 0, 1, dp);\\n    }\\n};\\n```\\n\\n**2. Tabulation**\\n```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        int n = nums.size(), curr;\\n        vector<vector<long long> > dp(n+1, vector<long long>(2, 0));\\n        \\n        for(int i=n-1; i>=0; i--){\\n            for(int j=0; j<2; j++){\\n                curr = j ? nums[i] : -1*nums[i];\\n                dp[i][j] = max(dp[i+1][j], curr + dp[i+1][!j]);\\n            }\\n        }\\n        return dp[0][1];\\n    }\\n};\\n```\\n\\n**3. Space Optimization [O(n) - Time, O(1) - Space]**\\n```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        int n = nums.size(), val;\\n        vector<long long> next(2, 0), cur(2, 0);\\n        for(int i=n-1; i>=0; i--){\\n            for(int j=0; j<2; j++){\\n                val = j ? nums[i] : -1*nums[i];\\n                cur[j] = max(next[j], val + next[!j]);\\n            }\\n            next = cur;\\n        }\\n        return next[1];\\n    }\\n};\\n```\\n\\n**Upvote if you like the solution. \\nComment if there\\'s any confusion.\\nThanks :)**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    long long solve(vector<int> &nums, int i, int isPositive, vector<vector<long long> > &dp){\\n        if(i>=nums.size()) return 0; \\n        if(dp[i][isPositive] != -1) return dp[i][isPositive];\\n        \\n        int curr = isPositive ? nums[i] : -1*nums[i];\\n        return dp[i][isPositive] = max(solve(nums, i+1, isPositive, dp), curr + solve(nums, i+1, !isPositive, dp));\\n    }\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        vector<vector<long long> > dp(nums.size(), vector<long long>(2, -1));\\n        return solve(nums, 0, 1, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        int n = nums.size(), curr;\\n        vector<vector<long long> > dp(n+1, vector<long long>(2, 0));\\n        \\n        for(int i=n-1; i>=0; i--){\\n            for(int j=0; j<2; j++){\\n                curr = j ? nums[i] : -1*nums[i];\\n                dp[i][j] = max(dp[i+1][j], curr + dp[i+1][!j]);\\n            }\\n        }\\n        return dp[0][1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        int n = nums.size(), val;\\n        vector<long long> next(2, 0), cur(2, 0);\\n        for(int i=n-1; i>=0; i--){\\n            for(int j=0; j<2; j++){\\n                val = j ? nums[i] : -1*nums[i];\\n                cur[j] = max(next[j], val + next[!j]);\\n            }\\n            next = cur;\\n        }\\n        return next[1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2121493,
                "title": "java-memoized-code",
                "content": "```\\nclass Solution {\\n\\tlong[][] dp;\\n\\n\\tpublic long maxAlternatingSum(int[] nums) {\\n\\t\\tdp = new long[nums.length][2];\\n\\t\\tfor (long[] row : dp) {\\n\\t\\t\\tArrays.fill(row, Integer.MIN_VALUE);\\n\\t\\t}\\n\\t\\treturn maxAlternatingSum(nums, 0, 0);\\n\\t}\\n\\n\\tpublic long maxAlternatingSum(int[] nums, int n, int flag) {\\n\\t\\tif (n >= nums.length)\\n\\t\\t\\treturn 0;\\n\\t\\tif (dp[n][flag] != Integer.MIN_VALUE)\\n\\t\\t\\treturn dp[n][flag];\\n\\t\\tlong choosenEle = Integer.MIN_VALUE;\\n\\t\\tif (flag == 0) {\\n\\t\\t\\tchoosenEle = Math.max(choosenEle, maxAlternatingSum(nums, n + 1, 1) + nums[n]);\\n\\t\\t\\tdp[n][flag] = choosenEle;\\n\\t\\t} else {\\n\\t\\t\\tchoosenEle = Math.max(choosenEle, maxAlternatingSum(nums, n + 1, 0) - nums[n]);\\n\\t\\t\\tdp[n][flag] = choosenEle;\\n\\t\\t}\\n\\t\\tlong eleNotChoosen = maxAlternatingSum(nums, n + 1, flag);\\n\\t\\treturn dp[n][flag] = Math.max(eleNotChoosen, choosenEle);\\n\\t}\\n}",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tlong[][] dp;\\n\\n\\tpublic long maxAlternatingSum(int[] nums) {\\n\\t\\tdp = new long[nums.length][2];\\n\\t\\tfor (long[] row : dp) {\\n\\t\\t\\tArrays.fill(row, Integer.MIN_VALUE);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2049217,
                "title": "easy-to-understand-c-dp-memoization-fully-understandable",
                "content": "```class Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        \\n         vector<vector<long long>> t(nums.size(),vector<long long> (2,-1));\\n        \\n         return recur(t,1,0,nums);\\n    }\\n    \\n    long long recur(vector<vector<long long>> &t,int flag,int idx,vector<int> &nums)\\n    {\\n         if(idx == nums.size()) return 0;\\n         \\n         if(t[idx][flag] != -1) return t[idx][flag];\\n        \\n         if(flag == 1)\\n         {\\n             t[idx][flag] = max(nums[idx] + recur(t,0,idx+1,nums) , recur(t,1,idx+1,nums));\\n         }\\n        \\n         else\\n         {\\n             t[idx][flag] = max(-nums[idx] + recur(t,1,idx+1,nums) , recur(t,0,idx+1,nums));\\n         }\\n        \\n         return t[idx][flag];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        \\n         vector<vector<long long>> t(nums.size(),vector<long long> (2,-1));\\n        \\n         return recur(t,1,0,nums);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1905058,
                "title": "no-dp-o-n-time-o-1-space-explained",
                "content": "When we traverse nums from begin to end, there would be a pattern: we go from peak (high) to valley (low), and then valley to peak, so forth and so on. \\n\\nWhat would the optimal solution look like?\\n\\nIt would adds all the peaks, and then subtracts all vallies (except at beginning and end). \\n\\nSo we walk through the array, and update the answer when we realize we just passed a peak/valley. \\n\\n```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        int n = nums.size(); if(n == 1) return nums[0];\\n        long long sum = 0;\\n        for(int i = 1; i < n;)\\n        {\\n            //going up\\n            while(i < n && nums[i] >= nums[i-1]) i++;\\n            //I just slided down\\n            sum += nums[i++ -1]; \\n            //going down\\n            while(i < n && nums[i] <= nums[i-1]) i++;\\n            if(i < n)\\n                sum -= nums[i-1];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        int n = nums.size(); if(n == 1) return nums[0];\\n        long long sum = 0;\\n        for(int i = 1; i < n;)\\n        {\\n            //going up\\n            while(i < n && nums[i] >= nums[i-1]) i++;\\n            //I just slided down\\n            sum += nums[i++ -1]; \\n            //going down\\n            while(i < n && nums[i] <= nums[i-1]) i++;\\n            if(i < n)\\n                sum -= nums[i-1];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1805948,
                "title": "5-lines-of-python-code-easy-to-understand-o-n-time-o-1-space",
                "content": "```\\n   def maxAlternatingSum(self, nums: List[int]) -> int:\\n        \\n        # let sub[i] = maximum alternating sum subsequence ending at i with element i just subtracted\\n        # let add[i] = maximum alternating sum subsequence ending at i with element i just added\\n        # sub[i] = max(add[i-1] + nums[i])\\n        \\n        sub,add,m = 0,nums[0], max(0,nums[0])\\n        for val in nums[1:]:\\n            sub, add = max(add - val, sub), max(sub + val, add)\\n            m = max((m,sub,add))\\n        return m\\n```",
                "solutionTags": [],
                "code": "```\\n   def maxAlternatingSum(self, nums: List[int]) -> int:\\n        \\n        # let sub[i] = maximum alternating sum subsequence ending at i with element i just subtracted\\n        # let add[i] = maximum alternating sum subsequence ending at i with element i just added\\n        # sub[i] = max(add[i-1] + nums[i])\\n        \\n        sub,add,m = 0,nums[0], max(0,nums[0])\\n        for val in nums[1:]:\\n            sub, add = max(add - val, sub), max(sub + val, add)\\n            m = max((m,sub,add))\\n        return m\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1802025,
                "title": "no-dp-no-recursion-just-simple-logic-and-pattern",
                "content": "#### Don\\'t bother reading DP under related topics section. Just simple logic here is enough.\\n##### steps are:\\n**Just find a smallest negative array \\'s\\' which has two bigger elements on its left and right** LOL!\\n1. In other words, we just traverse the array and find the **largest** element as long as array is **increasing** *(Ai <= Ai+1)*. We stop when the array starts decreasing and add the `last` biggest we got so far to the sum.\\n2. Next, we just do opposite, find **smallest** element by traversing the array as long as it is **decreasing** *(Ai >= Ai+1)*.\\nJust repeat this process.\\n\\n**What we achieve:**\\nTwo biggest numbers are surrouding a smallest number (**BSB** pattern)\\nAlternatively, first, third, fifth.... are contributing towards addition to sum hence we looked for biggest, and second, fourth, sixth.... and so on were contributing towards substraction so we looked for smallest\\n\\n**What do we need to note here:**\\nwhile finding the **smallest** elements in decreasing array i.e. while finding the second, fourth.. (negative contributing) numbers, **we don\\'t take that number if it is last in the array**.. i.e. if it does not have any larger element on its right side. Because we are at loss right? if we had that larger element then only we would have taken this smaller negative number to compensate with this loss. But why to take loss when you can avoid it.. Just skip this element.\\n\\n**Last Note:\\nFind the pattern BSB (Biggest Smallest Biggest)**\\n\\n**Source code is:**\\n```\\nlong long maxAlternatingSum(vector<int>& nums) {\\n        long long sum = 0, last = -1;  // lastly taken element\\n        int idx = 0;\\n        bool inc = 1;   // we start from finding bigger elements : true when finding bigger element\\n        while (idx < nums.size()) {\\n            if (inc) {\\n\\t\\t\\t// while we get biggest element in increasing array\\n                while (idx < nums.size() && nums[idx] >= last) {\\n                    last = nums[idx++];\\n                }\\n                sum += last;  \\n                inc = !inc;  // change the mode from finding bigger element to finding smaller element\\n            } else {\\n\\t\\t\\t// while we get smallest element in decreasing array\\n                while (idx < nums.size() && nums[idx] <= last) {\\n                    last = nums[idx++];\\n                }\\n                if (idx != nums.size()) sum -= last;  // subtract only if we have bigger element ahead !\\n                inc = !inc; // change the mode from finding smaller element to finding bigger element\\n            }\\n        }\\n        return sum;\\n    }\\n```\\n\\n**Do upvote if you think this solution makes sense as most of us are afraid of just hearing DP (including me!) :)**\\n**Don\\'t hype dp.. finding maximum of an array is also a dp problem. It just takes a perspective !!**",
                "solutionTags": [],
                "code": "```\\nlong long maxAlternatingSum(vector<int>& nums) {\\n        long long sum = 0, last = -1;  // lastly taken element\\n        int idx = 0;\\n        bool inc = 1;   // we start from finding bigger elements : true when finding bigger element\\n        while (idx < nums.size()) {\\n            if (inc) {\\n\\t\\t\\t// while we get biggest element in increasing array\\n                while (idx < nums.size() && nums[idx] >= last) {\\n                    last = nums[idx++];\\n                }\\n                sum += last;  \\n                inc = !inc;  // change the mode from finding bigger element to finding smaller element\\n            } else {\\n\\t\\t\\t// while we get smallest element in decreasing array\\n                while (idx < nums.size() && nums[idx] <= last) {\\n                    last = nums[idx++];\\n                }\\n                if (idx != nums.size()) sum -= last;  // subtract only if we have bigger element ahead !\\n                inc = !inc; // change the mode from finding smaller element to finding bigger element\\n            }\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1798391,
                "title": "c-just-find-the-next-biggest-and-next-smallest-element",
                "content": "**if you liked the solution then please upvote it so that it can reach to more people**\\n```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        int i=0,n=nums.size();\\n\\n        long long sum=0;\\n        while(i<n){\\n            while( i+1<n && nums[i]<=nums[i+1]){     //finding the next biggest elemnet for even index\\n                i++;                \\n            }\\n            sum+=nums[i];\\n    \\n            while( i+1<n && nums[i]>=nums[i+1]){    //finding the next smallest elemnet for odd index\\n                i++;             \\n            }\\n            if(i==n-1) break;\\n            \\n            sum-=nums[i];\\n            i++;\\n        }\\n        return sum;\\n    }\\n};\\n```\\n\\n**If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        int i=0,n=nums.size();\\n\\n        long long sum=0;\\n        while(i<n){\\n            while( i+1<n && nums[i]<=nums[i+1]){     //finding the next biggest elemnet for even index\\n                i++;                \\n            }\\n            sum+=nums[i];\\n    \\n            while( i+1<n && nums[i]>=nums[i+1]){    //finding the next smallest elemnet for odd index\\n                i++;             \\n            }\\n            if(i==n-1) break;\\n            \\n            sum-=nums[i];\\n            i++;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774068,
                "title": "o-n-solution-explained-in-details",
                "content": "# Problem\\n\\nWe want to find a linear solution, so each element must be considered once without having to reanalyze all previous elements.\\n\\nSuppose we have a subsequence A and want to determine whether adding element k to it would improve its sum. k will either increase or decrease the sum depending on the length of A. If A is odd-sized (e.g. its length is 1, 3, 5 ...), then a new added element k will have an even index and consequently will be subtracted from the current sum. If A is even-sized, then element k will have an odd index and will be added to the current sum, increasing it.\\n\\nAt first, we might think that adding a new element to an odd-sized subsequence is always a bad move. However, adding a small k now which will decrease the sum might pay off in the future if it enables us to add a large k\\' element in the future which will be added to the sum.\\n\\nConsider example 1 (nums = [4, 2, 5, 3]). At every element, we want to know the best subsequence thus far which we call A.\\nWe start with element 4 and add it to to A. Thus, we have sum equal to 4.\\nNow we consider 2. Adding to 2 to A will lead to a worse sum right now, since sum will become (4 - 2 = 2). However, we might be able to add a larger number later to offset this loss.\\nWhen we consider element 5, we see that if we had added 2 to A, we could now create the subsequence A = [4, 2, 5] with sum (4 - 2 + 5 = 7). But, when we were analyzing element 2, we did not know about the 5 that would come next. Therefore, how can we decide whether to add an element or not to our current best subsequence A without looking at future elements in the nums sequence?\\n\\n# Solution\\nThe trick is to keep track of 2 subsequences: the best odd-sized subsequence and the best even-sized subsequence. Since the problem only requires the best sum and not the subsequences, we just keep track of the sum of each. These two variables will give us the best odd-sized subsequence and even-sized subsequence we can make at every element k of nums.\\n\\nConsider example 3 nums = [6,2,1,2,4,5].\\nWe start with bestOddSizedSubSequenceSum = 6 (A = [6]) and bestEvenSizedSubsequenceSum = 0 (A =[]).\\nNow, we consider the next element (2). The new best odd-sized subsequence will be either the current one or the best even-sized subsequence so far plus the new element (2). The odd-sized subsequence formed by adding 2 to A=[] is worse than just keeping A=[6]. So, we don\\'t change it.\\nThe new best-even sized subsequence will be either the current one or the best odd-sized subsequence minus the new element (2). Adding to 2 to A=[6] yields the even-sized subsequence A=[6,2] which is better than A=[]. So, the best even-sized subsequence is now [6,2] with sum =  4.\\n\\nWe keep doing this for the other elements of nums as the following table shows:\\n\\nk =              6 | 2 | 1 | 2 | 4  | 5\\nbestOdd =  6 | 6 | 6 | 7 | 9  | 10\\nbestEven = 0 | 4 | 5 | 5 | 5  |  5\\n\\nCan you see that bestOdd and bestEven will give us the best odd-sized and even-sized subsequences we can form by considering all elements up to k? When k = 1, we have the best odd-sized subsequence as [6] (sum = 6) and the best even-sized subsequence as [6, 1] (sum = 5). When k = 2 (second one), we have the best odd-sized subsequence as [6, 1, 2] (sum = 7) and the best even-sized subsequence as [6, 1] (sum = 5).\\n\\n# Implementation (Python 3 but similar to pseudocode)\\nThe implementation is straightforward once we grasp the core idea of the solution.\\n\\n```\\ndef maxAlternatingSum(self, nums: List[int]) -> int:\\n        bestOddSizedSequenceSum = nums[0]\\n        bestEvenSizedSequenceSum = 0\\n        for e in nums[1:]:  # skip the 1st element of nums\\n            bestOddSizedSequenceSum = max(bestOddSizedSequenceSum, bestEvenSizedSequenceSum + e)\\n            bestEvenSizedSequenceSum = max(bestEvenSizedSequenceSum, bestOddSizedSequenceSum - e)\\n        return bestOddSizedSequenceSum\\n```\\n",
                "solutionTags": [],
                "code": "```\\ndef maxAlternatingSum(self, nums: List[int]) -> int:\\n        bestOddSizedSequenceSum = nums[0]\\n        bestEvenSizedSequenceSum = 0\\n        for e in nums[1:]:  # skip the 1st element of nums\\n            bestOddSizedSequenceSum = max(bestOddSizedSequenceSum, bestEvenSizedSequenceSum + e)\\n            bestEvenSizedSequenceSum = max(bestEvenSizedSequenceSum, bestOddSizedSequenceSum - e)\\n        return bestOddSizedSequenceSum\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1639839,
                "title": "simple-c-o-n-time-o-1-space-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        long long  even_sum = nums[0];\\n        long long odd_sum = 0;\\n        for(int i = 1; i < nums.size(); i++){\\n            even_sum = max(even_sum, odd_sum + nums[i]);\\n            odd_sum = max(odd_sum, even_sum - nums[i]);\\n        }\\n        return even_sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        long long  even_sum = nums[0];\\n        long long odd_sum = 0;\\n        for(int i = 1; i < nums.size(); i++){\\n            even_sum = max(even_sum, odd_sum + nums[i]);\\n            odd_sum = max(odd_sum, even_sum - nums[i]);\\n        }\\n        return even_sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1393376,
                "title": "c-backtracking-and-memoisation-dynamic-programming",
                "content": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    ll max(ll a, ll b){\\n        return a > b ? a : b;\\n    }\\n    \\n    ll solve(int index, bool flag, vector<int> &nums, vector<vector<ll>> &dp){\\n        if(index >= nums.size())\\n            return 0;\\n        if(dp[index][flag] != INT_MIN)\\n            return dp[index][flag];\\n        ll op1 = solve(index + 1, flag, nums, dp), op2 = 0;\\n        if(flag)\\n            op2 += nums[index];\\n        else\\n            op2 -= nums[index];\\n        op2 += solve(index + 1, !flag, nums, dp);\\n        return dp[index][flag] = max(op1, op2);\\n    }\\n    \\n    long long maxAlternatingSum(vector<int>& nums) {\\n        vector<vector<ll>> dp(nums.size(), vector<ll>(2, INT_MIN));\\n        return solve(0, true, nums, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    ll max(ll a, ll b){\\n        return a > b ? a : b;\\n    }\\n    \\n    ll solve(int index, bool flag, vector<int> &nums, vector<vector<ll>> &dp){\\n        if(index >= nums.size())\\n            return 0;\\n        if(dp[index][flag] != INT_MIN)\\n            return dp[index][flag];\\n        ll op1 = solve(index + 1, flag, nums, dp), op2 = 0;\\n        if(flag)\\n            op2 += nums[index];\\n        else\\n            op2 -= nums[index];\\n        op2 += solve(index + 1, !flag, nums, dp);\\n        return dp[index][flag] = max(op1, op2);\\n    }\\n    \\n    long long maxAlternatingSum(vector<int>& nums) {\\n        vector<vector<ll>> dp(nums.size(), vector<ll>(2, INT_MIN));\\n        return solve(0, true, nums, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1387920,
                "title": "c-dp-o-n-time-o-1-space",
                "content": "```\\nlong long maxAlternatingSum(vector<int>& nums) {\\n            int n = nums.size();\\n            long long int evensum = nums[0];\\n            long long int oddsum = 0;\\n            for(int i=1;i<n; i++){\\n                evensum = max(evensum, oddsum +nums[i]);\\n                oddsum = max(oddsum, evensum - nums[i]);\\n            }\\n            return evensum;          \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nlong long maxAlternatingSum(vector<int>& nums) {\\n            int n = nums.size();\\n            long long int evensum = nums[0];\\n            long long int oddsum = 0;\\n            for(int i=1;i<n; i++){\\n                evensum = max(evensum, oddsum +nums[i]);\\n                oddsum = max(oddsum, evensum - nums[i]);\\n            }\\n            return evensum;          \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1325272,
                "title": "beginner-dp-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& A){\\n        int n=A.size();\\n        long long dp[n][2];\\n        for(int i=0;i<n;i++)dp[i][0]=dp[i][1]=0;\\n        dp[0][0]=A[0];\\n        dp[0][1]=0;\\n        long long cnt=max(dp[0][0],dp[0][1]);\\n        for(int i=1;i<n;i++){\\n            dp[i][1]=max(dp[i-1][1],dp[i-1][0]-A[i]);// not including the element at odd position\\n            dp[i][0]=max(dp[i-1][0],dp[i-1][1]+A[i]);// including or not including at even position\\n            cnt=max(cnt,max(dp[i][0],dp[i][1]));\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& A){\\n        int n=A.size();\\n        long long dp[n][2];\\n        for(int i=0;i<n;i++)dp[i][0]=dp[i][1]=0;\\n        dp[0][0]=A[0];\\n        dp[0][1]=0;\\n        long long cnt=max(dp[0][0],dp[0][1]);\\n        for(int i=1;i<n;i++){\\n            dp[i][1]=max(dp[i-1][1],dp[i-1][0]-A[i]);// not including the element at odd position\\n            dp[i][0]=max(dp[i-1][0],dp[i-1][1]+A[i]);// including or not including at even position\\n            cnt=max(cnt,max(dp[i][0],dp[i][1]));\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1299412,
                "title": "dp-recursion-memo-python",
                "content": "```\\nclass Solution:\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\n        dp={}\\n        n=len(nums)\\n        \\n        def dfs(sym,i):\\n            if i>=n:\\n                return 0\\n            if (sym,i) in dp:\\n                return dp[(sym,i)]\\n            if sym==\\'ad\\':\\n                dp[(sym,i)]=max(dfs(sym,i+1),nums[i]+dfs(\\'sub\\',i+1))\\n            else:\\n                dp[(sym,i)]=max(dfs(sym,i+1),dfs(\\'ad\\',i+1)-nums[i]) \\n            return dp[(sym,i)]\\n        \\n        \\n        return dfs(\\'ad\\',0)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\n        dp={}\\n        n=len(nums)\\n        \\n        def dfs(sym,i):\\n            if i>=n:\\n                return 0\\n            if (sym,i) in dp:\\n                return dp[(sym,i)]\\n            if sym==\\'ad\\':\\n                dp[(sym,i)]=max(dfs(sym,i+1),nums[i]+dfs(\\'sub\\',i+1))\\n            else:\\n                dp[(sym,i)]=max(dfs(sym,i+1),dfs(\\'ad\\',i+1)-nums[i]) \\n            return dp[(sym,i)]\\n        \\n        \\n        return dfs(\\'ad\\',0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298451,
                "title": "short-4-line-greedy-solution",
                "content": "Given an alternating sequence `(a0, a1... ak)`, the change in value after appending an element `x` depends only on whether we have an even or odd number of elements so far: \\n\\nIf we have even # of elements, we add x; otherwise, we subtract x. So, tracking the best subsequences of odd and even sizes gives an extremely simple update formula.\\n\\n```python\\nclass Solution:\\n\\tdef maxAlternatingSum(self, nums: List[int]) -> int:\\n\\t\\tbest_odd, best_even = nums[0], 0\\n\\t\\tfor x in nums[1:]:\\n\\t\\t\\tbest_odd, best_even = max(best_even+x, best_odd), max(best_odd-x, best_even)\\n\\t\\treturn max(best_even, best_odd)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n\\tdef maxAlternatingSum(self, nums: List[int]) -> int:\\n\\t\\tbest_odd, best_even = nums[0], 0\\n\\t\\tfor x in nums[1:]:\\n\\t\\t\\tbest_odd, best_even = max(best_even+x, best_odd), max(best_odd-x, best_even)\\n\\t\\treturn max(best_even, best_odd)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298430,
                "title": "c-dp-solution-o-n-time-o-1-space",
                "content": "dp[0] represent maximum sum end with even index, dp[1] represent maximum sum end with odd index.  \\n```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        int n = nums.size();\\n        long long dp[2] = {0, 0};\\n        for(int i = 0; i < n; i++) {\\n            long long prevEven = dp[0];\\n            dp[0] = max(dp[0], dp[1] + (long long)nums[i]);\\n            dp[1] = max(dp[1], prevEven - (long long)nums[i]);\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        int n = nums.size();\\n        long long dp[2] = {0, 0};\\n        for(int i = 0; i < n; i++) {\\n            long long prevEven = dp[0];\\n            dp[0] = max(dp[0], dp[1] + (long long)nums[i]);\\n            dp[1] = max(dp[1], prevEven - (long long)nums[i]);\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921551,
                "title": "easy-c-solution-2d-dp-heavily-commented",
                "content": "# Intuition\\r\\nsubsequence hai to pick ya non pick case baenega.\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n2D DP lagegi isme but approach boht pyari hai \\r\\ncode comment dekh k samjh ajaega.\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity: O(N)\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:o(N)\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    // ek dp array define kiya jo har index ki position even/odd store karega    \\r\\n    long long dp[1000001][2];\\r\\n\\r\\n    long long solve(vector<int>& nums, int i , int count){\\r\\n        // base case agar traverse karliya no changes in dp\\r\\n        if(i == nums.size()) return 0;\\r\\n\\r\\n        // memoisation condition\\r\\n        if(dp[i][count] != -1) return dp[i][count];\\r\\n        long long pick =0;\\r\\n        if(count ==0)\\r\\n        // agar even place pe add hoga number to add\\r\\n         pick = nums[i] + solve(nums,i+1,1);\\r\\n        //  odd place pe subtract\\r\\n        else pick = -nums[i] +solve(nums, i+1,0);\\r\\n\\r\\n        // pick nahi kiya to aage badhjao normal\\r\\n\\r\\n        long long nonpick = 0+ solve(nums,i+1,count);\\r\\n\\r\\n        return dp[i][count] = max(pick, nonpick);\\r\\n    }\\r\\n\\r\\n    long long maxAlternatingSum(vector<int>& nums) {\\r\\n\\r\\n        memset(dp, -1, sizeof(dp));\\r\\n       long long ans =  solve(nums, 0, 0);\\r\\n\\r\\n        return ans;\\r\\n        \\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    // ek dp array define kiya jo har index ki position even/odd store karega    \\r\\n    long long dp[1000001][2];\\r\\n\\r\\n    long long solve(vector<int>& nums, int i , int count){\\r\\n        // base case agar traverse karliya no changes in dp\\r\\n        if(i == nums.size()) return 0;\\r\\n\\r\\n        // memoisation condition\\r\\n        if(dp[i][count] != -1) return dp[i][count];\\r\\n        long long pick =0;\\r\\n        if(count ==0)\\r\\n        // agar even place pe add hoga number to add\\r\\n         pick = nums[i] + solve(nums,i+1,1);\\r\\n        //  odd place pe subtract\\r\\n        else pick = -nums[i] +solve(nums, i+1,0);\\r\\n\\r\\n        // pick nahi kiya to aage badhjao normal\\r\\n\\r\\n        long long nonpick = 0+ solve(nums,i+1,count);\\r\\n\\r\\n        return dp[i][count] = max(pick, nonpick);\\r\\n    }\\r\\n\\r\\n    long long maxAlternatingSum(vector<int>& nums) {\\r\\n\\r\\n        memset(dp, -1, sizeof(dp));\\r\\n       long long ans =  solve(nums, 0, 0);\\r\\n\\r\\n        return ans;\\r\\n        \\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807140,
                "title": "java-2-easy-appraoch-with-exaplaination-beginner-friendly",
                "content": "The Maximum Alternating Sum problem involves finding the maximum alternating sum of elements in an array. Given an array of integers, we need to choose elements alternately such that the sum of selected elements is maximized, and we alternate between adding and subtracting elements from the sum.\\r\\n\\r\\nFor instance, consider the array nums = [4, 2, 5, 3]. The maximum alternating sum that can be achieved is: 5 - 2 + 4 = 7.\\r\\n\\r\\nIn this article, we will explore two different approaches to solve the Maximum Alternating Sum problem using recursion: one without memoization, which can result in Time Limit Exceeded (TLE) for larger inputs, and another with memoization to optimize the recursive solution.\\r\\n\\r\\n\\r\\n# Intuition\\r\\n## Approach 1: Recursion without Memoization\\r\\nThe intuition behind this approach is straightforward and involves exploring all possible combinations of elements in the array. At each step, we have two choices: either include the current element in the sum or skip it. We recursively consider both options and continue exploring until we reach the end of the array.\\r\\n\\r\\nHowever, the main issue with this approach is that it leads to an exponential number of function calls. For each element in the array, we make two recursive calls, and each of those calls makes two more recursive calls, and so on. This results in the exponential growth of the recursion tree, and many subproblems are computed repeatedly, leading to redundant computations and inefficiency.\\r\\n\\r\\n## Approach 2: Recursion with Memoization\\r\\nThe intuition behind this approach builds upon the first one but seeks to optimize it by avoiding redundant computations. We use memoization, which is a technique of storing the results of already solved subproblems in a data structure (in this case, a 2D array) called the memoization table.\\r\\n\\r\\nWhen we encounter a subproblem that we have solved before, instead of recomputing it, we directly retrieve the previously computed result from the memoization table. This helps us save computation time and avoid the exponential growth of redundant function calls.\\r\\n\\r\\nThe memoization table essentially acts as a cache that stores the maximum alternating sums for different subarrays at various stages of the recursion. As we explore the recursion tree, we store the results of subproblems in the table, and when we encounter the same subproblem again, we retrieve the result from the table, eliminating the need to recompute it.\\r\\n\\r\\nBy using memoization, we significantly reduce the number of function calls and achieve a linear time complexity, making the solution more efficient, especially for larger input arrays.\\r\\n\\r\\nIn summary, while both approaches use recursion to solve the Maximum Alternating Sum problem, the second approach introduces memoization to optimize the solution and avoid redundant computations, resulting in a much more efficient algorithm.\\r\\n\\r\\n# Approach\\r\\n\\r\\n## Approach 1: Recursion without Memoization\\r\\nIn the first approach, we will use a recursive function to explore all possible combinations of elements in the array. We will consider two options at each step: either include the current element in the sum or skip it. The recursive function solve() will take four parameters:\\r\\n\\r\\nnums: The input array of integers.\\r\\nindex: The current index of the array we are considering.\\r\\nn: The length of the array.\\r\\nsign: An integer value representing the sign (+1 or -1) to alternate between addition and subtraction.\\r\\nThe function will return the maximum alternating sum that can be achieved starting from the given index with the provided sign.\\r\\n\\r\\nThe recursive approach without memoization can be straightforward to implement but may become very inefficient for larger inputs. The repeated computation of the same subproblems can lead to an exponential number of function calls, resulting in Time Limit Exceeded errors.\\r\\n\\r\\n## Approach 2: Recursion with Memoization\\r\\nTo overcome the performance issues of the first approach, we will use memoization to store the results of subproblems and avoid redundant computations. We will use a two-dimensional array memo to store the maximum alternating sums computed so far. The recursive function solve() will take an additional parameter, memo, to access and update the memoization table.\\r\\n\\r\\nBy using memoization, we store the results of subproblems in the memo array and retrieve them whenever needed, effectively reducing redundant computations. This optimization significantly improves the performance of the solution, making it more suitable for larger input arrays.\\r\\n\\r\\n# Complexity\\r\\n### Approach 1: Recursion without Memoization\\r\\n#### Time Complexity:\\r\\nExponential: O(2^n)\\r\\n#### Space Complexity:\\r\\nRecursion Stack: O(n)\\r\\nAuxiliary Space: O(1)\\r\\n### Approach 2: Recursion with Memoization\\r\\n#### Time Complexity:\\r\\n\\r\\nLinear: O(n)\\r\\n#### Space Complexity:\\r\\n\\r\\nMemoization Table: O(n)\\r\\nRecursion Stack: O(n)\\r\\n\\r\\n# Please Upvote \\u2764\\uFE0F\\u2764\\uFE0F\\u2764\\uFE0F\\r\\n# Code\\r\\n**Approach 1**: Recursion without Memoization\\r\\n```\\r\\nclass Solution {\\r\\n    public long maxAlternatingSum(int[] nums) {\\r\\n        int n = nums.length;\\r\\n        return solve(nums, 0, n, 1);\\r\\n    }\\r\\n\\r\\n    public long solve(int[] nums, int index, int n, int sign) {\\r\\n        if (index >= n) return 0;\\r\\n\\r\\n        // Skip current element\\r\\n        long skip = solve(nums, index + 1, n, sign);\\r\\n\\r\\n        // Take current element\\r\\n        long value = nums[index] * sign;\\r\\n        long take = value + solve(nums, index + 1, n, -sign);\\r\\n\\r\\n        return Math.max(skip, take);\\r\\n    }\\r\\n}\\r\\n\\r\\n```\\r\\n**Approach 2**: Recursion with Memoization\\r\\n```\\r\\nclass Solution {\\r\\n    public long maxAlternatingSum(int[] nums) {\\r\\n        int n = nums.length;\\r\\n        Long[][] memo = new Long[n][2];\\r\\n        for (int i = 0; i < n; i++) Arrays.fill(memo[i], null);\\r\\n        return solve(nums, 0, n, false, memo);\\r\\n    }\\r\\n\\r\\n    public static long solve(int[] nums, int index, int n, boolean signneg, Long[][] memo) {\\r\\n        if (index >= n) return 0;\\r\\n        if (memo[index][signneg ? 1 : 0] != null) return memo[index][signneg ? 1 : 0]; \\r\\n        //skip\\r\\n        long skip = solve(nums, index + 1, n, signneg, memo);\\r\\n        //take\\r\\n        long value = nums[index];\\r\\n        if (signneg) {\\r\\n            value = -1 * value;\\r\\n        }\\r\\n        long take = value + solve(nums, index + 1, n, !signneg, memo);\\r\\n        memo[index][signneg ? 1 : 0] = Math.max(skip, take);\\r\\n        return memo[index][signneg ? 1 : 0];\\r\\n    }\\r\\n}\\r\\n\\r\\n```\\r\\n\\r\\n## Conclusion\\r\\nIn this article, we explored two different approaches to solve the Maximum Alternating Sum problem using recursion. The first approach without memoization can lead to Time Limit Exceeded errors for larger inputs due to the exponential growth of redundant function calls. The second approach with memoization optimizes the recursive solution by storing and reusing the results of subproblems, making it more efficient and practical for solving the problem even for larger input arrays.",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\r\\nclass Solution {\\r\\n    public long maxAlternatingSum(int[] nums) {\\r\\n        int n = nums.length;\\r\\n        return solve(nums, 0, n, 1);\\r\\n    }\\r\\n\\r\\n    public long solve(int[] nums, int index, int n, int sign) {\\r\\n        if (index >= n) return 0;\\r\\n\\r\\n        // Skip current element\\r\\n        long skip = solve(nums, index + 1, n, sign);\\r\\n\\r\\n        // Take current element\\r\\n        long value = nums[index] * sign;\\r\\n        long take = value + solve(nums, index + 1, n, -sign);\\r\\n\\r\\n        return Math.max(skip, take);\\r\\n    }\\r\\n}\\r\\n\\r\\n```\n```\\r\\nclass Solution {\\r\\n    public long maxAlternatingSum(int[] nums) {\\r\\n        int n = nums.length;\\r\\n        Long[][] memo = new Long[n][2];\\r\\n        for (int i = 0; i < n; i++) Arrays.fill(memo[i], null);\\r\\n        return solve(nums, 0, n, false, memo);\\r\\n    }\\r\\n\\r\\n    public static long solve(int[] nums, int index, int n, boolean signneg, Long[][] memo) {\\r\\n        if (index >= n) return 0;\\r\\n        if (memo[index][signneg ? 1 : 0] != null) return memo[index][signneg ? 1 : 0]; \\r\\n        //skip\\r\\n        long skip = solve(nums, index + 1, n, signneg, memo);\\r\\n        //take\\r\\n        long value = nums[index];\\r\\n        if (signneg) {\\r\\n            value = -1 * value;\\r\\n        }\\r\\n        long take = value + solve(nums, index + 1, n, !signneg, memo);\\r\\n        memo[index][signneg ? 1 : 0] = Math.max(skip, take);\\r\\n        return memo[index][signneg ? 1 : 0];\\r\\n    }\\r\\n}\\r\\n\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743925,
                "title": "easy-to-understand-c-solution-using-memoization",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    long long dp[100006][2];\\r\\n    long long solve(int i, int x, vector<int>& nums){\\r\\n        if(i == nums.size()) return 0;\\r\\n        if(dp[i][x] != -1) return dp[i][x];\\r\\n        long long skip = solve(i+1,x,nums);\\r\\n        long long consider;\\r\\n        if(x == 0) {\\r\\n            consider = nums[i] + solve(i+1,1,nums);\\r\\n        }\\r\\n        else consider = -nums[i] + solve(i+1,0,nums);\\r\\n        return dp[i][x] = max(skip,consider);\\r\\n    }\\r\\n    long long maxAlternatingSum(vector<int>& nums) {\\r\\n        memset(dp,-1,sizeof(dp));\\r\\n        return solve(0,0,nums);\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    long long dp[100006][2];\\r\\n    long long solve(int i, int x, vector<int>& nums){\\r\\n        if(i == nums.size()) return 0;\\r\\n        if(dp[i][x] != -1) return dp[i][x];\\r\\n        long long skip = solve(i+1,x,nums);\\r\\n        long long consider;\\r\\n        if(x == 0) {\\r\\n            consider = nums[i] + solve(i+1,1,nums);\\r\\n        }\\r\\n        else consider = -nums[i] + solve(i+1,0,nums);\\r\\n        return dp[i][x] = max(skip,consider);\\r\\n    }\\r\\n    long long maxAlternatingSum(vector<int>& nums) {\\r\\n        memset(dp,-1,sizeof(dp));\\r\\n        return solve(0,0,nums);\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708419,
                "title": "dp",
                "content": "# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    long long solve(int ind, int pos, vector<int> &nums, vector<vector<long long>> &dp)\\r\\n{\\r\\n    if (ind == nums.size())\\r\\n    {\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    if (dp[ind][pos] != -1)\\r\\n    {\\r\\n        return dp[ind][pos];\\r\\n    }\\r\\n\\r\\n    long long nonpick = solve(ind + 1, pos, nums, dp);\\r\\n    long long pick = 0;\\r\\n\\r\\n    if (pos)\\r\\n    {\\r\\n        pick = (long long)nums[ind] + solve(ind + 1, !pos, nums, dp);\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        pick = (long long)-nums[ind] + solve(ind + 1, !pos, nums, dp);\\r\\n    }\\r\\n    return dp[ind][pos] = max(pick, nonpick);\\r\\n}\\r\\n\\r\\nlong long maxAlternatingSum(vector<int> &nums)\\r\\n{\\r\\n    vector<vector<long long>> dp((long long)nums.size(), vector<long long>(2, -1));\\r\\n    return solve(0, 1, nums, dp);\\r\\n}\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    long long solve(int ind, int pos, vector<int> &nums, vector<vector<long long>> &dp)\\r\\n{\\r\\n    if (ind == nums.size())\\r\\n    {\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    if (dp[ind][pos] != -1)\\r\\n    {\\r\\n        return dp[ind][pos];\\r\\n    }\\r\\n\\r\\n    long long nonpick = solve(ind + 1, pos, nums, dp);\\r\\n    long long pick = 0;\\r\\n\\r\\n    if (pos)\\r\\n    {\\r\\n        pick = (long long)nums[ind] + solve(ind + 1, !pos, nums, dp);\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        pick = (long long)-nums[ind] + solve(ind + 1, !pos, nums, dp);\\r\\n    }\\r\\n    return dp[ind][pos] = max(pick, nonpick);\\r\\n}\\r\\n\\r\\nlong long maxAlternatingSum(vector<int> &nums)\\r\\n{\\r\\n    vector<vector<long long>> dp((long long)nums.size(), vector<long long>(2, -1));\\r\\n    return solve(0, 1, nums, dp);\\r\\n}\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451806,
                "title": "short-and-easy-to-understand-dp-solution-using-recursion-memoziation",
                "content": "```\\nclass Solution {\\npublic:\\n  long long dp[100002][2];\\n    long long f(vector<int>& nums,int i,int flag)\\n    {\\n        if(i>=nums.size())return 0;\\n        long long take=0;\\n        if(dp[i][flag]!=-1)return dp[i][flag];\\n        if(flag==0)\\n        {\\n            take+= max(nums[i]+f(nums,i+1,1),f(nums,i+1,flag));\\n        }\\n        if(flag==1)\\n        {\\n            take+= max(-nums[i]+f(nums,i+1,0),f(nums,i+1,flag));\\n        }\\n        return  dp[i][flag] =  take;\\n        \\n    }\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        return f(nums,0,0);\\n    }\\n};\\n```\\nupvote if it helps (:",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  long long dp[100002][2];\\n    long long f(vector<int>& nums,int i,int flag)\\n    {\\n        if(i>=nums.size())return 0;\\n        long long take=0;\\n        if(dp[i][flag]!=-1)return dp[i][flag];\\n        if(flag==0)\\n        {\\n            take+= max(nums[i]+f(nums,i+1,1),f(nums,i+1,flag));\\n        }\\n        if(flag==1)\\n        {\\n            take+= max(-nums[i]+f(nums,i+1,0),f(nums,i+1,flag));\\n        }\\n        return  dp[i][flag] =  take;\\n        \\n    }\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        return f(nums,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426056,
                "title": "easy-solution-with-clear-approach-explanation-98-22-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn the problem statement it was clearly mentioned that we need to take maximum altering sum. so we have to take one max element and then a min element and that too in order.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nso iterate through the loop in list and take the two numbers if nums[i]>nums[i+1].\\nlast item we need to take everytime. if you think why the answer is it was a odd indices number any way so we need to add it to result to get maximum list. \\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n- we iterate through the list so it takes n time.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n- we used a single variable ans so 1 space required.\\n- please upvote me if you like the answer,it will gives me motivation.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\n        ans = 0\\n        for i in range(len(nums) - 1):\\n            if nums[i] > nums[i + 1]:\\n                ans += nums[i] - nums[i + 1]\\n        ans += nums[-1]\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\n        ans = 0\\n        for i in range(len(nums) - 1):\\n            if nums[i] > nums[i + 1]:\\n                ans += nums[i] - nums[i + 1]\\n        ans += nums[-1]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3352654,
                "title": "my-simple-easy-to-understand-c-stack-solution",
                "content": "First thing to observe is that we should always pick odd number of elements in the subsequence because we need to add elements at odd indices and subtract elements at even indices.  \\nThe idea is we will maintain a stack now we will have two scenarios -> \\n1. size of stack is even then it means now whatever number we will push into the stack is going to be added but if the current element is smaller or equal to last pushed element then we will pop the element and push the current element because we will have better answer now ex-> [5,3,2] now in stack I have [5,3] now the current element is 2 if I directly push 2 into the stack then ans would be 5+2-3 = 4 but if my stack only contains [5,2] and since my stack size is even at end I need to pop the last push element then stack contains [5] so the answer would be 5. \\n2. size of stack is odd then it means whatever number we will push into the stack is going to be subtracted but if the current element is greater than or equal to last pushed element then we will pop the element and push the current element ex -> arr = [5,7], stack = [5] and current element is 7 it is bigger than the element present at the top of stack so we will pop 5 from stack and push 7 into the stack and since my final stack is of odd length we not need to pop the top element hence, the answer would be 7.\\n\\nCode -> \\n\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll maxAlternatingSum(vector<int>& nums) {\\n        stack<int> st; \\n        \\n        int n = nums.size();\\n        \\n        for(int i = 0; i < n; i++) {\\n            \\n            if(!st.size()) {\\n                st.push(i);\\n            } else {\\n                \\n                if(st.size()%2 == 0){\\n                    \\n                    if(nums[st.top()] >= nums[i]) {\\n                        st.pop();\\n                    } \\n                    \\n                } else {\\n                    \\n                    if(nums[st.top()] <= nums[i]) {\\n                        st.pop();\\n                    }\\n                    \\n                }\\n                st.push(i);\\n                \\n            }\\n            \\n        }\\n        \\n        if(st.size()%2 == 0) st.pop();\\n        ll ans = 0;\\n        int idx = 0;\\n        while(!st.empty()) {\\n\\n            if(idx%2 == 0) {\\n                ans += (ll)nums[st.top()];\\n            } else {\\n                ans -= (ll)nums[st.top()];\\n            }\\n            idx++;\\n            \\n            st.pop();\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nPlease upvote!!",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll maxAlternatingSum(vector<int>& nums) {\\n        stack<int> st; \\n        \\n        int n = nums.size();\\n        \\n        for(int i = 0; i < n; i++) {\\n            \\n            if(!st.size()) {\\n                st.push(i);\\n            } else {\\n                \\n                if(st.size()%2 == 0){\\n                    \\n                    if(nums[st.top()] >= nums[i]) {\\n                        st.pop();\\n                    } \\n                    \\n                } else {\\n                    \\n                    if(nums[st.top()] <= nums[i]) {\\n                        st.pop();\\n                    }\\n                    \\n                }\\n                st.push(i);\\n                \\n            }\\n            \\n        }\\n        \\n        if(st.size()%2 == 0) st.pop();\\n        ll ans = 0;\\n        int idx = 0;\\n        while(!st.empty()) {\\n\\n            if(idx%2 == 0) {\\n                ans += (ll)nums[st.top()];\\n            } else {\\n                ans -= (ll)nums[st.top()];\\n            }\\n            idx++;\\n            \\n            st.pop();\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160635,
                "title": "java-easy-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxAlternatingSum(int[] nums) {\\n        int n = nums.length;\\n        long dp[][] = new long[n][2];\\n        dp[0][0] = nums[0];\\n        for(int i=1; i<n; i++){\\n            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]+nums[i]);\\n            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0]-nums[i]);\\n        }\\n\\n        return Math.max(dp[n-1][0], dp[n-1][1]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public long maxAlternatingSum(int[] nums) {\\n        int n = nums.length;\\n        long dp[][] = new long[n][2];\\n        dp[0][0] = nums[0];\\n        for(int i=1; i<n; i++){\\n            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]+nums[i]);\\n            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0]-nums[i]);\\n        }\\n\\n        return Math.max(dp[n-1][0], dp[n-1][1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2971311,
                "title": "pick-notpick-approach-recursion-memoization-tabulation",
                "content": "# Backtracking Approach TLE\\r\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\r\\n        self.answer = -99999\\r\\n        def f(ind,visited):\\r\\n            if ind<0:\\r\\n                ans = [0,0]\\r\\n                c = 0\\r\\n                for i in range(len(nums)):\\r\\n                    if visited[i] == 0:\\r\\n                        ans[c%2] += nums[i]\\r\\n                        c += 1\\r\\n                self.answer = max(self.answer,ans[0]-ans[1])\\r\\n                return \\r\\n            visited[ind] = 1\\r\\n            f(ind-1,visited)\\r\\n            visited[ind] = 0\\r\\n            f1(ind-1,visited)\\r\\n        n = len(nums)\\r\\n        visited = [0]*n\\r\\n        f(n-1,visited)\\r\\n        return self.answer\\r\\n\\r\\n```\\r\\nBasic Pick and Not Pick approach\\r\\n----------------------------------\\r\\nBasically our aim is to divide array in 2 subsequence\\r\\n    then max ( subSeq1 - subSeq2 ) = ANSWER\\r\\n    or we can say we will add 0/2/4/6 ...th elements\\r\\n       ans subtract 1/3/5/7 ...th elements\\r\\n```\\r\\n# Recursive Approach TLE\\r\\n```\\r\\n#Pick/notPick Approach\\r\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\r\\n        def f(ind,state):\\r\\n            # Return as reached end\\r\\n            if ind<0:\\r\\n                return 0\\r\\n            # val = 1  -- Add\\r\\n            # val = -1 -- Sub\\r\\n            val = -1\\r\\n            # state - True for Add\\r\\n            # state - False for Sub\\r\\n            if state:\\r\\n                val = 1\\r\\n\\r\\n            # if we consider the element \\r\\n            pick = nums[ind] * (val) + f(ind-1,not state)\\r\\n            # if we skip the element\\r\\n            notPick = f(ind-1,state)\\r\\n\\r\\n            return max(pick,notPick)\\r\\n        return f(len(nums)-1,True)\\r\\n```\\r\\n# Memoization\\r\\n```\\r\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\r\\n        def f(ind,state,dp):\\r\\n            if ind<0:\\r\\n                return 0\\r\\n            if dp[ind][state] != -1:\\r\\n                return dp[ind][state]\\r\\n            val = -1\\r\\n            if state:\\r\\n                val = 1\\r\\n            pick = nums[ind] * (val) + f(ind-1,not state,dp)\\r\\n            notPick = f(ind-1,state,dp)\\r\\n            dp[ind][state] =  max(pick,notPick)\\r\\n            return dp[ind][state]\\r\\n        n = len(nums)\\r\\n        dp = [[-1,-1] for i in range(n+1)]\\r\\n        return f(n-1,True,dp)\\r\\n```\\r\\n\\r\\n# Tabulation\\r\\n```\\r\\nclass Solution:\\r\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\r\\n        n = len(nums)\\r\\n        dp = [[0,0] for i in range(n+1)]\\r\\n        for ind in range(0,n,1):\\r\\n            for state in [False,True]:\\r\\n                val = -1\\r\\n                if state:\\r\\n                    val = 1\\r\\n                pick = nums[ind] * (val) + dp[ind-1][not state]\\r\\n                notPick = dp[ind-1][state]\\r\\n                dp[ind][state] =  max(pick,notPick)\\r\\n        return dp[n-1][True]\\r\\n    \\r\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\r\\nBasic Pick and Not Pick approach\\r\\n----------------------------------\\r\\nBasically our aim is to divide array in 2 subsequence\\r\\n    then max ( subSeq1 - subSeq2 ) = ANSWER\\r\\n    or we can say we will add 0/2/4/6 ...th elements\\r\\n       ans subtract 1/3/5/7 ...th elements\\r\\n```\n```\\r\\n#Pick/notPick Approach\\r\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\r\\n        def f(ind,state):\\r\\n            # Return as reached end\\r\\n            if ind<0:\\r\\n                return 0\\r\\n            # val = 1  -- Add\\r\\n            # val = -1 -- Sub\\r\\n            val = -1\\r\\n            # state - True for Add\\r\\n            # state - False for Sub\\r\\n            if state:\\r\\n                val = 1\\r\\n\\r\\n            # if we consider the element \\r\\n            pick = nums[ind] * (val) + f(ind-1,not state)\\r\\n            # if we skip the element\\r\\n            notPick = f(ind-1,state)\\r\\n\\r\\n            return max(pick,notPick)\\r\\n        return f(len(nums)-1,True)\\r\\n```\n```\\r\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\r\\n        def f(ind,state,dp):\\r\\n            if ind<0:\\r\\n                return 0\\r\\n            if dp[ind][state] != -1:\\r\\n                return dp[ind][state]\\r\\n            val = -1\\r\\n            if state:\\r\\n                val = 1\\r\\n            pick = nums[ind] * (val) + f(ind-1,not state,dp)\\r\\n            notPick = f(ind-1,state,dp)\\r\\n            dp[ind][state] =  max(pick,notPick)\\r\\n            return dp[ind][state]\\r\\n        n = len(nums)\\r\\n        dp = [[-1,-1] for i in range(n+1)]\\r\\n        return f(n-1,True,dp)\\r\\n```\n```\\r\\nclass Solution:\\r\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\r\\n        n = len(nums)\\r\\n        dp = [[0,0] for i in range(n+1)]\\r\\n        for ind in range(0,n,1):\\r\\n            for state in [False,True]:\\r\\n                val = -1\\r\\n                if state:\\r\\n                    val = 1\\r\\n                pick = nums[ind] * (val) + dp[ind-1][not state]\\r\\n                notPick = dp[ind-1][state]\\r\\n                dp[ind][state] =  max(pick,notPick)\\r\\n        return dp[n-1][True]\\r\\n    \\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2473193,
                "title": "python-topdown-bottom-up-with-visualisation",
                "content": "We need to select alternating sequence\\nLets take an example: [ 4, 2, 5, 3]\\n\\nAt index 0(odd index) we have two options\\n1. Select the 0th index element and add to sum (since it is an odd index). The next index will be even.\\n\\t`dfs(index + 1, not odd)`\\n2. Ignore the 0th index element and move to 1st index. The next index will still be odd.\\n\\t`dfs(index + 1, odd)`\\n\\nWe need to select maximum of both\\n\\nAt index 1(even index), we have two options\\n1. Select the 1st index element and subtract from sum(since it is an even index). The next index will be odd\\n\\t`dfs(index + 1, not odd)`\\n2. Ignore the 1st index element and move to 2nd index. The next index will still be even.\\n\\t`dfs(index + 1, odd)`\\n\\nWe need to select maximum of both\\n\\n\\n**Top Down:**\\n\\n```\\nclass Solution:\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\n        \\n        # Time: O(N) // Space: O(N)\\n        @cache\\n        def dfs(index, odd):\\n            if index >= len(nums):\\n                return 0\\n            \\n            if odd:\\n                return max(dfs(index + 1, not odd) + nums[index], dfs(index + 1, odd))\\n            else:\\n                return max(dfs(index + 1, not odd) - nums[index], dfs(index + 1, odd))\\n            \\n        return dfs(0, 1)\\n```\\n        \\n\\n**Bottom up:**\\n\\nConverting the above recursive solution into 2D array\\nThis is how the table will look for example [4, 2, 3, 5]\\n\\n![image](https://assets.leetcode.com/users/images/da6becdf-47ea-414c-b13a-3aa05807f425_1661342817.1583724.jpeg)\\n\\n\\n```\\n        # Time - O(N) // Space - O(N)\\n        dp = [[0 for _ in range(2)] for _ in range(len(nums) + 1)]\\n        \\n        for i in range(len(nums) - 1, -1, -1):\\n            dp[i][1] = max(dp[i + 1][0] + nums[i], dp[i + 1][1])\\n            dp[i][0] = max(dp[i + 1][1] - nums[i], dp[i + 1][0])\\n        \\n\\t\\treturn max(dp)[1]\\n```\\n\\n**Space Optimised:**\\n\\nIf we look closely, we can notice that we need just the last two values of even index and odd index\\nThe above solution can be optimised by taking two variable as even and odd\\n\\n```\\n        # Space - O(1)\\n        odd, even = 0, 0\\n        for i in range(0, len(nums)):\\n            odd = max(even + nums[i], odd)\\n            even = max(odd - nums[i], even)\\n        return odd\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\n        \\n        # Time: O(N) // Space: O(N)\\n        @cache\\n        def dfs(index, odd):\\n            if index >= len(nums):\\n                return 0\\n            \\n            if odd:\\n                return max(dfs(index + 1, not odd) + nums[index], dfs(index + 1, odd))\\n            else:\\n                return max(dfs(index + 1, not odd) - nums[index], dfs(index + 1, odd))\\n            \\n        return dfs(0, 1)\\n```\n```\\n        # Time - O(N) // Space - O(N)\\n        dp = [[0 for _ in range(2)] for _ in range(len(nums) + 1)]\\n        \\n        for i in range(len(nums) - 1, -1, -1):\\n            dp[i][1] = max(dp[i + 1][0] + nums[i], dp[i + 1][1])\\n            dp[i][0] = max(dp[i + 1][1] - nums[i], dp[i + 1][0])\\n        \\n\\t\\treturn max(dp)[1]\\n```\n```\\n        # Space - O(1)\\n        odd, even = 0, 0\\n        for i in range(0, len(nums)):\\n            odd = max(even + nums[i], odd)\\n            even = max(odd - nums[i], even)\\n        return odd\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2446408,
                "title": "easy-dp-check-the-ways-maximize-the-return-value",
                "content": "```\\nclass Solution {\\npublic:\\n    long long find(vector <int> &nums, int ind, int flag, vector<vector<long long>> &dp)\\n    {\\n        if(ind >= nums.size())\\n            return 0;\\n        if(dp[ind][flag] != -1)\\n            return dp[ind][flag];\\n        long long a = 0, b= 0, c =0, d= 0;\\n        if(flag)\\n        a = find(nums, ind + 1, 0, dp) + nums[ind];\\n        b = find(nums, ind + 1, flag, dp);\\n        if(!flag)\\n        c = find(nums, ind + 1, 1, dp) - nums[ind];\\n        d = find(nums, ind + 1, flag, dp);\\n        long long maxi = max(a,(max(b,max(d,c))));\\n        return dp[ind][flag] = maxi;\\n    }\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        vector< vector<long long>> dp(nums.size()+1, vector<long long> (2, -1));\\n        return find(nums, 0, 1, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long find(vector <int> &nums, int ind, int flag, vector<vector<long long>> &dp)\\n    {\\n        if(ind >= nums.size())\\n            return 0;\\n        if(dp[ind][flag] != -1)\\n            return dp[ind][flag];\\n        long long a = 0, b= 0, c =0, d= 0;\\n        if(flag)\\n        a = find(nums, ind + 1, 0, dp) + nums[ind];\\n        b = find(nums, ind + 1, flag, dp);\\n        if(!flag)\\n        c = find(nums, ind + 1, 1, dp) - nums[ind];\\n        d = find(nums, ind + 1, flag, dp);\\n        long long maxi = max(a,(max(b,max(d,c))));\\n        return dp[ind][flag] = maxi;\\n    }\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        vector< vector<long long>> dp(nums.size()+1, vector<long long> (2, -1));\\n        return find(nums, 0, 1, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390361,
                "title": "java-o-n-time-dp-solution",
                "content": "```\\n// DP Solution\\n// Time complexity: O(N)\\n// Space complexity: O(1)\\nclass Solution {\\n    public long maxAlternatingSum(int[] nums) {\\n        long even = 0, odd = 0;\\n        for (int num : nums) {\\n            even = Math.max(even, odd + num);\\n            odd = even - num;\\n        }\\n        return even;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// DP Solution\\n// Time complexity: O(N)\\n// Space complexity: O(1)\\nclass Solution {\\n    public long maxAlternatingSum(int[] nums) {\\n        long even = 0, odd = 0;\\n        for (int num : nums) {\\n            even = Math.max(even, odd + num);\\n            odd = even - num;\\n        }\\n        return even;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2380518,
                "title": "c-simplest-memoization-knapsack",
                "content": "class Solution {\\npublic:\\n    \\n    typedef long long ll;\\n    vector<vector<ll>> dp;\\n    \\n    ll fun(int i, vector<int>& nums, int f){\\n        \\n        if(i >= nums.size())\\n            return 0;\\n        \\n        if(dp[i][f+1] != -1)\\n            return dp[i][f+1];\\n        \\n         ll take = ( (f == 1? 1 : -1) * nums[i]) + fun(i+1,nums,(-1)*f);\\n         ll leave = fun(i+1,nums,f); \\n        \\n        return dp[i][f+1] = max(take , leave);\\n    } \\n    \\n    long long maxAlternatingSum(vector<int>& nums) {\\n        \\n        dp = vector<vector<ll>> (nums.size(), vector<ll>(3,-1));\\n        return fun(0,nums,1);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    typedef long long ll;\\n    vector<vector<ll>> dp;\\n    \\n    ll fun(int i, vector<int>& nums, int f){\\n        \\n        if(i >= nums.size())\\n            return 0;\\n        \\n        if(dp[i][f+1] != -1)\\n            return dp[i][f+1];\\n        \\n         ll take = ( (f == 1? 1 : -1) * nums[i]) + fun(i+1,nums,(-1)*f);\\n         ll leave = fun(i+1,nums,f); \\n        \\n        return dp[i][f+1] = max(take , leave);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2297166,
                "title": "greedy",
                "content": "![image](https://assets.leetcode.com/users/images/70a24502-309e-4dfc-b728-e249961352c9_1658261545.3515944.png)\\n\\n\\n\\n**Solution 1**\\n* add sentinel value `-1` to the input array (to ensure that the last value will be `max`);\\n* while you can: add next *local* maximum/minimum with respective sign (`+/-`) to the output variable.\\n\\n**Code:**\\n```\\nlong long maxAlternatingSum(vector<int>& n)\\n{\\n\\tlong long out{};\\n    n.push_back(-1);\\n\\tfor(int i{1}, p{1}; i<size(n); ++i)\\n\\t\\tif(p*n[i]<p*n[i-1])   \\n            out+=p*n[i-1], p*=-1;\\n\\treturn out;\\n}\\n```\\n`p` stands for **p**arity.\\n\\n**Solution 2**\\nIn this algo we gradually add up the segments that lead from maxima to minima.\\nCare should be taken with the last segment.\\n```\\nlong long maxAlternatingSum(vector<int>& n)\\n{\\n\\tlong long out{};\\n\\tfor(int i{1}; i<size(n); ++i)\\n\\t\\tif(n[i]<n[i-1])   \\n            out+=n[i-1]-n[i];\\n\\treturn out+n.back();\\n}\\n```\\n\\nSimilar: [122. Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/discuss/1050256/basic)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nlong long maxAlternatingSum(vector<int>& n)\\n{\\n\\tlong long out{};\\n    n.push_back(-1);\\n\\tfor(int i{1}, p{1}; i<size(n); ++i)\\n\\t\\tif(p*n[i]<p*n[i-1])   \\n            out+=p*n[i-1], p*=-1;\\n\\treturn out;\\n}\\n```\n```\\nlong long maxAlternatingSum(vector<int>& n)\\n{\\n\\tlong long out{};\\n\\tfor(int i{1}; i<size(n); ++i)\\n\\t\\tif(n[i]<n[i-1])   \\n            out+=n[i-1]-n[i];\\n\\treturn out+n.back();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2295791,
                "title": "python-easy-memoization",
                "content": "```\\nclass Solution(object):\\n    def maxAlternatingSum(self, nums):\\n        dp  = {}\\n        def max_sum(arr,i,add = False):\\n            if i>=len(arr):\\n                return 0\\n            if (i,add) in dp:\\n                return dp[(i,add)]\\n            nothing = max_sum(arr,i+1, add)\\n            if not add:\\n                added = max_sum(arr,i+1,True) + arr[i]\\n                dp[(i,add)] =  max(added,nothing)\\n            elif add:\\n                subs = max_sum(arr,i+1, False) -arr[i]\\n                dp[(i,add)] = max(nothing, subs)\\n            return dp[(i,add)]\\n        return max_sum(nums,0)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxAlternatingSum(self, nums):\\n        dp  = {}\\n        def max_sum(arr,i,add = False):\\n            if i>=len(arr):\\n                return 0\\n            if (i,add) in dp:\\n                return dp[(i,add)]\\n            nothing = max_sum(arr,i+1, add)\\n            if not add:\\n                added = max_sum(arr,i+1,True) + arr[i]\\n                dp[(i,add)] =  max(added,nothing)\\n            elif add:\\n                subs = max_sum(arr,i+1, False) -arr[i]\\n                dp[(i,add)] = max(nothing, subs)\\n            return dp[(i,add)]\\n        return max_sum(nums,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2272623,
                "title": "c-easy-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    // add maximas and subtract minimas \\n    long long maxAlternatingSum(vector<int>& nums) {\\n        nums.push_back(INT_MIN); // this step is required if the last element is a maxima\\n        int n=nums.size();\\n        long long sum=0,prev=0; // prev stores the odd index value that will be subtracted\\n        bool pickMax=true;\\n        for(int i=1;i<n;i++){\\n            if(pickMax){\\n                if(nums[i-1]>nums[i]){\\n                    sum+=nums[i-1]-prev;\\n                    pickMax=false;\\n                }\\n            }else{\\n                if(nums[i-1]<nums[i]){\\n                    prev=nums[i-1]; // this value will be subtracted only if we come accross a maxima later.\\n                    pickMax=true;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // add maximas and subtract minimas \\n    long long maxAlternatingSum(vector<int>& nums) {\\n        nums.push_back(INT_MIN); // this step is required if the last element is a maxima\\n        int n=nums.size();\\n        long long sum=0,prev=0; // prev stores the odd index value that will be subtracted\\n        bool pickMax=true;\\n        for(int i=1;i<n;i++){\\n            if(pickMax){\\n                if(nums[i-1]>nums[i]){\\n                    sum+=nums[i-1]-prev;\\n                    pickMax=false;\\n                }\\n            }else{\\n                if(nums[i-1]<nums[i]){\\n                    prev=nums[i-1]; // this value will be subtracted only if we come accross a maxima later.\\n                    pickMax=true;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2264786,
                "title": "c-house-robber-approach-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        long long odd = 0;\\n        long long even = 0;\\n        int n = nums.size();\\n        for(int i=0; i<n; i++) {\\n            long long temp = even;\\n            even = max(even, odd+nums[i]);\\n            odd = max(odd, temp-nums[i]);\\n        }\\n        return max(even,odd);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        long long odd = 0;\\n        long long even = 0;\\n        int n = nums.size();\\n        for(int i=0; i<n; i++) {\\n            long long temp = even;\\n            even = max(even, odd+nums[i]);\\n            odd = max(odd, temp-nums[i]);\\n        }\\n        return max(even,odd);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2183540,
                "title": "memoization-solution",
                "content": "class Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        \\n        vector<vector<long long>> dp(n,vector<long long>(2,INT_MAX));\\n        \\n        return solve(nums,0,0,dp);\\n        \\n    }\\n    \\n    long long solve(vector<int>& nums,int i,int checker,vector<vector<long long>>& dp){\\n        \\n       if(i==nums.size()){              \\n           return 0;                   \\n       }\\n        \\n       if(dp[i][checker]!=INT_MAX){\\n           return dp[i][checker];\\n       } \\n                   \\n       int sum=0;\\n        \\n       if(checker==0){\\n           sum=nums[i];\\n       }\\n        \\n       else{\\n           sum=(-1*nums[i]);\\n       }\\n       \\n       dp[i][checker]=max(sum+solve(nums,i+1,1-checker,dp),solve(nums,i+1,checker,dp));\\n              \\n        return dp[i][checker];\\n          \\n    } \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        \\n        vector<vector<long long>> dp(n,vector<long long>(2,INT_MAX));\\n        \\n        return solve(nums,0,0,dp);\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2156684,
                "title": "scala-one-line-solution",
                "content": "```\\n\\n  def maxAlternatingSum(nums: Array[Int]): Long = {\\n    nums.zipAll(nums.drop(1), 0, 0).map(n => n._1 - n._2).map(_.toLong).filter(_ > 0).sum\\n  }\\n```\\n\\n\\n\\nor\\n\\n\\n```\\n    def maxAlternatingSum(nums: Array[Int]): Long = {\\n    (nums.toSeq :+ 0).sliding(2, 1).map(n => n(0) - n(1)).map(_.toLong).filter(_ > 0).sum\\n    }\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\n\\n  def maxAlternatingSum(nums: Array[Int]): Long = {\\n    nums.zipAll(nums.drop(1), 0, 0).map(n => n._1 - n._2).map(_.toLong).filter(_ > 0).sum\\n  }\\n```\n```\\n    def maxAlternatingSum(nums: Array[Int]): Long = {\\n    (nums.toSeq :+ 0).sliding(2, 1).map(n => n(0) - n(1)).map(_.toLong).filter(_ > 0).sum\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2124826,
                "title": "python-dp-o-n-time-o-n-space",
                "content": "```\\nclass Solution:\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\n        \\n        nums.insert(0,0)\\n        dp = [0]*(len(nums))\\n        \\n        for i in range(1,len(nums)):\\n            dp[i] = max(dp[i-1]+nums[i]-nums[i-1], dp[i-1])\\n            \\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\n        \\n        nums.insert(0,0)\\n        dp = [0]*(len(nums))\\n        \\n        for i in range(1,len(nums)):\\n            dp[i] = max(dp[i-1]+nums[i]-nums[i-1], dp[i-1])\\n            \\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2105958,
                "title": "java-solution-using-the-concept-of-best-time-to-buy-and-sell-stocks",
                "content": "```\\n// Maximum Alternating Subsequence Sum\\n// Leetcode\\n\\nclass Solution {\\n    public long maxAlternatingSum(int[] A) {\\n        long odd = 0, even = 0;\\n        for (int a: A) {\\n            even = Math.max(even, odd + a);\\n            odd = even - a;\\n        }\\n        return even;\\n    }\\n}\\n```\\n\\n### Please solve the problem of (Best time to buy and sell stocks) before solving this.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Maximum Alternating Subsequence Sum\\n// Leetcode\\n\\nclass Solution {\\n    public long maxAlternatingSum(int[] A) {\\n        long odd = 0, even = 0;\\n        for (int a: A) {\\n            even = Math.max(even, odd + a);\\n            odd = even - a;\\n        }\\n        return even;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2078165,
                "title": "maximum-alternating-subsequence-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    \\n    ll helper(int i,vector<int> &nums,int size,vector<vector<ll>> &dp,int isEven){\\n        if(i == size) return 0;\\n        if(dp[i][isEven] != -1) return dp[i][isEven];\\n        ll res = 0;\\n        if(isEven){\\n            ll include = (ll) nums[i] + helper(i+1,nums,size,dp,0);\\n            ll notInclude = (ll)helper(i+1,nums,size,dp,1);\\n            res = max(include,notInclude);\\n        }\\n        else{\\n            ll include = (ll)-nums[i] + helper(i+1,nums,size,dp,1);\\n            ll notInclude = (ll)helper(i+1,nums,size,dp,0);\\n            res = max(include,notInclude);\\n        }\\n        return dp[i][isEven] = res;\\n        \\n    }\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        int i = 0;\\n        int n = nums.size();\\n        vector<vector<ll>> dp(n,vector<ll> (2,-1));\\n        ll maxi = helper(i,nums,n,dp,1);\\n        return maxi;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    typedef long long ll;\\n    \\n    ll helper(int i,vector<int> &nums,int size,vector<vector<ll>> &dp,int isEven){\\n        if(i == size) return 0;\\n        if(dp[i][isEven] != -1) return dp[i][isEven];\\n        ll res = 0;\\n        if(isEven){\\n            ll include = (ll) nums[i] + helper(i+1,nums,size,dp,0);\\n            ll notInclude = (ll)helper(i+1,nums,size,dp,1);\\n            res = max(include,notInclude);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1908287,
                "title": "c-find-continuously-descending-numbers-like-reversed-stock-buy",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        \\n        nums.push_back(0);\\n        \\n        int n =nums.size();\\n        \\n        long long r=0;\\n        \\n        for(int i=0;i<n-1;++i)\\n        {\\n            int j=i;\\n            while(j+1<n && nums[j+1]<=nums[j])\\n                j++;\\n            \\n            if(j>i)\\n            {\\n                r+= nums[i]-nums[j];\\n                \\n                i=j;\\n            }\\n        }\\n        \\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        \\n        nums.push_back(0);\\n        \\n        int n =nums.size();\\n        \\n        long long r=0;\\n        \\n        for(int i=0;i<n-1;++i)\\n        {\\n            int j=i;\\n            while(j+1<n && nums[j+1]<=nums[j])\\n                j++;\\n            \\n            if(j>i)\\n            {\\n                r+= nums[i]-nums[j];\\n                \\n                i=j;\\n            }\\n        }\\n        \\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1897744,
                "title": "java-memoization-solution",
                "content": "public static long recur(int i,int state,int []nums,Long dp[][]){\\n        if(i>=nums.length){\\n            return 0;\\n        }\\n        if(dp[i][state]!=null)return dp[i][state]; \\n        \\n        if(state==1){ //we are searching for even indexed element for subseq then its sign will be + ->(denoted by 1)\\n\\t\\t// thus the next element will always be a odd indexed thus state is changed from 1 to 0         \\n\\t\\t//BUT if we didnt take the number then we are still searching for the even indexed number so state =1 still // \\n            return dp[i][state]=Math.max(nums[i]+recur(i+1,0,nums,dp),0+recur(i+1,1,nums,dp));\\n        }\\n        else{//searching for odd indexed element \\n            return dp[i][state]=Math.max(-nums[i]+recur(i+1,1,nums,dp),0+recur(i+1,0,nums,dp));\\n            \\n            //when we took a number for odd indexed then we are changing the state from 0 to 1 as we will now search for even indexed number\\n\\t\\t\\t// BUT if we didnt take that number then state will remain as 0 as we havn\\'t got the odd indexed number till now//\\n        }\\n        \\n        \\n    }\\n    public long maxAlternatingSum(int[] nums) {\\n        int n=nums.length;\\n        Long dp[][]=new Long[nums.length+1][2]; //only 2 changing parameter(index and state)\\n        //state=1 (even indexed element searching)\\n        //state=0 (odd indexed element searching)\\n        return recur(0,1,nums,dp);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "public static long recur(int i,int state,int []nums,Long dp[][]){\\n        if(i>=nums.length){\\n            return 0;\\n        }\\n        if(dp[i][state]!=null)return dp[i][state]; \\n        \\n        if(state==1){ //we are searching for even indexed element for subseq then its sign will be + ->(denoted by 1)\\n\\t\\t// thus the next element will always be a odd indexed thus state is changed from 1 to 0         \\n\\t\\t//BUT if we didnt take the number then we are still searching for the even indexed number so state =1 still // \\n            return dp[i][state]=Math.max(nums[i]+recur(i+1,0,nums,dp),0+recur(i+1,1,nums,dp));\\n        }\\n        else{//searching for odd indexed element \\n            return dp[i][state]=Math.max(-nums[i]+recur(i+1,1,nums,dp),0+recur(i+1,0,nums,dp));\\n            \\n            //when we took a number for odd indexed then we are changing the state from 0 to 1 as we will now search for even indexed number\\n\\t\\t\\t// BUT if we didnt take that number then state will remain as 0 as we havn\\'t got the odd indexed number till now//\\n        }\\n        \\n        \\n    }\\n    public long maxAlternatingSum(int[] nums) {\\n        int n=nums.length;\\n        Long dp[][]=new Long[nums.length+1][2]; //only 2 changing parameter(index and state)\\n        //state=1 (even indexed element searching)\\n        //state=0 (odd indexed element searching)\\n        return recur(0,1,nums,dp);\\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1897291,
                "title": "c-dp-memoization",
                "content": "```\\n#define ll long long \\nclass Solution {\\npublic:\\n    vector<int> a;\\n    int n;\\n    ll dp[100000][2];\\n    ll solve(int pos,int flag){\\n        if(pos==n)return 0;\\n        else if(dp[pos][flag]!=-1)return dp[pos][flag];\\n        ll ans=0;\\n        if(flag==0){\\n            ans=max(solve(pos+1,1)+a[pos],solve(pos+1,0));\\n        }\\n        else if(flag==1){\\n            ans=max(solve(pos+1,0)-a[pos],solve(pos+1,1));\\n        }\\n        return dp[pos][flag]=ans;\\n    }\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        a=nums;\\n        n=nums.size();\\n        memset(dp,-1,sizeof dp);\\n        return solve(0,0);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> a;\\n    int n;\\n    ll dp[100000][2];\\n    ll solve(int pos,int flag){\\n        if(pos==n)return 0;\\n        else if(dp[pos][flag]!=-1)return dp[pos][flag];\\n        ll ans=0;\\n        if(flag==0){\\n            ans=max(solve(pos+1,1)+a[pos],solve(pos+1,0));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1886038,
                "title": "c-easy-small",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        //a - b + c : odd length\\n        //a - b + c -d : even length\\n        // odd => stores max alternating sum upto i of odd length subsequence\\n        // even => stores max alternating sum upto i of even length subsequence\\n        // at i,we have to update odd and even\\n        // if current element updates odd then current element would be the last element of the subsequence, then new odd would be the previous even + current element => even + x if it is greater than previous odd then update odd\\n        // if current element updates even then current element would be the last element of the subsequence, the new even would be the current odd - current element => odd - x if it is greater than previous even then update even.\\n        long long odd = 0,even = 0;\\n        for(int x:nums){\\n            odd = max(odd,even+x);\\n            even = max(even,odd - x);\\n        }\\n        return odd;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        //a - b + c : odd length\\n        //a - b + c -d : even length\\n        // odd => stores max alternating sum upto i of odd length subsequence\\n        // even => stores max alternating sum upto i of even length subsequence\\n        // at i,we have to update odd and even\\n        // if current element updates odd then current element would be the last element of the subsequence, then new odd would be the previous even + current element => even + x if it is greater than previous odd then update odd\\n        // if current element updates even then current element would be the last element of the subsequence, the new even would be the current odd - current element => odd - x if it is greater than previous even then update even.\\n        long long odd = 0,even = 0;\\n        for(int x:nums){\\n            odd = max(odd,even+x);\\n            even = max(even,odd - x);\\n        }\\n        return odd;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1836744,
                "title": "c-memo-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    //flag = 0//want to insert in odd\\n    //flag = 1//want to insert in even\\n        long long int dp[100001][3];\\n    long long int solve(int i, vector<int> &nums, bool flag){\\n        if (i>=nums.size()){\\n            return 0;\\n        }\\n        if (dp[i][flag]!=-1){\\n            return dp[i][flag];\\n        }\\n        if (flag==0){\\n            long long int ans = -nums[i]+solve(i+1,nums,1);\\n            ans = max(ans,solve(i+1,nums,0));\\n            return dp[i][flag]=ans;\\n            \\n        }\\n        else{\\n            long long int ans = nums[i]+solve(i+1,nums,0);\\n            ans = max(ans,solve(i+1,nums,1));\\n            return dp[i][flag]=ans;\\n        }\\n        \\n        \\n    }\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        memset(dp,-1,sizeof dp);\\n        return solve(0,nums,1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //flag = 0//want to insert in odd\\n    //flag = 1//want to insert in even\\n        long long int dp[100001][3];\\n    long long int solve(int i, vector<int> &nums, bool flag){\\n        if (i>=nums.size()){\\n            return 0;\\n        }\\n        if (dp[i][flag]!=-1){\\n            return dp[i][flag];\\n        }\\n        if (flag==0){\\n            long long int ans = -nums[i]+solve(i+1,nums,1);\\n            ans = max(ans,solve(i+1,nums,0));\\n            return dp[i][flag]=ans;\\n            \\n        }\\n        else{\\n            long long int ans = nums[i]+solve(i+1,nums,0);\\n            ans = max(ans,solve(i+1,nums,1));\\n            return dp[i][flag]=ans;\\n        }\\n        \\n        \\n    }\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        memset(dp,-1,sizeof dp);\\n        return solve(0,nums,1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1799093,
                "title": "python-solution",
                "content": "### Solution 1\\n\\n```\\nclass Solution(object):\\n    def maxAlternatingSum(self, nums):\\n        \\n        d=dict()\\n        def dp(i,e):\\n            if i>=len(nums):\\n                return 0\\n            if (i,e) in d:\\n                return d[(i,e)]\\n            \\n            \\n            s=nums[i] if e else (-1*nums[i])\\n            d[(i,e)]=max(s+dp(i+1,not e),dp(i+1,e))\\n            \\n            return d[(i,e)]\\n            \\n\\n        return dp(0,True)\\n```\\n\\n### Solution 2\\n```\\nclass Solution(object):\\n    def maxAlternatingSum(self, nums):\\n        \\n        e,o=0,0\\n        \\n        for i in range(len(nums)):\\n            te=max(o+nums[i],e)\\n            to=max(e-nums[i],o)\\n            e,o=te,to\\n        \\n        return e\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxAlternatingSum(self, nums):\\n        \\n        d=dict()\\n        def dp(i,e):\\n            if i>=len(nums):\\n                return 0\\n            if (i,e) in d:\\n                return d[(i,e)]\\n            \\n            \\n            s=nums[i] if e else (-1*nums[i])\\n            d[(i,e)]=max(s+dp(i+1,not e),dp(i+1,e))\\n            \\n            return d[(i,e)]\\n            \\n\\n        return dp(0,True)\\n```\n```\\nclass Solution(object):\\n    def maxAlternatingSum(self, nums):\\n        \\n        e,o=0,0\\n        \\n        for i in range(len(nums)):\\n            te=max(o+nums[i],e)\\n            to=max(e-nums[i],o)\\n            e,o=te,to\\n        \\n        return e\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1773440,
                "title": "c-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    long long dp[100005][2];\\n    \\n    long long solve(vector<int>& nums, int idx, int sign){\\n         if(idx >= nums.size()) return 0;\\n         if(dp[idx][sign] != -1) return dp[idx][sign];\\n        \\n         long long op1 = LLONG_MIN, op2 = LLONG_MIN;\\n         \\n         // don\\'t do anything\\n        \\n         op1 = solve(nums, idx + 1, sign);\\n         \\n         // include even sum\\n         if(sign){\\n             op2 = nums[idx] + solve(nums, idx + 1, 0);\\n         }\\n        // include odd sum\\n        else{\\n            op2 = -1 * 1LL* nums[idx] + solve(nums, idx + 1, 1);\\n        }\\n        \\n        return dp[idx][sign] = max(op1, op2);\\n    }\\n    \\n    long long maxAlternatingSum(vector<int>& nums) {\\n          memset(dp, -1, sizeof(dp));\\n          return solve(nums, 0, 1);       \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    long long dp[100005][2];\\n    \\n    long long solve(vector<int>& nums, int idx, int sign){\\n         if(idx >= nums.size()) return 0;\\n         if(dp[idx][sign] != -1) return dp[idx][sign];\\n        \\n         long long op1 = LLONG_MIN, op2 = LLONG_MIN;\\n         \\n         // don\\'t do anything\\n        \\n         op1 = solve(nums, idx + 1, sign);\\n         \\n         // include even sum\\n         if(sign){\\n             op2 = nums[idx] + solve(nums, idx + 1, 0);\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 1709063,
                "title": "short-and-sweet-linear-tc-constant-sc",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        long long ee=nums[0];\\n        long long oe=0;\\n        for(int i=1;i<nums.size();i++){\\n            long long curr=nums[i];\\n            ee=max(ee,oe+curr);\\n            oe=max(oe,ee-curr);\\n        }\\n        return ee;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        long long ee=nums[0];\\n        long long oe=0;\\n        for(int i=1;i<nums.size();i++){\\n            long long curr=nums[i];\\n            ee=max(ee,oe+curr);\\n            oe=max(oe,ee-curr);\\n        }\\n        return ee;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1705046,
                "title": "java-simplest-7-line-solution",
                "content": "space complexity O(1)\\n```\\nclass Solution {\\n    public long maxAlternatingSum(int[] nums) {\\n        long preOdd = 0, preEven = 0, max = 0;\\n        for(int i=0;i<nums.length;i++){\\n            preEven = Math.max(preOdd+nums[i], preEven);\\n            preOdd = Math.max(preEven-nums[i], preOdd);\\n            max = Math.max(preEven, Math.max(max, preOdd));\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\nspace complexity O(n)\\n```\\nclass Solution {\\n    public long maxAlternatingSum(int[] nums) {\\n        long [][] dp = new long[2][nums.length+1];\\n        long max = 0;\\n        for(int i=0;i<nums.length;i++){\\n            dp[0][i+1] = Math.max(dp[1][i]+nums[i], dp[0][i]);\\n            dp[1][i+1] = Math.max(dp[0][i]-nums[i], dp[1][i]);\\n            max = Math.max(dp[0][i+1], Math.max(max, dp[1][i+1]));\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long maxAlternatingSum(int[] nums) {\\n        long preOdd = 0, preEven = 0, max = 0;\\n        for(int i=0;i<nums.length;i++){\\n            preEven = Math.max(preOdd+nums[i], preEven);\\n            preOdd = Math.max(preEven-nums[i], preOdd);\\n            max = Math.max(preEven, Math.max(max, preOdd));\\n        }\\n        return max;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public long maxAlternatingSum(int[] nums) {\\n        long [][] dp = new long[2][nums.length+1];\\n        long max = 0;\\n        for(int i=0;i<nums.length;i++){\\n            dp[0][i+1] = Math.max(dp[1][i]+nums[i], dp[0][i]);\\n            dp[1][i+1] = Math.max(dp[0][i]-nums[i], dp[1][i]);\\n            max = Math.max(dp[0][i+1], Math.max(max, dp[1][i+1]));\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1703835,
                "title": "java-easy-to-understand-beginner-friendly-memoization-sol",
                "content": "```\\nclass Solution {\\n    public long maxAlternatingSum(int[] nums) {\\n        int n = nums.length;\\n        long dp[][] = new long[n+1][2];\\n        for(long ar[]:dp){Arrays.fill(ar,-1);}\\n        return solve(nums,dp,0,0);\\n    }\\n    long solve(int nums[],long dp[][],int index,int state){\\n        \\n        if(index == nums.length){\\n            return 0l;\\n        }\\n        \\n        long ans = Long.MIN_VALUE;\\n        \\n        if(dp[index][state] != -1l)\\n            return dp[index][state];\\n        \\n        long op1 = solve(nums,dp,index+1,state);\\n        \\n        long op2 = (state==0?1:-1)*nums[index] + solve(nums,dp,index+1,state^1);\\n        \\n        dp[index][state] = Math.max(op1,op2);\\n        \\n        return dp[index][state];\\n        \\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public long maxAlternatingSum(int[] nums) {\\n        int n = nums.length;\\n        long dp[][] = new long[n+1][2];\\n        for(long ar[]:dp){Arrays.fill(ar,-1);}\\n        return solve(nums,dp,0,0);\\n    }\\n    long solve(int nums[],long dp[][],int index,int state){\\n        \\n        if(index == nums.length){\\n            return 0l;\\n        }\\n        \\n        long ans = Long.MIN_VALUE;\\n        \\n        if(dp[index][state] != -1l)\\n            return dp[index][state];\\n        \\n        long op1 = solve(nums,dp,index+1,state);\\n        \\n        long op2 = (state==0?1:-1)*nums[index] + solve(nums,dp,index+1,state^1);\\n        \\n        dp[index][state] = Math.max(op1,op2);\\n        \\n        return dp[index][state];\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1661945,
                "title": "144-ms-faster-than-96-68-91-mb-less-than-98-45-c",
                "content": "prevOdd is if previous selected array is odd\\n```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        long long prevOdd=nums[0];\\n        long long prevEven=0;\\n        for(int i=1;i<nums.size();i++){\\n            long long tmpEven=max(prevEven, prevOdd-nums[i]);\\n            long long tmpOdd=max(prevOdd, prevEven+nums[i]);\\n            prevOdd=tmpOdd;\\n            prevEven=tmpEven;\\n        }\\n        return max(prevOdd, prevEven);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        long long prevOdd=nums[0];\\n        long long prevEven=0;\\n        for(int i=1;i<nums.size();i++){\\n            long long tmpEven=max(prevEven, prevOdd-nums[i]);\\n            long long tmpOdd=max(prevOdd, prevEven+nums[i]);\\n            prevOdd=tmpOdd;\\n            prevEven=tmpEven;\\n        }\\n        return max(prevOdd, prevEven);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1615488,
                "title": "python-4-line-easy-to-understand",
                "content": "\\n\\n- use min, max to represent min/max result from subarray [j+1:]\\n- for result of subarray [j:], if we add num[j], then result of j+1 needs to be -1\\n-- min is either min(j+1), or num[j] - max(j+1)\\n-- max is either max(j+1), or num[j] - min(j+1)\\n\\n```\\nclass Solution:\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\n        mx, mn = nums[-1], 0\\n        for j in range(len(nums) - 2, -1, -1):\\n            mx, mn = max(mx, nums[j] - mn), min(mn, nums[j] - mx)\\n        return mx\\n\\t\\t",
                "solutionTags": [],
                "code": "\\n\\n- use min, max to represent min/max result from subarray [j+1:]\\n- for result of subarray [j:], if we add num[j], then result of j+1 needs to be -1\\n-- min is either min(j+1), or num[j] - max(j+1)\\n-- max is either max(j+1), or num[j] - min(j+1)\\n\\n```\\nclass Solution:\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\n        mx, mn = nums[-1], 0\\n        for j in range(len(nums) - 2, -1, -1):\\n            mx, mn = max(mx, nums[j] - mn), min(mn, nums[j] - mx)\\n        return mx\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 1530004,
                "title": "c-dynamic-programming-simple-intuitive-approach",
                "content": "class Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        \\n        long long n=nums.size();\\n        \\n        vector<long long>odd(n,0);\\n        vector<long long>even(n,0);\\n        \\n       \\n        odd[0]=0;\\n        even[0]=nums[0];\\n        \\n        for(int i=1;i<n;i++){\\n            \\n            odd[i]=max(odd[i-1],even[i-1]-nums[i]);\\n            \\n            even[i]=max(even[i-1],odd[i-1]+nums[i]);\\n            \\n        }\\n        \\n        long long maxi=max(odd[n-1],even[n-1]);\\n        \\n        return maxi;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        \\n        long long n=nums.size();\\n        \\n        vector<long long>odd(n,0);\\n        vector<long long>even(n,0);\\n        \\n       \\n        odd[0]=0;\\n        even[0]=nums[0];\\n        \\n        for(int i=1;i<n;i++){\\n            \\n            odd[i]=max(odd[i-1],even[i-1]-nums[i]);\\n            \\n            even[i]=max(even[i-1],odd[i-1]+nums[i]);\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1417226,
                "title": "dp-o-n-solution",
                "content": "```\\n#define pb push_back\\n#define ll long long int\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& a) {\\n        int i=0,j,n=a.size();\\n        if(n==1)\\n            return a[0];\\n        \\n        if(n==2)\\n            return max(a[0],a[1]);\\n        \\n        // 0 -- odd length max sum\\n        // 1 -- even length max sum\\n        ll dp[n][2];\\n        \\n        memset(dp,0,sizeof(dp));\\n        \\n        dp[0][0]=a[0];\\n        dp[0][1]=0;\\n        \\n        for(i=1;i<n;i++){\\n            dp[i][0]=max(dp[i-1][0],dp[i-1][1]+a[i]);\\n            dp[i][1]=max(dp[i-1][1],dp[i-1][0]-a[i]);\\n        }\\n        \\n        \\n        return max(dp[n-1][0],dp[n-1][1]);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n#define pb push_back\\n#define ll long long int\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& a) {\\n        int i=0,j,n=a.size();\\n        if(n==1)\\n            return a[0];\\n        \\n        if(n==2)\\n            return max(a[0],a[1]);\\n        \\n        // 0 -- odd length max sum\\n        // 1 -- even length max sum\\n        ll dp[n][2];\\n        \\n        memset(dp,0,sizeof(dp));\\n        \\n        dp[0][0]=a[0];\\n        dp[0][1]=0;\\n        \\n        for(i=1;i<n;i++){\\n            dp[i][0]=max(dp[i-1][0],dp[i-1][1]+a[i]);\\n            dp[i][1]=max(dp[i-1][1],dp[i-1][0]-a[i]);\\n        }\\n        \\n        \\n        return max(dp[n-1][0],dp[n-1][1]);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1410393,
                "title": "python-another-way-to-think-about-greedy",
                "content": "Before solving this problem, there are 2 very important key points we need to realize:\\n1. When we are choosing even-index number, this should be as big as it can be. Thus, given `n1` and `n2` where `n2` appears right after `n1`. We always choose `n2` if it is `bigger`\\n2. When we are choosing odd-index number, this should be as small as it can be. Thus, given `n1` and `n2` where `n2` appears right after `n1`. We always choose `n2` if it is `smaller`\\n\\n```python\\nclass Solution:\\n    # 996 ms, 99.7%. Time: O(N). Space: O(N)\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\n        seq = [nums[0]] # to store the sequence\\n        inc = True # flag for increasing/decreasing\\n        for n1, n2 in zip(nums, nums[1:]):\\n            if (n2 > n1) == inc: # same as if (n2 > n1 and inc == True) or (n2 <= 1 and inc == False)\\n                seq[-1] = n2 # we always choose the best option as noted above.\\n            else:\\n\\t\\t\\t\\t# else, use it as new valid and flip the flag.\\n                seq.append(n2)\\n                inc = not inc\\n        \\n\\t\\t# we always want odd-length seq because we exclude the last odd-index number.\\n        if len(seq) % 2 == 0: seq.pop()\\n        return sum(seq[::2]) - sum(seq[1::2])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```python\\nclass Solution:\\n    # 996 ms, 99.7%. Time: O(N). Space: O(N)\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\n        seq = [nums[0]] # to store the sequence\\n        inc = True # flag for increasing/decreasing\\n        for n1, n2 in zip(nums, nums[1:]):\\n            if (n2 > n1) == inc: # same as if (n2 > n1 and inc == True) or (n2 <= 1 and inc == False)\\n                seq[-1] = n2 # we always choose the best option as noted above.\\n            else:\\n\\t\\t\\t\\t# else, use it as new valid and flip the flag.\\n                seq.append(n2)\\n                inc = not inc\\n        \\n\\t\\t# we always want odd-length seq because we exclude the last odd-index number.\\n        if len(seq) % 2 == 0: seq.pop()\\n        return sum(seq[::2]) - sum(seq[1::2])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1358136,
                "title": "python-dp-o-n-time-complexity-solution",
                "content": "Think of this as a sum of the points along 2 routes. To take each step you need to switch from route A to route B or from route B to route A, at the same time increase the index by one. Take the [5, 6, 7, 8] test case as example.\\n\\nA: [5,    6,   7,  8]\\nB: [-5, -6, -7, -8]\\n\\nThis process mimics the alternation between even and odd indices. So dynamic programming solves this by keep track of 4 values(can be reduced to 2) as shown in the code. It\\'s travial to modify this to be O(1) space complexity.\\n\\n\\n\\n```\\nclass Solution:\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\n        even = nums\\n        odd = [-i for i in nums]\\n        end_even = 0\\n        end_odd = 0\\n        mx_even = 0\\n        mx_odd = 0\\n        \\n        for i in range(len(nums)):\\n            end_even = mx_odd + even[i]\\n            end_odd = mx_even + odd[i]\\n            \\n            mx_even = max(end_even, mx_even)\\n            mx_odd = max(end_odd, mx_odd)\\n            \\n        #return max(mx_even, mx_odd)\\n        return mx_even\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\n        even = nums\\n        odd = [-i for i in nums]\\n        end_even = 0\\n        end_odd = 0\\n        mx_even = 0\\n        mx_odd = 0\\n        \\n        for i in range(len(nums)):\\n            end_even = mx_odd + even[i]\\n            end_odd = mx_even + odd[i]\\n            \\n            mx_even = max(end_even, mx_even)\\n            mx_odd = max(end_odd, mx_odd)\\n            \\n        #return max(mx_even, mx_odd)\\n        return mx_even\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1337876,
                "title": "java-solution-greedy-3ms-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\n    public long maxAlternatingSum(int[] nums) {\\n        long curMax = nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]>nums[i-1]){\\n                curMax += nums[i]-nums[i-1];\\n            }\\n        }\\n        return curMax;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long maxAlternatingSum(int[] nums) {\\n        long curMax = nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]>nums[i-1]){\\n                curMax += nums[i]-nums[i-1];\\n            }\\n        }\\n        return curMax;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1328794,
                "title": "java-solution-o-n-time-o-1-space-2-variable-approach",
                "content": "class Solution {\\n    public long maxAlternatingSum(int[] nums) {\\n        \\n        long odd= nums[0], even=0;\\n        for(int i=1; i<nums.length; i++)\\n        {\\n            long o= Math.max(odd,even+ nums[i]);\\n            long e= Math.max(even,odd- nums[i]);\\n            odd=o; even=e;\\n        }\\n        return Math.max(odd,even);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public long maxAlternatingSum(int[] nums) {\\n        \\n        long odd= nums[0], even=0;\\n        for(int i=1; i<nums.length; i++)\\n        {\\n            long o= Math.max(odd,even+ nums[i]);\\n            long e= Math.max(even,odd- nums[i]);\\n            odd=o; even=e;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1312905,
                "title": "c-solution",
                "content": "```\\n\\n```public:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        long long int sum=nums[0];\\n        for(long long int i=1;i<nums.size();i++)\\n        {\\n            sum=sum+max(0,nums[i]-nums[i-1]);\\n        }\\n        return sum;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1309806,
                "title": "simple-java-solution-greedy-strategy",
                "content": "for odd digit you can choose maximal digit possible and for even digit you can choose minimal digit possible\\n```\\nclass Solution {\\n    public long maxAlternatingSum(int[] nums) {\\n        int i=0;\\n        int f=0;\\n        long ans=0;\\n        if(nums.length==1)return nums[0];\\n        while(i<nums.length-1){\\n            // System.out.println(i);\\n            if(f==0){\\n                while(i!=nums.length-1&&nums[i]<=nums[i+1])i++;\\n            }else{\\n                while(i!=nums.length-1&&nums[i]>=nums[i+1])i++;\\n            }\\n            // System.out.println(ans);\\n            if(i==nums.length-1&&f==1){\\n                  \\n            }else{\\n                ans=ans+(1L*nums[i]*(f==0?1:-1));\\n                 f^=1;\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public long maxAlternatingSum(int[] nums) {\\n        int i=0;\\n        int f=0;\\n        long ans=0;\\n        if(nums.length==1)return nums[0];\\n        while(i<nums.length-1){\\n            // System.out.println(i);\\n            if(f==0){\\n                while(i!=nums.length-1&&nums[i]<=nums[i+1])i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1309147,
                "title": "5-lines-c-solution-98-faster-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) \\n    {\\n        long result = nums [0];\\n        int len = nums.size ();\\n        for (int i = 1; i < len; ++i)\\n            result += max (0, nums [i] - nums [i-1]);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) \\n    {\\n        long result = nums [0];\\n        int len = nums.size ();\\n        for (int i = 1; i < len; ++i)\\n            result += max (0, nums [i] - nums [i-1]);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1301789,
                "title": "simple-c-recursion-memoisation",
                "content": "```\\nclass Solution {\\npublic:\\n   long long int dp[1000000][2];\\n   long long maxAlternatingSum(vector<int>& nums) {\\n       memset(dp,-1,sizeof(dp));\\n       return helper(nums,0,1);\\n    }\\n    \\n    long long int helper(vector<int>& nums, int i, int sign){\\n        if(i>=nums.size()) return 0;\\n        \\n        if(dp[i][sign]!=-1) return dp[i][sign];\\n        long long int sum;\\n        if(sign==1) sum=max(helper(nums,i+1,1), nums[i]+helper(nums,i+1,0));\\n        else if(sign==0) sum=max(helper(nums,i+1,0), -nums[i]+helper(nums,i+1,1));\\n        return dp[i][sign]=sum;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n   long long int dp[1000000][2];\\n   long long maxAlternatingSum(vector<int>& nums) {\\n       memset(dp,-1,sizeof(dp));\\n       return helper(nums,0,1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1301781,
                "title": "c-greedy-approach-o-1-space-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        long long even=0,odd=0;\\n        for(auto x: nums){\\n            even = max(even, odd+x);\\n            odd = even-x;\\n        }\\n        return even;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        long long even=0,odd=0;\\n        for(auto x: nums){\\n            even = max(even, odd+x);\\n            odd = even-x;\\n        }\\n        return even;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1299295,
                "title": "c-short-solution-156-ms-100",
                "content": "Run-time is `O(N)`, space is `O(1)`. Technically this is a DP solution with space optimization. Idea is that if you want current element to occupy a even slot, you can get at most maximum \"odd\" size subsequence result from before minus this element, and likewise if you want current element to occupy odd slot, you can get at most maximum \"even\" size sequence result from before plus this element. Final result will be maximum result from odd size subsequence.\\n\\n```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        int64_t oddMax{0}, evenMax{0}, tmpOdd, tmpEven;\\n        for(const auto &n: nums) {\\n            tmpOdd = evenMax + n;\\n            tmpEven = oddMax - n;\\n            oddMax = std::max(oddMax, tmpOdd);\\n            evenMax = std::max(evenMax, tmpEven);\\n        }\\n        \\n        return oddMax;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        int64_t oddMax{0}, evenMax{0}, tmpOdd, tmpEven;\\n        for(const auto &n: nums) {\\n            tmpOdd = evenMax + n;\\n            tmpEven = oddMax - n;\\n            oddMax = std::max(oddMax, tmpOdd);\\n            evenMax = std::max(evenMax, tmpEven);\\n        }\\n        \\n        return oddMax;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298867,
                "title": "python-easy-intuitive-solution-memoized-recursive-approach",
                "content": "```\\nclass Solution:\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\n        m=len(nums)\\n        dp=[[-1]*(3) for i in range(m)]\\n        \\n        def solve(i,s):              #i=index, s=sign\\n            if i>=m:\\n                return 0\\n            \\n            if dp[i][s]!=-1:\\n                return dp[i][s]\\n            \\n            dp[i][s]= max(s*nums[i]+solve(i+1,-1*s),solve(i+1,s))      #alternating + and -\\n            return dp[i][s]\\n            \\n        \\n        return solve(0,1)\\n```\\n**I found this some similar to House Robber Problem during the contest**.\\n**If you find this helpful,please do upvote.**",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\n        m=len(nums)\\n        dp=[[-1]*(3) for i in range(m)]\\n        \\n        def solve(i,s):              #i=index, s=sign\\n            if i>=m:\\n                return 0\\n            \\n            if dp[i][s]!=-1:\\n                return dp[i][s]\\n            \\n            dp[i][s]= max(s*nums[i]+solve(i+1,-1*s),solve(i+1,s))      #alternating + and -\\n            return dp[i][s]\\n            \\n        \\n        return solve(0,1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298803,
                "title": "simple-java-code-with-detailed-explanation",
                "content": "This problem is a variant (approximately, not exactly) of buying and selling stocks. This means, all we need to do is find the maximum element of an increasing sequence and then find the minimum element of a decreasing sequence. The maximum element will contribute in a positive way in the overall sum whereas the minimum will contribute in a negative way, giving us the max diff.\\n\\n\\nAlso, selecting odd number of elements will always be beneficial as the extra element in the last which we could have added, would have contributed in a negative way.\\n\\n```\\nclass Solution {\\n    public long maxAlternatingSum(int[] nums) {\\n        long ans = 0;\\n        int n = nums.length;\\n        int i = 0;\\n        List<Integer> list = new ArrayList<>();\\n        while(i<n){\\n            while(i+1 < n && nums[i]<nums[i+1]){\\n                i++;\\n            }\\n            list.add(nums[i]);\\n            i++;\\n            while(i+1<n && nums[i]>nums[i+1]){\\n                i++;\\n            }\\n            if(i<n){\\n                list.add(nums[i]);    \\n            }\\n            \\n            i++;\\n        }\\n        int len = list.size();\\n        if(len%2==0){\\n            len--;\\n        }\\n        long mul = 1;\\n        for(i=0;i<len;i++){\\n            ans = ans + mul*list.get(i);\\n            mul *=-1;\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public long maxAlternatingSum(int[] nums) {\\n        long ans = 0;\\n        int n = nums.length;\\n        int i = 0;\\n        List<Integer> list = new ArrayList<>();\\n        while(i<n){\\n            while(i+1 < n && nums[i]<nums[i+1]){\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1298769,
                "title": "go-dp-o-n-o-1",
                "content": "```\\nfunc maxAlternatingSum(nums []int) int64 {\\n    dp := make(map[int64]int64, 2)\\n    for i := 0; i < len(nums); i++ {\\n        x := dp[1] + int64(nums[i])\\n        if x > dp[0]{\\n            dp[0] = x\\n        }\\n        y := dp[0] - int64(nums[i])\\n        if y > dp[1]{\\n            dp[1] = y\\n        }\\n    }\\n    return dp[0];\\n}",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunc maxAlternatingSum(nums []int) int64 {\\n    dp := make(map[int64]int64, 2)\\n    for i := 0; i < len(nums); i++ {\\n        x := dp[1] + int64(nums[i])\\n        if x > dp[0]{\\n            dp[0] = x\\n        }\\n        y := dp[0] - int64(nums[i])\\n        if y > dp[1]{\\n            dp[1] = y\\n        }\\n    }\\n    return dp[0];\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1298659,
                "title": "c-brute-force-to-memoization",
                "content": "During programming interviews, I found it easier to first come up with brute force solution and found the overlapping cases, and we can use memoization to solve that easily.\\n\\nBrute force: \\n```\\n    long long maxAlternatingSum(vector<int>& nums, int add = 1, int i = 0) {\\n        if(i == nums.size()) return 0;\\n        int cur =  nums[i];\\n        if(add) { // You either skip the current one or take the current one depending on whether you subtract or add. \\n\\t\\t\\treturn max(cur + maxAlternatingSum(nums, 0, i + 1), maxAlternatingSum(nums, 1, i + 1));\\n\\t\\t}\\n\\t\\treturn max(-1*cur + maxAlternatingSum(nums, 1, i + 1), maxAlternatingSum(nums, 0, i + 1));\\n    }\\n```\\nObviously there will be overlapping cases, so we store results that are already computed and we dont have to compute again. \\nMemoization solution: \\n\\n```\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        vector<vector<long long>> memo(2, vector<long long>(nums.size(), 0));\\n        return helper(nums, 1, 0, memo);\\n    }\\n    \\n    long long helper(vector<int>& nums, int add, int i, vector<vector<long long>>& memo) {\\n        if(i == nums.size()) return 0;\\n        int cur =  nums[i];\\n        if(!memo[add][i]) {\\n            if(add) {\\n                memo[add][i] = max(cur + helper(nums, 0, i + 1, memo), helper(nums, 1, i + 1, memo));\\n            } else {\\n                memo[add][i] = max(-1*cur + helper(nums, 1, i + 1, memo), helper(nums, 0, i + 1, memo));\\n            }\\n        }\\n        return memo[add][i];\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    long long maxAlternatingSum(vector<int>& nums, int add = 1, int i = 0) {\\n        if(i == nums.size()) return 0;\\n        int cur =  nums[i];\\n        if(add) { // You either skip the current one or take the current one depending on whether you subtract or add. \\n\\t\\t\\treturn max(cur + maxAlternatingSum(nums, 0, i + 1), maxAlternatingSum(nums, 1, i + 1));\\n\\t\\t}\\n\\t\\treturn max(-1*cur + maxAlternatingSum(nums, 1, i + 1), maxAlternatingSum(nums, 0, i + 1));\\n    }\\n```\n```\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        vector<vector<long long>> memo(2, vector<long long>(nums.size(), 0));\\n        return helper(nums, 1, 0, memo);\\n    }\\n    \\n    long long helper(vector<int>& nums, int add, int i, vector<vector<long long>>& memo) {\\n        if(i == nums.size()) return 0;\\n        int cur =  nums[i];\\n        if(!memo[add][i]) {\\n            if(add) {\\n                memo[add][i] = max(cur + helper(nums, 0, i + 1, memo), helper(nums, 1, i + 1, memo));\\n            } else {\\n                memo[add][i] = max(-1*cur + helper(nums, 1, i + 1, memo), helper(nums, 0, i + 1, memo));\\n            }\\n        }\\n        return memo[add][i];\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1298628,
                "title": "simple-recursive-and-iterative-dp-faster-than-100-space-better-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    long long dp[100001][2];\\n    \\n    long long go1(vector<int>& nums, int index, int find) {\\n        if (dp[index][find] != -1) {\\n            return dp[index][find];\\n        } else {\\n            if (index == 0) {\\n                return dp[index][find] = 0;\\n            } else {\\n                if (find == 1) {\\n                    return dp[index][find] = max(nums[index-1]+go1(nums, index-1, 0), go1(nums, index-1, 1));\\n                } else {\\n                    return dp[index][find] = max(go1(nums, index-1, 1) - nums[index-1], go1(nums, index-1, 0));\\n                }\\n            }\\n        }\\n    }\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        memset(dp, -1, sizeof(dp));\\n        return go1(nums, nums.size(), 1);\\n    }\\n};\\n```\\n\\nWhen this code is changed into iterative dp: \\n```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        int n = nums.size();\\n        long long dp[n+1][2];\\n        dp[0][0] = 0;\\n        dp[0][1] = 0;\\n        for (int i=1; i<=n; i++) {\\n            dp[i][0] = max(nums[i-1] + dp[i-1][1], dp[i-1][0]);\\n            dp[i][1] = max(dp[i-1][0] - nums[i-1], dp[i-1][1]);\\n        }\\n        return dp[n][0];\\n    }\\n};\\n```\\n\\nUpvote if you like it!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[100001][2];\\n    \\n    long long go1(vector<int>& nums, int index, int find) {\\n        if (dp[index][find] != -1) {\\n            return dp[index][find];\\n        } else {\\n            if (index == 0) {\\n                return dp[index][find] = 0;\\n            } else {\\n                if (find == 1) {\\n                    return dp[index][find] = max(nums[index-1]+go1(nums, index-1, 0), go1(nums, index-1, 1));\\n                } else {\\n                    return dp[index][find] = max(go1(nums, index-1, 1) - nums[index-1], go1(nums, index-1, 0));\\n                }\\n            }\\n        }\\n    }\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        memset(dp, -1, sizeof(dp));\\n        return go1(nums, nums.size(), 1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        int n = nums.size();\\n        long long dp[n+1][2];\\n        dp[0][0] = 0;\\n        dp[0][1] = 0;\\n        for (int i=1; i<=n; i++) {\\n            dp[i][0] = max(nums[i-1] + dp[i-1][1], dp[i-1][0]);\\n            dp[i][1] = max(dp[i-1][0] - nums[i-1], dp[i-1][1]);\\n        }\\n        return dp[n][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298621,
                "title": "simple-java-5-liner-solution",
                "content": "```\\nclass Solution {\\n    public long maxAlternatingSum(int[] nums) {\\n        long maxPlus = 0, maxMinus = 0;\\n        for (int i=0; i<nums.length; i++) {\\n            maxPlus = Math.max(maxPlus, maxMinus + nums[i]);\\n            maxMinus = Math.max(maxMinus, maxPlus - nums[i]);\\n        }\\n        return Math.max(maxPlus, maxMinus);\\n    }\\n}\\n```\\n\\nHere `maxPlus` and `maxMinux` refer to the maximum alternating sum ending with an addition (odd number of elements) or a subtraction.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long maxAlternatingSum(int[] nums) {\\n        long maxPlus = 0, maxMinus = 0;\\n        for (int i=0; i<nums.length; i++) {\\n            maxPlus = Math.max(maxPlus, maxMinus + nums[i]);\\n            maxMinus = Math.max(maxMinus, maxPlus - nums[i]);\\n        }\\n        return Math.max(maxPlus, maxMinus);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298615,
                "title": "c-simple-solution-single-traversal-o-n-time-and-o-1-space",
                "content": "We will traverse the array and first pick the maximum in an increasing sequence and then the minimum in an decreasing sequence.\\nFinally we will remove the last number in 2nd sequence if it\\'s last\\n\\n\\t\\'\\'\\'\\n\\t long long maxAlternatingSum(vector<int>& a) {\\n        int n=a.size();\\n\\t\\t//We divide it into two sequences, the first one in which all numbers of even position will bw there and in second all numbers of odd position \\n        int i=0; \\n        long long b=0,c=0; // b is 1st sequence and c is second sequence\\n        int prev=0;\\n        while(i<n){\\n            while(i<n-1 and a[i+1]>a[i])\\n                ++i;\\n            if(i<n){\\n               b+=a[i];\\n                prev=0; // if this is last then nothing will be subtracted from second\\n            }\\n            ++i;\\n            while(i<n-1 and a[i]>a[i+1])\\n                ++i;\\n            if(i<n){\\n                c+=a[i];\\n                prev=a[i]; // if this is last then we don\\'t need this as we have to maximise the difference\\n            }\\n            ++i;\\n        }\\n        c-=prev;  // if the last number is in 2nd then we subtract it\\n        return b-c; // finally return the difference of both sequences\\n    }",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "We will traverse the array and first pick the maximum in an increasing sequence and then the minimum in an decreasing sequence.\\nFinally we will remove the last number in 2nd sequence if it\\'s last\\n\\n\\t\\'\\'\\'\\n\\t long long maxAlternatingSum(vector<int>& a) {\\n        int n=a.size();\\n\\t\\t//We divide it into two sequences, the first one in which all numbers of even position will bw there and in second all numbers of odd position \\n        int i=0; \\n        long long b=0,c=0; // b is 1st sequence and c is second sequence\\n        int prev=0;\\n        while(i<n){\\n            while(i<n-1 and a[i+1]>a[i])\\n                ++i;\\n            if(i<n){\\n               b+=a[i];\\n                prev=0; // if this is last then nothing will be subtracted from second\\n            }\\n            ++i;\\n            while(i<n-1 and a[i]>a[i+1])\\n                ++i;\\n            if(i<n){\\n                c+=a[i];\\n                prev=a[i]; // if this is last then we don\\'t need this as we have to maximise the difference\\n            }\\n            ++i;\\n        }\\n        c-=prev;  // if the last number is in 2nd then we subtract it\\n        return b-c; // finally return the difference of both sequences\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1298608,
                "title": "python-stack-solution-o-n",
                "content": "```\\nclass Solution:\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\n        stack = []\\n        count = 0\\n        for i, num in enumerate(nums):\\n            if not stack:\\n                stack.append(num)\\n            else:\\n                if nums[i] > nums[i - 1]:\\n                    if stack[-1] - nums[i - 1] + num > num:\\n                        stack.append(stack.pop() - nums[i - 1])\\n                        stack.append(num)                    \\n                    else:\\n                        stack[-1] = num\\n                \\n        return sum(stack)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\n        stack = []\\n        count = 0\\n        for i, num in enumerate(nums):\\n            if not stack:\\n                stack.append(num)\\n            else:\\n                if nums[i] > nums[i - 1]:\\n                    if stack[-1] - nums[i - 1] + num > num:\\n                        stack.append(stack.pop() - nums[i - 1])\\n                        stack.append(num)                    \\n                    else:\\n                        stack[-1] = num\\n                \\n        return sum(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298594,
                "title": "simple-traversal-c-easy-o-n-explained",
                "content": "simple idea is just to traverse the vector if we find more difference btw even and odd position just replace them to result vector.\\n```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& v) {\\n        vector<int> t;\\n        t.push_back(v[0]);\\n        bool f=0;\\n        for(int i=1;i<v.size();i++)\\n        {\\n            if(f==0)\\n            {\\n                if(t.back()<=v[i])\\n                    t.back()=v[i];\\n                else \\n                    t.push_back(v[i]),f=!f;\\n            }\\n            else \\n            {\\n                if(t.back()<v[i])\\n                    t.push_back(v[i]),f=!f;\\n                else\\n                    t.back()=v[i];   \\n            }   \\n        }\\n        if(f)t.pop_back();\\n        long ans=0;\\n        for(int i=0;i<t.size();i++)\\n        {\\n            if(i%2==0)ans+=t[i];\\n            else ans-=t[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& v) {\\n        vector<int> t;\\n        t.push_back(v[0]);\\n        bool f=0;\\n        for(int i=1;i<v.size();i++)\\n        {\\n            if(f==0)\\n            {\\n                if(t.back()<=v[i])\\n                    t.back()=v[i];\\n                else \\n                    t.push_back(v[i]),f=!f;\\n            }\\n            else \\n            {\\n                if(t.back()<v[i])\\n                    t.push_back(v[i]),f=!f;\\n                else\\n                    t.back()=v[i];   \\n            }   \\n        }\\n        if(f)t.pop_back();\\n        long ans=0;\\n        for(int i=0;i<t.size();i++)\\n        {\\n            if(i%2==0)ans+=t[i];\\n            else ans-=t[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298592,
                "title": "c-easy-to-read-one-pass-scan-solution-performance-100-memory-100",
                "content": "~~~\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        int n = nums.size(), up = nums[0], i = 0;\\n        long long ret = 0;\\n\\n        // each iteration in the loop is:\\n        // 1) to find the last of incresing subsequence, \\n        //    this will be the next even element\\n        // 2) to add it to the solution\\n        // 3) to find the last of decresing subsequence\\n        //    if it is not the last element, it will be the next odd elemwent\\n        // 4) to adjust the up bound for next iteration\\n        while (i < n) {\\n            // searching for up bound (or, even index element)\\n            while (i < n && nums[i] >= up) up = nums[i++];\\n            // picking it up\\n            ret += up;\\n            // if there is only one element remaining, ignore it \\n            if (i >= n - 1) break;\\n            \\n            // searching for low bound (or next odd index element)\\n            int low = nums[i];\\n            while (i < n && nums[i] <= low) low = nums[i++];\\n            if (i > n - 1) break;\\n            \\n            // picking it up so that we can add another even index element\\n            ret -= low;\\n            \\n            // adjusting up bound\\n            up = low;\\n        }\\n        return ret;\\n    }\\n};\\n~~~\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        int n = nums.size(), up = nums[0], i = 0;\\n        long long ret = 0;\\n\\n        // each iteration in the loop is:\\n        // 1) to find the last of incresing subsequence, \\n        //    this will be the next even element\\n        // 2) to add it to the solution\\n        // 3) to find the last of decresing subsequence\\n        //    if it is not the last element, it will be the next odd elemwent\\n        // 4) to adjust the up bound for next iteration\\n        while (i < n) {\\n            // searching for up bound (or, even index element)\\n            while (i < n && nums[i] >= up) up = nums[i++];\\n            // picking it up\\n            ret += up;\\n            // if there is only one element remaining, ignore it \\n            if (i >= n - 1) break;\\n            \\n            // searching for low bound (or next odd index element)\\n            int low = nums[i];\\n            while (i < n && nums[i] <= low) low = nums[i++];\\n            if (i > n - 1) break;\\n            \\n            // picking it up so that we can add another even index element\\n            ret -= low;\\n            \\n            // adjusting up bound\\n            up = low;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1298497,
                "title": "c-greedy-approach-o-n-time-o-1-space",
                "content": "##### Consider the following cases\\n\\n1. [5,6] : In this case you would simply take [6]\\n2. [5,6,1] : Even in this case you will take [6]\\n3. [5,4,2] : In this case you will take [5]\\n4. [5,4,6] : You\\'ll take [5,4,6] since 5 - 4 + 6 = 7.\\n4. [5,4,2,6] : In this case you will take [5,2,6] since 5 - 2 + 6 = 9\\n[5,4,2,6, 1] : In this case you will take [5,2,6] ie. you won\\'t take the last number for substraction\\n\\n##### Conclusions from the above\\n\\n1. If our substraction is the last element or substraction element is more than positive element, then no need to substract\\n```\\nif(neg == INT_MAX || idx == nums.size()) ans += pos; // Don\\'t substract\\nelse ans += (pos - neg);\\n```\\n\\n2. After we fix our positive element, if we find an element more than our positive element, then update the positive element.\\n\\n```\\nif(nums[idx] >= pos) {\\n\\tpos = nums[idx++];\\n\\tcontinue;\\n} \\n```\\n\\n3. After we fix our negative element, if we find an element lesser than our negative element, then  update the negative element.\\n\\n```\\nelse {\\n\\tneg = min(neg,(long long)nums[idx++]);\\n}\\n```\\n\\n4. After we fix our negative element, if we find an element greater than our negative element, then we use that as our next positive element so break the negative element search.\\n\\n```\\nif(nums[idx] > neg) {\\n\\tbreak;\\n}\\n```\\n\\n##### Code\\n\\n```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        long long ans = 0;\\n        long long pos = 0, neg = INT_MAX;\\n        int idx = 0;\\n        while(idx != nums.size()) {\\n            pos = nums[idx++]; // Fix positive element\\n            while(idx != nums.size()) {\\n                if(nums[idx] > neg) { // Current element greater than negative element\\n                    break;\\n                }\\n                if(nums[idx] >= pos) { // Current element greater than positive element\\n                    pos = nums[idx++];\\n                    continue;\\n                } else {\\n                    neg = min(neg,(long long)nums[idx++]); // Update negative element\\n                }\\n            }\\n            if(neg == INT_MAX || idx == nums.size()) ans += pos; // If not last or negative greater than positive\\n            else ans += (pos - neg);\\n            neg = INT_MAX;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nif(neg == INT_MAX || idx == nums.size()) ans += pos; // Don\\'t substract\\nelse ans += (pos - neg);\\n```\n```\\nif(nums[idx] >= pos) {\\n\\tpos = nums[idx++];\\n\\tcontinue;\\n} \\n```\n```\\nelse {\\n\\tneg = min(neg,(long long)nums[idx++]);\\n}\\n```\n```\\nif(nums[idx] > neg) {\\n\\tbreak;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        long long ans = 0;\\n        long long pos = 0, neg = INT_MAX;\\n        int idx = 0;\\n        while(idx != nums.size()) {\\n            pos = nums[idx++]; // Fix positive element\\n            while(idx != nums.size()) {\\n                if(nums[idx] > neg) { // Current element greater than negative element\\n                    break;\\n                }\\n                if(nums[idx] >= pos) { // Current element greater than positive element\\n                    pos = nums[idx++];\\n                    continue;\\n                } else {\\n                    neg = min(neg,(long long)nums[idx++]); // Update negative element\\n                }\\n            }\\n            if(neg == INT_MAX || idx == nums.size()) ans += pos; // If not last or negative greater than positive\\n            else ans += (pos - neg);\\n            neg = INT_MAX;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298480,
                "title": "one-pass-python-solution",
                "content": "```\\nflag, result = 1, 0\\nnums.append(-1)\\nfor i in range(len(nums) - 1):\\n\\tif flag and nums[i] > nums[i + 1]:\\n\\t\\tresult += nums[i]\\n\\t\\tflag ^= 1\\n\\telif not flag and nums[i] < nums[i + 1]:\\n\\t\\tresult -= nums[i]\\n\\t\\tflag ^= 1\\nreturn result\\n```",
                "solutionTags": [],
                "code": "```\\nflag, result = 1, 0\\nnums.append(-1)\\nfor i in range(len(nums) - 1):\\n\\tif flag and nums[i] > nums[i + 1]:\\n\\t\\tresult += nums[i]\\n\\t\\tflag ^= 1\\n\\telif not flag and nums[i] < nums[i + 1]:\\n\\t\\tresult -= nums[i]\\n\\t\\tflag ^= 1\\nreturn result\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1298479,
                "title": "c-o-n-solution-with-explanation-and-example",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        // 1) First take 0 index element to be added to answer ( At Present this is  the candidate element which can be added to our answer) \\n        // 2 ) Now we want a number which is less than our candidate number  . If we found, then we can easily add our candidate number to       \\n        //    answer and now we want a number which can be subtracted from our sum. So this number will be now candidate to be decrease from our sum. \\n\\t\\t//     Now Same process will begin with the fact that now we want a element which is greater than our candidate.\\n        // 3) Else if we don\\'t find (when we find a number which is greater than our candidate) then we will update our candidate to this number\\n        \\n        // For eg. let we have 6 2 1 2 4 5\\n        // --> Candidate ele= 6. search for smaller element. we found that 2 is smaller so we can easily add 6 to our answer.\\n        // --> Now candidate ele=2 Search for greater element. we found that 1 is smaller this means that 1 will benefit us. So updated candidate is 1\\n        //  --> Now we found 2 is greater so we decrease 1 from our answer. New candidate is 2 and now we want to search for smaller element\\n        // This will continue in same fashion \\n        long long sum=0;\\n        int pos=0,neg;\\n        bool flag=0; \\n        for(int i=1;i<nums.size();i++){\\n            //-ve\\n            if(!flag){\\n                if(nums[i]<nums[pos]){\\n                    neg=i;\\n                    sum+=nums[pos];\\n                    flag=!flag;\\n                }\\n                else{\\n                    pos=i;\\n                }\\n            }\\n            else{\\n                if(nums[i]>nums[neg]){\\n                    sum-=nums[neg];\\n                    pos=i;\\n                    flag=!flag;\\n                }\\n                else{\\n                    neg=i;\\n                }\\n            }\\n        }\\n        if(!flag){\\n            sum+=nums[pos];\\n        }\\n        return sum;\\n    }\\n};\\n\\nUpvote if u like it :)\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        // 1) First take 0 index element to be added to answer ( At Present this is  the candidate element which can be added to our answer) \\n        // 2 ) Now we want a number which is less than our candidate number  . If we found, then we can easily add our candidate number to       \\n        //    answer and now we want a number which can be subtracted from our sum. So this number will be now candidate to be decrease from our sum. \\n\\t\\t//     Now Same process will begin with the fact that now we want a element which is greater than our candidate.\\n        // 3) Else if we don\\'t find (when we find a number which is greater than our candidate) then we will update our candidate to this number\\n        \\n        // For eg. let we have 6 2 1 2 4 5\\n        // --> Candidate ele= 6. search for smaller element. we found that 2 is smaller so we can easily add 6 to our answer.\\n        // --> Now candidate ele=2 Search for greater element. we found that 1 is smaller this means that 1 will benefit us. So updated candidate is 1\\n        //  --> Now we found 2 is greater so we decrease 1 from our answer. New candidate is 2 and now we want to search for smaller element\\n        // This will continue in same fashion \\n        long long sum=0;\\n        int pos=0,neg;\\n        bool flag=0; \\n        for(int i=1;i<nums.size();i++){\\n            //-ve\\n            if(!flag){\\n                if(nums[i]<nums[pos]){\\n                    neg=i;\\n                    sum+=nums[pos];\\n                    flag=!flag;\\n                }\\n                else{\\n                    pos=i;\\n                }\\n            }\\n            else{\\n                if(nums[i]>nums[neg]){\\n                    sum-=nums[neg];\\n                    pos=i;\\n                    flag=!flag;\\n                }\\n                else{\\n                    neg=i;\\n                }\\n            }\\n        }\\n        if(!flag){\\n            sum+=nums[pos];\\n        }\\n        return sum;\\n    }\\n};\\n\\nUpvote if u like it :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298471,
                "title": "python-flag-n",
                "content": "**Python**\\n\\n*Use flag to determine whether you have to go for next larger number or smaller number*\\n\\n```python\\n\\nclass Solution:\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\n        tot = 0;flag = 1\\n        maxi = nums[0]; mini = float(\"inf\")\\n        for i in range(1,len(nums)):\\n            if flag:\\n                if nums[i] < maxi:\\n                    tot += maxi\\n                    flag = 0\\n                    mini = nums[i]\\n                    maxi = 0\\n                else:\\n                    maxi = max(nums[i],maxi)\\n\\n            else:\\n                if nums[i] > mini:\\n                    tot -= mini\\n                    flag = 1\\n                    maxi = nums[i]\\n                else:\\n                    mini = min(nums[i],mini)\\n\\n        return tot+maxi\\n        \\n```",
                "solutionTags": [],
                "code": "```python\\n\\nclass Solution:\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\n        tot = 0;flag = 1\\n        maxi = nums[0]; mini = float(\"inf\")\\n        for i in range(1,len(nums)):\\n            if flag:\\n                if nums[i] < maxi:\\n                    tot += maxi\\n                    flag = 0\\n                    mini = nums[i]\\n                    maxi = 0\\n                else:\\n                    maxi = max(nums[i],maxi)\\n\\n            else:\\n                if nums[i] > mini:\\n                    tot -= mini\\n                    flag = 1\\n                    maxi = nums[i]\\n                else:\\n                    mini = min(nums[i],mini)\\n\\n        return tot+maxi\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298456,
                "title": "python3-dp-o-n-o-1-one-pass",
                "content": "```\\nclass Solution:\\n    # observation:\\n    #   consider sequence [a0, a1, a2, ..., an]\\n    #   `alternatingSum(a0, a1, ..., an) = a0 - a1 + ... = a0 - (a1 - a2 + a3 - ...) = a0 - alternatingSum(a1, ..., an)`\\n    #   so that we have a subproblem of the same type\\n    # \\n    # idea:\\n    #   consider: [a0, a1, a2, ..., an]\\n    #   there are 2 cases:\\n    #     1. take a0 into our subsequence, then result `a0 - minAlternatingSum(a1, a2, ..., an)`\\n    #     2. skip a0, then result is `maxAlternatingSum(a1, a2, ..., an)`\\n    #   \\n    #   so we need to take `max` out of these two cases,\\n    #   `minAlternatingSum` is solved in the same way but with taking `min`\\n    #\\n    #   dp format is `dp[i] = [maxAlternatingSum(ai..an), maxAlternatingSum(ai..an)]\\n    #   dp transition is `dp[i] = [\\n    #       max(dp[i - 1][0], nums[i] - dp[i - 1][1]),\\n    #       min(dp[i - 1][1], nums[i] - dp[i - 1][0])\\n    #   ]`\\n    #\\n    \\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\n        max_min = (0, 0)\\n        for num in nums:\\n            max_min = (\\n                max(max_min[0], num - max_min[1]),\\n                min(max_min[1], num - max_min[0])\\n            )\\n        return max_min[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # observation:\\n    #   consider sequence [a0, a1, a2, ..., an]\\n    #   `alternatingSum(a0, a1, ..., an) = a0 - a1 + ... = a0 - (a1 - a2 + a3 - ...) = a0 - alternatingSum(a1, ..., an)`\\n    #   so that we have a subproblem of the same type\\n    # \\n    # idea:\\n    #   consider: [a0, a1, a2, ..., an]\\n    #   there are 2 cases:\\n    #     1. take a0 into our subsequence, then result `a0 - minAlternatingSum(a1, a2, ..., an)`\\n    #     2. skip a0, then result is `maxAlternatingSum(a1, a2, ..., an)`\\n    #   \\n    #   so we need to take `max` out of these two cases,\\n    #   `minAlternatingSum` is solved in the same way but with taking `min`\\n    #\\n    #   dp format is `dp[i] = [maxAlternatingSum(ai..an), maxAlternatingSum(ai..an)]\\n    #   dp transition is `dp[i] = [\\n    #       max(dp[i - 1][0], nums[i] - dp[i - 1][1]),\\n    #       min(dp[i - 1][1], nums[i] - dp[i - 1][0])\\n    #   ]`\\n    #\\n    \\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\n        max_min = (0, 0)\\n        for num in nums:\\n            max_min = (\\n                max(max_min[0], num - max_min[1]),\\n                min(max_min[1], num - max_min[0])\\n            )\\n        return max_min[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298438,
                "title": "a-few-solutions",
                "content": "Consider the ups/downs of a linear scan of `A` as mountain \"peaks\" and \"valleys\".  Then we can return `best` accumulated alternating sum from peak-to-peak inclusive.\\n    \\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun maxAlternatingSum(A: IntArray): Long {\\n        var best = mutableListOf<Long>()\\n        var N = A.size\\n        var i = 0\\n        while (i < N) {\\n            while (i + 1 < N && A[i] < A[i + 1]) ++i; best.add(A[i].toLong())  // \\uD83D\\uDC46 peak\\n            if (++i == N) break\\n            while (i + 1 < N && A[i + 1] < A[i]) ++i; best.add(A[i].toLong())  // \\uD83D\\uDC47 valley\\n        }\\n        if (best.size % 2 == 0)   // \\u2B50\\uFE0F peak-to-peak has odd cardinality (ie. drop last valley)\\n            best = best.dropLast(1).toMutableList()\\n        return best.toList().mapIndexed{ i, x -> if (i % 2 == 0) x else -x }.sum()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet maxAlternatingSum = (A, best = []) => {\\n    let N = A.length,\\n        i = 0;\\n    while (i < N) {\\n        while (i + 1 < N && A[i] < A[i + 1]) ++i; best.push(A[i]);  // \\uD83D\\uDC46 peak\\n        if (++i == N) break;\\n        while (i + 1 < N && A[i + 1] < A[i]) ++i; best.push(A[i]);  // \\uD83D\\uDC47 valley\\n    }\\n    if (!(best.length & 1))  // \\u2B50\\uFE0F peak-to-peak has odd cardinality (ie. drop last valley)\\n        best.pop();\\n    return _.sum(best.map((x, i) => i & 1 ? -x : x));\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def maxAlternatingSum(self, A: List[int]) -> int:\\n        best = []\\n        N = len(A)\\n        i = 0\\n        while i < N:\\n            while i + 1 < N and A[i] < A[i + 1]: i += 1  # \\uD83D\\uDC46 peak\\n            best.append(A[i])\\n            i += 1\\n            if i == N: break\\n            while i + 1 < N and A[i + 1] < A[i]: i += 1  # \\uD83D\\uDC47 valley\\n            best.append(A[i])\\n        if not (len(best) & 1):  # \\u2B50\\uFE0F peak-to-peak has odd cardinality (ie. drop last valley)\\n            best.pop()\\n        return sum(-x if i & 1 else x for i, x in enumerate(best))\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using LL = long long;\\n    using VLL = vector<LL>;\\n    LL maxAlternatingSum(VI& A, VLL best = {}) {\\n        int N = A.size(),\\n            i = 0;\\n        while (i < N) {\\n            while (i + 1 < N && A[i] < A[i + 1]) ++i; best.push_back(A[i]);  // \\uD83D\\uDC46 peak\\n            if (++i == N) break;\\n            while (i + 1 < N && A[i + 1] < A[i]) ++i; best.push_back(A[i]);  // \\uD83D\\uDC47 valley\\n        }\\n        if (!(best.size() & 1))  // \\u2B50\\uFE0F peak-to-peak has odd cardinality (ie. drop last valley)\\n            best.pop_back();\\n        return accumulate(best.begin(), best.end(), 0LL, [i = -1](auto t, auto x) mutable {\\n            return t + (++i & 1 ? -x : x);\\n        });\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun maxAlternatingSum(A: IntArray): Long {\\n        var best = mutableListOf<Long>()\\n        var N = A.size\\n        var i = 0\\n        while (i < N) {\\n            while (i + 1 < N && A[i] < A[i + 1]) ++i; best.add(A[i].toLong())  // \\uD83D\\uDC46 peak\\n            if (++i == N) break\\n            while (i + 1 < N && A[i + 1] < A[i]) ++i; best.add(A[i].toLong())  // \\uD83D\\uDC47 valley\\n        }\\n        if (best.size % 2 == 0)   // \\u2B50\\uFE0F peak-to-peak has odd cardinality (ie. drop last valley)\\n            best = best.dropLast(1).toMutableList()\\n        return best.toList().mapIndexed{ i, x -> if (i % 2 == 0) x else -x }.sum()\\n    }\\n}\\n```\n```\\nlet maxAlternatingSum = (A, best = []) => {\\n    let N = A.length,\\n        i = 0;\\n    while (i < N) {\\n        while (i + 1 < N && A[i] < A[i + 1]) ++i; best.push(A[i]);  // \\uD83D\\uDC46 peak\\n        if (++i == N) break;\\n        while (i + 1 < N && A[i + 1] < A[i]) ++i; best.push(A[i]);  // \\uD83D\\uDC47 valley\\n    }\\n    if (!(best.length & 1))  // \\u2B50\\uFE0F peak-to-peak has odd cardinality (ie. drop last valley)\\n        best.pop();\\n    return _.sum(best.map((x, i) => i & 1 ? -x : x));\\n};\\n```\n```\\nclass Solution:\\n    def maxAlternatingSum(self, A: List[int]) -> int:\\n        best = []\\n        N = len(A)\\n        i = 0\\n        while i < N:\\n            while i + 1 < N and A[i] < A[i + 1]: i += 1  # \\uD83D\\uDC46 peak\\n            best.append(A[i])\\n            i += 1\\n            if i == N: break\\n            while i + 1 < N and A[i + 1] < A[i]: i += 1  # \\uD83D\\uDC47 valley\\n            best.append(A[i])\\n        if not (len(best) & 1):  # \\u2B50\\uFE0F peak-to-peak has odd cardinality (ie. drop last valley)\\n            best.pop()\\n        return sum(-x if i & 1 else x for i, x in enumerate(best))\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using LL = long long;\\n    using VLL = vector<LL>;\\n    LL maxAlternatingSum(VI& A, VLL best = {}) {\\n        int N = A.size(),\\n            i = 0;\\n        while (i < N) {\\n            while (i + 1 < N && A[i] < A[i + 1]) ++i; best.push_back(A[i]);  // \\uD83D\\uDC46 peak\\n            if (++i == N) break;\\n            while (i + 1 < N && A[i + 1] < A[i]) ++i; best.push_back(A[i]);  // \\uD83D\\uDC47 valley\\n        }\\n        if (!(best.size() & 1))  // \\u2B50\\uFE0F peak-to-peak has odd cardinality (ie. drop last valley)\\n            best.pop_back();\\n        return accumulate(best.begin(), best.end(), 0LL, [i = -1](auto t, auto x) mutable {\\n            return t + (++i & 1 ? -x : x);\\n        });\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298432,
                "title": "c-o-n-simple-solution-and-explanation",
                "content": "Things to note: \\n- There are no negative numbers.\\n- Odd and even is with respect to the order of the subsequence.\\n- We never want to return a subsequence that ended with an odd index, only the ones that ended with an addition will be considered.\\n\\nWhat we need to do is keep track of the largest odd and even subsequence starting them at 0 ( as there are no negative numbers ).\\n\\n`up` is going to be the subsequence that added `nums[i]` and `down` is the subsequence that subtracted `nums[i]`.\\n\\nWe add `nums[i]` to the max `down` subsequence to get the max `up` subsequence, and we subtract `nums[i]` to the max `up` subsequence\\nto get the max `down` subsequence.\\n\\nAfter doing that for all numbers we have the answer in `up`.\\n\\nLastly, `long long` is redundant in modern compilers. A single `long` will give you a 64 bit number already :)\\n\\n```cpp\\nlong maxAlternatingSum(vector<int>& nums) \\n{\\n    long up = 0, down = 0;\\n    for( long n : nums )\\n    {\\n        long tmp = up;\\n        up = max( up, down+n );\\n        down = max( down, tmp-n );\\n    }\\n    return up;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nlong maxAlternatingSum(vector<int>& nums) \\n{\\n    long up = 0, down = 0;\\n    for( long n : nums )\\n    {\\n        long tmp = up;\\n        up = max( up, down+n );\\n        down = max( down, tmp-n );\\n    }\\n    return up;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4105740,
                "title": "c-easy-solution",
                "content": "# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    vector<vector<long long>>dp;\\r\\n    long long solve(vector<int>& nums,int i,bool even){\\r\\n        if(i == nums.size())\\r\\n            return 0;\\r\\n        if(dp[i][even] != -1)\\r\\n            return dp[i][even];\\r\\n        long long take = INT_MIN;\\r\\n        if(even)\\r\\n            take = nums[i] + solve(nums,i+1,false);\\r\\n        else\\r\\n            take = -nums[i] + solve(nums,i+1,true);\\r\\n        long long notTake = solve(nums,i+1,even);\\r\\n        return dp[i][even] = max(take,notTake);\\r\\n    }\\r\\n    long long maxAlternatingSum(vector<int>& nums) {\\r\\n        dp = vector<vector<long long>>(nums.size(),vector<long long>(2,-1));\\r\\n        return solve(nums,0,true);\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    vector<vector<long long>>dp;\\r\\n    long long solve(vector<int>& nums,int i,bool even){\\r\\n        if(i == nums.size())\\r\\n            return 0;\\r\\n        if(dp[i][even] != -1)\\r\\n            return dp[i][even];\\r\\n        long long take = INT_MIN;\\r\\n        if(even)\\r\\n            take = nums[i] + solve(nums,i+1,false);\\r\\n        else\\r\\n            take = -nums[i] + solve(nums,i+1,true);\\r\\n        long long notTake = solve(nums,i+1,even);\\r\\n        return dp[i][even] = max(take,notTake);\\r\\n    }\\r\\n    long long maxAlternatingSum(vector<int>& nums) {\\r\\n        dp = vector<vector<long long>>(nums.size(),vector<long long>(2,-1));\\r\\n        return solve(nums,0,true);\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4098868,
                "title": "recursive-memoization-dp-with-array-dp-with-constant-space-golang-space-o-1-time-o-n-dp",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n$$\\r\\np(i, sign) = \\\\begin{cases}\\r\\n0 & \\\\text{if } i >= N \\\\\\\\\\r\\nmax\\\\{sign * a[i] + p(i+1, !sign), p(i+1, sign)\\\\} & \\\\text{otherwise}\\r\\n\\\\end{cases}\\r\\n$$\\r\\n\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity: O(n)\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity: O(1)\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nimport \"fmt\"\\r\\n\\r\\n// time O(2^n)\\r\\nfunc maxAlternatingSum_recursive(nums []int) int64 {\\r\\n\\tcount := 0\\r\\n\\tvar dfs func(i int, sign bool) int64\\r\\n\\tdfs = func(i int, sign bool) int64 {\\r\\n\\t\\tcount++\\r\\n\\t\\tif i == len(nums) {\\r\\n\\t\\t\\treturn 0\\r\\n\\t\\t}\\r\\n\\t\\treturn max(\\r\\n\\t\\t\\tint64(sign2num(sign)*nums[i])+dfs(i+1, !sign),\\r\\n\\t\\t\\tdfs(i+1, sign),\\r\\n\\t\\t)\\r\\n\\t}\\r\\n\\tres := dfs(0, true)\\r\\n\\tfmt.Printf(\"count %d\\\\n\", count)\\r\\n\\treturn res\\r\\n}\\r\\n\\r\\nfunc max(a, b int64) int64 {\\r\\n\\tif a > b {\\r\\n\\t\\treturn a\\r\\n\\t}\\r\\n\\treturn b\\r\\n}\\r\\n\\r\\nfunc sign2num(sign bool) int {\\r\\n\\tif sign {\\r\\n\\t\\treturn 1\\r\\n\\t} else {\\r\\n\\t\\treturn -1\\r\\n\\t}\\r\\n}\\r\\n\\r\\n// cache with map\\r\\n// time O(n), space O(n)\\r\\nfunc maxAlternatingSum_memoization(nums []int) int64 {\\r\\n\\tcount := 0\\r\\n\\ttype item struct {\\r\\n\\t\\ti    int\\r\\n\\t\\tsign bool\\r\\n\\t}\\r\\n\\tdp := make(map[item]int64)\\r\\n\\tvar dfs func(i int, sign bool) int64\\r\\n\\tdfs = func(i int, sign bool) int64 {\\r\\n\\t\\tcount++\\r\\n\\t\\tif ans, exists := dp[item{i, sign}]; exists {\\r\\n\\t\\t\\treturn ans\\r\\n\\t\\t}\\r\\n\\t\\tif i == len(nums) {\\r\\n\\t\\t\\treturn 0\\r\\n\\t\\t}\\r\\n\\t\\tres := max(\\r\\n\\t\\t\\tint64(sign2num(sign)*nums[i])+dfs(i+1, !sign),\\r\\n\\t\\t\\tdfs(i+1, sign),\\r\\n\\t\\t)\\r\\n\\t\\tdp[item{i, sign}] = res\\r\\n\\t\\treturn res\\r\\n\\t}\\r\\n\\tres := dfs(0, true)\\r\\n\\tfmt.Printf(\"count %d\\\\n\", count)\\r\\n\\treturn res\\r\\n}\\r\\n\\r\\n// using array\\r\\n// time O(n), space O(n)\\r\\nfunc maxAlternatingSum_memoization2(nums []int) int64 {\\r\\n\\tcount := 0\\r\\n\\tvar (\\r\\n\\t\\tdp_positive = make([]int64, len(nums)+1)\\r\\n\\t\\tdp_negative = make([]int64, len(nums)+1)\\r\\n\\t)\\r\\n\\tdp := func(sign bool) []int64 {\\r\\n\\t\\tif sign {\\r\\n\\t\\t\\treturn dp_positive\\r\\n\\t\\t} else {\\r\\n\\t\\t\\treturn dp_negative\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tvar dfs func(i int, sign bool) int64\\r\\n\\tdfs = func(i int, sign bool) int64 {\\r\\n\\t\\tcount++\\r\\n\\t\\tif ans := dp(sign)[i]; ans != 0 {\\r\\n\\t\\t\\treturn ans\\r\\n\\t\\t}\\r\\n\\t\\tif i == len(nums) {\\r\\n\\t\\t\\treturn 0\\r\\n\\t\\t}\\r\\n\\t\\tres := max(\\r\\n\\t\\t\\tint64(sign2num(sign)*nums[i])+dfs(i+1, !sign),\\r\\n\\t\\t\\tdfs(i+1, sign),\\r\\n\\t\\t)\\r\\n\\t\\tdp(sign)[i] = res\\r\\n\\t\\treturn res\\r\\n\\t}\\r\\n\\tres := dfs(0, true)\\r\\n\\tfmt.Printf(\"count %d\\\\n\", count)\\r\\n\\treturn res\\r\\n}\\r\\n\\r\\n// dp with array\\r\\n// time O(n), space O(n)\\r\\nfunc maxAlternatingSum_dp(nums []int) int64 {\\r\\n\\tcount := 0\\r\\n\\tvar (\\r\\n\\t\\tdp_positive = make([]int64, len(nums)+1)\\r\\n\\t\\tdp_negative = make([]int64, len(nums)+1)\\r\\n\\t)\\r\\n\\tdp := func(sign bool) []int64 {\\r\\n\\t\\tif sign {\\r\\n\\t\\t\\treturn dp_positive\\r\\n\\t\\t} else {\\r\\n\\t\\t\\treturn dp_negative\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tfor i := len(nums) - 1; i >= 0; i-- {\\r\\n\\t\\tcount++\\r\\n\\t\\tdp(true)[i] = max(int64(nums[i])+dp(false)[i+1], dp(true)[i+1])\\r\\n\\t\\tdp(false)[i] = max(int64(-1*nums[i])+dp(true)[i+1], dp(false)[i+1])\\r\\n\\t}\\r\\n\\tres := dp(true)[0]\\r\\n\\tfmt.Printf(\"count %d\\\\n\", count)\\r\\n\\treturn res\\r\\n}\\r\\n\\r\\n// dp with constant space\\r\\n// time O(n), space O(1)\\r\\nfunc maxAlternatingSum_dp2(nums []int) int64 {\\r\\n\\tcount := 0\\r\\n\\tvar (\\r\\n\\t\\tdp_positive int64 = 0\\r\\n\\t\\tdp_negative int64 = 0\\r\\n\\t)\\r\\n\\r\\n\\tfor i := len(nums) - 1; i >= 0; i-- {\\r\\n\\t\\tcount++\\r\\n\\t\\tdp_positive, dp_negative = max(dp_negative+int64(nums[i]), dp_positive), max(dp_positive-int64(nums[i]), dp_negative)\\r\\n\\t}\\r\\n\\tfmt.Printf(\"count %d\\\\n\", count)\\r\\n\\treturn dp_positive\\r\\n}\\r\\n\\r\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\r\\nimport \"fmt\"\\r\\n\\r\\n// time O(2^n)\\r\\nfunc maxAlternatingSum_recursive(nums []int) int64 {\\r\\n\\tcount := 0\\r\\n\\tvar dfs func(i int, sign bool) int64\\r\\n\\tdfs = func(i int, sign bool) int64 {\\r\\n\\t\\tcount++\\r\\n\\t\\tif i == len(nums) {\\r\\n\\t\\t\\treturn 0\\r\\n\\t\\t}\\r\\n\\t\\treturn max(\\r\\n\\t\\t\\tint64(sign2num(sign)*nums[i])+dfs(i+1, !sign),\\r\\n\\t\\t\\tdfs(i+1, sign),\\r\\n\\t\\t)\\r\\n\\t}\\r\\n\\tres := dfs(0, true)\\r\\n\\tfmt.Printf(\"count %d\\\\n\", count)\\r\\n\\treturn res\\r\\n}\\r\\n\\r\\nfunc max(a, b int64) int64 {\\r\\n\\tif a > b {\\r\\n\\t\\treturn a\\r\\n\\t}\\r\\n\\treturn b\\r\\n}\\r\\n\\r\\nfunc sign2num(sign bool) int {\\r\\n\\tif sign {\\r\\n\\t\\treturn 1\\r\\n\\t} else {\\r\\n\\t\\treturn -1\\r\\n\\t}\\r\\n}\\r\\n\\r\\n// cache with map\\r\\n// time O(n), space O(n)\\r\\nfunc maxAlternatingSum_memoization(nums []int) int64 {\\r\\n\\tcount := 0\\r\\n\\ttype item struct {\\r\\n\\t\\ti    int\\r\\n\\t\\tsign bool\\r\\n\\t}\\r\\n\\tdp := make(map[item]int64)\\r\\n\\tvar dfs func(i int, sign bool) int64\\r\\n\\tdfs = func(i int, sign bool) int64 {\\r\\n\\t\\tcount++\\r\\n\\t\\tif ans, exists := dp[item{i, sign}]; exists {\\r\\n\\t\\t\\treturn ans\\r\\n\\t\\t}\\r\\n\\t\\tif i == len(nums) {\\r\\n\\t\\t\\treturn 0\\r\\n\\t\\t}\\r\\n\\t\\tres := max(\\r\\n\\t\\t\\tint64(sign2num(sign)*nums[i])+dfs(i+1, !sign),\\r\\n\\t\\t\\tdfs(i+1, sign),\\r\\n\\t\\t)\\r\\n\\t\\tdp[item{i, sign}] = res\\r\\n\\t\\treturn res\\r\\n\\t}\\r\\n\\tres := dfs(0, true)\\r\\n\\tfmt.Printf(\"count %d\\\\n\", count)\\r\\n\\treturn res\\r\\n}\\r\\n\\r\\n// using array\\r\\n// time O(n), space O(n)\\r\\nfunc maxAlternatingSum_memoization2(nums []int) int64 {\\r\\n\\tcount := 0\\r\\n\\tvar (\\r\\n\\t\\tdp_positive = make([]int64, len(nums)+1)\\r\\n\\t\\tdp_negative = make([]int64, len(nums)+1)\\r\\n\\t)\\r\\n\\tdp := func(sign bool) []int64 {\\r\\n\\t\\tif sign {\\r\\n\\t\\t\\treturn dp_positive\\r\\n\\t\\t} else {\\r\\n\\t\\t\\treturn dp_negative\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tvar dfs func(i int, sign bool) int64\\r\\n\\tdfs = func(i int, sign bool) int64 {\\r\\n\\t\\tcount++\\r\\n\\t\\tif ans := dp(sign)[i]; ans != 0 {\\r\\n\\t\\t\\treturn ans\\r\\n\\t\\t}\\r\\n\\t\\tif i == len(nums) {\\r\\n\\t\\t\\treturn 0\\r\\n\\t\\t}\\r\\n\\t\\tres := max(\\r\\n\\t\\t\\tint64(sign2num(sign)*nums[i])+dfs(i+1, !sign),\\r\\n\\t\\t\\tdfs(i+1, sign),\\r\\n\\t\\t)\\r\\n\\t\\tdp(sign)[i] = res\\r\\n\\t\\treturn res\\r\\n\\t}\\r\\n\\tres := dfs(0, true)\\r\\n\\tfmt.Printf(\"count %d\\\\n\", count)\\r\\n\\treturn res\\r\\n}\\r\\n\\r\\n// dp with array\\r\\n// time O(n), space O(n)\\r\\nfunc maxAlternatingSum_dp(nums []int) int64 {\\r\\n\\tcount := 0\\r\\n\\tvar (\\r\\n\\t\\tdp_positive = make([]int64, len(nums)+1)\\r\\n\\t\\tdp_negative = make([]int64, len(nums)+1)\\r\\n\\t)\\r\\n\\tdp := func(sign bool) []int64 {\\r\\n\\t\\tif sign {\\r\\n\\t\\t\\treturn dp_positive\\r\\n\\t\\t} else {\\r\\n\\t\\t\\treturn dp_negative\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tfor i := len(nums) - 1; i >= 0; i-- {\\r\\n\\t\\tcount++\\r\\n\\t\\tdp(true)[i] = max(int64(nums[i])+dp(false)[i+1], dp(true)[i+1])\\r\\n\\t\\tdp(false)[i] = max(int64(-1*nums[i])+dp(true)[i+1], dp(false)[i+1])\\r\\n\\t}\\r\\n\\tres := dp(true)[0]\\r\\n\\tfmt.Printf(\"count %d\\\\n\", count)\\r\\n\\treturn res\\r\\n}\\r\\n\\r\\n// dp with constant space\\r\\n// time O(n), space O(1)\\r\\nfunc maxAlternatingSum_dp2(nums []int) int64 {\\r\\n\\tcount := 0\\r\\n\\tvar (\\r\\n\\t\\tdp_positive int64 = 0\\r\\n\\t\\tdp_negative int64 = 0\\r\\n\\t)\\r\\n\\r\\n\\tfor i := len(nums) - 1; i >= 0; i-- {\\r\\n\\t\\tcount++\\r\\n\\t\\tdp_positive, dp_negative = max(dp_negative+int64(nums[i]), dp_positive), max(dp_positive-int64(nums[i]), dp_negative)\\r\\n\\t}\\r\\n\\tfmt.Printf(\"count %d\\\\n\", count)\\r\\n\\treturn dp_positive\\r\\n}\\r\\n\\r\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4098001,
                "title": "easy-solution-o-n",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution:\\r\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\r\\n        pm=nums[0]\\r\\n        nm=0\\r\\n        l=[0]*len(nums)\\r\\n        l[0] = nums[0]\\r\\n        for i in range(1,len(nums)):\\r\\n            if pm - nums[i] > nm*(-1) + nums[i]:\\r\\n                l[i] = (pm - nums[i]) * (-1)\\r\\n                if pm < nm*(-1) + nums[i]:\\r\\n                    pm = nm*(-1) + nums[i]\\r\\n                if nm > l[i]:\\r\\n                    nm = l[i]\\r\\n            elif pm - nums[i] < nm*(-1) + nums[i]:\\r\\n                l[i] = nm*(-1) + nums[i]\\r\\n                if nm*(-1) < pm - nums[i]:\\r\\n                    nm = (pm - nums[i])*(-1)\\r\\n                if pm < l[i]:\\r\\n                    pm = l[i]\\r\\n            else:\\r\\n                l[i] = (pm - nums[i]) * (-1)\\r\\n                if nm > l[i]:\\r\\n                    nm = l[i]\\r\\n                if pm < l[i]*(-1):\\r\\n                    pm = [i]\\r\\n        \\r\\n        return max(pm,nm)\\r\\n            \\r\\n            \\r\\n        \\r\\n        print(l)\\r\\n        return max(pm,nm)\\r\\n\\r\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\r\\nclass Solution:\\r\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\r\\n        pm=nums[0]\\r\\n        nm=0\\r\\n        l=[0]*len(nums)\\r\\n        l[0] = nums[0]\\r\\n        for i in range(1,len(nums)):\\r\\n            if pm - nums[i] > nm*(-1) + nums[i]:\\r\\n                l[i] = (pm - nums[i]) * (-1)\\r\\n                if pm < nm*(-1) + nums[i]:\\r\\n                    pm = nm*(-1) + nums[i]\\r\\n                if nm > l[i]:\\r\\n                    nm = l[i]\\r\\n            elif pm - nums[i] < nm*(-1) + nums[i]:\\r\\n                l[i] = nm*(-1) + nums[i]\\r\\n                if nm*(-1) < pm - nums[i]:\\r\\n                    nm = (pm - nums[i])*(-1)\\r\\n                if pm < l[i]:\\r\\n                    pm = l[i]\\r\\n            else:\\r\\n                l[i] = (pm - nums[i]) * (-1)\\r\\n                if nm > l[i]:\\r\\n                    nm = l[i]\\r\\n                if pm < l[i]*(-1):\\r\\n                    pm = [i]\\r\\n        \\r\\n        return max(pm,nm)\\r\\n            \\r\\n            \\r\\n        \\r\\n        print(l)\\r\\n        return max(pm,nm)\\r\\n\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084176,
                "title": "memoized-code",
                "content": "\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\n   public long [][]memo;\\r\\n    public long check(int []nums,int idx,int flag){\\r\\n        if(idx>=nums.length){\\r\\n            return 0;\\r\\n        }\\r\\n        if(memo[idx][flag]!=0){\\r\\n            return memo[idx][flag];\\r\\n        }\\r\\n        long value=nums[idx];\\r\\n        if(flag==1){\\r\\n            value=-value;\\r\\n            \\r\\n        }\\r\\n        long take =check(nums,idx+1,(flag==1)?0:1)+value;\\r\\n        long not_take=check(nums,idx+1,flag);\\r\\n\\r\\n        return memo[idx][flag]=Math.max(take,not_take);\\r\\n    }\\r\\n    public long maxAlternatingSum(int[] nums) {\\r\\n        int n=nums.length;\\r\\n        memo=new long [n][2];\\r\\n\\r\\n       return  check(nums,0,0);\\r\\n    }\\r\\n}\\r\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\r\\nclass Solution {\\r\\n   public long [][]memo;\\r\\n    public long check(int []nums,int idx,int flag){\\r\\n        if(idx>=nums.length){\\r\\n            return 0;\\r\\n        }\\r\\n        if(memo[idx][flag]!=0){\\r\\n            return memo[idx][flag];\\r\\n        }\\r\\n        long value=nums[idx];\\r\\n        if(flag==1){\\r\\n            value=-value;\\r\\n            \\r\\n        }\\r\\n        long take =check(nums,idx+1,(flag==1)?0:1)+value;\\r\\n        long not_take=check(nums,idx+1,flag);\\r\\n\\r\\n        return memo[idx][flag]=Math.max(take,not_take);\\r\\n    }\\r\\n    public long maxAlternatingSum(int[] nums) {\\r\\n        int n=nums.length;\\r\\n        memo=new long [n][2];\\r\\n\\r\\n       return  check(nums,0,0);\\r\\n    }\\r\\n}\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072760,
                "title": "add-subtract-similar-to-buy-n-sell-stocks-with-no-constrain",
                "content": "**``` Idea : ```**      No matter what subset we select even index of subset will have + and odd indexes will have a - effect, means alternet + & -\\nSo we can keep a pointer which tells us what we did just previously  \\n```\\n0->means we did addition last time (sold the stock so this time we buy so subtract)\\n1-> we did subtraction last time (bought a stock and now we have to sell it so addition)\\n```\\n***Time : O(2n)*\\n*Space : O(2n)***\\n\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    long long dp[100002][3];\\n    vector<int>a;\\n    long long solve (int idx, int prev)\\n    {\\n        if(idx==n) return 0;\\n        if(dp[idx][prev]!=-1) return dp[idx][prev];\\n        long long ans=0;\\n        \\n        ans= solve(idx+1,prev);  // ignore current element\\n        \\n        if(prev==0)// prev pos then now negative\\n        {\\n            ans= max(ans, solve(idx+1,!prev)-a[idx]);\\n        }else if(prev==1)// prev neg then now positive \\n        {\\n            ans= max(ans,solve(idx+1,!prev)+a[idx]);\\\\\\n        }\\n        return dp[idx][prev]=ans;\\n    }\\n    long long maxAlternatingSum(vector<int>& nums) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        a=nums;\\n        n=a.size();\\n        return solve(0,1);\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "``` Idea : ```\n```\\n0->means we did addition last time (sold the stock so this time we buy so subtract)\\n1-> we did subtraction last time (bought a stock and now we have to sell it so addition)\\n```\n```\\nclass Solution {\\npublic:\\n    int n;\\n    long long dp[100002][3];\\n    vector<int>a;\\n    long long solve (int idx, int prev)\\n    {\\n        if(idx==n) return 0;\\n        if(dp[idx][prev]!=-1) return dp[idx][prev];\\n        long long ans=0;\\n        \\n        ans= solve(idx+1,prev);  // ignore current element\\n        \\n        if(prev==0)// prev pos then now negative\\n        {\\n            ans= max(ans, solve(idx+1,!prev)-a[idx]);\\n        }else if(prev==1)// prev neg then now positive \\n        {\\n            ans= max(ans,solve(idx+1,!prev)+a[idx]);\\\\\\n        }\\n        return dp[idx][prev]=ans;\\n    }\\n    long long maxAlternatingSum(vector<int>& nums) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        a=nums;\\n        n=a.size();\\n        return solve(0,1);\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070273,
                "title": "python-dp-decision-making-simple-o-n-o-1-space",
                "content": "```\\nclass Solution:\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\n        dp = nums[0]\\n        dp2 = 0\\n        res = max(dp,dp2)\\n        for i in range(1,len(nums)):\\n            ldp,ldp2 = dp,dp2\\n            dp = max(ldp,ldp2+nums[i])\\n            dp2 = max(ldp2,ldp-nums[i])\\n            res = max(res,dp,dp2)\\n        return res",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\n        dp = nums[0]\\n        dp2 = 0\\n        res = max(dp,dp2)\\n        for i in range(1,len(nums)):\\n            ldp,ldp2 = dp,dp2\\n            dp = max(ldp,ldp2+nums[i])\\n            dp2 = max(ldp2,ldp-nums[i])\\n            res = max(res,dp,dp2)\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 4067980,
                "title": "c-easy-fast-memo",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity: O(2*N)\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity: O(2*N)\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    long long solve(vector<int>& nums,int idx,bool even,vector<vector<long long>> &dp)\\r\\n    {\\r\\n        if(idx>=nums.size())\\r\\n        return 0;\\r\\n\\r\\n        if(dp[idx][even]!=-1)\\r\\n        return dp[idx][even];\\r\\n\\r\\n        if(even)\\r\\n        {\\r\\n            long long take=nums[idx]+solve(nums,idx+1,!even,dp);\\r\\n            long long nottake=solve(nums,idx+1,even,dp);\\r\\n\\r\\n            if(take>=nottake)\\r\\n            return dp[idx][even]=take;\\r\\n            else\\r\\n            return dp[idx][even]=nottake;\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            long long take=-nums[idx]+solve(nums,idx+1,!even,dp);\\r\\n            long long nottake=solve(nums,idx+1,even,dp);\\r\\n\\r\\n            if(take>=nottake)\\r\\n            return dp[idx][even]=take;\\r\\n            else\\r\\n            return dp[idx][even]=nottake;\\r\\n            \\r\\n        }\\r\\n    }\\r\\n    long long maxAlternatingSum(vector<int>& nums) {\\r\\n        \\r\\n        int n=nums.size();\\r\\n        vector<vector<long long>> dp(n+1,vector<long long>(3,-1));\\r\\n        return solve(nums,0,true,dp);\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    long long solve(vector<int>& nums,int idx,bool even,vector<vector<long long>> &dp)\\r\\n    {\\r\\n        if(idx>=nums.size())\\r\\n        return 0;\\r\\n\\r\\n        if(dp[idx][even]!=-1)\\r\\n        return dp[idx][even];\\r\\n\\r\\n        if(even)\\r\\n        {\\r\\n            long long take=nums[idx]+solve(nums,idx+1,!even,dp);\\r\\n            long long nottake=solve(nums,idx+1,even,dp);\\r\\n\\r\\n            if(take>=nottake)\\r\\n            return dp[idx][even]=take;\\r\\n            else\\r\\n            return dp[idx][even]=nottake;\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            long long take=-nums[idx]+solve(nums,idx+1,!even,dp);\\r\\n            long long nottake=solve(nums,idx+1,even,dp);\\r\\n\\r\\n            if(take>=nottake)\\r\\n            return dp[idx][even]=take;\\r\\n            else\\r\\n            return dp[idx][even]=nottake;\\r\\n            \\r\\n        }\\r\\n    }\\r\\n    long long maxAlternatingSum(vector<int>& nums) {\\r\\n        \\r\\n        int n=nums.size();\\r\\n        vector<vector<long long>> dp(n+1,vector<long long>(3,-1));\\r\\n        return solve(nums,0,true,dp);\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055685,
                "title": "java-recursion-memo",
                "content": "\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\n    long[][]dp ; \\r\\n    public long maxAlternatingSum(int[] nums) {\\r\\n        dp = new long[nums.length][2];\\r\\n        for( var el : dp) Arrays.fill(el , -1l);\\r\\n        return algo( nums , 0 , 1);\\r\\n\\r\\n    }\\r\\n    public long algo( int[] nums , int i, int iseven){\\r\\n        if( i ==  nums.length) return 0 ;\\r\\n\\r\\n        if( dp[i][iseven] > -1) return dp[i][iseven];\\r\\n        \\r\\n        long res=  0l ;\\r\\n        if( iseven == 1){\\r\\n            res = Math.max( nums[i] + algo( nums , i+1 , 0) , algo(nums , i+1 , 1));\\r\\n        }else{\\r\\n            res = Math.max( -nums[i] + algo( nums , i+1 , 1) , algo(nums , i+1 , 0));\\r\\n        }\\r\\n        dp[i][iseven] = res; \\r\\n        return res;\\r\\n\\r\\n    }\\r\\n}\\r\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\r\\nclass Solution {\\r\\n    long[][]dp ; \\r\\n    public long maxAlternatingSum(int[] nums) {\\r\\n        dp = new long[nums.length][2];\\r\\n        for( var el : dp) Arrays.fill(el , -1l);\\r\\n        return algo( nums , 0 , 1);\\r\\n\\r\\n    }\\r\\n    public long algo( int[] nums , int i, int iseven){\\r\\n        if( i ==  nums.length) return 0 ;\\r\\n\\r\\n        if( dp[i][iseven] > -1) return dp[i][iseven];\\r\\n        \\r\\n        long res=  0l ;\\r\\n        if( iseven == 1){\\r\\n            res = Math.max( nums[i] + algo( nums , i+1 , 0) , algo(nums , i+1 , 1));\\r\\n        }else{\\r\\n            res = Math.max( -nums[i] + algo( nums , i+1 , 1) , algo(nums , i+1 , 0));\\r\\n        }\\r\\n        dp[i][iseven] = res; \\r\\n        return res;\\r\\n\\r\\n    }\\r\\n}\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050573,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  long long maxAlternatingSum(vector<int>& nums) {\\n    long even = 0;  // Max alternating sum ending with a even index\\n    long odd = 0;   // Max alternating sum ending with a odd index\\n\\n    for (const int num : nums) {\\n      even = max(even, odd + num);\\n      odd = even - num;\\n    }\\n\\n    return even;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  long long maxAlternatingSum(vector<int>& nums) {\\n    long even = 0;  // Max alternating sum ending with a even index\\n    long odd = 0;   // Max alternating sum ending with a odd index\\n\\n    for (const int num : nums) {\\n      even = max(even, odd + num);\\n      odd = even - num;\\n    }\\n\\n    return even;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022872,
                "title": "python-3-javascript-using-kadane-s-algorithm-to-make-this-problem-easy-to-understand",
                "content": "# Python\\r\\n```\\r\\nclass Solution:\\r\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\r\\n        n = len(nums)\\r\\n        even_sum = nums[0]  # initialize even sum with the first element\\r\\n        odd_sum = 0  # initialize odd sum with 0\\r\\n\\r\\n        for i in range(1, n):\\r\\n            new_even_sum = max(even_sum, odd_sum + nums[i])\\r\\n            new_odd_sum = max(odd_sum, even_sum - nums[i])\\r\\n            even_sum, odd_sum = new_even_sum, new_odd_sum\\r\\n\\r\\n        return max(even_sum, odd_sum)\\r\\n```\\r\\n\\r\\n# JavaScript\\r\\n```\\r\\n/**\\r\\n * @param {number[]} nums\\r\\n * @return {number}\\r\\n */\\r\\nvar maxAlternatingSum = function(nums) {\\r\\n    const N = nums.length\\r\\n    let even_sum = nums[0]\\r\\n    let odd_sum = 0\\r\\n\\r\\n    for (let i = 1; i < N; i++) {\\r\\n        new_even_sum = Math.max(even_sum, odd_sum + nums[i])\\r\\n        new_odd_sum = Math.max(odd_sum, even_sum - nums[i])\\r\\n        even_sum = new_even_sum\\r\\n        odd_sum = new_odd_sum\\r\\n    }\\r\\n\\r\\n    return Math.max(even_sum, odd_sum)\\r\\n};\\r\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\r\\nclass Solution:\\r\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\r\\n        n = len(nums)\\r\\n        even_sum = nums[0]  # initialize even sum with the first element\\r\\n        odd_sum = 0  # initialize odd sum with 0\\r\\n\\r\\n        for i in range(1, n):\\r\\n            new_even_sum = max(even_sum, odd_sum + nums[i])\\r\\n            new_odd_sum = max(odd_sum, even_sum - nums[i])\\r\\n            even_sum, odd_sum = new_even_sum, new_odd_sum\\r\\n\\r\\n        return max(even_sum, odd_sum)\\r\\n```\n```\\r\\n/**\\r\\n * @param {number[]} nums\\r\\n * @return {number}\\r\\n */\\r\\nvar maxAlternatingSum = function(nums) {\\r\\n    const N = nums.length\\r\\n    let even_sum = nums[0]\\r\\n    let odd_sum = 0\\r\\n\\r\\n    for (let i = 1; i < N; i++) {\\r\\n        new_even_sum = Math.max(even_sum, odd_sum + nums[i])\\r\\n        new_odd_sum = Math.max(odd_sum, even_sum - nums[i])\\r\\n        even_sum = new_even_sum\\r\\n        odd_sum = new_odd_sum\\r\\n    }\\r\\n\\r\\n    return Math.max(even_sum, odd_sum)\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997499,
                "title": "123ms-beats-96-55-of-users-with-c-91-17mb-beats-82-12-of-users-with-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        long long sumEven=0,sumOdd=0,tmpEven=0, tmpOdd=0;\\n        for(int i=nums.size()-1 ; i >=0 ;i--){\\n            tmpEven=max(sumOdd+nums[i],sumEven);\\n            tmpOdd=max(sumEven-nums[i],sumOdd);\\n            sumEven=tmpEven;\\n            sumOdd=tmpOdd;\\n        }\\n    return sumEven;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        long long sumEven=0,sumOdd=0,tmpEven=0, tmpOdd=0;\\n        for(int i=nums.size()-1 ; i >=0 ;i--){\\n            tmpEven=max(sumOdd+nums[i],sumEven);\\n            tmpOdd=max(sumEven-nums[i],sumOdd);\\n            sumEven=tmpEven;\\n            sumOdd=tmpOdd;\\n        }\\n    return sumEven;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982563,
                "title": "recursive-memoization-true-dp",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\nSo how do we know it\\'s DP (dynamic programming)? Well first, we are asked to find a **maximum** which hints that dp may be a valid approach. Second, we are given some constraints: of the numbers in our subarray, the even indices must be added to the sum while the odd indices subtracted. From there we model our decision tree and attempt to develop a recursive solution. Recursive solutions often benefit from memoization/caching, so we can add that to our solution as well. Finally, you may notice that the current max subsequence sum only depends on the previous two sums and thus we can use temporary varaibles and iteration to achieve a true DP solution.\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\nOur recursive solution can be developed by simply walking through our choices. At this given index, I can either add it or skip it. If I use it our new problem becomes: ok +/- this number, now next time im doing the opposite. If I skip it, it becomes ok I don\\'t use this number and now next time i\\'m still doing the same operation. That is compeltely it for the logic of each function call.\\r\\n\\r\\nOnce we develop and understand our recursive solution we see that each new sum only depends on their sign +/- and whether our choice is to use it or skip it. From this we can extract our recursive calls and use a reverse for loop to enumerate our logic.\\r\\n\\r\\n\\r\\n# Recursive Bottom Up\\r\\n```\\r\\nclass Solution:\\r\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\r\\n        dp = {}\\r\\n        #Define dp dict: maps each index and boolean to a sum\\r\\n        #i = index, even = true/false\\r\\n        def dfs(i, even):\\r\\n            #Base case\\r\\n            if i == len(nums):\\r\\n                return 0\\r\\n            #If already calculated\\r\\n            if (i,even) in dp:\\r\\n                return dp[(i,even)]\\r\\n            #Add or subtract number based on function call params\\r\\n            total = nums[i] if even else (-1 * nums[i])\\r\\n            #Update our dict, make recursive calls for both options (adding in which case we invert even or skipping in which case even stays the same)\\r\\n            dp[(i,even)] = max(total + dfs(i+1, not even), dfs(i+1, even))\\r\\n            #return the calculated maximum since we\\'re using our return values\\r\\n            return dp[(i,even)]\\r\\n        #Call our function at the start, and it should recurse through the entire array in O(n) returning the correct sum\\r\\n        return dfs(0, True)\\r\\n```\\r\\n\\r\\n\\r\\n# True DP\\r\\n```\\r\\nclass Solution:\\r\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\r\\n        #initialize sums to 0\\r\\n        sumEven, sumOdd = 0,0\\r\\n        #Top down \\r\\n        for i in range(len(nums) -1, -1, -1):\\r\\n            #max between using it or not using it\\r\\n            tmpEven = max(sumOdd + nums[i], sumEven)\\r\\n            #same thing, notice since we\\'re odd we subtract from even, or we keep sumOdd\\r\\n            tmpOdd = max(sumEven - nums[i], sumOdd)\\r\\n        #update our values\\r\\n            sumEven, sumOdd = tmpEven, tmpOdd\\r\\n        #at the end, sumEven should hold our maxmimum, this is guranteed, im still not sure why tho lol\\r\\n        return sumEven\\r\\n```\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\nO(n) recursive\\r\\nO(n) iterative\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\nO(n) recursive + memo\\r\\nO(1) two vars\\r\\n\\r\\n# Aside\\r\\nIf you\\'re not yet familiar with many dynamic programming problems, this problem can seem impossible and overwhelming. However, do not let that get you down. Learning something new and totally unfamiliar than anything you\\'ve done before is an uncomfortable and challenging process that even the greatest programmers have had to nartually go through. Just keep on going, embrace the learning process and eventually it will click. - OKCDuGod",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\r\\nclass Solution:\\r\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\r\\n        dp = {}\\r\\n        #Define dp dict: maps each index and boolean to a sum\\r\\n        #i = index, even = true/false\\r\\n        def dfs(i, even):\\r\\n            #Base case\\r\\n            if i == len(nums):\\r\\n                return 0\\r\\n            #If already calculated\\r\\n            if (i,even) in dp:\\r\\n                return dp[(i,even)]\\r\\n            #Add or subtract number based on function call params\\r\\n            total = nums[i] if even else (-1 * nums[i])\\r\\n            #Update our dict, make recursive calls for both options (adding in which case we invert even or skipping in which case even stays the same)\\r\\n            dp[(i,even)] = max(total + dfs(i+1, not even), dfs(i+1, even))\\r\\n            #return the calculated maximum since we\\'re using our return values\\r\\n            return dp[(i,even)]\\r\\n        #Call our function at the start, and it should recurse through the entire array in O(n) returning the correct sum\\r\\n        return dfs(0, True)\\r\\n```\n```\\r\\nclass Solution:\\r\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\r\\n        #initialize sums to 0\\r\\n        sumEven, sumOdd = 0,0\\r\\n        #Top down \\r\\n        for i in range(len(nums) -1, -1, -1):\\r\\n            #max between using it or not using it\\r\\n            tmpEven = max(sumOdd + nums[i], sumEven)\\r\\n            #same thing, notice since we\\'re odd we subtract from even, or we keep sumOdd\\r\\n            tmpOdd = max(sumEven - nums[i], sumOdd)\\r\\n        #update our values\\r\\n            sumEven, sumOdd = tmpEven, tmpOdd\\r\\n        #at the end, sumEven should hold our maxmimum, this is guranteed, im still not sure why tho lol\\r\\n        return sumEven\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967774,
                "title": "java-o-n-t-c-o-1-s-c-very-easy",
                "content": "```\\nclass Solution {\\n    public long maxAlternatingSum(int[] nums) {\\n        long[] prev = new long[2];\\n        long[] curr = new long[2];\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            curr[1] = Math.max(-nums[i] + prev[0], prev[1]);\\n            curr[0] = Math.max(nums[i] + prev[1], prev[0]);\\n            prev = curr;\\n        }\\n        return prev[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public long maxAlternatingSum(int[] nums) {\\n        long[] prev = new long[2];\\n        long[] curr = new long[2];\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            curr[1] = Math.max(-nums[i] + prev[0], prev[1]);\\n            curr[0] = Math.max(nums[i] + prev[1], prev[0]);\\n            prev = curr;\\n        }\\n        return prev[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960406,
                "title": "c-greedy-monotonicity-99-o-n-o-1",
                "content": "# Intuition\\r\\nLooks for peak & trough in nums[]\\r\\n\\r\\n# Complexity\\r\\nTime: O(n)\\r\\nSpace: O(1)\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    long long maxAlternatingSum(vector<int>& nums) {\\r\\n        if(nums.size() == 1) return nums[0];\\r\\n        bool needEven = true;\\r\\n        long long ans = 0;\\r\\n\\r\\n        for(int i = 0; i < nums.size() - 1; i++){\\r\\n            if(nums[i] >= nums[i+1] && needEven == true){\\r\\n                ans += nums[i];\\r\\n                needEven = !needEven;\\r\\n            }\\r\\n            if(nums[i] <= nums[i+1] && needEven == false){\\r\\n                ans -= nums[i];\\r\\n                needEven = !needEven;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if(nums[nums.size() - 1] >= nums[nums.size() - 2] && needEven){\\r\\n            ans += nums[nums.size() - 1];\\r\\n        }\\r\\n\\r\\n        // corner case: do NOT append a odd at the end\\r\\n        return ans;\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    long long maxAlternatingSum(vector<int>& nums) {\\r\\n        if(nums.size() == 1) return nums[0];\\r\\n        bool needEven = true;\\r\\n        long long ans = 0;\\r\\n\\r\\n        for(int i = 0; i < nums.size() - 1; i++){\\r\\n            if(nums[i] >= nums[i+1] && needEven == true){\\r\\n                ans += nums[i];\\r\\n                needEven = !needEven;\\r\\n            }\\r\\n            if(nums[i] <= nums[i+1] && needEven == false){\\r\\n                ans -= nums[i];\\r\\n                needEven = !needEven;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if(nums[nums.size() - 1] >= nums[nums.size() - 2] && needEven){\\r\\n            ans += nums[nums.size() - 1];\\r\\n        }\\r\\n\\r\\n        // corner case: do NOT append a odd at the end\\r\\n        return ans;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954479,
                "title": "python-top-down-dp-bottom-up-dp-space-optimized-bottom-up-dp",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution:\\r\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\r\\n        # Top-down\\r\\n        memo = {}\\r\\n        def dfs(i, is_even):\\r\\n            if i == len(nums):\\r\\n                return 0\\r\\n            if (i, is_even) not in memo:\\r\\n                memo[(i, is_even)] = dfs(i + 1, is_even) # Don\\'t use current in subseq\\r\\n                if is_even:\\r\\n                    memo[(i, is_even)] = max(memo[(i, is_even)], dfs(i + 1, not is_even) + nums[i])\\r\\n                else:\\r\\n                    memo[(i, is_even)] = max(memo[(i, is_even)], dfs(i + 1, not is_even) - nums[i])\\r\\n            return memo[(i, is_even)]\\r\\n        return dfs(0, True)\\r\\n        \\r\\n        # Bottom-up\\r\\n        N = len(nums)\\r\\n        dp = [[0, 0] for _ in range(N+1)]\\r\\n        for i in range(N-1, -1, -1):\\r\\n            dp[i][0] = max(dp[i+1][0], dp[i+1][1] + nums[i])\\r\\n            dp[i][1] = max(dp[i+1][1], dp[i+1][0] - nums[i])\\r\\n        return max(dp[0])\\r\\n\\r\\n        # Constant space bottom-up\\r\\n        choose_odd, choose_even = 0, 0\\r\\n        for num in nums:\\r\\n            choose_even = max(choose_even, choose_odd + num)\\r\\n            choose_odd = max(choose_odd, choose_even - num)\\r\\n        return max(choose_odd, choose_even)\\r\\n\\r\\n\\r\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\r\\nclass Solution:\\r\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\r\\n        # Top-down\\r\\n        memo = {}\\r\\n        def dfs(i, is_even):\\r\\n            if i == len(nums):\\r\\n                return 0\\r\\n            if (i, is_even) not in memo:\\r\\n                memo[(i, is_even)] = dfs(i + 1, is_even) # Don\\'t use current in subseq\\r\\n                if is_even:\\r\\n                    memo[(i, is_even)] = max(memo[(i, is_even)], dfs(i + 1, not is_even) + nums[i])\\r\\n                else:\\r\\n                    memo[(i, is_even)] = max(memo[(i, is_even)], dfs(i + 1, not is_even) - nums[i])\\r\\n            return memo[(i, is_even)]\\r\\n        return dfs(0, True)\\r\\n        \\r\\n        # Bottom-up\\r\\n        N = len(nums)\\r\\n        dp = [[0, 0] for _ in range(N+1)]\\r\\n        for i in range(N-1, -1, -1):\\r\\n            dp[i][0] = max(dp[i+1][0], dp[i+1][1] + nums[i])\\r\\n            dp[i][1] = max(dp[i+1][1], dp[i+1][0] - nums[i])\\r\\n        return max(dp[0])\\r\\n\\r\\n        # Constant space bottom-up\\r\\n        choose_odd, choose_even = 0, 0\\r\\n        for num in nums:\\r\\n            choose_even = max(choose_even, choose_odd + num)\\r\\n            choose_odd = max(choose_odd, choose_even - num)\\r\\n        return max(choose_odd, choose_even)\\r\\n\\r\\n\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952267,
                "title": "python-memoization",
                "content": "\\n```\\nclass Solution:\\n    def maxAlternatingSum(self, A: List[int]) -> int:\\n        N = len(A)\\n        dp = {}\\n        def dfs(i, isEven):\\n            if i==N:\\n                return 0\\n            if (i, isEven) in dp:\\n                return dp[(i, isEven)]\\n            if isEven:\\n                dp[(i, isEven)] = max(A[i] + dfs(i+1, False), dfs(i+1, True))\\n            else:\\n                dp[(i, isEven)] = max(-A[i] + dfs(i+1, True), dfs(i+1, False))\\n            return dp[(i, isEven)]\\n        return dfs(0, True)\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxAlternatingSum(self, A: List[int]) -> int:\\n        N = len(A)\\n        dp = {}\\n        def dfs(i, isEven):\\n            if i==N:\\n                return 0\\n            if (i, isEven) in dp:\\n                return dp[(i, isEven)]\\n            if isEven:\\n                dp[(i, isEven)] = max(A[i] + dfs(i+1, False), dfs(i+1, True))\\n            else:\\n                dp[(i, isEven)] = max(-A[i] + dfs(i+1, True), dfs(i+1, False))\\n            return dp[(i, isEven)]\\n        return dfs(0, True)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948775,
                "title": "easy-o-n-solution",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    long long maxAlternatingSum(vector<int>& nums) {\\r\\n        int n = nums.size();\\r\\n        vector<vector<long long>> dp(n, vector<long long>(2, 0));\\r\\n        dp[0][0] = 0;\\r\\n        dp[0][1] = nums[0];\\r\\n        for (int i = 1; i < n; i++) {\\r\\n            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - nums[i]);\\r\\n            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + nums[i]);\\r\\n        }\\r\\n        return max(dp[n - 1][0], dp[n - 1][1]);\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    long long maxAlternatingSum(vector<int>& nums) {\\r\\n        int n = nums.size();\\r\\n        vector<vector<long long>> dp(n, vector<long long>(2, 0));\\r\\n        dp[0][0] = 0;\\r\\n        dp[0][1] = nums[0];\\r\\n        for (int i = 1; i < n; i++) {\\r\\n            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - nums[i]);\\r\\n            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + nums[i]);\\r\\n        }\\r\\n        return max(dp[n - 1][0], dp[n - 1][1]);\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928248,
                "title": "memoization",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    long long dp[100005][2];\\r\\n    long long dfs(vector<int>&nums, int idx,int reidx){\\r\\n        if(idx==nums.size()){\\r\\n            return 0;\\r\\n        }\\r\\n        if(dp[idx][reidx%2]!=-1) return dp[idx][reidx%2];\\r\\n        long long take =0;\\r\\n        long long skip=0;\\r\\n        if(reidx%2==0)\\r\\n        take = nums[idx]+dfs(nums,idx+1,reidx+1);\\r\\n        else\\r\\n        take = dfs(nums,idx+1,reidx+1)-nums[idx];\\r\\n        skip = dfs(nums,idx+1,reidx);\\r\\n        return dp[idx][reidx%2] = max(take,skip);\\r\\n\\r\\n\\r\\n    }\\r\\n    long long maxAlternatingSum(vector<int>& nums) {\\r\\n        for(int i=0; i<100005; i++)\\r\\n        for(int j=0; j<2; j++)\\r\\n        dp[i][j] = -1;\\r\\n        return dfs(nums,0,0);\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    long long dp[100005][2];\\r\\n    long long dfs(vector<int>&nums, int idx,int reidx){\\r\\n        if(idx==nums.size()){\\r\\n            return 0;\\r\\n        }\\r\\n        if(dp[idx][reidx%2]!=-1) return dp[idx][reidx%2];\\r\\n        long long take =0;\\r\\n        long long skip=0;\\r\\n        if(reidx%2==0)\\r\\n        take = nums[idx]+dfs(nums,idx+1,reidx+1);\\r\\n        else\\r\\n        take = dfs(nums,idx+1,reidx+1)-nums[idx];\\r\\n        skip = dfs(nums,idx+1,reidx);\\r\\n        return dp[idx][reidx%2] = max(take,skip);\\r\\n\\r\\n\\r\\n    }\\r\\n    long long maxAlternatingSum(vector<int>& nums) {\\r\\n        for(int i=0; i<100005; i++)\\r\\n        for(int j=0; j<2; j++)\\r\\n        dp[i][j] = -1;\\r\\n        return dfs(nums,0,0);\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928247,
                "title": "memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\r\\npublic:\\r\\n    long long dp[100005][2];\\r\\n    long long dfs(vector<int>&nums, int idx,int reidx){\\r\\n        if(idx==nums.size()){\\r\\n            return 0;\\r\\n        }\\r\\n        if(dp[idx][reidx%2]!=-1) return dp[idx][reidx%2];\\r\\n        long long take =0;\\r\\n        long long skip=0;\\r\\n        if(reidx%2==0)\\r\\n        take = nums[idx]+dfs(nums,idx+1,reidx+1);\\r\\n        else\\r\\n        take = dfs(nums,idx+1,reidx+1)-nums[idx];\\r\\n        skip = dfs(nums,idx+1,reidx);\\r\\n        return dp[idx][reidx%2] = max(take,skip);\\r\\n\\r\\n\\r\\n    }\\r\\n    long long maxAlternatingSum(vector<int>& nums) {\\r\\n        for(int i=0; i<100005; i++)\\r\\n        for(int j=0; j<2; j++)\\r\\n        dp[i][j] = -1;\\r\\n        return dfs(nums,0,0);\\r\\n    }\\r\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\r\\npublic:\\r\\n    long long dp[100005][2];\\r\\n    long long dfs(vector<int>&nums, int idx,int reidx){\\r\\n        if(idx==nums.size()){\\r\\n            return 0;\\r\\n        }\\r\\n        if(dp[idx][reidx%2]!=-1) return dp[idx][reidx%2];\\r\\n        long long take =0;\\r\\n        long long skip=0;\\r\\n        if(reidx%2==0)\\r\\n        take = nums[idx]+dfs(nums,idx+1,reidx+1);\\r\\n        else\\r\\n        take = dfs(nums,idx+1,reidx+1)-nums[idx];\\r\\n        skip = dfs(nums,idx+1,reidx);\\r\\n        return dp[idx][reidx%2] = max(take,skip);\\r\\n\\r\\n\\r\\n    }\\r\\n    long long maxAlternatingSum(vector<int>& nums) {\\r\\n        for(int i=0; i<100005; i++)\\r\\n        for(int j=0; j<2; j++)\\r\\n        dp[i][j] = -1;\\r\\n        return dfs(nums,0,0);\\r\\n    }\\r\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3882902,
                "title": "c-dp-memoization-solution",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    long long f(int ind,bool sign,vector<int>&nums,vector<vector<long long>> &dp){\\r\\n        if(ind>=nums.size()){\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        if(dp[ind][sign]!=-1){\\r\\n            return dp[ind][sign];\\r\\n        }\\r\\n\\r\\n        long long exclude = f(ind+1,sign,nums,dp);\\r\\n        long long include = 0;\\r\\n        if(sign==true){\\r\\n            include = nums[ind]+ f(ind+1,!sign,nums,dp);\\r\\n        }else{\\r\\n            include = -nums[ind] + f(ind+1,!sign,nums,dp);\\r\\n        }\\r\\n\\r\\n        return dp[ind][sign] = max(include,exclude);\\r\\n    }\\r\\n\\r\\n    long long maxAlternatingSum(vector<int>& nums) {\\r\\n        int n = nums.size();\\r\\n        vector<vector<long long>> dp(n,vector<long long>(2,-1));\\r\\n        return f(0,true,nums,dp);\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    long long f(int ind,bool sign,vector<int>&nums,vector<vector<long long>> &dp){\\r\\n        if(ind>=nums.size()){\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        if(dp[ind][sign]!=-1){\\r\\n            return dp[ind][sign];\\r\\n        }\\r\\n\\r\\n        long long exclude = f(ind+1,sign,nums,dp);\\r\\n        long long include = 0;\\r\\n        if(sign==true){\\r\\n            include = nums[ind]+ f(ind+1,!sign,nums,dp);\\r\\n        }else{\\r\\n            include = -nums[ind] + f(ind+1,!sign,nums,dp);\\r\\n        }\\r\\n\\r\\n        return dp[ind][sign] = max(include,exclude);\\r\\n    }\\r\\n\\r\\n    long long maxAlternatingSum(vector<int>& nums) {\\r\\n        int n = nums.size();\\r\\n        vector<vector<long long>> dp(n,vector<long long>(2,-1));\\r\\n        return f(0,true,nums,dp);\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869757,
                "title": "from-traditional-memorization-to-best-time-to-buy-sell-stocks-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nTraditional Memorization:\\n```\\nclass Solution {\\n    HashMap<String, Long> map=new HashMap<>();\\n    public long maxAlternatingSum(int[] nums) {\\n        return populate(nums, 0, true);\\n    }\\n    public long populate(int[] nums, int ptr, boolean isEven){\\n        if(ptr==nums.length)return 0;\\n        StringBuilder sb=new StringBuilder();\\n        sb.append(ptr);\\n        sb.append(\",\");\\n        sb.append(isEven);\\n        if(map.containsKey(sb.toString()))return map.get(sb.toString());\\n        map.put(sb.toString(), Math.max(isEven?populate(nums, ptr+1, !isEven)+nums[ptr]\\n        :populate(nums, ptr+1, !isEven)-nums[ptr], populate(nums, ptr+1, isEven)));\\n        return map.get(sb.toString ());\\n    }\\n}\\n```\\nBest time 2 buy or sell stocks 2:\\n```\\nclass Solution {\\n    public long maxAlternatingSum(int[] nums) {\\n        long sum=nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            if(nums[i]>nums[i-1])sum+=(nums[i]-nums[i-1]);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<String, Long> map=new HashMap<>();\\n    public long maxAlternatingSum(int[] nums) {\\n        return populate(nums, 0, true);\\n    }\\n    public long populate(int[] nums, int ptr, boolean isEven){\\n        if(ptr==nums.length)return 0;\\n        StringBuilder sb=new StringBuilder();\\n        sb.append(ptr);\\n        sb.append(\",\");\\n        sb.append(isEven);\\n        if(map.containsKey(sb.toString()))return map.get(sb.toString());\\n        map.put(sb.toString(), Math.max(isEven?populate(nums, ptr+1, !isEven)+nums[ptr]\\n        :populate(nums, ptr+1, !isEven)-nums[ptr], populate(nums, ptr+1, isEven)));\\n        return map.get(sb.toString ());\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public long maxAlternatingSum(int[] nums) {\\n        long sum=nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            if(nums[i]>nums[i-1])sum+=(nums[i]-nums[i-1]);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864669,
                "title": "dp-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long solve(int i,vector<int>&v,vector<vector<long long>>&dp,int l){\\n        if(i>=v.size()) return 0;\\n        if(dp[i][l%2]!=-1) return dp[i][l%2];\\n        long long a1=solve(i+1,v,dp,l);\\n        long long a2;\\n        if(l%2==0) a2=v[i]+solve(i+1,v,dp,l+1);\\n        else a2=-v[i]+solve(i+1,v,dp,l+1);\\n        return dp[i][l%2]=max(a1,a2); \\n    }\\n    long long maxAlternatingSum(vector<int>& v) {\\n        int n=v.size();\\n        vector<vector<long long>>dp(n,vector<long long>(2,-1));\\n        return solve(0,v,dp,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solve(int i,vector<int>&v,vector<vector<long long>>&dp,int l){\\n        if(i>=v.size()) return 0;\\n        if(dp[i][l%2]!=-1) return dp[i][l%2];\\n        long long a1=solve(i+1,v,dp,l);\\n        long long a2;\\n        if(l%2==0) a2=v[i]+solve(i+1,v,dp,l+1);\\n        else a2=-v[i]+solve(i+1,v,dp,l+1);\\n        return dp[i][l%2]=max(a1,a2); \\n    }\\n    long long maxAlternatingSum(vector<int>& v) {\\n        int n=v.size();\\n        vector<vector<long long>>dp(n,vector<long long>(2,-1));\\n        return solve(0,v,dp,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833280,
                "title": "dp-without-memory-beats-99-iterative",
                "content": "# Intuition\\nThe code efficiently calculates the maximum alternating sum by using two variables sumEven and sumOdd to keep track of the best sums considering different combinations of included and excluded elements. The loop iterates through the list in reverse order to ensure that it considers all possible combinations of elements. The final result is the maximum alternating sum, which is returned by the function.\\n* sumEven: First value in the subsequence was added\\n* sumOdd: First value in the subsequence was subtracted\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\n\\n        sumEven, sumOdd = 0, 0\\n        for i in range(len(nums)-1, -1, -1):\\n            sumEven, sumOdd = max(sumEven, sumOdd + nums[i]), max(sumOdd, sumEven - nums[i])\\n        return sumEven\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\n\\n        sumEven, sumOdd = 0, 0\\n        for i in range(len(nums)-1, -1, -1):\\n            sumEven, sumOdd = max(sumEven, sumOdd + nums[i]), max(sumOdd, sumEven - nums[i])\\n        return sumEven\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832400,
                "title": "c-recursion-dp",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:O(N)\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:O(N)\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    typedef long long ll;\\r\\n    ll dp[100001][2];\\r\\n\\r\\n    ll solve (int i,vector<int>&nums,int n,bool flag){\\r\\n        if(i>=n)return 0;\\r\\n        if(dp[i][flag]!=-1)return dp[i][flag];\\r\\n        ll skip=solve(i+1,nums,n,flag);\\r\\n        ll val=nums[i];\\r\\n        if(flag==false){val=-val;}\\r\\n        ll take=val+solve(i+1,nums,n,!flag);\\r\\n        return dp[i][flag]= max(skip,take);\\r\\n    }\\r\\n\\r\\n    long long maxAlternatingSum(vector<int>& nums) {\\r\\n        int n=nums.size();\\r\\n        memset(dp,-1,sizeof(dp));\\r\\n        return solve(0,nums,n,true);\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    typedef long long ll;\\r\\n    ll dp[100001][2];\\r\\n\\r\\n    ll solve (int i,vector<int>&nums,int n,bool flag){\\r\\n        if(i>=n)return 0;\\r\\n        if(dp[i][flag]!=-1)return dp[i][flag];\\r\\n        ll skip=solve(i+1,nums,n,flag);\\r\\n        ll val=nums[i];\\r\\n        if(flag==false){val=-val;}\\r\\n        ll take=val+solve(i+1,nums,n,!flag);\\r\\n        return dp[i][flag]= max(skip,take);\\r\\n    }\\r\\n\\r\\n    long long maxAlternatingSum(vector<int>& nums) {\\r\\n        int n=nums.size();\\r\\n        memset(dp,-1,sizeof(dp));\\r\\n        return solve(0,nums,n,true);\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829516,
                "title": "dp-recursive-memory-python",
                "content": "# Intuition\\r\\nThe code uses a recursive approach with memoization to find the maximum alternating sum of elements from a list. It defines a function dfs that explores two options at each index: include the current element with the opposite parity (even/odd) and skip the current element. The memory dictionary stores computed results to avoid redundant calculations. Starting from the first element, the function calculates the maximum alternating sum by considering both even and odd indices. The final result returned is the maximum alternating sum obtained. This approach efficiently solves the problem by avoiding unnecessary computations, improving performance.\\r\\n# Complexity\\r\\n- Time complexity: O(n)\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:O(n)\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution:\\r\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\r\\n\\r\\n        memory = dict()\\r\\n        def dfs(i, even):\\r\\n\\r\\n            if i == len(nums):\\r\\n                return 0\\r\\n            \\r\\n            if (i,even) in memory:\\r\\n                return memory[(i,even)]\\r\\n\\r\\n            total = nums[i] if even else -1*nums[i]\\r\\n            memory[(i,even)] = max(total + dfs(i+1, not even), dfs(i+1, even))\\r\\n\\r\\n            return memory[(i,even)]\\r\\n\\r\\n        return dfs(0, True)\\r\\n\\r\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\r\\nclass Solution:\\r\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\r\\n\\r\\n        memory = dict()\\r\\n        def dfs(i, even):\\r\\n\\r\\n            if i == len(nums):\\r\\n                return 0\\r\\n            \\r\\n            if (i,even) in memory:\\r\\n                return memory[(i,even)]\\r\\n\\r\\n            total = nums[i] if even else -1*nums[i]\\r\\n            memory[(i,even)] = max(total + dfs(i+1, not even), dfs(i+1, even))\\r\\n\\r\\n            return memory[(i,even)]\\r\\n\\r\\n        return dfs(0, True)\\r\\n\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823548,
                "title": "beats-100-memorization-recursion",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    long long dp[100006][2];\\r\\n    long long solve(int ind, int flag, vector<int>& nums)\\r\\n    {\\r\\n        if(ind>= nums.size())\\r\\n            return 0;\\r\\n        if(dp[ind][flag] != -1)\\r\\n            return dp[ind][flag];\\r\\n        long long  notTake = 0+solve(ind+1, flag, nums);\\r\\n        long long  take=0;\\r\\n        if(flag==0)\\r\\n        {\\r\\n            take = nums[ind]+solve(ind+1, 1, nums);\\r\\n        }\\r\\n        else\\r\\n            take = -1*nums[ind]+solve(ind+1, 0, nums);\\r\\n        return dp[ind][flag] = max(take, notTake);\\r\\n    }\\r\\n    long long maxAlternatingSum(vector<int>& nums) {\\r\\n        int n = nums.size();\\r\\n        memset(dp,-1,sizeof(dp));\\r\\n        return solve(0, 0, nums);\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    long long dp[100006][2];\\r\\n    long long solve(int ind, int flag, vector<int>& nums)\\r\\n    {\\r\\n        if(ind>= nums.size())\\r\\n            return 0;\\r\\n        if(dp[ind][flag] != -1)\\r\\n            return dp[ind][flag];\\r\\n        long long  notTake = 0+solve(ind+1, flag, nums);\\r\\n        long long  take=0;\\r\\n        if(flag==0)\\r\\n        {\\r\\n            take = nums[ind]+solve(ind+1, 1, nums);\\r\\n        }\\r\\n        else\\r\\n            take = -1*nums[ind]+solve(ind+1, 0, nums);\\r\\n        return dp[ind][flag] = max(take, notTake);\\r\\n    }\\r\\n    long long maxAlternatingSum(vector<int>& nums) {\\r\\n        int n = nums.size();\\r\\n        memset(dp,-1,sizeof(dp));\\r\\n        return solve(0, 0, nums);\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822074,
                "title": "simple-beginner-level-c-solution-dp-method-beats-100-in-memory",
                "content": "\\r\\n# Complexity\\r\\n- Time complexity: ```O(n)```\\r\\n- Space complexity: ```O(1)```\\r\\n\\r\\n# Code\\r\\n```cpp\\r\\n// Runtime 202 ms Beats 50% Memory 13.7 MB Beats 100%\\r\\ninline long max(long a, long b) {\\r\\n    return (a > b) ? a : b;\\r\\n}\\r\\nlong long maxAlternatingSum(int* nums, int numsSize) {\\r\\n    // DP method\\r\\n\\r\\n    // Time complexity: O(n)\\r\\n    // Space complexity: O(1)\\r\\n\\r\\n    long even = 0L;  // max alternating sum ending with a \\'even\\' index\\r\\n    long odd  = 0L;  // max alternating sum ending with a \\'odd\\' index\\r\\n\\r\\n    for (int i = 0; i < numsSize; i++) {\\r\\n        even = max(even, odd + nums[i]);\\r\\n        odd = even - nums[i];\\r\\n    }\\r\\n    return even;\\r\\n}\\r\\n```\\r\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```O(n)```\n```O(1)```\n```cpp\\r\\n// Runtime 202 ms Beats 50% Memory 13.7 MB Beats 100%\\r\\ninline long max(long a, long b) {\\r\\n    return (a > b) ? a : b;\\r\\n}\\r\\nlong long maxAlternatingSum(int* nums, int numsSize) {\\r\\n    // DP method\\r\\n\\r\\n    // Time complexity: O(n)\\r\\n    // Space complexity: O(1)\\r\\n\\r\\n    long even = 0L;  // max alternating sum ending with a \\'even\\' index\\r\\n    long odd  = 0L;  // max alternating sum ending with a \\'odd\\' index\\r\\n\\r\\n    for (int i = 0; i < numsSize; i++) {\\r\\n        even = max(even, odd + nums[i]);\\r\\n        odd = even - nums[i];\\r\\n    }\\r\\n    return even;\\r\\n}\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3818579,
                "title": "c-easy-solution-memoization",
                "content": "# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\ntypedef long long ll;\\r\\n    ll helper(int pos, int prev, vector<int>& nums, vector<vector<ll>>& dp)\\r\\n    {\\r\\n        int n=nums.size();\\r\\n        if(pos==n) return 0;\\r\\n        if(dp[pos][prev]!=-1) return dp[pos][prev]; \\r\\n        ll not_pick = helper(pos+1,prev,nums,dp);\\r\\n        ll pick=0;\\r\\n        if(prev==0) pick = nums[pos] + helper(pos+1,1,nums,dp);\\r\\n        else pick = helper(pos+1,0,nums,dp) - nums[pos];\\r\\n        return dp[pos][prev] = max(pick,not_pick);\\r\\n    }\\r\\n    long long maxAlternatingSum(vector<int>& nums) {\\r\\n        int n=nums.size();\\r\\n        vector<vector<ll>> dp(n,vector<ll>(2,-1));\\r\\n        return helper(0,0,nums,dp);\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\ntypedef long long ll;\\r\\n    ll helper(int pos, int prev, vector<int>& nums, vector<vector<ll>>& dp)\\r\\n    {\\r\\n        int n=nums.size();\\r\\n        if(pos==n) return 0;\\r\\n        if(dp[pos][prev]!=-1) return dp[pos][prev]; \\r\\n        ll not_pick = helper(pos+1,prev,nums,dp);\\r\\n        ll pick=0;\\r\\n        if(prev==0) pick = nums[pos] + helper(pos+1,1,nums,dp);\\r\\n        else pick = helper(pos+1,0,nums,dp) - nums[pos];\\r\\n        return dp[pos][prev] = max(pick,not_pick);\\r\\n    }\\r\\n    long long maxAlternatingSum(vector<int>& nums) {\\r\\n        int n=nums.size();\\r\\n        vector<vector<ll>> dp(n,vector<ll>(2,-1));\\r\\n        return helper(0,0,nums,dp);\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789385,
                "title": "easy-approach-c-tc-o-n-sc-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n     long long int sum = 0 ;\\n        int flag = 0;  // for \"+\" or \"-\"\\n        long long int ans =0 ;\\n        for(int i = 0; i < nums.size(); i++){\\n            \\n            if(flag == 0){\\n                while(i+1<nums.size() && nums[i] <= nums[i+1]){   // to add next maximum number\\n                    i++;\\n                }\\n                sum+=nums[i];\\n                ans = max(ans,sum);\\n                flag=1;\\n            }\\n            else{\\n                while(i+1<nums.size() && nums[i] >= nums[i+1]){ // to subtract least number\\n                    i++;\\n                }\\n                sum-=nums[i];\\n                if(sum < 0){\\n                    sum = 0; \\n                    i--;\\n                } \\n                flag=0;\\n            }   \\n        }  \\n        \\n      return ans;  \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n     long long int sum = 0 ;\\n        int flag = 0;  // for \"+\" or \"-\"\\n        long long int ans =0 ;\\n        for(int i = 0; i < nums.size(); i++){\\n            \\n            if(flag == 0){\\n                while(i+1<nums.size() && nums[i] <= nums[i+1]){   // to add next maximum number\\n                    i++;\\n                }\\n                sum+=nums[i];\\n                ans = max(ans,sum);\\n                flag=1;\\n            }\\n            else{\\n                while(i+1<nums.size() && nums[i] >= nums[i+1]){ // to subtract least number\\n                    i++;\\n                }\\n                sum-=nums[i];\\n                if(sum < 0){\\n                    sum = 0; \\n                    i--;\\n                } \\n                flag=0;\\n            }   \\n        }  \\n        \\n      return ans;  \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774734,
                "title": "c-easy-solution-using-dp",
                "content": "```\\npublic class Solution {\\n    public long MaxAlternatingSum(int[] nums) {\\n        int n = nums.Length;\\n        long[][] dp = new long[n][];\\n        for(int i = 0; i < n;i++) dp[i] = new long[] {-1,-1};\\n        long solve(int idx,int op){\\n            if(idx >= n) return 0;\\n            int i = (op > -1)? op : 0;\\n            if(dp[idx][i] != -1) return dp[idx][i];\\n            long take = (op * nums[idx]) + solve(idx + 1,op * -1);\\n            long leave = solve(idx + 1,op);\\n            return dp[idx][i] = Math.Max(take,leave);\\n        }\\n        return solve(0,1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution {\\n    public long MaxAlternatingSum(int[] nums) {\\n        int n = nums.Length;\\n        long[][] dp = new long[n][];\\n        for(int i = 0; i < n;i++) dp[i] = new long[] {-1,-1};\\n        long solve(int idx,int op){\\n            if(idx >= n) return 0;\\n            int i = (op > -1)? op : 0;\\n            if(dp[idx][i] != -1) return dp[idx][i];\\n            long take = (op * nums[idx]) + solve(idx + 1,op * -1);\\n            long leave = solve(idx + 1,op);\\n            return dp[idx][i] = Math.Max(take,leave);\\n        }\\n        return solve(0,1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774733,
                "title": "c-easy-solution-using-dp",
                "content": "```\\npublic class Solution {\\n    public long MaxAlternatingSum(int[] nums) {\\n        int n = nums.Length;\\n        long[][] dp = new long[n][];\\n        for(int i = 0; i < n;i++) dp[i] = new long[] {-1,-1};\\n        long solve(int idx,int op){\\n            if(idx >= n) return 0;\\n            int i = (op > -1)? op : 0;\\n            if(dp[idx][i] != -1) return dp[idx][i];\\n            long take = (op * nums[idx]) + solve(idx + 1,op * -1);\\n            long leave = solve(idx + 1,op);\\n            return dp[idx][i] = Math.Max(take,leave);\\n        }\\n        return solve(0,1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution {\\n    public long MaxAlternatingSum(int[] nums) {\\n        int n = nums.Length;\\n        long[][] dp = new long[n][];\\n        for(int i = 0; i < n;i++) dp[i] = new long[] {-1,-1};\\n        long solve(int idx,int op){\\n            if(idx >= n) return 0;\\n            int i = (op > -1)? op : 0;\\n            if(dp[idx][i] != -1) return dp[idx][i];\\n            long take = (op * nums[idx]) + solve(idx + 1,op * -1);\\n            long leave = solve(idx + 1,op);\\n            return dp[idx][i] = Math.Max(take,leave);\\n        }\\n        return solve(0,1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769490,
                "title": "simple-and-intuitive-c-tc-o-n-sc-o-1-solution",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\nWe only pick positive number to add to sum. Therefore, we have to keep the smallest max_diff_i, which indicates that we pick nums[i] as negative and add to the max_sum before index i.  \\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\nKeep Essential Infornation to reduce TC from O(N*N) -> O(N)\\r\\n\\r\\n# Complexity\\r\\n- Time complexity: O(N)\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n\\r\\n- Space complexity: O(1)\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    long long maxAlternatingSum(vector<int>& nums) {\\r\\n        /*\\r\\n                      4, 2, 5, 3\\r\\n        max_value  0  4  4  7 \\r\\n        max_diff   0  0  2  2\\r\\n\\r\\n        sum_(t) = max(nums[i] + max_diff, sum_(t-1))\\r\\n        max_diff_t = max(max_diff, sum_(t-1) - nums[i])\\r\\n\\r\\n        TC: O(N)\\r\\n        SC: O(1)\\r\\n\\r\\n        */\\r\\n        long long max_diff = 0 ; \\r\\n        long long max_sum = 0 ; \\r\\n        for (int i=0; i<nums.size(); ++i) {\\r\\n            \\r\\n            long long max_sum_next = max(nums[i] + max_diff, max_sum);\\r\\n            max_diff = max(max_diff, max_sum - nums[i]) ;\\r\\n            max_sum = max_sum_next ; \\r\\n        }\\r\\n        return max_sum;\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    long long maxAlternatingSum(vector<int>& nums) {\\r\\n        /*\\r\\n                      4, 2, 5, 3\\r\\n        max_value  0  4  4  7 \\r\\n        max_diff   0  0  2  2\\r\\n\\r\\n        sum_(t) = max(nums[i] + max_diff, sum_(t-1))\\r\\n        max_diff_t = max(max_diff, sum_(t-1) - nums[i])\\r\\n\\r\\n        TC: O(N)\\r\\n        SC: O(1)\\r\\n\\r\\n        */\\r\\n        long long max_diff = 0 ; \\r\\n        long long max_sum = 0 ; \\r\\n        for (int i=0; i<nums.size(); ++i) {\\r\\n            \\r\\n            long long max_sum_next = max(nums[i] + max_diff, max_sum);\\r\\n            max_diff = max(max_diff, max_sum - nums[i]) ;\\r\\n            max_sum = max_sum_next ; \\r\\n        }\\r\\n        return max_sum;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766470,
                "title": "c-memoization-tabulation-method-space-optimisation",
                "content": "class Solution {\\npublic:\\n    \\n    //T.C:--  O(N) \\n    //S.C:--  O(N) + O(N)\\n    \\n    long long solveMem(vector<int>& nums, int n, int i, int flag, vector<vector<long long>>& dp) {\\n        \\n        if(i >= n) {\\n            return 0;\\n        }\\n        \\n        if(dp[i][flag] != -1) {\\n            return dp[i][flag];\\n        }\\n        \\n        long long value = nums[i];\\n        \\n        //skip\\n        long long skip = solve(nums, n, i+1, flag, dp);\\n        if(flag == 0) {\\n            value = -value;\\n        }\\n        \\n        //take\\n        long long take = value + solve(nums, n, i+1, !flag, dp);\\n        \\n        return dp[i][flag] = max(take, skip);\\n    }\\n    \\n    \\n    long long maxAlternatingSum(vector<int>& nums) {\\n        \\n         return solveMem(nums, n, 0, 1, dp);\\n\\t\\t \\n\\t\\t }\\n   };\\n   \\n   \\n     long long maxAlternatingSum(vector<int>& nums) {\\n        //Tabulation Method\\n        //T.C:-   O(N)\\n        //S.C:--  O(N)    \\n            \\n        int n = nums.size();\\n        vector<vector<long long>> dp(n+1, vector<long long>(2, 0));\\n        \\n        for(int i=n-1; i>=0; i--) {\\n            for(int flag=0; flag<2; flag++) {\\n               \\n        long long value = nums[i];\\n        \\n        //skip\\n        long long skip = dp[i+1][flag];\\n        if(flag == 0) {\\n            value = -value;\\n        }\\n        \\n        //take\\n        long long take = value + dp[i+1][!flag];\\n        \\n         dp[i][flag] = max(take, skip);   \\n            }\\n        }\\n        \\n        return dp[0][1];\\n        \\n\\t }\\n };  \\n \\n \\n \\n        //space optimisations\\n        //T.C:-   O(N)\\n        //S.C:--  O(1)\\n\\t\\t\\n\\t\\tlong long maxAlternatingSum(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<long long> curr(2, 0);\\n        vector<long long> next(2, 0);\\n        \\n        \\n        for(int i=n-1; i>=0; i--) {\\n            for(int flag=0; flag<2; flag++) {\\n               \\n        long long value = nums[i];\\n        \\n        //skip\\n        long long skip = next[flag];\\n        if(flag == 0) {\\n            value = -value;\\n        }\\n        \\n        //take\\n        long long take = value + next[!flag];\\n        \\n         curr[flag] = max(take, skip);   \\n            }\\n            next = curr;\\n        }\\n        \\n        return next[1];\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    //T.C:--  O(N) \\n    //S.C:--  O(N) + O(N)\\n    \\n    long long solveMem(vector<int>& nums, int n, int i, int flag, vector<vector<long long>>& dp) {\\n        \\n        if(i >= n) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3764905,
                "title": "efficient-c-solution-o-n-time-and-o-1-space-complexity",
                "content": "# Complexity\\r\\n- Time complexity: $$O(n)$$\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity: $$O(1)$$\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    long long maxAlternatingSum(vector<int>& nums) {\\r\\n        if(nums.size() == 1) return nums[0];\\r\\n        int smallest, highest, i;\\r\\n\\r\\n        long long ans = 0;\\r\\n        smallest = 0;\\r\\n        highest = nums[0];\\r\\n        i = 1;\\r\\n\\r\\n        while(i < nums.size()) {\\r\\n            if(nums[i] < nums[i - 1]) {\\r\\n                if(highest > smallest) {\\r\\n                    ans += highest - smallest;\\r\\n                    highest = 0;\\r\\n                }\\r\\n                smallest = nums[i];\\r\\n            }\\r\\n            else highest = nums[i];\\r\\n            i++;\\r\\n        }\\r\\n        if(highest > smallest) ans += highest - smallest;\\r\\n\\r\\n        return ans;\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    long long maxAlternatingSum(vector<int>& nums) {\\r\\n        if(nums.size() == 1) return nums[0];\\r\\n        int smallest, highest, i;\\r\\n\\r\\n        long long ans = 0;\\r\\n        smallest = 0;\\r\\n        highest = nums[0];\\r\\n        i = 1;\\r\\n\\r\\n        while(i < nums.size()) {\\r\\n            if(nums[i] < nums[i - 1]) {\\r\\n                if(highest > smallest) {\\r\\n                    ans += highest - smallest;\\r\\n                    highest = 0;\\r\\n                }\\r\\n                smallest = nums[i];\\r\\n            }\\r\\n            else highest = nums[i];\\r\\n            i++;\\r\\n        }\\r\\n        if(highest > smallest) ans += highest - smallest;\\r\\n\\r\\n        return ans;\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3715148,
                "title": "javascript-just-find-slice-max-and-min",
                "content": "# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\nThere are three types of array:\\r\\n1. Totally ascending order;\\r\\n2. Totally descending order;\\r\\n3. Alternating ascending and descending;\\r\\n\\r\\nFor these three types array, the answers are:\\r\\n1. The last element of array;\\r\\n2. The first element of array;\\r\\n3. Alternating find max and min element of slice array, get the accumulation;\\r\\n\\r\\n \\r\\n![IMG_62263D1BFE18-1.jpeg](https://assets.leetcode.com/users/images/0ab1e28f-7153-4762-b8ba-3ac552286e33_1688439652.5844648.jpeg)\\r\\n\\r\\n# Complexity\\r\\n- Time complexity: $$O(n)$$\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n  \\r\\n- Space complexity: $$O(1)$$\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n# Code\\r\\n```\\r\\n/**\\r\\n * @param {number[]} nums\\r\\n * @return {number}\\r\\n */\\r\\nvar maxAlternatingSum = function(nums) {\\r\\n    const len = nums.length\\r\\n    let sum = 0\\r\\n    let i = 0\\r\\n\\r\\n    while (i < len) {\\r\\n        // find slice max\\r\\n        while (i < len) {\\r\\n            const [x, y, z] = [nums[i - 1] || 0, nums[i], nums[i + 1] || 0]\\r\\n            \\r\\n            i += 1\\r\\n            \\r\\n            if (x <= y && y > z) {\\r\\n                sum += y\\r\\n                break\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // find slice min\\r\\n        while (i < len) {\\r\\n            const [x, y, z] = [nums[i - 1], nums[i], nums[i + 1] || Number.MAX_SAFE_INTEGER]\\r\\n            \\r\\n            i += 1\\r\\n            \\r\\n            if (x >= y && y < z) {\\t\\r\\n                if (i === len) break\\r\\n                \\r\\n                sum -= y\\r\\n                break\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return sum\\r\\n};\\r\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\r\\n/**\\r\\n * @param {number[]} nums\\r\\n * @return {number}\\r\\n */\\r\\nvar maxAlternatingSum = function(nums) {\\r\\n    const len = nums.length\\r\\n    let sum = 0\\r\\n    let i = 0\\r\\n\\r\\n    while (i < len) {\\r\\n        // find slice max\\r\\n        while (i < len) {\\r\\n            const [x, y, z] = [nums[i - 1] || 0, nums[i], nums[i + 1] || 0]\\r\\n            \\r\\n            i += 1\\r\\n            \\r\\n            if (x <= y && y > z) {\\r\\n                sum += y\\r\\n                break\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // find slice min\\r\\n        while (i < len) {\\r\\n            const [x, y, z] = [nums[i - 1], nums[i], nums[i + 1] || Number.MAX_SAFE_INTEGER]\\r\\n            \\r\\n            i += 1\\r\\n            \\r\\n            if (x >= y && y < z) {\\t\\r\\n                if (i === len) break\\r\\n                \\r\\n                sum -= y\\r\\n                break\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    return sum\\r\\n};\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3676636,
                "title": "easy-to-understand-simple-solution-c-beats-60-iit-roorkee",
                "content": "# Intuition \\r\\nObservation\\r\\n\\r\\n# Approach\\r\\n2D DP with certain condition\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:O(N*N);\\r\\n\\r\\n- Space complexity:O(N*2);\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n    long long dp[100001][2];\\r\\n    long long calc(vector<int>& nums,int index,bool flag)\\r\\n    {\\r\\n        if(index>=nums.size())\\r\\n        {\\r\\n            return 0ll;\\r\\n        }\\r\\n        if(dp[index][flag]!=-1)\\r\\n        {\\r\\n            return dp[index][flag];\\r\\n        }\\r\\n        if(flag==1)\\r\\n        {\\r\\n            long long sum1=0;\\r\\n            long long sum2=0;\\r\\n            sum1=nums[index]+calc(nums,index+1,0);\\r\\n            sum2=calc(nums,index+1,1);\\r\\n            return dp[index][1]=max(sum1,sum2);\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            long long sum3=0;\\r\\n            long long sum4=0;\\r\\n            sum3=-nums[index]+calc(nums,index+1,1);\\r\\n            sum4=calc(nums,index+1,0);\\r\\n            return dp[index][0]=max(sum3,sum4);\\r\\n        }\\r\\n        return 0;\\r\\n    }\\r\\n    long long maxAlternatingSum(vector<int>& nums) \\r\\n    {\\r\\n        memset(dp,-1,sizeof(dp));\\r\\n        return calc(nums,0,1); \\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n    long long dp[100001][2];\\r\\n    long long calc(vector<int>& nums,int index,bool flag)\\r\\n    {\\r\\n        if(index>=nums.size())\\r\\n        {\\r\\n            return 0ll;\\r\\n        }\\r\\n        if(dp[index][flag]!=-1)\\r\\n        {\\r\\n            return dp[index][flag];\\r\\n        }\\r\\n        if(flag==1)\\r\\n        {\\r\\n            long long sum1=0;\\r\\n            long long sum2=0;\\r\\n            sum1=nums[index]+calc(nums,index+1,0);\\r\\n            sum2=calc(nums,index+1,1);\\r\\n            return dp[index][1]=max(sum1,sum2);\\r\\n        }\\r\\n        else\\r\\n        {\\r\\n            long long sum3=0;\\r\\n            long long sum4=0;\\r\\n            sum3=-nums[index]+calc(nums,index+1,1);\\r\\n            sum4=calc(nums,index+1,0);\\r\\n            return dp[index][0]=max(sum3,sum4);\\r\\n        }\\r\\n        return 0;\\r\\n    }\\r\\n    long long maxAlternatingSum(vector<int>& nums) \\r\\n    {\\r\\n        memset(dp,-1,sizeof(dp));\\r\\n        return calc(nums,0,1); \\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641348,
                "title": "c-solution-2d-dp-memo-tabulation-space-optimization",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution {\\r\\npublic:\\r\\n//memoization\\r\\n    long long solve(vector<int> & nums,int index,int flag,vector<vector<long long>> & dp){\\r\\n        if(index>=nums.size()) return 0;\\r\\n        if(dp[index][flag] != -1) return dp[index][flag];\\r\\n        long long pick=0;\\r\\n        if(flag) pick=solve(nums,index+1,0,dp)+nums[index];\\r\\n        else pick=solve(nums,index+1,1,dp)-nums[index];\\r\\n        long long  notPick=solve(nums,index+1,flag,dp);\\r\\n        return dp[index][flag]=max(pick,notPick);\\r\\n    }\\r\\n    long long maxAlternatingSum1(vector<int>& nums){\\r\\n        vector<vector<long long>> dp(nums.size(),vector<long long>(2,-1));\\r\\n        return solve(nums,0,1,dp);\\r\\n    }\\r\\n//tabulation\\r\\n    long long maxAlternatingSum2(vector<int>& nums){\\r\\n        vector<vector<long long >> dp(nums.size(),vector<long long>(2,-1));\\r\\n        dp[0][1]=nums[0];\\r\\n        dp[0][0]=0;\\r\\n\\r\\n        for(int i=1;i<nums.size();i++){\\r\\n            int flag=0;\\r\\n            for(int j=0;j<2;j++){\\r\\n                long long pick=0;\\r\\n                if(flag) pick=dp[i-1][flag-1]+nums[i];\\r\\n                else pick=dp[i-1][flag+1]-nums[i];\\r\\n                long long notPick=dp[i-1][flag];\\r\\n                dp[i][flag]=max(pick,notPick);\\r\\n                flag=1;\\r\\n            }\\r\\n        }\\r\\n        return max(dp[nums.size()-1][0],dp[nums.size()-1][1]);\\r\\n    }\\r\\n//space optimization\\r\\nlong long maxAlternatingSum(vector<int>& nums){\\r\\n        vector<long long> arr(2);\\r\\n        arr[0]=0;\\r\\n        arr[1]=nums[0];\\r\\n\\r\\n        for(int i=1;i<nums.size();i++){\\r\\n            vector<long long> temp(2);\\r\\n            for(int j=0;j<2;j++){\\r\\n                long long pick=0;\\r\\n                if(j) pick=arr[0]+nums[i];\\r\\n                else pick=arr[1]-nums[i];\\r\\n                long long notPick=arr[j];\\r\\n                temp[j]=max(pick,notPick);\\r\\n            }\\r\\n            arr=temp;\\r\\n        }\\r\\n        return max(arr[0],arr[1]);\\r\\n    }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\r\\nclass Solution {\\r\\npublic:\\r\\n//memoization\\r\\n    long long solve(vector<int> & nums,int index,int flag,vector<vector<long long>> & dp){\\r\\n        if(index>=nums.size()) return 0;\\r\\n        if(dp[index][flag] != -1) return dp[index][flag];\\r\\n        long long pick=0;\\r\\n        if(flag) pick=solve(nums,index+1,0,dp)+nums[index];\\r\\n        else pick=solve(nums,index+1,1,dp)-nums[index];\\r\\n        long long  notPick=solve(nums,index+1,flag,dp);\\r\\n        return dp[index][flag]=max(pick,notPick);\\r\\n    }\\r\\n    long long maxAlternatingSum1(vector<int>& nums){\\r\\n        vector<vector<long long>> dp(nums.size(),vector<long long>(2,-1));\\r\\n        return solve(nums,0,1,dp);\\r\\n    }\\r\\n//tabulation\\r\\n    long long maxAlternatingSum2(vector<int>& nums){\\r\\n        vector<vector<long long >> dp(nums.size(),vector<long long>(2,-1));\\r\\n        dp[0][1]=nums[0];\\r\\n        dp[0][0]=0;\\r\\n\\r\\n        for(int i=1;i<nums.size();i++){\\r\\n            int flag=0;\\r\\n            for(int j=0;j<2;j++){\\r\\n                long long pick=0;\\r\\n                if(flag) pick=dp[i-1][flag-1]+nums[i];\\r\\n                else pick=dp[i-1][flag+1]-nums[i];\\r\\n                long long notPick=dp[i-1][flag];\\r\\n                dp[i][flag]=max(pick,notPick);\\r\\n                flag=1;\\r\\n            }\\r\\n        }\\r\\n        return max(dp[nums.size()-1][0],dp[nums.size()-1][1]);\\r\\n    }\\r\\n//space optimization\\r\\nlong long maxAlternatingSum(vector<int>& nums){\\r\\n        vector<long long> arr(2);\\r\\n        arr[0]=0;\\r\\n        arr[1]=nums[0];\\r\\n\\r\\n        for(int i=1;i<nums.size();i++){\\r\\n            vector<long long> temp(2);\\r\\n            for(int j=0;j<2;j++){\\r\\n                long long pick=0;\\r\\n                if(j) pick=arr[0]+nums[i];\\r\\n                else pick=arr[1]-nums[i];\\r\\n                long long notPick=arr[j];\\r\\n                temp[j]=max(pick,notPick);\\r\\n            }\\r\\n            arr=temp;\\r\\n        }\\r\\n        return max(arr[0],arr[1]);\\r\\n    }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628511,
                "title": "greedy-stack-o-n-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\n        stack = []\\n        even =True\\n        re = 0\\n        for i in nums:\\n            \\n            if even:\\n                if stack and stack[-1]>i:\\n                    re += stack.pop()\\n                    stack.append(i)\\n                    re -= i\\n                else:\\n                    stack.append(i)\\n                    even = False\\n                    re += i\\n            else:\\n                if stack[-1]<i:\\n                    re -= stack.pop()\\n                    stack.append(i)\\n                    re +=i\\n                else:\\n                    stack.append(i)\\n                    even = True\\n                    re -= i\\n        if len(stack)%2==0:\\n            re+=stack.pop()\\n        return re\\n        \\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\n        stack = []\\n        even =True\\n        re = 0\\n        for i in nums:\\n            \\n            if even:\\n                if stack and stack[-1]>i:\\n                    re += stack.pop()\\n                    stack.append(i)\\n                    re -= i\\n                else:\\n                    stack.append(i)\\n                    even = False\\n                    re += i\\n            else:\\n                if stack[-1]<i:\\n                    re -= stack.pop()\\n                    stack.append(i)\\n                    re +=i\\n                else:\\n                    stack.append(i)\\n                    even = True\\n                    re -= i\\n        if len(stack)%2==0:\\n            re+=stack.pop()\\n        return re\\n        \\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602082,
                "title": "ruby-solution-with-min-and-max-memos-100-100",
                "content": "# Intuition\\r\\nBecause you\\'re both adding and subtracting, it makes most sense to have two different memos.\\r\\n\\r\\n# Approach\\r\\n1. Make nums an instance variable.\\r\\n2. Create min and max memos.\\r\\n3. Call the max_sum helper function starting at index 0.\\r\\n\\r\\nmax_sum:\\r\\n1. Return 0 if at the end of nums.\\r\\n2. Return a memoized value if possible.\\r\\n3. Consider two options:\\r\\n    a. Do not include the current number; call the function  for i+1\\r\\n    b. Include the current number; find the *minimum* from the remaining numbers and subtract that.\\r\\n4. Choose the higher option, memoize, and return.\\r\\n\\r\\nmin_sum is exactly the same, with min/max reversed.\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n$$O(n)$$\\r\\n\\r\\n- Space complexity:\\r\\n$$O(n)$$\\r\\n\\r\\n# Code\\r\\n```\\r\\ndef max_alternating_sum(nums)\\r\\n    @nums = nums\\r\\n    @min_memo = {}\\r\\n    @max_memo = {}\\r\\n\\r\\n    max_sum(0)\\r\\nend\\r\\n\\r\\ndef max_sum(i)\\r\\n    return 0 if i == @nums.length\\r\\n    return @max_memo[i] if @max_memo[i]\\r\\n\\r\\n    options = [max_sum(i+1), @nums[i] - min_sum(i+1)]\\r\\n    @max_memo[i] = options.max\\r\\nend\\r\\n\\r\\ndef min_sum(i)\\r\\n    return 0 if i == @nums.length\\r\\n    return @min_memo[i] if @min_memo[i]\\r\\n\\r\\n    options = [min_sum(i+1), @nums[i] - max_sum(i+1)]\\r\\n    @min_memo[i] = options.min\\r\\nend\\r\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\r\\ndef max_alternating_sum(nums)\\r\\n    @nums = nums\\r\\n    @min_memo = {}\\r\\n    @max_memo = {}\\r\\n\\r\\n    max_sum(0)\\r\\nend\\r\\n\\r\\ndef max_sum(i)\\r\\n    return 0 if i == @nums.length\\r\\n    return @max_memo[i] if @max_memo[i]\\r\\n\\r\\n    options = [max_sum(i+1), @nums[i] - min_sum(i+1)]\\r\\n    @max_memo[i] = options.max\\r\\nend\\r\\n\\r\\ndef min_sum(i)\\r\\n    return 0 if i == @nums.length\\r\\n    return @min_memo[i] if @min_memo[i]\\r\\n\\r\\n    options = [min_sum(i+1), @nums[i] - max_sum(i+1)]\\r\\n    @min_memo[i] = options.min\\r\\nend\\r\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1727743,
                "content": [
                    {
                        "username": "user2957XF",
                        "content": "In my opinion, the wording in this question is a little bit confusing, because the sign is determined by the element's index *in the selected subsequence* and not by its original index."
                    },
                    {
                        "username": "satyam47",
                        "content": "Similar to [122. Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "I did using 0/1 knapsack  in tabular method. It\\'s giving tle after 43 tcs. Can anyone give me reasons ?\\n\\nMy Code: \\n\\n```\\nclass Solution {\\npublic:\\n    long long traverse(vector<int>& nums, int count,  int pos, vector<vector<int>>& dp){\\n       if(pos == nums.size()) return 0; \\n        long long k1 = 0, k2 = 0; \\n        if(dp[count][pos+1] == -1) dp[count][pos+1] = traverse(nums, count, pos+1, dp); \\n        k1 = dp[count][pos+1]; \\n\\n            if(dp[count+1][pos+1] == -1) dp[count+1][pos+1] = traverse(nums, count+1, pos+1, dp); \\n        if(count %2 == 0)  k2 = dp[count+1][pos+1] + nums[pos];\\n        else  k2 = dp[count+1][pos+1] - nums[pos]; \\n\\n        if(k1 > k2) return k1; \\n        return k2; \\n\\n    }\\n\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        vector<vector< int>> dp(nums.size()+1, vector< int> (nums.size()+1, -1)); \\n        for(int i=0; i<=nums.size(); i++) dp[i][nums.size()] = 0; \\n        for(int i=0; i<=nums.size(); i++) dp[0][i] = 0; \\n\\n        for(int i=nums.size()-1; i>=0; i--){\\n            for(int j = nums.size()-1; j>=0; j--){\\n                long long  k1 = 0, k2 = 0; \\n                k1 = dp[i][j+1]; \\n                 k2 = dp[i+1][j+1]; \\n                 if(i%2 == 0) k2 += nums[j]; else k2 -= nums[j]; \\n\\n                 if(k1 > k2) dp[i][j] = k1; else dp[i][j] = k2; \\n            }\\n        } \\n        return dp[0][0]; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "BlunderPride",
                        "content": "class Solution {\\n    // memoised:\\nlong long helper(vector<int> &nums, int ind, int flag,vector<vector<int>> &memo)\\n\\n{\\n\\n    if(ind>=nums.size()) return 0;\\n    if(memo[ind][flag]!=-1) return memo[ind][flag];\\n    // take or not take\\n    int sum;\\n        if(flag==0) {\\n            sum= -nums[ind];\\n        }\\n        if(flag==1) sum= nums[ind];\\n        return memo[ind][flag]=max(sum + helper(nums, ind+1, !flag, memo), helper(nums, ind+1, flag, memo));\\n}\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n            vector<vector<int>> memo(100001, vector<int> (2, -1));\\n\\n        int n= nums.size();\\n        long long res=0;\\n        int ind=0;\\n       int flag= true;\\n        res=helper(nums, ind, flag, memo);\\n        return res;\\n    }\\n};\\n\\n\\nwhy is this code breaking on larger test cases? can anyone help.\\n63rd tc is not getting executed out of 65 test cases."
                    },
                    {
                        "username": "Vss4969",
                        "content": "If the next element is equal to the previous one, should I :\\n* consider it as greater than or\\n* less than or\\n* forget it and move on to next element.\\n\\n??? anyone"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Dude, don\\'t care about the element, if you consider it and it\\'s index is even in subsequence  add it, else subtract it, else forget it and move on. "
                    },
                    {
                        "username": "Prajju22",
                        "content": "think of knapsack but do not forget for changing the sign if any element is selected "
                    }
                ]
            },
            {
                "id": 2053734,
                "content": [
                    {
                        "username": "user2957XF",
                        "content": "In my opinion, the wording in this question is a little bit confusing, because the sign is determined by the element's index *in the selected subsequence* and not by its original index."
                    },
                    {
                        "username": "satyam47",
                        "content": "Similar to [122. Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "I did using 0/1 knapsack  in tabular method. It\\'s giving tle after 43 tcs. Can anyone give me reasons ?\\n\\nMy Code: \\n\\n```\\nclass Solution {\\npublic:\\n    long long traverse(vector<int>& nums, int count,  int pos, vector<vector<int>>& dp){\\n       if(pos == nums.size()) return 0; \\n        long long k1 = 0, k2 = 0; \\n        if(dp[count][pos+1] == -1) dp[count][pos+1] = traverse(nums, count, pos+1, dp); \\n        k1 = dp[count][pos+1]; \\n\\n            if(dp[count+1][pos+1] == -1) dp[count+1][pos+1] = traverse(nums, count+1, pos+1, dp); \\n        if(count %2 == 0)  k2 = dp[count+1][pos+1] + nums[pos];\\n        else  k2 = dp[count+1][pos+1] - nums[pos]; \\n\\n        if(k1 > k2) return k1; \\n        return k2; \\n\\n    }\\n\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        vector<vector< int>> dp(nums.size()+1, vector< int> (nums.size()+1, -1)); \\n        for(int i=0; i<=nums.size(); i++) dp[i][nums.size()] = 0; \\n        for(int i=0; i<=nums.size(); i++) dp[0][i] = 0; \\n\\n        for(int i=nums.size()-1; i>=0; i--){\\n            for(int j = nums.size()-1; j>=0; j--){\\n                long long  k1 = 0, k2 = 0; \\n                k1 = dp[i][j+1]; \\n                 k2 = dp[i+1][j+1]; \\n                 if(i%2 == 0) k2 += nums[j]; else k2 -= nums[j]; \\n\\n                 if(k1 > k2) dp[i][j] = k1; else dp[i][j] = k2; \\n            }\\n        } \\n        return dp[0][0]; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "BlunderPride",
                        "content": "class Solution {\\n    // memoised:\\nlong long helper(vector<int> &nums, int ind, int flag,vector<vector<int>> &memo)\\n\\n{\\n\\n    if(ind>=nums.size()) return 0;\\n    if(memo[ind][flag]!=-1) return memo[ind][flag];\\n    // take or not take\\n    int sum;\\n        if(flag==0) {\\n            sum= -nums[ind];\\n        }\\n        if(flag==1) sum= nums[ind];\\n        return memo[ind][flag]=max(sum + helper(nums, ind+1, !flag, memo), helper(nums, ind+1, flag, memo));\\n}\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n            vector<vector<int>> memo(100001, vector<int> (2, -1));\\n\\n        int n= nums.size();\\n        long long res=0;\\n        int ind=0;\\n       int flag= true;\\n        res=helper(nums, ind, flag, memo);\\n        return res;\\n    }\\n};\\n\\n\\nwhy is this code breaking on larger test cases? can anyone help.\\n63rd tc is not getting executed out of 65 test cases."
                    },
                    {
                        "username": "Vss4969",
                        "content": "If the next element is equal to the previous one, should I :\\n* consider it as greater than or\\n* less than or\\n* forget it and move on to next element.\\n\\n??? anyone"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Dude, don\\'t care about the element, if you consider it and it\\'s index is even in subsequence  add it, else subtract it, else forget it and move on. "
                    },
                    {
                        "username": "Prajju22",
                        "content": "think of knapsack but do not forget for changing the sign if any element is selected "
                    }
                ]
            },
            {
                "id": 1984428,
                "content": [
                    {
                        "username": "user2957XF",
                        "content": "In my opinion, the wording in this question is a little bit confusing, because the sign is determined by the element's index *in the selected subsequence* and not by its original index."
                    },
                    {
                        "username": "satyam47",
                        "content": "Similar to [122. Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "I did using 0/1 knapsack  in tabular method. It\\'s giving tle after 43 tcs. Can anyone give me reasons ?\\n\\nMy Code: \\n\\n```\\nclass Solution {\\npublic:\\n    long long traverse(vector<int>& nums, int count,  int pos, vector<vector<int>>& dp){\\n       if(pos == nums.size()) return 0; \\n        long long k1 = 0, k2 = 0; \\n        if(dp[count][pos+1] == -1) dp[count][pos+1] = traverse(nums, count, pos+1, dp); \\n        k1 = dp[count][pos+1]; \\n\\n            if(dp[count+1][pos+1] == -1) dp[count+1][pos+1] = traverse(nums, count+1, pos+1, dp); \\n        if(count %2 == 0)  k2 = dp[count+1][pos+1] + nums[pos];\\n        else  k2 = dp[count+1][pos+1] - nums[pos]; \\n\\n        if(k1 > k2) return k1; \\n        return k2; \\n\\n    }\\n\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        vector<vector< int>> dp(nums.size()+1, vector< int> (nums.size()+1, -1)); \\n        for(int i=0; i<=nums.size(); i++) dp[i][nums.size()] = 0; \\n        for(int i=0; i<=nums.size(); i++) dp[0][i] = 0; \\n\\n        for(int i=nums.size()-1; i>=0; i--){\\n            for(int j = nums.size()-1; j>=0; j--){\\n                long long  k1 = 0, k2 = 0; \\n                k1 = dp[i][j+1]; \\n                 k2 = dp[i+1][j+1]; \\n                 if(i%2 == 0) k2 += nums[j]; else k2 -= nums[j]; \\n\\n                 if(k1 > k2) dp[i][j] = k1; else dp[i][j] = k2; \\n            }\\n        } \\n        return dp[0][0]; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "BlunderPride",
                        "content": "class Solution {\\n    // memoised:\\nlong long helper(vector<int> &nums, int ind, int flag,vector<vector<int>> &memo)\\n\\n{\\n\\n    if(ind>=nums.size()) return 0;\\n    if(memo[ind][flag]!=-1) return memo[ind][flag];\\n    // take or not take\\n    int sum;\\n        if(flag==0) {\\n            sum= -nums[ind];\\n        }\\n        if(flag==1) sum= nums[ind];\\n        return memo[ind][flag]=max(sum + helper(nums, ind+1, !flag, memo), helper(nums, ind+1, flag, memo));\\n}\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n            vector<vector<int>> memo(100001, vector<int> (2, -1));\\n\\n        int n= nums.size();\\n        long long res=0;\\n        int ind=0;\\n       int flag= true;\\n        res=helper(nums, ind, flag, memo);\\n        return res;\\n    }\\n};\\n\\n\\nwhy is this code breaking on larger test cases? can anyone help.\\n63rd tc is not getting executed out of 65 test cases."
                    },
                    {
                        "username": "Vss4969",
                        "content": "If the next element is equal to the previous one, should I :\\n* consider it as greater than or\\n* less than or\\n* forget it and move on to next element.\\n\\n??? anyone"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Dude, don\\'t care about the element, if you consider it and it\\'s index is even in subsequence  add it, else subtract it, else forget it and move on. "
                    },
                    {
                        "username": "Prajju22",
                        "content": "think of knapsack but do not forget for changing the sign if any element is selected "
                    }
                ]
            },
            {
                "id": 1975377,
                "content": [
                    {
                        "username": "user2957XF",
                        "content": "In my opinion, the wording in this question is a little bit confusing, because the sign is determined by the element's index *in the selected subsequence* and not by its original index."
                    },
                    {
                        "username": "satyam47",
                        "content": "Similar to [122. Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "I did using 0/1 knapsack  in tabular method. It\\'s giving tle after 43 tcs. Can anyone give me reasons ?\\n\\nMy Code: \\n\\n```\\nclass Solution {\\npublic:\\n    long long traverse(vector<int>& nums, int count,  int pos, vector<vector<int>>& dp){\\n       if(pos == nums.size()) return 0; \\n        long long k1 = 0, k2 = 0; \\n        if(dp[count][pos+1] == -1) dp[count][pos+1] = traverse(nums, count, pos+1, dp); \\n        k1 = dp[count][pos+1]; \\n\\n            if(dp[count+1][pos+1] == -1) dp[count+1][pos+1] = traverse(nums, count+1, pos+1, dp); \\n        if(count %2 == 0)  k2 = dp[count+1][pos+1] + nums[pos];\\n        else  k2 = dp[count+1][pos+1] - nums[pos]; \\n\\n        if(k1 > k2) return k1; \\n        return k2; \\n\\n    }\\n\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        vector<vector< int>> dp(nums.size()+1, vector< int> (nums.size()+1, -1)); \\n        for(int i=0; i<=nums.size(); i++) dp[i][nums.size()] = 0; \\n        for(int i=0; i<=nums.size(); i++) dp[0][i] = 0; \\n\\n        for(int i=nums.size()-1; i>=0; i--){\\n            for(int j = nums.size()-1; j>=0; j--){\\n                long long  k1 = 0, k2 = 0; \\n                k1 = dp[i][j+1]; \\n                 k2 = dp[i+1][j+1]; \\n                 if(i%2 == 0) k2 += nums[j]; else k2 -= nums[j]; \\n\\n                 if(k1 > k2) dp[i][j] = k1; else dp[i][j] = k2; \\n            }\\n        } \\n        return dp[0][0]; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "BlunderPride",
                        "content": "class Solution {\\n    // memoised:\\nlong long helper(vector<int> &nums, int ind, int flag,vector<vector<int>> &memo)\\n\\n{\\n\\n    if(ind>=nums.size()) return 0;\\n    if(memo[ind][flag]!=-1) return memo[ind][flag];\\n    // take or not take\\n    int sum;\\n        if(flag==0) {\\n            sum= -nums[ind];\\n        }\\n        if(flag==1) sum= nums[ind];\\n        return memo[ind][flag]=max(sum + helper(nums, ind+1, !flag, memo), helper(nums, ind+1, flag, memo));\\n}\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n            vector<vector<int>> memo(100001, vector<int> (2, -1));\\n\\n        int n= nums.size();\\n        long long res=0;\\n        int ind=0;\\n       int flag= true;\\n        res=helper(nums, ind, flag, memo);\\n        return res;\\n    }\\n};\\n\\n\\nwhy is this code breaking on larger test cases? can anyone help.\\n63rd tc is not getting executed out of 65 test cases."
                    },
                    {
                        "username": "Vss4969",
                        "content": "If the next element is equal to the previous one, should I :\\n* consider it as greater than or\\n* less than or\\n* forget it and move on to next element.\\n\\n??? anyone"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Dude, don\\'t care about the element, if you consider it and it\\'s index is even in subsequence  add it, else subtract it, else forget it and move on. "
                    },
                    {
                        "username": "Prajju22",
                        "content": "think of knapsack but do not forget for changing the sign if any element is selected "
                    }
                ]
            },
            {
                "id": 1946592,
                "content": [
                    {
                        "username": "user2957XF",
                        "content": "In my opinion, the wording in this question is a little bit confusing, because the sign is determined by the element's index *in the selected subsequence* and not by its original index."
                    },
                    {
                        "username": "satyam47",
                        "content": "Similar to [122. Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "I did using 0/1 knapsack  in tabular method. It\\'s giving tle after 43 tcs. Can anyone give me reasons ?\\n\\nMy Code: \\n\\n```\\nclass Solution {\\npublic:\\n    long long traverse(vector<int>& nums, int count,  int pos, vector<vector<int>>& dp){\\n       if(pos == nums.size()) return 0; \\n        long long k1 = 0, k2 = 0; \\n        if(dp[count][pos+1] == -1) dp[count][pos+1] = traverse(nums, count, pos+1, dp); \\n        k1 = dp[count][pos+1]; \\n\\n            if(dp[count+1][pos+1] == -1) dp[count+1][pos+1] = traverse(nums, count+1, pos+1, dp); \\n        if(count %2 == 0)  k2 = dp[count+1][pos+1] + nums[pos];\\n        else  k2 = dp[count+1][pos+1] - nums[pos]; \\n\\n        if(k1 > k2) return k1; \\n        return k2; \\n\\n    }\\n\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        vector<vector< int>> dp(nums.size()+1, vector< int> (nums.size()+1, -1)); \\n        for(int i=0; i<=nums.size(); i++) dp[i][nums.size()] = 0; \\n        for(int i=0; i<=nums.size(); i++) dp[0][i] = 0; \\n\\n        for(int i=nums.size()-1; i>=0; i--){\\n            for(int j = nums.size()-1; j>=0; j--){\\n                long long  k1 = 0, k2 = 0; \\n                k1 = dp[i][j+1]; \\n                 k2 = dp[i+1][j+1]; \\n                 if(i%2 == 0) k2 += nums[j]; else k2 -= nums[j]; \\n\\n                 if(k1 > k2) dp[i][j] = k1; else dp[i][j] = k2; \\n            }\\n        } \\n        return dp[0][0]; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "BlunderPride",
                        "content": "class Solution {\\n    // memoised:\\nlong long helper(vector<int> &nums, int ind, int flag,vector<vector<int>> &memo)\\n\\n{\\n\\n    if(ind>=nums.size()) return 0;\\n    if(memo[ind][flag]!=-1) return memo[ind][flag];\\n    // take or not take\\n    int sum;\\n        if(flag==0) {\\n            sum= -nums[ind];\\n        }\\n        if(flag==1) sum= nums[ind];\\n        return memo[ind][flag]=max(sum + helper(nums, ind+1, !flag, memo), helper(nums, ind+1, flag, memo));\\n}\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n            vector<vector<int>> memo(100001, vector<int> (2, -1));\\n\\n        int n= nums.size();\\n        long long res=0;\\n        int ind=0;\\n       int flag= true;\\n        res=helper(nums, ind, flag, memo);\\n        return res;\\n    }\\n};\\n\\n\\nwhy is this code breaking on larger test cases? can anyone help.\\n63rd tc is not getting executed out of 65 test cases."
                    },
                    {
                        "username": "Vss4969",
                        "content": "If the next element is equal to the previous one, should I :\\n* consider it as greater than or\\n* less than or\\n* forget it and move on to next element.\\n\\n??? anyone"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Dude, don\\'t care about the element, if you consider it and it\\'s index is even in subsequence  add it, else subtract it, else forget it and move on. "
                    },
                    {
                        "username": "Prajju22",
                        "content": "think of knapsack but do not forget for changing the sign if any element is selected "
                    }
                ]
            },
            {
                "id": 1938385,
                "content": [
                    {
                        "username": "user2957XF",
                        "content": "In my opinion, the wording in this question is a little bit confusing, because the sign is determined by the element's index *in the selected subsequence* and not by its original index."
                    },
                    {
                        "username": "satyam47",
                        "content": "Similar to [122. Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "I did using 0/1 knapsack  in tabular method. It\\'s giving tle after 43 tcs. Can anyone give me reasons ?\\n\\nMy Code: \\n\\n```\\nclass Solution {\\npublic:\\n    long long traverse(vector<int>& nums, int count,  int pos, vector<vector<int>>& dp){\\n       if(pos == nums.size()) return 0; \\n        long long k1 = 0, k2 = 0; \\n        if(dp[count][pos+1] == -1) dp[count][pos+1] = traverse(nums, count, pos+1, dp); \\n        k1 = dp[count][pos+1]; \\n\\n            if(dp[count+1][pos+1] == -1) dp[count+1][pos+1] = traverse(nums, count+1, pos+1, dp); \\n        if(count %2 == 0)  k2 = dp[count+1][pos+1] + nums[pos];\\n        else  k2 = dp[count+1][pos+1] - nums[pos]; \\n\\n        if(k1 > k2) return k1; \\n        return k2; \\n\\n    }\\n\\n    long long maxAlternatingSum(vector<int>& nums) {\\n        vector<vector< int>> dp(nums.size()+1, vector< int> (nums.size()+1, -1)); \\n        for(int i=0; i<=nums.size(); i++) dp[i][nums.size()] = 0; \\n        for(int i=0; i<=nums.size(); i++) dp[0][i] = 0; \\n\\n        for(int i=nums.size()-1; i>=0; i--){\\n            for(int j = nums.size()-1; j>=0; j--){\\n                long long  k1 = 0, k2 = 0; \\n                k1 = dp[i][j+1]; \\n                 k2 = dp[i+1][j+1]; \\n                 if(i%2 == 0) k2 += nums[j]; else k2 -= nums[j]; \\n\\n                 if(k1 > k2) dp[i][j] = k1; else dp[i][j] = k2; \\n            }\\n        } \\n        return dp[0][0]; \\n    }\\n};\\n```"
                    },
                    {
                        "username": "BlunderPride",
                        "content": "class Solution {\\n    // memoised:\\nlong long helper(vector<int> &nums, int ind, int flag,vector<vector<int>> &memo)\\n\\n{\\n\\n    if(ind>=nums.size()) return 0;\\n    if(memo[ind][flag]!=-1) return memo[ind][flag];\\n    // take or not take\\n    int sum;\\n        if(flag==0) {\\n            sum= -nums[ind];\\n        }\\n        if(flag==1) sum= nums[ind];\\n        return memo[ind][flag]=max(sum + helper(nums, ind+1, !flag, memo), helper(nums, ind+1, flag, memo));\\n}\\npublic:\\n    long long maxAlternatingSum(vector<int>& nums) {\\n            vector<vector<int>> memo(100001, vector<int> (2, -1));\\n\\n        int n= nums.size();\\n        long long res=0;\\n        int ind=0;\\n       int flag= true;\\n        res=helper(nums, ind, flag, memo);\\n        return res;\\n    }\\n};\\n\\n\\nwhy is this code breaking on larger test cases? can anyone help.\\n63rd tc is not getting executed out of 65 test cases."
                    },
                    {
                        "username": "Vss4969",
                        "content": "If the next element is equal to the previous one, should I :\\n* consider it as greater than or\\n* less than or\\n* forget it and move on to next element.\\n\\n??? anyone"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Dude, don\\'t care about the element, if you consider it and it\\'s index is even in subsequence  add it, else subtract it, else forget it and move on. "
                    },
                    {
                        "username": "Prajju22",
                        "content": "think of knapsack but do not forget for changing the sign if any element is selected "
                    }
                ]
            }
        ]
    }
]