[
    {
        "title": "Symmetric Tree",
        "question_content": "Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).\n&nbsp;\nExample 1:\n\nInput: root = [1,2,2,3,4,4,3]\nOutput: true\n\nExample 2:\n\nInput: root = [1,2,2,null,3,null,3]\nOutput: false\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the tree is in the range [1, 1000].\n\t-100 <= Node.val <= 100\n\n&nbsp;\nFollow up: Could you solve it both recursively and iteratively?",
        "solutions": [
            {
                "id": 33054,
                "title": "recursive-and-non-recursive-solutions-in-java",
                "content": "Recursive--400ms:\\n\\n    public boolean isSymmetric(TreeNode root) {\\n        return root==null || isSymmetricHelp(root.left, root.right);\\n    }\\n    \\n    private boolean isSymmetricHelp(TreeNode left, TreeNode right){\\n        if(left==null || right==null)\\n            return left==right;\\n        if(left.val!=right.val)\\n            return false;\\n        return isSymmetricHelp(left.left, right.right) && isSymmetricHelp(left.right, right.left);\\n    }\\n\\nNon-recursive(use Stack)--460ms:\\n\\n    public boolean isSymmetric(TreeNode root) {\\n        if(root==null)  return true;\\n        \\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        TreeNode left, right;\\n        if(root.left!=null){\\n            if(root.right==null) return false;\\n            stack.push(root.left);\\n            stack.push(root.right);\\n        }\\n        else if(root.right!=null){\\n            return false;\\n        }\\n            \\n        while(!stack.empty()){\\n            if(stack.size()%2!=0)   return false;\\n            right = stack.pop();\\n            left = stack.pop();\\n            if(right.val!=left.val) return false;\\n            \\n            if(left.left!=null){\\n                if(right.right==null)   return false;\\n                stack.push(left.left);\\n                stack.push(right.right);\\n            }\\n            else if(right.right!=null){\\n                return false;\\n            }\\n                \\n            if(left.right!=null){\\n                if(right.left==null)   return false;\\n                stack.push(left.right);\\n                stack.push(right.left);\\n            }\\n            else if(right.left!=null){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Recursion"
                ],
                "code": "Recursive--400ms:\\n\\n    public boolean isSymmetric(TreeNode root) {\\n        return root==null || isSymmetricHelp(root.left, root.right);\\n    }\\n    \\n    private boolean isSymmetricHelp(TreeNode left, TreeNode right){\\n        if(left==null || right==null)\\n            return left==right;\\n        if(left.val!=right.val)\\n            return false;\\n        return isSymmetricHelp(left.left, right.right) && isSymmetricHelp(left.right, right.left);\\n    }\\n\\nNon-recursive(use Stack)--460ms:\\n\\n    public boolean isSymmetric(TreeNode root) {\\n        if(root==null)  return true;\\n        \\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        TreeNode left, right;\\n        if(root.left!=null){\\n            if(root.right==null) return false;\\n            stack.push(root.left);\\n            stack.push(root.right);\\n        }\\n        else if(root.right!=null){\\n            return false;\\n        }\\n            \\n        while(!stack.empty()){\\n            if(stack.size()%2!=0)   return false;\\n            right = stack.pop();\\n            left = stack.pop();\\n            if(right.val!=left.val) return false;\\n            \\n            if(left.left!=null){\\n                if(right.right==null)   return false;\\n                stack.push(left.left);\\n                stack.push(right.right);\\n            }\\n            else if(right.right!=null){\\n                return false;\\n            }\\n                \\n            if(left.right!=null){\\n                if(right.left==null)   return false;\\n                stack.push(left.right);\\n                stack.push(right.left);\\n            }\\n            else if(right.left!=null){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 33050,
                "title": "recursively-and-iteratively-solution-in-python",
                "content": "Basically, this question is recursively. Or we can say, the tree structure is recursively, so the recursively solution maybe easy to write:\\n\\nTC: O(b) SC: O(log n)\\n\\n    class Solution:\\n      def isSymmetric(self, root):\\n        if root is None:\\n          return True\\n        else:\\n          return self.isMirror(root.left, root.right)\\n\\n      def isMirror(self, left, right):\\n        if left is None and right is None:\\n          return True\\n        if left is None or right is None:\\n          return False\\n\\n        if left.val == right.val:\\n          outPair = self.isMirror(left.left, right.right)\\n          inPiar = self.isMirror(left.right, right.left)\\n          return outPair and inPiar\\n        else:\\n          return False\\n\\nThe essence of recursively is Stack, so we can use our own stack to rewrite it into iteratively:\\n\\n     class Solution2:\\n      def isSymmetric(self, root):\\n        if root is None:\\n          return True\\n\\n        stack = [[root.left, root.right]]\\n\\n        while len(stack) > 0:\\n          pair = stack.pop(0)\\n          left = pair[0]\\n          right = pair[1]\\n\\n          if left is None and right is None:\\n            continue\\n          if left is None or right is None:\\n            return False\\n          if left.val == right.val:\\n            stack.insert(0, [left.left, right.right])\\n\\n            stack.insert(0, [left.right, right.left])\\n          else:\\n            return False\\n        return True",
                "solutionTags": [],
                "code": "Basically, this question is recursively. Or we can say, the tree structure is recursively, so the recursively solution maybe easy to write:\\n\\nTC: O(b) SC: O(log n)\\n\\n    class Solution:\\n      def isSymmetric(self, root):\\n        if root is None:\\n          return True\\n        else:\\n          return self.isMirror(root.left, root.right)\\n\\n      def isMirror(self, left, right):\\n        if left is None and right is None:\\n          return True\\n        if left is None or right is None:\\n          return False\\n\\n        if left.val == right.val:\\n          outPair = self.isMirror(left.left, right.right)\\n          inPiar = self.isMirror(left.right, right.left)\\n          return outPair and inPiar\\n        else:\\n          return False\\n\\nThe essence of recursively is Stack, so we can use our own stack to rewrite it into iteratively:\\n\\n     class Solution2:\\n      def isSymmetric(self, root):\\n        if root is None:\\n          return True\\n\\n        stack = [[root.left, root.right]]\\n\\n        while len(stack) > 0:\\n          pair = stack.pop(0)\\n          left = pair[0]\\n          right = pair[1]\\n\\n          if left is None and right is None:\\n            continue\\n          if left is None or right is None:\\n            return False\\n          if left.val == right.val:\\n            stack.insert(0, [left.left, right.right])\\n\\n            stack.insert(0, [left.right, right.left])\\n          else:\\n            return False\\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 33104,
                "title": "1ms-recursive-java-solution-easy-to-understand",
                "content": "     public boolean isSymmetric(TreeNode root) {\\n        if(root==null) return true;\\n        return isMirror(root.left,root.right);\\n    }\\n    public boolean isMirror(TreeNode p, TreeNode q) {\\n        if(p==null && q==null) return true;\\n        if(p==null || q==null) return false;\\n        return (p.val==q.val) && isMirror(p.left,q.right) && isMirror(p.right,q.left);\\n    }",
                "solutionTags": [],
                "code": "     public boolean isSymmetric(TreeNode root) {\\n        if(root==null) return true;\\n        return isMirror(root.left,root.right);\\n    }\\n    public boolean isMirror(TreeNode p, TreeNode q) {\\n        if(p==null && q==null) return true;\\n        if(p==null || q==null) return false;\\n        return (p.val==q.val) && isMirror(p.left,q.right) && isMirror(p.right,q.left);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3290112,
                "title": "easy-solutions-in-java-python-and-c-look-at-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n To check if a binary tree is symmetric, we need to compare its left subtree and right subtree. To do this, we can traverse the tree recursively and compare the left and right subtrees at each level. If they are symmetric, we continue the traversal. Otherwise, we can immediately return false.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can define a recursive helper function that takes two nodes as input, one from the left subtree and one from the right subtree. The helper function returns true if both nodes are null, or if their values are equal and their subtrees are symmetric.\\n\\n\\n# Complexity\\n- Time complexity:The time complexity of the algorithm is $$O(n)$$, where n is the number of nodes in the binary tree. We need to visit each node once to check if the tree is symmetric.\\n- Space complexity:\\nThe space complexity of the algorithm is $$O(h)$$, where h is the height of the binary tree. In the worst case, the tree can be completely unbalanced, and the recursion stack can go as deep as the height of the tree.\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n# Code\\n``` Java []\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        if (root == null) {\\n            return true;\\n        }\\n        return isMirror(root.left, root.right);\\n    }\\n    \\n    private boolean isMirror(TreeNode node1, TreeNode node2) {\\n        if (node1 == null && node2 == null) {\\n            return true;\\n        }\\n        if (node1 == null || node2 == null) {\\n            return false;\\n        }\\n        return node1.val == node2.val && isMirror(node1.left, node2.right) && isMirror(node1.right, node2.left);\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution(object):\\n    def isMirror(self, left, right):\\n        if not left and not right:\\n            return True\\n        if not left or not right:\\n            return False\\n        return left.val == right.val and self.isMirror(left.left, right.right) and self.isMirror(left.right, right.left)\\n    \\n    def isSymmetric(self, root):\\n        if not root:\\n            return True\\n        return self.isMirror(root.left, root.right)\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isMirror(TreeNode* left, TreeNode* right) {\\n    if (!left && !right) return true;\\n    if (!left || !right) return false;\\n    return (left->val == right->val) && isMirror(left->left, right->right) && isMirror(left->right, right->left);\\n}\\n\\nbool isSymmetric(TreeNode* root) {\\n    if (!root) return true;\\n    return isMirror(root->left, root->right);\\n}\\n\\n};\\n\\n\\n```\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n``` Java []\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        if (root == null) {\\n            return true;\\n        }\\n        return isMirror(root.left, root.right);\\n    }\\n    \\n    private boolean isMirror(TreeNode node1, TreeNode node2) {\\n        if (node1 == null && node2 == null) {\\n            return true;\\n        }\\n        if (node1 == null || node2 == null) {\\n            return false;\\n        }\\n        return node1.val == node2.val && isMirror(node1.left, node2.right) && isMirror(node1.right, node2.left);\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution(object):\\n    def isMirror(self, left, right):\\n        if not left and not right:\\n            return True\\n        if not left or not right:\\n            return False\\n        return left.val == right.val and self.isMirror(left.left, right.right) and self.isMirror(left.right, right.left)\\n    \\n    def isSymmetric(self, root):\\n        if not root:\\n            return True\\n        return self.isMirror(root.left, root.right)\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool isMirror(TreeNode* left, TreeNode* right) {\\n    if (!left && !right) return true;\\n    if (!left || !right) return false;\\n    return (left->val == right->val) && isMirror(left->left, right->right) && isMirror(left->right, right->left);\\n}\\n\\nbool isSymmetric(TreeNode* root) {\\n    if (!root) return true;\\n    return isMirror(root->left, root->right);\\n}\\n\\n};\\n\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 33089,
                "title": "my-c-accepted-code-in-16ms-with-iteration-solution",
                "content": "    /**\\n     * Definition for binary tree\\n     * struct TreeNode {\\n     *     int val;\\n     *     TreeNode *left;\\n     *     TreeNode *right;\\n     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n        bool isSymmetric(TreeNode *root) {\\n            TreeNode *left, *right;\\n            if (!root)\\n                return true;\\n            \\n            queue<TreeNode*> q1, q2;\\n            q1.push(root->left);\\n            q2.push(root->right);\\n            while (!q1.empty() && !q2.empty()){\\n                left = q1.front();\\n                q1.pop();\\n                right = q2.front();\\n                q2.pop();\\n                if (NULL == left && NULL == right)\\n                    continue;\\n                if (NULL == left || NULL == right)\\n                    return false;\\n                if (left->val != right->val)\\n                    return false;\\n                q1.push(left->left);\\n                q1.push(left->right);\\n                q2.push(right->right);\\n                q2.push(right->left);\\n            }\\n            return true;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isSymmetric(TreeNode *root) {\\n            TreeNode *left, *right;\\n            if (!root)\\n                return true;\\n            \\n            queue<TreeNode*> q1, q2;\\n            q1.push(root->left);\\n            q2.push(root->right);\\n            while (!q1.empty() && !q2.empty()){\\n                left = q1.front();\\n                q1.pop();\\n                right = q2.front();\\n                q2.pop();\\n                if (NULL == left && NULL == right)\\n                    continue;\\n                if (NULL == left || NULL == right)\\n                    return false;\\n                if (left->val != right->val)\\n                    return false;\\n                q1.push(left->left);\\n                q1.push(left->right);\\n                q2.push(right->right);\\n                q2.push(right->left);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 33056,
                "title": "15-lines-of-c-solution-8-ms",
                "content": "    bool isSymmetric(TreeNode *root) {\\n            if (!root) return true;\\n            return helper(root->left, root->right);\\n        }\\n        \\n        bool helper(TreeNode* p, TreeNode* q) {\\n            if (!p && !q) {\\n                return true;\\n            } else if (!p || !q) {\\n                return false;\\n            }\\n            \\n            if (p->val != q->val) {\\n                return false;\\n            }\\n            \\n            return helper(p->left,q->right) && helper(p->right, q->left); \\n        }",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "    bool isSymmetric(TreeNode *root) {\\n            if (!root) return true;\\n            return helper(root->left, root->right);\\n        }\\n        \\n        bool helper(TreeNode* p, TreeNode* q) {\\n            if (!p && !q) {\\n                return true;\\n            } else if (!p || !q) {\\n                return false;\\n            }\\n            \\n            if (p->val != q->val) {\\n                return false;\\n            }\\n            \\n            return helper(p->left,q->right) && helper(p->right, q->left); \\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1064732,
                "title": "c-easy-solution-with-comments-0ms-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        \\n        if(root==NULL) return true; //Tree is empty\\n        \\n        return isSymmetricTest(root->left,root->right);\\n    }\\n    \\n    bool isSymmetricTest(TreeNode* p , TreeNode* q){\\n        if(p == NULL && q == NULL) //left & right node is NULL \\n            return true; \\n        \\n        else if(p == NULL || q == NULL) //one of them is Not NULL\\n            return false; \\n        \\n        else if(p->val!=q->val) \\n            return false;\\n        \\n        return isSymmetricTest(p->left,q->right) && isSymmetricTest(p->right,q->left); //comparing left subtree\\'s left child with right subtree\\'s right child --AND-- comparing left subtree\\'s right child with right subtree\\'s left child\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        \\n        if(root==NULL) return true; //Tree is empty\\n        \\n        return isSymmetricTest(root->left,root->right);\\n    }\\n    \\n    bool isSymmetricTest(TreeNode* p , TreeNode* q){\\n        if(p == NULL && q == NULL) //left & right node is NULL \\n            return true; \\n        \\n        else if(p == NULL || q == NULL) //one of them is Not NULL\\n            return false; \\n        \\n        else if(p->val!=q->val) \\n            return false;\\n        \\n        return isSymmetricTest(p->left,q->right) && isSymmetricTest(p->right,q->left); //comparing left subtree\\'s left child with right subtree\\'s right child --AND-- comparing left subtree\\'s right child with right subtree\\'s left child\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 33068,
                "title": "6line-ac-python",
                "content": "\\n\\n\\n        def isSymmetric(self, root):\\n            def isSym(L,R):\\n                if not L and not R: return True\\n                if L and R and L.val == R.val: \\n                    return isSym(L.left, R.right) and isSym(L.right, R.left)\\n                return False\\n            return isSym(root, root)",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n\\n\\n        def isSymmetric(self, root):\\n            def isSym(L,R):\\n                if not L and not R: return True\\n                if L and R and L.val == R.val: \\n                    return isSym(L.left, R.right) and isSym(L.right, R.left)\\n                return False\\n            return isSym(root, root)",
                "codeTag": "Python3"
            },
            {
                "id": 3094040,
                "title": "easiest-beginner-friendly-sol-with-diagram-dfs-o-n-time-and-o-h-space",
                "content": "**For Iterative approach please find below link :**\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3290155/day-72-with-diagram-iterative-and-recursive-easiest-beginner-friendly-sol/\\n# Intuition\\nWe need to validate only 3 conditions including base condition and recursively call to the function:\\n- If both \"leftRoot\" and \"rightRoot\" are null, return true\\n- If only one of \"leftRoot\" or \"rightRoot\" is null, return false\\n- If \"leftRoot\" and \"rightRoot\" are not null and their values are not equal, return false\\n- If \"leftRoot\" and \"rightRoot\" are not null and their values are equal, recursively call \"isTreeSymmetric\" on the left child of \"leftRoot\" and the right child of \"rightRoot\", and the right child of \"leftRoot\" and the left child of \"rightRoot\"\\n\\n![WhatsApp Image 2023-01-24 at 6.54.24 PM.jpeg](https://assets.leetcode.com/users/images/3ce67a24-c51f-4cff-a5ac-58425726b650_1674566690.8242106.jpeg)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Define a function \"isTreeSymmetric\" that takes in two TreeNode pointers as inputs, \"leftRoot\" and \"rightRoot\"\\n2. If both \"leftRoot\" and \"rightRoot\" are null, return true\\n3. If only one of \"leftRoot\" or \"rightRoot\" is null, return false\\n4. If \"leftRoot\" and \"rightRoot\" are not null and their values are not equal, return false\\n5. If \"leftRoot\" and \"rightRoot\" are not null and their values are equal, recursively call \"isTreeSymmetric\" on the left child of \"leftRoot\" and the right child of \"rightRoot\", and the right child of \"leftRoot\" and the left child of \"rightRoot\"\\n6. Return true if both recursive calls return true, else return false\\n7. Define a function \"isSymmetric\" that takes in a TreeNode pointer \"root\" as input\\n8. Call \"isTreeSymmetric\" on the left child of \"root\" and the right child of \"root\" and return the result\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isTreeSymmetric(TreeNode* leftRoot, TreeNode* rightRoot){\\n        if(leftRoot == nullptr && rightRoot == nullptr)\\n            return true;\\n        if((leftRoot == nullptr && rightRoot != nullptr)  || (leftRoot != nullptr && rightRoot == nullptr))\\n            return false;\\n        if(leftRoot -> val != rightRoot -> val)\\n            return false;\\n        return isTreeSymmetric(leftRoot -> left, rightRoot -> right) && isTreeSymmetric(leftRoot -> right, rightRoot -> left);\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        return isTreeSymmetric(root -> left, root -> right);\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean isTreeSymmetric(TreeNode leftRoot, TreeNode rightRoot){\\n        if(leftRoot == null && rightRoot == null)\\n            return true;\\n        if((leftRoot == null && rightRoot != null)  || (leftRoot != null && rightRoot == null))\\n            return false;\\n        if(leftRoot.val != rightRoot.val)\\n            return false;\\n        return isTreeSymmetric(leftRoot.left, rightRoot.right) && isTreeSymmetric(leftRoot.right, rightRoot.left);\\n    }\\n    public boolean isSymmetric(TreeNode root) {\\n        return isTreeSymmetric(root.left, root.right);\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def isTreeSymmetric(self, leftRoot, rightRoot):\\n        if leftRoot is None and rightRoot is None:\\n            return True\\n        if (leftRoot is None and rightRoot is not None) or (leftRoot is not None and rightRoot is None):\\n            return False\\n        if leftRoot.val != rightRoot.val:\\n            return False\\n        return self.isTreeSymmetric(leftRoot.left, rightRoot.right) and self.isTreeSymmetric(leftRoot.right, rightRoot.left)\\n    def isSymmetric(self, root):\\n        return self.isTreeSymmetric(root.left, root.right)\\n\\n```\\n\\n# Complexity\\n- Time complexity: **O(n)**, where n is the total number of nodes in the binary tree. This is because the solution visits each node once and compares its values with the corresponding symmetric node, thus the function isTreeSymmetric() is called on each node at most once. The time complexity of the isTreeSymmetric() function is O(n/2) because it only visits half of the nodes (in the best case when the tree is symmetric) and in the worst case it visits all nodes in the tree (when the tree is not symmetric).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(h)**, where h is the height of the binary tree. This is because the recursive calls made by the solution consume memory on the call stack equal to the height of the tree. In the worst case when the binary tree is linear, the height of the tree is equal to n, thus the space complexity becomes O(n). However, in the best case when the binary tree is perfectly balanced, the height of the tree is log(n), thus the space complexity becomes O(log(n)).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isTreeSymmetric(TreeNode* leftRoot, TreeNode* rightRoot){\\n        if(leftRoot == nullptr && rightRoot == nullptr)\\n            return true;\\n        if((leftRoot == nullptr && rightRoot != nullptr)  || (leftRoot != nullptr && rightRoot == nullptr))\\n            return false;\\n        if(leftRoot -> val != rightRoot -> val)\\n            return false;\\n        return isTreeSymmetric(leftRoot -> left, rightRoot -> right) && isTreeSymmetric(leftRoot -> right, rightRoot -> left);\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        return isTreeSymmetric(root -> left, root -> right);\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean isTreeSymmetric(TreeNode leftRoot, TreeNode rightRoot){\\n        if(leftRoot == null && rightRoot == null)\\n            return true;\\n        if((leftRoot == null && rightRoot != null)  || (leftRoot != null && rightRoot == null))\\n            return false;\\n        if(leftRoot.val != rightRoot.val)\\n            return false;\\n        return isTreeSymmetric(leftRoot.left, rightRoot.right) && isTreeSymmetric(leftRoot.right, rightRoot.left);\\n    }\\n    public boolean isSymmetric(TreeNode root) {\\n        return isTreeSymmetric(root.left, root.right);\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def isTreeSymmetric(self, leftRoot, rightRoot):\\n        if leftRoot is None and rightRoot is None:\\n            return True\\n        if (leftRoot is None and rightRoot is not None) or (leftRoot is not None and rightRoot is None):\\n            return False\\n        if leftRoot.val != rightRoot.val:\\n            return False\\n        return self.isTreeSymmetric(leftRoot.left, rightRoot.right) and self.isTreeSymmetric(leftRoot.right, rightRoot.left)\\n    def isSymmetric(self, root):\\n        return self.isTreeSymmetric(root.left, root.right)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 33325,
                "title": "python-short-recursive-and-iterative-solutions",
                "content": "\\n    def isSymmetric(self, root):\\n        if not root:\\n            return True\\n        return self.dfs(root.left, root.right)\\n        \\n    def dfs(self, l, r):\\n        if l and r:\\n            return l.val == r.val and self.dfs(l.left, r.right) and self.dfs(l.right, r.left)\\n        return l == r\\n\\t\\t\\n\\tdef isSymmetric(self, root):\\n        if not root:\\n            return True\\n        stack = [(root.left, root.right)]\\n        while stack:\\n            l, r = stack.pop()\\n            if not l and not r:\\n                continue\\n            if not l or not r or (l.val != r.val):\\n                return False\\n            stack.append((l.left, r.right))\\n            stack.append((l.right, r.left))\\n        return True",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "\\n    def isSymmetric(self, root):\\n        if not root:\\n            return True\\n        return self.dfs(root.left, root.right)\\n        \\n    def dfs(self, l, r):\\n        if l and r:\\n            return l.val == r.val and self.dfs(l.left, r.right) and self.dfs(l.right, r.left)\\n        return l == r\\n\\t\\t\\n\\tdef isSymmetric(self, root):\\n        if not root:\\n            return True\\n        stack = [(root.left, root.right)]\\n        while stack:\\n            l, r = stack.pop()\\n            if not l and not r:\\n                continue\\n            if not l or not r or (l.val != r.val):\\n                return False\\n            stack.append((l.left, r.right))\\n            stack.append((l.right, r.left))\\n        return True",
                "codeTag": "Python3"
            },
            {
                "id": 33152,
                "title": "short-and-clean-java-iterative-solution",
                "content": "     public boolean isSymmetric(TreeNode root) {\\n            Queue<TreeNode> q = new LinkedList<TreeNode>();\\n            if(root == null) return true;\\n            q.add(root.left);\\n            q.add(root.right);\\n            while(q.size() > 1){\\n                TreeNode left = q.poll(),\\n                         right = q.poll();\\n                if(left== null&& right == null) continue;\\n                if(left == null ^ right == null) return false;\\n                if(left.val != right.val) return false;\\n                q.add(left.left);\\n                q.add(right.right);\\n                q.add(left.right);\\n                q.add(right.left);            \\n            }\\n            return true;\\n        }",
                "solutionTags": [],
                "code": "     public boolean isSymmetric(TreeNode root) {\\n            Queue<TreeNode> q = new LinkedList<TreeNode>();\\n            if(root == null) return true;\\n            q.add(root.left);\\n            q.add(root.right);\\n            while(q.size() > 1){\\n                TreeNode left = q.poll(),\\n                         right = q.poll();\\n                if(left== null&& right == null) continue;\\n                if(left == null ^ right == null) return false;\\n                if(left.val != right.val) return false;\\n                q.add(left.left);\\n                q.add(right.right);\\n                q.add(left.right);\\n                q.add(right.left);            \\n            }\\n            return true;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 33073,
                "title": "javascript-recursive-and-iterative-solutions",
                "content": "The idea is to check whether the tree's left and right subtrees are mirroring each other, we can use preorder traversal:\\n```\\nvar isSymmetric = function(root) {\\n    if (!root) { // Sanity check\\n        return true;\\n    }\\n\\n    // Check if tree s & t are mirroring each other\\n    function isMirror(s, t) {\\n        if (!s && !t) {\\n            return true; // Both nodes are null, ok\\n        }\\n        if (!s || !t || s.val !== t.val) {\\n            return false; // Found a mismatch\\n        }\\n        // Compare the left subtree of `s` with the right subtree of `t`\\n        // and the right subtree of `s` with the left subtree of `t`\\n        return isMirror(s.left, t.right) && isMirror(s.right, t.left);\\n    }\\n\\n    return isMirror(root.left, root.right);\\n};\\n```\\nAs it's preorder DFS, time complexity is `O(n)`, and space complexity is `O(1)` if we ignore the recursion stack which is the height of the tree.\\n\\nThe question asks us to implement the solution iteratively, and it's easy to convert the above preorder to make it traverse iteratively using stack:\\n```\\nfunction isMirror(p, q) {\\n    // Create two stacks\\n    var s1 = [p], s2 = [q];\\n\\n    // Perform preorder traversal\\n    while (s1.length > 0 || s2.length > 0) {\\n        var n1 = s1.pop(), n2 = s2.pop();\\n\\n        // Two null nodes, let's continue\\n        if (!n1 && !n2) continue;\\n\\n        // Return false as long as there is a mismatch\\n        if (!n1 || !n2 || n1.val !== n2.val) return false;\\n\\n        // Scan tree s from left to right\\n        // and scan tree t from right to left\\n        s1.push(n1.left); s1.push(n1.right);\\n        s2.push(n2.right); s2.push(n2.left);\\n    }\\n\\n    return true;\\n}\\n```\\nTime complexity is still `O(n)`, and space complexity is the height of the tree.\\n\\nAnother solution is to use BFS, we just need to traverse both subtrees in level order, one from left to right, and the other is right to left, let's modify the above `isMirror` function to the following:\\n```\\nfunction isMirror(s, t) {\\n    var q1 = [s], q2 = [t];\\n\\n    // Perform breadth-first search\\n    while (q1.length > 0 || q2.length > 0) {\\n        // Dequeue\\n        var n1 = q1.shift(), n2 = q2.shift();\\n\\n        // Two null nodes, let's continue\\n        if (!n1 && !n2) continue;\\n\\n        // Return false as long as there is a mismatch\\n        if (!n1 || !n2 || n1.val !== n2.val) return false;\\n\\n        // Scan tree s from left to right\\n        // and scan tree t from right to left\\n        q1.push(n1.left); q1.push(n1.right);\\n        q2.push(n2.right); q2.push(n2.left);\\n    }\\n\\n    return true;\\n}\\n```\\nTime complexity is `O(n)` and space complexity is the width of the tree.",
                "solutionTags": [],
                "code": "```\\nvar isSymmetric = function(root) {\\n    if (!root) { // Sanity check\\n        return true;\\n    }\\n\\n    // Check if tree s & t are mirroring each other\\n    function isMirror(s, t) {\\n        if (!s && !t) {\\n            return true; // Both nodes are null, ok\\n        }\\n        if (!s || !t || s.val !== t.val) {\\n            return false; // Found a mismatch\\n        }\\n        // Compare the left subtree of `s` with the right subtree of `t`\\n        // and the right subtree of `s` with the left subtree of `t`\\n        return isMirror(s.left, t.right) && isMirror(s.right, t.left);\\n    }\\n\\n    return isMirror(root.left, root.right);\\n};\\n```\n```\\nfunction isMirror(p, q) {\\n    // Create two stacks\\n    var s1 = [p], s2 = [q];\\n\\n    // Perform preorder traversal\\n    while (s1.length > 0 || s2.length > 0) {\\n        var n1 = s1.pop(), n2 = s2.pop();\\n\\n        // Two null nodes, let's continue\\n        if (!n1 && !n2) continue;\\n\\n        // Return false as long as there is a mismatch\\n        if (!n1 || !n2 || n1.val !== n2.val) return false;\\n\\n        // Scan tree s from left to right\\n        // and scan tree t from right to left\\n        s1.push(n1.left); s1.push(n1.right);\\n        s2.push(n2.right); s2.push(n2.left);\\n    }\\n\\n    return true;\\n}\\n```\n```\\nfunction isMirror(s, t) {\\n    var q1 = [s], q2 = [t];\\n\\n    // Perform breadth-first search\\n    while (q1.length > 0 || q2.length > 0) {\\n        // Dequeue\\n        var n1 = q1.shift(), n2 = q2.shift();\\n\\n        // Two null nodes, let's continue\\n        if (!n1 && !n2) continue;\\n\\n        // Return false as long as there is a mismatch\\n        if (!n1 || !n2 || n1.val !== n2.val) return false;\\n\\n        // Scan tree s from left to right\\n        // and scan tree t from right to left\\n        q1.push(n1.left); q1.push(n1.right);\\n        q2.push(n2.right); q2.push(n2.left);\\n    }\\n\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2423766,
                "title": "easy-0-ms-100-fully-explained-java-c-python-js-python3",
                "content": "# **Java Solution:**\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Symmetric Tree.\\n```\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        // Soecial case...\\n        if (root == null)\\n\\t\\t    return true;\\n        // call the function  recursively...\\n\\t    return isSymmetric(root.left, root.right);\\n    }\\n    // After division the tree will be divided in two parts...\\n    // The root of the left part is rootleft & the root of the right part is rootright...\\n    public boolean isSymmetric(TreeNode rootleft, TreeNode rootright) {\\n        // If root of the left part & the root of the right part is same, return true...\\n\\t    if (rootleft == null && rootright == null) {\\n\\t\\t    return true;\\n\\t    }\\n        // If root of any part is null, then the binary tree is not symmetric. So return false...\\n        else if (rootright == null || rootleft == null) {\\n\\t\\t    return false;\\n\\t    }\\n        // If the value of the root of the left part is not equal to the value of the root of the right part...\\n        if (rootleft.val != rootright.val)\\n\\t\\t    return false;\\n        // In case of not symmetric...\\n        if (!isSymmetric(rootleft.left, rootright.right))\\n\\t\\t    return false;\\n\\t    if (!isSymmetric(rootleft.right, rootright.left))\\n\\t\\t    return false;\\n        // Otherwise, return true...\\n        return true;\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        // Special case...\\n        if(root == nullptr) return true;\\n        // Return the function recursively...\\n        return isSymmetric(root->left,root->right);\\n    }\\n    // A tree is called symmetric if the left subtree must be a mirror reflection of the right subtree...\\n    bool isSymmetric(TreeNode* leftroot,TreeNode* rightroot){\\n        // If both root nodes are null pointers, return true...\\n        if(!leftroot && !rightroot)  return true;\\n        // If exactly one of them is a null node, return false...\\n        if(!leftroot || !rightroot)  return false;\\n        // If root nodes haven\\'t same value, return false...\\n        if(leftroot->val != rightroot->val)  return false;\\n        // Return true if the values of root nodes are same and left as well as right subtrees are symmetric...\\n        return isSymmetric(leftroot->left, rightroot->right) && isSymmetric(leftroot->right, rightroot->left);\\n    }\\n};\\n```\\n\\n# **Python Solution:**\\n```\\nclass Solution(object):\\n    def isSymmetric(self, root):\\n        # Special case...\\n        if not root:\\n            return true;\\n        # Return the function recursively...\\n        return self.isSame(root.left, root.right)\\n    # A tree is called symmetric if the left subtree must be a mirror reflection of the right subtree...\\n    def isSame(self, leftroot, rightroot):\\n        # If both root nodes are null pointers, return true...\\n        if leftroot == None and rightroot == None:\\n            return True\\n        # If exactly one of them is a null node, return false...\\n        if leftroot == None or rightroot == None:\\n            return False\\n        # If root nodes haven\\'t same value, return false...\\n        if leftroot.val != rightroot.val:\\n            return False\\n        # Return true if the values of root nodes are same and left as well as right subtrees are symmetric...\\n        return self.isSame(leftroot.left, rightroot.right) and self.isSame(leftroot.right, rightroot.left)\\n```\\n            \\n# **JavaScript Solution:**\\nRuntime: 66 ms, faster than 97.80% of JavaScript online submissions for Symmetric Tree.\\n```\\nvar isSymmetric = function(root) {\\n    // Special case...\\n    if (!root)\\n        return true;\\n    // Return the function recursively...\\n    return isSame(root.left, root.right);\\n};\\n// A tree is called symmetric if the left subtree must be a mirror reflection of the right subtree...\\nvar isSame = function (leftroot, rightroot) {\\n    // If both root nodes are null pointers, return true...\\n    // If exactly one of them is a null node, return false...\\n    // If root nodes haven\\'t same value, return false...\\n    if ((!leftroot && rightroot) || (leftroot && !rightroot) || (leftroot && rightroot && leftroot.val !== rightroot.val))\\n        return false;\\n    // Return true if the values of root nodes are same and left as well as right subtrees are symmetric...\\n    if (leftroot && rightroot)\\n        return isSame(leftroot.left, rightroot.right) && isSame(leftroot.right, rightroot.left);\\n    return true;\\n};\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        # Special case...\\n        if not root:\\n            return true;\\n        # Return the function recursively...\\n        return self.isSame(root.left, root.right)\\n    # A tree is called symmetric if the left subtree must be a mirror reflection of the right subtree...\\n    def isSame(self, leftroot, rightroot):\\n        # If both root nodes are null pointers, return true...\\n        if leftroot == None and rightroot == None:\\n            return True\\n        # If exactly one of them is a null node, return false...\\n        if leftroot == None or rightroot == None:\\n            return False\\n        # If root nodes haven\\'t same value, return false...\\n        if leftroot.val != rightroot.val:\\n            return False\\n        # Return true if the values of root nodes are same and left as well as right subtrees are symmetric...\\n        return self.isSame(leftroot.left, rightroot.right) and self.isSame(leftroot.right, rightroot.left)\\n```\\n**I am working hard for you guys...\\nPlease upvote if you find any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        // Soecial case...\\n        if (root == null)\\n\\t\\t    return true;\\n        // call the function  recursively...\\n\\t    return isSymmetric(root.left, root.right);\\n    }\\n    // After division the tree will be divided in two parts...\\n    // The root of the left part is rootleft & the root of the right part is rootright...\\n    public boolean isSymmetric(TreeNode rootleft, TreeNode rootright) {\\n        // If root of the left part & the root of the right part is same, return true...\\n\\t    if (rootleft == null && rootright == null) {\\n\\t\\t    return true;\\n\\t    }\\n        // If root of any part is null, then the binary tree is not symmetric. So return false...\\n        else if (rootright == null || rootleft == null) {\\n\\t\\t    return false;\\n\\t    }\\n        // If the value of the root of the left part is not equal to the value of the root of the right part...\\n        if (rootleft.val != rootright.val)\\n\\t\\t    return false;\\n        // In case of not symmetric...\\n        if (!isSymmetric(rootleft.left, rootright.right))\\n\\t\\t    return false;\\n\\t    if (!isSymmetric(rootleft.right, rootright.left))\\n\\t\\t    return false;\\n        // Otherwise, return true...\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        // Special case...\\n        if(root == nullptr) return true;\\n        // Return the function recursively...\\n        return isSymmetric(root->left,root->right);\\n    }\\n    // A tree is called symmetric if the left subtree must be a mirror reflection of the right subtree...\\n    bool isSymmetric(TreeNode* leftroot,TreeNode* rightroot){\\n        // If both root nodes are null pointers, return true...\\n        if(!leftroot && !rightroot)  return true;\\n        // If exactly one of them is a null node, return false...\\n        if(!leftroot || !rightroot)  return false;\\n        // If root nodes haven\\'t same value, return false...\\n        if(leftroot->val != rightroot->val)  return false;\\n        // Return true if the values of root nodes are same and left as well as right subtrees are symmetric...\\n        return isSymmetric(leftroot->left, rightroot->right) && isSymmetric(leftroot->right, rightroot->left);\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def isSymmetric(self, root):\\n        # Special case...\\n        if not root:\\n            return true;\\n        # Return the function recursively...\\n        return self.isSame(root.left, root.right)\\n    # A tree is called symmetric if the left subtree must be a mirror reflection of the right subtree...\\n    def isSame(self, leftroot, rightroot):\\n        # If both root nodes are null pointers, return true...\\n        if leftroot == None and rightroot == None:\\n            return True\\n        # If exactly one of them is a null node, return false...\\n        if leftroot == None or rightroot == None:\\n            return False\\n        # If root nodes haven\\'t same value, return false...\\n        if leftroot.val != rightroot.val:\\n            return False\\n        # Return true if the values of root nodes are same and left as well as right subtrees are symmetric...\\n        return self.isSame(leftroot.left, rightroot.right) and self.isSame(leftroot.right, rightroot.left)\\n```\n```\\nvar isSymmetric = function(root) {\\n    // Special case...\\n    if (!root)\\n        return true;\\n    // Return the function recursively...\\n    return isSame(root.left, root.right);\\n};\\n// A tree is called symmetric if the left subtree must be a mirror reflection of the right subtree...\\nvar isSame = function (leftroot, rightroot) {\\n    // If both root nodes are null pointers, return true...\\n    // If exactly one of them is a null node, return false...\\n    // If root nodes haven\\'t same value, return false...\\n    if ((!leftroot && rightroot) || (leftroot && !rightroot) || (leftroot && rightroot && leftroot.val !== rightroot.val))\\n        return false;\\n    // Return true if the values of root nodes are same and left as well as right subtrees are symmetric...\\n    if (leftroot && rightroot)\\n        return isSame(leftroot.left, rightroot.right) && isSame(leftroot.right, rightroot.left);\\n    return true;\\n};\\n```\n```\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        # Special case...\\n        if not root:\\n            return true;\\n        # Return the function recursively...\\n        return self.isSame(root.left, root.right)\\n    # A tree is called symmetric if the left subtree must be a mirror reflection of the right subtree...\\n    def isSame(self, leftroot, rightroot):\\n        # If both root nodes are null pointers, return true...\\n        if leftroot == None and rightroot == None:\\n            return True\\n        # If exactly one of them is a null node, return false...\\n        if leftroot == None or rightroot == None:\\n            return False\\n        # If root nodes haven\\'t same value, return false...\\n        if leftroot.val != rightroot.val:\\n            return False\\n        # Return true if the values of root nodes are same and left as well as right subtrees are symmetric...\\n        return self.isSame(leftroot.left, rightroot.right) and self.isSame(leftroot.right, rightroot.left)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290198,
                "title": "image-explanation-recursive-non-recursive-complete-intuition",
                "content": "# Video Solution\\nhttps://youtu.be/41j4iR4Gx9s\\n\\n# Approach & Intuition\\n![image.png](https://assets.leetcode.com/users/images/a0ec0746-4ddd-4dec-adbd-d540f823e889_1678669824.4317465.png)\\n![image.png](https://assets.leetcode.com/users/images/a7825991-e7bf-44b1-ba38-c68853372580_1678669848.2439427.png)\\n![image.png](https://assets.leetcode.com/users/images/7065f13f-bb82-4066-983e-cba9fc6239ab_1678669858.1537697.png)\\n![image.png](https://assets.leetcode.com/users/images/c86dff88-7545-47af-a3ee-214e784692ff_1678669864.8307462.png)\\n![image.png](https://assets.leetcode.com/users/images/8f319a20-de8c-496c-9b8b-a0594c51114e_1678669872.3450804.png)\\n![image.png](https://assets.leetcode.com/users/images/a1a5be50-9390-4d6a-9019-08f2eb5dae6f_1678669881.0141463.png)\\n![image.png](https://assets.leetcode.com/users/images/401aedaf-4111-4649-81c8-16282f60662a_1678669890.8298717.png)\\n![image.png](https://assets.leetcode.com/users/images/a2194d4e-58e3-45ec-9f0b-79968f851827_1678669898.3149576.png)\\n![image.png](https://assets.leetcode.com/users/images/01d99578-7858-415f-9e4f-931f458bf59c_1678669906.1509514.png)\\n![image.png](https://assets.leetcode.com/users/images/da50d440-dc6b-4c47-a46e-b4a5376151b3_1678669914.0028672.png)\\n\\n\\n# Recursive Code\\n```\\nclass Solution {\\npublic:\\n    bool isSymmetricHelper(TreeNode* leftNode, TreeNode* rightNode){\\n        if(leftNode==NULL && rightNode==NULL) return true;\\n        if(leftNode==NULL || rightNode==NULL || leftNode->val != rightNode->val) return false;\\n        \\n        return isSymmetricHelper(leftNode->left, rightNode->right) && isSymmetricHelper(leftNode->right, rightNode->left);\\n    }\\n\\n    bool isSymmetric(TreeNode* root) {\\n        if(root == NULL) return true;\\n        return isSymmetricHelper(root->left, root->right);\\n    }\\n};\\n```\\n\\n# Non-Recursive Code\\n```\\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        if(root == NULL) return true;\\n\\n        queue<TreeNode*> q;\\n        q.push(root->left);\\n        q.push(root->right);\\n        while(!q.empty()){\\n            TreeNode* leftNode = q.front();\\n            q.pop();\\n            TreeNode* rightNode = q.front();\\n            q.pop();\\n\\n            if(leftNode==NULL && rightNode==NULL) continue;\\n            if(leftNode==NULL || rightNode==NULL || leftNode->val != rightNode->val) return false;\\n            q.push(leftNode->left);\\n            q.push(rightNode->right);\\n            q.push(leftNode->right);\\n            q.push(rightNode->left);\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSymmetricHelper(TreeNode* leftNode, TreeNode* rightNode){\\n        if(leftNode==NULL && rightNode==NULL) return true;\\n        if(leftNode==NULL || rightNode==NULL || leftNode->val != rightNode->val) return false;\\n        \\n        return isSymmetricHelper(leftNode->left, rightNode->right) && isSymmetricHelper(leftNode->right, rightNode->left);\\n    }\\n\\n    bool isSymmetric(TreeNode* root) {\\n        if(root == NULL) return true;\\n        return isSymmetricHelper(root->left, root->right);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        if(root == NULL) return true;\\n\\n        queue<TreeNode*> q;\\n        q.push(root->left);\\n        q.push(root->right);\\n        while(!q.empty()){\\n            TreeNode* leftNode = q.front();\\n            q.pop();\\n            TreeNode* rightNode = q.front();\\n            q.pop();\\n\\n            if(leftNode==NULL && rightNode==NULL) continue;\\n            if(leftNode==NULL || rightNode==NULL || leftNode->val != rightNode->val) return false;\\n            q.push(leftNode->left);\\n            q.push(rightNode->right);\\n            q.push(leftNode->right);\\n            q.push(rightNode->left);\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 433170,
                "title": "ismirror-dfs-recursion-one-two-stacks-bfs-queue-solution-in-java",
                "content": "Reference: [LeetCode](https://leetcode.com/problems/symmetric-tree/) <span class=\"gray\">EPI 9.2</span>\\nDifficulty: <span class=\"green\">Easy</span>\\n\\n## Problem\\n\\n> Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).\\n\\n**Example:** \\n\\n`[1,2,2,3,4,4,3]` is symmetric:\\n\\n```java\\n    1\\n   / \\\\\\n  2   2\\n / \\\\ / \\\\\\n3  4 4  3\\n```\\n\\nBut the following `[1,2,2,null,3,null,3]` is not:\\n\\n```java\\n    1\\n   / \\\\\\n  2   2\\n   \\\\   \\\\\\n   3    3\\n```\\n\\n**Follow up:** Bonus points if you could solve it both `recursively` and `iteratively`.\\n\\n\\n\\n\\n## Analysis\\n\\n**Idea:** A tree is symmetric if it is a `mirror reflection` of itself.\\n\\n**Note:** Distinguish the concept of `symmetric` (one tree) and `mirror reflection` (two trees).\\n\\n```java\\n    1\\n   / \\\\\\n  2   2       t1 & t2\\n / \\\\ / \\\\\\n3  4 4  3\\n|  | |  |\\n---|-|----->  isMirror(t1.left, t2.right)\\n   | |      \\n   -------->  isMirror(t1.right, t2.left)\\n```\\n\\nThe question is when are two trees a mirror reflection of each other? **Three conditions:**\\n\\n- Their two roots have the same value.\\n- The right subtree `t1.right` of each tree `t1` is a mirror reflection of the left subtree `t2.left` of the other tree `t2`.\\n- The left subtree `t1.left` of each tree `t1` is a mirror reflection of the right subtree `t2.right` of the other tree `t2`.\\n\\n**Bad Idea (the wrong direction):**\\n\\nA tree is symmetric if its left subtree is symmetric and its right subtree is symmetric. Consider this case:\\n\\n```java\\n    1\\n   / \\\\\\n  2   2\\n / \\\\ / \\\\\\n3  4 4  3\\n```\\n\\nTwo subtrees of root are not symmetric, but the root is symmetric.\\n\\n\\nFrom EPI, swapping any subtrees of a tree and comparing with the original is also workable.\\n\\n\\n\\n### Recursion\\n\\nCome up with the recursive structure.\\n\\n```java\\npublic boolean isSymmetric(TreeNode root) {\\n  return isMirror(root, root);\\n}\\n\\nprivate boolean isMirror(TreeNode t1, TreeNode t2) {\\n  // base case\\n  if (t1 == null && t2 == null) return true;\\n  if (t1 == null || t2 == null) return false;\\n  // check values\\n  if (t1.val != t2.val) return false;\\n  // check left subtree and right subtree\\n  return isMirror(t1.right, t2.left) && isMirror(t1.left, t2.right);\\n}\\n```\\n\\n**Improvement:**\\n\\nActually, there is not too much improvement since it is bounded by a constant `2`.\\n\\n```java\\npublic boolean isSymmetric(TreeNode root) {\\n  if (root == null) { // required\\n    return true;\\n  }\\n  return isMirror(root.left, root.right); // so t1 and t2 are different trees\\n}\\n```\\n\\n**Time:** `O(N)` because we traverse the entire input tree once (`\\\\sim 2N`).\\n**Space:** `O(h)`\\n\\n\\n\\n\\n### Iteration (One/Two Stacks)\\n\\nUse two stacks to simulate the recursive method.\\n\\n**Note:** Null check => Value check\\n\\n```java\\npublic boolean isSymmetric(TreeNode root) {\\n  if (root == null) { // need checking because we use root\\'s value\\n    return true;\\n  }\\n  Stack<TreeNode> lStack = new Stack<>();\\n  Stack<TreeNode> rStack = new Stack<>();\\n  // Preorder-like traversal\\n  lStack.push(root.left); rStack.push(root.right);\\n  \\n  while (lStack.size() > 0 && rStack.size() > 0)  {\\n    TreeNode t1 = lStack.pop();\\n    TreeNode t2 = rStack.pop();\\n    // null check\\n    if (t1 == null && t2 == null) continue;\\n    if (t1 == null || t2 == null) return false;\\n    // value check\\n    if (t1.val != t2.val) return false;\\n    // push children\\n    lStack.push(t1.right); lStack.push(t1.left); // could be null\\n    rStack.push(t2.left);  rStack.push(t2.right);\\n  }\\n  // One of the stack might be empty\\n  return lStack.size() == 0 && rStack.size() == 0;\\n}\\n```\\n\\nOr just use one stack:\\n\\n- Be careful of the ordering of pushing.\\n\\n```java\\npublic boolean isSymmetric(TreeNode root) {\\n  if (root == null) {\\n    return true;\\n  }\\n  if (root.left == null && root.right == null) return true;\\n  if (root.left == null || root.right == null) return false;\\n  // children are not null\\n  Stack<TreeNode> stack = new Stack<>();\\n  stack.push(root.left);\\n  stack.push(root.right);\\n  \\n  while (stack.size() > 0) {\\n    TreeNode t1 = stack.pop();\\n    TreeNode t2 = stack.pop();\\n    // null check\\n    if (t1 == null && t2 == null) continue;\\n    if (t1 == null || t2 == null) return false;\\n    // value check\\n    if (t1.val != t2.val) return false;\\n    // push children\\n    stack.push(t1.right); stack.push(t2.left); // could be null\\n    stack.push(t1.left); stack.push(t2.right);\\n  }\\n  \\n  return true;\\n}\\n```\\n\\n\\n**Time:** `O(N)`\\n**Space:** `O(h)`\\n\\n\\n\\n\\n### Iteration (BFS)\\n\\nCompare nodes at each layer.\\n- Each two consecutive nodes in the queue should be equal.\\n- Each time, two nodes are extracted and their values are compared.\\n- Then their right and left children of the two nodes are enqueued in opposite order.\\n\\n```java\\n    1\\n   / \\\\\\n  2   2     queue: 2    2 (t1)\\n / \\\\ / \\\\\\n3  4 4  3   queue: 4    4    3    3\\n                           t2.r t1.l\\n```\\n\\n```java\\npublic boolean isSymmetric(TreeNode root) {\\n  if (root == null) {\\n    return true;\\n  }\\n  Queue<TreeNode> queue = new LinkedList<>();\\n  queue.offer(root.left);\\n  queue.offer(root.right);\\n\\n  while (queue.size() > 0) {\\n    TreeNode t1 = queue.poll();\\n    TreeNode t2 = queue.poll();\\n    // check\\n    if (t1 == null && t2 == null) continue;\\n    if (t1 == null || t2 == null) return false;\\n    if (t1.val != t2.val) return false;\\n    // offer children\\n    queue.offer(t1.left);\\n    queue.offer(t2.right);\\n\\n    queue.offer(t1.right);\\n    queue.offer(t2.left);\\n  }\\n  return true;\\n}\\n```\\n\\n\\n**Time:** `O(N)`\\n**Space:** `O(w)` where `w` is the maximum number nodes in a level of the tree.\\n\\n",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```java\\n    1\\n   / \\\\\\n  2   2\\n / \\\\ / \\\\\\n3  4 4  3\\n```\n```java\\n    1\\n   / \\\\\\n  2   2\\n   \\\\   \\\\\\n   3    3\\n```\n```java\\n    1\\n   / \\\\\\n  2   2       t1 & t2\\n / \\\\ / \\\\\\n3  4 4  3\\n|  | |  |\\n---|-|----->  isMirror(t1.left, t2.right)\\n   | |      \\n   -------->  isMirror(t1.right, t2.left)\\n```\n```java\\n    1\\n   / \\\\\\n  2   2\\n / \\\\ / \\\\\\n3  4 4  3\\n```\n```java\\npublic boolean isSymmetric(TreeNode root) {\\n  return isMirror(root, root);\\n}\\n\\nprivate boolean isMirror(TreeNode t1, TreeNode t2) {\\n  // base case\\n  if (t1 == null && t2 == null) return true;\\n  if (t1 == null || t2 == null) return false;\\n  // check values\\n  if (t1.val != t2.val) return false;\\n  // check left subtree and right subtree\\n  return isMirror(t1.right, t2.left) && isMirror(t1.left, t2.right);\\n}\\n```\n```java\\npublic boolean isSymmetric(TreeNode root) {\\n  if (root == null) { // required\\n    return true;\\n  }\\n  return isMirror(root.left, root.right); // so t1 and t2 are different trees\\n}\\n```\n```java\\npublic boolean isSymmetric(TreeNode root) {\\n  if (root == null) { // need checking because we use root\\'s value\\n    return true;\\n  }\\n  Stack<TreeNode> lStack = new Stack<>();\\n  Stack<TreeNode> rStack = new Stack<>();\\n  // Preorder-like traversal\\n  lStack.push(root.left); rStack.push(root.right);\\n  \\n  while (lStack.size() > 0 && rStack.size() > 0)  {\\n    TreeNode t1 = lStack.pop();\\n    TreeNode t2 = rStack.pop();\\n    // null check\\n    if (t1 == null && t2 == null) continue;\\n    if (t1 == null || t2 == null) return false;\\n    // value check\\n    if (t1.val != t2.val) return false;\\n    // push children\\n    lStack.push(t1.right); lStack.push(t1.left); // could be null\\n    rStack.push(t2.left);  rStack.push(t2.right);\\n  }\\n  // One of the stack might be empty\\n  return lStack.size() == 0 && rStack.size() == 0;\\n}\\n```\n```java\\npublic boolean isSymmetric(TreeNode root) {\\n  if (root == null) {\\n    return true;\\n  }\\n  if (root.left == null && root.right == null) return true;\\n  if (root.left == null || root.right == null) return false;\\n  // children are not null\\n  Stack<TreeNode> stack = new Stack<>();\\n  stack.push(root.left);\\n  stack.push(root.right);\\n  \\n  while (stack.size() > 0) {\\n    TreeNode t1 = stack.pop();\\n    TreeNode t2 = stack.pop();\\n    // null check\\n    if (t1 == null && t2 == null) continue;\\n    if (t1 == null || t2 == null) return false;\\n    // value check\\n    if (t1.val != t2.val) return false;\\n    // push children\\n    stack.push(t1.right); stack.push(t2.left); // could be null\\n    stack.push(t1.left); stack.push(t2.right);\\n  }\\n  \\n  return true;\\n}\\n```\n```java\\n    1\\n   / \\\\\\n  2   2     queue: 2    2 (t1)\\n / \\\\ / \\\\\\n3  4 4  3   queue: 4    4    3    3\\n                           t2.r t1.l\\n```\n```java\\npublic boolean isSymmetric(TreeNode root) {\\n  if (root == null) {\\n    return true;\\n  }\\n  Queue<TreeNode> queue = new LinkedList<>();\\n  queue.offer(root.left);\\n  queue.offer(root.right);\\n\\n  while (queue.size() > 0) {\\n    TreeNode t1 = queue.poll();\\n    TreeNode t2 = queue.poll();\\n    // check\\n    if (t1 == null && t2 == null) continue;\\n    if (t1 == null || t2 == null) return false;\\n    if (t1.val != t2.val) return false;\\n    // offer children\\n    queue.offer(t1.left);\\n    queue.offer(t2.right);\\n\\n    queue.offer(t1.right);\\n    queue.offer(t2.left);\\n  }\\n  return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 33080,
                "title": "recursive-and-iterative-dfs-and-bfs-in-c-easy-to-understand",
                "content": "**Iterative in BFS**:\\n\\n    bool isSymmetric(TreeNode* root) {\\n        if(!root) return true;\\n        queue<nodepair> q;\\n        q.push(make_pair(root->left, root->right));\\n        while(!q.empty()){\\n            nodepair p = q.front();\\n            q.pop();\\n            if(!p.first && !p.second) continue;\\n            if(!p.first || !p.second) return false;\\n            if(p.first->val != p.second->val) return false;\\n            q.push(make_pair(p.first->left, p.second->right));\\n            q.push(make_pair(p.first->right, p.second->left));\\n        }\\n        return true;\\n    }\\n\\n**Iterative in DFS**:\\n\\n    bool isSymmetric(TreeNode* root) {\\n        if(!root) return true;\\n        stack<TreeNode*> sl, sr;\\n        sl.push(root);\\n        sr.push(root);\\n        TreeNode * lp = root->left, *rp = root->right;\\n        while(lp || ! sl.empty() || rp || !sl.empty()){\\n            if((!lp && rp) || (lp && !rp)) return false;\\n            if(lp && rp){\\n                if(lp->val != rp->val) return false;\\n                sl.push(lp);\\n                sr.push(rp);\\n                lp = lp->left;\\n                rp = rp->right;\\n            }else{\\n                lp = sl.top()->right;\\n                rp = sr.top()->left;\\n                sl.pop();\\n                sr.pop();\\n            }\\n        }\\n        return true;\\n    }\\n\\n**Recursive**:\\n\\n    bool isSymmetric(TreeNode* root) {\\n        if(!root) return true;\\n        return helper(root->left, root->right);\\n    }\\n    bool helper(TreeNode* left, TreeNode* right){\\n        if(!left && !right) return true;\\n        if(!left || !right) return false;\\n        return (left->val == right->val) && helper(left->left, right->right) && helper(left->right, right->left);\\n    }",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "**Iterative in BFS**:\\n\\n    bool isSymmetric(TreeNode* root) {\\n        if(!root) return true;\\n        queue<nodepair> q;\\n        q.push(make_pair(root->left, root->right));\\n        while(!q.empty()){\\n            nodepair p = q.front();\\n            q.pop();\\n            if(!p.first && !p.second) continue;\\n            if(!p.first || !p.second) return false;\\n            if(p.first->val != p.second->val) return false;\\n            q.push(make_pair(p.first->left, p.second->right));\\n            q.push(make_pair(p.first->right, p.second->left));\\n        }\\n        return true;\\n    }\\n\\n**Iterative in DFS**:\\n\\n    bool isSymmetric(TreeNode* root) {\\n        if(!root) return true;\\n        stack<TreeNode*> sl, sr;\\n        sl.push(root);\\n        sr.push(root);\\n        TreeNode * lp = root->left, *rp = root->right;\\n        while(lp || ! sl.empty() || rp || !sl.empty()){\\n            if((!lp && rp) || (lp && !rp)) return false;\\n            if(lp && rp){\\n                if(lp->val != rp->val) return false;\\n                sl.push(lp);\\n                sr.push(rp);\\n                lp = lp->left;\\n                rp = rp->right;\\n            }else{\\n                lp = sl.top()->right;\\n                rp = sr.top()->left;\\n                sl.pop();\\n                sr.pop();\\n            }\\n        }\\n        return true;\\n    }\\n\\n**Recursive**:\\n\\n    bool isSymmetric(TreeNode* root) {\\n        if(!root) return true;\\n        return helper(root->left, root->right);\\n    }\\n    bool helper(TreeNode* left, TreeNode* right){\\n        if(!left && !right) return true;\\n        if(!left || !right) return false;\\n        return (left->val == right->val) && helper(left->left, right->right) && helper(left->right, right->left);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3290298,
                "title": "c-easy-solution-recursive-approach-heavily-commented",
                "content": "## **\\u2705\\u2705C++ || Easy Solution || \\uD83D\\uDCAF\\uD83D\\uDCAFRecursive Approach || Heavily Commented**\\n# **Please Upvote as it really motivates me**\\n\\n```\\nclass Solution {\\npublic:\\n    bool isEqual(TreeNode*r1,TreeNode*r2){\\n        //if we have both root to nullptr then we will return true\\n        //else we will be returning false\\n        \\n        if(!r1||!r2)\\n            return r1==r2;\\n        //if not null then we will check for the r1 and r2 values\\n        if(r1->val==r2->val){\\n        //we will check for the r1 left and r2 right because they will be on opposite sides\\n            return isEqual(r1->left,r2->right)&&isEqual(r1->right,r2->left);\\n        }\\n        //if r1 val not equal to r2 val then return false\\n        return false;\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        //The Approach is simple i.e. we will have to check if \\n            //1. the right and left is equal \\n        return isEqual(root->left,root->right);\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/7f423b57-81a2-46ce-9ab2-72ad38f668f7_1675480558.466273.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isEqual(TreeNode*r1,TreeNode*r2){\\n        //if we have both root to nullptr then we will return true\\n        //else we will be returning false\\n        \\n        if(!r1||!r2)\\n            return r1==r2;\\n        //if not null then we will check for the r1 and r2 values\\n        if(r1->val==r2->val){\\n        //we will check for the r1 left and r2 right because they will be on opposite sides\\n            return isEqual(r1->left,r2->right)&&isEqual(r1->right,r2->left);\\n        }\\n        //if r1 val not equal to r2 val then return false\\n        return false;\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        //The Approach is simple i.e. we will have to check if \\n            //1. the right and left is equal \\n        return isEqual(root->left,root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1398964,
                "title": "c-recursive-well-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    bool solve(TreeNode * r1, TreeNode * r2)\\n    {    \\n        if(r1 == NULL && r2 == NULL)\\n            return true; \\n\\t\\t\\n        else if(r1 == NULL || r2 == NULL || r1->val != r2->val)\\n            return false; \\n        \\n        return solve(r1->left, r2->right) && solve(r1->right, r2->left);\\n    }\\n    \\n    bool isSymmetric(TreeNode* root) \\n    {\\n        return solve(root->left, root->right);     \\n    }\\n};\\n```\\n\\nExplanation :\\n\\n```\\nclass Solution {\\npublic:\\n    bool solve(TreeNode * r1, TreeNode * r2)\\n    {\\n        // See the tree diagram are r1 and r2 null ? No, so this line dont execute\\n        if(r1 == NULL && r2 == NULL)\\n            return true; \\n\\t\\t\\n        // Is any one of r1 or r2 null ? Or are these values different ? No. Both values are\\n        // same so this else if wont execute either\\n        else if(r1 == NULL || r2 == NULL || r1->val != r2->val)\\n            return false; \\n        \\n        // Now comes the main part, we are calling 2 seperate function calls \\n        return solve(r1->left, r2->right) && solve(r1->right, r2->left);\\n        // First solve() before && will execute\\n        // r1->left is 3 and r2->right = 3\\n        // Both values are same , they will by pass both if and else if statement\\n        // Now again r1->left is null and r2->right is null\\n        // So they will return true from first if condtion\\n        // Now the scene is : we have executed first solve() before && and it has\\n        // returned us True so expression becomes \\' return true && solve() \\'\\n        // Now solve after && will execute \\n        // Similarly it will check for 4 and 4 , it will by pass if else statements\\n        // next time both will become null, so will return true\\n        // Thus 2nd solve() at the end will also hold true\\n        // and we know \\'true && true\\' is true\\n        // so true will be returned to caller, and thus tree is mirror of itself.\\n        // Similarly you can check for any testcase, flow of execution will remain same.\\n        \\n    }\\n    \\n    bool isSymmetric(TreeNode* root) \\n    {\\n        // Imagine a tree:    1\\n        //                 2     2\\n        //               3   4 4   3\\n        // We are standing on root that is 1, function begins\\n        // and now r1 and r2 points to 2 and 2 respectively.                      \\n        return solve(root->left, root->right);     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(TreeNode * r1, TreeNode * r2)\\n    {    \\n        if(r1 == NULL && r2 == NULL)\\n            return true; \\n\\t\\t\\n        else if(r1 == NULL || r2 == NULL || r1->val != r2->val)\\n            return false; \\n        \\n        return solve(r1->left, r2->right) && solve(r1->right, r2->left);\\n    }\\n    \\n    bool isSymmetric(TreeNode* root) \\n    {\\n        return solve(root->left, root->right);     \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool solve(TreeNode * r1, TreeNode * r2)\\n    {\\n        // See the tree diagram are r1 and r2 null ? No, so this line dont execute\\n        if(r1 == NULL && r2 == NULL)\\n            return true; \\n\\t\\t\\n        // Is any one of r1 or r2 null ? Or are these values different ? No. Both values are\\n        // same so this else if wont execute either\\n        else if(r1 == NULL || r2 == NULL || r1->val != r2->val)\\n            return false; \\n        \\n        // Now comes the main part, we are calling 2 seperate function calls \\n        return solve(r1->left, r2->right) && solve(r1->right, r2->left);\\n        // First solve() before && will execute\\n        // r1->left is 3 and r2->right = 3\\n        // Both values are same , they will by pass both if and else if statement\\n        // Now again r1->left is null and r2->right is null\\n        // So they will return true from first if condtion\\n        // Now the scene is : we have executed first solve() before && and it has\\n        // returned us True so expression becomes \\' return true && solve() \\'\\n        // Now solve after && will execute \\n        // Similarly it will check for 4 and 4 , it will by pass if else statements\\n        // next time both will become null, so will return true\\n        // Thus 2nd solve() at the end will also hold true\\n        // and we know \\'true && true\\' is true\\n        // so true will be returned to caller, and thus tree is mirror of itself.\\n        // Similarly you can check for any testcase, flow of execution will remain same.\\n        \\n    }\\n    \\n    bool isSymmetric(TreeNode* root) \\n    {\\n        // Imagine a tree:    1\\n        //                 2     2\\n        //               3   4 4   3\\n        // We are standing on root that is 1, function begins\\n        // and now r1 and r2 points to 2 and 2 respectively.                      \\n        return solve(root->left, root->right);     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 33057,
                "title": "python-iterative-way-using-a-queue",
                "content": "Each iteration, it checks whether two nodes are symmetric and then push (node1.left, node2.right), (node1.right, node2.left) to the end of queue.\\n\\n    class Solution:\\n    # @param root, a tree node\\n    # @return a boolean\\n    def isSymmetric(self, root):\\n        if not root:\\n            return True\\n\\n        dq = collections.deque([(root.left,root.right),])\\n        while dq:\\n            node1, node2 = dq.popleft()\\n            if not node1 and not node2:\\n                continue\\n            if not node1 or not node2:\\n                return False\\n            if node1.val != node2.val:\\n                return False\\n            # node1.left and node2.right are symmetric nodes in structure\\n            # node1.right and node2.left are symmetric nodes in structure\\n            dq.append((node1.left,node2.right))\\n            dq.append((node1.right,node2.left))\\n        return True",
                "solutionTags": [
                    "Python"
                ],
                "code": "Each iteration, it checks whether two nodes are symmetric and then push (node1.left, node2.right), (node1.right, node2.left) to the end of queue.\\n\\n    class Solution:\\n    # @param root, a tree node\\n    # @return a boolean\\n    def isSymmetric(self, root):\\n        if not root:\\n            return True\\n\\n        dq = collections.deque([(root.left,root.right),])\\n        while dq:\\n            node1, node2 = dq.popleft()\\n            if not node1 and not node2:\\n                continue\\n            if not node1 or not node2:\\n                return False\\n            if node1.val != node2.val:\\n                return False\\n            # node1.left and node2.right are symmetric nodes in structure\\n            # node1.right and node2.left are symmetric nodes in structure\\n            dq.append((node1.left,node2.right))\\n            dq.append((node1.right,node2.left))\\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 494632,
                "title": "javascript-95-speed-100-memory-w-comments",
                "content": "```\\nvar isSymmetric = function(root) {\\n    if (root == null) return true;\\n    \\n    return symmetryChecker(root.left, root.right);\\n};\\n\\nfunction symmetryChecker(left, right) {\\n    if (left == null && right == null) return true; // If both sub trees are empty\\n    if (left == null || right == null) return false; // If only one of the sub trees are empty\\n    if (left.val !== right.val) return false; // If the values dont match up\\n    \\n\\t// Check both subtrees but travelled in a mirrored/symmetric fashion\\n\\t// (one goes left, other goes right)  and make sure they\\'re both symmetric\\n    return symmetryChecker(left.left, right.right) &&\\n    symmetryChecker(left.right, right.left);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isSymmetric = function(root) {\\n    if (root == null) return true;\\n    \\n    return symmetryChecker(root.left, root.right);\\n};\\n\\nfunction symmetryChecker(left, right) {\\n    if (left == null && right == null) return true; // If both sub trees are empty\\n    if (left == null || right == null) return false; // If only one of the sub trees are empty\\n    if (left.val !== right.val) return false; // If the values dont match up\\n    \\n\\t// Check both subtrees but travelled in a mirrored/symmetric fashion\\n\\t// (one goes left, other goes right)  and make sure they\\'re both symmetric\\n    return symmetryChecker(left.left, right.right) &&\\n    symmetryChecker(left.right, right.left);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 33313,
                "title": "slim-java-solution",
                "content": "The idea is:\\n1. level traversal.\\n2. push nodes onto stack, every 2 consecutive is a pair, and should either be both null or have equal value.\\nrepeat until stack is empty.\\n\\n    public boolean isSymmetric(TreeNode root) {\\n        if (root == null)\\n            return true;\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        stack.push(root.left);\\n        stack.push(root.right);\\n        while (!stack.isEmpty()) {\\n            TreeNode node1 = stack.pop();\\n            TreeNode node2 = stack.pop();\\n            if (node1 == null && node2 == null)\\n                continue;\\n            if (node1 == null || node2 == null)\\n                return false;\\n            if (node1.val != node2.val)\\n                return false;\\n            stack.push(node1.left);\\n            stack.push(node2.right);\\n            stack.push(node1.right);\\n            stack.push(node2.left);\\n        }\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "The idea is:\\n1. level traversal.\\n2. push nodes onto stack, every 2 consecutive is a pair, and should either be both null or have equal value.\\nrepeat until stack is empty.\\n\\n    public boolean isSymmetric(TreeNode root) {\\n        if (root == null)\\n            return true;\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        stack.push(root.left);\\n        stack.push(root.right);\\n        while (!stack.isEmpty()) {\\n            TreeNode node1 = stack.pop();\\n            TreeNode node2 = stack.pop();\\n            if (node1 == null && node2 == null)\\n                continue;\\n            if (node1 == null || node2 == null)\\n                return false;\\n            if (node1.val != node2.val)\\n                return false;\\n            stack.push(node1.left);\\n            stack.push(node2.right);\\n            stack.push(node1.right);\\n            stack.push(node2.left);\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1805548,
                "title": "python-simple-python-solution-using-recursion",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 41 ms, faster than 29.46% of Python3 online submissions for Symmetric Tree.\\n# Memory Usage: 13.8 MB, less than 99.68% of Python3 online submissions for Symmetric Tree.\\n\\tclass Solution:\\n\\t\\tdef isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n\\n\\t\\t\\tdef check_mirror_image(root1, root2):\\n\\n\\t\\t\\t\\tif root1 == None and root2 == None:\\n\\t\\t\\t\\t\\treturn True\\n\\n\\t\\t\\t\\tif root1 != None and root2 == None or root1 == None and root2 != None:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\tif root1.val == root2.val:\\n\\t\\t\\t\\t\\treturn check_mirror_image(root1.left, root2.right) and check_mirror_image(root1.right, root2.left)\\n\\n\\t\\t\\treturn check_mirror_image(root, root)\\n\\t\\t\\t\\n# Thank You So Much \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 41 ms, faster than 29.46% of Python3 online submissions for Symmetric Tree.\\n# Memory Usage: 13.8 MB, less than 99.68% of Python3 online submissions for Symmetric Tree.\\n\\tclass Solution:\\n\\t\\tdef isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n\\n\\t\\t\\tdef check_mirror_image(root1, root2):\\n\\n\\t\\t\\t\\tif root1 == None and root2 == None:\\n\\t\\t\\t\\t\\treturn True\\n\\n\\t\\t\\t\\tif root1 != None and root2 == None or root1 == None and root2 != None:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\tif root1.val == root2.val:\\n\\t\\t\\t\\t\\treturn check_mirror_image(root1.left, root2.right) and check_mirror_image(root1.right, root2.left)\\n\\n\\t\\t\\treturn check_mirror_image(root, root)\\n\\t\\t\\t\\n# Thank You So Much \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D\\n",
                "codeTag": "Java"
            },
            {
                "id": 33361,
                "title": "another-passed-java-solution",
                "content": "    public class Solution {\\n        public boolean isSymmetric(TreeNode root) {\\n            if (root == null) \\n                return true;\\n            \\n            return isSymmetric(root.left, root.right);\\n        }\\n        \\n        boolean isSymmetric(TreeNode left, TreeNode right) {\\n            if (left == null && right == null) \\n                return true;\\n\\n            if (left == null || right == null) \\n                return false;\\n\\n            if (left.val != right.val) \\n                return false;\\n\\n            return isSymmetric(left.left, right.right) && isSymmetric(left.right, right.left);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean isSymmetric(TreeNode root) {\\n            if (root == null) \\n                return true;\\n            \\n            return isSymmetric(root.left, root.right);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 33127,
                "title": "easy-and-simple-using-one-queue-iterative-in-java",
                "content": "    public class Solution {\\n        public boolean isSymmetric(TreeNode root) {\\n            if(root == null) return true;\\n            Queue<TreeNode> queue = new LinkedList<TreeNode>();\\n            queue.offer(root.left);\\n            queue.offer(root.right);\\n            while(!queue.isEmpty()){\\n                TreeNode left = queue.poll();\\n                TreeNode right = queue.poll();\\n                if(left == null && right == null) continue;\\n                if(left == null || right == null) return false;\\n                if(left.val != right.val) return false;\\n                queue.offer(left.left);\\n                queue.offer(right.right);\\n                queue.offer(left.right);\\n                queue.offer(right.left);\\n                \\n            }\\n            return true;\\n            \\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isSymmetric(TreeNode root) {\\n            if(root == null) return true;\\n            Queue<TreeNode> queue = new LinkedList<TreeNode>();\\n            queue.offer(root.left);\\n            queue.offer(root.right);\\n            while(!queue.isEmpty()){\\n                TreeNode left = queue.poll();\\n                TreeNode right = queue.poll();\\n                if(left == null && right == null) continue;\\n                if(left == null || right == null) return false;\\n                if(left.val != right.val) return false;\\n                queue.offer(left.left);\\n                queue.offer(right.right);\\n                queue.offer(left.right);\\n                queue.offer(right.left);\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 939789,
                "title": "python-best-and-explained-o-n-recursion",
                "content": "```python\\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n        if not root:\\n            return True\\n        \\n        def isMirror(tree1, tree2):\\n            if not tree1 or not tree2: # if one of them is null\\n                return tree2 == tree1  # compare them\\n            if tree1.val != tree2.val: # if above not executed, means they are both number\\n                return False           # if they are both different return false\\n                                       # if they are similar go and look further\\n            return isMirror(tree1.left, tree2.right) and isMirror(tree1.right, tree2.left)\\n            \\n        return isMirror(root.left, root.right)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n        if not root:\\n            return True\\n        \\n        def isMirror(tree1, tree2):\\n            if not tree1 or not tree2: # if one of them is null\\n                return tree2 == tree1  # compare them\\n            if tree1.val != tree2.val: # if above not executed, means they are both number\\n                return False           # if they are both different return false\\n                                       # if they are similar go and look further\\n            return isMirror(tree1.left, tree2.right) and isMirror(tree1.right, tree2.left)\\n            \\n        return isMirror(root.left, root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 311745,
                "title": "easy-to-understand-python",
                "content": "Recursive\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n        if not root:\\n            return True\\n        return self.check(root.left, root.right)\\n        \\n    def check(self, left, right):\\n        if left is None and right is None:\\n            return True\\n        if left is None or right is None:\\n            return False\\n        if left.val != right.val:\\n            return False\\n        a = self.check(left.left, right.right)\\n        b = self.check(left.right, right.left)\\n        return a and b\\n```\\nIterative\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n        if not root:\\n            return True\\n        stack = collections.deque([(root.left, root.right)])\\n        while stack:\\n            l, r = stack.pop()\\n            if l is None and r is None:\\n                continue\\n            if l is None or r is None:\\n                return False\\n            if l.val != r.val:\\n                return False\\n            stack.append((l.left, r.right))\\n            stack.append((l.right, r.left))\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Depth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n        if not root:\\n            return True\\n        return self.check(root.left, root.right)\\n        \\n    def check(self, left, right):\\n        if left is None and right is None:\\n            return True\\n        if left is None or right is None:\\n            return False\\n        if left.val != right.val:\\n            return False\\n        a = self.check(left.left, right.right)\\n        b = self.check(left.right, right.left)\\n        return a and b\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n        if not root:\\n            return True\\n        stack = collections.deque([(root.left, root.right)])\\n        while stack:\\n            l, r = stack.pop()\\n            if l is None and r is None:\\n                continue\\n            if l is None or r is None:\\n                return False\\n            if l.val != r.val:\\n                return False\\n            stack.append((l.left, r.right))\\n            stack.append((l.right, r.left))\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 33290,
                "title": "share-my-recursive-c-solution-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        bool isSymmetric(TreeNode* root) {\\n            if (root == NULL)\\n                return true;\\n            \\n            return checkSymmetric(root->left, root->right);\\n        }\\n        //check the two nodes in symmetric position\\n        bool checkSymmetric(TreeNode *leftSymmetricNode, TreeNode *rightSymmetricNode)\\n        {\\n            if (leftSymmetricNode == NULL && rightSymmetricNode == NULL)\\n                return true;\\n            if (leftSymmetricNode == NULL || rightSymmetricNode == NULL)\\n                return false;\\n            if (leftSymmetricNode->val == rightSymmetricNode->val)\\n                return checkSymmetric(leftSymmetricNode->left, rightSymmetricNode->right) && checkSymmetric(leftSymmetricNode->right, rightSymmetricNode->left);\\n            return false;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool isSymmetric(TreeNode* root) {\\n            if (root == NULL)\\n                return true;\\n            \\n            return checkSymmetric(root->left, root->right);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 160691,
                "title": "python-solution",
                "content": "Recursive:\\n```\\nclass Solution(object):\\n    def isSymmetric(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        def isSym(root1, root2):\\n            if root1 == None and root2 == None:\\n                return True\\n            elif root1 == None and root2 != None:\\n                return False\\n            elif root1 != None and root2 == None:\\n                return False\\n            else:\\n                if root1.val != root2.val:\\n                    return False\\n                else:\\n                    return isSym(root1.left, root2.right) and isSym(root1.right,root2.left)\\n        return root == None or isSym(root.left,root.right)\\n```\\nIterative (DFS):\\n```\\nclass Solution(object):\\n    def isSymmetric(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if root == None:\\n            return True\\n        stack = [root,root]\\n        while stack:\\n            r1 = stack.pop()\\n            r2 = stack.pop()\\n            if r1 == None and r2 == None:\\n                continue\\n            if r1 == None or r2 == None:\\n                return False\\n            if r1.val != r2.val:\\n                return False\\n            stack.append(r1.left)\\n            stack.append(r2.right)\\n            stack.append(r1.right)\\n            stack.append(r2.left)\\n        return True\\n```\\nIterative (BFS):\\n```\\nclass Solution(object):\\n    def isSymmetric(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if root == None:\\n            return True\\n        queue = collections.deque([root, root])\\n        while queue:\\n            r1 = queue.pop()\\n            r2 = queue.pop()\\n            if r1 == None and r2 == None:\\n                continue\\n            if r1 == None or r2 == None:\\n                return False\\n            if r1.val != r2.val:\\n                return False\\n            queue.append(r1.left)\\n            queue.append(r2.right)\\n            queue.append(r1.right)\\n            queue.append(r2.left)\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isSymmetric(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        def isSym(root1, root2):\\n            if root1 == None and root2 == None:\\n                return True\\n            elif root1 == None and root2 != None:\\n                return False\\n            elif root1 != None and root2 == None:\\n                return False\\n            else:\\n                if root1.val != root2.val:\\n                    return False\\n                else:\\n                    return isSym(root1.left, root2.right) and isSym(root1.right,root2.left)\\n        return root == None or isSym(root.left,root.right)\\n```\n```\\nclass Solution(object):\\n    def isSymmetric(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if root == None:\\n            return True\\n        stack = [root,root]\\n        while stack:\\n            r1 = stack.pop()\\n            r2 = stack.pop()\\n            if r1 == None and r2 == None:\\n                continue\\n            if r1 == None or r2 == None:\\n                return False\\n            if r1.val != r2.val:\\n                return False\\n            stack.append(r1.left)\\n            stack.append(r2.right)\\n            stack.append(r1.right)\\n            stack.append(r2.left)\\n        return True\\n```\n```\\nclass Solution(object):\\n    def isSymmetric(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if root == None:\\n            return True\\n        queue = collections.deque([root, root])\\n        while queue:\\n            r1 = queue.pop()\\n            r2 = queue.pop()\\n            if r1 == None and r2 == None:\\n                continue\\n            if r1 == None or r2 == None:\\n                return False\\n            if r1.val != r2.val:\\n                return False\\n            queue.append(r1.left)\\n            queue.append(r2.right)\\n            queue.append(r1.right)\\n            queue.append(r2.left)\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878795,
                "title": "elegant-swift-solution-by-conforming-to-equatable",
                "content": "```\\nclass Solution {\\n    func isSymmetric(_ root: TreeNode?) -> Bool {\\n\\t\\troot?.left == root?.right\\n\\t}\\n}\\n\\nextension TreeNode: Equatable {\\n    public static func ==(lhs: TreeNode, rhs: TreeNode) -> Bool {\\n        lhs.val == rhs.val && lhs.left == rhs.right && lhs.right == rhs.left\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func isSymmetric(_ root: TreeNode?) -> Bool {\\n\\t\\troot?.left == root?.right\\n\\t}\\n}\\n\\nextension TreeNode: Equatable {\\n    public static func ==(lhs: TreeNode, rhs: TreeNode) -> Bool {\\n        lhs.val == rhs.val && lhs.left == rhs.right && lhs.right == rhs.left\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 748090,
                "title": "python-3-dfs-iterative-solution-using-stack-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def isSymmetric(self, root):\\n        stack = []\\n        if root: stack.append([root.left, root.right])\\n\\n        while(len(stack) > 0):\\n            left, right = stack.pop()\\n            \\n            if left and right:\\n                if left.val != right.val: return False\\n                stack.append([left.left, right.right])\\n                stack.append([right.left, left.right])\\n        \\n            elif left or right: return False\\n        \\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSymmetric(self, root):\\n        stack = []\\n        if root: stack.append([root.left, root.right])\\n\\n        while(len(stack) > 0):\\n            left, right = stack.pop()\\n            \\n            if left and right:\\n                if left.val != right.val: return False\\n                stack.append([left.left, right.right])\\n                stack.append([right.left, left.right])\\n        \\n            elif left or right: return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2689461,
                "title": "java-easy-recursive-solution-easiest-approach-runtime-0-ms",
                "content": "```\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n       return root == null || isMirror(root.left, root.right);\\n    }\\n    boolean isMirror(TreeNode node1, TreeNode node2) {\\n        if (node1 == null && node2 == null) return true;\\n        \\n        if (node1 == null || node2 == null) return false;\\n        \\n        if (node1.val != node2.val) return false;\\n        return isMirror(node1.left, node2.right) && isMirror(node1.right, node2.left);\\n    }\\n}\\n\\n```\\n![image](https://assets.leetcode.com/users/images/0ad972be-ccb4-4c1f-92f1-2ec39d38b178_1665474715.5691338.png)\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n       return root == null || isMirror(root.left, root.right);\\n    }\\n    boolean isMirror(TreeNode node1, TreeNode node2) {\\n        if (node1 == null && node2 == null) return true;\\n        \\n        if (node1 == null || node2 == null) return false;\\n        \\n        if (node1.val != node2.val) return false;\\n        return isMirror(node1.left, node2.right) && isMirror(node1.right, node2.left);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2749982,
                "title": "java-bfs-and-dfs",
                "content": "# Please Upvote \\uD83D\\uDE07\\n---\\n##### 1. DFS approach:\\n```\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        return help(root.left, root.right);\\n    }\\n\\n    private boolean help(TreeNode left, TreeNode right) {\\n        if (left == null || right == null) {\\n            return left == right;\\n        }\\n        if (left.val != right.val) {\\n            return false;\\n        }\\n        boolean check1 = help(left.left, right.right);\\n        boolean check2 = help(left.right, right.left);\\n        return check1 && check2;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```\\n---\\n##### 2. BFS approach:\\n```\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n\\n        while (!q.isEmpty()) {\\n            int n = q.size();\\n            List<Integer> list = new ArrayList<>();\\n\\n            for (int i = 0; i < n; i++) {\\n                TreeNode curr = q.poll();\\n\\n                if (curr == null) list.add(null);\\n                else {\\n                    list.add(curr.val);\\n                    q.offer(curr.left);\\n                    q.offer(curr.right);\\n                }\\n            }\\n\\n            if (!checkSymmetry(list)) return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    public boolean checkSymmetry(List<Integer> list) {\\n        int l = 0, r = list.size() - 1;\\n\\n        while (l < r) {\\n            if (list.get(l++) != list.get(r--)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        return help(root.left, root.right);\\n    }\\n\\n    private boolean help(TreeNode left, TreeNode right) {\\n        if (left == null || right == null) {\\n            return left == right;\\n        }\\n        if (left.val != right.val) {\\n            return false;\\n        }\\n        boolean check1 = help(left.left, right.right);\\n        boolean check2 = help(left.right, right.left);\\n        return check1 && check2;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```\n```\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n\\n        while (!q.isEmpty()) {\\n            int n = q.size();\\n            List<Integer> list = new ArrayList<>();\\n\\n            for (int i = 0; i < n; i++) {\\n                TreeNode curr = q.poll();\\n\\n                if (curr == null) list.add(null);\\n                else {\\n                    list.add(curr.val);\\n                    q.offer(curr.left);\\n                    q.offer(curr.right);\\n                }\\n            }\\n\\n            if (!checkSymmetry(list)) return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    public boolean checkSymmetry(List<Integer> list) {\\n        int l = 0, r = list.size() - 1;\\n\\n        while (l < r) {\\n            if (list.get(l++) != list.get(r--)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 33247,
                "title": "2-lines-java-solution-use-1ms",
                "content": "\\n\\n    public class Solution {\\n        public boolean isSymmetric(TreeNode root) {\\n            return isMirror(root,root);\\n        }\\n    \\n        public boolean isMirror(TreeNode a,TreeNode b){\\n            return a==null||b==null?a==b:a.val==b.val&&isMirror(a.left,b.right)&&isMirror(a.right,b.left);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isSymmetric(TreeNode root) {\\n            return isMirror(root,root);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3293275,
                "title": "php-javascript-recursive-iterative-solutions",
                "content": "### 1. Recursive Solution\\nThis solution uses recursion to check if a binary tree is symmetric. The recursive helper function isMirror() checks if the two nodes of the binary tree are mirror images of each other, by comparing their values, and then recursively checking if their left and right nodes are mirror images of each other. If the values are equal and the subtrees are mirrors, then the function returns true. Otherwise, it returns false.\\n\\nThe *time complexity* of this solution is O(n) as all nodes in the binary tree must be visited in order to determine if the tree is symmetric. \\nThe *space complexity* is also O(n) as the recursive stack may contain up to n elements.\\n\\n\\n```javascript []\\nvar isSymmetric = function (root) {\\n    if (root == null) return true;\\n    return isMirror(root.left, root.right);\\n\\n    function isMirror(leftNode, rightNode) {\\n        if (leftNode == null && rightNode == null) return true;\\n        if (leftNode == null || rightNode == null) return false;\\n        return leftNode.val === rightNode.val &&\\n            isMirror(leftNode.left, rightNode.right) &&\\n            isMirror(leftNode.right, rightNode.left);\\n    }\\n};\\n```\\n```PHP []\\nclass Solution\\n{\\n    /**\\n     * @param TreeNode $root\\n     * @return Boolean\\n     */\\n    function isSymmetric(TreeNode $root): bool {\\n        if ($root === null) {\\n            return true;\\n        }\\n        return $this->isNodesMirror($root->left, $root->right);\\n    }\\n\\n    function isNodesMirror(?TreeNode $leftNode, ?TreeNode $rightNode): bool {\\n        if ($leftNode === null && $rightNode === null) {\\n            return true;\\n        }\\n        if ($leftNode === null || $rightNode === null) {\\n            return false;\\n        }\\n        return $leftNode->val === $rightNode->val &&\\n            $this->isNodesMirror($leftNode->left, $rightNode->right) &&\\n            $this->isNodesMirror($leftNode->right, $rightNode->left);\\n    }\\n}\\n```\\n\\n\\n### 2. Iterative Solution\\nThis solution uses a Breadth-First Search approach to traverse the tree. A queue is used to store left and right nodes of the tree at each level. If the left node and right node are both null then the loop continues. If either one is null or the values of the nodes do not match then false is returned. If the values match then the left and right children of each node are pushed to the queue for comparison. If the loop completes without returning false then true is returned.\\n*Time complexity*: O(n) as the algorithm visits each node once.\\n*Space complexity*: O(n) as the queue stores all nodes at each level.\\n\\n```javascript []\\nvar isSymmetric = function (root) {\\n    if (root == null) return true;\\n    let queue = [root.left, root.right];\\n    while (queue.length > 0) {\\n        let leftNode = queue.shift();\\n        let rightNode = queue.shift();\\n        if (leftNode == null && rightNode == null) continue;\\n        if (leftNode == null ||\\n            rightNode == null ||\\n            leftNode.val !== rightNode.val) {\\n            return false;\\n        }\\n        queue.push(leftNode.left, rightNode.right);\\n        queue.push(leftNode.right, rightNode.left);\\n    }\\n    return true;\\n}\\n```\\n```PHP []\\nclass Solution\\n{\\n    /**\\n     * @param TreeNode $root\\n     * @return Boolean\\n     */\\n    function isSymmetric(?TreeNode $root): bool {\\n        if ($root === null) {\\n            return true;\\n        }\\n        $queue = [[$root->left, $root->right]];\\n\\n        while ($queue) {\\n            $newQueue = [];\\n            foreach ($queue as [$leftNode, $rightNode]) {\\n                if ($leftNode === null && $rightNode === null) {\\n                    continue;\\n                }\\n                if ($leftNode->val !== $rightNode->val ||\\n                    $leftNode === null ||\\n                    $rightNode === null) {\\n                    return false;\\n                }\\n                $newQueue[] = [$leftNode->left, $rightNode->right];\\n                $newQueue[] = [$leftNode->right, $rightNode->left];\\n            }\\n            $queue = $newQueue;\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n\\n\\n### If my work was useful for you, please upvote\\n\\uD83D\\uDC4D\\uD83D\\uDC4D\\uD83D\\uDC4D",
                "solutionTags": [
                    "JavaScript",
                    "PHP"
                ],
                "code": "```javascript []\\nvar isSymmetric = function (root) {\\n    if (root == null) return true;\\n    return isMirror(root.left, root.right);\\n\\n    function isMirror(leftNode, rightNode) {\\n        if (leftNode == null && rightNode == null) return true;\\n        if (leftNode == null || rightNode == null) return false;\\n        return leftNode.val === rightNode.val &&\\n            isMirror(leftNode.left, rightNode.right) &&\\n            isMirror(leftNode.right, rightNode.left);\\n    }\\n};\\n```\n```PHP []\\nclass Solution\\n{\\n    /**\\n     * @param TreeNode $root\\n     * @return Boolean\\n     */\\n    function isSymmetric(TreeNode $root): bool {\\n        if ($root === null) {\\n            return true;\\n        }\\n        return $this->isNodesMirror($root->left, $root->right);\\n    }\\n\\n    function isNodesMirror(?TreeNode $leftNode, ?TreeNode $rightNode): bool {\\n        if ($leftNode === null && $rightNode === null) {\\n            return true;\\n        }\\n        if ($leftNode === null || $rightNode === null) {\\n            return false;\\n        }\\n        return $leftNode->val === $rightNode->val &&\\n            $this->isNodesMirror($leftNode->left, $rightNode->right) &&\\n            $this->isNodesMirror($leftNode->right, $rightNode->left);\\n    }\\n}\\n```\n```javascript []\\nvar isSymmetric = function (root) {\\n    if (root == null) return true;\\n    let queue = [root.left, root.right];\\n    while (queue.length > 0) {\\n        let leftNode = queue.shift();\\n        let rightNode = queue.shift();\\n        if (leftNode == null && rightNode == null) continue;\\n        if (leftNode == null ||\\n            rightNode == null ||\\n            leftNode.val !== rightNode.val) {\\n            return false;\\n        }\\n        queue.push(leftNode.left, rightNode.right);\\n        queue.push(leftNode.right, rightNode.left);\\n    }\\n    return true;\\n}\\n```\n```PHP []\\nclass Solution\\n{\\n    /**\\n     * @param TreeNode $root\\n     * @return Boolean\\n     */\\n    function isSymmetric(?TreeNode $root): bool {\\n        if ($root === null) {\\n            return true;\\n        }\\n        $queue = [[$root->left, $root->right]];\\n\\n        while ($queue) {\\n            $newQueue = [];\\n            foreach ($queue as [$leftNode, $rightNode]) {\\n                if ($leftNode === null && $rightNode === null) {\\n                    continue;\\n                }\\n                if ($leftNode->val !== $rightNode->val ||\\n                    $leftNode === null ||\\n                    $rightNode === null) {\\n                    return false;\\n                }\\n                $newQueue[] = [$leftNode->left, $rightNode->right];\\n                $newQueue[] = [$leftNode->right, $rightNode->left];\\n            }\\n            $queue = $newQueue;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2636087,
                "title": "python-dfs-bfs",
                "content": "**DFS Solution**\\n```\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        if not root:\\n            return True\\n        \\n        def dfs(l, r):\\n            if not l and not r:\\n                return True\\n            \\n            if not l or not r:\\n                return False\\n            \\n            if l.val == r.val:\\n                return dfs(l.left, r.right) and dfs(l.right, r.left)\\n            \\n            return False\\n        \\n        return dfs(root.left, root.right)\\n```\\n\\n**BFS Solution**\\n```\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        if not root:\\n            return True\\n        \\n        q = deque()\\n        q.append((root.left, root.right))\\n        while q:\\n            for _ in range(len(q)):\\n                left, right = q.popleft()\\n                if not left and not right:\\n                    continue\\n                    \\n                elif not left or not right:\\n                    return False\\n                \\n                else:\\n                    if left.val != right.val:\\n                        return False\\n                    \\n                    q.append((left.left, right.right))\\n                    q.append((left.right, right.left))\\n                    \\n        return True\\n```\\n**Please upvote if you find this helpful**",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        if not root:\\n            return True\\n        \\n        def dfs(l, r):\\n            if not l and not r:\\n                return True\\n            \\n            if not l or not r:\\n                return False\\n            \\n            if l.val == r.val:\\n                return dfs(l.left, r.right) and dfs(l.right, r.left)\\n            \\n            return False\\n        \\n        return dfs(root.left, root.right)\\n```\n```\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        if not root:\\n            return True\\n        \\n        q = deque()\\n        q.append((root.left, root.right))\\n        while q:\\n            for _ in range(len(q)):\\n                left, right = q.popleft()\\n                if not left and not right:\\n                    continue\\n                    \\n                elif not left or not right:\\n                    return False\\n                \\n                else:\\n                    if left.val != right.val:\\n                        return False\\n                    \\n                    q.append((left.left, right.right))\\n                    q.append((left.right, right.left))\\n                    \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 944937,
                "title": "c-solution-recursive-and-iterative",
                "content": "**Note**\\nThe answer is true when root is nullptr.\\n```\\nclass Solution\\n{\\npublic:\\n\\t// recursive : 12 ms 16.7 MB\\n\\tbool isSymmetric(TreeNode* root) {\\n\\t\\treturn !root || isEquivalent(root->left, root->right);\\n\\t}\\n\\n\\tbool isEquivalent(TreeNode* leftNode, TreeNode* rightNode)\\n\\t{\\n\\t\\tif (!leftNode && rightNode || leftNode && !rightNode) return false;\\n\\n\\t\\treturn !leftNode || leftNode->val == rightNode->val && isEquivalent(leftNode->left, rightNode->right) && isEquivalent(leftNode->right, rightNode->left);\\n\\t}\\n\\n\\t// iterative : 4 ms\\t16.9 MB\\n\\tbool isSymmetric3(TreeNode* root) {\\n\\t\\tif (!root) return true;\\n\\t\\tqueue<TreeNode*> pending({ root->left, root->right });\\n\\n\\t\\twhile (!pending.empty())\\n\\t\\t{\\n\\t\\t\\tTreeNode* l = pending.front();\\n\\t\\t\\tpending.pop();\\n\\t\\t\\tTreeNode* r = pending.front();\\n\\t\\t\\tpending.pop();\\n\\n\\t\\t\\tif (!l && r || l && !r) return false;\\n\\t\\t\\tif (l)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (l->val != r->val) return false;\\n\\t\\t\\t\\tpending.push(l->left);\\n\\t\\t\\t\\tpending.push(r->right);\\n\\t\\t\\t\\tpending.push(l->right);\\n\\t\\t\\t\\tpending.push(r->left);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n\\t// recursive : 12 ms 16.7 MB\\n\\tbool isSymmetric(TreeNode* root) {\\n\\t\\treturn !root || isEquivalent(root->left, root->right);\\n\\t}\\n\\n\\tbool isEquivalent(TreeNode* leftNode, TreeNode* rightNode)\\n\\t{\\n\\t\\tif (!leftNode && rightNode || leftNode && !rightNode) return false;\\n\\n\\t\\treturn !leftNode || leftNode->val == rightNode->val && isEquivalent(leftNode->left, rightNode->right) && isEquivalent(leftNode->right, rightNode->left);\\n\\t}\\n\\n\\t// iterative : 4 ms\\t16.9 MB\\n\\tbool isSymmetric3(TreeNode* root) {\\n\\t\\tif (!root) return true;\\n\\t\\tqueue<TreeNode*> pending({ root->left, root->right });\\n\\n\\t\\twhile (!pending.empty())\\n\\t\\t{\\n\\t\\t\\tTreeNode* l = pending.front();\\n\\t\\t\\tpending.pop();\\n\\t\\t\\tTreeNode* r = pending.front();\\n\\t\\t\\tpending.pop();\\n\\n\\t\\t\\tif (!l && r || l && !r) return false;\\n\\t\\t\\tif (l)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (l->val != r->val) return false;\\n\\t\\t\\t\\tpending.push(l->left);\\n\\t\\t\\t\\tpending.push(r->right);\\n\\t\\t\\t\\tpending.push(l->right);\\n\\t\\t\\t\\tpending.push(r->left);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 33286,
                "title": "java-iterative-recursive-solutions",
                "content": "#Recursive#\\n    public boolean isSymmetric(TreeNode root) {\\n    \\tif(root==null) return true;\\n    \\treturn isSymmetric(root.left, root.right);\\n    }\\n    private boolean isSymmetric(TreeNode root1, TreeNode root2) {\\n    \\tif(root1==null && root2==null) return true;\\n    \\tif(root1==null || root2==null) return false;\\n    \\tif(root1.val!=root2.val) return false;\\n    \\treturn isSymmetric(root1.left, root2.right) && isSymmetric(root1.right, root2.left);\\n    }\\n#Iterative#\\n    public boolean isSymmetric(TreeNode root) {\\n    \\tif(root==null) return true;\\n    \\tQueue<TreeNode> q1=new LinkedList<>(), q2=new LinkedList<>();\\n    \\tq1.add(root.left); \\n    \\tq2.add(root.right);\\n    \\twhile(!q1.isEmpty() && !q2.isEmpty()) {\\n    \\t\\tint size1=q1.size(), size2=q2.size();\\n    \\t\\tif(size1!=size2) return false;\\n    \\t\\tfor(int i=0; i<size1; i++) {\\n    \\t\\t\\tTreeNode current1=q1.remove(), current2=q2.remove();\\n    \\t\\t\\tif(current1==null && current2==null) continue;\\n    \\t\\t\\tif(current1==null || current2==null) return false; \\n    \\t\\t\\tif(current1.val!=current2.val) return false;\\n    \\t\\t\\tq1.add(current1.left);\\n    \\t\\t\\tq1.add(current1.right);\\n    \\t\\t\\tq2.add(current2.right);\\n    \\t\\t\\tq2.add(current2.left);\\n    \\t\\t}\\n    \\t}\\n    \\treturn q1.isEmpty() && q2.isEmpty();\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "#Recursive#\\n    public boolean isSymmetric(TreeNode root) {\\n    \\tif(root==null) return true;\\n    \\treturn isSymmetric(root.left, root.right);\\n    }\\n    private boolean isSymmetric(TreeNode root1, TreeNode root2) {\\n    \\tif(root1==null && root2==null) return true;\\n    \\tif(root1==null || root2==null) return false;\\n    \\tif(root1.val!=root2.val) return false;\\n    \\treturn isSymmetric(root1.left, root2.right) && isSymmetric(root1.right, root2.left);\\n    }\\n#Iterative#\\n    public boolean isSymmetric(TreeNode root) {\\n    \\tif(root==null) return true;\\n    \\tQueue<TreeNode> q1=new LinkedList<>(), q2=new LinkedList<>();\\n    \\tq1.add(root.left); \\n    \\tq2.add(root.right);\\n    \\twhile(!q1.isEmpty() && !q2.isEmpty()) {\\n    \\t\\tint size1=q1.size(), size2=q2.size();\\n    \\t\\tif(size1!=size2) return false;\\n    \\t\\tfor(int i=0; i<size1; i++) {\\n    \\t\\t\\tTreeNode current1=q1.remove(), current2=q2.remove();\\n    \\t\\t\\tif(current1==null && current2==null) continue;\\n    \\t\\t\\tif(current1==null || current2==null) return false; \\n    \\t\\t\\tif(current1.val!=current2.val) return false;\\n    \\t\\t\\tq1.add(current1.left);\\n    \\t\\t\\tq1.add(current1.right);\\n    \\t\\t\\tq2.add(current2.right);\\n    \\t\\t\\tq2.add(current2.left);\\n    \\t\\t}\\n    \\t}\\n    \\treturn q1.isEmpty() && q2.isEmpty();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 33311,
                "title": "4ms-simple-c-code",
                "content": "    class Solution {\\n    public:\\n    bool isSymmetric(TreeNode* root) {\\n            if (!root){\\n                return true;\\n            }\\n            else{\\n                return isSame(root->left, root->right);\\n            }\\n        }\\n    private: // hide functions in the private helps to improve running time\\n        bool isSame (TreeNode* n1, TreeNode* n2){\\n            if (!n1 || !n2){\\n                return n1 == n2;\\n            }\\n            else{\\n                return (n1->val == n2->val && isSame(n1->left, n2->right) && isSame(n1->right, n2->left));\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public:\\n    bool isSymmetric(TreeNode* root) {\\n            if (!root){\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3290825,
                "title": "python-solution-with-easy-explanation",
                "content": "> # *Please Upvote if it helps !* \\n\\n---\\n\\n- # Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nTo check whether a tree is mirror symmetric or not, we need to compare the left and right subtrees of each node. If they are mirror images of each other, then the tree is mirror symmetric.\\n\\n- # Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nIn this code, we first check if the root of the tree is None, in which case we return True because an empty tree is mirror symmetric.\\n\\nThen, we define a helper function called `isMirror` which takes two nodes as input and checks whether they are mirror images of each other. If both nodes are None, we return True. If one of them is None, we return False because a node cannot be a mirror image of None. \\n\\nOtherwise, we check if the values of the nodes are equal and then recursively check whether the left subtree of the first node is a mirror image of the right subtree of the second node, and whether the right subtree of the first node is a mirror image of the left subtree of the second node.\\n\\nFinally, we call the `isMirror` function with the left and right subtrees of the root node and return the result. If the tree is mirror symmetric, the function will return True, otherwise it will return False.\\n\\n- # Code\\n\\nHere is the  `Python` code to check whether a tree is mirror symmetric or not:\\n\\n```\\n\\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n        def isMirror(t1, t2):\\n            if not t1 and not t2:\\n                return True\\n            if not t1 or not t2:\\n                return False\\n            return t1.val == t2.val and isMirror(t1.right, t2.left) and isMirror(t1.left, t2.right)\\n        \\n        return isMirror(root, root)\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n        def isMirror(t1, t2):\\n            if not t1 and not t2:\\n                return True\\n            if not t1 or not t2:\\n                return False\\n            return t1.val == t2.val and isMirror(t1.right, t2.left) and isMirror(t1.left, t2.right)\\n        \\n        return isMirror(root, root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290297,
                "title": "java-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\nclass Solution {\\n    static boolean mir( TreeNode t1 , TreeNode t2 )\\n    {\\n        if( t1==null && t2== null ) return true;\\n        else if( t1==null || t2==null ) return false;\\n\\n        return ( t1.val==t2.val ) && mir( t1.right , t2.left ) && mir( t1.left , t2.right );\\n    }\\n    public boolean isSymmetric(TreeNode root) \\n    {\\n        return mir( root , root );\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\nclass Solution {\\n    static boolean mir( TreeNode t1 , TreeNode t2 )\\n    {\\n        if( t1==null && t2== null ) return true;\\n        else if( t1==null || t2==null ) return false;\\n\\n        return ( t1.val==t2.val ) && mir( t1.right , t2.left ) && mir( t1.left , t2.right );\\n    }\\n    public boolean isSymmetric(TreeNode root) \\n    {\\n        return mir( root , root );\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053636,
                "title": "c-short-simple-recursive-code",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRecurively check for the subtrees. Return false if they aren\\'t equal.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool isSame(TreeNode* t1, TreeNode* t2){\\n        if(!t1 && !t2){return true;}\\n        if(t1 && !t2){return false;}\\n        if(t2 && !t1){return false;}\\n        if(t1->val==t2->val){return isSame(t1->left,t2->right) && isSame(t1->right,t2->left);}\\n        return false;\\n    }\\n\\n    bool isSymmetric(TreeNode* root) {\\n    return isSame(root->left,root->right);            \\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool isSame(TreeNode* t1, TreeNode* t2){\\n        if(!t1 && !t2){return true;}\\n        if(t1 && !t2){return false;}\\n        if(t2 && !t1){return false;}\\n        if(t1->val==t2->val){return isSame(t1->left,t2->right) && isSame(t1->right,t2->left);}\\n        return false;\\n    }\\n\\n    bool isSymmetric(TreeNode* root) {\\n    return isSame(root->left,root->right);            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2771896,
                "title": "ts-easy-solution-recursive",
                "content": "Let me know in comments if you have any doubts. I will be happy to answer.\\nPlease upvote if you found the solution useful.\\n\\n```\\nconst isSymmetric = (root: TreeNode | null): boolean => {\\n  return isMirror(root, root);\\n};\\n  \\nconst isMirror = (t1: TreeNode | null, t2: TreeNode | null): boolean => {\\n  if (t1 === null && t2 === null) return true;\\n  if (t1 === null || t2 === null) return false;\\n  \\n  return (t1.val === t2.val) && isMirror(t1.left, t2.right) && isMirror(t1.right, t2.left);\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nconst isSymmetric = (root: TreeNode | null): boolean => {\\n  return isMirror(root, root);\\n};\\n  \\nconst isMirror = (t1: TreeNode | null, t2: TreeNode | null): boolean => {\\n  if (t1 === null && t2 === null) return true;\\n  if (t1 === null || t2 === null) return false;\\n  \\n  return (t1.val === t2.val) && isMirror(t1.left, t2.right) && isMirror(t1.right, t2.left);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2089367,
                "title": "facebook-amazon-interview-100ms-easy-to-understand-very-clean-code-tc-o-n-sc-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        \\n        if(root==NULL) return true; //To check if tree is empty or not\\n        \\n        return isSymmetricTest(root->left,root->right);\\n    }\\n    bool isSymmetricTest(TreeNode* p , TreeNode* q){\\n        if(p == NULL && q == NULL) // left & right node are NULL \\n            return true; \\n        \\n        else if(p == NULL || q == NULL) // one of them is Not NULL\\n            return false; \\n        \\n        else if(p->val!=q->val) \\n            return false;\\n        \\n        return isSymmetricTest(p->left,q->right) && isSymmetricTest(p->right,q->left);\\n    }\\n};\\n```\\n\\n# If you understand this solution, then please please upvote!!!",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        \\n        if(root==NULL) return true; //To check if tree is empty or not\\n        \\n        return isSymmetricTest(root->left,root->right);\\n    }\\n    bool isSymmetricTest(TreeNode* p , TreeNode* q){\\n        if(p == NULL && q == NULL) // left & right node are NULL \\n            return true; \\n        \\n        else if(p == NULL || q == NULL) // one of them is Not NULL\\n            return false; \\n        \\n        else if(p->val!=q->val) \\n            return false;\\n        \\n        return isSymmetricTest(p->left,q->right) && isSymmetricTest(p->right,q->left);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926232,
                "title": "100-fastest-swift-solution-time-o-n-space-o-n",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes.\\n    //   - space: O(n), where n is the number of nodes.\\n    \\n    func isSymmetric(_ root: TreeNode?) -> Bool {\\n        isMirror(root, root)\\n    }\\n    \\n    \\n    private func isMirror(_ left: TreeNode?, _ right: TreeNode?) -> Bool {\\n        if left == nil, right == nil { return true }\\n        \\n        guard left?.val == right?.val else { return false }\\n        \\n        return isMirror(left?.left, right?.right) && isMirror(left?.right, right?.left)\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes.\\n    //   - space: O(n), where n is the number of nodes.\\n    \\n    func isSymmetric(_ root: TreeNode?) -> Bool {\\n        isMirror(root, root)\\n    }\\n    \\n    \\n    private func isMirror(_ left: TreeNode?, _ right: TreeNode?) -> Bool {\\n        if left == nil, right == nil { return true }\\n        \\n        guard left?.val == right?.val else { return false }\\n        \\n        return isMirror(left?.left, right?.right) && isMirror(left?.right, right?.left)\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1120677,
                "title": "100-faster-0ms-runtime-short-c-solution",
                "content": "```\\n\\n\\n    bool isMirror(TreeNode* root1,TreeNode *root2){\\n        if(root1==NULL && root2==NULL)\\n            return true;\\n        if(root1 && root2 && root1->val == root2->val)\\n            return isMirror(root1->left,root2->right) && isMirror(root1->right,root2->left);\\n        \\n        return false;\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        return isMirror(root,root);\\n    }\\n\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n\\n\\n    bool isMirror(TreeNode* root1,TreeNode *root2){\\n        if(root1==NULL && root2==NULL)\\n            return true;\\n        if(root1 && root2 && root1->val == root2->val)\\n            return isMirror(root1->left,root2->right) && isMirror(root1->right,root2->left);\\n        \\n        return false;\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        return isMirror(root,root);\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 535045,
                "title": "py3-sol-in-just-few-lines-24ms-beats-97-63",
                "content": "```\\ndef isSymmetricBst(node1, node2):\\n    if node1==None and node2==None:\\n        return True\\n    elif node1==None or node2==None:\\n        return False\\n    else:\\n        return node1.val==node2.val and isSymmetricBst(node1.left,node2.right) and isSymmetricBst(node1.right, node2.left)\\n    \\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n        if not root:\\n            return True\\n#         since we need to check whether left is mirror to right, vice versa\\n        return isSymmetricBst(root.left, root.right)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef isSymmetricBst(node1, node2):\\n    if node1==None and node2==None:\\n        return True\\n    elif node1==None or node2==None:\\n        return False\\n    else:\\n        return node1.val==node2.val and isSymmetricBst(node1.left,node2.right) and isSymmetricBst(node1.right, node2.left)\\n    \\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n        if not root:\\n            return True\\n#         since we need to check whether left is mirror to right, vice versa\\n        return isSymmetricBst(root.left, root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518599,
                "title": "c-solution-easy-to-understand-o-n",
                "content": "# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isEqual(TreeNode* left, TreeNode* right) {\\n        if (!left && !right)\\n            return true;\\n        \\n        if (!left || !right || left->val != right->val)\\n            return false;\\n        \\n        return isEqual(left->left, right->right) && isEqual(left->right, right->left);\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        return isEqual(root->left, root->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isEqual(TreeNode* left, TreeNode* right) {\\n        if (!left && !right)\\n            return true;\\n        \\n        if (!left || !right || left->val != right->val)\\n            return false;\\n        \\n        return isEqual(left->left, right->right) && isEqual(left->right, right->left);\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        return isEqual(root->left, root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 33370,
                "title": "clean-iterative-solution-in-c",
                "content": "    /**\\n     * Definition for a binary tree node.\\n     * struct TreeNode {\\n     *     int val;\\n     *     TreeNode *left;\\n     *     TreeNode *right;\\n     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n        bool isSymmetric(TreeNode* root) {\\n            if(!root) return true;\\n            stack<TreeNode*> sk;\\n            sk.push(root->left);\\n            sk.push(root->right);\\n            \\n            TreeNode* pA, *pB;\\n            while(!sk.empty()) {\\n                pA = sk.top();\\n                sk.pop();\\n                pB = sk.top();\\n                sk.pop();\\n                \\n                if(!pA && !pB) continue;\\n                if(!pA || !pB) return false;\\n                if(pA->val != pB->val) return false;\\n                \\n                sk.push(pA->left);\\n                sk.push(pB->right);\\n                sk.push(pA->right);\\n                sk.push(pB->left);\\n            }\\n            \\n            return true;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isSymmetric(TreeNode* root) {\\n            if(!root) return true;\\n            stack<TreeNode*> sk;\\n            sk.push(root->left);\\n            sk.push(root->right);\\n            \\n            TreeNode* pA, *pB;\\n            while(!sk.empty()) {\\n                pA = sk.top();\\n                sk.pop();\\n                pB = sk.top();\\n                sk.pop();\\n                \\n                if(!pA && !pB) continue;\\n                if(!pA || !pB) return false;\\n                if(pA->val != pB->val) return false;\\n                \\n                sk.push(pA->left);\\n                sk.push(pB->right);\\n                sk.push(pA->right);\\n                sk.push(pB->left);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 33326,
                "title": "beautiful-recursive-and-iterative-solutions",
                "content": "Very simple ideas. Notice how both look similar to each other.\\n\\n    /**\\n     * Definition for binary tree\\n     * struct TreeNode {\\n     *     int val;\\n     *     TreeNode *left;\\n     *     TreeNode *right;\\n     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n     * };\\n     */\\n    #include<queue>\\n    using namespace std;\\n    typedef pair<TreeNode*,TreeNode*> nodepair;\\n    class Solution {\\n    public:\\n        bool isSymmetricRecursive(TreeNode*a,TreeNode*b){\\n            if(a){\\n                return b && a->val==b->val && \\n                    isSymmetricRecursive(a->left,b->right) &&\\n                    isSymmetricRecursive(a->right,b->left);\\n            }\\n            return !b;\\n        }\\n        bool isSymmetricRecursive(TreeNode*root){\\n            return !root || isSymmetricRecursive(root->left,root->right);\\n        }\\n        bool isSymmetric(TreeNode *root) {\\n            // Level-order BFS.\\n            queue<nodepair> q;\\n            if(root)\\n                q.push(make_pair(root->left,root->right));\\n            while(q.size()){\\n                nodepair p=q.front(); q.pop();\\n                if(p.first){\\n                    if(!p.second)return false;\\n                    if(p.first->val != p.second->val) return false;\\n                    // the order of children pushed to q is the key to the solution.\\n                    q.push(make_pair(p.first->left,p.second->right));\\n                    q.push(make_pair(p.first->right,p.second->left));\\n                }\\n                else if(p.second) return false;\\n            }\\n            return true;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isSymmetricRecursive(TreeNode*a,TreeNode*b){\\n            if(a){\\n                return b && a->val==b->val && \\n                    isSymmetricRecursive(a->left,b->right) &&\\n                    isSymmetricRecursive(a->right,b->left);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2817548,
                "title": "java",
                "content": "If you like it pls upvote\\n\\n```\\n\\n public boolean isSymmetric(TreeNode root) {\\n  if (root == null) return true;\\n  Stack<TreeNode> stack = new Stack<>();\\n  stack.push(root.left);\\n  stack.push(root.right);\\n\\n  while (!stack.isEmpty()) {\\n   TreeNode n1 = stack.pop();\\n   TreeNode n2 = stack.pop();\\n\\n   if (n1 == null && n2 == null) continue;\\n   if (n1 == null || n2 == null || n1.val != n2.val) return false;\\n\\n   stack.push(n1.left);\\n   stack.push(n2.right);\\n   stack.push(n1.right);\\n   stack.push(n2.left);\\n  }\\n\\n  return true;\\n }\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n public boolean isSymmetric(TreeNode root) {\\n  if (root == null) return true;\\n  Stack<TreeNode> stack = new Stack<>();\\n  stack.push(root.left);\\n  stack.push(root.right);\\n\\n  while (!stack.isEmpty()) {\\n   TreeNode n1 = stack.pop();\\n   TreeNode n2 = stack.pop();\\n\\n   if (n1 == null && n2 == null) continue;\\n   if (n1 == null || n2 == null || n1.val != n2.val) return false;\\n\\n   stack.push(n1.left);\\n   stack.push(n2.right);\\n   stack.push(n1.right);\\n   stack.push(n2.left);\\n  }\\n\\n  return true;\\n }\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1725862,
                "title": "recursively-and-iteratively-level-order-traversal-in-python",
                "content": "**Solution 1. recursively solution**\\n\\n```\\ndef isSymmetric(self, root):\\n\\tdef treeMatch(root1, root2):\\n\\t\\tif not root1 and not root2:\\n\\t\\t\\treturn True\\n\\t\\tif (root1 and not root2) or (root2 and not root1):\\n\\t\\t\\treturn False\\n\\t\\tif root1.val != root2.val:\\n\\t\\t\\treturn False\\n\\t\\treturn treeMatch(root1.left, root2.right) and treeMatch(root1.right, root2.left)\\n\\treturn treeMatch(root.left, root.right)\\n```\\n\\n**Solution 2. iteratively solution, using level order traversal**\\n```\\ndef isSymmetric(self, root):\\n\\n\\tdef levelSymetric(nums):\\n\\t\\treturn nums[:] == nums[::-1]\\n\\n\\ttree = [root]\\n\\twhile tree:\\n\\t\\tlevel = []\\n\\t\\tfor _ in range(len(tree)):\\n\\t\\t\\ttmp = tree.pop(0)\\n\\t\\t\\tif not tmp:\\n\\t\\t\\t\\tlevel.append(None)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tlevel.append(tmp.val)\\n\\t\\t\\t\\ttree.append(tmp.left)\\n\\t\\t\\t\\ttree.append(tmp.right)\\n\\t\\tif not levelSymetric(level):\\n\\t\\t\\treturn False\\n\\treturn True\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\ndef isSymmetric(self, root):\\n\\tdef treeMatch(root1, root2):\\n\\t\\tif not root1 and not root2:\\n\\t\\t\\treturn True\\n\\t\\tif (root1 and not root2) or (root2 and not root1):\\n\\t\\t\\treturn False\\n\\t\\tif root1.val != root2.val:\\n\\t\\t\\treturn False\\n\\t\\treturn treeMatch(root1.left, root2.right) and treeMatch(root1.right, root2.left)\\n\\treturn treeMatch(root.left, root.right)\\n```\n```\\ndef isSymmetric(self, root):\\n\\n\\tdef levelSymetric(nums):\\n\\t\\treturn nums[:] == nums[::-1]\\n\\n\\ttree = [root]\\n\\twhile tree:\\n\\t\\tlevel = []\\n\\t\\tfor _ in range(len(tree)):\\n\\t\\t\\ttmp = tree.pop(0)\\n\\t\\t\\tif not tmp:\\n\\t\\t\\t\\tlevel.append(None)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tlevel.append(tmp.val)\\n\\t\\t\\t\\ttree.append(tmp.left)\\n\\t\\t\\t\\ttree.append(tmp.right)\\n\\t\\tif not levelSymetric(level):\\n\\t\\t\\treturn False\\n\\treturn True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 642861,
                "title": "python-simple-bfs-iterative-approach-with-explaination",
                "content": "Think in pairs would really help. \\nTo check if a tree is symmetric, we need a BFS on 2 sides of symmetry: left and right. If left and right value match, we should proceed. \\nThe key is to add the children of left and right in the proper order: outter match, then inner match. Because we are queuing in pairs, the children of inner pairs will match with the inner grandchildren, and so are the outter pairs. \\n```\\nclass Solution(object):\\n    def isSymmetric(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        \\n        if not root:\\n            return True\\n        \\n        queue = [root.left, root.right]\\n        \\n        while len(queue) > 0:\\n            # pop 2 from queue\\n            left = queue.pop(0)\\n            right = queue.pop(0)\\n            \\n            # Evalate the pair\\n            if not left and not right:\\n                continue\\n            elif left and right and left.val == right.val:\\n                pass\\n            else:\\n                return False\\n            \\n            # Enqueue children\\n            queue.append(left.left)\\n            queue.append(right.right)\\n            queue.append(left.right)\\n            queue.append(right.left)\\n        \\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def isSymmetric(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        \\n        if not root:\\n            return True\\n        \\n        queue = [root.left, root.right]\\n        \\n        while len(queue) > 0:\\n            # pop 2 from queue\\n            left = queue.pop(0)\\n            right = queue.pop(0)\\n            \\n            # Evalate the pair\\n            if not left and not right:\\n                continue\\n            elif left and right and left.val == right.val:\\n                pass\\n            else:\\n                return False\\n            \\n            # Enqueue children\\n            queue.append(left.left)\\n            queue.append(right.right)\\n            queue.append(left.right)\\n            queue.append(right.left)\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 33252,
                "title": "java-solution-1ms-4-lines-code-recursive-easy-to-understand",
                "content": "\\tpublic static boolean isSymmetric(TreeNode root) {\\n\\t\\treturn isSymmetric(root,root);\\n\\t}\\n\\t\\n\\tpublic static boolean isSymmetric(TreeNode p, TreeNode q){\\n\\t\\tif(p==null && q==null) return true;\\n\\t\\tif(p==null || q==null) return false;\\n\\t\\t\\n\\t\\treturn p.val ==q.val&&isSymmetric(p.left,q.right)&&isSymmetric(p.right,q.left);\\n\\t}",
                "solutionTags": [],
                "code": "\\tpublic static boolean isSymmetric(TreeNode root) {\\n\\t\\treturn isSymmetric(root,root);\\n\\t}\\n\\t\\n\\tpublic static boolean isSymmetric(TreeNode p, TreeNode q){\\n\\t\\tif(p==null && q==null) return true;\\n\\t\\tif(p==null || q==null) return false;\\n\\t\\t\\n\\t\\treturn p.val ==q.val&&isSymmetric(p.left,q.right)&&isSymmetric(p.right,q.left);\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 33401,
                "title": "concise-recursive-java-solution",
                "content": "This method is my best recursive try. Use two TreeNode as parameters.\\n\\nIf you are willing to help, \\n\\nPlease go to https://oj.leetcode.com/discuss/24968/is-my-method-a-recursive-one-java-solution\\nto see my another recursive solution and give some comment on that recursive method.\\n   \\n\\n    public class Solution {\\n            public boolean isSymmetric(TreeNode root) {\\n                if(root==null){return true;}\\n                return isSymmetric(root.left, root.right);\\n            }\\n            \\n            private boolean isSymmetric(TreeNode a, TreeNode b){\\n                if(a==null&&b==null){return true;}\\n                if(a==null||b==null){return false;}\\n                if(a.val!=b.val){return false;}\\n                return isSymmetric(a.left,b.right)&&isSymmetric(a.right,b.left);\\n            }\\n        }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n            public boolean isSymmetric(TreeNode root) {\\n                if(root==null){return true;}",
                "codeTag": "Java"
            },
            {
                "id": 3931624,
                "title": "symmetric-tree-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool check(TreeNode* root1, TreeNode* root2)\\n    {\\n        if(root1==NULL && root2==NULL)\\n            return true;\\n        if(root1==NULL || root2==NULL)\\n            return false;\\n        if(root1->val==root2->val)\\n            return check(root1->left, root2->right) && check(root1->right, root2->left);\\n        return false;\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        return check(root->left, root->right);\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/21243a90-9cb4-4904-acec-45e72bc6ede1_1692455011.561149.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool check(TreeNode* root1, TreeNode* root2)\\n    {\\n        if(root1==NULL && root2==NULL)\\n            return true;\\n        if(root1==NULL || root2==NULL)\\n            return false;\\n        if(root1->val==root2->val)\\n            return check(root1->left, root2->right) && check(root1->right, root2->left);\\n        return false;\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        return check(root->left, root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3227769,
                "title": "java-solution-0ms-runtime-beats-100-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBy seeing the problem my first intuition was to use BFS to solve the problem,by taking a queue but as i approached the problem i understand that using DFS is more optimal and less complex to solve this problem.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere are two parts of the tree - the left one and the right one.\\n**Some Observations :**\\n- The `leftnode` of left subtree is equal to the `rightnode` of right subtree.\\n- Similarly the `rightnode` of left subtree is equal to the `leftnode` of right subtree.\\n\\nSo we can apply these recursively to check if the nodes are equal or not.\\nIf the tree is symmetric then the algorithm reaches the leaf nodes where each node is null, then we return `true`.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        if(root == null){\\n            return true;\\n        }\\n        return checkSymmetric(root.left,root.right);\\n    }\\n    public boolean checkSymmetric(TreeNode leftNode,TreeNode rightNode){\\n        if(leftNode == null && rightNode == null){\\n            return true;\\n        }\\n        if(leftNode == null ^ rightNode == null){\\n            return false;\\n        }\\n        if(leftNode.val != rightNode.val){\\n            return false;\\n        }\\n        return checkSymmetric(leftNode.left,rightNode.right) && checkSymmetric(leftNode.right,rightNode.left);\\n\\n    }\\n}\\n```\\nIf any doubt or suggestions, Please do comment :)\\n\\nPLEASE DO UPVOTE GUYS!!! :)\\n\\nThank You!!!",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        if(root == null){\\n            return true;\\n        }\\n        return checkSymmetric(root.left,root.right);\\n    }\\n    public boolean checkSymmetric(TreeNode leftNode,TreeNode rightNode){\\n        if(leftNode == null && rightNode == null){\\n            return true;\\n        }\\n        if(leftNode == null ^ rightNode == null){\\n            return false;\\n        }\\n        if(leftNode.val != rightNode.val){\\n            return false;\\n        }\\n        return checkSymmetric(leftNode.left,rightNode.right) && checkSymmetric(leftNode.right,rightNode.left);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2796828,
                "title": "0-ms100-iteration-recursion",
                "content": "#### Iteration\\n\\n```golang\\nfunc isSymmetric(root *TreeNode) bool {\\n    if root == nil {\\n\\t\\treturn true\\n\\t}\\n\\tvar stack []*TreeNode\\n\\tstack = append(stack, root.Left, root.Right)\\n\\tfor len(stack) > 0 {\\n\\t\\tl, r := stack[0], stack[1]\\n\\t\\tstack = stack[2:]\\n\\t\\tif l == nil && r == nil {\\n\\t\\t\\tcontinue\\n\\t\\t} else if (l == nil && r != nil) || l != nil && r == nil {\\n\\t\\t\\treturn false\\n\\t\\t} else if l.Val != r.Val {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t\\tstack = append(stack, l.Left, r.Right, l.Right, r.Left)\\n\\t}\\n\\treturn true\\n}\\n```\\n\\n#### Recursion\\n\\n```golang\\nfunc isSymmetric(root *TreeNode) bool {\\n\\tif root == nil {\\n\\t\\treturn true\\n\\t}\\n\\treturn helper(root.Left, root.Right)\\n}\\n\\nfunc helper(left *TreeNode, right *TreeNode) bool {\\n\\tif left == nil || right == nil {\\n\\t\\treturn left == right\\n\\t}\\n\\tif left.Val != right.Val {\\n\\t\\treturn false\\n\\t}\\n\\treturn helper(left.Left, right.Right) && helper(left.Right, right.Left)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```golang\\nfunc isSymmetric(root *TreeNode) bool {\\n    if root == nil {\\n\\t\\treturn true\\n\\t}\\n\\tvar stack []*TreeNode\\n\\tstack = append(stack, root.Left, root.Right)\\n\\tfor len(stack) > 0 {\\n\\t\\tl, r := stack[0], stack[1]\\n\\t\\tstack = stack[2:]\\n\\t\\tif l == nil && r == nil {\\n\\t\\t\\tcontinue\\n\\t\\t} else if (l == nil && r != nil) || l != nil && r == nil {\\n\\t\\t\\treturn false\\n\\t\\t} else if l.Val != r.Val {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t\\tstack = append(stack, l.Left, r.Right, l.Right, r.Left)\\n\\t}\\n\\treturn true\\n}\\n```\n```golang\\nfunc isSymmetric(root *TreeNode) bool {\\n\\tif root == nil {\\n\\t\\treturn true\\n\\t}\\n\\treturn helper(root.Left, root.Right)\\n}\\n\\nfunc helper(left *TreeNode, right *TreeNode) bool {\\n\\tif left == nil || right == nil {\\n\\t\\treturn left == right\\n\\t}\\n\\tif left.Val != right.Val {\\n\\t\\treturn false\\n\\t}\\n\\treturn helper(left.Left, right.Right) && helper(left.Right, right.Left)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2283175,
                "title": "0ms-java-10-lines-recursive-explaining-full-few-lines-easy-to-understand",
                "content": "So the solution is a little simple, \\nthe first step is  how to build the algorithm if two tree is the same (The link about that excercise https://leetcode.com/problems/same-tree/)  \\n\\nThis is the code to compare if two **tree is the same** (https://leetcode.com/problems/same-tree/discuss/32687/Five-line-Java-solution-with-recursion)\\n\\n```\\npublic boolean isSameTree(TreeNode p, TreeNode q) {\\n    if(p == null && q == null) return true;\\n    if(p == null || q == null) return false;\\n    if(p.val == q.val)\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    return false;\\n}\\n```\\n\\nSo, When we developed the excersice before so we only have a little change for do this excercise. The change is the method isSameTree, how the root in the middle have a mirror so in the part of isSameTree we only do a reverse so we compare left with right and right with left. \\n\\nAnd the call with the root \\n\\n```\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {        \\n        return isSameTree(root.right, root.left);\\n    }\\n    \\n   public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null) return true;\\n        if(p == null || q == null) return false;\\n        if(p.val == q.val)\\n            return isSameTree(p.left, q.right) && isSameTree(p.right, q.left);\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\npublic boolean isSameTree(TreeNode p, TreeNode q) {\\n    if(p == null && q == null) return true;\\n    if(p == null || q == null) return false;\\n    if(p.val == q.val)\\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n    return false;\\n}\\n```\n```\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {        \\n        return isSameTree(root.right, root.left);\\n    }\\n    \\n   public boolean isSameTree(TreeNode p, TreeNode q) {\\n        if(p == null && q == null) return true;\\n        if(p == null || q == null) return false;\\n        if(p.val == q.val)\\n            return isSameTree(p.left, q.right) && isSameTree(p.right, q.left);\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324014,
                "title": "swift-symmetric-tree-test-cases",
                "content": "```swift\\nclass Solution {\\n    func isSymmetric(_ root: TreeNode?) -> Bool {\\n        return check(root, root)\\n    }\\n    private final func check(_ l: TreeNode?, _ r: TreeNode?) -> Bool {\\n        if [l,r].allSatisfy({$0 == nil}) { return true }\\n        if l == nil || r == nil { return false }\\n        let n = (l?.left, r?.right)\\n        return l?.val == r?.val && check(n.0,n.1) && check(n.1,n.0)\\n    }\\n}\\n```\\n\\n```swift\\nimport XCTest\\n\\n// Executed 2 tests, with 0 failures (0 unexpected) in 0.065 (0.067) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test1() {\\n        let res = s.isSymmetric(.init([1,2,2,3,4,4,3]))\\n        XCTAssertEqual(res, true)\\n    }\\n    func test2() {\\n        let res = s.isSymmetric(.init([1,2,2,nil,3,nil,3]))\\n        XCTAssertEqual(res, false)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n```swift\\npublic class TreeNode {\\n    public var val: Int\\n    public var left: TreeNode?\\n    public var right: TreeNode?\\n    public init() { self.val = 0; self.left = nil; self.right = nil; }\\n    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n    }\\n    public init?(_ array: [Int?]) {\\n        var values = array\\n        guard !values.isEmpty, let head = values.removeFirst() else { return nil }\\n        \\n        val = head; left = nil; right = nil\\n        \\n        var queue = [self]\\n        while !queue.isEmpty {\\n            let node = queue.removeFirst()\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.left = TreeNode(val)\\n                queue.append(node.left!)\\n            }\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.right = TreeNode(val)\\n                queue.append(node.right!)\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func isSymmetric(_ root: TreeNode?) -> Bool {\\n        return check(root, root)\\n    }\\n    private final func check(_ l: TreeNode?, _ r: TreeNode?) -> Bool {\\n        if [l,r].allSatisfy({$0 == nil}) { return true }\\n        if l == nil || r == nil { return false }\\n        let n = (l?.left, r?.right)\\n        return l?.val == r?.val && check(n.0,n.1) && check(n.1,n.0)\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 2 tests, with 0 failures (0 unexpected) in 0.065 (0.067) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test1() {\\n        let res = s.isSymmetric(.init([1,2,2,3,4,4,3]))\\n        XCTAssertEqual(res, true)\\n    }\\n    func test2() {\\n        let res = s.isSymmetric(.init([1,2,2,nil,3,nil,3]))\\n        XCTAssertEqual(res, false)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\n```swift\\npublic class TreeNode {\\n    public var val: Int\\n    public var left: TreeNode?\\n    public var right: TreeNode?\\n    public init() { self.val = 0; self.left = nil; self.right = nil; }\\n    public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n    public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n    }\\n    public init?(_ array: [Int?]) {\\n        var values = array\\n        guard !values.isEmpty, let head = values.removeFirst() else { return nil }\\n        \\n        val = head; left = nil; right = nil\\n        \\n        var queue = [self]\\n        while !queue.isEmpty {\\n            let node = queue.removeFirst()\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.left = TreeNode(val)\\n                queue.append(node.left!)\\n            }\\n            if !values.isEmpty, let val = values.removeFirst() {\\n                node.right = TreeNode(val)\\n                queue.append(node.right!)\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 712470,
                "title": "javascript-iterative-commented",
                "content": "```\\n/**\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n*/\\nvar isSymmetric = function(root) {\\n//     if there is no root that means it is a symettric tree\\n    if(!root) return true\\n//     Start 2 queue one for the left banch and one for the right branch\\n    let q1 = [root.left], q2 = [root.right]\\n//     traverse through both branches, until they are both exhausted at the same time\\n    while (q1.length > 0 && q2.length > 0){\\n//         get current left and compare it to the right of each branch (this is how a mirror works)\\n        let node1 = q1.shift()\\n        let node2 = q2.shift()\\n//         if both are null at the same time, just move on\\n        if(!node1 && !node2) continue\\n//         if the current level is not symmetric (1 of them is null or they are not equal) return false\\n        if(!node1 || !node2 || node1.val !== node2.val) return false\\n//         to mentain comparing left to right (this is the tricky part, you have to push left and right & reverse for each branch)\\n        q1.push(node1.left)\\n        q2.push(node2.right)\\n        q1.push(node1.right)\\n        q2.push(node2.left)\\n    }\\n//     If both are exhausted at the same time and they are symmeteric return true\\n    return true\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n*/\\nvar isSymmetric = function(root) {\\n//     if there is no root that means it is a symettric tree\\n    if(!root) return true\\n//     Start 2 queue one for the left banch and one for the right branch\\n    let q1 = [root.left], q2 = [root.right]\\n//     traverse through both branches, until they are both exhausted at the same time\\n    while (q1.length > 0 && q2.length > 0){\\n//         get current left and compare it to the right of each branch (this is how a mirror works)\\n        let node1 = q1.shift()\\n        let node2 = q2.shift()\\n//         if both are null at the same time, just move on\\n        if(!node1 && !node2) continue\\n//         if the current level is not symmetric (1 of them is null or they are not equal) return false\\n        if(!node1 || !node2 || node1.val !== node2.val) return false\\n//         to mentain comparing left to right (this is the tricky part, you have to push left and right & reverse for each branch)\\n        q1.push(node1.left)\\n        q2.push(node2.right)\\n        q1.push(node1.right)\\n        q2.push(node2.left)\\n    }\\n//     If both are exhausted at the same time and they are symmeteric return true\\n    return true\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 447611,
                "title": "javascript-queue-in-10-lines",
                "content": "```\\nvar isSymmetric = function(root) {\\n  const q = [root, root];\\n  while (q.length) {\\n    const [l, r] = [q.shift(), q.shift()];\\n    if (!l && !r) continue;\\n    if (!!l !== !!r || l.val !== r.val) return false;\\n    q.push(l.left, r.right, l.right, r.left);\\n  }\\n  \\n  return true;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Queue"
                ],
                "code": "```\\nvar isSymmetric = function(root) {\\n  const q = [root, root];\\n  while (q.length) {\\n    const [l, r] = [q.shift(), q.shift()];\\n    if (!l && !r) continue;\\n    if (!!l !== !!r || l.val !== r.val) return false;\\n    q.push(l.left, r.right, l.right, r.left);\\n  }\\n  \\n  return true;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 33297,
                "title": "clean-java-solution",
                "content": "    public class Solution {\\n        public boolean isSymmetric(TreeNode root) {\\n            return isSymmetric(root, root);\\n        }\\n        \\n        boolean isSymmetric(TreeNode n1, TreeNode n2) {\\n            if(n1 == null && n2 == null) return true;\\n            if(n1 == null || n2 == null) return false;\\n            if(n1.val != n2.val) return false;\\n            return isSymmetric(n1.left, n2.right) && isSymmetric(n2.right, n1.left);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean isSymmetric(TreeNode root) {\\n            return isSymmetric(root, root);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 33295,
                "title": "0-ms-c-solution-donerecusively",
                "content": "\\n\\nbool isSymmetricRecursively(struct TreeNode* Lnode ,struct TreeNode* Rnode ){\\n    \\n    if(Lnode==NULL && Rnode==NULL)\\n        return true;\\n        \\n    if(Lnode==NULL || Rnode==NULL)\\n         return false ;\\n    \\n    \\n    return ((Lnode->val==Rnode->val) &&\\n                        isSymmetricRecursively(Lnode->left,Rnode->right) \\n                                   && isSymmetricRecursively(Lnode->right,Rnode->left )) ;\\n            \\n} \\n\\nbool isSymmetric(struct TreeNode* root) {\\n    \\n    if(root==NULL)\\n        return true;\\n        \\n       return isSymmetricRecursively(root->left ,root->right); \\n}",
                "solutionTags": [],
                "code": "\\n\\nbool isSymmetricRecursively(struct TreeNode* Lnode ,struct TreeNode* Rnode ){\\n    \\n    if(Lnode==NULL && Rnode==NULL)\\n        return true;\\n        \\n    if(Lnode==NULL || Rnode==NULL)\\n         return false ;\\n    \\n    \\n    return ((Lnode->val==Rnode->val) &&\\n                        isSymmetricRecursively(Lnode->left,Rnode->right) \\n                                   && isSymmetricRecursively(Lnode->right,Rnode->left )) ;\\n            \\n} \\n\\nbool isSymmetric(struct TreeNode* root) {\\n    \\n    if(root==NULL)\\n        return true;\\n        \\n       return isSymmetricRecursively(root->left ,root->right); \\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 3292699,
                "title": "iterative-bfs-0-ms-beats-100-cpp-submissions",
                "content": "# Intuition\\nChecking Tree\\'s symmetry comparing values of same level nodes in left and right subtrees.\\n\\n# Approach\\nPerform **Breadth-first search** using queue data structure to do a level order traversal of the tree comparing values of corresponding level nodes in left and right subtrees thus know whether symmetric or not. Pushing two copies of each node into the queue so the comparison of nodes that are non-direct children of each other is feasible. For instance, nodes seperated by null values.\\n\\n# Complexity\\n- Time complexity:\\nWorst case : O(N) where N is the number of nodes in the tree.\\n\\n- Space complexity:\\nO(W) where W is the maximum width of the tree.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n    if(!root) return 1;\\n    queue<TreeNode*> q;\\n    q.push(root), q.push(root);\\n    while(!q.empty()) {\\n        TreeNode* n(q.front());\\n        q.pop();\\n        TreeNode* n2(q.front());\\n        q.pop();\\n        if(n==nullptr and n2==nullptr) continue;\\n        if(n==nullptr or n2==nullptr or n->val!=n2->val) return 0;\\n        q.push(n->left), q.push(n2->right), q.push(n->right), q.push(n2->left);\\n    }\\n    return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n    if(!root) return 1;\\n    queue<TreeNode*> q;\\n    q.push(root), q.push(root);\\n    while(!q.empty()) {\\n        TreeNode* n(q.front());\\n        q.pop();\\n        TreeNode* n2(q.front());\\n        q.pop();\\n        if(n==nullptr and n2==nullptr) continue;\\n        if(n==nullptr or n2==nullptr or n->val!=n2->val) return 0;\\n        q.push(n->left), q.push(n2->right), q.push(n->right), q.push(n2->left);\\n    }\\n    return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290624,
                "title": "c-recursive-solution-easy-observation-day-13-successfull-leetcodedaily",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOn observing we clearly see we have to perform repetitive task for two roots which are mainly the left and right part we want to compare \\nSo we can divide our bigger problem into smaller problem of taking the whole tree and only compare the left and right part of the root  which hints us towards recursion.\\n\\n![subtrees.png](https://assets.leetcode.com/users/images/a72ac51c-afe5-4eee-982b-a88e3050788e_1678681623.2849514.png)\\n\\n \\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can observe that a binary tree is symmetric if the following conditions are met:\\n\\n- The value of the left subtree\\'s root node is equal to the value of the right subtree\\'s root node.\\n- The left subtree\\'s left child is identical to the right subtree\\'s right child.\\n- The left subtree\\'s right child is identical to the right subtree\\'s left child.\\n- Both the left and right subtrees are either empty (NULL) or non-empty.\\nIt is important to note that if only one of the left and right subtrees is non-empty, we cannot compare further as the identical part of the subtree is missing. Therefore, both subtrees must be either empty or non-empty in a symmetric binary tree.\\n\\n# Complexity\\n- ## Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**O(n)**, where n is the total number of nodes in the binary tree.  The time complexity of the symmetric() function is **O(n/2) because it only visits half of the nodes (in the best case when the tree is symmetric)** and in the worst case it **visits all nodes in the tree (when the tree is not symmetric) in this case it is 0(N)**.\\n\\n\\n- ## Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**O(h)**, where h is the height of the binary tree. This is because the recursive calls made by the solution consume memory on the call stack equal to the height of the tree. In the worst case when the binary tree is linear, **the height of the tree is equal to n, thus the space complexity becomes O(n)**. However, in the best case when the binary tree is **perfectly balanced, the height of the tree is log(n), thus the space complexity becomes O(log(n))**.\\n\\nFeel free to share any improvements that can be done to the code \\n# If u wish to connect with me [LinkedIn](https://www.linkedin.com/in/pawas-goyal/)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool symmetric(TreeNode *lst,TreeNode *rst){\\n        if(lst==NULL && rst==NULL)return true;\\n        if(lst==NULL || rst==NULL)return false;\\n        if(lst->val!=rst->val)return false;\\n        return symmetric(lst->left,rst->right)&&symmetric(lst->right,rst->left);\\n        \\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        if(!root || root->right==NULL && root->left==NULL)return true;\\n        return symmetric(root->left,root->right);\\n        \\n    }\\n};\\n```\\n![06351dc5-1e55-461d-acf2-60c9048c4726_1675165944.4721575.webp](https://assets.leetcode.com/users/images/6c305529-29d2-4a58-b09d-ee292769d403_1678682609.1504712.webp)\\n\\n# UPVOTE IF U LIKE THE SOLUTION\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool symmetric(TreeNode *lst,TreeNode *rst){\\n        if(lst==NULL && rst==NULL)return true;\\n        if(lst==NULL || rst==NULL)return false;\\n        if(lst->val!=rst->val)return false;\\n        return symmetric(lst->left,rst->right)&&symmetric(lst->right,rst->left);\\n        \\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        if(!root || root->right==NULL && root->left==NULL)return true;\\n        return symmetric(root->left,root->right);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2691813,
                "title": "easy-understand-recursion-c",
                "content": "```\\npublic:\\n    bool is_same(TreeNode *root1, TreeNode *root2){\\n        if(!root1 && !root2) return true;\\n        if((!root1 && root2) || (root1 && !root2)) return false;\\n        \\n        if(root1->val == root2->val) return is_same(root1->left , root2->right) && is_same(root1->right , root2->left);\\n        else return false;\\n    }\\n    \\n    bool isSymmetric(TreeNode* root) {\\n        return is_same(root->left, root->right);\\n    }\\n};\\n/* If you like it please upvote */\\n```\\nIf you like it please upvote",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\npublic:\\n    bool is_same(TreeNode *root1, TreeNode *root2){\\n        if(!root1 && !root2) return true;\\n        if((!root1 && root2) || (root1 && !root2)) return false;\\n        \\n        if(root1->val == root2->val) return is_same(root1->left , root2->right) && is_same(root1->right , root2->left);\\n        else return false;\\n    }\\n    \\n    bool isSymmetric(TreeNode* root) {\\n        return is_same(root->left, root->right);\\n    }\\n};\\n/* If you like it please upvote */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1774561,
                "title": "c-4-ms-easy-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isSymmetric(TreeNode* root) {\\n\\t\\t\\treturn (root==NULL || isSymmetricHelp(root->left,root->right));\\n\\t\\t}\\n\\t\\tbool isSymmetricHelp(TreeNode*left,TreeNode*right){\\n\\t\\t\\tif(left==NULL || right==NULL)\\n\\t\\t\\t\\treturn left==right;\\n\\t\\t\\tif(left->val != right->val)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\treturn isSymmetricHelp(left->left,right->right) && isSymmetricHelp(left->right,right->left);\\n\\t\\t}\\n\\t};\\n\\t\\n\\tTC : O(N)\\n\\n\\tfeel free to ask your doubts :)\\n\\tand pls upvote if it was helpful :)",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool isSymmetric(TreeNode* root) {\\n\\t\\t\\treturn (root==NULL || isSymmetricHelp(root->left,root->right));\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1628473,
                "title": "c-100-runtime-iterative-solution",
                "content": "```\\nbool isSymmetric(TreeNode* root) {\\n        if(!root) return true;\\n        queue<TreeNode*> queue;\\n        queue.push(root->left);\\n        queue.push(root->right);\\n        while(!queue.empty()) {\\n            TreeNode *left = queue.front(); queue.pop();\\n            TreeNode *right = queue.front(); queue.pop();\\n            if(!left && !right) continue;\\n            if(!left || !right) return false;\\n            if(left->val != right->val) return false;\\n            queue.push(left->left);\\n            queue.push(right->right);\\n            queue.push(left->right);\\n            queue.push(right->left);\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```\\nbool isSymmetric(TreeNode* root) {\\n        if(!root) return true;\\n        queue<TreeNode*> queue;\\n        queue.push(root->left);\\n        queue.push(root->right);\\n        while(!queue.empty()) {\\n            TreeNode *left = queue.front(); queue.pop();\\n            TreeNode *right = queue.front(); queue.pop();\\n            if(!left && !right) continue;\\n            if(!left || !right) return false;\\n            if(left->val != right->val) return false;\\n            queue.push(left->left);\\n            queue.push(right->right);\\n            queue.push(left->right);\\n            queue.push(right->left);\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 625640,
                "title": "in-c",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\nbool parallel_traverse(struct TreeNode* a, struct TreeNode* b)\\n{\\n    if (a == NULL && b == NULL)\\n        return true;\\n \\n    if (a == NULL || b == NULL)\\n        return false;\\n\\n    if (a->val != b->val)\\n        return false;\\n    \\n    return parallel_traverse(a->left, b->right) && parallel_traverse(a->right, b->left);\\n}\\n\\nbool isSymmetric(struct TreeNode* root)\\n{\\n    if (root == NULL)\\n        return true;\\n    return parallel_traverse(root->left, root->right);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\nbool parallel_traverse(struct TreeNode* a, struct TreeNode* b)\\n{\\n    if (a == NULL && b == NULL)\\n        return true;\\n \\n    if (a == NULL || b == NULL)\\n        return false;\\n\\n    if (a->val != b->val)\\n        return false;\\n    \\n    return parallel_traverse(a->left, b->right) && parallel_traverse(a->right, b->left);\\n}\\n\\nbool isSymmetric(struct TreeNode* root)\\n{\\n    if (root == NULL)\\n        return true;\\n    return parallel_traverse(root->left, root->right);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 182013,
                "title": "javascript",
                "content": "```\\nvar isSymmetric = function(root) {\\n    if(!root) \\n        return true;\\n    return dfs(root.left, root.right);\\n    \\n    function dfs(leftNode, rightNode) {\\n        if (!leftNode && !rightNode) {\\n            return true;\\n        }\\n        if(leftNode && !rightNode || !leftNode && rightNode || leftNode.val !== rightNode.val) {\\n            return false;\\n        }\\n        return dfs(leftNode.right, rightNode.left) && dfs(leftNode.left, rightNode.right);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar isSymmetric = function(root) {\\n    if(!root) \\n        return true;\\n    return dfs(root.left, root.right);\\n    \\n    function dfs(leftNode, rightNode) {\\n        if (!leftNode && !rightNode) {\\n            return true;\\n        }\\n        if(leftNode && !rightNode || !leftNode && rightNode || leftNode.val !== rightNode.val) {\\n            return false;\\n        }\\n        return dfs(leftNode.right, rightNode.left) && dfs(leftNode.left, rightNode.right);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 33305,
                "title": "recursive-and-non-recursive-solutions-in-python",
                "content": "Recursive solution (68ms):\\n\\n    class Solution(object):\\n        def isSymmetric(self, root):\\n            if not root:\\n                return True\\n            return self.equals(root.left, root.right)\\n        \\n        def equals(self, node1, node2):\\n            if not node1 and not node2:\\n                return True\\n            elif node1 and node2 and node1.val == node2.val:\\n                return self.equals(node1.left, node2.right) and self.equals(node1.right, node2.left)\\n            else:\\n                return False\\n\\nNon-Recursive solution (52ms):\\n\\n    class Solution(object):\\n        def isSymmetric(self, root):\\n            if not root:\\n                return True\\n            stack = []\\n            stack.append((root.left, root.right))\\n            \\n            while stack:\\n                left, right = stack.pop()\\n                if not left and not right:\\n                    continue\\n                elif left and right and left.val == right.val:\\n                    stack.append((left.left, right.right))\\n                    stack.append((left.right, right.left))\\n                else:\\n                    return False\\n            \\n            return True",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "Recursive solution (68ms):\\n\\n    class Solution(object):\\n        def isSymmetric(self, root):\\n            if not root:\\n                return True\\n            return self.equals(root.left, root.right)\\n        \\n        def equals(self, node1, node2):\\n            if not node1 and not node2:\\n                return True\\n            elif node1 and node2 and node1.val == node2.val:\\n                return self.equals(node1.left, node2.right) and self.equals(node1.right, node2.left)\\n            else:\\n                return False\\n\\nNon-Recursive solution (52ms):\\n\\n    class Solution(object):\\n        def isSymmetric(self, root):\\n            if not root:\\n                return True\\n            stack = []\\n            stack.append((root.left, root.right))\\n            \\n            while stack:\\n                left, right = stack.pop()\\n                if not left and not right:\\n                    continue\\n                elif left and right and left.val == right.val:\\n                    stack.append((left.left, right.right))\\n                    stack.append((left.right, right.left))\\n                else:\\n                    return False\\n            \\n            return True",
                "codeTag": "Java"
            },
            {
                "id": 33359,
                "title": "tree-versions-in-java-recursion-optimized-tail-recursion-and-pre-order-iteration",
                "content": "The most simple version is normal recursion:\\n\\n    public class Solution {\\n    \\tpublic boolean isSymmetric(TreeNode root) {\\n    \\t\\treturn this.isMirror(root, root);\\n    \\t}\\n    \\n    \\tprivate boolean isMirror(TreeNode t0, TreeNode t1) {\\n\\t\\tif (t0 == null || t1 == null) {\\n\\t\\t\\treturn t0 == t1;\\n\\t\\t}\\n\\t\\treturn t0.val == t1.val\\n\\t\\t\\t\\t&& this.isMirror(t0.left, t1.right)\\n\\t\\t\\t\\t&& this.isMirror(t0.right, t1.left);\\n    \\t}\\n    }\\n\\nAnd the last recursive call in method isMirror() above can be optimized to loop, this will reduce the actual recursive calls:\\n\\n    public class Solution {\\n    \\tpublic boolean isSymmetric(TreeNode root) {\\n    \\t\\treturn this.isMirror(root, root);\\n    \\t}\\n    \\n    \\tprivate boolean isMirror(TreeNode t0, TreeNode t1) {\\n    \\t\\twhile (t0 != null && t1 != null) {\\n    \\t\\t\\tif (t0.val != t1.val || !this.isMirror(t0.left, t1.right)) {\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t\\t}\\n    \\t\\t\\tt0 = t0.right;\\n    \\t\\t\\tt1 = t1.left;\\n    \\t\\t}\\n    \\t\\treturn t0 == t1;\\n    \\t}\\n    }\\nThere are two kinds of iteration at least. The BFS-like iteration, which is based on queue, has a space complexity of O(n). And the DFS-like iteration, which is based on stack, has a better space complexity of O(log n).\\n\\nHere is the DFS-like pre-order iteration:\\n\\n    public class Solution {\\n    \\tpublic boolean isSymmetric(TreeNode root) {\\n    \\t\\tDeque<TreeNode[]> stack = new LinkedList<>();\\n    \\t\\tstack.push(new TreeNode[]{root, root});\\n    \\t\\twhile (!stack.isEmpty()) {\\n    \\t\\t\\tTreeNode[] pair = stack.pop();\\n    \\t\\t\\tTreeNode t0 = pair[0], t1 = pair[1];\\n    \\t\\t\\tif (t0 == null && t1 == null) {\\n    \\t\\t\\t\\tcontinue;\\n    \\t\\t\\t}\\n    \\t\\t\\tif (t0 == null || t1 == null || t0.val != t1.val) {\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t\\t}\\n    \\t\\t\\tstack.push(new TreeNode[]{t0.left, t1.right});\\n    \\t\\t\\tstack.push(new TreeNode[]{t0.right, t1.left});\\n    \\t\\t}\\n    \\t\\treturn true;\\n    \\t}\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n    \\tpublic boolean isSymmetric(TreeNode root) {\\n    \\t\\treturn this.isMirror(root, root);\\n    \\t}",
                "codeTag": "Java"
            },
            {
                "id": 33193,
                "title": "my-ac-code-is-there-a-better-method",
                "content": "     public boolean checkSymmetric(TreeNode lsubTree,TreeNode rsubTree){\\n        if(lsubTree==null&&rsubTree==null) return true;\\n        else if(lsubTree!=null&&rsubTree==null) return false;\\n        else if(lsubTree==null&&rsubTree!=null) return false;\\n        else if(lsubTree.val!=rsubTree.val) return false;\\n        boolean lt=checkSymmetric(lsubTree.left,rsubTree.right);\\n        boolean rt=checkSymmetric(lsubTree.right,rsubTree.left);\\n        return lt&&rt;\\n    }\\n    public boolean isSymmetric(TreeNode root) {\\n        if(root==null) return true;\\n        return checkSymmetric(root.left,root.right);\\n    }",
                "solutionTags": [],
                "code": "     public boolean checkSymmetric(TreeNode lsubTree,TreeNode rsubTree){\\n        if(lsubTree==null&&rsubTree==null) return true;\\n        else if(lsubTree!=null&&rsubTree==null) return false;\\n        else if(lsubTree==null&&rsubTree!=null) return false;\\n        else if(lsubTree.val!=rsubTree.val) return false;\\n        boolean lt=checkSymmetric(lsubTree.left,rsubTree.right);\\n        boolean rt=checkSymmetric(lsubTree.right,rsubTree.left);\\n        return lt&&rt;\\n    }\\n    public boolean isSymmetric(TreeNode root) {\\n        if(root==null) return true;\\n        return checkSymmetric(root.left,root.right);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2927946,
                "title": "101-symmetric-tree-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- At first i was thinking to solve it with iterative approach, but it would be costly to use a queue for this, so i thought to use the recursive approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We use recursive approach to solve this problem, the tree would be symmetric if it\\'s foldable you know, so we should start by checking first if the root is null so we have a symmetric tree.\\n\\n- A tree would only be foldable - symmetric - if the left sub-tree leftNode is equivalent to the right sub-tree rightNode and left sub-tree rightNode is equivalent to right sub-tree leftNode.\\n- so we build isMirror function that takes two nodes the left sub-tree parent and the right sub-tree parent and start the comparison as mentioned above in the second point.\\n- If there is any failure for any tested condition the function will be terminated and return false so we don\\'t have to check any more, that\\'s because we are processing the tree level by level, so that\\'s why we will be using o(h) where is h is the height of the tree at worst case.\\n# Complexity\\n- Time complexity: O(n) where is n is the nodes number because we check every single node.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(h) where is h is the tree height.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar isSymmetric = function(root) {\\n    if(root == null) return true;\\n    return isMirror(root.left, root.right);\\n}; \\n\\nconst isMirror = (leftNode, rightNode) => {\\n    if(leftNode == null && rightNode == null) return true;\\n    if(leftNode == null || rightNode == null) return false;\\n    if(leftNode.val !== rightNode.val) return false;\\n   \\n    return isMirror(leftNode.left, rightNode.right) && isMirror(leftNode.right, rightNode.left);\\n}\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar isSymmetric = function(root) {\\n    if(root == null) return true;\\n    return isMirror(root.left, root.right);\\n}; \\n\\nconst isMirror = (leftNode, rightNode) => {\\n    if(leftNode == null && rightNode == null) return true;\\n    if(leftNode == null || rightNode == null) return false;\\n    if(leftNode.val !== rightNode.val) return false;\\n   \\n    return isMirror(leftNode.left, rightNode.right) && isMirror(leftNode.right, rightNode.left);\\n}\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2445423,
                "title": "c-7ms-shortest-solution",
                "content": "This question is just an another part of checking two same trees.we treat both left and right subtrees as different. Here we will need to compare left value of one tree with right value of another tree.\\n```\\nclass Solution {\\nprivate:\\n    bool isSameTree(TreeNode *p, TreeNode *q) {\\n        if (p == NULL || q == NULL) return (p == q);\\n        return (p->val == q->val && isSameTree(p->left, q->right) && isSameTree(p->right, q->left));\\n    }\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        return isSameTree(root->left,root->right);\\n    }\\n};\\n```\\n**-->UPVOTE IF FOUND USEFUL OR LEARNED ANYTHING!!!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isSameTree(TreeNode *p, TreeNode *q) {\\n        if (p == NULL || q == NULL) return (p == q);\\n        return (p->val == q->val && isSameTree(p->left, q->right) && isSameTree(p->right, q->left));\\n    }\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        return isSameTree(root->left,root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 33342,
                "title": "7-lines-c-solution",
                "content": "/*\\nThe key is to traverse the left subtree with order root -> left -> right, \\nand the right subtree with order root -> right-> left\\n*/\\n\\n\\n    bool isSymmetric(TreeNode* root) {\\n        if (!root) return true;\\n        return isSymmetric_helper(root->left, root->right);\\n    }\\n    bool isSymmetric_helper(TreeNode* root1, TreeNode* root2) {\\n        if (root1==NULL && root2==NULL) return true;\\n        if (root1==NULL || root2==NULL) return false;\\n        if (root1->val != root2->val) return false;\\n        return isSymmetric_helper(root1->left, root2->right) && isSymmetric_helper(root1->right, root2->left);\\n    }",
                "solutionTags": [],
                "code": "/*\\nThe key is to traverse the left subtree with order root -> left -> right, \\nand the right subtree with order root -> right-> left\\n*/\\n\\n\\n    bool isSymmetric(TreeNode* root) {\\n        if (!root) return true;\\n        return isSymmetric_helper(root->left, root->right);\\n    }\\n    bool isSymmetric_helper(TreeNode* root1, TreeNode* root2) {\\n        if (root1==NULL && root2==NULL) return true;\\n        if (root1==NULL || root2==NULL) return false;\\n        if (root1->val != root2->val) return false;\\n        return isSymmetric_helper(root1->left, root2->right) && isSymmetric_helper(root1->right, root2->left);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 33352,
                "title": "a-simple-python-recursive-solution-o-n-60ms",
                "content": "    # Definition for a binary tree node.\\n    # class TreeNode:\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution:\\n        # @param {TreeNode} root\\n        # @return {boolean}\\n        def isSymmetric(self, root):\\n            if not root:\\n                return True\\n    \\n            return self.isSymmetricTree(root.left, root.right)\\n    \\n        def isSymmetricTree(self, node1, node2):\\n            if node1 and node2:\\n                return node1.val == node2.val and self.isSymmetricTree(node1.left, node2.right) and self.isSymmetricTree(node1.right, node2.left)\\n            else:\\n                return node1 == node2",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {TreeNode}",
                "codeTag": "Java"
            },
            {
                "id": 33406,
                "title": "two-simple-accepted-java-solutions-recursion-and-iteration",
                "content": "The idea is simple. Traverse both on left an right branches of the root symmetricaly and check if the values are equal.\\n\\n\\nRecursion.\\n\\n    public boolean isSymmetric(TreeNode root) {\\n        return root == null ? true : symmetric(root.left, root.right);\\n    }\\n\\t\\n\\tpublic boolean symmetric(TreeNode left, TreeNode right) {\\n        if (left == null && right == null) {\\n        \\treturn true;\\n        } else if (left != null && right != null && left.val == right.val) {\\n        \\treturn symmetric(left.left, right.right) && symmetric(left.right, right.left);\\n        } else {\\n        \\treturn false;\\n        }\\n    }\\n\\n\\n\\nIteration.\\n\\n    public boolean isSymmetric(TreeNode root) {\\n        if (root == null || (root.left == null && root.right == null)) return true;\\n        Stack<TreeNode> L = new Stack<TreeNode>();\\n        Stack<TreeNode> R = new Stack<TreeNode>();\\n        L.push(root.left);\\n        R.push(root.right);\\n        \\n        while(!L.isEmpty() && !R.isEmpty()) {\\n        \\tTreeNode left = L.pop();\\n        \\tTreeNode right = R.pop();\\n        \\tif (left == null && right == null) continue;\\n        \\tif (left != null && right != null && left.val == right.val) {\\n        \\t\\tL.push(left.left);\\n        \\t\\tR.push(right.right);\\n        \\t\\tL.push(left.right);\\n        \\t\\tR.push(right.left);\\n        \\t\\tcontinue;\\n        \\t}\\n        \\treturn false;\\n        }\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "The idea is simple. Traverse both on left an right branches of the root symmetricaly and check if the values are equal.\\n\\n\\nRecursion.\\n\\n    public boolean isSymmetric(TreeNode root) {\\n        return root == null ? true : symmetric(root.left, root.right);\\n    }\\n\\t\\n\\tpublic boolean symmetric(TreeNode left, TreeNode right) {\\n        if (left == null && right == null) {\\n        \\treturn true;\\n        } else if (left != null && right != null && left.val == right.val) {\\n        \\treturn symmetric(left.left, right.right) && symmetric(left.right, right.left);\\n        } else {\\n        \\treturn false;\\n        }\\n    }\\n\\n\\n\\nIteration.\\n\\n    public boolean isSymmetric(TreeNode root) {\\n        if (root == null || (root.left == null && root.right == null)) return true;\\n        Stack<TreeNode> L = new Stack<TreeNode>();\\n        Stack<TreeNode> R = new Stack<TreeNode>();\\n        L.push(root.left);\\n        R.push(root.right);\\n        \\n        while(!L.isEmpty() && !R.isEmpty()) {\\n        \\tTreeNode left = L.pop();\\n        \\tTreeNode right = R.pop();\\n        \\tif (left == null && right == null) continue;\\n        \\tif (left != null && right != null && left.val == right.val) {\\n        \\t\\tL.push(left.left);\\n        \\t\\tR.push(right.right);\\n        \\t\\tL.push(left.right);\\n        \\t\\tR.push(right.left);\\n        \\t\\tcontinue;\\n        \\t}\\n        \\treturn false;\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 33417,
                "title": "my-16ms-c-solution",
                "content": "    \\n    bool DFS(TreeNode *left,TreeNode *right)\\n    {\\n        if(left == NULL || right == NULL)\\n            return left == right;\\n        return (left->val == right->val)&DFS(left->right,right->left)&DFS(left->left,right->right);\\n    }\\n    bool isSymmetric(TreeNode *root) {\\n        if(root == NULL)\\n            return true;\\n        return DFS(root->left,root->right);\\n    }",
                "solutionTags": [],
                "code": "    \\n    bool DFS(TreeNode *left,TreeNode *right)\\n    {\\n        if(left == NULL || right == NULL)\\n            return left == right;\\n        return (left->val == right->val)&DFS(left->right,right->left)&DFS(left->left,right->right);\\n    }\\n    bool isSymmetric(TreeNode *root) {\\n        if(root == NULL)\\n            return true;\\n        return DFS(root->left,root->right);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3290155,
                "title": "day-72-with-diagram-iterative-and-recursive-easiest-beginner-friendly-sol",
                "content": "**NOTE - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Intuition of this Problem:\\nWe need to validate only 3 conditions including base condition and recursively call to the function:\\n- If both \"leftRoot\" and \"rightRoot\" are null, return true\\n- If only one of \"leftRoot\" or \"rightRoot\" is null, return false\\n- If \"leftRoot\" and \"rightRoot\" are not null and their values are not equal, return false\\n- If \"leftRoot\" and \"rightRoot\" are not null and their values are equal, recursively call \"isTreeSymmetric\" on the left child of \"leftRoot\" and the right child of \"rightRoot\", and the right child of \"leftRoot\" and the left child of \"rightRoot\"\\n\\n![WhatsApp Image 2023-01-24 at 6.54.24 PM.jpeg](https://assets.leetcode.com/users/images/3ce67a24-c51f-4cff-a5ac-58425726b650_1674566690.8242106.jpeg)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach for this Problem:\\n1. Define a function \"isTreeSymmetric\" that takes in two TreeNode pointers as inputs, \"leftRoot\" and \"rightRoot\"\\n2. If both \"leftRoot\" and \"rightRoot\" are null, return true\\n3. If only one of \"leftRoot\" or \"rightRoot\" is null, return false\\n4. If \"leftRoot\" and \"rightRoot\" are not null and their values are not equal, return false\\n5. If \"leftRoot\" and \"rightRoot\" are not null and their values are equal, recursively call \"isTreeSymmetric\" on the left child of \"leftRoot\" and the right child of \"rightRoot\", and the right child of \"leftRoot\" and the left child of \"rightRoot\"\\n6. Return true if both recursive calls return true, else return false\\n7. Define a function \"isSymmetric\" that takes in a TreeNode pointer \"root\" as input\\n8. Call \"isTreeSymmetric\" on the left child of \"root\" and the right child of \"root\" and return the result\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Humble Request:\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Code:\\n```C++ []\\n//Iterative approach\\n// TC - O(n), where n is the number of nodes in the binary tree. This is because the code visits each node in the binary tree once, and the while loop iterates over all nodes in the worst-case scenario.\\n// SC - O(n), where n is the number of nodes in the binary tree. This is because the code uses a queue to store nodes in a level-by-level manner, and in the worst-case scenario, the queue will contain all the nodes of the binary tree. Therefore, the space required by the queue will be proportional to the number of nodes in the tree, leading to O(n) space complexity.\\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        if (root == nullptr)\\n            return true;\\n        queue<TreeNode*> q;\\n        q.push(root -> left);\\n        q.push(root -> right);\\n        while (!q.empty()) {\\n            TreeNode *leftRoot = q.front();\\n            q.pop();\\n            TreeNode *rightRoot = q.front();\\n            q.pop();\\n            if (leftRoot == nullptr && rightRoot == nullptr)\\n                continue;\\n            if ((leftRoot == nullptr && rightRoot != nullptr) || (leftRoot != nullptr && rightRoot == nullptr))\\n                return false;\\n            if (leftRoot -> val != rightRoot -> val)\\n                return false;\\n            q.push(leftRoot -> left);\\n            q.push(rightRoot -> right);\\n            q.push(leftRoot -> right);\\n            q.push(rightRoot -> left);\\n        }\\n        return true;\\n    }\\n};\\n```\\n```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isTreeSymmetric(TreeNode* leftRoot, TreeNode* rightRoot){\\n        if(leftRoot == nullptr && rightRoot == nullptr)\\n            return true;\\n        if((leftRoot == nullptr && rightRoot != nullptr)  || (leftRoot != nullptr && rightRoot == nullptr))\\n            return false;\\n        if(leftRoot -> val != rightRoot -> val)\\n            return false;\\n        return isTreeSymmetric(leftRoot -> left, rightRoot -> right) && isTreeSymmetric(leftRoot -> right, rightRoot -> left);\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        return isTreeSymmetric(root -> left, root -> right);\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean isTreeSymmetric(TreeNode leftRoot, TreeNode rightRoot){\\n        if(leftRoot == null && rightRoot == null)\\n            return true;\\n        if((leftRoot == null && rightRoot != null)  || (leftRoot != null && rightRoot == null))\\n            return false;\\n        if(leftRoot.val != rightRoot.val)\\n            return false;\\n        return isTreeSymmetric(leftRoot.left, rightRoot.right) && isTreeSymmetric(leftRoot.right, rightRoot.left);\\n    }\\n    public boolean isSymmetric(TreeNode root) {\\n        return isTreeSymmetric(root.left, root.right);\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def isTreeSymmetric(self, leftRoot, rightRoot):\\n        if leftRoot is None and rightRoot is None:\\n            return True\\n        if (leftRoot is None and rightRoot is not None) or (leftRoot is not None and rightRoot is None):\\n            return False\\n        if leftRoot.val != rightRoot.val:\\n            return False\\n        return self.isTreeSymmetric(leftRoot.left, rightRoot.right) and self.isTreeSymmetric(leftRoot.right, rightRoot.left)\\n    def isSymmetric(self, root):\\n        return self.isTreeSymmetric(root.left, root.right)\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(n)**, where n is the total number of nodes in the binary tree. This is because the solution visits each node once and compares its values with the corresponding symmetric node, thus the function isTreeSymmetric() is called on each node at most once. The time complexity of the isTreeSymmetric() function is O(n/2) because it only visits half of the nodes (in the best case when the tree is symmetric) and in the worst case it visits all nodes in the tree (when the tree is not symmetric).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(h)**, where h is the height of the binary tree. This is because the recursive calls made by the solution consume memory on the call stack equal to the height of the tree. In the worst case when the binary tree is linear, the height of the tree is equal to n, thus the space complexity becomes O(n). However, in the best case when the binary tree is perfectly balanced, the height of the tree is log(n), thus the space complexity becomes O(log(n)).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```C++ []\\n//Iterative approach\\n// TC - O(n), where n is the number of nodes in the binary tree. This is because the code visits each node in the binary tree once, and the while loop iterates over all nodes in the worst-case scenario.\\n// SC - O(n), where n is the number of nodes in the binary tree. This is because the code uses a queue to store nodes in a level-by-level manner, and in the worst-case scenario, the queue will contain all the nodes of the binary tree. Therefore, the space required by the queue will be proportional to the number of nodes in the tree, leading to O(n) space complexity.\\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        if (root == nullptr)\\n            return true;\\n        queue<TreeNode*> q;\\n        q.push(root -> left);\\n        q.push(root -> right);\\n        while (!q.empty()) {\\n            TreeNode *leftRoot = q.front();\\n            q.pop();\\n            TreeNode *rightRoot = q.front();\\n            q.pop();\\n            if (leftRoot == nullptr && rightRoot == nullptr)\\n                continue;\\n            if ((leftRoot == nullptr && rightRoot != nullptr) || (leftRoot != nullptr && rightRoot == nullptr))\\n                return false;\\n            if (leftRoot -> val != rightRoot -> val)\\n                return false;\\n            q.push(leftRoot -> left);\\n            q.push(rightRoot -> right);\\n            q.push(leftRoot -> right);\\n            q.push(rightRoot -> left);\\n        }\\n        return true;\\n    }\\n};\\n```\n```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isTreeSymmetric(TreeNode* leftRoot, TreeNode* rightRoot){\\n        if(leftRoot == nullptr && rightRoot == nullptr)\\n            return true;\\n        if((leftRoot == nullptr && rightRoot != nullptr)  || (leftRoot != nullptr && rightRoot == nullptr))\\n            return false;\\n        if(leftRoot -> val != rightRoot -> val)\\n            return false;\\n        return isTreeSymmetric(leftRoot -> left, rightRoot -> right) && isTreeSymmetric(leftRoot -> right, rightRoot -> left);\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        return isTreeSymmetric(root -> left, root -> right);\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean isTreeSymmetric(TreeNode leftRoot, TreeNode rightRoot){\\n        if(leftRoot == null && rightRoot == null)\\n            return true;\\n        if((leftRoot == null && rightRoot != null)  || (leftRoot != null && rightRoot == null))\\n            return false;\\n        if(leftRoot.val != rightRoot.val)\\n            return false;\\n        return isTreeSymmetric(leftRoot.left, rightRoot.right) && isTreeSymmetric(leftRoot.right, rightRoot.left);\\n    }\\n    public boolean isSymmetric(TreeNode root) {\\n        return isTreeSymmetric(root.left, root.right);\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def isTreeSymmetric(self, leftRoot, rightRoot):\\n        if leftRoot is None and rightRoot is None:\\n            return True\\n        if (leftRoot is None and rightRoot is not None) or (leftRoot is not None and rightRoot is None):\\n            return False\\n        if leftRoot.val != rightRoot.val:\\n            return False\\n        return self.isTreeSymmetric(leftRoot.left, rightRoot.right) and self.isTreeSymmetric(leftRoot.right, rightRoot.left)\\n    def isSymmetric(self, root):\\n        return self.isTreeSymmetric(root.left, root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196119,
                "title": "easy-c-solution-dfs-beats-100-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Do preorder traversal in the left subtree (node-left-right) and preorder traversal in reverse manner (node-right-left) in the right subtree. \\n2. At any point, if we find any dissimilarity then the tree is not symmetric, otherwise it is symmetric.\\n\\n# Complexity\\n- Time complexity:\\n    O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:\\n  O(h)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(TreeNode *root1, TreeNode *root2){\\n        if(root1==NULL && root2==NULL) return true;\\n        if(!(root1 && root2)) return false;\\n\\n        if(root1->val!=root2->val) return false;\\n        bool l=check(root1->left,root2->right);\\n        bool r=check(root1->right,root2->left);\\n        return l&&r;\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        return check(root->left,root->right);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(TreeNode *root1, TreeNode *root2){\\n        if(root1==NULL && root2==NULL) return true;\\n        if(!(root1 && root2)) return false;\\n\\n        if(root1->val!=root2->val) return false;\\n        bool l=check(root1->left,root2->right);\\n        bool r=check(root1->right,root2->left);\\n        return l&&r;\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        return check(root->left,root->right);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3059196,
                "title": "tree-100-beat-0ms-runtime-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool tra(TreeNode* root1,TreeNode* root2){\\n        if(root1==0&&root2==0){\\n            return true;\\n        }\\n        if(root1==0||root2==0||root1->val!=root2->val){\\n            return false;\\n        }\\n        return tra(root1->left,root2->right)&&tra(root1->right,root2->left);\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        return tra(root->left,root->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool tra(TreeNode* root1,TreeNode* root2){\\n        if(root1==0&&root2==0){\\n            return true;\\n        }\\n        if(root1==0||root2==0||root1->val!=root2->val){\\n            return false;\\n        }\\n        return tra(root1->left,root2->right)&&tra(root1->right,root2->left);\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        return tra(root->left,root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2023412,
                "title": "clean-and-easy-recursive-and-iterative-solutions",
                "content": "**Recursive**\\n\\n```\\nvar isSymmetric = function(root) {\\n    \\n    const helper = (node1, node2) => {\\n        if(node1 === null && node2 === null)\\n            return true;\\n        \\n        if(node1 === null || node2 === null)\\n            return false;\\n        \\n        if(node1.val === node2.val) {\\n            return helper(node1.left, node2.right) && helper(node1.right, node2.left);\\n        } else {\\n            return false;\\n        }\\n    }\\n    \\n    return helper(root.left, root.right);\\n};\\n```\\n\\n**Iterative**\\n\\n```\\nvar isSymmetric = function(root) {\\n    \\n    const arr = [];\\n    \\n    arr.push([root.left, root.right]);\\n    \\n    while(arr.length) {\\n        let [node1, node2] = arr.pop();\\n        \\n        if(node1 === null && node2 === null)\\n            continue;\\n        \\n        if(node1 === null || node2 === null)\\n            return false;\\n        \\n        if(node1.val === node2.val) {\\n            arr.push([node1.left, node2.right]);\\n            arr.push([node1.right, node2.left]);\\n        } else {\\n            return false;\\n        }\\n    }\\n    \\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nvar isSymmetric = function(root) {\\n    \\n    const helper = (node1, node2) => {\\n        if(node1 === null && node2 === null)\\n            return true;\\n        \\n        if(node1 === null || node2 === null)\\n            return false;\\n        \\n        if(node1.val === node2.val) {\\n            return helper(node1.left, node2.right) && helper(node1.right, node2.left);\\n        } else {\\n            return false;\\n        }\\n    }\\n    \\n    return helper(root.left, root.right);\\n};\\n```\n```\\nvar isSymmetric = function(root) {\\n    \\n    const arr = [];\\n    \\n    arr.push([root.left, root.right]);\\n    \\n    while(arr.length) {\\n        let [node1, node2] = arr.pop();\\n        \\n        if(node1 === null && node2 === null)\\n            continue;\\n        \\n        if(node1 === null || node2 === null)\\n            return false;\\n        \\n        if(node1.val === node2.val) {\\n            arr.push([node1.left, node2.right]);\\n            arr.push([node1.right, node2.left]);\\n        } else {\\n            return false;\\n        }\\n    }\\n    \\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1448819,
                "title": "recursive-and-iterative-js-versions",
                "content": "Recursive:\\n```\\nvar isSymmetric = function(root) {\\n/**\\n * Compares two TreeNode\\'s\\n * @param {TreeNode} root1\\n * @param {TreeNode} root2\\n * @return {boolean}\\n */\\n    function isEqual(root1, root2) {\\n        if (!root1 && !root2) return true;\\n        if (!root1 || !root2) return false;\\n        return root1.val === root2.val\\n            && isEqual(root1.left, root2.right)\\n            && isEqual(root1.right, root2.left);\\n    }\\n    if (!root) return true;\\n    return isEqual(root.left, root.right)\\n};\\n```\\n\\nIterative: \\n```\\nvar isSymmetric = function(root) {\\n    if (!root) return true;\\n    \\n    const stack = [root.left, root.right];\\n    while (stack.length) {\\n        const currLeft = stack.shift();\\n        const currRight = stack.shift();\\n        if (!currLeft && !currRight) continue;\\n        if ((!currLeft || !currRight) || currLeft.val !== currRight.val) return false;\\n        stack.push(currLeft.left, currRight.right, currLeft.right, currRight.left);\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isSymmetric = function(root) {\\n/**\\n * Compares two TreeNode\\'s\\n * @param {TreeNode} root1\\n * @param {TreeNode} root2\\n * @return {boolean}\\n */\\n    function isEqual(root1, root2) {\\n        if (!root1 && !root2) return true;\\n        if (!root1 || !root2) return false;\\n        return root1.val === root2.val\\n            && isEqual(root1.left, root2.right)\\n            && isEqual(root1.right, root2.left);\\n    }\\n    if (!root) return true;\\n    return isEqual(root.left, root.right)\\n};\\n```\n```\\nvar isSymmetric = function(root) {\\n    if (!root) return true;\\n    \\n    const stack = [root.left, root.right];\\n    while (stack.length) {\\n        const currLeft = stack.shift();\\n        const currRight = stack.shift();\\n        if (!currLeft && !currRight) continue;\\n        if ((!currLeft || !currRight) || currLeft.val !== currRight.val) return false;\\n        stack.push(currLeft.left, currRight.right, currLeft.right, currRight.left);\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 479794,
                "title": "python-3-simple-recursion-faster-than-97-and-less-memory-than-100",
                "content": "\\n\\n```\\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n        \\n        if not root:\\n            return True\\n        \\n        left=root.left\\n        right=root.right\\n        \\n        if not left and not right:\\n            return True\\n        \\n        def check(t1, t2):\\n            if not t1 and not t2:\\n                return True\\n            if t1 and not t2:\\n                return False\\n            if not t1 and t2:\\n                return False\\n            if t1.val!=t2.val:\\n                return False\\n            return check(t1.left, t2.right) and check(t1.right, t2.left)\\n        \\n        return check(left, right)\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n        \\n        if not root:\\n            return True\\n        \\n        left=root.left\\n        right=root.right\\n        \\n        if not left and not right:\\n            return True\\n        \\n        def check(t1, t2):\\n            if not t1 and not t2:\\n                return True\\n            if t1 and not t2:\\n                return False\\n            if not t1 and t2:\\n                return False\\n            if t1.val!=t2.val:\\n                return False\\n            return check(t1.left, t2.right) and check(t1.right, t2.left)\\n        \\n        return check(left, right)\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 183416,
                "title": "python-dfs",
                "content": "### 101.  Symmetric Tree\\n\\n\\u8FD9\\u9053\\u9898\\u5177\\u4F53\\u7684Recursion Rule\\u4E0D\\u662F\\u4F20\\u9012Root\\u672C\\u8EAB\\uFF0C\\u800C\\u662F\\u5BF9\\u4E24\\u4E2A\\u5B50\\u5B69\\u5B50\\u7684\\u6BD4\\u8F83\\uFF0C\\u6240\\u4EE5Helper\\u7684\\u53C2\\u6570\\u5B9A\\u4E49\\u4E3A`root.left` \\u548C `root.right`. \\u7136\\u540E\\u6839\\u636E\\u9898\\u76EE\\u7684\\u7279\\u6027\\uFF0C\\u5728\\u6BCF\\u4E00\\u5C42\\u5F80\\u4E0B\\u4F20\\u9012\\u4E4B\\u524D\\u8981\\u505A\\u6BD4\\u8F83\\uFF0C\\u6240\\u4EE5\\u662F`preorder`\\u7684\\u5199\\u6CD5\\uFF0C\\u5148\\u5199\\u6BD4\\u8F83\\u7684\\u51E0\\u79CD\\u683C\\u5F0F\\uFF0C\\u7136\\u540E\\u5728\\u505A\\u9012\\u5F52\\u3002\\u9012\\u5F52\\u5411\\u4E0A\\u8FD4\\u56DE\\u7684\\u53C2\\u6570\\u662F\\u4E00\\u4E2ABoolean\\u3002\\n\\n\\u65F6\\u95F4\\u590D\\u6742\\u5EA6 : O(N)\\n\\u7A7A\\u95F4\\u590D\\u6742\\u5EA6 : O(N) or O(Height)\\n\\n```python\\nclass Solution(object):\\n    def isSymmetric(self, root):\\n        if not root: return True\\n        return self.dfs_helper(root.left, root.right)\\n        \\n    \\n    def dfs_helper(self, n1, n2):\\n        if not n1 and not n2: return True\\n        if not n1 or not n2: return False\\n        if n1.val != n2.val: return False\\n        left = self.dfs_helper(n1.left, n2.right)\\n        right = self.dfs_helper(n1.right, n2.left)\\n        return left and right\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def isSymmetric(self, root):\\n        if not root: return True\\n        return self.dfs_helper(root.left, root.right)\\n        \\n    \\n    def dfs_helper(self, n1, n2):\\n        if not n1 and not n2: return True\\n        if not n1 or not n2: return False\\n        if n1.val != n2.val: return False\\n        left = self.dfs_helper(n1.left, n2.right)\\n        right = self.dfs_helper(n1.right, n2.left)\\n        return left and right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 33177,
                "title": "simple-and-easy-understand-recursive-and-iterative-python-solutions",
                "content": "recursive:\\n\\n```\\n    def isSymmetric(self, root):\\n        if not root: return True\\n        return self.helper(root.left, root.right)\\n\\n    def helper(self, left, right):\\n# first make sure left and right is not none\\n        if left and right: \\n            if left.val == right.val:\\n                return self.helper(left.left, right.right) and self.helper(left.right, right.left)\\n            else:\\n                return False\\n        else:\\n# otherwise,return left == right\\n            return left == right \\n```\\n\\niterative using stack:\\n\\n```\\n    def isSymmetric(self, root):\\n\\n        if not root: return True\\n    \\n        stack = [[root.left, root.right]]\\n        \\n        while stack:\\n            node1, node2 = stack.pop()\\n            if node1 and node2: # make sure not None\\n                if node1.val != node2.val:\\n                    return False\\n                else:\\n                    stack.append([node1.left, node2.right])\\n                    stack.append([node1.right, node2.left])\\n            else:\\n                if node1 == node2:\\n                    continue\\n                else:\\n                    return False\\n        \\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\n    def isSymmetric(self, root):\\n        if not root: return True\\n        return self.helper(root.left, root.right)\\n\\n    def helper(self, left, right):\\n# first make sure left and right is not none\\n        if left and right: \\n            if left.val == right.val:\\n                return self.helper(left.left, right.right) and self.helper(left.right, right.left)\\n            else:\\n                return False\\n        else:\\n# otherwise,return left == right\\n            return left == right \\n```\n```\\n    def isSymmetric(self, root):\\n\\n        if not root: return True\\n    \\n        stack = [[root.left, root.right]]\\n        \\n        while stack:\\n            node1, node2 = stack.pop()\\n            if node1 and node2: # make sure not None\\n                if node1.val != node2.val:\\n                    return False\\n                else:\\n                    stack.append([node1.left, node2.right])\\n                    stack.append([node1.right, node2.left])\\n            else:\\n                if node1 == node2:\\n                    continue\\n                else:\\n                    return False\\n        \\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 33260,
                "title": "easy-java-solution-with-comments",
                "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        \\n        //Base casees: if root is null or only 1 node is present\\n        if(root==null || (root.left==null && root.right==null))\\n            return true;\\n            \\n        //if either subtree is empty return false\\n        if(root.left==null || root.right==null)\\n            return false;\\n            \\n        return Symmetric(root.left,root.right);\\n        \\n    }\\n    \\n    \\n    public boolean Symmetric(TreeNode node1, TreeNode node2)\\n    {\\n        //if both are null, return true\\n        if(node1==null && node2==null)\\n            return true;\\n            \\n        //if either one is null, return false\\n        if(node1==null || node2==null)\\n            return false;\\n        \\n        //if they both are equal, compare their children\\n        if(node1.val==node2.val)\\n        {\\n            return Symmetric(node1.left,node2.right) && Symmetric(node1.right,node2.left);\\n        }\\n        else\\n            return false;\\n        \\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        \\n        //Base casees: if root is null or only 1 node is present\\n        if(root==null || (root.left==null && root.right==null))\\n            return true;\\n            \\n        //if either subtree is empty return false\\n        if(root.left==null || root.right==null)\\n            return false;\\n            \\n        return Symmetric(root.left,root.right);\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 33381,
                "title": "simple-java-recursive-solution",
                "content": "    public class Solution {\\n        public boolean isSymmetric(TreeNode root) {\\n            if (root == null) return true;\\n            return isSymmetric(root.left, root.right);\\n        }\\n        \\n        // Returns whether tree 'left' is mirror of tree 'right'\\n        public boolean isSymmetric(TreeNode left, TreeNode right) {\\n            // Case 1: both are null - return true\\n            if (left == null && right == null) return true;\\n            \\n            // Case 2: one is null but not the other - return false\\n            if (left == null || right == null) return false;\\n            \\n            // Case 3: both are not null - check whether they're equal and left/right subtrees are mirrors\\n            return left.val == right.val && isSymmetric(left.left, right.right) && isSymmetric(left.right, right.left);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isSymmetric(TreeNode root) {\\n            if (root == null) return true;\\n            return isSymmetric(root.left, root.right);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3291837,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        return isMirror(root, root);\\n    }\\n\\n    bool isMirror(TreeNode* t1, TreeNode* t2) {\\n        if (t1 == nullptr && t2 == nullptr) {\\n            return true;\\n        }\\n        if (t1 == nullptr || t2 == nullptr) {\\n            return false;\\n        }\\n        return t1->val == t2->val && isMirror(t1->right, t2->left) && isMirror(t1->left, t2->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        return isMirror(root, root);\\n    }\\n\\n    bool isMirror(TreeNode* t1, TreeNode* t2) {\\n        if (t1 == nullptr && t2 == nullptr) {\\n            return true;\\n        }\\n        if (t1 == nullptr || t2 == nullptr) {\\n            return false;\\n        }\\n        return t1->val == t2->val && isMirror(t1->right, t2->left) && isMirror(t1->left, t2->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290079,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        return self.isSame(root, root)\\n    \\n    def isSame(self, n1, n2):\\n        if not n1 and not n2:\\n            return True\\n        elif not n1 or not n2:\\n            return False\\n        \\n        return n1.val == n2.val and self.isSame(n1.right, n2.left) and self.isSame(n1.left, n2.right)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        return self.isSame(root, root)\\n    \\n    def isSame(self, n1, n2):\\n        if not n1 and not n2:\\n            return True\\n        elif not n1 or not n2:\\n            return False\\n        \\n        return n1.val == n2.val and self.isSame(n1.right, n2.left) and self.isSame(n1.left, n2.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3189527,
                "title": "symmetric-tree-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe isSymmetric function takes a binary tree root as input, and returns True if it is symmetric, and False otherwise.\\n\\nThe isMirror function checks whether two nodes node1 and node2 are mirrors of each other. It returns True if they are, and False otherwise.\\n\\nThe isSymmetric function checks whether the left and right subtrees of root are mirrors of each other, using the isMirror function. If they are, it returns True, and False otherwise.\\n\\nThe time complexity of this solution is O(n), where n is the number of nodes in the binary tree, since we visit each node once. The space complexity is O(h), where h is the height of the binary tree, since the depth of the recursive call stack is at most the height of the binary tree.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n        if not root:\\n            return True\\n        return self.isMirror(root.left, root.right)\\n    \\n    def isMirror(self, node1: TreeNode, node2: TreeNode) -> bool:\\n        if not node1 and not node2:\\n            return True\\n        if not node1 or not node2:\\n            return False\\n        if node1.val != node2.val:\\n            return False\\n        return self.isMirror(node1.left, node2.right) and self.isMirror(node1.right, node2.left)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n        if not root:\\n            return True\\n        return self.isMirror(root.left, root.right)\\n    \\n    def isMirror(self, node1: TreeNode, node2: TreeNode) -> bool:\\n        if not node1 and not node2:\\n            return True\\n        if not node1 or not node2:\\n            return False\\n        if node1.val != node2.val:\\n            return False\\n        return self.isMirror(node1.left, node2.right) and self.isMirror(node1.right, node2.left)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2728716,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        def dfs(r1,r2):\\n            if not r1 and not r2:\\n                return True\\n            if not r1 or not r2:\\n                return False\\n            return r1.val == r2.val and dfs(r1.left, r2.right) and dfs(r1.right, r2.left)\\n        return dfs(root.left, root.right) if root else True",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        def dfs(r1,r2):\\n            if not r1 and not r2:\\n                return True\\n            if not r1 or not r2:\\n                return False\\n            return r1.val == r2.val and dfs(r1.left, r2.right) and dfs(r1.right, r2.left)\\n        return dfs(root.left, root.right) if root else True",
                "codeTag": "Java"
            },
            {
                "id": 1937483,
                "title": "python-faster-than-98-8-with-explaination",
                "content": "# Please upvote if it helps\\n### Recursive Approach:\\n- Have to define a function which will receive two nodes which is P and Q\\n- If both p and q is None then, return True\\n- if p or q is none, then return False \\n\\t- Because it\\'s not symmetric if one has value and the other one is empty\\n- if p.val is not equal to q.val , then return False\\n- Return function(p.left, q.right) and function(p.right, q.left)\\n\\t- Because to check symmetric we have to check :\\n\\t\\t- if (leftOfLeft==rightOfRight) and (rightOfLeft==leftOfRgiht) is true then its symmetric\\n\\t\\t- otherwise its not.\\n\\t\\n- That\\'s all\\n\\nCode:\\n\\n```\\ndef isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        def isMirror(p, q):\\n            if not p and not q:\\n                return True\\n            if not p or not q:\\n                return False\\n            if p.val != q.val:\\n                return False\\n            \\n            return isMirror(p.left, q.right) and isMirror(p.right, q.left)\\n        \\n        \\n        return isMirror(root.left, root.right)\\n        \\n```\\n\\n#### Leave a comment if you have any question.\\n![image](https://assets.leetcode.com/users/images/3dd47369-9bc2-4a35-8ccb-b6dc00dd0a1a_1649707786.1095674.png)\\n",
                "solutionTags": [
                    "Python",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\ndef isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        def isMirror(p, q):\\n            if not p and not q:\\n                return True\\n            if not p or not q:\\n                return False\\n            if p.val != q.val:\\n                return False\\n            \\n            return isMirror(p.left, q.right) and isMirror(p.right, q.left)\\n        \\n        \\n        return isMirror(root.left, root.right)\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1898293,
                "title": "my-python-recursive-solution",
                "content": "\\n```\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        def compareSub(p, q):\\n            if p == None and q == None:\\n                return True\\n            if p == None or q == None:\\n                return False\\n            if p.val != q.val:\\n                return False\\n            return compareSub(p.left, q.right) and compareSub(p.right, q.left)\\n        return compareSub(root, root)\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        def compareSub(p, q):\\n            if p == None and q == None:\\n                return True\\n            if p == None or q == None:\\n                return False\\n            if p.val != q.val:\\n                return False\\n            return compareSub(p.left, q.right) and compareSub(p.right, q.left)\\n        return compareSub(root, root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1456554,
                "title": "python-dfs-clean-concise",
                "content": "```python\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        def dfs(root1, root2):\\n            if root1 == None and root2 == None:\\n                return True\\n            if root1 == None or root2 == None or root1.val != root2.val:\\n                return False\\n            \\n            return dfs(root1.right, root2.left) and dfs(root1.left, root2.right)\\n        \\n        return dfs(root.left, root.right)\\n```\\nComplexity:\\n- Time: `O(N)`, where `N <= 1000` is number of nodes in the binary tree.\\n- Space: `O(H)`, where `H` is the height of the binary tree.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        def dfs(root1, root2):\\n            if root1 == None and root2 == None:\\n                return True\\n            if root1 == None or root2 == None or root1.val != root2.val:\\n                return False\\n            \\n            return dfs(root1.right, root2.left) and dfs(root1.left, root2.right)\\n        \\n        return dfs(root.left, root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 909732,
                "title": "python-concise-recursive-solution",
                "content": "```\\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n        def _symmetric(n1, n2):        \\n            if not n1 and not n2:\\n                return True\\n            if (not n1 and n2) or (not n2 and n1):\\n                return False\\n            return n1.val == n2.val and _symmetric(n1.left, n2.right) and _symmetric(n1.right, n2.left)\\n           \\n        return _symmetric(root, root)\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n        def _symmetric(n1, n2):        \\n            if not n1 and not n2:\\n                return True\\n            if (not n1 and n2) or (not n2 and n1):\\n                return False\\n            return n1.val == n2.val and _symmetric(n1.left, n2.right) and _symmetric(n1.right, n2.left)\\n           \\n        return _symmetric(root, root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 642604,
                "title": "0-ms-faster-than-100-00-of-java-online-submissions",
                "content": "Runtime: 0 ms, faster than 100.00% of Java online submissions for Symmetric Tree.\\nMemory Usage: 37.4 MB, less than 74.15% of Java online submissions for Symmetric Tree.\\n```\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        return root==null || traverse(root.left,root.right);\\n    }\\n    private boolean traverse(TreeNode one,TreeNode two){\\n        if(one==null && two==null)return true;\\n        if(one==null || two==null)return false;\\n        if(one.val!=two.val)return false;\\n        boolean resl=traverse(one.left,two.right);\\n        if(!resl)return false;\\n        boolean resr=traverse(one.right,two.left);\\n        if(!resr)return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        return root==null || traverse(root.left,root.right);\\n    }\\n    private boolean traverse(TreeNode one,TreeNode two){\\n        if(one==null && two==null)return true;\\n        if(one==null || two==null)return false;\\n        if(one.val!=two.val)return false;\\n        boolean resl=traverse(one.left,two.right);\\n        if(!resl)return false;\\n        boolean resr=traverse(one.right,two.left);\\n        if(!resr)return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 229212,
                "title": "swift-solution-beats-100",
                "content": "```\\nclass Solution {\\n    func isSymmetric(_ root: TreeNode?) -> Bool {\\n        return isMirror(root, root)\\n    }\\n    func isMirror(_ t1:TreeNode?,_ t2:TreeNode?) ->Bool {\\n        if(t1 == nil && t2 == nil) {return true}\\n        if(t1 == nil || t2 == nil) {return false}\\n        return (t1!.val == t2!.val) &&\\n               isMirror(t1!.right,t2!.left) &&\\n               isMirror(t1!.left,t2!.right)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func isSymmetric(_ root: TreeNode?) -> Bool {\\n        return isMirror(root, root)\\n    }\\n    func isMirror(_ t1:TreeNode?,_ t2:TreeNode?) ->Bool {\\n        if(t1 == nil && t2 == nil) {return true}\\n        if(t1 == nil || t2 == nil) {return false}\\n        return (t1!.val == t2!.val) &&\\n               isMirror(t1!.right,t2!.left) &&\\n               isMirror(t1!.left,t2!.right)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 33386,
                "title": "share-3-methods-to-solve-this-problem-java",
                "content": "First.\\nWe can define a binary tree by mid-order and post-order or pre-order and mid-order, the mirror tree is same to the origin tree. So we can check these two trees' mid-order and post-order are all same?\\n\\n    public boolean isSymmetric(TreeNode root) {\\n            if (root==null)\\n                return true;\\n            return getMidOrderSeq(root).equals(getReMidOrderSeq(root))&&getPostOrderSeq(root).equals(getRePostOrderSeq(root));\\n        }\\n    \\n        public String getMidOrderSeq(TreeNode node) {\\n            if (node == null) {\\n                return \"\";\\n            }\\n            return getMidOrderSeq(node.left) + node.val + getMidOrderSeq(node.right);\\n        }\\n        public String getReMidOrderSeq(TreeNode node) {\\n            if (node == null) {\\n                return \"\";\\n            }\\n            return getReMidOrderSeq(node.right) + node.val + getReMidOrderSeq(node.left);\\n        }\\n        public String getPostOrderSeq(TreeNode node) {\\n            if (node == null) {\\n                return \"\";\\n            }\\n            return getPostOrderSeq(node.left) +getPostOrderSeq(node.right)+ node.val ;\\n        }\\n        public String getRePostOrderSeq(TreeNode node) {\\n            if (node == null) {\\n                return \"\";\\n            }\\n            return getRePostOrderSeq(node.right) +getRePostOrderSeq(node.left)+ node.val ;\\n        }\\n\\n\\nSecond. Normal recursion.\\n\\n     public boolean isSymmetric(TreeNode root) {\\n            if (root == null)\\n                return true;\\n            return isSymmetric(root, root);\\n    \\n        }\\n    \\n        public boolean isSymmetric(TreeNode left, TreeNode right) {\\n            if (left == null || right == null) {\\n                return left == right;\\n            }\\n            return left.val == right.val && isSymmetric(left.left, right.right) && isSymmetric(left.right, right.left);\\n        }\\n\\nThird. Iteration.\\n\\n    public boolean isSymmetricIter(TreeNode root) {\\n            if (root == null || (root.left == null && root.right == null))\\n                return true;\\n            Stack<TreeNode> leftStack = new Stack<>();\\n            Stack<TreeNode> rightStack = new Stack<>();\\n            leftStack.push(root.left);\\n            rightStack.push(root.right);\\n            while (!leftStack.isEmpty() && !rightStack.isEmpty()) {\\n                TreeNode left = leftStack.pop();\\n                TreeNode right = rightStack.pop();\\n                if (left == null && right == null) {\\n                    continue;\\n                }\\n                if (left == null || right == null)\\n                    return false;\\n                if (left.val != right.val)\\n                    return false;\\n                leftStack.push(left.left);\\n                rightStack.push(right.right);\\n                leftStack.push(left.right);\\n                rightStack.push(right.left);\\n            }\\n            return true;\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "First.\\nWe can define a binary tree by mid-order and post-order or pre-order and mid-order, the mirror tree is same to the origin tree. So we can check these two trees' mid-order and post-order are all same?\\n\\n    public boolean isSymmetric(TreeNode root) {\\n            if (root==null)\\n                return true;\\n            return getMidOrderSeq(root).equals(getReMidOrderSeq(root))&&getPostOrderSeq(root).equals(getRePostOrderSeq(root));\\n        }\\n    \\n        public String getMidOrderSeq(TreeNode node) {\\n            if (node == null) {\\n                return \"\";\\n            }\\n            return getMidOrderSeq(node.left) + node.val + getMidOrderSeq(node.right);\\n        }\\n        public String getReMidOrderSeq(TreeNode node) {\\n            if (node == null) {\\n                return \"\";\\n            }\\n            return getReMidOrderSeq(node.right) + node.val + getReMidOrderSeq(node.left);\\n        }\\n        public String getPostOrderSeq(TreeNode node) {\\n            if (node == null) {\\n                return \"\";\\n            }\\n            return getPostOrderSeq(node.left) +getPostOrderSeq(node.right)+ node.val ;\\n        }\\n        public String getRePostOrderSeq(TreeNode node) {\\n            if (node == null) {\\n                return \"\";\\n            }\\n            return getRePostOrderSeq(node.right) +getRePostOrderSeq(node.left)+ node.val ;\\n        }\\n\\n\\nSecond. Normal recursion.\\n\\n     public boolean isSymmetric(TreeNode root) {\\n            if (root == null)\\n                return true;\\n            return isSymmetric(root, root);\\n    \\n        }\\n    \\n        public boolean isSymmetric(TreeNode left, TreeNode right) {\\n            if (left == null || right == null) {\\n                return left == right;\\n            }\\n            return left.val == right.val && isSymmetric(left.left, right.right) && isSymmetric(left.right, right.left);\\n        }\\n\\nThird. Iteration.\\n\\n    public boolean isSymmetricIter(TreeNode root) {\\n            if (root == null || (root.left == null && root.right == null))\\n                return true;\\n            Stack<TreeNode> leftStack = new Stack<>();\\n            Stack<TreeNode> rightStack = new Stack<>();\\n            leftStack.push(root.left);\\n            rightStack.push(root.right);\\n            while (!leftStack.isEmpty() && !rightStack.isEmpty()) {\\n                TreeNode left = leftStack.pop();\\n                TreeNode right = rightStack.pop();\\n                if (left == null && right == null) {\\n                    continue;\\n                }\\n                if (left == null || right == null)\\n                    return false;\\n                if (left.val != right.val)\\n                    return false;\\n                leftStack.push(left.left);\\n                rightStack.push(right.right);\\n                leftStack.push(left.right);\\n                rightStack.push(right.left);\\n            }\\n            return true;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 33407,
                "title": "my-simple-c-recursive-solution-9ms",
                "content": "    class Solution {\\n    public:\\n        bool areSymmetricTrees(TreeNode *rootA, TreeNode *rootB){\\n            if( (!rootA) && (!rootB) )\\n            {\\n                return true;\\n            }\\n            else if( rootA && rootB )\\n            {\\n                return (rootA->val == rootB->val) && areSymmetricTrees(rootA->left, rootB->right)\\n                && areSymmetricTrees(rootB->left, rootA->right);\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        bool isSymmetric(TreeNode *root) {\\n            if(!root)\\n            {\\n                return true;\\n            }\\n            else\\n            {\\n                return areSymmetricTrees(root->left, root->right);\\n            }\\n            \\n        }\\n    };\\n\\nA help function is defined to check if two trees are symmetric.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool areSymmetricTrees(TreeNode *rootA, TreeNode *rootB){\\n            if( (!rootA) && (!rootB) )\\n            {\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 33374,
                "title": "recusive-solution-for-symmetric-tree-is-it-an-optimal-solution-to-use-inordertraversal",
                "content": "The approach I have is:\\n1. get two vectors which saves both left and right sides of the root in inorderTraversal format.\\n2. compare the vectors to see if they are symmetric.\\nIt needs extra O(2n) space, not sure if this is an accepted solution. Or is there any better to solve this problem recursively.\\n\\n    /*recusive*/\\n    class inorderTraversal {\\n    public:\\n        vector<int> solution(TreeNode *root) {\\n            // IMPORTANT: Please reset any member data you declared, as\\n            // the same Solution instance will be reused for each test case.\\n            vector <int> results;\\n    \\t\\tvector <int> rightResults;\\n    \\t\\tif(!root) return results;\\n    \\t\\tresults=solution(root->left);\\n            results.insert(results.end(),root->val);\\n    \\t\\trightResults=solution(root->right);\\n    \\t\\tif(!rightResults.empty())\\n    \\t\\t\\tresults.insert(results.end(),rightResults.begin(), rightResults.end());\\n        }\\n    };\\n    \\n    class Solution {\\n    public:\\n        bool isSymmetric(TreeNode *root) {\\n            // IMPORTANT: Please reset any member data you declared, as\\n            // the same Solution instance will be reused for each test case.\\n            if(!root) return true;\\n    \\t\\tinorderTraversal instance;\\n    \\t\\tvector <int> leftResults=instance.solution(root->left);\\n    \\t\\tvector <int> rightResults=instance.solution(root->right);\\n    \\t\\tif(leftResults.size()!=rightResults.size())\\n    \\t\\t\\treturn false;\\n    \\t\\tint size=leftResults.size();\\n    \\t\\tif(!size) return true;\\n    \\n    \\t\\tfor(int i=0; i< size; i++)\\n    \\t\\t{\\n    \\t\\t\\tif(leftResults[i]!=rightResults[size-1-i])\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\treturn true;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isSymmetric(TreeNode *root) {\\n            // IMPORTANT: Please reset any member data you declared, as\\n            // the same Solution instance will be reused for each test case.\\n            if(!root) return true;\\n    \\t\\tinorderTraversal instance;\\n    \\t\\tvector <int> leftResults=instance.solution(root->left);\\n    \\t\\tvector <int> rightResults=instance.solution(root->right);\\n    \\t\\tif(leftResults.size()!=rightResults.size())\\n    \\t\\t\\treturn false;\\n    \\t\\tint size=leftResults.size();\\n    \\t\\tif(!size) return true;\\n    \\n    \\t\\tfor(int i=0; i< size; i++)\\n    \\t\\t{\\n    \\t\\t\\tif(leftResults[i]!=rightResults[size-1-i])\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3648117,
                "title": "c-easy-method",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool c(TreeNode* left, TreeNode* right){\\n        if(!left || !right){\\n            return left==right;\\n        }\\n        if(left->val!=right->val)return false;\\n        return c(left->left,right->right) && c(left->right,right->left);\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        return c(root,root);\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/bdc85d8b-0970-490c-afb7-cd6f07b58742_1686996931.7722983.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool c(TreeNode* left, TreeNode* right){\\n        if(!left || !right){\\n            return left==right;\\n        }\\n        if(left->val!=right->val)return false;\\n        return c(left->left,right->right) && c(left->right,right->left);\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        return c(root,root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169564,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\nbool myfunc(TreeNode* p,TreeNode* q)\\n{\\n    if(p==NULL)\\n    {\\n        return p==q;\\n    }\\n    if(q==NULL)\\n    {\\n        return p==q;\\n    }\\n    if(p->val!=q->val)\\n    {\\n        return false;\\n    }\\n    return myfunc(p->left,q->right)&&myfunc(p->right,q->left);\\n}\\n    bool isSymmetric(TreeNode* root) {\\n       return myfunc(root->left,root->right);\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n        def isMirror(left, right):\\n            if left is None and right is None:\\n                return True\\n            if left is None or right is None:\\n                return False\\n            if left.val != right.val:\\n                return False\\n            return isMirror(left.left, right.right) and isMirror(left.right, right.left)\\n\\n        if root is None:\\n            return True\\n        else:\\n            return isMirror(root.left, root.right)\\n```\\n\\n```Java []\\nclass Solution {\\n    public boolean isTreeSymmetric(TreeNode leftRoot, TreeNode rightRoot){\\n        if(leftRoot == null && rightRoot == null)\\n            return true;\\n        if((leftRoot == null && rightRoot != null)  || (leftRoot != null && rightRoot == null))\\n            return false;\\n        if(leftRoot.val != rightRoot.val)\\n            return false;\\n        return isTreeSymmetric(leftRoot.left, rightRoot.right) && isTreeSymmetric(leftRoot.right, rightRoot.left);\\n    }\\n    public boolean isSymmetric(TreeNode root) {\\n        return isTreeSymmetric(root.left, root.right);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\nbool myfunc(TreeNode* p,TreeNode* q)\\n{\\n    if(p==NULL)\\n    {\\n        return p==q;\\n    }\\n    if(q==NULL)\\n    {\\n        return p==q;\\n    }\\n    if(p->val!=q->val)\\n    {\\n        return false;\\n    }\\n    return myfunc(p->left,q->right)&&myfunc(p->right,q->left);\\n}\\n    bool isSymmetric(TreeNode* root) {\\n       return myfunc(root->left,root->right);\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n        def isMirror(left, right):\\n            if left is None and right is None:\\n                return True\\n            if left is None or right is None:\\n                return False\\n            if left.val != right.val:\\n                return False\\n            return isMirror(left.left, right.right) and isMirror(left.right, right.left)\\n\\n        if root is None:\\n            return True\\n        else:\\n            return isMirror(root.left, root.right)\\n```\n```Java []\\nclass Solution {\\n    public boolean isTreeSymmetric(TreeNode leftRoot, TreeNode rightRoot){\\n        if(leftRoot == null && rightRoot == null)\\n            return true;\\n        if((leftRoot == null && rightRoot != null)  || (leftRoot != null && rightRoot == null))\\n            return false;\\n        if(leftRoot.val != rightRoot.val)\\n            return false;\\n        return isTreeSymmetric(leftRoot.left, rightRoot.right) && isTreeSymmetric(leftRoot.right, rightRoot.left);\\n    }\\n    public boolean isSymmetric(TreeNode root) {\\n        return isTreeSymmetric(root.left, root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3003505,
                "title": "java-recursion-runtime-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean preOrder(TreeNode temp,TreeNode temp1){\\n        if(temp==null || temp1==null){\\n            return temp==temp1;\\n        }\\n        if(temp.val!=temp1.val) return false;\\n        \\n        return preOrder(temp.left,temp1.right) && preOrder(temp.right,temp1.left);\\n        \\n    }\\n    public boolean isSymmetric(TreeNode root) {\\n        return root==null || preOrder(root.left,root.right); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean preOrder(TreeNode temp,TreeNode temp1){\\n        if(temp==null || temp1==null){\\n            return temp==temp1;\\n        }\\n        if(temp.val!=temp1.val) return false;\\n        \\n        return preOrder(temp.left,temp1.right) && preOrder(temp.right,temp1.left);\\n        \\n    }\\n    public boolean isSymmetric(TreeNode root) {\\n        return root==null || preOrder(root.left,root.right); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2888798,
                "title": "python3-beautiful-solution-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen I saw the problem I thought about a problem I solved recently: https://leetcode.com/problems/same-tree/description/. I copied my solution from the isSameTree submission and started thinking how it can help me solve this problem.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMoving from the isSameTree solution.\\nLet\\'s imagine we have 2 subtrees: left and right ones.\\nTo solve the problem we will have to compare:\\n- left node of the left subtree to the right node of the right subtree\\n- right node of the left subtree to the left node of the right subtree\\n- repeat recursively for the child nodes\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(log(n))$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        return self.isSameTreeReverse(root.left, root.right)\\n\\n    def isSameTreeReverse(self, p, q):\\n        if p is None and q is None:\\n            return True\\n\\n        if p and q and p.val == q.val:\\n            return self.isSameTreeReverse(p.left, q.right) and self.isSameTreeReverse(p.right, q.left)\\n\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        return self.isSameTreeReverse(root.left, root.right)\\n\\n    def isSameTreeReverse(self, p, q):\\n        if p is None and q is None:\\n            return True\\n\\n        if p and q and p.val == q.val:\\n            return self.isSameTreeReverse(p.left, q.right) and self.isSameTreeReverse(p.right, q.left)\\n\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765179,
                "title": "easy-c",
                "content": "```\\npublic:\\n    bool is_same(TreeNode *root1, TreeNode *root2){\\n        if(!root1 && !root2) return true;\\n        if((!root1 && root2) || (root1 && !root2)) return false;\\n        \\n        if(root1->val == root2->val) return is_same(root1->left , root2->right) && is_same(root1->right , root2->left);\\n        else return false;\\n    }\\n    \\n    bool isSymmetric(TreeNode* root) {\\n        return is_same(root->left, root->right);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\npublic:\\n    bool is_same(TreeNode *root1, TreeNode *root2){\\n        if(!root1 && !root2) return true;\\n        if((!root1 && root2) || (root1 && !root2)) return false;\\n        \\n        if(root1->val == root2->val) return is_same(root1->left , root2->right) && is_same(root1->right , root2->left);\\n        else return false;\\n    }\\n    \\n    bool isSymmetric(TreeNode* root) {\\n        return is_same(root->left, root->right);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2596242,
                "title": "c-fastest-recursive-o-n-easy-to-understand",
                "content": "**please upvote **\\n```\\n\\nclass Solution {\\npublic:\\n    bool solve(TreeNode* lroot, TreeNode* rroot){\\n        if (!lroot && !rroot) return true;\\n        else if (lroot && rroot){\\n            bool c = (lroot->val==rroot->val);\\n            if (c){\\n                bool a = solve(lroot->left, rroot->right);\\n                bool b = solve(lroot->right, rroot->left);\\n                return (a && b);\\n            }\\n            else return false;\\n        }\\n        else return false;\\n    }\\n \\n    \\n    bool isSymmetric(TreeNode* root) {\\n        if(!root) return true;\\n        return solve(root->left, root->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool solve(TreeNode* lroot, TreeNode* rroot){\\n        if (!lroot && !rroot) return true;\\n        else if (lroot && rroot){\\n            bool c = (lroot->val==rroot->val);\\n            if (c){\\n                bool a = solve(lroot->left, rroot->right);\\n                bool b = solve(lroot->right, rroot->left);\\n                return (a && b);\\n            }\\n            else return false;\\n        }\\n        else return false;\\n    }\\n \\n    \\n    bool isSymmetric(TreeNode* root) {\\n        if(!root) return true;\\n        return solve(root->left, root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2586852,
                "title": "python3-iterative-recursive-bfs-intuitive-neat",
                "content": "Iterative\\n```\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        L, R = [root], [root]\\n        while L or R:\\n            l, r = L.pop(), R.pop()\\n            if not (l or r):\\n                continue\\n            elif not (l and r):\\n                return False\\n            elif (l.val != r.val):\\n                return False\\n            L.append(l.right) \\n            L.append(l.left)\\n            R.append(r.left) \\n            R.append(r.right)\\n        return True\\n```\\nRecursive\\n```\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        def isSym(n1 = root, n2 = root):\\n            if not (n1 or n2):\\n                return True\\n            elif not (n1 and n2):\\n                return False\\n            elif n1.val != n2.val:\\n                return False\\n            return isSym(n1.left, n2.right) and isSym(n1.right, n2.left)\\n        return isSym()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Recursion",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        L, R = [root], [root]\\n        while L or R:\\n            l, r = L.pop(), R.pop()\\n            if not (l or r):\\n                continue\\n            elif not (l and r):\\n                return False\\n            elif (l.val != r.val):\\n                return False\\n            L.append(l.right) \\n            L.append(l.left)\\n            R.append(r.left) \\n            R.append(r.right)\\n        return True\\n```\n```\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        def isSym(n1 = root, n2 = root):\\n            if not (n1 or n2):\\n                return True\\n            elif not (n1 and n2):\\n                return False\\n            elif n1.val != n2.val:\\n                return False\\n            return isSym(n1.left, n2.right) and isSym(n1.right, n2.left)\\n        return isSym()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2498426,
                "title": "c-simple-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    //for symmetricity preorder and postorder should be same\\n    \\n    bool trav(TreeNode* root1, TreeNode* root2){\\n\\n        if(root1==NULL and root2==NULL)\\n            return 1;\\n        if( (root1!=NULL and root2==NULL) or (root1==NULL and root2!=NULL) )\\n            return 0;\\n        if(root1->val != root2->val)\\n            return 0;\\n        \\n        int side1 = trav(root1->left,root2->right);\\n        int side2 = trav(root1->right, root2->left);\\n        \\n        return side1&&side2; \\n    }\\n    \\n    bool isSymmetric(TreeNode* root) {\\n        \\n        if(root==NULL)\\n            return 1;\\n        \\n        return trav(root->left,root->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    //for symmetricity preorder and postorder should be same\\n    \\n    bool trav(TreeNode* root1, TreeNode* root2){\\n\\n        if(root1==NULL and root2==NULL)\\n            return 1;\\n        if( (root1!=NULL and root2==NULL) or (root1==NULL and root2!=NULL) )\\n            return 0;\\n        if(root1->val != root2->val)\\n            return 0;\\n        \\n        int side1 = trav(root1->left,root2->right);\\n        int side2 = trav(root1->right, root2->left);\\n        \\n        return side1&&side2; \\n    }\\n    \\n    bool isSymmetric(TreeNode* root) {\\n        \\n        if(root==NULL)\\n            return 1;\\n        \\n        return trav(root->left,root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625565,
                "title": "python-iterative-recursive",
                "content": "recursive\\n\\n\\tclass Solution:\\n\\t\\tdef isSymmetric(self, root):\\n\\t\\t\\tif not root:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\tdef helper(l, r):\\n\\t\\t\\t\\tif not l and not r:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tif l and r and l.val == r.val:\\n\\t\\t\\t\\t\\treturn helper(l.left, r.right) and helper(l.right, r.left)\\n\\n\\t\\t\\treturn helper(root, root)\\n\\t\\t\\t\\niterative\\n\\n\\tclass Solution:\\n\\t\\tdef isSymmetric(self, root):\\n\\t\\t\\tqueue = [(root, root)]\\n\\t\\t\\twhile queue:\\n\\t\\t\\t\\tl, r = queue.pop(0)\\n\\t\\t\\t\\tif l is None and r is None:\\n\\t\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\t\\tif l is None or r is None:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\tif l.val == r.val:\\n\\t\\t\\t\\t\\tqueue.append((l.left, r.right))\\n\\t\\t\\t\\t\\tqueue.append((l.right, r.left))\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\treturn True",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Iterator"
                ],
                "code": "recursive\\n\\n\\tclass Solution:\\n\\t\\tdef isSymmetric(self, root):\\n\\t\\t\\tif not root:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\tdef helper(l, r):\\n\\t\\t\\t\\tif not l and not r:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tif l and r and l.val == r.val:\\n\\t\\t\\t\\t\\treturn helper(l.left, r.right) and helper(l.right, r.left)\\n\\n\\t\\t\\treturn helper(root, root)\\n\\t\\t\\t\\niterative\\n\\n\\tclass Solution:\\n\\t\\tdef isSymmetric(self, root):\\n\\t\\t\\tqueue = [(root, root)]\\n\\t\\t\\twhile queue:\\n\\t\\t\\t\\tl, r = queue.pop(0)\\n\\t\\t\\t\\tif l is None and r is None:\\n\\t\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\t\\tif l is None or r is None:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\tif l.val == r.val:\\n\\t\\t\\t\\t\\tqueue.append((l.left, r.right))\\n\\t\\t\\t\\t\\tqueue.append((l.right, r.left))\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\treturn True",
                "codeTag": "Java"
            },
            {
                "id": 1474761,
                "title": "recursive-solution",
                "content": "```\\nclass Solution:\\n    def isSymmetric(self, root):\\n        def isSym(L,R):\\n            if not L and not R: return True\\n            if L and R and L.val == R.val: \\n                return isSym(L.left, R.right) and isSym(L.right, R.left)\\n            return False\\n        return isSym(root, root)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isSymmetric(self, root):\\n        def isSym(L,R):\\n            if not L and not R: return True\\n            if L and R and L.val == R.val: \\n                return isSym(L.left, R.right) and isSym(L.right, R.left)\\n            return False\\n        return isSym(root, root)",
                "codeTag": "Java"
            },
            {
                "id": 1283321,
                "title": "simple-c-recursive-and-iterative-solutions",
                "content": "**Please upvote this post to motivate me in my quest of documenting leetcode solutions.**\\n```\\n// M-1 : Recursive TC - O(n) SC - O(n) \\nclass Solution {\\npublic:\\n    bool mirror(TreeNode* node1, TreeNode* node2)\\n    {\\n        if(node1 == NULL && node2 == NULL) return true;\\n        if(node1 == NULL || node2 == NULL) return false;\\n        return node1->val == node2->val && mirror(node1->left, node2->right) && mirror(node1->right, node2->left);\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        return mirror(root, root);\\n    }\\n};\\n// M-2 : Iterative TC - O(n) SC - O(n) \\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root); q.push(root);\\n        while(!q.empty())\\n        {\\n            TreeNode* n1 = q.front(); q.pop();\\n            TreeNode* n2 = q.front(); q.pop();\\n            if(n1 == NULL && n2 == NULL) continue;\\n            if(n1 == NULL || n2 == NULL) return false;\\n            if(n1->val != n2->val) return false;\\n            q.push(n1->left);\\n            q.push(n2->right);\\n            q.push(n1->right);\\n            q.push(n2->left);\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// M-1 : Recursive TC - O(n) SC - O(n) \\nclass Solution {\\npublic:\\n    bool mirror(TreeNode* node1, TreeNode* node2)\\n    {\\n        if(node1 == NULL && node2 == NULL) return true;\\n        if(node1 == NULL || node2 == NULL) return false;\\n        return node1->val == node2->val && mirror(node1->left, node2->right) && mirror(node1->right, node2->left);\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        return mirror(root, root);\\n    }\\n};\\n// M-2 : Iterative TC - O(n) SC - O(n) \\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root); q.push(root);\\n        while(!q.empty())\\n        {\\n            TreeNode* n1 = q.front(); q.pop();\\n            TreeNode* n2 = q.front(); q.pop();\\n            if(n1 == NULL && n2 == NULL) continue;\\n            if(n1 == NULL || n2 == NULL) return false;\\n            if(n1->val != n2->val) return false;\\n            q.push(n1->left);\\n            q.push(n2->right);\\n            q.push(n1->right);\\n            q.push(n2->left);\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917388,
                "title": "c-recursive-76ms-faster-than-100",
                "content": "Runtime: 76 ms, faster than 100.00% of C# online submissions for Symmetric Tree.\\nMemory Usage: 25.7 MB, less than 50.29% of C# online submissions for Symmetric Tree.\\n```\\npublic class Solution {\\n    public bool IsSymmetric(TreeNode root) => CheckSymetry(root?.left, root?.right);\\n    \\n    private bool CheckSymetry(TreeNode left, TreeNode right)\\n    {\\n        if(left == null || right == null)\\n            return left?.val == right?.val;\\n        if(left.val != right.val)\\n            return false;\\n\\n        return CheckSymetry(left.left, right.right) && CheckSymetry(left.right, right.left);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool IsSymmetric(TreeNode root) => CheckSymetry(root?.left, root?.right);\\n    \\n    private bool CheckSymetry(TreeNode left, TreeNode right)\\n    {\\n        if(left == null || right == null)\\n            return left?.val == right?.val;\\n        if(left.val != right.val)\\n            return false;\\n\\n        return CheckSymetry(left.left, right.right) && CheckSymetry(left.right, right.left);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 858855,
                "title": "c-bfs-palindrome-check-dfs-and-0ms",
                "content": "**Runtime: 0 ms, faster than 100.00% of C++ online submissions for Symmetric Tree.\\nMemory Usage: 16.7 MB, less than 21.66% of C++ online submissions for Symmetric Tree.**  \\n\\n**BFS**\\n```\\nclass Solution {\\npublic: \\n    bool isPalindrome(vector<int> &nums) { \\n        int i = 0; \\n        int j = nums.size()-1;\\n        while(i < j) { \\n            if(nums[i] != nums[j]) { \\n                return false;\\n            }  \\n            i++; \\n            j--;\\n        } \\n        return true;\\n    }\\n    bool isSymmetric(TreeNode* root) {  \\n        if(root == NULL || (root->left == NULL && root->right == NULL)) { \\n            return true;\\n        } \\n        queue<TreeNode *> q; \\n        q.push(root); \\n        while(!q.empty()) {  \\n             vector<int> auxiliary; \\n             int n = q.size(); \\n             for(int i = 0; i < n; i++) { \\n                if(q.front()){ \\n                    q.push(q.front()->left); \\n                    q.push(q.front()->right);   \\n                    auxiliary.push_back(q.front()->val);\\n\\n                } \\n                else{ \\n                    auxiliary.push_back(-1);\\n                }  \\n                q.pop();  \\n                 \\n             }\\n             if(!isPalindrome(auxiliary)) { \\n                return false;\\n             }\\n        }\\n         return true;\\n    }\\n};\\n```  \\n\\n**DFS** \\n```\\nclass Solution {\\npublic: \\n    bool checkMirror(TreeNode *ldt,TreeNode *rdt) { \\n        if(!ldt && !rdt) return true; \\n        \\n        if((!ldt && rdt) || (!rdt && ldt)) return false;  \\n        \\n        return checkMirror(ldt->left,rdt->right) && checkMirror(ldt->right,rdt->left) && ldt->val == rdt->val;\\n    }\\n    bool isSymmetric(TreeNode* root) {  \\n     \\n        if(!root) return true; \\n    \\n        return checkMirror(root->left,root->right);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    bool isPalindrome(vector<int> &nums) { \\n        int i = 0; \\n        int j = nums.size()-1;\\n        while(i < j) { \\n            if(nums[i] != nums[j]) { \\n                return false;\\n            }  \\n            i++; \\n            j--;\\n        } \\n        return true;\\n    }\\n    bool isSymmetric(TreeNode* root) {  \\n        if(root == NULL || (root->left == NULL && root->right == NULL)) { \\n            return true;\\n        } \\n        queue<TreeNode *> q; \\n        q.push(root); \\n        while(!q.empty()) {  \\n             vector<int> auxiliary; \\n             int n = q.size(); \\n             for(int i = 0; i < n; i++) { \\n                if(q.front()){ \\n                    q.push(q.front()->left); \\n                    q.push(q.front()->right);   \\n                    auxiliary.push_back(q.front()->val);\\n\\n                } \\n                else{ \\n                    auxiliary.push_back(-1);\\n                }  \\n                q.pop();  \\n                 \\n             }\\n             if(!isPalindrome(auxiliary)) { \\n                return false;\\n             }\\n        }\\n         return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic: \\n    bool checkMirror(TreeNode *ldt,TreeNode *rdt) { \\n        if(!ldt && !rdt) return true; \\n        \\n        if((!ldt && rdt) || (!rdt && ldt)) return false;  \\n        \\n        return checkMirror(ldt->left,rdt->right) && checkMirror(ldt->right,rdt->left) && ldt->val == rdt->val;\\n    }\\n    bool isSymmetric(TreeNode* root) {  \\n     \\n        if(!root) return true; \\n    \\n        return checkMirror(root->left,root->right);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 812630,
                "title": "javascript-solution-recursive-iterative-approach",
                "content": "**Recursive Approach**\\n\\n```\\nvar isSymmetric = function(root) {\\n    return isMirror(root, root);\\n    \\n    function isMirror(node1, node2) {\\n        // edge case\\n        if (node1 == null && node2 == null) return true;\\n        if (node1 == null || node2 == null) return false;\\n        \\n        return node1.val == node2.val && isMirror(node1.left, node2.right) && isMirror(node1.right, node2.left);\\n    }\\n};\\n```\\n\\n<br>\\n\\n---\\n\\n**Iterative Approach**\\n\\n```\\nvar isSymmetric = function(root) {\\n    const queue = [];\\n    \\n    queue.push(root, root);\\n    \\n    while (queue.length > 0) {\\n        const node1 = queue.shift();\\n        const node2 = queue.shift();\\n        \\n        if (node1 == null && node2 == null) continue;\\n        if (node1 == null || node2 == null) return false;\\n        if (node1.val != node2.val) return false;\\n        \\n        queue.push(node1.left, node2.right);            \\n        queue.push(node1.right, node2.left);\\n    }\\n    \\n    return true;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nvar isSymmetric = function(root) {\\n    return isMirror(root, root);\\n    \\n    function isMirror(node1, node2) {\\n        // edge case\\n        if (node1 == null && node2 == null) return true;\\n        if (node1 == null || node2 == null) return false;\\n        \\n        return node1.val == node2.val && isMirror(node1.left, node2.right) && isMirror(node1.right, node2.left);\\n    }\\n};\\n```\n```\\nvar isSymmetric = function(root) {\\n    const queue = [];\\n    \\n    queue.push(root, root);\\n    \\n    while (queue.length > 0) {\\n        const node1 = queue.shift();\\n        const node2 = queue.shift();\\n        \\n        if (node1 == null && node2 == null) continue;\\n        if (node1 == null || node2 == null) return false;\\n        if (node1.val != node2.val) return false;\\n        \\n        queue.push(node1.left, node2.right);            \\n        queue.push(node1.right, node2.left);\\n    }\\n    \\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 758753,
                "title": "javascript-dfs-recursive-solution",
                "content": "Inspirted by @jeantimex [solution](https://leetcode.com/problems/symmetric-tree/discuss/33073/JavaScript-recursive-and-iterative-solutions).\\n```\\nvar isSymmetric = function(root) {\\n  if(!root) return true;\\n  return dfs(root.left, root.right);\\n};\\n\\nfunction dfs(s, t){\\n  if(!s && !t) return true;\\n  if(!s || !t) return false;\\n  if(s.val !== t.val) return false;\\n  \\n  return dfs(s.left, t.right) && dfs(s.right, t.left)\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nvar isSymmetric = function(root) {\\n  if(!root) return true;\\n  return dfs(root.left, root.right);\\n};\\n\\nfunction dfs(s, t){\\n  if(!s && !t) return true;\\n  if(!s || !t) return false;\\n  if(s.val !== t.val) return false;\\n  \\n  return dfs(s.left, t.right) && dfs(s.right, t.left)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 688627,
                "title": "go-recursive",
                "content": "```go\\nfunc isSymmetric(root *TreeNode) bool {\\n    if root == nil {\\n        return true\\n    }\\n    return visit(root.Left, root.Right)\\n}\\n\\nfunc visit(root1 *TreeNode, root2 *TreeNode) bool {\\n    if root1 == nil && root2 == nil {\\n        return true\\n    }\\n    \\n    if root1 == nil || root2 == nil {\\n        return false\\n    }\\n    \\n    if root1.Val != root2.Val {\\n        return false\\n    }\\n    \\n    return visit(root1.Right, root2.Left) && visit(root1.Left, root2.Right)\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc isSymmetric(root *TreeNode) bool {\\n    if root == nil {\\n        return true\\n    }\\n    return visit(root.Left, root.Right)\\n}\\n\\nfunc visit(root1 *TreeNode, root2 *TreeNode) bool {\\n    if root1 == nil && root2 == nil {\\n        return true\\n    }\\n    \\n    if root1 == nil || root2 == nil {\\n        return false\\n    }\\n    \\n    if root1.Val != root2.Val {\\n        return false\\n    }\\n    \\n    return visit(root1.Right, root2.Left) && visit(root1.Left, root2.Right)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 637497,
                "title": "java-python-iterative-recursive",
                "content": "```\\npublic boolean isSymmetric(TreeNode root) {\\n        if (root == null) return true;\\n        Stack<TreeNode> st = new Stack<>();\\n        st.push(root.left);\\n        st.push(root.right);\\n        while (!st.isEmpty()) {\\n            TreeNode left = st.pop(), right = st.pop();\\n            if (left == null && right == null) continue;\\n            if (left == null || right == null || left.val != right.val) return false;\\n            st.push(left.right);\\n            st.push(right.left);\\n            st.push(right.right);\\n            st.push(left.left);\\n        }\\n        return true;\\n    }\\n```\\n\\n```\\ndef isSymmetric(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        def helper(left,right):\\n            if right == None or left  ==  None:\\n                return right  ==  None and left ==  None\\n            return right.val == left.val and helper(left.left,right.right) and helper(left.right, right.left)\\n        \\n        if root == None:\\n            return True\\n        return helper(root.left, root.right)\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isSymmetric(TreeNode root) {\\n        if (root == null) return true;\\n        Stack<TreeNode> st = new Stack<>();\\n        st.push(root.left);\\n        st.push(root.right);\\n        while (!st.isEmpty()) {\\n            TreeNode left = st.pop(), right = st.pop();\\n            if (left == null && right == null) continue;\\n            if (left == null || right == null || left.val != right.val) return false;\\n            st.push(left.right);\\n            st.push(right.left);\\n            st.push(right.right);\\n            st.push(left.left);\\n        }\\n        return true;\\n    }\\n```\n```\\ndef isSymmetric(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        def helper(left,right):\\n            if right == None or left  ==  None:\\n                return right  ==  None and left ==  None\\n            return right.val == left.val and helper(left.left,right.right) and helper(left.right, right.left)\\n        \\n        if root == None:\\n            return True\\n        return helper(root.left, root.right)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 343964,
                "title": "rust-0ms",
                "content": "```\\n// https://github.com/wangyuntao/leetcode-rs\\nimpl Solution {\\n    pub fn is_symmetric(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        type Rn = Rc<RefCell<TreeNode>>;\\n\\n        fn f(p: Option<&Rn>, q: Option<&Rn>) -> bool {\\n            match (p, q) {\\n                (None, None) => true,\\n                (Some(p), Some(q)) => {\\n                    let p = p.borrow();\\n                    let q = q.borrow();\\n                    p.val == q.val\\n                        && f(p.left.as_ref(), q.right.as_ref())\\n                        && f(p.right.as_ref(), q.left.as_ref())\\n                }\\n                _ => false,\\n            }\\n        }\\n\\n        match root {\\n            None => true,\\n            Some(n) => {\\n                let n = n.borrow();\\n                f(n.left.as_ref(), n.right.as_ref())\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// https://github.com/wangyuntao/leetcode-rs\\nimpl Solution {\\n    pub fn is_symmetric(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        type Rn = Rc<RefCell<TreeNode>>;\\n\\n        fn f(p: Option<&Rn>, q: Option<&Rn>) -> bool {\\n            match (p, q) {\\n                (None, None) => true,\\n                (Some(p), Some(q)) => {\\n                    let p = p.borrow();\\n                    let q = q.borrow();\\n                    p.val == q.val\\n                        && f(p.left.as_ref(), q.right.as_ref())\\n                        && f(p.right.as_ref(), q.left.as_ref())\\n                }\\n                _ => false,\\n            }\\n        }\\n\\n        match root {\\n            None => true,\\n            Some(n) => {\\n                let n = n.borrow();\\n                f(n.left.as_ref(), n.right.as_ref())\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 341522,
                "title": "js-dfs-solution",
                "content": "The key is to recognize the tree as two different tree. For the first tree, we go left -> right. For the second, we go right -> left.\\n\\n```\\nvar isSymmetric = function(root) {\\n    return helper(root, root)\\n};\\n\\nconst helper = function(p, q) {\\n    if (p == null && q == null)\\n        return true\\n    if (p == null || q == null)\\n        return false\\n    return p.val == q.val && helper(p.left, q.right) && helper(p.right, q.left)\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isSymmetric = function(root) {\\n    return helper(root, root)\\n};\\n\\nconst helper = function(p, q) {\\n    if (p == null && q == null)\\n        return true\\n    if (p == null || q == null)\\n        return false\\n    return p.val == q.val && helper(p.left, q.right) && helper(p.right, q.left)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 245871,
                "title": "simple-iterative-python-solution",
                "content": "Simple iterative Python solution.\\n\\n```       \\n        if not root:\\n            return True\\n        \\n        stack = [(root.left, root.right)]\\n     \\n        while stack:\\n            nodes = stack.pop()\\n\\t\\t\\t\\n            l, r = nodes\\n\\n            if l is None and r is None: \\n                continue  \\n            if l is None or r is None:\\n                return False\\n\\n            if l.val != r.val:  \\n                return False\\n\\n            stack.append((l.right,r.left))\\n            stack.append((l.left,r.right))\\n                \\n        return True\\n\\t\\t```",
                "solutionTags": [],
                "code": "```       \\n        if not root:\\n            return True\\n        \\n        stack = [(root.left, root.right)]\\n     \\n        while stack:\\n            nodes = stack.pop()\\n\\t\\t\\t\\n            l, r = nodes\\n\\n            if l is None and r is None: \\n                continue  \\n            if l is None or r is None:\\n                return False\\n\\n            if l.val != r.val:  \\n                return False\\n\\n            stack.append((l.right,r.left))\\n            stack.append((l.left,r.right))\\n                \\n        return True\\n\\t\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 33052,
                "title": "recursive-python-solution",
                "content": "Recursive Python Solution\\n```\\nclass Solution(object):\\n    \\n    def compare(self,rootleft,rootright):\\n        if rootleft == None or rootright == None:\\n            return rootleft==rootright\\n        return rootleft.val == rootright.val and self.compare(rootleft.left,rootright.right) and self.compare(rootleft.right,rootright.left)\\n    \\n    def isSymmetric(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not root:\\n            return True\\n        return self.compare(root.left,root.right)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    \\n    def compare(self,rootleft,rootright):\\n        if rootleft == None or rootright == None:\\n            return rootleft==rootright\\n        return rootleft.val == rootright.val and self.compare(rootleft.left,rootright.right) and self.compare(rootleft.right,rootright.left)\\n    \\n    def isSymmetric(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not root:\\n            return True\\n        return self.compare(root.left,root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 33234,
                "title": "java-1ms-recursive-solution-and-2ms-iterative-solution",
                "content": "Recursive:\\n\\n        public boolean isSymmetric(TreeNode root) {\\n    \\t\\tif (root == null)\\n    \\t\\t\\treturn true;\\n    \\t\\tif (root.left != null && root.right != null) {\\n    \\t\\t\\tif (root.left.val != root.right.val)\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\treturn isSymmetric(root.left, root.right);\\n    \\t}\\n    \\t\\n    \\tprivate boolean isSymmetric(TreeNode t1, TreeNode t2) {\\n    \\t\\tif (t1 == null && t2 == null)\\n    \\t\\t\\treturn true;\\n    \\t\\tif (t1 == null || t2 == null)\\n    \\t\\t\\treturn false;\\n    \\t\\tboolean isLeftSymmetric = isSymmetric(t1.left, t2.right);\\n    \\t\\tboolean isRightSymmetric = isSymmetric(t1.right, t2.left);\\n    \\t\\treturn (t1.val == t2.val) && isLeftSymmetric && isRightSymmetric;\\n    \\t}\\n\\nIterative:\\n\\n    public boolean isSymmetric(TreeNode root) {\\n    \\t\\tif (root == null)\\n    \\t\\t\\treturn true;\\n    \\t\\t\\n    \\t\\tQueue<TreeNode> left = new LinkedList<>();\\n    \\t\\tQueue<TreeNode> right = new LinkedList<>();\\n    \\t\\tleft.add(root.left);\\n    \\t\\tright.add(root.right);\\n    \\t\\twhile(!left.isEmpty() && !right.isEmpty()) {\\n    \\t\\t\\tTreeNode l = left.poll();\\n    \\t\\t\\tTreeNode r = right.poll();\\n    \\t\\t\\t\\n    \\t\\t\\tif (l == null && r == null)\\n    \\t\\t\\t\\tcontinue;\\n    \\t\\t\\tif (l == null || r == null)\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t\\t\\n    \\t\\t\\tif (l.val != r.val)\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t\\t\\n    \\t\\t\\tleft.add(l.left);\\n    \\t\\t\\tright.add(r.right);\\n    \\t\\t\\t\\n    \\t\\t\\tleft.add(l.right);\\n    \\t\\t\\tright.add(r.left);\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tif (left.isEmpty() && right.isEmpty())\\n    \\t\\t\\treturn true;\\n    \\t\\telse \\n    \\t\\t\\treturn false;\\n    \\t}",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "Recursive:\\n\\n        public boolean isSymmetric(TreeNode root) {\\n    \\t\\tif (root == null)\\n    \\t\\t\\treturn true;\\n    \\t\\tif (root.left != null && root.right != null) {\\n    \\t\\t\\tif (root.left.val != root.right.val)\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\treturn isSymmetric(root.left, root.right);\\n    \\t}\\n    \\t\\n    \\tprivate boolean isSymmetric(TreeNode t1, TreeNode t2) {\\n    \\t\\tif (t1 == null && t2 == null)\\n    \\t\\t\\treturn true;\\n    \\t\\tif (t1 == null || t2 == null)\\n    \\t\\t\\treturn false;\\n    \\t\\tboolean isLeftSymmetric = isSymmetric(t1.left, t2.right);\\n    \\t\\tboolean isRightSymmetric = isSymmetric(t1.right, t2.left);\\n    \\t\\treturn (t1.val == t2.val) && isLeftSymmetric && isRightSymmetric;\\n    \\t}\\n\\nIterative:\\n\\n    public boolean isSymmetric(TreeNode root) {\\n    \\t\\tif (root == null)\\n    \\t\\t\\treturn true;\\n    \\t\\t\\n    \\t\\tQueue<TreeNode> left = new LinkedList<>();\\n    \\t\\tQueue<TreeNode> right = new LinkedList<>();\\n    \\t\\tleft.add(root.left);\\n    \\t\\tright.add(root.right);\\n    \\t\\twhile(!left.isEmpty() && !right.isEmpty()) {\\n    \\t\\t\\tTreeNode l = left.poll();\\n    \\t\\t\\tTreeNode r = right.poll();\\n    \\t\\t\\t\\n    \\t\\t\\tif (l == null && r == null)\\n    \\t\\t\\t\\tcontinue;\\n    \\t\\t\\tif (l == null || r == null)\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t\\t\\n    \\t\\t\\tif (l.val != r.val)\\n    \\t\\t\\t\\treturn false;\\n    \\t\\t\\t\\n    \\t\\t\\tleft.add(l.left);\\n    \\t\\t\\tright.add(r.right);\\n    \\t\\t\\t\\n    \\t\\t\\tleft.add(l.right);\\n    \\t\\t\\tright.add(r.left);\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tif (left.isEmpty() && right.isEmpty())\\n    \\t\\t\\treturn true;\\n    \\t\\telse \\n    \\t\\t\\treturn false;\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 33304,
                "title": "java-1m-simple-solution-with-recursion",
                "content": "public class Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        if(root == null) return true;\\n        return isSymmetric(root.left, root.right);\\n    }\\n    \\n    public boolean isSymmetric(TreeNode node1 , TreeNode node2){\\n        if(node1 == null && node2 == null) return true;\\n        if(node1 == null || node2 == null) return false;\\n        \\n        return node1.val == node2.val\\n               &&isSymmetric(node1.left, node2.right)\\n               && isSymmetric(node1.right,node2.left);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        if(root == null) return true;\\n        return isSymmetric(root.left, root.right);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 33337,
                "title": "0ms-c-language-solution",
                "content": "    /**\\n     * Definition for a binary tree node.\\n     * struct TreeNode {\\n     *     int val;\\n     *     struct TreeNode *left;\\n     *     struct TreeNode *right;\\n     * };\\n     */\\n    \\n    bool checkNodes(struct TreeNode* a, struct TreeNode* b)\\n    {\\n        if(a == NULL && b == NULL)\\n        {\\n            return true;\\n        }\\n        \\n        if(a == NULL || b == NULL)\\n        {\\n            return false;\\n        }\\n        if(a->val != b->val)\\n        {\\n            return false;\\n        }\\n        return checkNodes(a->left, b->right) && checkNodes(a->right, b->left);\\n    }\\n    bool isSymmetric(struct TreeNode* root) {\\n        if(root == NULL)\\n        {\\n            return true;\\n        }\\n        return checkNodes(root->left, root->right);\\n    }",
                "solutionTags": [],
                "code": "    /**\\n     * Definition for a binary tree node.\\n     * struct TreeNode {\\n     *     int val;\\n     *     struct TreeNode *left;\\n     *     struct TreeNode *right;\\n     * };\\n     */\\n    \\n    bool checkNodes(struct TreeNode* a, struct TreeNode* b)\\n    {\\n        if(a == NULL && b == NULL)\\n        {\\n            return true;\\n        }\\n        \\n        if(a == NULL || b == NULL)\\n        {\\n            return false;\\n        }\\n        if(a->val != b->val)\\n        {\\n            return false;\\n        }\\n        return checkNodes(a->left, b->right) && checkNodes(a->right, b->left);\\n    }\\n    bool isSymmetric(struct TreeNode* root) {\\n        if(root == NULL)\\n        {\\n            return true;\\n        }\\n        return checkNodes(root->left, root->right);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 33390,
                "title": "share-my-accepted-2-line-simple-recurion-solution-java",
                "content": "Recursively compare left.left with right.right and left.right, right.left.\\n  \\n    public static boolean isSymmetric(TreeNode root) {\\n    \\treturn isSymmetric(root, root);\\n    }\\n    \\n    public static boolean isSymmetric(TreeNode left, TreeNode right) {\\n        if(left == null || right == null) return left == right;\\n        return (left.val == right.val) && isSymmetric(left.left, right.right) && isSymmetric(left.right, right.left);\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "Recursively compare left.left with right.right and left.right, right.left.\\n  \\n    public static boolean isSymmetric(TreeNode root) {\\n    \\treturn isSymmetric(root, root);\\n    }\\n    \\n    public static boolean isSymmetric(TreeNode left, TreeNode right) {\\n        if(left == null || right == null) return left == right;\\n        return (left.val == right.val) && isSymmetric(left.left, right.right) && isSymmetric(left.right, right.left);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3291861,
                "title": "fast-explained-solution-c",
                "content": "# Idea\\n\\nAt the same level, the **left node on the left side** should be equal to the **right node on the right side**.\\n\\n*Have a look at this:*\\n\\n![explain ques2.png](https://assets.leetcode.com/users/images/fdb1fcd0-5a22-4bf8-8359-6e8a426ae70d_1678682830.9710195.png)\\n\\n\\n![explain ques.png](https://assets.leetcode.com/users/images/73c5c4bf-a7aa-4dc6-88c2-fca4d0e38017_1678682816.57048.png)\\n\\nI hope you can understand it a bit more clearly now;\\n\\n``` C++ []\\nclass Solution {\\nprivate:\\n    bool isEquivalent(TreeNode* left, TreeNode* right) {\\n        if (!left || !right) return left == right;\\n        else return left->val == right->val && isEquivalent(left->left, right->right) && isEquivalent(right->left, left->right);\\n    }\\n\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        return isEquivalent(root->left, root->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` C++ []\\nclass Solution {\\nprivate:\\n    bool isEquivalent(TreeNode* left, TreeNode* right) {\\n        if (!left || !right) return left == right;\\n        else return left->val == right->val && isEquivalent(left->left, right->right) && isEquivalent(right->left, left->right);\\n    }\\n\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        return isEquivalent(root->left, root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291856,
                "title": "fast-explained-solution-java-beats-100-submissions",
                "content": "# Idea\\n\\nAt the same level, the **left node on the left side** should be equal to the **right node on the right side**.\\n\\n*Have a look at this:*\\n\\n![explain ques2.png](https://assets.leetcode.com/users/images/fdb1fcd0-5a22-4bf8-8359-6e8a426ae70d_1678682830.9710195.png)\\n\\n\\n![explain ques.png](https://assets.leetcode.com/users/images/73c5c4bf-a7aa-4dc6-88c2-fca4d0e38017_1678682816.57048.png)\\n\\nI hope you can understand it a bit more clearly now;\\n\\n**This JAVA solution beats 100% of all submissions:**\\n\\n``` JAVA []\\nclass Solution {\\n    private boolean isEquivalent(TreeNode left, TreeNode right) {\\n        if (left==null || right==null) return left == right;\\n        else return left.val == right.val && isEquivalent(left.left, right.right) && isEquivalent(left.right, right.left);\\n    }\\n\\n    public boolean isSymmetric(TreeNode root) {\\n        return isEquivalent(root.left, root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` JAVA []\\nclass Solution {\\n    private boolean isEquivalent(TreeNode left, TreeNode right) {\\n        if (left==null || right==null) return left == right;\\n        else return left.val == right.val && isEquivalent(left.left, right.right) && isEquivalent(left.right, right.left);\\n    }\\n\\n    public boolean isSymmetric(TreeNode root) {\\n        return isEquivalent(root.left, root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291174,
                "title": "top-1-rare-approach",
                "content": "# ***`Ladies and gentlemen, distinguished guests, and esteemed colleagues, it is my utmost pleasure to address you today.`***\\n\\n*As we gather here,* ***I feel honored to share my passion for problem-solving and collaboration with individuals such as yourselves.*** \\n*Through my extensive experience and expertise,* ***I have learned that the key to success lies in forming connections with like-minded professionals who share a common vision for growth and development.***\\n#\\n*As we all know,* **[LinkedIn](https://www.linkedin.com/in/cucerdariancatalin/)** ***provides us*** *with a* ***unique*** ***opportunity to expand our networks*** *and form* ***meaningful connections*** *with individuals from all walks of life*.\\n`By connecting with me,` *you will have the chance to collaborate on complex* ***challenges,*** *share ***innovative*** ideas,* *and ***together,*** achieve professional and personal* ***[growth]().***\\n\\n`No matter your background or level of experience`, I ***[invite]()*** you to ***join me*** on this ***journey*** towards excellence. By ***working together*** and ***leveraging*** our diverse ***perspectives***,* `we can achieve what was once thought impossible.`\\n\\n*So, let us not hesitate to take the ***first step*** `towards a brighter future`. ***Reach out to me today***, and let us `START a conversation that will take us to new heights!`*\\n\\n# [\\uD83D\\uDE4F\\uD83C\\uDFFB Let\\'s connect & **SHARE** network on **LinkedIn**](https://www.linkedin.com/in/cucerdariancatalin/)\\n\\n# [\\uD83E\\uDDF3 Be part of **The Money Team\\xAE (TMT)**](https://www.linkedin.com/newsletters/7034097027214946304/)\\n\\n# [\\u23F3 Sharing Knowledge on **Medium**](https://medium.com/@cucerdariancatalin)\\n\\n\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar isSymmetric = function(root) {\\n    if(!root) return true;\\n    return symmetryChk(root.left , root.right);\\n};\\n    \\nconst symmetryChk = function (leftNode , rightNode) {\\n    if (!leftNode && !rightNode) return true;\\n    if(!leftNode || !rightNode) return false;\\n    if(leftNode.val !== rightNode.val) return false;\\n\\n    return (symmetryChk(leftNode.left , rightNode.right) && symmetryChk(leftNode.right , rightNode.left));\\n};\\n\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar isSymmetric = function(root) {\\n    if(!root) return true;\\n    return symmetryChk(root.left , root.right);\\n};\\n    \\nconst symmetryChk = function (leftNode , rightNode) {\\n    if (!leftNode && !rightNode) return true;\\n    if(!leftNode || !rightNode) return false;\\n    if(leftNode.val !== rightNode.val) return false;\\n\\n    return (symmetryChk(leftNode.left , rightNode.right) && symmetryChk(leftNode.right , rightNode.left));\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3291170,
                "title": "top-1-rare-approach",
                "content": "# ***`Ladies and gentlemen, distinguished guests, and esteemed colleagues, it is my utmost pleasure to address you today.`***\\n\\n*As we gather here,* ***I feel honored to share my passion for problem-solving and collaboration with individuals such as yourselves.*** \\n*Through my extensive experience and expertise,* ***I have learned that the key to success lies in forming connections with like-minded professionals who share a common vision for growth and development.***\\n#\\n*As we all know,* **[LinkedIn](https://www.linkedin.com/in/cucerdariancatalin/)** ***provides us*** *with a* ***unique*** ***opportunity to expand our networks*** *and form* ***meaningful connections*** *with individuals from all walks of life*.\\n`By connecting with me,` *you will have the chance to collaborate on complex* ***challenges,*** *share ***innovative*** ideas,* *and ***together,*** achieve professional and personal* ***[growth]().***\\n\\n`No matter your background or level of experience`, I ***[invite]()*** you to ***join me*** on this ***journey*** towards excellence. By ***working together*** and ***leveraging*** our diverse ***perspectives***,* `we can achieve what was once thought impossible.`\\n\\n*So, let us not hesitate to take the ***first step*** `towards a brighter future`. ***Reach out to me today***, and let us `START a conversation that will take us to new heights!`*\\n\\n# [\\uD83D\\uDE4F\\uD83C\\uDFFB Let\\'s connect & **SHARE** network on **LinkedIn**](https://www.linkedin.com/in/cucerdariancatalin/)\\n\\n# [\\uD83E\\uDDF3 Be part of **The Money Team\\xAE (TMT)**](https://www.linkedin.com/newsletters/7034097027214946304/)\\n\\n# [\\u23F3 Sharing Knowledge on **Medium**](https://medium.com/@cucerdariancatalin)\\n\\n\\n\\n```\\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n        def _symmetric(n1, n2):        \\n            if not n1 and not n2:\\n                return True\\n            if (not n1 and n2) or (not n2 and n1):\\n                return False\\n            return n1.val == n2.val and _symmetric(n1.left, n2.right) and _symmetric(n1.right, n2.left)\\n           \\n        return _symmetric(root, root) \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n        def _symmetric(n1, n2):        \\n            if not n1 and not n2:\\n                return True\\n            if (not n1 and n2) or (not n2 and n1):\\n                return False\\n            return n1.val == n2.val and _symmetric(n1.left, n2.right) and _symmetric(n1.right, n2.left)\\n           \\n        return _symmetric(root, root) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290629,
                "title": "fast-easy-solution-java-c-explained-with-illustrations",
                "content": "# Idea\\n\\nAt the same level, the **left node on the left side** should be equal to the **right node on the right side**.\\n\\n*Have a look at this:*\\n\\n![explain ques2.png](https://assets.leetcode.com/users/images/fdb1fcd0-5a22-4bf8-8359-6e8a426ae70d_1678682830.9710195.png)\\n\\n\\n![explain ques.png](https://assets.leetcode.com/users/images/73c5c4bf-a7aa-4dc6-88c2-fca4d0e38017_1678682816.57048.png)\\n\\nI hope you can understand it a bit more clearly now;\\n\\n**This JAVA solution beats 100% of all submissions:**\\n\\n``` JAVA []\\nclass Solution {\\n    private boolean isEquivalent(TreeNode left, TreeNode right) {\\n        if (left==null || right==null) return left == right;\\n        else return left.val == right.val && isEquivalent(left.left, right.right) && isEquivalent(left.right, right.left);\\n    }\\n\\n    public boolean isSymmetric(TreeNode root) {\\n        return isEquivalent(root.left, root.right);\\n    }\\n}\\n```\\n\\nNo worries, I also got **C++** for you guys too:\\n\\nApprently this is the same code as the JAVA one but doesn\\'t beat 100% of all submissions - can you **tell why** in the comments?\\n\\n``` C++ []\\nclass Solution {\\nprivate:\\n    bool isEquivalent(TreeNode* left, TreeNode* right) {\\n        if (!left || !right) return left == right;\\n        else return left->val == right->val && isEquivalent(left->left, right->right) && isEquivalent(right->left, left->right);\\n    }\\n\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        return isEquivalent(root->left, root->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "``` JAVA []\\nclass Solution {\\n    private boolean isEquivalent(TreeNode left, TreeNode right) {\\n        if (left==null || right==null) return left == right;\\n        else return left.val == right.val && isEquivalent(left.left, right.right) && isEquivalent(left.right, right.left);\\n    }\\n\\n    public boolean isSymmetric(TreeNode root) {\\n        return isEquivalent(root.left, root.right);\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\nprivate:\\n    bool isEquivalent(TreeNode* left, TreeNode* right) {\\n        if (!left || !right) return left == right;\\n        else return left->val == right->val && isEquivalent(left->left, right->right) && isEquivalent(right->left, left->right);\\n    }\\n\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        return isEquivalent(root->left, root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225162,
                "title": "best-o-n-solution",
                "content": "# Approach\\nPreorder traversal\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        return isSame(root->left, root->right);\\n    }\\nprivate:\\n    bool isSame(TreeNode* p, TreeNode* q) {\\n        if (!p && !q)\\n            return true;\\n        if (!p || !q)\\n            return false;   \\n        if (p->val != q->val)\\n            return false;\\n        bool l = isSame(p->left, q->right);  \\n        bool r = isSame(p->right, q->left);  \\n        if (!l || !r)\\n            return false;\\n        return true;           \\n    }    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        return isSame(root->left, root->right);\\n    }\\nprivate:\\n    bool isSame(TreeNode* p, TreeNode* q) {\\n        if (!p && !q)\\n            return true;\\n        if (!p || !q)\\n            return false;   \\n        if (p->val != q->val)\\n            return false;\\n        bool l = isSame(p->left, q->right);  \\n        bool r = isSame(p->right, q->left);  \\n        if (!l || !r)\\n            return false;\\n        return true;           \\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859615,
                "title": "c-recursion-dfs",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool check(TreeNode * left, TreeNode * right){\\n        if(right == NULL && left == NULL){\\n            return true;\\n        }\\n        if(left == NULL && right != NULL){\\n            return false;\\n        }\\n        if(left != NULL && right == NULL){\\n            return false;\\n        }\\n        if(right->val != left->val){\\n                return false;\\n        }\\n        \\n        return check(left->left,right->right) && check(left->right,right->left);\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        if(root == NULL){\\n            return true;\\n        }\\n        return check(root,root);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool check(TreeNode * left, TreeNode * right){\\n        if(right == NULL && left == NULL){\\n            return true;\\n        }\\n        if(left == NULL && right != NULL){\\n            return false;\\n        }\\n        if(left != NULL && right == NULL){\\n            return false;\\n        }\\n        if(right->val != left->val){\\n                return false;\\n        }\\n        \\n        return check(left->left,right->right) && check(left->right,right->left);\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        if(root == NULL){\\n            return true;\\n        }\\n        return check(root,root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812680,
                "title": "bfs-for-children",
                "content": "```\\nclass Solution(object):\\n    def isSymmetric(self, root):\\n        if not root:\\n            return True\\n        \\n        queue = [root.left, root.right]\\n        \\n        while len(queue) > 0:\\n            left = queue.pop(0)\\n            right = queue.pop(0)\\n            \\n            if not left and not right:\\n                continue\\n            elif left and right and left.val == right.val:\\n                pass\\n            else:\\n                return False\\n            \\n            queue.append(left.left)\\n            queue.append(right.right)\\n            queue.append(left.right)\\n            queue.append(right.left)\\n        \\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isSymmetric(self, root):\\n        if not root:\\n            return True\\n        \\n        queue = [root.left, root.right]\\n        \\n        while len(queue) > 0:\\n            left = queue.pop(0)\\n            right = queue.pop(0)\\n            \\n            if not left and not right:\\n                continue\\n            elif left and right and left.val == right.val:\\n                pass\\n            else:\\n                return False\\n            \\n            queue.append(left.left)\\n            queue.append(right.right)\\n            queue.append(left.right)\\n            queue.append(right.left)\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2710270,
                "title": "c-1-line-answer-simple-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isMirror(TreeNode* root1, TreeNode* root2){\\n        if(root1 == NULL && root2 == NULL){\\n            return true;\\n        }\\n        if(root1 && root2 && root1->val == root2->val)\\n           return isMirror(root1->left, root2->right) && isMirror(root1->right, root2->left);\\n        \\n        return false;\\n    }\\n    \\n\\n    bool isSymmetric(TreeNode* root) {\\n        return isMirror(root, root);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isMirror(TreeNode* root1, TreeNode* root2){\\n        if(root1 == NULL && root2 == NULL){\\n            return true;\\n        }\\n        if(root1 && root2 && root1->val == root2->val)\\n           return isMirror(root1->left, root2->right) && isMirror(root1->right, root2->left);\\n        \\n        return false;\\n    }\\n    \\n\\n    bool isSymmetric(TreeNode* root) {\\n        return isMirror(root, root);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674497,
                "title": "2-great-python-solutions",
                "content": "**DFS Recursive Solution**\\n```\\ndef isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n\\tdef checkSymmetry(lft, rght): # helper method\\n\\t\\tif lft and rght and lft.val == rght.val: # if both sides exist and have equal value\\n\\t\\t\\t# the left side on the left should equal the right side on the right\\n\\t\\t\\t# the right side on the left should equal the left side on the right\\n\\t\\t\\treturn checkSymmetry(lft.left,rght.right) and checkSymmetry(lft.right,rght.left) \\n\\t\\treturn not lft and not rght # if neither side exists, it is symmetric; if one side exists, it is not\\n\\treturn checkSymmetry(root.left, root.right) # check the left and the right are symmetric\\n```\\nThe key here is that the left side of the left subtree of ```root``` should be symmetric to the right side of the right subtree of ```root``` and the right side of the left subtree of ```root``` should be symmetric to the left side of the right subtree of ```root```. Using this relationship we can create a simple DFS recursive solution.\\n\\n**BFS Iterative Solution**\\n```\\ndef isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n\\tleftSide = collections.deque([root.left]) # bfs queue for the left side\\n\\trightSide = collections.deque([root.right]) # bfs queue for the right side\\n\\twhile leftSide and rightSide: # while both exist\\n\\t\\tleft = leftSide.popleft() # node on the left side\\n\\t\\tright = rightSide.popleft() # node on the right side\\n\\t\\tif left and right: # if both nodes exist\\n\\t\\t\\tif not left.val == right.val: # make sure they have the same value\\n\\t\\t\\t\\treturn False\\n\\t\\t\\t# append the nodes in the next level in the opposite order to check for symmetry\\n\\t\\t\\tleftSide.append(left.left) \\n\\t\\t\\tleftSide.append(left.right)\\n\\t\\t\\trightSide.append(right.right)\\n\\t\\t\\trightSide.append(right.left)\\n\\t\\telif left or right: # if only one side has a node, it is not symmetric\\n\\t\\t\\treturn False\\n\\treturn not leftSide and not rightSide # make sure neither side has any nodes remaining\\n```\\nIn this solution we essentially find the level-order traversal of the left subtree and right subtree of ```root``` but we traverse them in opposite directions. If the traversals ever differ then we know that the tree is not symmetric, so we return ```False```. If we never encounter a difference, and neither side has nodes left, we return ```True```.\\n\\n**Thanks for Reading!**\\nIf this post has been helpful, please consider upvoting! If you have any questions, please feel free to ask in the comments and I will try to answer them. Also, if I made any mistakes or there are other optimizations, methods I didn\\'t consider, etc. please let me know!",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\ndef isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n\\tdef checkSymmetry(lft, rght): # helper method\\n\\t\\tif lft and rght and lft.val == rght.val: # if both sides exist and have equal value\\n\\t\\t\\t# the left side on the left should equal the right side on the right\\n\\t\\t\\t# the right side on the left should equal the left side on the right\\n\\t\\t\\treturn checkSymmetry(lft.left,rght.right) and checkSymmetry(lft.right,rght.left) \\n\\t\\treturn not lft and not rght # if neither side exists, it is symmetric; if one side exists, it is not\\n\\treturn checkSymmetry(root.left, root.right) # check the left and the right are symmetric\\n```\n```root```\n```root```\n```root```\n```root```\n```\\ndef isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n\\tleftSide = collections.deque([root.left]) # bfs queue for the left side\\n\\trightSide = collections.deque([root.right]) # bfs queue for the right side\\n\\twhile leftSide and rightSide: # while both exist\\n\\t\\tleft = leftSide.popleft() # node on the left side\\n\\t\\tright = rightSide.popleft() # node on the right side\\n\\t\\tif left and right: # if both nodes exist\\n\\t\\t\\tif not left.val == right.val: # make sure they have the same value\\n\\t\\t\\t\\treturn False\\n\\t\\t\\t# append the nodes in the next level in the opposite order to check for symmetry\\n\\t\\t\\tleftSide.append(left.left) \\n\\t\\t\\tleftSide.append(left.right)\\n\\t\\t\\trightSide.append(right.right)\\n\\t\\t\\trightSide.append(right.left)\\n\\t\\telif left or right: # if only one side has a node, it is not symmetric\\n\\t\\t\\treturn False\\n\\treturn not leftSide and not rightSide # make sure neither side has any nodes remaining\\n```\n```root```\n```False```\n```True```",
                "codeTag": "Python3"
            },
            {
                "id": 2568119,
                "title": "97-80-senior-developer-javascript-js-2022",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar isSymmetric = function(node1, node2) {\\n    if(node2 === undefined) {\\n        node2 = node1.right;\\n        node1 = node1.left;\\n    }\\n    if (node1 === null && node2 === null) return true;  \\n    if (node1 === null || node2 === null || node1.val !== node2.val) return false;\\n    return isSymmetric(node1.left, node2.right) && isSymmetric(node1.right, node2.left);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar isSymmetric = function(node1, node2) {\\n    if(node2 === undefined) {\\n        node2 = node1.right;\\n        node1 = node1.left;\\n    }\\n    if (node1 === null && node2 === null) return true;  \\n    if (node1 === null || node2 === null || node1.val !== node2.val) return false;\\n    return isSymmetric(node1.left, node2.right) && isSymmetric(node1.right, node2.left);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2346923,
                "title": "c-solution-using-recursion-simple-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n\\t\\n\\t//checking if the left subtree and right subtree are mirror images or not\\n    bool isMirror(TreeNode* root1, TreeNode* root2) \\n    {\\n        if(root1==NULL && root2==NULL) //if both trees are empty\\n            return true;\\n        if(root1==NULL || root2==NULL) //if one of the trees is empty\\n            return false;\\n        return root1->val==root2->val && isMirror(root1->left, root2->right) && isMirror(root1->right, root2->left);\\n    }\\n\\t\\n    bool isSymmetric(TreeNode* root) {\\n        return isMirror(root->left, root->right); //sending the left node and right node of the root to the isMirror function\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t\\n\\t//checking if the left subtree and right subtree are mirror images or not\\n    bool isMirror(TreeNode* root1, TreeNode* root2) \\n    {\\n        if(root1==NULL && root2==NULL) //if both trees are empty\\n            return true;\\n        if(root1==NULL || root2==NULL) //if one of the trees is empty\\n            return false;\\n        return root1->val==root2->val && isMirror(root1->left, root2->right) && isMirror(root1->right, root2->left);\\n    }\\n\\t\\n    bool isSymmetric(TreeNode* root) {\\n        return isMirror(root->left, root->right); //sending the left node and right node of the root to the isMirror function\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2172540,
                "title": "python3-recursive-solution-using-dfs",
                "content": "```\\nclass Solution:\\n    \\n    def isSymmetric(self, root: TreeNode) -> bool:\\n        if root==None:\\n            return True\\n        \\n        def getResult(left,right):\\n\\n            if left==None and right==None:\\n                return True\\n            if left==None or right==None or left.val != right.val:\\n                return False\\n\\n            return getResult(left.left,right.right) and getResult(left.right,right.left)\\n        \\n        return getResult(root.left,root.right)\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def isSymmetric(self, root: TreeNode) -> bool:\\n        if root==None:\\n            return True\\n        \\n        def getResult(left,right):\\n\\n            if left==None and right==None:\\n                return True\\n            if left==None or right==None or left.val != right.val:\\n                return False\\n\\n            return getResult(left.left,right.right) and getResult(left.right,right.left)\\n        \\n        return getResult(root.left,root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2008719,
                "title": "o-n-time-beats-99-97-memory-speed-0ms-may-2022",
                "content": "```\\n```\\n\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* ***Java***\\n```\\npublic boolean isSymmetric(TreeNode root) {\\n    if(root==null)  return true;\\n    \\n    Stack<TreeNode> stack = new Stack<TreeNode>();\\n    TreeNode left, right;\\n    if(root.left!=null){\\n        if(root.right==null) return false;\\n        stack.push(root.left);\\n        stack.push(root.right);\\n    }\\n    else if(root.right!=null){\\n        return false;\\n    }\\n        \\n    while(!stack.empty()){\\n        if(stack.size()%2!=0)   return false;\\n        right = stack.pop();\\n        left = stack.pop();\\n        if(right.val!=left.val) return false;\\n        \\n        if(left.left!=null){\\n            if(right.right==null)   return false;\\n            stack.push(left.left);\\n            stack.push(right.right);\\n        }\\n        else if(right.right!=null){\\n            return false;\\n        }\\n            \\n        if(left.right!=null){\\n            if(right.left==null)   return false;\\n            stack.push(left.right);\\n            stack.push(right.left);\\n        }\\n        else if(right.left!=null){\\n            return false;\\n        }\\n    }\\n    \\n    return true;\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 7.0MB*** (beats 100.00% / 100.00%).\\n* ***C++***\\n```\\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        \\n        if(root==NULL) return true; //Tree is empty\\n        \\n        return isSymmetricTest(root->left,root->right);\\n    }\\n    \\n    bool isSymmetricTest(TreeNode* p , TreeNode* q){\\n        if(p == NULL && q == NULL) //left & right node is NULL \\n            return true; \\n        \\n        else if(p == NULL || q == NULL) //one of them is Not NULL\\n            return false; \\n        \\n        else if(p->val!=q->val) \\n            return false;\\n        \\n        return isSymmetricTest(p->left,q->right) && isSymmetricTest(p->right,q->left); //comparing left subtree\\'s left child with right subtree\\'s right child --AND-- comparing left subtree\\'s right child with right subtree\\'s left child\\n    }\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n\\nThe best result for the code below is ***26ms / 12.2MB*** (beats 95.42% / 82.32%).\\n* ***Python***\\n```\\ndef isSymmetric(self, root):\\n        def isSym(L,R):\\n            if not L and not R: return True\\n            if L and R and L.val == R.val: \\n                return isSym(L.left, R.right) and isSym(L.right, R.left)\\n            return False\\n        return isSym(root, root)\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***51ms / 34.2MB*** (beats 100.00% / 84.12%).\\n* ***JavaScript***\\n```\\nar isSymmetric = function(root) {\\n    if (root == null) return true;\\n    \\n    return symmetryChecker(root.left, root.right);\\n};\\n\\nfunction symmetryChecker(left, right) {\\n    if (left == null && right == null) return true; // If both sub trees are empty\\n    if (left == null || right == null) return false; // If only one of the sub trees are empty\\n    if (left.val !== right.val) return false; // If the values dont match up\\n    \\n\\t// Check both subtrees but travelled in a mirrored/symmetric fashion\\n\\t// (one goes left, other goes right)  and make sure they\\'re both symmetric\\n    return symmetryChecker(left.left, right.right) &&\\n    symmetryChecker(left.right, right.left);\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***68ms / 44.2MB*** (beats 100.00% / 45.25%).\\n* ***Kotlin***\\n```\\nclass Solution {\\n    fun isSymmetric(root: TreeNode?): Boolean {\\n        if (root == null)\\n            return true\\n        return helper(root.left, root.right)\\n    }\\n    \\n    fun helper(root: TreeNode?, flip: TreeNode?): Boolean {\\n\\t\\t// Same but null\\n        if (root == null && flip == null)\\n            return true\\n        \\n\\t\\t// Only one is null. Easy out, but also prevents numerous null checks\\n        if (root == null || flip == null)\\n            return false\\n        \\n\\t\\t// Aren\\'t equal\\n        if (root.`val` != flip.`val`)\\n            return false\\n        \\n        return helper(root.left, flip.right) && helper(root.right, flip.left)\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***12ms / 32.2MB*** (beats 95% / 84%).\\n* ***Swift***\\n```\\nclass Solution {\\n    func isSymmetric(_ root: TreeNode?) -> Bool {\\n\\t\\troot?.left == root?.right\\n\\t}\\n}\\n\\nextension TreeNode: Equatable {\\n    public static func ==(lhs: TreeNode, rhs: TreeNode) -> Bool {\\n        lhs.val == rhs.val && lhs.left == rhs.right && lhs.right == rhs.left\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin",
                    "Recursion"
                ],
                "code": "```\\n```\n```\\n```\n```\\n```\n```\\n```\n```\\npublic boolean isSymmetric(TreeNode root) {\\n    if(root==null)  return true;\\n    \\n    Stack<TreeNode> stack = new Stack<TreeNode>();\\n    TreeNode left, right;\\n    if(root.left!=null){\\n        if(root.right==null) return false;\\n        stack.push(root.left);\\n        stack.push(root.right);\\n    }\\n    else if(root.right!=null){\\n        return false;\\n    }\\n        \\n    while(!stack.empty()){\\n        if(stack.size()%2!=0)   return false;\\n        right = stack.pop();\\n        left = stack.pop();\\n        if(right.val!=left.val) return false;\\n        \\n        if(left.left!=null){\\n            if(right.right==null)   return false;\\n            stack.push(left.left);\\n            stack.push(right.right);\\n        }\\n        else if(right.right!=null){\\n            return false;\\n        }\\n            \\n        if(left.right!=null){\\n            if(right.left==null)   return false;\\n            stack.push(left.right);\\n            stack.push(right.left);\\n        }\\n        else if(right.left!=null){\\n            return false;\\n        }\\n    }\\n    \\n    return true;\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        \\n        if(root==NULL) return true; //Tree is empty\\n        \\n        return isSymmetricTest(root->left,root->right);\\n    }\\n    \\n    bool isSymmetricTest(TreeNode* p , TreeNode* q){\\n        if(p == NULL && q == NULL) //left & right node is NULL \\n            return true; \\n        \\n        else if(p == NULL || q == NULL) //one of them is Not NULL\\n            return false; \\n        \\n        else if(p->val!=q->val) \\n            return false;\\n        \\n        return isSymmetricTest(p->left,q->right) && isSymmetricTest(p->right,q->left); //comparing left subtree\\'s left child with right subtree\\'s right child --AND-- comparing left subtree\\'s right child with right subtree\\'s left child\\n    }\\n};\\n```\n```\\n```\n```\\n```\n```\\ndef isSymmetric(self, root):\\n        def isSym(L,R):\\n            if not L and not R: return True\\n            if L and R and L.val == R.val: \\n                return isSym(L.left, R.right) and isSym(L.right, R.left)\\n            return False\\n        return isSym(root, root)\\n```\n```\\n```\n```\\n```\n```\\nar isSymmetric = function(root) {\\n    if (root == null) return true;\\n    \\n    return symmetryChecker(root.left, root.right);\\n};\\n\\nfunction symmetryChecker(left, right) {\\n    if (left == null && right == null) return true; // If both sub trees are empty\\n    if (left == null || right == null) return false; // If only one of the sub trees are empty\\n    if (left.val !== right.val) return false; // If the values dont match up\\n    \\n\\t// Check both subtrees but travelled in a mirrored/symmetric fashion\\n\\t// (one goes left, other goes right)  and make sure they\\'re both symmetric\\n    return symmetryChecker(left.left, right.right) &&\\n    symmetryChecker(left.right, right.left);\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    fun isSymmetric(root: TreeNode?): Boolean {\\n        if (root == null)\\n            return true\\n        return helper(root.left, root.right)\\n    }\\n    \\n    fun helper(root: TreeNode?, flip: TreeNode?): Boolean {\\n\\t\\t// Same but null\\n        if (root == null && flip == null)\\n            return true\\n        \\n\\t\\t// Only one is null. Easy out, but also prevents numerous null checks\\n        if (root == null || flip == null)\\n            return false\\n        \\n\\t\\t// Aren\\'t equal\\n        if (root.`val` != flip.`val`)\\n            return false\\n        \\n        return helper(root.left, flip.right) && helper(root.right, flip.left)\\n    }\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    func isSymmetric(_ root: TreeNode?) -> Bool {\\n\\t\\troot?.left == root?.right\\n\\t}\\n}\\n\\nextension TreeNode: Equatable {\\n    public static func ==(lhs: TreeNode, rhs: TreeNode) -> Bool {\\n        lhs.val == rhs.val && lhs.left == rhs.right && lhs.right == rhs.left\\n    }\\n}\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1836696,
                "title": "c-2-approaches-recursive-iterative-o-n-time-easy-clean-code",
                "content": "**1. Recursive**\\n```\\nbool isSymmetric(TreeNode* l,TreeNode* r)\\n    {\\n        if(!l && !r)\\n            return 1;\\n        \\n        if(!l || !r || l->val!=r->val)\\n            return 0;\\n        \\n        return isSymmetric(l->left,r->right) && isSymmetric(l->right,r->left);\\n    }\\n    \\n    bool isSymmetric(TreeNode* root) {\\n        if(!root)\\n            return 1;\\n        \\n        return isSymmetric(root->left,root->right);\\n    }\\n```\\n\\n**2. Iterative**\\n```\\nbool isSymmetric(TreeNode* root) {\\n        \\n        if(!root)\\n            return 1;\\n        \\n        queue<TreeNode*> q;\\n        q.push(root->left);\\n        q.push(root->right);\\n        \\n        while(!q.empty())\\n        {\\n            TreeNode *l,*r;\\n            \\n            l=q.front();\\n            q.pop();\\n            \\n            r=q.front();\\n            q.pop();\\n            \\n            if(!l && !r)\\n                continue;\\n            \\n            if(!l || !r || l->val!=r->val)\\n                return 0;\\n            \\n            q.push(l->left);\\n            q.push(r->right);\\n            \\n            q.push(l->right);\\n            q.push(r->left);\\n        }\\n        return 1;\\n    }\\n```\\n\\n**Do share your views & upvote if you like !!!**  \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nbool isSymmetric(TreeNode* l,TreeNode* r)\\n    {\\n        if(!l && !r)\\n            return 1;\\n        \\n        if(!l || !r || l->val!=r->val)\\n            return 0;\\n        \\n        return isSymmetric(l->left,r->right) && isSymmetric(l->right,r->left);\\n    }\\n    \\n    bool isSymmetric(TreeNode* root) {\\n        if(!root)\\n            return 1;\\n        \\n        return isSymmetric(root->left,root->right);\\n    }\\n```\n```\\nbool isSymmetric(TreeNode* root) {\\n        \\n        if(!root)\\n            return 1;\\n        \\n        queue<TreeNode*> q;\\n        q.push(root->left);\\n        q.push(root->right);\\n        \\n        while(!q.empty())\\n        {\\n            TreeNode *l,*r;\\n            \\n            l=q.front();\\n            q.pop();\\n            \\n            r=q.front();\\n            q.pop();\\n            \\n            if(!l && !r)\\n                continue;\\n            \\n            if(!l || !r || l->val!=r->val)\\n                return 0;\\n            \\n            q.push(l->left);\\n            q.push(r->right);\\n            \\n            q.push(l->right);\\n            q.push(r->left);\\n        }\\n        return 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1780508,
                "title": "python-solution",
                "content": "Here\\'s my solution:\\n```\\n# Runtime: 37 ms, faster than 65.77% of Python3 online submissions for Symmetric Tree.\\n# Memory Usage: 14.1 MB, less than 61.59% of Python3 online submissions for Symmetric Tree.\\nclass Solution:\\n    def isSymmetric(self, root):\\n        return self.checkNodes(root.left, root.right)\\n\\n    def checkNodes(self, leftNode, rightNode):\\n        if leftNode == None and rightNode == None:\\n            result = True\\n        elif leftNode == None or rightNode == None:\\n            result = False\\n        else:\\n            if leftNode.val != rightNode.val:\\n                result = False\\n            else:\\n                result = self.checkNodes(leftNode.left, rightNode.right)\\n                if result:\\n                    result = self.checkNodes(leftNode.right, rightNode.left)\\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Runtime: 37 ms, faster than 65.77% of Python3 online submissions for Symmetric Tree.\\n# Memory Usage: 14.1 MB, less than 61.59% of Python3 online submissions for Symmetric Tree.\\nclass Solution:\\n    def isSymmetric(self, root):\\n        return self.checkNodes(root.left, root.right)\\n\\n    def checkNodes(self, leftNode, rightNode):\\n        if leftNode == None and rightNode == None:\\n            result = True\\n        elif leftNode == None or rightNode == None:\\n            result = False\\n        else:\\n            if leftNode.val != rightNode.val:\\n                result = False\\n            else:\\n                result = self.checkNodes(leftNode.left, rightNode.right)\\n                if result:\\n                    result = self.checkNodes(leftNode.right, rightNode.left)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774096,
                "title": "python-solution-with-clear-explanation-super-simple-faster-than-99-recursive-iterative",
                "content": "***For BFS problems, generally there are two approaches we can use, recursive and iterative ones.\\nSo we\\'ll talk about those two approaches in this post.***\\n\\n### **1. Recursively.**\\n\\n```\\n    def isSymmetric(self, root):\\n\\t\\n        # 1) recursively\\n        def same_tree(left, right):\\n            if (not left) and (not right):   # both None, good. Check other branches.\\n                continue\\n            elif (not left) or (not right):  # one is None and the other is not, not the same tree\\n                return False\\n            else:                            # both not None, check do a further check\\n                if (left.val != right.val):  # Different values stored, not the same tree\\n                    return False\\n                else:                        # Same values stored, good. \\n\\t\\t\\t\\t                             # Let\\'s check their child nodes\\n                    return same_tree(left.left, right.right) \\n                      and same_tree(left.right, right.left)\\n        \\n        if not root: return True\\n        return same_tree(root.left, root.right)\\n```\\n\\nFor the recusive approach, we need to **define a helper function** in most cases. \\nThat\\'s why I use the `same_tree` function here.\\nThen the work is basically just setting the conditions, which I described in details above in the code.\\n\\n**Performance:**\\n*Runtime: 11 ms, faster than 99.55% of Python online submissions for Symmetric Tree.\\nMemory Usage: 13.6 MB, less than 74.11% of Python online submissions for Symmetric Tree.*\\n\\n\\n### **2. Iteratively.**\\n\\n```\\n    def isSymmetric(self, root):\\n\\n        #2) Iteratively\\n        if not root:\\n            return True\\n        \\n        queue = collections.deque([(root.left, root.right)])\\n        while queue:\\n            left, right = queue.popleft()\\n            if (not left) and (not right):\\n                continue\\n            elif (not left) or (not right):\\n                return False\\n            else:\\n                if (left.val != right.val):\\n                    return False\\n                else:\\n                    queue.append((left.left, right.right))\\n                    queue.append((left.right, right.left))\\n        return True\\n```\\n\\nFor the iterative approach here, the main idea is that we **pair up the nodes that should have the same value**, and compare them and adding their childnodes as we looping through the whole tree.\\nNotice that we are using `collections.queue` here. `list` would work too, but `append()` and `pop()` for `collections.queue` is O(1) instead of O(n) for lists. \\nSo we are using queue here for better performance (especially when we are working on huge trees).\\nThe condition settings are the same as those in the recursive aproach, feel free to check it above in the first section.\\n\\n\\n***Hope you find this post helpful. Please upvote if you like it. Welcome for further discussions below!***",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n    def isSymmetric(self, root):\\n\\t\\n        # 1) recursively\\n        def same_tree(left, right):\\n            if (not left) and (not right):   # both None, good. Check other branches.\\n                continue\\n            elif (not left) or (not right):  # one is None and the other is not, not the same tree\\n                return False\\n            else:                            # both not None, check do a further check\\n                if (left.val != right.val):  # Different values stored, not the same tree\\n                    return False\\n                else:                        # Same values stored, good. \\n\\t\\t\\t\\t                             # Let\\'s check their child nodes\\n                    return same_tree(left.left, right.right) \\n                      and same_tree(left.right, right.left)\\n        \\n        if not root: return True\\n        return same_tree(root.left, root.right)\\n```\n```\\n    def isSymmetric(self, root):\\n\\n        #2) Iteratively\\n        if not root:\\n            return True\\n        \\n        queue = collections.deque([(root.left, root.right)])\\n        while queue:\\n            left, right = queue.popleft()\\n            if (not left) and (not right):\\n                continue\\n            elif (not left) or (not right):\\n                return False\\n            else:\\n                if (left.val != right.val):\\n                    return False\\n                else:\\n                    queue.append((left.left, right.right))\\n                    queue.append((left.right, right.left))\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1730254,
                "title": "python-3-recursive-preorder-traversal",
                "content": "**Suggestions to make it better are always welcomed.**\\n\\nWe handle base conditions first: \\n1. If first and second tree are both None, then they are symmetric.\\n2. If only 1 of them is None, they are asymmetric.\\n3. If the value of nodes in first and second are different, they are asymmetric.\\n\\nWe can combine all the asymmetric base cases in 1 if condition too.\\n\\nFrom the given example, we can see there are 2 subtrees that we are going to compare. We compare the left node of first tree with the right node of the second tree. Similarly, we compare the right node of first tree with the left node of the secod tree.\\n\\nAfter both the recursive calls return with the status of their subtrees, we return the status of current first and second trees to their parent node. Eventually the value bubbles up and we return the final result.\\n\\n```\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        if not root:\\n            return True\\n            \\n        def helper(firstTree, secondTree):\\n            if not firstTree and not secondTree:\\n                return True\\n                \\n            if not firstTree and secondTree:\\n                return False\\n            elif firstTree and not secondTree:\\n                return False\\n            elif firstTree.val != secondTree.val:\\n                return False\\n            \\n            mirror1 = helper(firstTree.left, secondTree.right)\\n            mirror2 = helper(firstTree.right, secondTree.left)\\n            return mirror1 and mirror2\\n        \\n        return helper(root.left, root.right)\\n```\\n\\n**I hope that you\\'ve found this useful.\\nIn that case, please upvote. It only motivates me to write more such posts\\uD83D\\uDE03**",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        if not root:\\n            return True\\n            \\n        def helper(firstTree, secondTree):\\n            if not firstTree and not secondTree:\\n                return True\\n                \\n            if not firstTree and secondTree:\\n                return False\\n            elif firstTree and not secondTree:\\n                return False\\n            elif firstTree.val != secondTree.val:\\n                return False\\n            \\n            mirror1 = helper(firstTree.left, secondTree.right)\\n            mirror2 = helper(firstTree.right, secondTree.left)\\n            return mirror1 and mirror2\\n        \\n        return helper(root.left, root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1586784,
                "title": "easy-to-learn-best-for-beginer-c",
                "content": "```\\nclass Solution {\\npublic:\\n \\n      //divide in two tree s lefttree ans righttree \\n    bool Compair(TreeNode* lefttree,TreeNode* righttree ){\\n        if(lefttree==NULL && righttree ==NULL)\\n        {\\n            return true;\\n        }\\n        if(lefttree==NULL || righttree ==NULL)\\n            \\n        {\\n            return false;\\n        }\\n        if(lefttree->val!=righttree ->val)\\n        {\\n            return false;\\n        }\\n        \\n\\t\\t//we check p left child with q right child and vice versa \\n        return Compair(lefttree->left,righttree ->right) && Compair(lefttree->right,righttree ->left);\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==NULL)\\n        {\\n            return true;\\n        }\\n            \\n        return Compair(root->left,root->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n \\n      //divide in two tree s lefttree ans righttree \\n    bool Compair(TreeNode* lefttree,TreeNode* righttree ){\\n        if(lefttree==NULL && righttree ==NULL)\\n        {\\n            return true;\\n        }\\n        if(lefttree==NULL || righttree ==NULL)\\n            \\n        {\\n            return false;\\n        }\\n        if(lefttree->val!=righttree ->val)\\n        {\\n            return false;\\n        }\\n        \\n\\t\\t//we check p left child with q right child and vice versa \\n        return Compair(lefttree->left,righttree ->right) && Compair(lefttree->right,righttree ->left);\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==NULL)\\n        {\\n            return true;\\n        }\\n            \\n        return Compair(root->left,root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1540519,
                "title": "simple-python-recursive-and-iterative-solutions",
                "content": "**Both are O(n) time and space.**\\n**1}Recursive**\\n```\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        \\n        def isEqual(t1,t2):\\n            if not t1 and not t2: return True\\n            if not t1 or not t2:return False\\n            if t1.val!=t2.val: return False\\n            inner=isEqual(t1.left,t2.right)\\n            outer=isEqual(t1.right,t2.left)\\n            \\n            return inner and outer\\n        return isEqual(root.left,root.right)\\n```\\n\\n**2)Iterative:**\\n```\\n\\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n\\n \\n        level=[root]\\n        \\n        while level:\\n            nextlevel=[]\\n            currLevel=[]\\n            for node in level:\\n                if node.right:\\n                    nextlevel.append(node.right)\\n                    currLevel.append(node.right.val)\\n                else:\\n                    currLevel.append(\"Empty\")\\n                if node.left:    \\n                    nextlevel.append(node.left)\\n                    currLevel.append(node.left.val)\\n                else:\\n                    currLevel.append(\"Empty\")    \\n            if currLevel != currLevel[::-1]:\\n                return False\\n\\n            level=nextlevel\\n        return True   \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n        \\n        def isEqual(t1,t2):\\n            if not t1 and not t2: return True\\n            if not t1 or not t2:return False\\n            if t1.val!=t2.val: return False\\n            inner=isEqual(t1.left,t2.right)\\n            outer=isEqual(t1.right,t2.left)\\n            \\n            return inner and outer\\n        return isEqual(root.left,root.right)\\n```\n```\\n\\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n\\n \\n        level=[root]\\n        \\n        while level:\\n            nextlevel=[]\\n            currLevel=[]\\n            for node in level:\\n                if node.right:\\n                    nextlevel.append(node.right)\\n                    currLevel.append(node.right.val)\\n                else:\\n                    currLevel.append(\"Empty\")\\n                if node.left:    \\n                    nextlevel.append(node.left)\\n                    currLevel.append(node.left.val)\\n                else:\\n                    currLevel.append(\"Empty\")    \\n            if currLevel != currLevel[::-1]:\\n                return False\\n\\n            level=nextlevel\\n        return True   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1408213,
                "title": "python-easy-recursion-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n\\n\\t\\t\\tdef fun(root1, root2):\\n\\t\\t\\t\\tif root1 is None and root2 is None:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tif root1 is None or root2 is None:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\tif root1.val == root2.val:\\n\\t\\t\\t\\t\\tx = fun(root1.left, root2.right)\\n\\t\\t\\t\\t\\ty = fun(root1.right, root2.left)\\n\\n\\t\\t\\t\\t\\tif x == True and y == True:\\n\\t\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\treturn False\\n\\n\\n\\t\\t\\tif root is None:\\n\\t\\t\\t\\treturn True\\n\\n\\t\\t\\treturn fun(root, root)\\n\\t\\t\\t\\n# if you like the solution, Please upvote!!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef isSymmetric(self, root: Optional[TreeNode]) -> bool:\\n\\n\\t\\t\\tdef fun(root1, root2):\\n\\t\\t\\t\\tif root1 is None and root2 is None:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tif root1 is None or root2 is None:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\tif root1.val == root2.val:\\n\\t\\t\\t\\t\\tx = fun(root1.left, root2.right)\\n\\t\\t\\t\\t\\ty = fun(root1.right, root2.left)\\n\\n\\t\\t\\t\\t\\tif x == True and y == True:\\n\\t\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\treturn False\\n\\n\\n\\t\\t\\tif root is None:\\n\\t\\t\\t\\treturn True\\n\\n\\t\\t\\treturn fun(root, root)\\n\\t\\t\\t\\n# if you like the solution, Please upvote!!",
                "codeTag": "Java"
            },
            {
                "id": 1235596,
                "title": "c-simple-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(TreeNode * lefft, TreeNode * rigght)\\n    {\\n        if(lefft==nullptr and rigght==nullptr)\\n            return true;\\n        if(lefft==nullptr or rigght==nullptr)\\n            return false;\\n        if(lefft->val!=rigght->val)\\n            return false;\\n        return check(lefft->left,rigght->right) and check(lefft->right, rigght->left);\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==nullptr)\\n            return true;\\n        return check(root->left,root->right);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(TreeNode * lefft, TreeNode * rigght)\\n    {\\n        if(lefft==nullptr and rigght==nullptr)\\n            return true;\\n        if(lefft==nullptr or rigght==nullptr)\\n            return false;\\n        if(lefft->val!=rigght->val)\\n            return false;\\n        return check(lefft->left,rigght->right) and check(lefft->right, rigght->left);\\n    }\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==nullptr)\\n            return true;\\n        return check(root->left,root->right);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1229761,
                "title": "rust-recursive-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of Rust online submissions for Symmetric Tree.\\nMemory Usage: 2.3 MB, less than 5.26% of Rust online submissions for Symmetric Tree.\\n```\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn is_symmetric(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        fn compare(l: Option<Rc<RefCell<TreeNode>>>, r: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n            match (l, r) {\\n                (None, None) => true,\\n                (None, Some(n)) | (Some(n), None) => false,\\n                (Some(l), Some(r)) => {\\n                    if l.borrow().val != r.borrow().val {\\n                        return false;\\n                    }\\n                    return compare(l.borrow().left.clone(), r.borrow().right.clone())\\n                        && compare(l.borrow().right.clone(), r.borrow().left.clone())\\n                }\\n            }\\n        }\\n        match root {\\n            Some(r) => compare(r.borrow().left.clone(), r.borrow().right.clone()),\\n            None => true\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn is_symmetric(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        fn compare(l: Option<Rc<RefCell<TreeNode>>>, r: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n            match (l, r) {\\n                (None, None) => true,\\n                (None, Some(n)) | (Some(n), None) => false,\\n                (Some(l), Some(r)) => {\\n                    if l.borrow().val != r.borrow().val {\\n                        return false;\\n                    }\\n                    return compare(l.borrow().left.clone(), r.borrow().right.clone())\\n                        && compare(l.borrow().right.clone(), r.borrow().left.clone())\\n                }\\n            }\\n        }\\n        match root {\\n            Some(r) => compare(r.borrow().left.clone(), r.borrow().right.clone()),\\n            None => true\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1569663,
                "content": [
                    {
                        "username": "sharabiania",
                        "content": "Should change the title of the question to Mirror Tree. Symetric Tree can cause confusion."
                    },
                    {
                        "username": "heissanjay",
                        "content": "That\\'s correct, Symmetric doesn\\'t cover the mirror property "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Lol yeah that tripped me up for a few minutes for sure."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes bro symmetric also mean the same i think"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think this question difficulty is needed to be increased. Its difficulty should be medium."
                    },
                    {
                        "username": "AdamGold",
                        "content": "I disagree. This question is nearly identical to another easy problem, tree equality. Except instead of chcking p.left with q.left, you check p.left against r.right and vice versa"
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@stridemann](/stridemann) You\\'re not the standard of how people see this problem. Probably you are good in node theory. \\n\\nBut at each problem with TreeNode people leave comments with requests of increasing diifficulty. And i think they are right. This is very complicate even for people with 1 year programming experience like me."
                    },
                    {
                        "username": "stridemann",
                        "content": "Sorry, disagree.\nFor my level of solving problems medium takes up to 1-2 hour, hard can be more than a day, but this problem is around 10 min.\nIf s1 need a theory with code and good step-by-step visualization https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/BinaryTreeTraversal.html "
                    },
                    {
                        "username": "mandy1339",
                        "content": "The solution was not trivial. You have to know how to traverse to trees simultaneously in inverse order. I couldn\\'t think of any trivial solutions. Took me too long for an easy problem. What do you think?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its a tough problem for sure. I had to seek a hint to solve too but it made a lot of sense after realizing it "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "agree. Yesterdays hard on the daily coding challenges was easier then this lol"
                    },
                    {
                        "username": "djslim",
                        "content": "BFS works pretty well, just need to push null into queue to mark on which side nodes are, my javascript code:\\n\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "sairajd044",
                        "content": "I computed mirror of left subtree and checked if it is equal to right subtree,"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "I struggled on this one too"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Idk i just did post order on the left and right subtrees at the main root, but inverted the left subtree as i did the dfs. If the tree is \"symmetrical\" both post orders should be identical. Solutions may become trivial depending one how you\\'re looking at the principle parts of the problem"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried to solve it using BFS and splitting it into levels, then checking if each level was a palindrome. I feel that is a more intuitive solution than traversing both halves at the same time. I got it to work for 197 out of 199 of cases before giving up."
                    },
                    {
                        "username": "sahle123",
                        "content": "[@djslim](/djslim) You\\'re not supposed to post your code in the Discussions tab. There\\'s already a tab for finding people\\'s solution."
                    },
                    {
                        "username": "djslim",
                        "content": "yup, you can do bfs, \\nmy js code:\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "BrodyK",
                        "content": "I created a BFS solution if you wanted to compare it to yours\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3192072/breadth-search-solution-python/"
                    },
                    {
                        "username": "dark",
                        "content": "This problem involves two point:\\n\\n**symmetric:**\\n\\nconsider tree T:\\n\\nif T is null, then T is symmetric\\n\\nif T->left is mirror of T->right,then T is symmetric\\n\\n**mirror**\\n\\nconsider two tree T and R:\\n\\nif T=R=NULL, then T is mirror of R\\n\\nif T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror\\n\\notherwise the mirror relationship cannot estabished"
                    },
                    {
                        "username": "Neo57",
                        "content": "you forgot one part. The accurate statement is \"if T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror and T.val == R.Val\""
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "just move inorder in the leftsubtree and move reverse inorder in the rightsubtree simultaneously and check if they have the same value. "
                    },
                    {
                        "username": "souravedu87",
                        "content": "testcase 195 fails with this approach [1,2,2,2,null,2]"
                    },
                    {
                        "username": "carl-egge",
                        "content": "I was trying to implent this approach, but I had a problem with one testcase where I think the inorder is the same, but is it not mirrored:\\n[5,4,1,null,1,null,4,2,null,2,null]\\n\\nBoth sides lead to a inorder of [4,2,1] (if one is reversed)"
                    },
                    {
                        "username": "shikharscout",
                        "content": "This will not work for Test Case 95"
                    },
                    {
                        "username": "riteshroshan77",
                        "content": "same i was thinking but unable to convert my thought in code"
                    },
                    {
                        "username": "Heathro",
                        "content": "your commet was very handy. I tried to figure out how to deepsearch both sides to be able to compare, and here comes your \"reverse in-odred\" advise. thank you =)"
                    },
                    {
                        "username": "meow_power",
                        "content": "It\\'s a shame that even on solving this problem before I can\\'t think on how to solve this problem :("
                    },
                    {
                        "username": "mskamel",
                        "content": "Sorry to hear that you are frustrated man, it\\'s okay. Keep solving these questions and you will get better at them. A personal advice from me is to not read the solutions before you solve the problem, this will help you truly get better at LeetCode. I wish you all the best and keep grinding ;)"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Same. Even some hard problems here just a matter of time. Maybe day or more. \\n\\nThis one seems undoable for those who don\\'t know theory perfect. "
                    },
                    {
                        "username": "jclo123",
                        "content": ">The number of recursive calls is bound by the height of the tree. In the worst case, the tree is linear and the height is in O(n).\\n\\nHowever, if it is a linear tree, it will return false right at if (!left || !right).  I think the worst case should be a balanced tree where we need to make recursive call on each node."
                    },
                    {
                        "username": "njain07",
                        "content": "[1,2,2,5,null,null,5,6,null,null,6]\\n\\nAccording to my understanding, the levels of the tree should be:\\n[1]\\n[2,2]\\n[5,null,null,5]\\n[6,null,null,6] --> shouldn\\'t this have a length of 8 and not 4?\\n\\n*This testcode\\'s expected output is true.*"
                    },
                    {
                        "username": "dima0000000000",
                        "content": "Null elements cannot have their leaves, so the branch ends on it."
                    },
                    {
                        "username": "ben_huang",
                        "content": "step1. rotate(root->left)\\nstep2. equal(root->right,root->left)"
                    }
                ]
            },
            {
                "id": 1831340,
                "content": [
                    {
                        "username": "sharabiania",
                        "content": "Should change the title of the question to Mirror Tree. Symetric Tree can cause confusion."
                    },
                    {
                        "username": "heissanjay",
                        "content": "That\\'s correct, Symmetric doesn\\'t cover the mirror property "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Lol yeah that tripped me up for a few minutes for sure."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes bro symmetric also mean the same i think"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think this question difficulty is needed to be increased. Its difficulty should be medium."
                    },
                    {
                        "username": "AdamGold",
                        "content": "I disagree. This question is nearly identical to another easy problem, tree equality. Except instead of chcking p.left with q.left, you check p.left against r.right and vice versa"
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@stridemann](/stridemann) You\\'re not the standard of how people see this problem. Probably you are good in node theory. \\n\\nBut at each problem with TreeNode people leave comments with requests of increasing diifficulty. And i think they are right. This is very complicate even for people with 1 year programming experience like me."
                    },
                    {
                        "username": "stridemann",
                        "content": "Sorry, disagree.\nFor my level of solving problems medium takes up to 1-2 hour, hard can be more than a day, but this problem is around 10 min.\nIf s1 need a theory with code and good step-by-step visualization https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/BinaryTreeTraversal.html "
                    },
                    {
                        "username": "mandy1339",
                        "content": "The solution was not trivial. You have to know how to traverse to trees simultaneously in inverse order. I couldn\\'t think of any trivial solutions. Took me too long for an easy problem. What do you think?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its a tough problem for sure. I had to seek a hint to solve too but it made a lot of sense after realizing it "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "agree. Yesterdays hard on the daily coding challenges was easier then this lol"
                    },
                    {
                        "username": "djslim",
                        "content": "BFS works pretty well, just need to push null into queue to mark on which side nodes are, my javascript code:\\n\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "sairajd044",
                        "content": "I computed mirror of left subtree and checked if it is equal to right subtree,"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "I struggled on this one too"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Idk i just did post order on the left and right subtrees at the main root, but inverted the left subtree as i did the dfs. If the tree is \"symmetrical\" both post orders should be identical. Solutions may become trivial depending one how you\\'re looking at the principle parts of the problem"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried to solve it using BFS and splitting it into levels, then checking if each level was a palindrome. I feel that is a more intuitive solution than traversing both halves at the same time. I got it to work for 197 out of 199 of cases before giving up."
                    },
                    {
                        "username": "sahle123",
                        "content": "[@djslim](/djslim) You\\'re not supposed to post your code in the Discussions tab. There\\'s already a tab for finding people\\'s solution."
                    },
                    {
                        "username": "djslim",
                        "content": "yup, you can do bfs, \\nmy js code:\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "BrodyK",
                        "content": "I created a BFS solution if you wanted to compare it to yours\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3192072/breadth-search-solution-python/"
                    },
                    {
                        "username": "dark",
                        "content": "This problem involves two point:\\n\\n**symmetric:**\\n\\nconsider tree T:\\n\\nif T is null, then T is symmetric\\n\\nif T->left is mirror of T->right,then T is symmetric\\n\\n**mirror**\\n\\nconsider two tree T and R:\\n\\nif T=R=NULL, then T is mirror of R\\n\\nif T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror\\n\\notherwise the mirror relationship cannot estabished"
                    },
                    {
                        "username": "Neo57",
                        "content": "you forgot one part. The accurate statement is \"if T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror and T.val == R.Val\""
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "just move inorder in the leftsubtree and move reverse inorder in the rightsubtree simultaneously and check if they have the same value. "
                    },
                    {
                        "username": "souravedu87",
                        "content": "testcase 195 fails with this approach [1,2,2,2,null,2]"
                    },
                    {
                        "username": "carl-egge",
                        "content": "I was trying to implent this approach, but I had a problem with one testcase where I think the inorder is the same, but is it not mirrored:\\n[5,4,1,null,1,null,4,2,null,2,null]\\n\\nBoth sides lead to a inorder of [4,2,1] (if one is reversed)"
                    },
                    {
                        "username": "shikharscout",
                        "content": "This will not work for Test Case 95"
                    },
                    {
                        "username": "riteshroshan77",
                        "content": "same i was thinking but unable to convert my thought in code"
                    },
                    {
                        "username": "Heathro",
                        "content": "your commet was very handy. I tried to figure out how to deepsearch both sides to be able to compare, and here comes your \"reverse in-odred\" advise. thank you =)"
                    },
                    {
                        "username": "meow_power",
                        "content": "It\\'s a shame that even on solving this problem before I can\\'t think on how to solve this problem :("
                    },
                    {
                        "username": "mskamel",
                        "content": "Sorry to hear that you are frustrated man, it\\'s okay. Keep solving these questions and you will get better at them. A personal advice from me is to not read the solutions before you solve the problem, this will help you truly get better at LeetCode. I wish you all the best and keep grinding ;)"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Same. Even some hard problems here just a matter of time. Maybe day or more. \\n\\nThis one seems undoable for those who don\\'t know theory perfect. "
                    },
                    {
                        "username": "jclo123",
                        "content": ">The number of recursive calls is bound by the height of the tree. In the worst case, the tree is linear and the height is in O(n).\\n\\nHowever, if it is a linear tree, it will return false right at if (!left || !right).  I think the worst case should be a balanced tree where we need to make recursive call on each node."
                    },
                    {
                        "username": "njain07",
                        "content": "[1,2,2,5,null,null,5,6,null,null,6]\\n\\nAccording to my understanding, the levels of the tree should be:\\n[1]\\n[2,2]\\n[5,null,null,5]\\n[6,null,null,6] --> shouldn\\'t this have a length of 8 and not 4?\\n\\n*This testcode\\'s expected output is true.*"
                    },
                    {
                        "username": "dima0000000000",
                        "content": "Null elements cannot have their leaves, so the branch ends on it."
                    },
                    {
                        "username": "ben_huang",
                        "content": "step1. rotate(root->left)\\nstep2. equal(root->right,root->left)"
                    }
                ]
            },
            {
                "id": 1576379,
                "content": [
                    {
                        "username": "sharabiania",
                        "content": "Should change the title of the question to Mirror Tree. Symetric Tree can cause confusion."
                    },
                    {
                        "username": "heissanjay",
                        "content": "That\\'s correct, Symmetric doesn\\'t cover the mirror property "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Lol yeah that tripped me up for a few minutes for sure."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes bro symmetric also mean the same i think"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think this question difficulty is needed to be increased. Its difficulty should be medium."
                    },
                    {
                        "username": "AdamGold",
                        "content": "I disagree. This question is nearly identical to another easy problem, tree equality. Except instead of chcking p.left with q.left, you check p.left against r.right and vice versa"
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@stridemann](/stridemann) You\\'re not the standard of how people see this problem. Probably you are good in node theory. \\n\\nBut at each problem with TreeNode people leave comments with requests of increasing diifficulty. And i think they are right. This is very complicate even for people with 1 year programming experience like me."
                    },
                    {
                        "username": "stridemann",
                        "content": "Sorry, disagree.\nFor my level of solving problems medium takes up to 1-2 hour, hard can be more than a day, but this problem is around 10 min.\nIf s1 need a theory with code and good step-by-step visualization https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/BinaryTreeTraversal.html "
                    },
                    {
                        "username": "mandy1339",
                        "content": "The solution was not trivial. You have to know how to traverse to trees simultaneously in inverse order. I couldn\\'t think of any trivial solutions. Took me too long for an easy problem. What do you think?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its a tough problem for sure. I had to seek a hint to solve too but it made a lot of sense after realizing it "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "agree. Yesterdays hard on the daily coding challenges was easier then this lol"
                    },
                    {
                        "username": "djslim",
                        "content": "BFS works pretty well, just need to push null into queue to mark on which side nodes are, my javascript code:\\n\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "sairajd044",
                        "content": "I computed mirror of left subtree and checked if it is equal to right subtree,"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "I struggled on this one too"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Idk i just did post order on the left and right subtrees at the main root, but inverted the left subtree as i did the dfs. If the tree is \"symmetrical\" both post orders should be identical. Solutions may become trivial depending one how you\\'re looking at the principle parts of the problem"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried to solve it using BFS and splitting it into levels, then checking if each level was a palindrome. I feel that is a more intuitive solution than traversing both halves at the same time. I got it to work for 197 out of 199 of cases before giving up."
                    },
                    {
                        "username": "sahle123",
                        "content": "[@djslim](/djslim) You\\'re not supposed to post your code in the Discussions tab. There\\'s already a tab for finding people\\'s solution."
                    },
                    {
                        "username": "djslim",
                        "content": "yup, you can do bfs, \\nmy js code:\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "BrodyK",
                        "content": "I created a BFS solution if you wanted to compare it to yours\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3192072/breadth-search-solution-python/"
                    },
                    {
                        "username": "dark",
                        "content": "This problem involves two point:\\n\\n**symmetric:**\\n\\nconsider tree T:\\n\\nif T is null, then T is symmetric\\n\\nif T->left is mirror of T->right,then T is symmetric\\n\\n**mirror**\\n\\nconsider two tree T and R:\\n\\nif T=R=NULL, then T is mirror of R\\n\\nif T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror\\n\\notherwise the mirror relationship cannot estabished"
                    },
                    {
                        "username": "Neo57",
                        "content": "you forgot one part. The accurate statement is \"if T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror and T.val == R.Val\""
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "just move inorder in the leftsubtree and move reverse inorder in the rightsubtree simultaneously and check if they have the same value. "
                    },
                    {
                        "username": "souravedu87",
                        "content": "testcase 195 fails with this approach [1,2,2,2,null,2]"
                    },
                    {
                        "username": "carl-egge",
                        "content": "I was trying to implent this approach, but I had a problem with one testcase where I think the inorder is the same, but is it not mirrored:\\n[5,4,1,null,1,null,4,2,null,2,null]\\n\\nBoth sides lead to a inorder of [4,2,1] (if one is reversed)"
                    },
                    {
                        "username": "shikharscout",
                        "content": "This will not work for Test Case 95"
                    },
                    {
                        "username": "riteshroshan77",
                        "content": "same i was thinking but unable to convert my thought in code"
                    },
                    {
                        "username": "Heathro",
                        "content": "your commet was very handy. I tried to figure out how to deepsearch both sides to be able to compare, and here comes your \"reverse in-odred\" advise. thank you =)"
                    },
                    {
                        "username": "meow_power",
                        "content": "It\\'s a shame that even on solving this problem before I can\\'t think on how to solve this problem :("
                    },
                    {
                        "username": "mskamel",
                        "content": "Sorry to hear that you are frustrated man, it\\'s okay. Keep solving these questions and you will get better at them. A personal advice from me is to not read the solutions before you solve the problem, this will help you truly get better at LeetCode. I wish you all the best and keep grinding ;)"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Same. Even some hard problems here just a matter of time. Maybe day or more. \\n\\nThis one seems undoable for those who don\\'t know theory perfect. "
                    },
                    {
                        "username": "jclo123",
                        "content": ">The number of recursive calls is bound by the height of the tree. In the worst case, the tree is linear and the height is in O(n).\\n\\nHowever, if it is a linear tree, it will return false right at if (!left || !right).  I think the worst case should be a balanced tree where we need to make recursive call on each node."
                    },
                    {
                        "username": "njain07",
                        "content": "[1,2,2,5,null,null,5,6,null,null,6]\\n\\nAccording to my understanding, the levels of the tree should be:\\n[1]\\n[2,2]\\n[5,null,null,5]\\n[6,null,null,6] --> shouldn\\'t this have a length of 8 and not 4?\\n\\n*This testcode\\'s expected output is true.*"
                    },
                    {
                        "username": "dima0000000000",
                        "content": "Null elements cannot have their leaves, so the branch ends on it."
                    },
                    {
                        "username": "ben_huang",
                        "content": "step1. rotate(root->left)\\nstep2. equal(root->right,root->left)"
                    }
                ]
            },
            {
                "id": 1753495,
                "content": [
                    {
                        "username": "sharabiania",
                        "content": "Should change the title of the question to Mirror Tree. Symetric Tree can cause confusion."
                    },
                    {
                        "username": "heissanjay",
                        "content": "That\\'s correct, Symmetric doesn\\'t cover the mirror property "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Lol yeah that tripped me up for a few minutes for sure."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes bro symmetric also mean the same i think"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think this question difficulty is needed to be increased. Its difficulty should be medium."
                    },
                    {
                        "username": "AdamGold",
                        "content": "I disagree. This question is nearly identical to another easy problem, tree equality. Except instead of chcking p.left with q.left, you check p.left against r.right and vice versa"
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@stridemann](/stridemann) You\\'re not the standard of how people see this problem. Probably you are good in node theory. \\n\\nBut at each problem with TreeNode people leave comments with requests of increasing diifficulty. And i think they are right. This is very complicate even for people with 1 year programming experience like me."
                    },
                    {
                        "username": "stridemann",
                        "content": "Sorry, disagree.\nFor my level of solving problems medium takes up to 1-2 hour, hard can be more than a day, but this problem is around 10 min.\nIf s1 need a theory with code and good step-by-step visualization https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/BinaryTreeTraversal.html "
                    },
                    {
                        "username": "mandy1339",
                        "content": "The solution was not trivial. You have to know how to traverse to trees simultaneously in inverse order. I couldn\\'t think of any trivial solutions. Took me too long for an easy problem. What do you think?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its a tough problem for sure. I had to seek a hint to solve too but it made a lot of sense after realizing it "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "agree. Yesterdays hard on the daily coding challenges was easier then this lol"
                    },
                    {
                        "username": "djslim",
                        "content": "BFS works pretty well, just need to push null into queue to mark on which side nodes are, my javascript code:\\n\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "sairajd044",
                        "content": "I computed mirror of left subtree and checked if it is equal to right subtree,"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "I struggled on this one too"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Idk i just did post order on the left and right subtrees at the main root, but inverted the left subtree as i did the dfs. If the tree is \"symmetrical\" both post orders should be identical. Solutions may become trivial depending one how you\\'re looking at the principle parts of the problem"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried to solve it using BFS and splitting it into levels, then checking if each level was a palindrome. I feel that is a more intuitive solution than traversing both halves at the same time. I got it to work for 197 out of 199 of cases before giving up."
                    },
                    {
                        "username": "sahle123",
                        "content": "[@djslim](/djslim) You\\'re not supposed to post your code in the Discussions tab. There\\'s already a tab for finding people\\'s solution."
                    },
                    {
                        "username": "djslim",
                        "content": "yup, you can do bfs, \\nmy js code:\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "BrodyK",
                        "content": "I created a BFS solution if you wanted to compare it to yours\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3192072/breadth-search-solution-python/"
                    },
                    {
                        "username": "dark",
                        "content": "This problem involves two point:\\n\\n**symmetric:**\\n\\nconsider tree T:\\n\\nif T is null, then T is symmetric\\n\\nif T->left is mirror of T->right,then T is symmetric\\n\\n**mirror**\\n\\nconsider two tree T and R:\\n\\nif T=R=NULL, then T is mirror of R\\n\\nif T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror\\n\\notherwise the mirror relationship cannot estabished"
                    },
                    {
                        "username": "Neo57",
                        "content": "you forgot one part. The accurate statement is \"if T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror and T.val == R.Val\""
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "just move inorder in the leftsubtree and move reverse inorder in the rightsubtree simultaneously and check if they have the same value. "
                    },
                    {
                        "username": "souravedu87",
                        "content": "testcase 195 fails with this approach [1,2,2,2,null,2]"
                    },
                    {
                        "username": "carl-egge",
                        "content": "I was trying to implent this approach, but I had a problem with one testcase where I think the inorder is the same, but is it not mirrored:\\n[5,4,1,null,1,null,4,2,null,2,null]\\n\\nBoth sides lead to a inorder of [4,2,1] (if one is reversed)"
                    },
                    {
                        "username": "shikharscout",
                        "content": "This will not work for Test Case 95"
                    },
                    {
                        "username": "riteshroshan77",
                        "content": "same i was thinking but unable to convert my thought in code"
                    },
                    {
                        "username": "Heathro",
                        "content": "your commet was very handy. I tried to figure out how to deepsearch both sides to be able to compare, and here comes your \"reverse in-odred\" advise. thank you =)"
                    },
                    {
                        "username": "meow_power",
                        "content": "It\\'s a shame that even on solving this problem before I can\\'t think on how to solve this problem :("
                    },
                    {
                        "username": "mskamel",
                        "content": "Sorry to hear that you are frustrated man, it\\'s okay. Keep solving these questions and you will get better at them. A personal advice from me is to not read the solutions before you solve the problem, this will help you truly get better at LeetCode. I wish you all the best and keep grinding ;)"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Same. Even some hard problems here just a matter of time. Maybe day or more. \\n\\nThis one seems undoable for those who don\\'t know theory perfect. "
                    },
                    {
                        "username": "jclo123",
                        "content": ">The number of recursive calls is bound by the height of the tree. In the worst case, the tree is linear and the height is in O(n).\\n\\nHowever, if it is a linear tree, it will return false right at if (!left || !right).  I think the worst case should be a balanced tree where we need to make recursive call on each node."
                    },
                    {
                        "username": "njain07",
                        "content": "[1,2,2,5,null,null,5,6,null,null,6]\\n\\nAccording to my understanding, the levels of the tree should be:\\n[1]\\n[2,2]\\n[5,null,null,5]\\n[6,null,null,6] --> shouldn\\'t this have a length of 8 and not 4?\\n\\n*This testcode\\'s expected output is true.*"
                    },
                    {
                        "username": "dima0000000000",
                        "content": "Null elements cannot have their leaves, so the branch ends on it."
                    },
                    {
                        "username": "ben_huang",
                        "content": "step1. rotate(root->left)\\nstep2. equal(root->right,root->left)"
                    }
                ]
            },
            {
                "id": 1568924,
                "content": [
                    {
                        "username": "sharabiania",
                        "content": "Should change the title of the question to Mirror Tree. Symetric Tree can cause confusion."
                    },
                    {
                        "username": "heissanjay",
                        "content": "That\\'s correct, Symmetric doesn\\'t cover the mirror property "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Lol yeah that tripped me up for a few minutes for sure."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes bro symmetric also mean the same i think"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think this question difficulty is needed to be increased. Its difficulty should be medium."
                    },
                    {
                        "username": "AdamGold",
                        "content": "I disagree. This question is nearly identical to another easy problem, tree equality. Except instead of chcking p.left with q.left, you check p.left against r.right and vice versa"
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@stridemann](/stridemann) You\\'re not the standard of how people see this problem. Probably you are good in node theory. \\n\\nBut at each problem with TreeNode people leave comments with requests of increasing diifficulty. And i think they are right. This is very complicate even for people with 1 year programming experience like me."
                    },
                    {
                        "username": "stridemann",
                        "content": "Sorry, disagree.\nFor my level of solving problems medium takes up to 1-2 hour, hard can be more than a day, but this problem is around 10 min.\nIf s1 need a theory with code and good step-by-step visualization https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/BinaryTreeTraversal.html "
                    },
                    {
                        "username": "mandy1339",
                        "content": "The solution was not trivial. You have to know how to traverse to trees simultaneously in inverse order. I couldn\\'t think of any trivial solutions. Took me too long for an easy problem. What do you think?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its a tough problem for sure. I had to seek a hint to solve too but it made a lot of sense after realizing it "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "agree. Yesterdays hard on the daily coding challenges was easier then this lol"
                    },
                    {
                        "username": "djslim",
                        "content": "BFS works pretty well, just need to push null into queue to mark on which side nodes are, my javascript code:\\n\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "sairajd044",
                        "content": "I computed mirror of left subtree and checked if it is equal to right subtree,"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "I struggled on this one too"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Idk i just did post order on the left and right subtrees at the main root, but inverted the left subtree as i did the dfs. If the tree is \"symmetrical\" both post orders should be identical. Solutions may become trivial depending one how you\\'re looking at the principle parts of the problem"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried to solve it using BFS and splitting it into levels, then checking if each level was a palindrome. I feel that is a more intuitive solution than traversing both halves at the same time. I got it to work for 197 out of 199 of cases before giving up."
                    },
                    {
                        "username": "sahle123",
                        "content": "[@djslim](/djslim) You\\'re not supposed to post your code in the Discussions tab. There\\'s already a tab for finding people\\'s solution."
                    },
                    {
                        "username": "djslim",
                        "content": "yup, you can do bfs, \\nmy js code:\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "BrodyK",
                        "content": "I created a BFS solution if you wanted to compare it to yours\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3192072/breadth-search-solution-python/"
                    },
                    {
                        "username": "dark",
                        "content": "This problem involves two point:\\n\\n**symmetric:**\\n\\nconsider tree T:\\n\\nif T is null, then T is symmetric\\n\\nif T->left is mirror of T->right,then T is symmetric\\n\\n**mirror**\\n\\nconsider two tree T and R:\\n\\nif T=R=NULL, then T is mirror of R\\n\\nif T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror\\n\\notherwise the mirror relationship cannot estabished"
                    },
                    {
                        "username": "Neo57",
                        "content": "you forgot one part. The accurate statement is \"if T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror and T.val == R.Val\""
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "just move inorder in the leftsubtree and move reverse inorder in the rightsubtree simultaneously and check if they have the same value. "
                    },
                    {
                        "username": "souravedu87",
                        "content": "testcase 195 fails with this approach [1,2,2,2,null,2]"
                    },
                    {
                        "username": "carl-egge",
                        "content": "I was trying to implent this approach, but I had a problem with one testcase where I think the inorder is the same, but is it not mirrored:\\n[5,4,1,null,1,null,4,2,null,2,null]\\n\\nBoth sides lead to a inorder of [4,2,1] (if one is reversed)"
                    },
                    {
                        "username": "shikharscout",
                        "content": "This will not work for Test Case 95"
                    },
                    {
                        "username": "riteshroshan77",
                        "content": "same i was thinking but unable to convert my thought in code"
                    },
                    {
                        "username": "Heathro",
                        "content": "your commet was very handy. I tried to figure out how to deepsearch both sides to be able to compare, and here comes your \"reverse in-odred\" advise. thank you =)"
                    },
                    {
                        "username": "meow_power",
                        "content": "It\\'s a shame that even on solving this problem before I can\\'t think on how to solve this problem :("
                    },
                    {
                        "username": "mskamel",
                        "content": "Sorry to hear that you are frustrated man, it\\'s okay. Keep solving these questions and you will get better at them. A personal advice from me is to not read the solutions before you solve the problem, this will help you truly get better at LeetCode. I wish you all the best and keep grinding ;)"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Same. Even some hard problems here just a matter of time. Maybe day or more. \\n\\nThis one seems undoable for those who don\\'t know theory perfect. "
                    },
                    {
                        "username": "jclo123",
                        "content": ">The number of recursive calls is bound by the height of the tree. In the worst case, the tree is linear and the height is in O(n).\\n\\nHowever, if it is a linear tree, it will return false right at if (!left || !right).  I think the worst case should be a balanced tree where we need to make recursive call on each node."
                    },
                    {
                        "username": "njain07",
                        "content": "[1,2,2,5,null,null,5,6,null,null,6]\\n\\nAccording to my understanding, the levels of the tree should be:\\n[1]\\n[2,2]\\n[5,null,null,5]\\n[6,null,null,6] --> shouldn\\'t this have a length of 8 and not 4?\\n\\n*This testcode\\'s expected output is true.*"
                    },
                    {
                        "username": "dima0000000000",
                        "content": "Null elements cannot have their leaves, so the branch ends on it."
                    },
                    {
                        "username": "ben_huang",
                        "content": "step1. rotate(root->left)\\nstep2. equal(root->right,root->left)"
                    }
                ]
            },
            {
                "id": 1634875,
                "content": [
                    {
                        "username": "sharabiania",
                        "content": "Should change the title of the question to Mirror Tree. Symetric Tree can cause confusion."
                    },
                    {
                        "username": "heissanjay",
                        "content": "That\\'s correct, Symmetric doesn\\'t cover the mirror property "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Lol yeah that tripped me up for a few minutes for sure."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes bro symmetric also mean the same i think"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think this question difficulty is needed to be increased. Its difficulty should be medium."
                    },
                    {
                        "username": "AdamGold",
                        "content": "I disagree. This question is nearly identical to another easy problem, tree equality. Except instead of chcking p.left with q.left, you check p.left against r.right and vice versa"
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@stridemann](/stridemann) You\\'re not the standard of how people see this problem. Probably you are good in node theory. \\n\\nBut at each problem with TreeNode people leave comments with requests of increasing diifficulty. And i think they are right. This is very complicate even for people with 1 year programming experience like me."
                    },
                    {
                        "username": "stridemann",
                        "content": "Sorry, disagree.\nFor my level of solving problems medium takes up to 1-2 hour, hard can be more than a day, but this problem is around 10 min.\nIf s1 need a theory with code and good step-by-step visualization https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/BinaryTreeTraversal.html "
                    },
                    {
                        "username": "mandy1339",
                        "content": "The solution was not trivial. You have to know how to traverse to trees simultaneously in inverse order. I couldn\\'t think of any trivial solutions. Took me too long for an easy problem. What do you think?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its a tough problem for sure. I had to seek a hint to solve too but it made a lot of sense after realizing it "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "agree. Yesterdays hard on the daily coding challenges was easier then this lol"
                    },
                    {
                        "username": "djslim",
                        "content": "BFS works pretty well, just need to push null into queue to mark on which side nodes are, my javascript code:\\n\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "sairajd044",
                        "content": "I computed mirror of left subtree and checked if it is equal to right subtree,"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "I struggled on this one too"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Idk i just did post order on the left and right subtrees at the main root, but inverted the left subtree as i did the dfs. If the tree is \"symmetrical\" both post orders should be identical. Solutions may become trivial depending one how you\\'re looking at the principle parts of the problem"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried to solve it using BFS and splitting it into levels, then checking if each level was a palindrome. I feel that is a more intuitive solution than traversing both halves at the same time. I got it to work for 197 out of 199 of cases before giving up."
                    },
                    {
                        "username": "sahle123",
                        "content": "[@djslim](/djslim) You\\'re not supposed to post your code in the Discussions tab. There\\'s already a tab for finding people\\'s solution."
                    },
                    {
                        "username": "djslim",
                        "content": "yup, you can do bfs, \\nmy js code:\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "BrodyK",
                        "content": "I created a BFS solution if you wanted to compare it to yours\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3192072/breadth-search-solution-python/"
                    },
                    {
                        "username": "dark",
                        "content": "This problem involves two point:\\n\\n**symmetric:**\\n\\nconsider tree T:\\n\\nif T is null, then T is symmetric\\n\\nif T->left is mirror of T->right,then T is symmetric\\n\\n**mirror**\\n\\nconsider two tree T and R:\\n\\nif T=R=NULL, then T is mirror of R\\n\\nif T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror\\n\\notherwise the mirror relationship cannot estabished"
                    },
                    {
                        "username": "Neo57",
                        "content": "you forgot one part. The accurate statement is \"if T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror and T.val == R.Val\""
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "just move inorder in the leftsubtree and move reverse inorder in the rightsubtree simultaneously and check if they have the same value. "
                    },
                    {
                        "username": "souravedu87",
                        "content": "testcase 195 fails with this approach [1,2,2,2,null,2]"
                    },
                    {
                        "username": "carl-egge",
                        "content": "I was trying to implent this approach, but I had a problem with one testcase where I think the inorder is the same, but is it not mirrored:\\n[5,4,1,null,1,null,4,2,null,2,null]\\n\\nBoth sides lead to a inorder of [4,2,1] (if one is reversed)"
                    },
                    {
                        "username": "shikharscout",
                        "content": "This will not work for Test Case 95"
                    },
                    {
                        "username": "riteshroshan77",
                        "content": "same i was thinking but unable to convert my thought in code"
                    },
                    {
                        "username": "Heathro",
                        "content": "your commet was very handy. I tried to figure out how to deepsearch both sides to be able to compare, and here comes your \"reverse in-odred\" advise. thank you =)"
                    },
                    {
                        "username": "meow_power",
                        "content": "It\\'s a shame that even on solving this problem before I can\\'t think on how to solve this problem :("
                    },
                    {
                        "username": "mskamel",
                        "content": "Sorry to hear that you are frustrated man, it\\'s okay. Keep solving these questions and you will get better at them. A personal advice from me is to not read the solutions before you solve the problem, this will help you truly get better at LeetCode. I wish you all the best and keep grinding ;)"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Same. Even some hard problems here just a matter of time. Maybe day or more. \\n\\nThis one seems undoable for those who don\\'t know theory perfect. "
                    },
                    {
                        "username": "jclo123",
                        "content": ">The number of recursive calls is bound by the height of the tree. In the worst case, the tree is linear and the height is in O(n).\\n\\nHowever, if it is a linear tree, it will return false right at if (!left || !right).  I think the worst case should be a balanced tree where we need to make recursive call on each node."
                    },
                    {
                        "username": "njain07",
                        "content": "[1,2,2,5,null,null,5,6,null,null,6]\\n\\nAccording to my understanding, the levels of the tree should be:\\n[1]\\n[2,2]\\n[5,null,null,5]\\n[6,null,null,6] --> shouldn\\'t this have a length of 8 and not 4?\\n\\n*This testcode\\'s expected output is true.*"
                    },
                    {
                        "username": "dima0000000000",
                        "content": "Null elements cannot have their leaves, so the branch ends on it."
                    },
                    {
                        "username": "ben_huang",
                        "content": "step1. rotate(root->left)\\nstep2. equal(root->right,root->left)"
                    }
                ]
            },
            {
                "id": 1830814,
                "content": [
                    {
                        "username": "sharabiania",
                        "content": "Should change the title of the question to Mirror Tree. Symetric Tree can cause confusion."
                    },
                    {
                        "username": "heissanjay",
                        "content": "That\\'s correct, Symmetric doesn\\'t cover the mirror property "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Lol yeah that tripped me up for a few minutes for sure."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes bro symmetric also mean the same i think"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think this question difficulty is needed to be increased. Its difficulty should be medium."
                    },
                    {
                        "username": "AdamGold",
                        "content": "I disagree. This question is nearly identical to another easy problem, tree equality. Except instead of chcking p.left with q.left, you check p.left against r.right and vice versa"
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@stridemann](/stridemann) You\\'re not the standard of how people see this problem. Probably you are good in node theory. \\n\\nBut at each problem with TreeNode people leave comments with requests of increasing diifficulty. And i think they are right. This is very complicate even for people with 1 year programming experience like me."
                    },
                    {
                        "username": "stridemann",
                        "content": "Sorry, disagree.\nFor my level of solving problems medium takes up to 1-2 hour, hard can be more than a day, but this problem is around 10 min.\nIf s1 need a theory with code and good step-by-step visualization https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/BinaryTreeTraversal.html "
                    },
                    {
                        "username": "mandy1339",
                        "content": "The solution was not trivial. You have to know how to traverse to trees simultaneously in inverse order. I couldn\\'t think of any trivial solutions. Took me too long for an easy problem. What do you think?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its a tough problem for sure. I had to seek a hint to solve too but it made a lot of sense after realizing it "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "agree. Yesterdays hard on the daily coding challenges was easier then this lol"
                    },
                    {
                        "username": "djslim",
                        "content": "BFS works pretty well, just need to push null into queue to mark on which side nodes are, my javascript code:\\n\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "sairajd044",
                        "content": "I computed mirror of left subtree and checked if it is equal to right subtree,"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "I struggled on this one too"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Idk i just did post order on the left and right subtrees at the main root, but inverted the left subtree as i did the dfs. If the tree is \"symmetrical\" both post orders should be identical. Solutions may become trivial depending one how you\\'re looking at the principle parts of the problem"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried to solve it using BFS and splitting it into levels, then checking if each level was a palindrome. I feel that is a more intuitive solution than traversing both halves at the same time. I got it to work for 197 out of 199 of cases before giving up."
                    },
                    {
                        "username": "sahle123",
                        "content": "[@djslim](/djslim) You\\'re not supposed to post your code in the Discussions tab. There\\'s already a tab for finding people\\'s solution."
                    },
                    {
                        "username": "djslim",
                        "content": "yup, you can do bfs, \\nmy js code:\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "BrodyK",
                        "content": "I created a BFS solution if you wanted to compare it to yours\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3192072/breadth-search-solution-python/"
                    },
                    {
                        "username": "dark",
                        "content": "This problem involves two point:\\n\\n**symmetric:**\\n\\nconsider tree T:\\n\\nif T is null, then T is symmetric\\n\\nif T->left is mirror of T->right,then T is symmetric\\n\\n**mirror**\\n\\nconsider two tree T and R:\\n\\nif T=R=NULL, then T is mirror of R\\n\\nif T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror\\n\\notherwise the mirror relationship cannot estabished"
                    },
                    {
                        "username": "Neo57",
                        "content": "you forgot one part. The accurate statement is \"if T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror and T.val == R.Val\""
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "just move inorder in the leftsubtree and move reverse inorder in the rightsubtree simultaneously and check if they have the same value. "
                    },
                    {
                        "username": "souravedu87",
                        "content": "testcase 195 fails with this approach [1,2,2,2,null,2]"
                    },
                    {
                        "username": "carl-egge",
                        "content": "I was trying to implent this approach, but I had a problem with one testcase where I think the inorder is the same, but is it not mirrored:\\n[5,4,1,null,1,null,4,2,null,2,null]\\n\\nBoth sides lead to a inorder of [4,2,1] (if one is reversed)"
                    },
                    {
                        "username": "shikharscout",
                        "content": "This will not work for Test Case 95"
                    },
                    {
                        "username": "riteshroshan77",
                        "content": "same i was thinking but unable to convert my thought in code"
                    },
                    {
                        "username": "Heathro",
                        "content": "your commet was very handy. I tried to figure out how to deepsearch both sides to be able to compare, and here comes your \"reverse in-odred\" advise. thank you =)"
                    },
                    {
                        "username": "meow_power",
                        "content": "It\\'s a shame that even on solving this problem before I can\\'t think on how to solve this problem :("
                    },
                    {
                        "username": "mskamel",
                        "content": "Sorry to hear that you are frustrated man, it\\'s okay. Keep solving these questions and you will get better at them. A personal advice from me is to not read the solutions before you solve the problem, this will help you truly get better at LeetCode. I wish you all the best and keep grinding ;)"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Same. Even some hard problems here just a matter of time. Maybe day or more. \\n\\nThis one seems undoable for those who don\\'t know theory perfect. "
                    },
                    {
                        "username": "jclo123",
                        "content": ">The number of recursive calls is bound by the height of the tree. In the worst case, the tree is linear and the height is in O(n).\\n\\nHowever, if it is a linear tree, it will return false right at if (!left || !right).  I think the worst case should be a balanced tree where we need to make recursive call on each node."
                    },
                    {
                        "username": "njain07",
                        "content": "[1,2,2,5,null,null,5,6,null,null,6]\\n\\nAccording to my understanding, the levels of the tree should be:\\n[1]\\n[2,2]\\n[5,null,null,5]\\n[6,null,null,6] --> shouldn\\'t this have a length of 8 and not 4?\\n\\n*This testcode\\'s expected output is true.*"
                    },
                    {
                        "username": "dima0000000000",
                        "content": "Null elements cannot have their leaves, so the branch ends on it."
                    },
                    {
                        "username": "ben_huang",
                        "content": "step1. rotate(root->left)\\nstep2. equal(root->right,root->left)"
                    }
                ]
            },
            {
                "id": 1567526,
                "content": [
                    {
                        "username": "sharabiania",
                        "content": "Should change the title of the question to Mirror Tree. Symetric Tree can cause confusion."
                    },
                    {
                        "username": "heissanjay",
                        "content": "That\\'s correct, Symmetric doesn\\'t cover the mirror property "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Lol yeah that tripped me up for a few minutes for sure."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes bro symmetric also mean the same i think"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think this question difficulty is needed to be increased. Its difficulty should be medium."
                    },
                    {
                        "username": "AdamGold",
                        "content": "I disagree. This question is nearly identical to another easy problem, tree equality. Except instead of chcking p.left with q.left, you check p.left against r.right and vice versa"
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@stridemann](/stridemann) You\\'re not the standard of how people see this problem. Probably you are good in node theory. \\n\\nBut at each problem with TreeNode people leave comments with requests of increasing diifficulty. And i think they are right. This is very complicate even for people with 1 year programming experience like me."
                    },
                    {
                        "username": "stridemann",
                        "content": "Sorry, disagree.\nFor my level of solving problems medium takes up to 1-2 hour, hard can be more than a day, but this problem is around 10 min.\nIf s1 need a theory with code and good step-by-step visualization https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/BinaryTreeTraversal.html "
                    },
                    {
                        "username": "mandy1339",
                        "content": "The solution was not trivial. You have to know how to traverse to trees simultaneously in inverse order. I couldn\\'t think of any trivial solutions. Took me too long for an easy problem. What do you think?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its a tough problem for sure. I had to seek a hint to solve too but it made a lot of sense after realizing it "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "agree. Yesterdays hard on the daily coding challenges was easier then this lol"
                    },
                    {
                        "username": "djslim",
                        "content": "BFS works pretty well, just need to push null into queue to mark on which side nodes are, my javascript code:\\n\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "sairajd044",
                        "content": "I computed mirror of left subtree and checked if it is equal to right subtree,"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "I struggled on this one too"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Idk i just did post order on the left and right subtrees at the main root, but inverted the left subtree as i did the dfs. If the tree is \"symmetrical\" both post orders should be identical. Solutions may become trivial depending one how you\\'re looking at the principle parts of the problem"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried to solve it using BFS and splitting it into levels, then checking if each level was a palindrome. I feel that is a more intuitive solution than traversing both halves at the same time. I got it to work for 197 out of 199 of cases before giving up."
                    },
                    {
                        "username": "sahle123",
                        "content": "[@djslim](/djslim) You\\'re not supposed to post your code in the Discussions tab. There\\'s already a tab for finding people\\'s solution."
                    },
                    {
                        "username": "djslim",
                        "content": "yup, you can do bfs, \\nmy js code:\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "BrodyK",
                        "content": "I created a BFS solution if you wanted to compare it to yours\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3192072/breadth-search-solution-python/"
                    },
                    {
                        "username": "dark",
                        "content": "This problem involves two point:\\n\\n**symmetric:**\\n\\nconsider tree T:\\n\\nif T is null, then T is symmetric\\n\\nif T->left is mirror of T->right,then T is symmetric\\n\\n**mirror**\\n\\nconsider two tree T and R:\\n\\nif T=R=NULL, then T is mirror of R\\n\\nif T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror\\n\\notherwise the mirror relationship cannot estabished"
                    },
                    {
                        "username": "Neo57",
                        "content": "you forgot one part. The accurate statement is \"if T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror and T.val == R.Val\""
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "just move inorder in the leftsubtree and move reverse inorder in the rightsubtree simultaneously and check if they have the same value. "
                    },
                    {
                        "username": "souravedu87",
                        "content": "testcase 195 fails with this approach [1,2,2,2,null,2]"
                    },
                    {
                        "username": "carl-egge",
                        "content": "I was trying to implent this approach, but I had a problem with one testcase where I think the inorder is the same, but is it not mirrored:\\n[5,4,1,null,1,null,4,2,null,2,null]\\n\\nBoth sides lead to a inorder of [4,2,1] (if one is reversed)"
                    },
                    {
                        "username": "shikharscout",
                        "content": "This will not work for Test Case 95"
                    },
                    {
                        "username": "riteshroshan77",
                        "content": "same i was thinking but unable to convert my thought in code"
                    },
                    {
                        "username": "Heathro",
                        "content": "your commet was very handy. I tried to figure out how to deepsearch both sides to be able to compare, and here comes your \"reverse in-odred\" advise. thank you =)"
                    },
                    {
                        "username": "meow_power",
                        "content": "It\\'s a shame that even on solving this problem before I can\\'t think on how to solve this problem :("
                    },
                    {
                        "username": "mskamel",
                        "content": "Sorry to hear that you are frustrated man, it\\'s okay. Keep solving these questions and you will get better at them. A personal advice from me is to not read the solutions before you solve the problem, this will help you truly get better at LeetCode. I wish you all the best and keep grinding ;)"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Same. Even some hard problems here just a matter of time. Maybe day or more. \\n\\nThis one seems undoable for those who don\\'t know theory perfect. "
                    },
                    {
                        "username": "jclo123",
                        "content": ">The number of recursive calls is bound by the height of the tree. In the worst case, the tree is linear and the height is in O(n).\\n\\nHowever, if it is a linear tree, it will return false right at if (!left || !right).  I think the worst case should be a balanced tree where we need to make recursive call on each node."
                    },
                    {
                        "username": "njain07",
                        "content": "[1,2,2,5,null,null,5,6,null,null,6]\\n\\nAccording to my understanding, the levels of the tree should be:\\n[1]\\n[2,2]\\n[5,null,null,5]\\n[6,null,null,6] --> shouldn\\'t this have a length of 8 and not 4?\\n\\n*This testcode\\'s expected output is true.*"
                    },
                    {
                        "username": "dima0000000000",
                        "content": "Null elements cannot have their leaves, so the branch ends on it."
                    },
                    {
                        "username": "ben_huang",
                        "content": "step1. rotate(root->left)\\nstep2. equal(root->right,root->left)"
                    }
                ]
            },
            {
                "id": 1572756,
                "content": [
                    {
                        "username": "sharabiania",
                        "content": "Should change the title of the question to Mirror Tree. Symetric Tree can cause confusion."
                    },
                    {
                        "username": "heissanjay",
                        "content": "That\\'s correct, Symmetric doesn\\'t cover the mirror property "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Lol yeah that tripped me up for a few minutes for sure."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes bro symmetric also mean the same i think"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think this question difficulty is needed to be increased. Its difficulty should be medium."
                    },
                    {
                        "username": "AdamGold",
                        "content": "I disagree. This question is nearly identical to another easy problem, tree equality. Except instead of chcking p.left with q.left, you check p.left against r.right and vice versa"
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@stridemann](/stridemann) You\\'re not the standard of how people see this problem. Probably you are good in node theory. \\n\\nBut at each problem with TreeNode people leave comments with requests of increasing diifficulty. And i think they are right. This is very complicate even for people with 1 year programming experience like me."
                    },
                    {
                        "username": "stridemann",
                        "content": "Sorry, disagree.\nFor my level of solving problems medium takes up to 1-2 hour, hard can be more than a day, but this problem is around 10 min.\nIf s1 need a theory with code and good step-by-step visualization https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/BinaryTreeTraversal.html "
                    },
                    {
                        "username": "mandy1339",
                        "content": "The solution was not trivial. You have to know how to traverse to trees simultaneously in inverse order. I couldn\\'t think of any trivial solutions. Took me too long for an easy problem. What do you think?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its a tough problem for sure. I had to seek a hint to solve too but it made a lot of sense after realizing it "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "agree. Yesterdays hard on the daily coding challenges was easier then this lol"
                    },
                    {
                        "username": "djslim",
                        "content": "BFS works pretty well, just need to push null into queue to mark on which side nodes are, my javascript code:\\n\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "sairajd044",
                        "content": "I computed mirror of left subtree and checked if it is equal to right subtree,"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "I struggled on this one too"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Idk i just did post order on the left and right subtrees at the main root, but inverted the left subtree as i did the dfs. If the tree is \"symmetrical\" both post orders should be identical. Solutions may become trivial depending one how you\\'re looking at the principle parts of the problem"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried to solve it using BFS and splitting it into levels, then checking if each level was a palindrome. I feel that is a more intuitive solution than traversing both halves at the same time. I got it to work for 197 out of 199 of cases before giving up."
                    },
                    {
                        "username": "sahle123",
                        "content": "[@djslim](/djslim) You\\'re not supposed to post your code in the Discussions tab. There\\'s already a tab for finding people\\'s solution."
                    },
                    {
                        "username": "djslim",
                        "content": "yup, you can do bfs, \\nmy js code:\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "BrodyK",
                        "content": "I created a BFS solution if you wanted to compare it to yours\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3192072/breadth-search-solution-python/"
                    },
                    {
                        "username": "dark",
                        "content": "This problem involves two point:\\n\\n**symmetric:**\\n\\nconsider tree T:\\n\\nif T is null, then T is symmetric\\n\\nif T->left is mirror of T->right,then T is symmetric\\n\\n**mirror**\\n\\nconsider two tree T and R:\\n\\nif T=R=NULL, then T is mirror of R\\n\\nif T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror\\n\\notherwise the mirror relationship cannot estabished"
                    },
                    {
                        "username": "Neo57",
                        "content": "you forgot one part. The accurate statement is \"if T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror and T.val == R.Val\""
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "just move inorder in the leftsubtree and move reverse inorder in the rightsubtree simultaneously and check if they have the same value. "
                    },
                    {
                        "username": "souravedu87",
                        "content": "testcase 195 fails with this approach [1,2,2,2,null,2]"
                    },
                    {
                        "username": "carl-egge",
                        "content": "I was trying to implent this approach, but I had a problem with one testcase where I think the inorder is the same, but is it not mirrored:\\n[5,4,1,null,1,null,4,2,null,2,null]\\n\\nBoth sides lead to a inorder of [4,2,1] (if one is reversed)"
                    },
                    {
                        "username": "shikharscout",
                        "content": "This will not work for Test Case 95"
                    },
                    {
                        "username": "riteshroshan77",
                        "content": "same i was thinking but unable to convert my thought in code"
                    },
                    {
                        "username": "Heathro",
                        "content": "your commet was very handy. I tried to figure out how to deepsearch both sides to be able to compare, and here comes your \"reverse in-odred\" advise. thank you =)"
                    },
                    {
                        "username": "meow_power",
                        "content": "It\\'s a shame that even on solving this problem before I can\\'t think on how to solve this problem :("
                    },
                    {
                        "username": "mskamel",
                        "content": "Sorry to hear that you are frustrated man, it\\'s okay. Keep solving these questions and you will get better at them. A personal advice from me is to not read the solutions before you solve the problem, this will help you truly get better at LeetCode. I wish you all the best and keep grinding ;)"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Same. Even some hard problems here just a matter of time. Maybe day or more. \\n\\nThis one seems undoable for those who don\\'t know theory perfect. "
                    },
                    {
                        "username": "jclo123",
                        "content": ">The number of recursive calls is bound by the height of the tree. In the worst case, the tree is linear and the height is in O(n).\\n\\nHowever, if it is a linear tree, it will return false right at if (!left || !right).  I think the worst case should be a balanced tree where we need to make recursive call on each node."
                    },
                    {
                        "username": "njain07",
                        "content": "[1,2,2,5,null,null,5,6,null,null,6]\\n\\nAccording to my understanding, the levels of the tree should be:\\n[1]\\n[2,2]\\n[5,null,null,5]\\n[6,null,null,6] --> shouldn\\'t this have a length of 8 and not 4?\\n\\n*This testcode\\'s expected output is true.*"
                    },
                    {
                        "username": "dima0000000000",
                        "content": "Null elements cannot have their leaves, so the branch ends on it."
                    },
                    {
                        "username": "ben_huang",
                        "content": "step1. rotate(root->left)\\nstep2. equal(root->right,root->left)"
                    }
                ]
            },
            {
                "id": 1572521,
                "content": [
                    {
                        "username": "sharabiania",
                        "content": "Should change the title of the question to Mirror Tree. Symetric Tree can cause confusion."
                    },
                    {
                        "username": "heissanjay",
                        "content": "That\\'s correct, Symmetric doesn\\'t cover the mirror property "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Lol yeah that tripped me up for a few minutes for sure."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes bro symmetric also mean the same i think"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think this question difficulty is needed to be increased. Its difficulty should be medium."
                    },
                    {
                        "username": "AdamGold",
                        "content": "I disagree. This question is nearly identical to another easy problem, tree equality. Except instead of chcking p.left with q.left, you check p.left against r.right and vice versa"
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@stridemann](/stridemann) You\\'re not the standard of how people see this problem. Probably you are good in node theory. \\n\\nBut at each problem with TreeNode people leave comments with requests of increasing diifficulty. And i think they are right. This is very complicate even for people with 1 year programming experience like me."
                    },
                    {
                        "username": "stridemann",
                        "content": "Sorry, disagree.\nFor my level of solving problems medium takes up to 1-2 hour, hard can be more than a day, but this problem is around 10 min.\nIf s1 need a theory with code and good step-by-step visualization https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/BinaryTreeTraversal.html "
                    },
                    {
                        "username": "mandy1339",
                        "content": "The solution was not trivial. You have to know how to traverse to trees simultaneously in inverse order. I couldn\\'t think of any trivial solutions. Took me too long for an easy problem. What do you think?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its a tough problem for sure. I had to seek a hint to solve too but it made a lot of sense after realizing it "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "agree. Yesterdays hard on the daily coding challenges was easier then this lol"
                    },
                    {
                        "username": "djslim",
                        "content": "BFS works pretty well, just need to push null into queue to mark on which side nodes are, my javascript code:\\n\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "sairajd044",
                        "content": "I computed mirror of left subtree and checked if it is equal to right subtree,"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "I struggled on this one too"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Idk i just did post order on the left and right subtrees at the main root, but inverted the left subtree as i did the dfs. If the tree is \"symmetrical\" both post orders should be identical. Solutions may become trivial depending one how you\\'re looking at the principle parts of the problem"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried to solve it using BFS and splitting it into levels, then checking if each level was a palindrome. I feel that is a more intuitive solution than traversing both halves at the same time. I got it to work for 197 out of 199 of cases before giving up."
                    },
                    {
                        "username": "sahle123",
                        "content": "[@djslim](/djslim) You\\'re not supposed to post your code in the Discussions tab. There\\'s already a tab for finding people\\'s solution."
                    },
                    {
                        "username": "djslim",
                        "content": "yup, you can do bfs, \\nmy js code:\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "BrodyK",
                        "content": "I created a BFS solution if you wanted to compare it to yours\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3192072/breadth-search-solution-python/"
                    },
                    {
                        "username": "dark",
                        "content": "This problem involves two point:\\n\\n**symmetric:**\\n\\nconsider tree T:\\n\\nif T is null, then T is symmetric\\n\\nif T->left is mirror of T->right,then T is symmetric\\n\\n**mirror**\\n\\nconsider two tree T and R:\\n\\nif T=R=NULL, then T is mirror of R\\n\\nif T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror\\n\\notherwise the mirror relationship cannot estabished"
                    },
                    {
                        "username": "Neo57",
                        "content": "you forgot one part. The accurate statement is \"if T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror and T.val == R.Val\""
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "just move inorder in the leftsubtree and move reverse inorder in the rightsubtree simultaneously and check if they have the same value. "
                    },
                    {
                        "username": "souravedu87",
                        "content": "testcase 195 fails with this approach [1,2,2,2,null,2]"
                    },
                    {
                        "username": "carl-egge",
                        "content": "I was trying to implent this approach, but I had a problem with one testcase where I think the inorder is the same, but is it not mirrored:\\n[5,4,1,null,1,null,4,2,null,2,null]\\n\\nBoth sides lead to a inorder of [4,2,1] (if one is reversed)"
                    },
                    {
                        "username": "shikharscout",
                        "content": "This will not work for Test Case 95"
                    },
                    {
                        "username": "riteshroshan77",
                        "content": "same i was thinking but unable to convert my thought in code"
                    },
                    {
                        "username": "Heathro",
                        "content": "your commet was very handy. I tried to figure out how to deepsearch both sides to be able to compare, and here comes your \"reverse in-odred\" advise. thank you =)"
                    },
                    {
                        "username": "meow_power",
                        "content": "It\\'s a shame that even on solving this problem before I can\\'t think on how to solve this problem :("
                    },
                    {
                        "username": "mskamel",
                        "content": "Sorry to hear that you are frustrated man, it\\'s okay. Keep solving these questions and you will get better at them. A personal advice from me is to not read the solutions before you solve the problem, this will help you truly get better at LeetCode. I wish you all the best and keep grinding ;)"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Same. Even some hard problems here just a matter of time. Maybe day or more. \\n\\nThis one seems undoable for those who don\\'t know theory perfect. "
                    },
                    {
                        "username": "jclo123",
                        "content": ">The number of recursive calls is bound by the height of the tree. In the worst case, the tree is linear and the height is in O(n).\\n\\nHowever, if it is a linear tree, it will return false right at if (!left || !right).  I think the worst case should be a balanced tree where we need to make recursive call on each node."
                    },
                    {
                        "username": "njain07",
                        "content": "[1,2,2,5,null,null,5,6,null,null,6]\\n\\nAccording to my understanding, the levels of the tree should be:\\n[1]\\n[2,2]\\n[5,null,null,5]\\n[6,null,null,6] --> shouldn\\'t this have a length of 8 and not 4?\\n\\n*This testcode\\'s expected output is true.*"
                    },
                    {
                        "username": "dima0000000000",
                        "content": "Null elements cannot have their leaves, so the branch ends on it."
                    },
                    {
                        "username": "ben_huang",
                        "content": "step1. rotate(root->left)\\nstep2. equal(root->right,root->left)"
                    }
                ]
            },
            {
                "id": 1569663,
                "content": [
                    {
                        "username": "sharabiania",
                        "content": "Should change the title of the question to Mirror Tree. Symetric Tree can cause confusion."
                    },
                    {
                        "username": "heissanjay",
                        "content": "That\\'s correct, Symmetric doesn\\'t cover the mirror property "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Lol yeah that tripped me up for a few minutes for sure."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes bro symmetric also mean the same i think"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think this question difficulty is needed to be increased. Its difficulty should be medium."
                    },
                    {
                        "username": "AdamGold",
                        "content": "I disagree. This question is nearly identical to another easy problem, tree equality. Except instead of chcking p.left with q.left, you check p.left against r.right and vice versa"
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@stridemann](/stridemann) You\\'re not the standard of how people see this problem. Probably you are good in node theory. \\n\\nBut at each problem with TreeNode people leave comments with requests of increasing diifficulty. And i think they are right. This is very complicate even for people with 1 year programming experience like me."
                    },
                    {
                        "username": "stridemann",
                        "content": "Sorry, disagree.\nFor my level of solving problems medium takes up to 1-2 hour, hard can be more than a day, but this problem is around 10 min.\nIf s1 need a theory with code and good step-by-step visualization https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/BinaryTreeTraversal.html "
                    },
                    {
                        "username": "mandy1339",
                        "content": "The solution was not trivial. You have to know how to traverse to trees simultaneously in inverse order. I couldn\\'t think of any trivial solutions. Took me too long for an easy problem. What do you think?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its a tough problem for sure. I had to seek a hint to solve too but it made a lot of sense after realizing it "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "agree. Yesterdays hard on the daily coding challenges was easier then this lol"
                    },
                    {
                        "username": "djslim",
                        "content": "BFS works pretty well, just need to push null into queue to mark on which side nodes are, my javascript code:\\n\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "sairajd044",
                        "content": "I computed mirror of left subtree and checked if it is equal to right subtree,"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "I struggled on this one too"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Idk i just did post order on the left and right subtrees at the main root, but inverted the left subtree as i did the dfs. If the tree is \"symmetrical\" both post orders should be identical. Solutions may become trivial depending one how you\\'re looking at the principle parts of the problem"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried to solve it using BFS and splitting it into levels, then checking if each level was a palindrome. I feel that is a more intuitive solution than traversing both halves at the same time. I got it to work for 197 out of 199 of cases before giving up."
                    },
                    {
                        "username": "sahle123",
                        "content": "[@djslim](/djslim) You\\'re not supposed to post your code in the Discussions tab. There\\'s already a tab for finding people\\'s solution."
                    },
                    {
                        "username": "djslim",
                        "content": "yup, you can do bfs, \\nmy js code:\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "BrodyK",
                        "content": "I created a BFS solution if you wanted to compare it to yours\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3192072/breadth-search-solution-python/"
                    },
                    {
                        "username": "dark",
                        "content": "This problem involves two point:\\n\\n**symmetric:**\\n\\nconsider tree T:\\n\\nif T is null, then T is symmetric\\n\\nif T->left is mirror of T->right,then T is symmetric\\n\\n**mirror**\\n\\nconsider two tree T and R:\\n\\nif T=R=NULL, then T is mirror of R\\n\\nif T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror\\n\\notherwise the mirror relationship cannot estabished"
                    },
                    {
                        "username": "Neo57",
                        "content": "you forgot one part. The accurate statement is \"if T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror and T.val == R.Val\""
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "just move inorder in the leftsubtree and move reverse inorder in the rightsubtree simultaneously and check if they have the same value. "
                    },
                    {
                        "username": "souravedu87",
                        "content": "testcase 195 fails with this approach [1,2,2,2,null,2]"
                    },
                    {
                        "username": "carl-egge",
                        "content": "I was trying to implent this approach, but I had a problem with one testcase where I think the inorder is the same, but is it not mirrored:\\n[5,4,1,null,1,null,4,2,null,2,null]\\n\\nBoth sides lead to a inorder of [4,2,1] (if one is reversed)"
                    },
                    {
                        "username": "shikharscout",
                        "content": "This will not work for Test Case 95"
                    },
                    {
                        "username": "riteshroshan77",
                        "content": "same i was thinking but unable to convert my thought in code"
                    },
                    {
                        "username": "Heathro",
                        "content": "your commet was very handy. I tried to figure out how to deepsearch both sides to be able to compare, and here comes your \"reverse in-odred\" advise. thank you =)"
                    },
                    {
                        "username": "meow_power",
                        "content": "It\\'s a shame that even on solving this problem before I can\\'t think on how to solve this problem :("
                    },
                    {
                        "username": "mskamel",
                        "content": "Sorry to hear that you are frustrated man, it\\'s okay. Keep solving these questions and you will get better at them. A personal advice from me is to not read the solutions before you solve the problem, this will help you truly get better at LeetCode. I wish you all the best and keep grinding ;)"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Same. Even some hard problems here just a matter of time. Maybe day or more. \\n\\nThis one seems undoable for those who don\\'t know theory perfect. "
                    },
                    {
                        "username": "jclo123",
                        "content": ">The number of recursive calls is bound by the height of the tree. In the worst case, the tree is linear and the height is in O(n).\\n\\nHowever, if it is a linear tree, it will return false right at if (!left || !right).  I think the worst case should be a balanced tree where we need to make recursive call on each node."
                    },
                    {
                        "username": "njain07",
                        "content": "[1,2,2,5,null,null,5,6,null,null,6]\\n\\nAccording to my understanding, the levels of the tree should be:\\n[1]\\n[2,2]\\n[5,null,null,5]\\n[6,null,null,6] --> shouldn\\'t this have a length of 8 and not 4?\\n\\n*This testcode\\'s expected output is true.*"
                    },
                    {
                        "username": "dima0000000000",
                        "content": "Null elements cannot have their leaves, so the branch ends on it."
                    },
                    {
                        "username": "ben_huang",
                        "content": "step1. rotate(root->left)\\nstep2. equal(root->right,root->left)"
                    }
                ]
            },
            {
                "id": 1831340,
                "content": [
                    {
                        "username": "sharabiania",
                        "content": "Should change the title of the question to Mirror Tree. Symetric Tree can cause confusion."
                    },
                    {
                        "username": "heissanjay",
                        "content": "That\\'s correct, Symmetric doesn\\'t cover the mirror property "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Lol yeah that tripped me up for a few minutes for sure."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes bro symmetric also mean the same i think"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think this question difficulty is needed to be increased. Its difficulty should be medium."
                    },
                    {
                        "username": "AdamGold",
                        "content": "I disagree. This question is nearly identical to another easy problem, tree equality. Except instead of chcking p.left with q.left, you check p.left against r.right and vice versa"
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@stridemann](/stridemann) You\\'re not the standard of how people see this problem. Probably you are good in node theory. \\n\\nBut at each problem with TreeNode people leave comments with requests of increasing diifficulty. And i think they are right. This is very complicate even for people with 1 year programming experience like me."
                    },
                    {
                        "username": "stridemann",
                        "content": "Sorry, disagree.\nFor my level of solving problems medium takes up to 1-2 hour, hard can be more than a day, but this problem is around 10 min.\nIf s1 need a theory with code and good step-by-step visualization https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/BinaryTreeTraversal.html "
                    },
                    {
                        "username": "mandy1339",
                        "content": "The solution was not trivial. You have to know how to traverse to trees simultaneously in inverse order. I couldn\\'t think of any trivial solutions. Took me too long for an easy problem. What do you think?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its a tough problem for sure. I had to seek a hint to solve too but it made a lot of sense after realizing it "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "agree. Yesterdays hard on the daily coding challenges was easier then this lol"
                    },
                    {
                        "username": "djslim",
                        "content": "BFS works pretty well, just need to push null into queue to mark on which side nodes are, my javascript code:\\n\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "sairajd044",
                        "content": "I computed mirror of left subtree and checked if it is equal to right subtree,"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "I struggled on this one too"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Idk i just did post order on the left and right subtrees at the main root, but inverted the left subtree as i did the dfs. If the tree is \"symmetrical\" both post orders should be identical. Solutions may become trivial depending one how you\\'re looking at the principle parts of the problem"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried to solve it using BFS and splitting it into levels, then checking if each level was a palindrome. I feel that is a more intuitive solution than traversing both halves at the same time. I got it to work for 197 out of 199 of cases before giving up."
                    },
                    {
                        "username": "sahle123",
                        "content": "[@djslim](/djslim) You\\'re not supposed to post your code in the Discussions tab. There\\'s already a tab for finding people\\'s solution."
                    },
                    {
                        "username": "djslim",
                        "content": "yup, you can do bfs, \\nmy js code:\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "BrodyK",
                        "content": "I created a BFS solution if you wanted to compare it to yours\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3192072/breadth-search-solution-python/"
                    },
                    {
                        "username": "dark",
                        "content": "This problem involves two point:\\n\\n**symmetric:**\\n\\nconsider tree T:\\n\\nif T is null, then T is symmetric\\n\\nif T->left is mirror of T->right,then T is symmetric\\n\\n**mirror**\\n\\nconsider two tree T and R:\\n\\nif T=R=NULL, then T is mirror of R\\n\\nif T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror\\n\\notherwise the mirror relationship cannot estabished"
                    },
                    {
                        "username": "Neo57",
                        "content": "you forgot one part. The accurate statement is \"if T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror and T.val == R.Val\""
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "just move inorder in the leftsubtree and move reverse inorder in the rightsubtree simultaneously and check if they have the same value. "
                    },
                    {
                        "username": "souravedu87",
                        "content": "testcase 195 fails with this approach [1,2,2,2,null,2]"
                    },
                    {
                        "username": "carl-egge",
                        "content": "I was trying to implent this approach, but I had a problem with one testcase where I think the inorder is the same, but is it not mirrored:\\n[5,4,1,null,1,null,4,2,null,2,null]\\n\\nBoth sides lead to a inorder of [4,2,1] (if one is reversed)"
                    },
                    {
                        "username": "shikharscout",
                        "content": "This will not work for Test Case 95"
                    },
                    {
                        "username": "riteshroshan77",
                        "content": "same i was thinking but unable to convert my thought in code"
                    },
                    {
                        "username": "Heathro",
                        "content": "your commet was very handy. I tried to figure out how to deepsearch both sides to be able to compare, and here comes your \"reverse in-odred\" advise. thank you =)"
                    },
                    {
                        "username": "meow_power",
                        "content": "It\\'s a shame that even on solving this problem before I can\\'t think on how to solve this problem :("
                    },
                    {
                        "username": "mskamel",
                        "content": "Sorry to hear that you are frustrated man, it\\'s okay. Keep solving these questions and you will get better at them. A personal advice from me is to not read the solutions before you solve the problem, this will help you truly get better at LeetCode. I wish you all the best and keep grinding ;)"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Same. Even some hard problems here just a matter of time. Maybe day or more. \\n\\nThis one seems undoable for those who don\\'t know theory perfect. "
                    },
                    {
                        "username": "jclo123",
                        "content": ">The number of recursive calls is bound by the height of the tree. In the worst case, the tree is linear and the height is in O(n).\\n\\nHowever, if it is a linear tree, it will return false right at if (!left || !right).  I think the worst case should be a balanced tree where we need to make recursive call on each node."
                    },
                    {
                        "username": "njain07",
                        "content": "[1,2,2,5,null,null,5,6,null,null,6]\\n\\nAccording to my understanding, the levels of the tree should be:\\n[1]\\n[2,2]\\n[5,null,null,5]\\n[6,null,null,6] --> shouldn\\'t this have a length of 8 and not 4?\\n\\n*This testcode\\'s expected output is true.*"
                    },
                    {
                        "username": "dima0000000000",
                        "content": "Null elements cannot have their leaves, so the branch ends on it."
                    },
                    {
                        "username": "ben_huang",
                        "content": "step1. rotate(root->left)\\nstep2. equal(root->right,root->left)"
                    }
                ]
            },
            {
                "id": 1576379,
                "content": [
                    {
                        "username": "sharabiania",
                        "content": "Should change the title of the question to Mirror Tree. Symetric Tree can cause confusion."
                    },
                    {
                        "username": "heissanjay",
                        "content": "That\\'s correct, Symmetric doesn\\'t cover the mirror property "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Lol yeah that tripped me up for a few minutes for sure."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes bro symmetric also mean the same i think"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think this question difficulty is needed to be increased. Its difficulty should be medium."
                    },
                    {
                        "username": "AdamGold",
                        "content": "I disagree. This question is nearly identical to another easy problem, tree equality. Except instead of chcking p.left with q.left, you check p.left against r.right and vice versa"
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@stridemann](/stridemann) You\\'re not the standard of how people see this problem. Probably you are good in node theory. \\n\\nBut at each problem with TreeNode people leave comments with requests of increasing diifficulty. And i think they are right. This is very complicate even for people with 1 year programming experience like me."
                    },
                    {
                        "username": "stridemann",
                        "content": "Sorry, disagree.\nFor my level of solving problems medium takes up to 1-2 hour, hard can be more than a day, but this problem is around 10 min.\nIf s1 need a theory with code and good step-by-step visualization https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/BinaryTreeTraversal.html "
                    },
                    {
                        "username": "mandy1339",
                        "content": "The solution was not trivial. You have to know how to traverse to trees simultaneously in inverse order. I couldn\\'t think of any trivial solutions. Took me too long for an easy problem. What do you think?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its a tough problem for sure. I had to seek a hint to solve too but it made a lot of sense after realizing it "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "agree. Yesterdays hard on the daily coding challenges was easier then this lol"
                    },
                    {
                        "username": "djslim",
                        "content": "BFS works pretty well, just need to push null into queue to mark on which side nodes are, my javascript code:\\n\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "sairajd044",
                        "content": "I computed mirror of left subtree and checked if it is equal to right subtree,"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "I struggled on this one too"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Idk i just did post order on the left and right subtrees at the main root, but inverted the left subtree as i did the dfs. If the tree is \"symmetrical\" both post orders should be identical. Solutions may become trivial depending one how you\\'re looking at the principle parts of the problem"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried to solve it using BFS and splitting it into levels, then checking if each level was a palindrome. I feel that is a more intuitive solution than traversing both halves at the same time. I got it to work for 197 out of 199 of cases before giving up."
                    },
                    {
                        "username": "sahle123",
                        "content": "[@djslim](/djslim) You\\'re not supposed to post your code in the Discussions tab. There\\'s already a tab for finding people\\'s solution."
                    },
                    {
                        "username": "djslim",
                        "content": "yup, you can do bfs, \\nmy js code:\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "BrodyK",
                        "content": "I created a BFS solution if you wanted to compare it to yours\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3192072/breadth-search-solution-python/"
                    },
                    {
                        "username": "dark",
                        "content": "This problem involves two point:\\n\\n**symmetric:**\\n\\nconsider tree T:\\n\\nif T is null, then T is symmetric\\n\\nif T->left is mirror of T->right,then T is symmetric\\n\\n**mirror**\\n\\nconsider two tree T and R:\\n\\nif T=R=NULL, then T is mirror of R\\n\\nif T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror\\n\\notherwise the mirror relationship cannot estabished"
                    },
                    {
                        "username": "Neo57",
                        "content": "you forgot one part. The accurate statement is \"if T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror and T.val == R.Val\""
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "just move inorder in the leftsubtree and move reverse inorder in the rightsubtree simultaneously and check if they have the same value. "
                    },
                    {
                        "username": "souravedu87",
                        "content": "testcase 195 fails with this approach [1,2,2,2,null,2]"
                    },
                    {
                        "username": "carl-egge",
                        "content": "I was trying to implent this approach, but I had a problem with one testcase where I think the inorder is the same, but is it not mirrored:\\n[5,4,1,null,1,null,4,2,null,2,null]\\n\\nBoth sides lead to a inorder of [4,2,1] (if one is reversed)"
                    },
                    {
                        "username": "shikharscout",
                        "content": "This will not work for Test Case 95"
                    },
                    {
                        "username": "riteshroshan77",
                        "content": "same i was thinking but unable to convert my thought in code"
                    },
                    {
                        "username": "Heathro",
                        "content": "your commet was very handy. I tried to figure out how to deepsearch both sides to be able to compare, and here comes your \"reverse in-odred\" advise. thank you =)"
                    },
                    {
                        "username": "meow_power",
                        "content": "It\\'s a shame that even on solving this problem before I can\\'t think on how to solve this problem :("
                    },
                    {
                        "username": "mskamel",
                        "content": "Sorry to hear that you are frustrated man, it\\'s okay. Keep solving these questions and you will get better at them. A personal advice from me is to not read the solutions before you solve the problem, this will help you truly get better at LeetCode. I wish you all the best and keep grinding ;)"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Same. Even some hard problems here just a matter of time. Maybe day or more. \\n\\nThis one seems undoable for those who don\\'t know theory perfect. "
                    },
                    {
                        "username": "jclo123",
                        "content": ">The number of recursive calls is bound by the height of the tree. In the worst case, the tree is linear and the height is in O(n).\\n\\nHowever, if it is a linear tree, it will return false right at if (!left || !right).  I think the worst case should be a balanced tree where we need to make recursive call on each node."
                    },
                    {
                        "username": "njain07",
                        "content": "[1,2,2,5,null,null,5,6,null,null,6]\\n\\nAccording to my understanding, the levels of the tree should be:\\n[1]\\n[2,2]\\n[5,null,null,5]\\n[6,null,null,6] --> shouldn\\'t this have a length of 8 and not 4?\\n\\n*This testcode\\'s expected output is true.*"
                    },
                    {
                        "username": "dima0000000000",
                        "content": "Null elements cannot have their leaves, so the branch ends on it."
                    },
                    {
                        "username": "ben_huang",
                        "content": "step1. rotate(root->left)\\nstep2. equal(root->right,root->left)"
                    }
                ]
            },
            {
                "id": 1753495,
                "content": [
                    {
                        "username": "sharabiania",
                        "content": "Should change the title of the question to Mirror Tree. Symetric Tree can cause confusion."
                    },
                    {
                        "username": "heissanjay",
                        "content": "That\\'s correct, Symmetric doesn\\'t cover the mirror property "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Lol yeah that tripped me up for a few minutes for sure."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes bro symmetric also mean the same i think"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think this question difficulty is needed to be increased. Its difficulty should be medium."
                    },
                    {
                        "username": "AdamGold",
                        "content": "I disagree. This question is nearly identical to another easy problem, tree equality. Except instead of chcking p.left with q.left, you check p.left against r.right and vice versa"
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@stridemann](/stridemann) You\\'re not the standard of how people see this problem. Probably you are good in node theory. \\n\\nBut at each problem with TreeNode people leave comments with requests of increasing diifficulty. And i think they are right. This is very complicate even for people with 1 year programming experience like me."
                    },
                    {
                        "username": "stridemann",
                        "content": "Sorry, disagree.\nFor my level of solving problems medium takes up to 1-2 hour, hard can be more than a day, but this problem is around 10 min.\nIf s1 need a theory with code and good step-by-step visualization https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/BinaryTreeTraversal.html "
                    },
                    {
                        "username": "mandy1339",
                        "content": "The solution was not trivial. You have to know how to traverse to trees simultaneously in inverse order. I couldn\\'t think of any trivial solutions. Took me too long for an easy problem. What do you think?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its a tough problem for sure. I had to seek a hint to solve too but it made a lot of sense after realizing it "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "agree. Yesterdays hard on the daily coding challenges was easier then this lol"
                    },
                    {
                        "username": "djslim",
                        "content": "BFS works pretty well, just need to push null into queue to mark on which side nodes are, my javascript code:\\n\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "sairajd044",
                        "content": "I computed mirror of left subtree and checked if it is equal to right subtree,"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "I struggled on this one too"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Idk i just did post order on the left and right subtrees at the main root, but inverted the left subtree as i did the dfs. If the tree is \"symmetrical\" both post orders should be identical. Solutions may become trivial depending one how you\\'re looking at the principle parts of the problem"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried to solve it using BFS and splitting it into levels, then checking if each level was a palindrome. I feel that is a more intuitive solution than traversing both halves at the same time. I got it to work for 197 out of 199 of cases before giving up."
                    },
                    {
                        "username": "sahle123",
                        "content": "[@djslim](/djslim) You\\'re not supposed to post your code in the Discussions tab. There\\'s already a tab for finding people\\'s solution."
                    },
                    {
                        "username": "djslim",
                        "content": "yup, you can do bfs, \\nmy js code:\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "BrodyK",
                        "content": "I created a BFS solution if you wanted to compare it to yours\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3192072/breadth-search-solution-python/"
                    },
                    {
                        "username": "dark",
                        "content": "This problem involves two point:\\n\\n**symmetric:**\\n\\nconsider tree T:\\n\\nif T is null, then T is symmetric\\n\\nif T->left is mirror of T->right,then T is symmetric\\n\\n**mirror**\\n\\nconsider two tree T and R:\\n\\nif T=R=NULL, then T is mirror of R\\n\\nif T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror\\n\\notherwise the mirror relationship cannot estabished"
                    },
                    {
                        "username": "Neo57",
                        "content": "you forgot one part. The accurate statement is \"if T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror and T.val == R.Val\""
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "just move inorder in the leftsubtree and move reverse inorder in the rightsubtree simultaneously and check if they have the same value. "
                    },
                    {
                        "username": "souravedu87",
                        "content": "testcase 195 fails with this approach [1,2,2,2,null,2]"
                    },
                    {
                        "username": "carl-egge",
                        "content": "I was trying to implent this approach, but I had a problem with one testcase where I think the inorder is the same, but is it not mirrored:\\n[5,4,1,null,1,null,4,2,null,2,null]\\n\\nBoth sides lead to a inorder of [4,2,1] (if one is reversed)"
                    },
                    {
                        "username": "shikharscout",
                        "content": "This will not work for Test Case 95"
                    },
                    {
                        "username": "riteshroshan77",
                        "content": "same i was thinking but unable to convert my thought in code"
                    },
                    {
                        "username": "Heathro",
                        "content": "your commet was very handy. I tried to figure out how to deepsearch both sides to be able to compare, and here comes your \"reverse in-odred\" advise. thank you =)"
                    },
                    {
                        "username": "meow_power",
                        "content": "It\\'s a shame that even on solving this problem before I can\\'t think on how to solve this problem :("
                    },
                    {
                        "username": "mskamel",
                        "content": "Sorry to hear that you are frustrated man, it\\'s okay. Keep solving these questions and you will get better at them. A personal advice from me is to not read the solutions before you solve the problem, this will help you truly get better at LeetCode. I wish you all the best and keep grinding ;)"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Same. Even some hard problems here just a matter of time. Maybe day or more. \\n\\nThis one seems undoable for those who don\\'t know theory perfect. "
                    },
                    {
                        "username": "jclo123",
                        "content": ">The number of recursive calls is bound by the height of the tree. In the worst case, the tree is linear and the height is in O(n).\\n\\nHowever, if it is a linear tree, it will return false right at if (!left || !right).  I think the worst case should be a balanced tree where we need to make recursive call on each node."
                    },
                    {
                        "username": "njain07",
                        "content": "[1,2,2,5,null,null,5,6,null,null,6]\\n\\nAccording to my understanding, the levels of the tree should be:\\n[1]\\n[2,2]\\n[5,null,null,5]\\n[6,null,null,6] --> shouldn\\'t this have a length of 8 and not 4?\\n\\n*This testcode\\'s expected output is true.*"
                    },
                    {
                        "username": "dima0000000000",
                        "content": "Null elements cannot have their leaves, so the branch ends on it."
                    },
                    {
                        "username": "ben_huang",
                        "content": "step1. rotate(root->left)\\nstep2. equal(root->right,root->left)"
                    }
                ]
            },
            {
                "id": 1568924,
                "content": [
                    {
                        "username": "sharabiania",
                        "content": "Should change the title of the question to Mirror Tree. Symetric Tree can cause confusion."
                    },
                    {
                        "username": "heissanjay",
                        "content": "That\\'s correct, Symmetric doesn\\'t cover the mirror property "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Lol yeah that tripped me up for a few minutes for sure."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes bro symmetric also mean the same i think"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think this question difficulty is needed to be increased. Its difficulty should be medium."
                    },
                    {
                        "username": "AdamGold",
                        "content": "I disagree. This question is nearly identical to another easy problem, tree equality. Except instead of chcking p.left with q.left, you check p.left against r.right and vice versa"
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@stridemann](/stridemann) You\\'re not the standard of how people see this problem. Probably you are good in node theory. \\n\\nBut at each problem with TreeNode people leave comments with requests of increasing diifficulty. And i think they are right. This is very complicate even for people with 1 year programming experience like me."
                    },
                    {
                        "username": "stridemann",
                        "content": "Sorry, disagree.\nFor my level of solving problems medium takes up to 1-2 hour, hard can be more than a day, but this problem is around 10 min.\nIf s1 need a theory with code and good step-by-step visualization https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/BinaryTreeTraversal.html "
                    },
                    {
                        "username": "mandy1339",
                        "content": "The solution was not trivial. You have to know how to traverse to trees simultaneously in inverse order. I couldn\\'t think of any trivial solutions. Took me too long for an easy problem. What do you think?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its a tough problem for sure. I had to seek a hint to solve too but it made a lot of sense after realizing it "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "agree. Yesterdays hard on the daily coding challenges was easier then this lol"
                    },
                    {
                        "username": "djslim",
                        "content": "BFS works pretty well, just need to push null into queue to mark on which side nodes are, my javascript code:\\n\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "sairajd044",
                        "content": "I computed mirror of left subtree and checked if it is equal to right subtree,"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "I struggled on this one too"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Idk i just did post order on the left and right subtrees at the main root, but inverted the left subtree as i did the dfs. If the tree is \"symmetrical\" both post orders should be identical. Solutions may become trivial depending one how you\\'re looking at the principle parts of the problem"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried to solve it using BFS and splitting it into levels, then checking if each level was a palindrome. I feel that is a more intuitive solution than traversing both halves at the same time. I got it to work for 197 out of 199 of cases before giving up."
                    },
                    {
                        "username": "sahle123",
                        "content": "[@djslim](/djslim) You\\'re not supposed to post your code in the Discussions tab. There\\'s already a tab for finding people\\'s solution."
                    },
                    {
                        "username": "djslim",
                        "content": "yup, you can do bfs, \\nmy js code:\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "BrodyK",
                        "content": "I created a BFS solution if you wanted to compare it to yours\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3192072/breadth-search-solution-python/"
                    },
                    {
                        "username": "dark",
                        "content": "This problem involves two point:\\n\\n**symmetric:**\\n\\nconsider tree T:\\n\\nif T is null, then T is symmetric\\n\\nif T->left is mirror of T->right,then T is symmetric\\n\\n**mirror**\\n\\nconsider two tree T and R:\\n\\nif T=R=NULL, then T is mirror of R\\n\\nif T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror\\n\\notherwise the mirror relationship cannot estabished"
                    },
                    {
                        "username": "Neo57",
                        "content": "you forgot one part. The accurate statement is \"if T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror and T.val == R.Val\""
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "just move inorder in the leftsubtree and move reverse inorder in the rightsubtree simultaneously and check if they have the same value. "
                    },
                    {
                        "username": "souravedu87",
                        "content": "testcase 195 fails with this approach [1,2,2,2,null,2]"
                    },
                    {
                        "username": "carl-egge",
                        "content": "I was trying to implent this approach, but I had a problem with one testcase where I think the inorder is the same, but is it not mirrored:\\n[5,4,1,null,1,null,4,2,null,2,null]\\n\\nBoth sides lead to a inorder of [4,2,1] (if one is reversed)"
                    },
                    {
                        "username": "shikharscout",
                        "content": "This will not work for Test Case 95"
                    },
                    {
                        "username": "riteshroshan77",
                        "content": "same i was thinking but unable to convert my thought in code"
                    },
                    {
                        "username": "Heathro",
                        "content": "your commet was very handy. I tried to figure out how to deepsearch both sides to be able to compare, and here comes your \"reverse in-odred\" advise. thank you =)"
                    },
                    {
                        "username": "meow_power",
                        "content": "It\\'s a shame that even on solving this problem before I can\\'t think on how to solve this problem :("
                    },
                    {
                        "username": "mskamel",
                        "content": "Sorry to hear that you are frustrated man, it\\'s okay. Keep solving these questions and you will get better at them. A personal advice from me is to not read the solutions before you solve the problem, this will help you truly get better at LeetCode. I wish you all the best and keep grinding ;)"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Same. Even some hard problems here just a matter of time. Maybe day or more. \\n\\nThis one seems undoable for those who don\\'t know theory perfect. "
                    },
                    {
                        "username": "jclo123",
                        "content": ">The number of recursive calls is bound by the height of the tree. In the worst case, the tree is linear and the height is in O(n).\\n\\nHowever, if it is a linear tree, it will return false right at if (!left || !right).  I think the worst case should be a balanced tree where we need to make recursive call on each node."
                    },
                    {
                        "username": "njain07",
                        "content": "[1,2,2,5,null,null,5,6,null,null,6]\\n\\nAccording to my understanding, the levels of the tree should be:\\n[1]\\n[2,2]\\n[5,null,null,5]\\n[6,null,null,6] --> shouldn\\'t this have a length of 8 and not 4?\\n\\n*This testcode\\'s expected output is true.*"
                    },
                    {
                        "username": "dima0000000000",
                        "content": "Null elements cannot have their leaves, so the branch ends on it."
                    },
                    {
                        "username": "ben_huang",
                        "content": "step1. rotate(root->left)\\nstep2. equal(root->right,root->left)"
                    }
                ]
            },
            {
                "id": 1634875,
                "content": [
                    {
                        "username": "sharabiania",
                        "content": "Should change the title of the question to Mirror Tree. Symetric Tree can cause confusion."
                    },
                    {
                        "username": "heissanjay",
                        "content": "That\\'s correct, Symmetric doesn\\'t cover the mirror property "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Lol yeah that tripped me up for a few minutes for sure."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes bro symmetric also mean the same i think"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think this question difficulty is needed to be increased. Its difficulty should be medium."
                    },
                    {
                        "username": "AdamGold",
                        "content": "I disagree. This question is nearly identical to another easy problem, tree equality. Except instead of chcking p.left with q.left, you check p.left against r.right and vice versa"
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@stridemann](/stridemann) You\\'re not the standard of how people see this problem. Probably you are good in node theory. \\n\\nBut at each problem with TreeNode people leave comments with requests of increasing diifficulty. And i think they are right. This is very complicate even for people with 1 year programming experience like me."
                    },
                    {
                        "username": "stridemann",
                        "content": "Sorry, disagree.\nFor my level of solving problems medium takes up to 1-2 hour, hard can be more than a day, but this problem is around 10 min.\nIf s1 need a theory with code and good step-by-step visualization https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/BinaryTreeTraversal.html "
                    },
                    {
                        "username": "mandy1339",
                        "content": "The solution was not trivial. You have to know how to traverse to trees simultaneously in inverse order. I couldn\\'t think of any trivial solutions. Took me too long for an easy problem. What do you think?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its a tough problem for sure. I had to seek a hint to solve too but it made a lot of sense after realizing it "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "agree. Yesterdays hard on the daily coding challenges was easier then this lol"
                    },
                    {
                        "username": "djslim",
                        "content": "BFS works pretty well, just need to push null into queue to mark on which side nodes are, my javascript code:\\n\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "sairajd044",
                        "content": "I computed mirror of left subtree and checked if it is equal to right subtree,"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "I struggled on this one too"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Idk i just did post order on the left and right subtrees at the main root, but inverted the left subtree as i did the dfs. If the tree is \"symmetrical\" both post orders should be identical. Solutions may become trivial depending one how you\\'re looking at the principle parts of the problem"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried to solve it using BFS and splitting it into levels, then checking if each level was a palindrome. I feel that is a more intuitive solution than traversing both halves at the same time. I got it to work for 197 out of 199 of cases before giving up."
                    },
                    {
                        "username": "sahle123",
                        "content": "[@djslim](/djslim) You\\'re not supposed to post your code in the Discussions tab. There\\'s already a tab for finding people\\'s solution."
                    },
                    {
                        "username": "djslim",
                        "content": "yup, you can do bfs, \\nmy js code:\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "BrodyK",
                        "content": "I created a BFS solution if you wanted to compare it to yours\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3192072/breadth-search-solution-python/"
                    },
                    {
                        "username": "dark",
                        "content": "This problem involves two point:\\n\\n**symmetric:**\\n\\nconsider tree T:\\n\\nif T is null, then T is symmetric\\n\\nif T->left is mirror of T->right,then T is symmetric\\n\\n**mirror**\\n\\nconsider two tree T and R:\\n\\nif T=R=NULL, then T is mirror of R\\n\\nif T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror\\n\\notherwise the mirror relationship cannot estabished"
                    },
                    {
                        "username": "Neo57",
                        "content": "you forgot one part. The accurate statement is \"if T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror and T.val == R.Val\""
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "just move inorder in the leftsubtree and move reverse inorder in the rightsubtree simultaneously and check if they have the same value. "
                    },
                    {
                        "username": "souravedu87",
                        "content": "testcase 195 fails with this approach [1,2,2,2,null,2]"
                    },
                    {
                        "username": "carl-egge",
                        "content": "I was trying to implent this approach, but I had a problem with one testcase where I think the inorder is the same, but is it not mirrored:\\n[5,4,1,null,1,null,4,2,null,2,null]\\n\\nBoth sides lead to a inorder of [4,2,1] (if one is reversed)"
                    },
                    {
                        "username": "shikharscout",
                        "content": "This will not work for Test Case 95"
                    },
                    {
                        "username": "riteshroshan77",
                        "content": "same i was thinking but unable to convert my thought in code"
                    },
                    {
                        "username": "Heathro",
                        "content": "your commet was very handy. I tried to figure out how to deepsearch both sides to be able to compare, and here comes your \"reverse in-odred\" advise. thank you =)"
                    },
                    {
                        "username": "meow_power",
                        "content": "It\\'s a shame that even on solving this problem before I can\\'t think on how to solve this problem :("
                    },
                    {
                        "username": "mskamel",
                        "content": "Sorry to hear that you are frustrated man, it\\'s okay. Keep solving these questions and you will get better at them. A personal advice from me is to not read the solutions before you solve the problem, this will help you truly get better at LeetCode. I wish you all the best and keep grinding ;)"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Same. Even some hard problems here just a matter of time. Maybe day or more. \\n\\nThis one seems undoable for those who don\\'t know theory perfect. "
                    },
                    {
                        "username": "jclo123",
                        "content": ">The number of recursive calls is bound by the height of the tree. In the worst case, the tree is linear and the height is in O(n).\\n\\nHowever, if it is a linear tree, it will return false right at if (!left || !right).  I think the worst case should be a balanced tree where we need to make recursive call on each node."
                    },
                    {
                        "username": "njain07",
                        "content": "[1,2,2,5,null,null,5,6,null,null,6]\\n\\nAccording to my understanding, the levels of the tree should be:\\n[1]\\n[2,2]\\n[5,null,null,5]\\n[6,null,null,6] --> shouldn\\'t this have a length of 8 and not 4?\\n\\n*This testcode\\'s expected output is true.*"
                    },
                    {
                        "username": "dima0000000000",
                        "content": "Null elements cannot have their leaves, so the branch ends on it."
                    },
                    {
                        "username": "ben_huang",
                        "content": "step1. rotate(root->left)\\nstep2. equal(root->right,root->left)"
                    }
                ]
            },
            {
                "id": 1830814,
                "content": [
                    {
                        "username": "sharabiania",
                        "content": "Should change the title of the question to Mirror Tree. Symetric Tree can cause confusion."
                    },
                    {
                        "username": "heissanjay",
                        "content": "That\\'s correct, Symmetric doesn\\'t cover the mirror property "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Lol yeah that tripped me up for a few minutes for sure."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes bro symmetric also mean the same i think"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think this question difficulty is needed to be increased. Its difficulty should be medium."
                    },
                    {
                        "username": "AdamGold",
                        "content": "I disagree. This question is nearly identical to another easy problem, tree equality. Except instead of chcking p.left with q.left, you check p.left against r.right and vice versa"
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@stridemann](/stridemann) You\\'re not the standard of how people see this problem. Probably you are good in node theory. \\n\\nBut at each problem with TreeNode people leave comments with requests of increasing diifficulty. And i think they are right. This is very complicate even for people with 1 year programming experience like me."
                    },
                    {
                        "username": "stridemann",
                        "content": "Sorry, disagree.\nFor my level of solving problems medium takes up to 1-2 hour, hard can be more than a day, but this problem is around 10 min.\nIf s1 need a theory with code and good step-by-step visualization https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/BinaryTreeTraversal.html "
                    },
                    {
                        "username": "mandy1339",
                        "content": "The solution was not trivial. You have to know how to traverse to trees simultaneously in inverse order. I couldn\\'t think of any trivial solutions. Took me too long for an easy problem. What do you think?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its a tough problem for sure. I had to seek a hint to solve too but it made a lot of sense after realizing it "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "agree. Yesterdays hard on the daily coding challenges was easier then this lol"
                    },
                    {
                        "username": "djslim",
                        "content": "BFS works pretty well, just need to push null into queue to mark on which side nodes are, my javascript code:\\n\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "sairajd044",
                        "content": "I computed mirror of left subtree and checked if it is equal to right subtree,"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "I struggled on this one too"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Idk i just did post order on the left and right subtrees at the main root, but inverted the left subtree as i did the dfs. If the tree is \"symmetrical\" both post orders should be identical. Solutions may become trivial depending one how you\\'re looking at the principle parts of the problem"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried to solve it using BFS and splitting it into levels, then checking if each level was a palindrome. I feel that is a more intuitive solution than traversing both halves at the same time. I got it to work for 197 out of 199 of cases before giving up."
                    },
                    {
                        "username": "sahle123",
                        "content": "[@djslim](/djslim) You\\'re not supposed to post your code in the Discussions tab. There\\'s already a tab for finding people\\'s solution."
                    },
                    {
                        "username": "djslim",
                        "content": "yup, you can do bfs, \\nmy js code:\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "BrodyK",
                        "content": "I created a BFS solution if you wanted to compare it to yours\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3192072/breadth-search-solution-python/"
                    },
                    {
                        "username": "dark",
                        "content": "This problem involves two point:\\n\\n**symmetric:**\\n\\nconsider tree T:\\n\\nif T is null, then T is symmetric\\n\\nif T->left is mirror of T->right,then T is symmetric\\n\\n**mirror**\\n\\nconsider two tree T and R:\\n\\nif T=R=NULL, then T is mirror of R\\n\\nif T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror\\n\\notherwise the mirror relationship cannot estabished"
                    },
                    {
                        "username": "Neo57",
                        "content": "you forgot one part. The accurate statement is \"if T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror and T.val == R.Val\""
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "just move inorder in the leftsubtree and move reverse inorder in the rightsubtree simultaneously and check if they have the same value. "
                    },
                    {
                        "username": "souravedu87",
                        "content": "testcase 195 fails with this approach [1,2,2,2,null,2]"
                    },
                    {
                        "username": "carl-egge",
                        "content": "I was trying to implent this approach, but I had a problem with one testcase where I think the inorder is the same, but is it not mirrored:\\n[5,4,1,null,1,null,4,2,null,2,null]\\n\\nBoth sides lead to a inorder of [4,2,1] (if one is reversed)"
                    },
                    {
                        "username": "shikharscout",
                        "content": "This will not work for Test Case 95"
                    },
                    {
                        "username": "riteshroshan77",
                        "content": "same i was thinking but unable to convert my thought in code"
                    },
                    {
                        "username": "Heathro",
                        "content": "your commet was very handy. I tried to figure out how to deepsearch both sides to be able to compare, and here comes your \"reverse in-odred\" advise. thank you =)"
                    },
                    {
                        "username": "meow_power",
                        "content": "It\\'s a shame that even on solving this problem before I can\\'t think on how to solve this problem :("
                    },
                    {
                        "username": "mskamel",
                        "content": "Sorry to hear that you are frustrated man, it\\'s okay. Keep solving these questions and you will get better at them. A personal advice from me is to not read the solutions before you solve the problem, this will help you truly get better at LeetCode. I wish you all the best and keep grinding ;)"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Same. Even some hard problems here just a matter of time. Maybe day or more. \\n\\nThis one seems undoable for those who don\\'t know theory perfect. "
                    },
                    {
                        "username": "jclo123",
                        "content": ">The number of recursive calls is bound by the height of the tree. In the worst case, the tree is linear and the height is in O(n).\\n\\nHowever, if it is a linear tree, it will return false right at if (!left || !right).  I think the worst case should be a balanced tree where we need to make recursive call on each node."
                    },
                    {
                        "username": "njain07",
                        "content": "[1,2,2,5,null,null,5,6,null,null,6]\\n\\nAccording to my understanding, the levels of the tree should be:\\n[1]\\n[2,2]\\n[5,null,null,5]\\n[6,null,null,6] --> shouldn\\'t this have a length of 8 and not 4?\\n\\n*This testcode\\'s expected output is true.*"
                    },
                    {
                        "username": "dima0000000000",
                        "content": "Null elements cannot have their leaves, so the branch ends on it."
                    },
                    {
                        "username": "ben_huang",
                        "content": "step1. rotate(root->left)\\nstep2. equal(root->right,root->left)"
                    }
                ]
            },
            {
                "id": 1567526,
                "content": [
                    {
                        "username": "sharabiania",
                        "content": "Should change the title of the question to Mirror Tree. Symetric Tree can cause confusion."
                    },
                    {
                        "username": "heissanjay",
                        "content": "That\\'s correct, Symmetric doesn\\'t cover the mirror property "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Lol yeah that tripped me up for a few minutes for sure."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes bro symmetric also mean the same i think"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think this question difficulty is needed to be increased. Its difficulty should be medium."
                    },
                    {
                        "username": "AdamGold",
                        "content": "I disagree. This question is nearly identical to another easy problem, tree equality. Except instead of chcking p.left with q.left, you check p.left against r.right and vice versa"
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@stridemann](/stridemann) You\\'re not the standard of how people see this problem. Probably you are good in node theory. \\n\\nBut at each problem with TreeNode people leave comments with requests of increasing diifficulty. And i think they are right. This is very complicate even for people with 1 year programming experience like me."
                    },
                    {
                        "username": "stridemann",
                        "content": "Sorry, disagree.\nFor my level of solving problems medium takes up to 1-2 hour, hard can be more than a day, but this problem is around 10 min.\nIf s1 need a theory with code and good step-by-step visualization https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/BinaryTreeTraversal.html "
                    },
                    {
                        "username": "mandy1339",
                        "content": "The solution was not trivial. You have to know how to traverse to trees simultaneously in inverse order. I couldn\\'t think of any trivial solutions. Took me too long for an easy problem. What do you think?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its a tough problem for sure. I had to seek a hint to solve too but it made a lot of sense after realizing it "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "agree. Yesterdays hard on the daily coding challenges was easier then this lol"
                    },
                    {
                        "username": "djslim",
                        "content": "BFS works pretty well, just need to push null into queue to mark on which side nodes are, my javascript code:\\n\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "sairajd044",
                        "content": "I computed mirror of left subtree and checked if it is equal to right subtree,"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "I struggled on this one too"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Idk i just did post order on the left and right subtrees at the main root, but inverted the left subtree as i did the dfs. If the tree is \"symmetrical\" both post orders should be identical. Solutions may become trivial depending one how you\\'re looking at the principle parts of the problem"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried to solve it using BFS and splitting it into levels, then checking if each level was a palindrome. I feel that is a more intuitive solution than traversing both halves at the same time. I got it to work for 197 out of 199 of cases before giving up."
                    },
                    {
                        "username": "sahle123",
                        "content": "[@djslim](/djslim) You\\'re not supposed to post your code in the Discussions tab. There\\'s already a tab for finding people\\'s solution."
                    },
                    {
                        "username": "djslim",
                        "content": "yup, you can do bfs, \\nmy js code:\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "BrodyK",
                        "content": "I created a BFS solution if you wanted to compare it to yours\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3192072/breadth-search-solution-python/"
                    },
                    {
                        "username": "dark",
                        "content": "This problem involves two point:\\n\\n**symmetric:**\\n\\nconsider tree T:\\n\\nif T is null, then T is symmetric\\n\\nif T->left is mirror of T->right,then T is symmetric\\n\\n**mirror**\\n\\nconsider two tree T and R:\\n\\nif T=R=NULL, then T is mirror of R\\n\\nif T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror\\n\\notherwise the mirror relationship cannot estabished"
                    },
                    {
                        "username": "Neo57",
                        "content": "you forgot one part. The accurate statement is \"if T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror and T.val == R.Val\""
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "just move inorder in the leftsubtree and move reverse inorder in the rightsubtree simultaneously and check if they have the same value. "
                    },
                    {
                        "username": "souravedu87",
                        "content": "testcase 195 fails with this approach [1,2,2,2,null,2]"
                    },
                    {
                        "username": "carl-egge",
                        "content": "I was trying to implent this approach, but I had a problem with one testcase where I think the inorder is the same, but is it not mirrored:\\n[5,4,1,null,1,null,4,2,null,2,null]\\n\\nBoth sides lead to a inorder of [4,2,1] (if one is reversed)"
                    },
                    {
                        "username": "shikharscout",
                        "content": "This will not work for Test Case 95"
                    },
                    {
                        "username": "riteshroshan77",
                        "content": "same i was thinking but unable to convert my thought in code"
                    },
                    {
                        "username": "Heathro",
                        "content": "your commet was very handy. I tried to figure out how to deepsearch both sides to be able to compare, and here comes your \"reverse in-odred\" advise. thank you =)"
                    },
                    {
                        "username": "meow_power",
                        "content": "It\\'s a shame that even on solving this problem before I can\\'t think on how to solve this problem :("
                    },
                    {
                        "username": "mskamel",
                        "content": "Sorry to hear that you are frustrated man, it\\'s okay. Keep solving these questions and you will get better at them. A personal advice from me is to not read the solutions before you solve the problem, this will help you truly get better at LeetCode. I wish you all the best and keep grinding ;)"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Same. Even some hard problems here just a matter of time. Maybe day or more. \\n\\nThis one seems undoable for those who don\\'t know theory perfect. "
                    },
                    {
                        "username": "jclo123",
                        "content": ">The number of recursive calls is bound by the height of the tree. In the worst case, the tree is linear and the height is in O(n).\\n\\nHowever, if it is a linear tree, it will return false right at if (!left || !right).  I think the worst case should be a balanced tree where we need to make recursive call on each node."
                    },
                    {
                        "username": "njain07",
                        "content": "[1,2,2,5,null,null,5,6,null,null,6]\\n\\nAccording to my understanding, the levels of the tree should be:\\n[1]\\n[2,2]\\n[5,null,null,5]\\n[6,null,null,6] --> shouldn\\'t this have a length of 8 and not 4?\\n\\n*This testcode\\'s expected output is true.*"
                    },
                    {
                        "username": "dima0000000000",
                        "content": "Null elements cannot have their leaves, so the branch ends on it."
                    },
                    {
                        "username": "ben_huang",
                        "content": "step1. rotate(root->left)\\nstep2. equal(root->right,root->left)"
                    }
                ]
            },
            {
                "id": 1572756,
                "content": [
                    {
                        "username": "sharabiania",
                        "content": "Should change the title of the question to Mirror Tree. Symetric Tree can cause confusion."
                    },
                    {
                        "username": "heissanjay",
                        "content": "That\\'s correct, Symmetric doesn\\'t cover the mirror property "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Lol yeah that tripped me up for a few minutes for sure."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes bro symmetric also mean the same i think"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think this question difficulty is needed to be increased. Its difficulty should be medium."
                    },
                    {
                        "username": "AdamGold",
                        "content": "I disagree. This question is nearly identical to another easy problem, tree equality. Except instead of chcking p.left with q.left, you check p.left against r.right and vice versa"
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@stridemann](/stridemann) You\\'re not the standard of how people see this problem. Probably you are good in node theory. \\n\\nBut at each problem with TreeNode people leave comments with requests of increasing diifficulty. And i think they are right. This is very complicate even for people with 1 year programming experience like me."
                    },
                    {
                        "username": "stridemann",
                        "content": "Sorry, disagree.\nFor my level of solving problems medium takes up to 1-2 hour, hard can be more than a day, but this problem is around 10 min.\nIf s1 need a theory with code and good step-by-step visualization https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/BinaryTreeTraversal.html "
                    },
                    {
                        "username": "mandy1339",
                        "content": "The solution was not trivial. You have to know how to traverse to trees simultaneously in inverse order. I couldn\\'t think of any trivial solutions. Took me too long for an easy problem. What do you think?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its a tough problem for sure. I had to seek a hint to solve too but it made a lot of sense after realizing it "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "agree. Yesterdays hard on the daily coding challenges was easier then this lol"
                    },
                    {
                        "username": "djslim",
                        "content": "BFS works pretty well, just need to push null into queue to mark on which side nodes are, my javascript code:\\n\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "sairajd044",
                        "content": "I computed mirror of left subtree and checked if it is equal to right subtree,"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "I struggled on this one too"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Idk i just did post order on the left and right subtrees at the main root, but inverted the left subtree as i did the dfs. If the tree is \"symmetrical\" both post orders should be identical. Solutions may become trivial depending one how you\\'re looking at the principle parts of the problem"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried to solve it using BFS and splitting it into levels, then checking if each level was a palindrome. I feel that is a more intuitive solution than traversing both halves at the same time. I got it to work for 197 out of 199 of cases before giving up."
                    },
                    {
                        "username": "sahle123",
                        "content": "[@djslim](/djslim) You\\'re not supposed to post your code in the Discussions tab. There\\'s already a tab for finding people\\'s solution."
                    },
                    {
                        "username": "djslim",
                        "content": "yup, you can do bfs, \\nmy js code:\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "BrodyK",
                        "content": "I created a BFS solution if you wanted to compare it to yours\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3192072/breadth-search-solution-python/"
                    },
                    {
                        "username": "dark",
                        "content": "This problem involves two point:\\n\\n**symmetric:**\\n\\nconsider tree T:\\n\\nif T is null, then T is symmetric\\n\\nif T->left is mirror of T->right,then T is symmetric\\n\\n**mirror**\\n\\nconsider two tree T and R:\\n\\nif T=R=NULL, then T is mirror of R\\n\\nif T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror\\n\\notherwise the mirror relationship cannot estabished"
                    },
                    {
                        "username": "Neo57",
                        "content": "you forgot one part. The accurate statement is \"if T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror and T.val == R.Val\""
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "just move inorder in the leftsubtree and move reverse inorder in the rightsubtree simultaneously and check if they have the same value. "
                    },
                    {
                        "username": "souravedu87",
                        "content": "testcase 195 fails with this approach [1,2,2,2,null,2]"
                    },
                    {
                        "username": "carl-egge",
                        "content": "I was trying to implent this approach, but I had a problem with one testcase where I think the inorder is the same, but is it not mirrored:\\n[5,4,1,null,1,null,4,2,null,2,null]\\n\\nBoth sides lead to a inorder of [4,2,1] (if one is reversed)"
                    },
                    {
                        "username": "shikharscout",
                        "content": "This will not work for Test Case 95"
                    },
                    {
                        "username": "riteshroshan77",
                        "content": "same i was thinking but unable to convert my thought in code"
                    },
                    {
                        "username": "Heathro",
                        "content": "your commet was very handy. I tried to figure out how to deepsearch both sides to be able to compare, and here comes your \"reverse in-odred\" advise. thank you =)"
                    },
                    {
                        "username": "meow_power",
                        "content": "It\\'s a shame that even on solving this problem before I can\\'t think on how to solve this problem :("
                    },
                    {
                        "username": "mskamel",
                        "content": "Sorry to hear that you are frustrated man, it\\'s okay. Keep solving these questions and you will get better at them. A personal advice from me is to not read the solutions before you solve the problem, this will help you truly get better at LeetCode. I wish you all the best and keep grinding ;)"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Same. Even some hard problems here just a matter of time. Maybe day or more. \\n\\nThis one seems undoable for those who don\\'t know theory perfect. "
                    },
                    {
                        "username": "jclo123",
                        "content": ">The number of recursive calls is bound by the height of the tree. In the worst case, the tree is linear and the height is in O(n).\\n\\nHowever, if it is a linear tree, it will return false right at if (!left || !right).  I think the worst case should be a balanced tree where we need to make recursive call on each node."
                    },
                    {
                        "username": "njain07",
                        "content": "[1,2,2,5,null,null,5,6,null,null,6]\\n\\nAccording to my understanding, the levels of the tree should be:\\n[1]\\n[2,2]\\n[5,null,null,5]\\n[6,null,null,6] --> shouldn\\'t this have a length of 8 and not 4?\\n\\n*This testcode\\'s expected output is true.*"
                    },
                    {
                        "username": "dima0000000000",
                        "content": "Null elements cannot have their leaves, so the branch ends on it."
                    },
                    {
                        "username": "ben_huang",
                        "content": "step1. rotate(root->left)\\nstep2. equal(root->right,root->left)"
                    }
                ]
            },
            {
                "id": 1572521,
                "content": [
                    {
                        "username": "sharabiania",
                        "content": "Should change the title of the question to Mirror Tree. Symetric Tree can cause confusion."
                    },
                    {
                        "username": "heissanjay",
                        "content": "That\\'s correct, Symmetric doesn\\'t cover the mirror property "
                    },
                    {
                        "username": "johnnyboy1981",
                        "content": "Lol yeah that tripped me up for a few minutes for sure."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes bro symmetric also mean the same i think"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "I think this question difficulty is needed to be increased. Its difficulty should be medium."
                    },
                    {
                        "username": "AdamGold",
                        "content": "I disagree. This question is nearly identical to another easy problem, tree equality. Except instead of chcking p.left with q.left, you check p.left against r.right and vice versa"
                    },
                    {
                        "username": "Vectorido",
                        "content": "[@stridemann](/stridemann) You\\'re not the standard of how people see this problem. Probably you are good in node theory. \\n\\nBut at each problem with TreeNode people leave comments with requests of increasing diifficulty. And i think they are right. This is very complicate even for people with 1 year programming experience like me."
                    },
                    {
                        "username": "stridemann",
                        "content": "Sorry, disagree.\nFor my level of solving problems medium takes up to 1-2 hour, hard can be more than a day, but this problem is around 10 min.\nIf s1 need a theory with code and good step-by-step visualization https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/BinaryTreeTraversal.html "
                    },
                    {
                        "username": "mandy1339",
                        "content": "The solution was not trivial. You have to know how to traverse to trees simultaneously in inverse order. I couldn\\'t think of any trivial solutions. Took me too long for an easy problem. What do you think?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its a tough problem for sure. I had to seek a hint to solve too but it made a lot of sense after realizing it "
                    },
                    {
                        "username": "cwooldridge",
                        "content": "agree. Yesterdays hard on the daily coding challenges was easier then this lol"
                    },
                    {
                        "username": "djslim",
                        "content": "BFS works pretty well, just need to push null into queue to mark on which side nodes are, my javascript code:\\n\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "sairajd044",
                        "content": "I computed mirror of left subtree and checked if it is equal to right subtree,"
                    },
                    {
                        "username": "OlfactoryReflex",
                        "content": "I struggled on this one too"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "Idk i just did post order on the left and right subtrees at the main root, but inverted the left subtree as i did the dfs. If the tree is \"symmetrical\" both post orders should be identical. Solutions may become trivial depending one how you\\'re looking at the principle parts of the problem"
                    },
                    {
                        "username": "Paco98",
                        "content": "I tried to solve it using BFS and splitting it into levels, then checking if each level was a palindrome. I feel that is a more intuitive solution than traversing both halves at the same time. I got it to work for 197 out of 199 of cases before giving up."
                    },
                    {
                        "username": "sahle123",
                        "content": "[@djslim](/djslim) You\\'re not supposed to post your code in the Discussions tab. There\\'s already a tab for finding people\\'s solution."
                    },
                    {
                        "username": "djslim",
                        "content": "yup, you can do bfs, \\nmy js code:\\n`\\nvar isSymmetric = function(root) {\\n    const queue = [root]\\n\\n    while(queue.length) {\\n        const len = queue.length\\n\\n        let left = 0\\n        let right = queue.length -1\\n\\n        while(left < right) {\\n            if(queue[left] === null && queue[right] === null) {\\n                left++\\n                right--\\n                continue\\n            }\\n            if(queue[left] === null || queue[right] === null) {\\n                return false\\n            }\\n\\n            if(queue[left].val !== queue[right].val) return  false\\n            left++\\n            right--\\n        }\\n\\n        for(let i = 0; i < len; i++) {\\n            const curr = queue.shift()\\n            if(curr===null) continue\\n            \\n            if(curr.left) {\\n                queue.push(curr.left)\\n            } else {\\n                queue.push(null)\\n            }\\n            if(curr.right) {\\n                queue.push(curr.right)\\n            } else {\\n                queue.push(null)\\n            }\\n        }\\n    }\\n\\n    return true\\n};\\n`"
                    },
                    {
                        "username": "BrodyK",
                        "content": "I created a BFS solution if you wanted to compare it to yours\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3192072/breadth-search-solution-python/"
                    },
                    {
                        "username": "dark",
                        "content": "This problem involves two point:\\n\\n**symmetric:**\\n\\nconsider tree T:\\n\\nif T is null, then T is symmetric\\n\\nif T->left is mirror of T->right,then T is symmetric\\n\\n**mirror**\\n\\nconsider two tree T and R:\\n\\nif T=R=NULL, then T is mirror of R\\n\\nif T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror\\n\\notherwise the mirror relationship cannot estabished"
                    },
                    {
                        "username": "Neo57",
                        "content": "you forgot one part. The accurate statement is \"if T and R both not NULL,and T->left is mirror of R->right,and T->right is mirror of R->left,then T and R is mirror and T.val == R.Val\""
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "just move inorder in the leftsubtree and move reverse inorder in the rightsubtree simultaneously and check if they have the same value. "
                    },
                    {
                        "username": "souravedu87",
                        "content": "testcase 195 fails with this approach [1,2,2,2,null,2]"
                    },
                    {
                        "username": "carl-egge",
                        "content": "I was trying to implent this approach, but I had a problem with one testcase where I think the inorder is the same, but is it not mirrored:\\n[5,4,1,null,1,null,4,2,null,2,null]\\n\\nBoth sides lead to a inorder of [4,2,1] (if one is reversed)"
                    },
                    {
                        "username": "shikharscout",
                        "content": "This will not work for Test Case 95"
                    },
                    {
                        "username": "riteshroshan77",
                        "content": "same i was thinking but unable to convert my thought in code"
                    },
                    {
                        "username": "Heathro",
                        "content": "your commet was very handy. I tried to figure out how to deepsearch both sides to be able to compare, and here comes your \"reverse in-odred\" advise. thank you =)"
                    },
                    {
                        "username": "meow_power",
                        "content": "It\\'s a shame that even on solving this problem before I can\\'t think on how to solve this problem :("
                    },
                    {
                        "username": "mskamel",
                        "content": "Sorry to hear that you are frustrated man, it\\'s okay. Keep solving these questions and you will get better at them. A personal advice from me is to not read the solutions before you solve the problem, this will help you truly get better at LeetCode. I wish you all the best and keep grinding ;)"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Same. Even some hard problems here just a matter of time. Maybe day or more. \\n\\nThis one seems undoable for those who don\\'t know theory perfect. "
                    },
                    {
                        "username": "jclo123",
                        "content": ">The number of recursive calls is bound by the height of the tree. In the worst case, the tree is linear and the height is in O(n).\\n\\nHowever, if it is a linear tree, it will return false right at if (!left || !right).  I think the worst case should be a balanced tree where we need to make recursive call on each node."
                    },
                    {
                        "username": "njain07",
                        "content": "[1,2,2,5,null,null,5,6,null,null,6]\\n\\nAccording to my understanding, the levels of the tree should be:\\n[1]\\n[2,2]\\n[5,null,null,5]\\n[6,null,null,6] --> shouldn\\'t this have a length of 8 and not 4?\\n\\n*This testcode\\'s expected output is true.*"
                    },
                    {
                        "username": "dima0000000000",
                        "content": "Null elements cannot have their leaves, so the branch ends on it."
                    },
                    {
                        "username": "ben_huang",
                        "content": "step1. rotate(root->left)\\nstep2. equal(root->right,root->left)"
                    }
                ]
            },
            {
                "id": 1830796,
                "content": [
                    {
                        "username": "divyamahankali29",
                        "content": "not really an easy problem. "
                    },
                    {
                        "username": "dengsitao",
                        "content": "I have submit same code twice, and the first time runtime is 4ms, and second time the runtime is 8ms.\\nand the memory usage changed from 16.3MB to 16.2MB.\\nDoes anybody know why?\\nMaybe it is because test set is not the same for every submit?"
                    },
                    {
                        "username": "Digger_",
                        "content": "It\\'s the same with me, I think it depends on the speed of the network and the power of the computer."
                    },
                    {
                        "username": "etekerl1",
                        "content": "I am getting this error when trying to compile my solution. Does anyone have any idea what this is? \\n\\nCannot implicitly convert type \\'TreeNode [/leetcode/user_code/interpret_1540783121.1122456_Xuw0WDwifV/precompiled/TreeNode.dll]\\' to \\'TreeNode [/leetcode/user_code/interpret_1540783121.1122456_Xuw0WDwifV/Solution.cs(11)]\\'\\n"
                    },
                    {
                        "username": "xiaoxiao3",
                        "content": "To me, this one is not quite easy. I couldn\\'t figure out the solution (iterator 2 nodes) without seeing the answer :( "
                    },
                    {
                        "username": "bumate90",
                        "content": "Huh, that wasn\\'t so easy. \\nPro tip: don\\'t try to separately traverse the two subtrees rather build\\na simple, intuitive, recursive solution looking at the example."
                    },
                    {
                        "username": "KratosOfSparta",
                        "content": "![image](https://assets.leetcode.com/users/tadichetty/image_1544642400.png)\\n\\nThis is weird, how do I solve this?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "i am giving up, i spend 30 min and passed only 1 test cases \\uD83D\\uDE23"
                    },
                    {
                        "username": "startupveteran",
                        "content": "In example #2, we are given [1,2,2,null,3,null,3]\n\nMy recursion code is shooting out an end result of [[1], [2, 2], [3, 3]]\n\nHow do I make it look like `[[1], [2, 2], [null, 3, null, 3]]`?"
                    },
                    {
                        "username": "startupveteran",
                        "content": "[@aakashsrh](/aakashsrh) I never got that to work out the way I envisioned it, but I solved the problem using a different method"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I have the exactly same question iteratively, [@startupveteran](/startupveteran) I wanted my 2nd example\\'s resultant to look like [[1], [2,2] ,[0,3,0,3] as left nodes are not present. Or if not [[1], [2,2] ,[0,3,0,3] then [[1], [2, 2], [null, 3, null, 3]]. Were you able to proceed ?"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "Can anyone help me I am unable to solve tree questions basically I understand the solution but unable to think on my own  what should I do\\n\\nNeed advice\\nWould it be fine if I follow some playlist and solve those questions first hoping that will give me idea of how to approach would that help because I am unable to think of solutions on my own or shouLD i solve questions on my own ..thanks "
                    },
                    {
                        "username": "Srishti_gugoriya",
                        "content": "I am facing the same problem. Can you suggest me what you did then ?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "the input is not an Array,, it is {\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":{\"val\":4,\"left\":null,\"right\":null}},\"right\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null},\"right\":{\"val\":3,\"left\":null,\"right\":null}}}"
                    }
                ]
            },
            {
                "id": 1573878,
                "content": [
                    {
                        "username": "divyamahankali29",
                        "content": "not really an easy problem. "
                    },
                    {
                        "username": "dengsitao",
                        "content": "I have submit same code twice, and the first time runtime is 4ms, and second time the runtime is 8ms.\\nand the memory usage changed from 16.3MB to 16.2MB.\\nDoes anybody know why?\\nMaybe it is because test set is not the same for every submit?"
                    },
                    {
                        "username": "Digger_",
                        "content": "It\\'s the same with me, I think it depends on the speed of the network and the power of the computer."
                    },
                    {
                        "username": "etekerl1",
                        "content": "I am getting this error when trying to compile my solution. Does anyone have any idea what this is? \\n\\nCannot implicitly convert type \\'TreeNode [/leetcode/user_code/interpret_1540783121.1122456_Xuw0WDwifV/precompiled/TreeNode.dll]\\' to \\'TreeNode [/leetcode/user_code/interpret_1540783121.1122456_Xuw0WDwifV/Solution.cs(11)]\\'\\n"
                    },
                    {
                        "username": "xiaoxiao3",
                        "content": "To me, this one is not quite easy. I couldn\\'t figure out the solution (iterator 2 nodes) without seeing the answer :( "
                    },
                    {
                        "username": "bumate90",
                        "content": "Huh, that wasn\\'t so easy. \\nPro tip: don\\'t try to separately traverse the two subtrees rather build\\na simple, intuitive, recursive solution looking at the example."
                    },
                    {
                        "username": "KratosOfSparta",
                        "content": "![image](https://assets.leetcode.com/users/tadichetty/image_1544642400.png)\\n\\nThis is weird, how do I solve this?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "i am giving up, i spend 30 min and passed only 1 test cases \\uD83D\\uDE23"
                    },
                    {
                        "username": "startupveteran",
                        "content": "In example #2, we are given [1,2,2,null,3,null,3]\n\nMy recursion code is shooting out an end result of [[1], [2, 2], [3, 3]]\n\nHow do I make it look like `[[1], [2, 2], [null, 3, null, 3]]`?"
                    },
                    {
                        "username": "startupveteran",
                        "content": "[@aakashsrh](/aakashsrh) I never got that to work out the way I envisioned it, but I solved the problem using a different method"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I have the exactly same question iteratively, [@startupveteran](/startupveteran) I wanted my 2nd example\\'s resultant to look like [[1], [2,2] ,[0,3,0,3] as left nodes are not present. Or if not [[1], [2,2] ,[0,3,0,3] then [[1], [2, 2], [null, 3, null, 3]]. Were you able to proceed ?"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "Can anyone help me I am unable to solve tree questions basically I understand the solution but unable to think on my own  what should I do\\n\\nNeed advice\\nWould it be fine if I follow some playlist and solve those questions first hoping that will give me idea of how to approach would that help because I am unable to think of solutions on my own or shouLD i solve questions on my own ..thanks "
                    },
                    {
                        "username": "Srishti_gugoriya",
                        "content": "I am facing the same problem. Can you suggest me what you did then ?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "the input is not an Array,, it is {\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":{\"val\":4,\"left\":null,\"right\":null}},\"right\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null},\"right\":{\"val\":3,\"left\":null,\"right\":null}}}"
                    }
                ]
            },
            {
                "id": 1569330,
                "content": [
                    {
                        "username": "divyamahankali29",
                        "content": "not really an easy problem. "
                    },
                    {
                        "username": "dengsitao",
                        "content": "I have submit same code twice, and the first time runtime is 4ms, and second time the runtime is 8ms.\\nand the memory usage changed from 16.3MB to 16.2MB.\\nDoes anybody know why?\\nMaybe it is because test set is not the same for every submit?"
                    },
                    {
                        "username": "Digger_",
                        "content": "It\\'s the same with me, I think it depends on the speed of the network and the power of the computer."
                    },
                    {
                        "username": "etekerl1",
                        "content": "I am getting this error when trying to compile my solution. Does anyone have any idea what this is? \\n\\nCannot implicitly convert type \\'TreeNode [/leetcode/user_code/interpret_1540783121.1122456_Xuw0WDwifV/precompiled/TreeNode.dll]\\' to \\'TreeNode [/leetcode/user_code/interpret_1540783121.1122456_Xuw0WDwifV/Solution.cs(11)]\\'\\n"
                    },
                    {
                        "username": "xiaoxiao3",
                        "content": "To me, this one is not quite easy. I couldn\\'t figure out the solution (iterator 2 nodes) without seeing the answer :( "
                    },
                    {
                        "username": "bumate90",
                        "content": "Huh, that wasn\\'t so easy. \\nPro tip: don\\'t try to separately traverse the two subtrees rather build\\na simple, intuitive, recursive solution looking at the example."
                    },
                    {
                        "username": "KratosOfSparta",
                        "content": "![image](https://assets.leetcode.com/users/tadichetty/image_1544642400.png)\\n\\nThis is weird, how do I solve this?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "i am giving up, i spend 30 min and passed only 1 test cases \\uD83D\\uDE23"
                    },
                    {
                        "username": "startupveteran",
                        "content": "In example #2, we are given [1,2,2,null,3,null,3]\n\nMy recursion code is shooting out an end result of [[1], [2, 2], [3, 3]]\n\nHow do I make it look like `[[1], [2, 2], [null, 3, null, 3]]`?"
                    },
                    {
                        "username": "startupveteran",
                        "content": "[@aakashsrh](/aakashsrh) I never got that to work out the way I envisioned it, but I solved the problem using a different method"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I have the exactly same question iteratively, [@startupveteran](/startupveteran) I wanted my 2nd example\\'s resultant to look like [[1], [2,2] ,[0,3,0,3] as left nodes are not present. Or if not [[1], [2,2] ,[0,3,0,3] then [[1], [2, 2], [null, 3, null, 3]]. Were you able to proceed ?"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "Can anyone help me I am unable to solve tree questions basically I understand the solution but unable to think on my own  what should I do\\n\\nNeed advice\\nWould it be fine if I follow some playlist and solve those questions first hoping that will give me idea of how to approach would that help because I am unable to think of solutions on my own or shouLD i solve questions on my own ..thanks "
                    },
                    {
                        "username": "Srishti_gugoriya",
                        "content": "I am facing the same problem. Can you suggest me what you did then ?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "the input is not an Array,, it is {\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":{\"val\":4,\"left\":null,\"right\":null}},\"right\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null},\"right\":{\"val\":3,\"left\":null,\"right\":null}}}"
                    }
                ]
            },
            {
                "id": 1819220,
                "content": [
                    {
                        "username": "divyamahankali29",
                        "content": "not really an easy problem. "
                    },
                    {
                        "username": "dengsitao",
                        "content": "I have submit same code twice, and the first time runtime is 4ms, and second time the runtime is 8ms.\\nand the memory usage changed from 16.3MB to 16.2MB.\\nDoes anybody know why?\\nMaybe it is because test set is not the same for every submit?"
                    },
                    {
                        "username": "Digger_",
                        "content": "It\\'s the same with me, I think it depends on the speed of the network and the power of the computer."
                    },
                    {
                        "username": "etekerl1",
                        "content": "I am getting this error when trying to compile my solution. Does anyone have any idea what this is? \\n\\nCannot implicitly convert type \\'TreeNode [/leetcode/user_code/interpret_1540783121.1122456_Xuw0WDwifV/precompiled/TreeNode.dll]\\' to \\'TreeNode [/leetcode/user_code/interpret_1540783121.1122456_Xuw0WDwifV/Solution.cs(11)]\\'\\n"
                    },
                    {
                        "username": "xiaoxiao3",
                        "content": "To me, this one is not quite easy. I couldn\\'t figure out the solution (iterator 2 nodes) without seeing the answer :( "
                    },
                    {
                        "username": "bumate90",
                        "content": "Huh, that wasn\\'t so easy. \\nPro tip: don\\'t try to separately traverse the two subtrees rather build\\na simple, intuitive, recursive solution looking at the example."
                    },
                    {
                        "username": "KratosOfSparta",
                        "content": "![image](https://assets.leetcode.com/users/tadichetty/image_1544642400.png)\\n\\nThis is weird, how do I solve this?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "i am giving up, i spend 30 min and passed only 1 test cases \\uD83D\\uDE23"
                    },
                    {
                        "username": "startupveteran",
                        "content": "In example #2, we are given [1,2,2,null,3,null,3]\n\nMy recursion code is shooting out an end result of [[1], [2, 2], [3, 3]]\n\nHow do I make it look like `[[1], [2, 2], [null, 3, null, 3]]`?"
                    },
                    {
                        "username": "startupveteran",
                        "content": "[@aakashsrh](/aakashsrh) I never got that to work out the way I envisioned it, but I solved the problem using a different method"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I have the exactly same question iteratively, [@startupveteran](/startupveteran) I wanted my 2nd example\\'s resultant to look like [[1], [2,2] ,[0,3,0,3] as left nodes are not present. Or if not [[1], [2,2] ,[0,3,0,3] then [[1], [2, 2], [null, 3, null, 3]]. Were you able to proceed ?"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "Can anyone help me I am unable to solve tree questions basically I understand the solution but unable to think on my own  what should I do\\n\\nNeed advice\\nWould it be fine if I follow some playlist and solve those questions first hoping that will give me idea of how to approach would that help because I am unable to think of solutions on my own or shouLD i solve questions on my own ..thanks "
                    },
                    {
                        "username": "Srishti_gugoriya",
                        "content": "I am facing the same problem. Can you suggest me what you did then ?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "the input is not an Array,, it is {\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":{\"val\":4,\"left\":null,\"right\":null}},\"right\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null},\"right\":{\"val\":3,\"left\":null,\"right\":null}}}"
                    }
                ]
            },
            {
                "id": 1741784,
                "content": [
                    {
                        "username": "divyamahankali29",
                        "content": "not really an easy problem. "
                    },
                    {
                        "username": "dengsitao",
                        "content": "I have submit same code twice, and the first time runtime is 4ms, and second time the runtime is 8ms.\\nand the memory usage changed from 16.3MB to 16.2MB.\\nDoes anybody know why?\\nMaybe it is because test set is not the same for every submit?"
                    },
                    {
                        "username": "Digger_",
                        "content": "It\\'s the same with me, I think it depends on the speed of the network and the power of the computer."
                    },
                    {
                        "username": "etekerl1",
                        "content": "I am getting this error when trying to compile my solution. Does anyone have any idea what this is? \\n\\nCannot implicitly convert type \\'TreeNode [/leetcode/user_code/interpret_1540783121.1122456_Xuw0WDwifV/precompiled/TreeNode.dll]\\' to \\'TreeNode [/leetcode/user_code/interpret_1540783121.1122456_Xuw0WDwifV/Solution.cs(11)]\\'\\n"
                    },
                    {
                        "username": "xiaoxiao3",
                        "content": "To me, this one is not quite easy. I couldn\\'t figure out the solution (iterator 2 nodes) without seeing the answer :( "
                    },
                    {
                        "username": "bumate90",
                        "content": "Huh, that wasn\\'t so easy. \\nPro tip: don\\'t try to separately traverse the two subtrees rather build\\na simple, intuitive, recursive solution looking at the example."
                    },
                    {
                        "username": "KratosOfSparta",
                        "content": "![image](https://assets.leetcode.com/users/tadichetty/image_1544642400.png)\\n\\nThis is weird, how do I solve this?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "i am giving up, i spend 30 min and passed only 1 test cases \\uD83D\\uDE23"
                    },
                    {
                        "username": "startupveteran",
                        "content": "In example #2, we are given [1,2,2,null,3,null,3]\n\nMy recursion code is shooting out an end result of [[1], [2, 2], [3, 3]]\n\nHow do I make it look like `[[1], [2, 2], [null, 3, null, 3]]`?"
                    },
                    {
                        "username": "startupveteran",
                        "content": "[@aakashsrh](/aakashsrh) I never got that to work out the way I envisioned it, but I solved the problem using a different method"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I have the exactly same question iteratively, [@startupveteran](/startupveteran) I wanted my 2nd example\\'s resultant to look like [[1], [2,2] ,[0,3,0,3] as left nodes are not present. Or if not [[1], [2,2] ,[0,3,0,3] then [[1], [2, 2], [null, 3, null, 3]]. Were you able to proceed ?"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "Can anyone help me I am unable to solve tree questions basically I understand the solution but unable to think on my own  what should I do\\n\\nNeed advice\\nWould it be fine if I follow some playlist and solve those questions first hoping that will give me idea of how to approach would that help because I am unable to think of solutions on my own or shouLD i solve questions on my own ..thanks "
                    },
                    {
                        "username": "Srishti_gugoriya",
                        "content": "I am facing the same problem. Can you suggest me what you did then ?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "the input is not an Array,, it is {\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":{\"val\":4,\"left\":null,\"right\":null}},\"right\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null},\"right\":{\"val\":3,\"left\":null,\"right\":null}}}"
                    }
                ]
            },
            {
                "id": 1572325,
                "content": [
                    {
                        "username": "divyamahankali29",
                        "content": "not really an easy problem. "
                    },
                    {
                        "username": "dengsitao",
                        "content": "I have submit same code twice, and the first time runtime is 4ms, and second time the runtime is 8ms.\\nand the memory usage changed from 16.3MB to 16.2MB.\\nDoes anybody know why?\\nMaybe it is because test set is not the same for every submit?"
                    },
                    {
                        "username": "Digger_",
                        "content": "It\\'s the same with me, I think it depends on the speed of the network and the power of the computer."
                    },
                    {
                        "username": "etekerl1",
                        "content": "I am getting this error when trying to compile my solution. Does anyone have any idea what this is? \\n\\nCannot implicitly convert type \\'TreeNode [/leetcode/user_code/interpret_1540783121.1122456_Xuw0WDwifV/precompiled/TreeNode.dll]\\' to \\'TreeNode [/leetcode/user_code/interpret_1540783121.1122456_Xuw0WDwifV/Solution.cs(11)]\\'\\n"
                    },
                    {
                        "username": "xiaoxiao3",
                        "content": "To me, this one is not quite easy. I couldn\\'t figure out the solution (iterator 2 nodes) without seeing the answer :( "
                    },
                    {
                        "username": "bumate90",
                        "content": "Huh, that wasn\\'t so easy. \\nPro tip: don\\'t try to separately traverse the two subtrees rather build\\na simple, intuitive, recursive solution looking at the example."
                    },
                    {
                        "username": "KratosOfSparta",
                        "content": "![image](https://assets.leetcode.com/users/tadichetty/image_1544642400.png)\\n\\nThis is weird, how do I solve this?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "i am giving up, i spend 30 min and passed only 1 test cases \\uD83D\\uDE23"
                    },
                    {
                        "username": "startupveteran",
                        "content": "In example #2, we are given [1,2,2,null,3,null,3]\n\nMy recursion code is shooting out an end result of [[1], [2, 2], [3, 3]]\n\nHow do I make it look like `[[1], [2, 2], [null, 3, null, 3]]`?"
                    },
                    {
                        "username": "startupveteran",
                        "content": "[@aakashsrh](/aakashsrh) I never got that to work out the way I envisioned it, but I solved the problem using a different method"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I have the exactly same question iteratively, [@startupveteran](/startupveteran) I wanted my 2nd example\\'s resultant to look like [[1], [2,2] ,[0,3,0,3] as left nodes are not present. Or if not [[1], [2,2] ,[0,3,0,3] then [[1], [2, 2], [null, 3, null, 3]]. Were you able to proceed ?"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "Can anyone help me I am unable to solve tree questions basically I understand the solution but unable to think on my own  what should I do\\n\\nNeed advice\\nWould it be fine if I follow some playlist and solve those questions first hoping that will give me idea of how to approach would that help because I am unable to think of solutions on my own or shouLD i solve questions on my own ..thanks "
                    },
                    {
                        "username": "Srishti_gugoriya",
                        "content": "I am facing the same problem. Can you suggest me what you did then ?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "the input is not an Array,, it is {\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":{\"val\":4,\"left\":null,\"right\":null}},\"right\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null},\"right\":{\"val\":3,\"left\":null,\"right\":null}}}"
                    }
                ]
            },
            {
                "id": 2047496,
                "content": [
                    {
                        "username": "divyamahankali29",
                        "content": "not really an easy problem. "
                    },
                    {
                        "username": "dengsitao",
                        "content": "I have submit same code twice, and the first time runtime is 4ms, and second time the runtime is 8ms.\\nand the memory usage changed from 16.3MB to 16.2MB.\\nDoes anybody know why?\\nMaybe it is because test set is not the same for every submit?"
                    },
                    {
                        "username": "Digger_",
                        "content": "It\\'s the same with me, I think it depends on the speed of the network and the power of the computer."
                    },
                    {
                        "username": "etekerl1",
                        "content": "I am getting this error when trying to compile my solution. Does anyone have any idea what this is? \\n\\nCannot implicitly convert type \\'TreeNode [/leetcode/user_code/interpret_1540783121.1122456_Xuw0WDwifV/precompiled/TreeNode.dll]\\' to \\'TreeNode [/leetcode/user_code/interpret_1540783121.1122456_Xuw0WDwifV/Solution.cs(11)]\\'\\n"
                    },
                    {
                        "username": "xiaoxiao3",
                        "content": "To me, this one is not quite easy. I couldn\\'t figure out the solution (iterator 2 nodes) without seeing the answer :( "
                    },
                    {
                        "username": "bumate90",
                        "content": "Huh, that wasn\\'t so easy. \\nPro tip: don\\'t try to separately traverse the two subtrees rather build\\na simple, intuitive, recursive solution looking at the example."
                    },
                    {
                        "username": "KratosOfSparta",
                        "content": "![image](https://assets.leetcode.com/users/tadichetty/image_1544642400.png)\\n\\nThis is weird, how do I solve this?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "i am giving up, i spend 30 min and passed only 1 test cases \\uD83D\\uDE23"
                    },
                    {
                        "username": "startupveteran",
                        "content": "In example #2, we are given [1,2,2,null,3,null,3]\n\nMy recursion code is shooting out an end result of [[1], [2, 2], [3, 3]]\n\nHow do I make it look like `[[1], [2, 2], [null, 3, null, 3]]`?"
                    },
                    {
                        "username": "startupveteran",
                        "content": "[@aakashsrh](/aakashsrh) I never got that to work out the way I envisioned it, but I solved the problem using a different method"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I have the exactly same question iteratively, [@startupveteran](/startupveteran) I wanted my 2nd example\\'s resultant to look like [[1], [2,2] ,[0,3,0,3] as left nodes are not present. Or if not [[1], [2,2] ,[0,3,0,3] then [[1], [2, 2], [null, 3, null, 3]]. Were you able to proceed ?"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "Can anyone help me I am unable to solve tree questions basically I understand the solution but unable to think on my own  what should I do\\n\\nNeed advice\\nWould it be fine if I follow some playlist and solve those questions first hoping that will give me idea of how to approach would that help because I am unable to think of solutions on my own or shouLD i solve questions on my own ..thanks "
                    },
                    {
                        "username": "Srishti_gugoriya",
                        "content": "I am facing the same problem. Can you suggest me what you did then ?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "the input is not an Array,, it is {\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":{\"val\":4,\"left\":null,\"right\":null}},\"right\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null},\"right\":{\"val\":3,\"left\":null,\"right\":null}}}"
                    }
                ]
            },
            {
                "id": 1927992,
                "content": [
                    {
                        "username": "divyamahankali29",
                        "content": "not really an easy problem. "
                    },
                    {
                        "username": "dengsitao",
                        "content": "I have submit same code twice, and the first time runtime is 4ms, and second time the runtime is 8ms.\\nand the memory usage changed from 16.3MB to 16.2MB.\\nDoes anybody know why?\\nMaybe it is because test set is not the same for every submit?"
                    },
                    {
                        "username": "Digger_",
                        "content": "It\\'s the same with me, I think it depends on the speed of the network and the power of the computer."
                    },
                    {
                        "username": "etekerl1",
                        "content": "I am getting this error when trying to compile my solution. Does anyone have any idea what this is? \\n\\nCannot implicitly convert type \\'TreeNode [/leetcode/user_code/interpret_1540783121.1122456_Xuw0WDwifV/precompiled/TreeNode.dll]\\' to \\'TreeNode [/leetcode/user_code/interpret_1540783121.1122456_Xuw0WDwifV/Solution.cs(11)]\\'\\n"
                    },
                    {
                        "username": "xiaoxiao3",
                        "content": "To me, this one is not quite easy. I couldn\\'t figure out the solution (iterator 2 nodes) without seeing the answer :( "
                    },
                    {
                        "username": "bumate90",
                        "content": "Huh, that wasn\\'t so easy. \\nPro tip: don\\'t try to separately traverse the two subtrees rather build\\na simple, intuitive, recursive solution looking at the example."
                    },
                    {
                        "username": "KratosOfSparta",
                        "content": "![image](https://assets.leetcode.com/users/tadichetty/image_1544642400.png)\\n\\nThis is weird, how do I solve this?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "i am giving up, i spend 30 min and passed only 1 test cases \\uD83D\\uDE23"
                    },
                    {
                        "username": "startupveteran",
                        "content": "In example #2, we are given [1,2,2,null,3,null,3]\n\nMy recursion code is shooting out an end result of [[1], [2, 2], [3, 3]]\n\nHow do I make it look like `[[1], [2, 2], [null, 3, null, 3]]`?"
                    },
                    {
                        "username": "startupveteran",
                        "content": "[@aakashsrh](/aakashsrh) I never got that to work out the way I envisioned it, but I solved the problem using a different method"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I have the exactly same question iteratively, [@startupveteran](/startupveteran) I wanted my 2nd example\\'s resultant to look like [[1], [2,2] ,[0,3,0,3] as left nodes are not present. Or if not [[1], [2,2] ,[0,3,0,3] then [[1], [2, 2], [null, 3, null, 3]]. Were you able to proceed ?"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "Can anyone help me I am unable to solve tree questions basically I understand the solution but unable to think on my own  what should I do\\n\\nNeed advice\\nWould it be fine if I follow some playlist and solve those questions first hoping that will give me idea of how to approach would that help because I am unable to think of solutions on my own or shouLD i solve questions on my own ..thanks "
                    },
                    {
                        "username": "Srishti_gugoriya",
                        "content": "I am facing the same problem. Can you suggest me what you did then ?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "the input is not an Array,, it is {\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":{\"val\":4,\"left\":null,\"right\":null}},\"right\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null},\"right\":{\"val\":3,\"left\":null,\"right\":null}}}"
                    }
                ]
            },
            {
                "id": 1876529,
                "content": [
                    {
                        "username": "divyamahankali29",
                        "content": "not really an easy problem. "
                    },
                    {
                        "username": "dengsitao",
                        "content": "I have submit same code twice, and the first time runtime is 4ms, and second time the runtime is 8ms.\\nand the memory usage changed from 16.3MB to 16.2MB.\\nDoes anybody know why?\\nMaybe it is because test set is not the same for every submit?"
                    },
                    {
                        "username": "Digger_",
                        "content": "It\\'s the same with me, I think it depends on the speed of the network and the power of the computer."
                    },
                    {
                        "username": "etekerl1",
                        "content": "I am getting this error when trying to compile my solution. Does anyone have any idea what this is? \\n\\nCannot implicitly convert type \\'TreeNode [/leetcode/user_code/interpret_1540783121.1122456_Xuw0WDwifV/precompiled/TreeNode.dll]\\' to \\'TreeNode [/leetcode/user_code/interpret_1540783121.1122456_Xuw0WDwifV/Solution.cs(11)]\\'\\n"
                    },
                    {
                        "username": "xiaoxiao3",
                        "content": "To me, this one is not quite easy. I couldn\\'t figure out the solution (iterator 2 nodes) without seeing the answer :( "
                    },
                    {
                        "username": "bumate90",
                        "content": "Huh, that wasn\\'t so easy. \\nPro tip: don\\'t try to separately traverse the two subtrees rather build\\na simple, intuitive, recursive solution looking at the example."
                    },
                    {
                        "username": "KratosOfSparta",
                        "content": "![image](https://assets.leetcode.com/users/tadichetty/image_1544642400.png)\\n\\nThis is weird, how do I solve this?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "i am giving up, i spend 30 min and passed only 1 test cases \\uD83D\\uDE23"
                    },
                    {
                        "username": "startupveteran",
                        "content": "In example #2, we are given [1,2,2,null,3,null,3]\n\nMy recursion code is shooting out an end result of [[1], [2, 2], [3, 3]]\n\nHow do I make it look like `[[1], [2, 2], [null, 3, null, 3]]`?"
                    },
                    {
                        "username": "startupveteran",
                        "content": "[@aakashsrh](/aakashsrh) I never got that to work out the way I envisioned it, but I solved the problem using a different method"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I have the exactly same question iteratively, [@startupveteran](/startupveteran) I wanted my 2nd example\\'s resultant to look like [[1], [2,2] ,[0,3,0,3] as left nodes are not present. Or if not [[1], [2,2] ,[0,3,0,3] then [[1], [2, 2], [null, 3, null, 3]]. Were you able to proceed ?"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "Can anyone help me I am unable to solve tree questions basically I understand the solution but unable to think on my own  what should I do\\n\\nNeed advice\\nWould it be fine if I follow some playlist and solve those questions first hoping that will give me idea of how to approach would that help because I am unable to think of solutions on my own or shouLD i solve questions on my own ..thanks "
                    },
                    {
                        "username": "Srishti_gugoriya",
                        "content": "I am facing the same problem. Can you suggest me what you did then ?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "the input is not an Array,, it is {\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":{\"val\":4,\"left\":null,\"right\":null}},\"right\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null},\"right\":{\"val\":3,\"left\":null,\"right\":null}}}"
                    }
                ]
            },
            {
                "id": 1831530,
                "content": [
                    {
                        "username": "divyamahankali29",
                        "content": "not really an easy problem. "
                    },
                    {
                        "username": "dengsitao",
                        "content": "I have submit same code twice, and the first time runtime is 4ms, and second time the runtime is 8ms.\\nand the memory usage changed from 16.3MB to 16.2MB.\\nDoes anybody know why?\\nMaybe it is because test set is not the same for every submit?"
                    },
                    {
                        "username": "Digger_",
                        "content": "It\\'s the same with me, I think it depends on the speed of the network and the power of the computer."
                    },
                    {
                        "username": "etekerl1",
                        "content": "I am getting this error when trying to compile my solution. Does anyone have any idea what this is? \\n\\nCannot implicitly convert type \\'TreeNode [/leetcode/user_code/interpret_1540783121.1122456_Xuw0WDwifV/precompiled/TreeNode.dll]\\' to \\'TreeNode [/leetcode/user_code/interpret_1540783121.1122456_Xuw0WDwifV/Solution.cs(11)]\\'\\n"
                    },
                    {
                        "username": "xiaoxiao3",
                        "content": "To me, this one is not quite easy. I couldn\\'t figure out the solution (iterator 2 nodes) without seeing the answer :( "
                    },
                    {
                        "username": "bumate90",
                        "content": "Huh, that wasn\\'t so easy. \\nPro tip: don\\'t try to separately traverse the two subtrees rather build\\na simple, intuitive, recursive solution looking at the example."
                    },
                    {
                        "username": "KratosOfSparta",
                        "content": "![image](https://assets.leetcode.com/users/tadichetty/image_1544642400.png)\\n\\nThis is weird, how do I solve this?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "i am giving up, i spend 30 min and passed only 1 test cases \\uD83D\\uDE23"
                    },
                    {
                        "username": "startupveteran",
                        "content": "In example #2, we are given [1,2,2,null,3,null,3]\n\nMy recursion code is shooting out an end result of [[1], [2, 2], [3, 3]]\n\nHow do I make it look like `[[1], [2, 2], [null, 3, null, 3]]`?"
                    },
                    {
                        "username": "startupveteran",
                        "content": "[@aakashsrh](/aakashsrh) I never got that to work out the way I envisioned it, but I solved the problem using a different method"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I have the exactly same question iteratively, [@startupveteran](/startupveteran) I wanted my 2nd example\\'s resultant to look like [[1], [2,2] ,[0,3,0,3] as left nodes are not present. Or if not [[1], [2,2] ,[0,3,0,3] then [[1], [2, 2], [null, 3, null, 3]]. Were you able to proceed ?"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "Can anyone help me I am unable to solve tree questions basically I understand the solution but unable to think on my own  what should I do\\n\\nNeed advice\\nWould it be fine if I follow some playlist and solve those questions first hoping that will give me idea of how to approach would that help because I am unable to think of solutions on my own or shouLD i solve questions on my own ..thanks "
                    },
                    {
                        "username": "Srishti_gugoriya",
                        "content": "I am facing the same problem. Can you suggest me what you did then ?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "the input is not an Array,, it is {\"val\":1,\"left\":{\"val\":2,\"left\":{\"val\":3,\"left\":null,\"right\":null},\"right\":{\"val\":4,\"left\":null,\"right\":null}},\"right\":{\"val\":2,\"left\":{\"val\":4,\"left\":null,\"right\":null},\"right\":{\"val\":3,\"left\":null,\"right\":null}}}"
                    }
                ]
            },
            {
                "id": 1831247,
                "content": [
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think the problem tag should be a medium ."
                    },
                    {
                        "username": "cattooo",
                        "content": "[2,3,3,4,5,5,4,null,null,8,9,9,8] expected output: True.\\n\\nCould someone explain me how is this true?"
                    },
                    {
                        "username": "user9313UP",
                        "content": "had same issue with this one, should it not be [2,3,3,4,5,5,4,null,8,9,9,8,null] instead ?"
                    },
                    {
                        "username": "Gydronium",
                        "content": "if you print this example in testcase tab you will see visualization of a tree"
                    },
                    {
                        "username": "lucianoinso",
                        "content": "You should \"imaginary\" attach two last nulls for the last node (\"4\").\n8, 9 and 9,8 are attached to the 5's, and the nulls to the 4's."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Oh sure, just what I wanted on a lovely Monday morning: a nice and easy problem to solve. How delightful."
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/symmetric-tree-leet-code-101/"
                    },
                    {
                        "username": "wdb",
                        "content": "Is there any difference between input[1,#,2]and input[1,null,2]?"
                    },
                    {
                        "username": "hammeramr",
                        "content": "in JS # is truthy and null is not\\n\\nif(\\'#\\') console.log(\\'this will print)\\nif (null) console.log(\\'this wont\\')"
                    },
                    {
                        "username": "abhinabroy",
                        "content": "The BFS solution is fairly easy for this one. I struggled to get the DFS one. What are your thoughts?"
                    },
                    {
                        "username": "supernoob00",
                        "content": "I think the solution to this problem becomes clear if you use a recursive helper method that takes two parameters:\\n\\n `boolean isMirrored(TreeNode r1, TreeNode r2)`\\n\\nThe above method tests if two separate trees are mirrors of each other.\\n"
                    },
                    {
                        "username": "Hnshlr",
                        "content": "When you go through Leetcode\\'s \"Top Interview 150\", they have you go through \"100. Same Tree\" and \"226. Invert Binary Tree\". Correct me if I\\'m wrong, but this problem is literally a combination of both."
                    },
                    {
                        "username": "samhithkadiyala",
                        "content": "There is a pattern here\\nthe pattern is that every half is the last row, if you just see carefully"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Good Easy question \nOne of the few easy question where you actually have to apply some logic"
                    }
                ]
            },
            {
                "id": 1831224,
                "content": [
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think the problem tag should be a medium ."
                    },
                    {
                        "username": "cattooo",
                        "content": "[2,3,3,4,5,5,4,null,null,8,9,9,8] expected output: True.\\n\\nCould someone explain me how is this true?"
                    },
                    {
                        "username": "user9313UP",
                        "content": "had same issue with this one, should it not be [2,3,3,4,5,5,4,null,8,9,9,8,null] instead ?"
                    },
                    {
                        "username": "Gydronium",
                        "content": "if you print this example in testcase tab you will see visualization of a tree"
                    },
                    {
                        "username": "lucianoinso",
                        "content": "You should \"imaginary\" attach two last nulls for the last node (\"4\").\n8, 9 and 9,8 are attached to the 5's, and the nulls to the 4's."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Oh sure, just what I wanted on a lovely Monday morning: a nice and easy problem to solve. How delightful."
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/symmetric-tree-leet-code-101/"
                    },
                    {
                        "username": "wdb",
                        "content": "Is there any difference between input[1,#,2]and input[1,null,2]?"
                    },
                    {
                        "username": "hammeramr",
                        "content": "in JS # is truthy and null is not\\n\\nif(\\'#\\') console.log(\\'this will print)\\nif (null) console.log(\\'this wont\\')"
                    },
                    {
                        "username": "abhinabroy",
                        "content": "The BFS solution is fairly easy for this one. I struggled to get the DFS one. What are your thoughts?"
                    },
                    {
                        "username": "supernoob00",
                        "content": "I think the solution to this problem becomes clear if you use a recursive helper method that takes two parameters:\\n\\n `boolean isMirrored(TreeNode r1, TreeNode r2)`\\n\\nThe above method tests if two separate trees are mirrors of each other.\\n"
                    },
                    {
                        "username": "Hnshlr",
                        "content": "When you go through Leetcode\\'s \"Top Interview 150\", they have you go through \"100. Same Tree\" and \"226. Invert Binary Tree\". Correct me if I\\'m wrong, but this problem is literally a combination of both."
                    },
                    {
                        "username": "samhithkadiyala",
                        "content": "There is a pattern here\\nthe pattern is that every half is the last row, if you just see carefully"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Good Easy question \nOne of the few easy question where you actually have to apply some logic"
                    }
                ]
            },
            {
                "id": 1830925,
                "content": [
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think the problem tag should be a medium ."
                    },
                    {
                        "username": "cattooo",
                        "content": "[2,3,3,4,5,5,4,null,null,8,9,9,8] expected output: True.\\n\\nCould someone explain me how is this true?"
                    },
                    {
                        "username": "user9313UP",
                        "content": "had same issue with this one, should it not be [2,3,3,4,5,5,4,null,8,9,9,8,null] instead ?"
                    },
                    {
                        "username": "Gydronium",
                        "content": "if you print this example in testcase tab you will see visualization of a tree"
                    },
                    {
                        "username": "lucianoinso",
                        "content": "You should \"imaginary\" attach two last nulls for the last node (\"4\").\n8, 9 and 9,8 are attached to the 5's, and the nulls to the 4's."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Oh sure, just what I wanted on a lovely Monday morning: a nice and easy problem to solve. How delightful."
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/symmetric-tree-leet-code-101/"
                    },
                    {
                        "username": "wdb",
                        "content": "Is there any difference between input[1,#,2]and input[1,null,2]?"
                    },
                    {
                        "username": "hammeramr",
                        "content": "in JS # is truthy and null is not\\n\\nif(\\'#\\') console.log(\\'this will print)\\nif (null) console.log(\\'this wont\\')"
                    },
                    {
                        "username": "abhinabroy",
                        "content": "The BFS solution is fairly easy for this one. I struggled to get the DFS one. What are your thoughts?"
                    },
                    {
                        "username": "supernoob00",
                        "content": "I think the solution to this problem becomes clear if you use a recursive helper method that takes two parameters:\\n\\n `boolean isMirrored(TreeNode r1, TreeNode r2)`\\n\\nThe above method tests if two separate trees are mirrors of each other.\\n"
                    },
                    {
                        "username": "Hnshlr",
                        "content": "When you go through Leetcode\\'s \"Top Interview 150\", they have you go through \"100. Same Tree\" and \"226. Invert Binary Tree\". Correct me if I\\'m wrong, but this problem is literally a combination of both."
                    },
                    {
                        "username": "samhithkadiyala",
                        "content": "There is a pattern here\\nthe pattern is that every half is the last row, if you just see carefully"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Good Easy question \nOne of the few easy question where you actually have to apply some logic"
                    }
                ]
            },
            {
                "id": 1739888,
                "content": [
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think the problem tag should be a medium ."
                    },
                    {
                        "username": "cattooo",
                        "content": "[2,3,3,4,5,5,4,null,null,8,9,9,8] expected output: True.\\n\\nCould someone explain me how is this true?"
                    },
                    {
                        "username": "user9313UP",
                        "content": "had same issue with this one, should it not be [2,3,3,4,5,5,4,null,8,9,9,8,null] instead ?"
                    },
                    {
                        "username": "Gydronium",
                        "content": "if you print this example in testcase tab you will see visualization of a tree"
                    },
                    {
                        "username": "lucianoinso",
                        "content": "You should \"imaginary\" attach two last nulls for the last node (\"4\").\n8, 9 and 9,8 are attached to the 5's, and the nulls to the 4's."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Oh sure, just what I wanted on a lovely Monday morning: a nice and easy problem to solve. How delightful."
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/symmetric-tree-leet-code-101/"
                    },
                    {
                        "username": "wdb",
                        "content": "Is there any difference between input[1,#,2]and input[1,null,2]?"
                    },
                    {
                        "username": "hammeramr",
                        "content": "in JS # is truthy and null is not\\n\\nif(\\'#\\') console.log(\\'this will print)\\nif (null) console.log(\\'this wont\\')"
                    },
                    {
                        "username": "abhinabroy",
                        "content": "The BFS solution is fairly easy for this one. I struggled to get the DFS one. What are your thoughts?"
                    },
                    {
                        "username": "supernoob00",
                        "content": "I think the solution to this problem becomes clear if you use a recursive helper method that takes two parameters:\\n\\n `boolean isMirrored(TreeNode r1, TreeNode r2)`\\n\\nThe above method tests if two separate trees are mirrors of each other.\\n"
                    },
                    {
                        "username": "Hnshlr",
                        "content": "When you go through Leetcode\\'s \"Top Interview 150\", they have you go through \"100. Same Tree\" and \"226. Invert Binary Tree\". Correct me if I\\'m wrong, but this problem is literally a combination of both."
                    },
                    {
                        "username": "samhithkadiyala",
                        "content": "There is a pattern here\\nthe pattern is that every half is the last row, if you just see carefully"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Good Easy question \nOne of the few easy question where you actually have to apply some logic"
                    }
                ]
            },
            {
                "id": 1571214,
                "content": [
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think the problem tag should be a medium ."
                    },
                    {
                        "username": "cattooo",
                        "content": "[2,3,3,4,5,5,4,null,null,8,9,9,8] expected output: True.\\n\\nCould someone explain me how is this true?"
                    },
                    {
                        "username": "user9313UP",
                        "content": "had same issue with this one, should it not be [2,3,3,4,5,5,4,null,8,9,9,8,null] instead ?"
                    },
                    {
                        "username": "Gydronium",
                        "content": "if you print this example in testcase tab you will see visualization of a tree"
                    },
                    {
                        "username": "lucianoinso",
                        "content": "You should \"imaginary\" attach two last nulls for the last node (\"4\").\n8, 9 and 9,8 are attached to the 5's, and the nulls to the 4's."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Oh sure, just what I wanted on a lovely Monday morning: a nice and easy problem to solve. How delightful."
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/symmetric-tree-leet-code-101/"
                    },
                    {
                        "username": "wdb",
                        "content": "Is there any difference between input[1,#,2]and input[1,null,2]?"
                    },
                    {
                        "username": "hammeramr",
                        "content": "in JS # is truthy and null is not\\n\\nif(\\'#\\') console.log(\\'this will print)\\nif (null) console.log(\\'this wont\\')"
                    },
                    {
                        "username": "abhinabroy",
                        "content": "The BFS solution is fairly easy for this one. I struggled to get the DFS one. What are your thoughts?"
                    },
                    {
                        "username": "supernoob00",
                        "content": "I think the solution to this problem becomes clear if you use a recursive helper method that takes two parameters:\\n\\n `boolean isMirrored(TreeNode r1, TreeNode r2)`\\n\\nThe above method tests if two separate trees are mirrors of each other.\\n"
                    },
                    {
                        "username": "Hnshlr",
                        "content": "When you go through Leetcode\\'s \"Top Interview 150\", they have you go through \"100. Same Tree\" and \"226. Invert Binary Tree\". Correct me if I\\'m wrong, but this problem is literally a combination of both."
                    },
                    {
                        "username": "samhithkadiyala",
                        "content": "There is a pattern here\\nthe pattern is that every half is the last row, if you just see carefully"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Good Easy question \nOne of the few easy question where you actually have to apply some logic"
                    }
                ]
            },
            {
                "id": 2072410,
                "content": [
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think the problem tag should be a medium ."
                    },
                    {
                        "username": "cattooo",
                        "content": "[2,3,3,4,5,5,4,null,null,8,9,9,8] expected output: True.\\n\\nCould someone explain me how is this true?"
                    },
                    {
                        "username": "user9313UP",
                        "content": "had same issue with this one, should it not be [2,3,3,4,5,5,4,null,8,9,9,8,null] instead ?"
                    },
                    {
                        "username": "Gydronium",
                        "content": "if you print this example in testcase tab you will see visualization of a tree"
                    },
                    {
                        "username": "lucianoinso",
                        "content": "You should \"imaginary\" attach two last nulls for the last node (\"4\").\n8, 9 and 9,8 are attached to the 5's, and the nulls to the 4's."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Oh sure, just what I wanted on a lovely Monday morning: a nice and easy problem to solve. How delightful."
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/symmetric-tree-leet-code-101/"
                    },
                    {
                        "username": "wdb",
                        "content": "Is there any difference between input[1,#,2]and input[1,null,2]?"
                    },
                    {
                        "username": "hammeramr",
                        "content": "in JS # is truthy and null is not\\n\\nif(\\'#\\') console.log(\\'this will print)\\nif (null) console.log(\\'this wont\\')"
                    },
                    {
                        "username": "abhinabroy",
                        "content": "The BFS solution is fairly easy for this one. I struggled to get the DFS one. What are your thoughts?"
                    },
                    {
                        "username": "supernoob00",
                        "content": "I think the solution to this problem becomes clear if you use a recursive helper method that takes two parameters:\\n\\n `boolean isMirrored(TreeNode r1, TreeNode r2)`\\n\\nThe above method tests if two separate trees are mirrors of each other.\\n"
                    },
                    {
                        "username": "Hnshlr",
                        "content": "When you go through Leetcode\\'s \"Top Interview 150\", they have you go through \"100. Same Tree\" and \"226. Invert Binary Tree\". Correct me if I\\'m wrong, but this problem is literally a combination of both."
                    },
                    {
                        "username": "samhithkadiyala",
                        "content": "There is a pattern here\\nthe pattern is that every half is the last row, if you just see carefully"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Good Easy question \nOne of the few easy question where you actually have to apply some logic"
                    }
                ]
            },
            {
                "id": 2038685,
                "content": [
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think the problem tag should be a medium ."
                    },
                    {
                        "username": "cattooo",
                        "content": "[2,3,3,4,5,5,4,null,null,8,9,9,8] expected output: True.\\n\\nCould someone explain me how is this true?"
                    },
                    {
                        "username": "user9313UP",
                        "content": "had same issue with this one, should it not be [2,3,3,4,5,5,4,null,8,9,9,8,null] instead ?"
                    },
                    {
                        "username": "Gydronium",
                        "content": "if you print this example in testcase tab you will see visualization of a tree"
                    },
                    {
                        "username": "lucianoinso",
                        "content": "You should \"imaginary\" attach two last nulls for the last node (\"4\").\n8, 9 and 9,8 are attached to the 5's, and the nulls to the 4's."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Oh sure, just what I wanted on a lovely Monday morning: a nice and easy problem to solve. How delightful."
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/symmetric-tree-leet-code-101/"
                    },
                    {
                        "username": "wdb",
                        "content": "Is there any difference between input[1,#,2]and input[1,null,2]?"
                    },
                    {
                        "username": "hammeramr",
                        "content": "in JS # is truthy and null is not\\n\\nif(\\'#\\') console.log(\\'this will print)\\nif (null) console.log(\\'this wont\\')"
                    },
                    {
                        "username": "abhinabroy",
                        "content": "The BFS solution is fairly easy for this one. I struggled to get the DFS one. What are your thoughts?"
                    },
                    {
                        "username": "supernoob00",
                        "content": "I think the solution to this problem becomes clear if you use a recursive helper method that takes two parameters:\\n\\n `boolean isMirrored(TreeNode r1, TreeNode r2)`\\n\\nThe above method tests if two separate trees are mirrors of each other.\\n"
                    },
                    {
                        "username": "Hnshlr",
                        "content": "When you go through Leetcode\\'s \"Top Interview 150\", they have you go through \"100. Same Tree\" and \"226. Invert Binary Tree\". Correct me if I\\'m wrong, but this problem is literally a combination of both."
                    },
                    {
                        "username": "samhithkadiyala",
                        "content": "There is a pattern here\\nthe pattern is that every half is the last row, if you just see carefully"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Good Easy question \nOne of the few easy question where you actually have to apply some logic"
                    }
                ]
            },
            {
                "id": 2037148,
                "content": [
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think the problem tag should be a medium ."
                    },
                    {
                        "username": "cattooo",
                        "content": "[2,3,3,4,5,5,4,null,null,8,9,9,8] expected output: True.\\n\\nCould someone explain me how is this true?"
                    },
                    {
                        "username": "user9313UP",
                        "content": "had same issue with this one, should it not be [2,3,3,4,5,5,4,null,8,9,9,8,null] instead ?"
                    },
                    {
                        "username": "Gydronium",
                        "content": "if you print this example in testcase tab you will see visualization of a tree"
                    },
                    {
                        "username": "lucianoinso",
                        "content": "You should \"imaginary\" attach two last nulls for the last node (\"4\").\n8, 9 and 9,8 are attached to the 5's, and the nulls to the 4's."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Oh sure, just what I wanted on a lovely Monday morning: a nice and easy problem to solve. How delightful."
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/symmetric-tree-leet-code-101/"
                    },
                    {
                        "username": "wdb",
                        "content": "Is there any difference between input[1,#,2]and input[1,null,2]?"
                    },
                    {
                        "username": "hammeramr",
                        "content": "in JS # is truthy and null is not\\n\\nif(\\'#\\') console.log(\\'this will print)\\nif (null) console.log(\\'this wont\\')"
                    },
                    {
                        "username": "abhinabroy",
                        "content": "The BFS solution is fairly easy for this one. I struggled to get the DFS one. What are your thoughts?"
                    },
                    {
                        "username": "supernoob00",
                        "content": "I think the solution to this problem becomes clear if you use a recursive helper method that takes two parameters:\\n\\n `boolean isMirrored(TreeNode r1, TreeNode r2)`\\n\\nThe above method tests if two separate trees are mirrors of each other.\\n"
                    },
                    {
                        "username": "Hnshlr",
                        "content": "When you go through Leetcode\\'s \"Top Interview 150\", they have you go through \"100. Same Tree\" and \"226. Invert Binary Tree\". Correct me if I\\'m wrong, but this problem is literally a combination of both."
                    },
                    {
                        "username": "samhithkadiyala",
                        "content": "There is a pattern here\\nthe pattern is that every half is the last row, if you just see carefully"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Good Easy question \nOne of the few easy question where you actually have to apply some logic"
                    }
                ]
            },
            {
                "id": 2029936,
                "content": [
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think the problem tag should be a medium ."
                    },
                    {
                        "username": "cattooo",
                        "content": "[2,3,3,4,5,5,4,null,null,8,9,9,8] expected output: True.\\n\\nCould someone explain me how is this true?"
                    },
                    {
                        "username": "user9313UP",
                        "content": "had same issue with this one, should it not be [2,3,3,4,5,5,4,null,8,9,9,8,null] instead ?"
                    },
                    {
                        "username": "Gydronium",
                        "content": "if you print this example in testcase tab you will see visualization of a tree"
                    },
                    {
                        "username": "lucianoinso",
                        "content": "You should \"imaginary\" attach two last nulls for the last node (\"4\").\n8, 9 and 9,8 are attached to the 5's, and the nulls to the 4's."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Oh sure, just what I wanted on a lovely Monday morning: a nice and easy problem to solve. How delightful."
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/symmetric-tree-leet-code-101/"
                    },
                    {
                        "username": "wdb",
                        "content": "Is there any difference between input[1,#,2]and input[1,null,2]?"
                    },
                    {
                        "username": "hammeramr",
                        "content": "in JS # is truthy and null is not\\n\\nif(\\'#\\') console.log(\\'this will print)\\nif (null) console.log(\\'this wont\\')"
                    },
                    {
                        "username": "abhinabroy",
                        "content": "The BFS solution is fairly easy for this one. I struggled to get the DFS one. What are your thoughts?"
                    },
                    {
                        "username": "supernoob00",
                        "content": "I think the solution to this problem becomes clear if you use a recursive helper method that takes two parameters:\\n\\n `boolean isMirrored(TreeNode r1, TreeNode r2)`\\n\\nThe above method tests if two separate trees are mirrors of each other.\\n"
                    },
                    {
                        "username": "Hnshlr",
                        "content": "When you go through Leetcode\\'s \"Top Interview 150\", they have you go through \"100. Same Tree\" and \"226. Invert Binary Tree\". Correct me if I\\'m wrong, but this problem is literally a combination of both."
                    },
                    {
                        "username": "samhithkadiyala",
                        "content": "There is a pattern here\\nthe pattern is that every half is the last row, if you just see carefully"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Good Easy question \nOne of the few easy question where you actually have to apply some logic"
                    }
                ]
            },
            {
                "id": 2007922,
                "content": [
                    {
                        "username": "SuyashSingh_1",
                        "content": "I think the problem tag should be a medium ."
                    },
                    {
                        "username": "cattooo",
                        "content": "[2,3,3,4,5,5,4,null,null,8,9,9,8] expected output: True.\\n\\nCould someone explain me how is this true?"
                    },
                    {
                        "username": "user9313UP",
                        "content": "had same issue with this one, should it not be [2,3,3,4,5,5,4,null,8,9,9,8,null] instead ?"
                    },
                    {
                        "username": "Gydronium",
                        "content": "if you print this example in testcase tab you will see visualization of a tree"
                    },
                    {
                        "username": "lucianoinso",
                        "content": "You should \"imaginary\" attach two last nulls for the last node (\"4\").\n8, 9 and 9,8 are attached to the 5's, and the nulls to the 4's."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Oh sure, just what I wanted on a lovely Monday morning: a nice and easy problem to solve. How delightful."
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/symmetric-tree-leet-code-101/"
                    },
                    {
                        "username": "wdb",
                        "content": "Is there any difference between input[1,#,2]and input[1,null,2]?"
                    },
                    {
                        "username": "hammeramr",
                        "content": "in JS # is truthy and null is not\\n\\nif(\\'#\\') console.log(\\'this will print)\\nif (null) console.log(\\'this wont\\')"
                    },
                    {
                        "username": "abhinabroy",
                        "content": "The BFS solution is fairly easy for this one. I struggled to get the DFS one. What are your thoughts?"
                    },
                    {
                        "username": "supernoob00",
                        "content": "I think the solution to this problem becomes clear if you use a recursive helper method that takes two parameters:\\n\\n `boolean isMirrored(TreeNode r1, TreeNode r2)`\\n\\nThe above method tests if two separate trees are mirrors of each other.\\n"
                    },
                    {
                        "username": "Hnshlr",
                        "content": "When you go through Leetcode\\'s \"Top Interview 150\", they have you go through \"100. Same Tree\" and \"226. Invert Binary Tree\". Correct me if I\\'m wrong, but this problem is literally a combination of both."
                    },
                    {
                        "username": "samhithkadiyala",
                        "content": "There is a pattern here\\nthe pattern is that every half is the last row, if you just see carefully"
                    },
                    {
                        "username": "Mohit_Jariwala",
                        "content": "Good Easy question \nOne of the few easy question where you actually have to apply some logic"
                    }
                ]
            },
            {
                "id": 1982668,
                "content": [
                    {
                        "username": "ashish030899",
                        "content": "If I do inorder traversal and store it in an array and then check if it is palindrome or not . Will it be a good approach ??"
                    },
                    {
                        "username": "Prashanth_Upputuri",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        return symmetric(root.left,root.right);\\n        \\n    }\\n    static boolean symmetric(TreeNode leftroot,TreeNode rightroot){\\n        if(rightroot == null && leftroot == null)\\n          return true;\\n        if(rightroot == null && leftroot != null)\\n          return false;\\n        if(rightroot != null && leftroot == null)\\n          return false;\\n        \\n        return (leftroot.val == rightroot.val)&&symmetric(leftroot.left,rightroot.right)&&symmetric(leftroot.right,rightroot.left);\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dynamic099",
                        "content": "I will say it is kind of a easy medium ."
                    },
                    {
                        "username": "amadouadiah",
                        "content": "NeetCode helped me understand how easy it actually is. You can create a different method that does a Depth First Search on both subtrees at the same time and recursively compares their children nodes."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nDFS Traversal C++ Easy solution \\n\\n--------------------------------------------\\n# Approach\\n\\n1. Define a recursive function `rec` that takes in two `TreeNode` pointers, `l` and `r`, and returns a boolean value.\\n2. Inside the `rec` function:\\n   a. Check if both `l` and `r` are `NULL` (indicating leaf nodes). If true, return `true` as the tree is symmetric at this level.\\n   b. Check if either `l` or `r` is `NULL`, but not both. If true, return `false` as the tree is not symmetric at this level.\\n   c. Check if the values of `l` and `r` are different. If true, return `false` as the tree is not symmetric at this level.\\n   d. Recursively call `rec` with `l->left` and `r->right` as arguments, and check if the subtrees starting from these nodes are symmetric.\\n   e. Recursively call `rec` with `l->right` and `r->left` as arguments, and check if the subtrees starting from these nodes are symmetric.\\n   f. Return the logical AND of the two recursive calls from steps d and e. This indicates whether the left and right subtrees are symmetric.\\n\\n3. Define the function `isSymmetric` that takes in a `TreeNode` pointer `root` and returns a boolean value.\\n4. Inside the `isSymmetric` function:\\n   a. Check if `root` is `NULL`. If true, return `true` as the tree is empty and thus symmetric.\\n   b. Return the result of calling `rec` with `root->left` and `root->right` as arguments. This checks if the entire tree is symmetric.\\n\\n---------------------------------\\n# Complexity\\n- Time complexity:\\nO(n) in worst case we have to visit all nodes. \\n\\n- Space complexity:\\nO(h) h=height of tree.\\n-----------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3700735/dfs-traversal-c-easy-solution/"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I want someone's insights on my approach. So i tried Level-Order Traversal with BFS using Queue.\n\nIn my 2D vector i have the elements stored in each of my level.\n\nLet us take the 2 examples given in the description\n\nRoot -> [1,2,2,3,4,4,3] \nResulting 2D Vector -> [[1],[2,2],[3,4,4,3]] \n\nRoot -> [1,2,2,null,3,null,3]\nResulting 2D Vector -> [[1],[2,2],[3,3]] \n\nNow I should be working around my 2D Vectors to determine if my tree is symmetric or not.\n\nSo, for every level in my 2D Vector i need to check if the element on the left-most side is equal to the right-most element if they are then i increment my left pointer and decrement my right pointer and do this until my right pointer is less than the left pointer. \n\nFocusing on the 2nd example's resulting 2D Vector i.e. [[1],[2,2],[3,3]] even though my approach would give me the answer that this tree is symmetric about the root node but it is not as both of these 3s are Right Sub Nodes of 2. Therefore giving me wrong answer.\n\nIs there a way i can put 0 in my internal Vector when i do not have a node either on the left of the parent node or on the right of the parent node. That might solve my problem.\n\nAny help is appreciated."
                    },
                    {
                        "username": "vardbabayan",
                        "content": "No, it will lead to Time Limit on big trees"
                    },
                    {
                        "username": "YshxGupta",
                        "content": "How to solve it iteratively ?\\n"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Using BFS Level-Order Traversal with the help of Queues."
                    },
                    {
                        "username": "SLDDL",
                        "content": "Quite funny seeing people saying its too hard, \\nJust do a recursive fonction that switches left and right  starting from the first left node then compare root.left and root.right"
                    },
                    {
                        "username": "jcodes5",
                        "content": "Interesting idea, does anyone know of any applications of symmetric/mirror binary trees?\\n\\nThe first thing that comes to mind is possible space saving hack by only saving one half of the tree, since you know the values of the other half by a change in traversal of the existing side? Can\\'t think of any real-world applications though."
                    },
                    {
                        "username": "aguilakrakatoa",
                        "content": "Should it be Mirror Tree? shouldn\\'t be? it\\'s a bit confusing."
                    }
                ]
            },
            {
                "id": 1980992,
                "content": [
                    {
                        "username": "ashish030899",
                        "content": "If I do inorder traversal and store it in an array and then check if it is palindrome or not . Will it be a good approach ??"
                    },
                    {
                        "username": "Prashanth_Upputuri",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        return symmetric(root.left,root.right);\\n        \\n    }\\n    static boolean symmetric(TreeNode leftroot,TreeNode rightroot){\\n        if(rightroot == null && leftroot == null)\\n          return true;\\n        if(rightroot == null && leftroot != null)\\n          return false;\\n        if(rightroot != null && leftroot == null)\\n          return false;\\n        \\n        return (leftroot.val == rightroot.val)&&symmetric(leftroot.left,rightroot.right)&&symmetric(leftroot.right,rightroot.left);\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dynamic099",
                        "content": "I will say it is kind of a easy medium ."
                    },
                    {
                        "username": "amadouadiah",
                        "content": "NeetCode helped me understand how easy it actually is. You can create a different method that does a Depth First Search on both subtrees at the same time and recursively compares their children nodes."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nDFS Traversal C++ Easy solution \\n\\n--------------------------------------------\\n# Approach\\n\\n1. Define a recursive function `rec` that takes in two `TreeNode` pointers, `l` and `r`, and returns a boolean value.\\n2. Inside the `rec` function:\\n   a. Check if both `l` and `r` are `NULL` (indicating leaf nodes). If true, return `true` as the tree is symmetric at this level.\\n   b. Check if either `l` or `r` is `NULL`, but not both. If true, return `false` as the tree is not symmetric at this level.\\n   c. Check if the values of `l` and `r` are different. If true, return `false` as the tree is not symmetric at this level.\\n   d. Recursively call `rec` with `l->left` and `r->right` as arguments, and check if the subtrees starting from these nodes are symmetric.\\n   e. Recursively call `rec` with `l->right` and `r->left` as arguments, and check if the subtrees starting from these nodes are symmetric.\\n   f. Return the logical AND of the two recursive calls from steps d and e. This indicates whether the left and right subtrees are symmetric.\\n\\n3. Define the function `isSymmetric` that takes in a `TreeNode` pointer `root` and returns a boolean value.\\n4. Inside the `isSymmetric` function:\\n   a. Check if `root` is `NULL`. If true, return `true` as the tree is empty and thus symmetric.\\n   b. Return the result of calling `rec` with `root->left` and `root->right` as arguments. This checks if the entire tree is symmetric.\\n\\n---------------------------------\\n# Complexity\\n- Time complexity:\\nO(n) in worst case we have to visit all nodes. \\n\\n- Space complexity:\\nO(h) h=height of tree.\\n-----------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3700735/dfs-traversal-c-easy-solution/"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I want someone's insights on my approach. So i tried Level-Order Traversal with BFS using Queue.\n\nIn my 2D vector i have the elements stored in each of my level.\n\nLet us take the 2 examples given in the description\n\nRoot -> [1,2,2,3,4,4,3] \nResulting 2D Vector -> [[1],[2,2],[3,4,4,3]] \n\nRoot -> [1,2,2,null,3,null,3]\nResulting 2D Vector -> [[1],[2,2],[3,3]] \n\nNow I should be working around my 2D Vectors to determine if my tree is symmetric or not.\n\nSo, for every level in my 2D Vector i need to check if the element on the left-most side is equal to the right-most element if they are then i increment my left pointer and decrement my right pointer and do this until my right pointer is less than the left pointer. \n\nFocusing on the 2nd example's resulting 2D Vector i.e. [[1],[2,2],[3,3]] even though my approach would give me the answer that this tree is symmetric about the root node but it is not as both of these 3s are Right Sub Nodes of 2. Therefore giving me wrong answer.\n\nIs there a way i can put 0 in my internal Vector when i do not have a node either on the left of the parent node or on the right of the parent node. That might solve my problem.\n\nAny help is appreciated."
                    },
                    {
                        "username": "vardbabayan",
                        "content": "No, it will lead to Time Limit on big trees"
                    },
                    {
                        "username": "YshxGupta",
                        "content": "How to solve it iteratively ?\\n"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Using BFS Level-Order Traversal with the help of Queues."
                    },
                    {
                        "username": "SLDDL",
                        "content": "Quite funny seeing people saying its too hard, \\nJust do a recursive fonction that switches left and right  starting from the first left node then compare root.left and root.right"
                    },
                    {
                        "username": "jcodes5",
                        "content": "Interesting idea, does anyone know of any applications of symmetric/mirror binary trees?\\n\\nThe first thing that comes to mind is possible space saving hack by only saving one half of the tree, since you know the values of the other half by a change in traversal of the existing side? Can\\'t think of any real-world applications though."
                    },
                    {
                        "username": "aguilakrakatoa",
                        "content": "Should it be Mirror Tree? shouldn\\'t be? it\\'s a bit confusing."
                    }
                ]
            },
            {
                "id": 1975188,
                "content": [
                    {
                        "username": "ashish030899",
                        "content": "If I do inorder traversal and store it in an array and then check if it is palindrome or not . Will it be a good approach ??"
                    },
                    {
                        "username": "Prashanth_Upputuri",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        return symmetric(root.left,root.right);\\n        \\n    }\\n    static boolean symmetric(TreeNode leftroot,TreeNode rightroot){\\n        if(rightroot == null && leftroot == null)\\n          return true;\\n        if(rightroot == null && leftroot != null)\\n          return false;\\n        if(rightroot != null && leftroot == null)\\n          return false;\\n        \\n        return (leftroot.val == rightroot.val)&&symmetric(leftroot.left,rightroot.right)&&symmetric(leftroot.right,rightroot.left);\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dynamic099",
                        "content": "I will say it is kind of a easy medium ."
                    },
                    {
                        "username": "amadouadiah",
                        "content": "NeetCode helped me understand how easy it actually is. You can create a different method that does a Depth First Search on both subtrees at the same time and recursively compares their children nodes."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nDFS Traversal C++ Easy solution \\n\\n--------------------------------------------\\n# Approach\\n\\n1. Define a recursive function `rec` that takes in two `TreeNode` pointers, `l` and `r`, and returns a boolean value.\\n2. Inside the `rec` function:\\n   a. Check if both `l` and `r` are `NULL` (indicating leaf nodes). If true, return `true` as the tree is symmetric at this level.\\n   b. Check if either `l` or `r` is `NULL`, but not both. If true, return `false` as the tree is not symmetric at this level.\\n   c. Check if the values of `l` and `r` are different. If true, return `false` as the tree is not symmetric at this level.\\n   d. Recursively call `rec` with `l->left` and `r->right` as arguments, and check if the subtrees starting from these nodes are symmetric.\\n   e. Recursively call `rec` with `l->right` and `r->left` as arguments, and check if the subtrees starting from these nodes are symmetric.\\n   f. Return the logical AND of the two recursive calls from steps d and e. This indicates whether the left and right subtrees are symmetric.\\n\\n3. Define the function `isSymmetric` that takes in a `TreeNode` pointer `root` and returns a boolean value.\\n4. Inside the `isSymmetric` function:\\n   a. Check if `root` is `NULL`. If true, return `true` as the tree is empty and thus symmetric.\\n   b. Return the result of calling `rec` with `root->left` and `root->right` as arguments. This checks if the entire tree is symmetric.\\n\\n---------------------------------\\n# Complexity\\n- Time complexity:\\nO(n) in worst case we have to visit all nodes. \\n\\n- Space complexity:\\nO(h) h=height of tree.\\n-----------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3700735/dfs-traversal-c-easy-solution/"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I want someone's insights on my approach. So i tried Level-Order Traversal with BFS using Queue.\n\nIn my 2D vector i have the elements stored in each of my level.\n\nLet us take the 2 examples given in the description\n\nRoot -> [1,2,2,3,4,4,3] \nResulting 2D Vector -> [[1],[2,2],[3,4,4,3]] \n\nRoot -> [1,2,2,null,3,null,3]\nResulting 2D Vector -> [[1],[2,2],[3,3]] \n\nNow I should be working around my 2D Vectors to determine if my tree is symmetric or not.\n\nSo, for every level in my 2D Vector i need to check if the element on the left-most side is equal to the right-most element if they are then i increment my left pointer and decrement my right pointer and do this until my right pointer is less than the left pointer. \n\nFocusing on the 2nd example's resulting 2D Vector i.e. [[1],[2,2],[3,3]] even though my approach would give me the answer that this tree is symmetric about the root node but it is not as both of these 3s are Right Sub Nodes of 2. Therefore giving me wrong answer.\n\nIs there a way i can put 0 in my internal Vector when i do not have a node either on the left of the parent node or on the right of the parent node. That might solve my problem.\n\nAny help is appreciated."
                    },
                    {
                        "username": "vardbabayan",
                        "content": "No, it will lead to Time Limit on big trees"
                    },
                    {
                        "username": "YshxGupta",
                        "content": "How to solve it iteratively ?\\n"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Using BFS Level-Order Traversal with the help of Queues."
                    },
                    {
                        "username": "SLDDL",
                        "content": "Quite funny seeing people saying its too hard, \\nJust do a recursive fonction that switches left and right  starting from the first left node then compare root.left and root.right"
                    },
                    {
                        "username": "jcodes5",
                        "content": "Interesting idea, does anyone know of any applications of symmetric/mirror binary trees?\\n\\nThe first thing that comes to mind is possible space saving hack by only saving one half of the tree, since you know the values of the other half by a change in traversal of the existing side? Can\\'t think of any real-world applications though."
                    },
                    {
                        "username": "aguilakrakatoa",
                        "content": "Should it be Mirror Tree? shouldn\\'t be? it\\'s a bit confusing."
                    }
                ]
            },
            {
                "id": 1966251,
                "content": [
                    {
                        "username": "ashish030899",
                        "content": "If I do inorder traversal and store it in an array and then check if it is palindrome or not . Will it be a good approach ??"
                    },
                    {
                        "username": "Prashanth_Upputuri",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        return symmetric(root.left,root.right);\\n        \\n    }\\n    static boolean symmetric(TreeNode leftroot,TreeNode rightroot){\\n        if(rightroot == null && leftroot == null)\\n          return true;\\n        if(rightroot == null && leftroot != null)\\n          return false;\\n        if(rightroot != null && leftroot == null)\\n          return false;\\n        \\n        return (leftroot.val == rightroot.val)&&symmetric(leftroot.left,rightroot.right)&&symmetric(leftroot.right,rightroot.left);\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dynamic099",
                        "content": "I will say it is kind of a easy medium ."
                    },
                    {
                        "username": "amadouadiah",
                        "content": "NeetCode helped me understand how easy it actually is. You can create a different method that does a Depth First Search on both subtrees at the same time and recursively compares their children nodes."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nDFS Traversal C++ Easy solution \\n\\n--------------------------------------------\\n# Approach\\n\\n1. Define a recursive function `rec` that takes in two `TreeNode` pointers, `l` and `r`, and returns a boolean value.\\n2. Inside the `rec` function:\\n   a. Check if both `l` and `r` are `NULL` (indicating leaf nodes). If true, return `true` as the tree is symmetric at this level.\\n   b. Check if either `l` or `r` is `NULL`, but not both. If true, return `false` as the tree is not symmetric at this level.\\n   c. Check if the values of `l` and `r` are different. If true, return `false` as the tree is not symmetric at this level.\\n   d. Recursively call `rec` with `l->left` and `r->right` as arguments, and check if the subtrees starting from these nodes are symmetric.\\n   e. Recursively call `rec` with `l->right` and `r->left` as arguments, and check if the subtrees starting from these nodes are symmetric.\\n   f. Return the logical AND of the two recursive calls from steps d and e. This indicates whether the left and right subtrees are symmetric.\\n\\n3. Define the function `isSymmetric` that takes in a `TreeNode` pointer `root` and returns a boolean value.\\n4. Inside the `isSymmetric` function:\\n   a. Check if `root` is `NULL`. If true, return `true` as the tree is empty and thus symmetric.\\n   b. Return the result of calling `rec` with `root->left` and `root->right` as arguments. This checks if the entire tree is symmetric.\\n\\n---------------------------------\\n# Complexity\\n- Time complexity:\\nO(n) in worst case we have to visit all nodes. \\n\\n- Space complexity:\\nO(h) h=height of tree.\\n-----------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3700735/dfs-traversal-c-easy-solution/"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I want someone's insights on my approach. So i tried Level-Order Traversal with BFS using Queue.\n\nIn my 2D vector i have the elements stored in each of my level.\n\nLet us take the 2 examples given in the description\n\nRoot -> [1,2,2,3,4,4,3] \nResulting 2D Vector -> [[1],[2,2],[3,4,4,3]] \n\nRoot -> [1,2,2,null,3,null,3]\nResulting 2D Vector -> [[1],[2,2],[3,3]] \n\nNow I should be working around my 2D Vectors to determine if my tree is symmetric or not.\n\nSo, for every level in my 2D Vector i need to check if the element on the left-most side is equal to the right-most element if they are then i increment my left pointer and decrement my right pointer and do this until my right pointer is less than the left pointer. \n\nFocusing on the 2nd example's resulting 2D Vector i.e. [[1],[2,2],[3,3]] even though my approach would give me the answer that this tree is symmetric about the root node but it is not as both of these 3s are Right Sub Nodes of 2. Therefore giving me wrong answer.\n\nIs there a way i can put 0 in my internal Vector when i do not have a node either on the left of the parent node or on the right of the parent node. That might solve my problem.\n\nAny help is appreciated."
                    },
                    {
                        "username": "vardbabayan",
                        "content": "No, it will lead to Time Limit on big trees"
                    },
                    {
                        "username": "YshxGupta",
                        "content": "How to solve it iteratively ?\\n"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Using BFS Level-Order Traversal with the help of Queues."
                    },
                    {
                        "username": "SLDDL",
                        "content": "Quite funny seeing people saying its too hard, \\nJust do a recursive fonction that switches left and right  starting from the first left node then compare root.left and root.right"
                    },
                    {
                        "username": "jcodes5",
                        "content": "Interesting idea, does anyone know of any applications of symmetric/mirror binary trees?\\n\\nThe first thing that comes to mind is possible space saving hack by only saving one half of the tree, since you know the values of the other half by a change in traversal of the existing side? Can\\'t think of any real-world applications though."
                    },
                    {
                        "username": "aguilakrakatoa",
                        "content": "Should it be Mirror Tree? shouldn\\'t be? it\\'s a bit confusing."
                    }
                ]
            },
            {
                "id": 1950587,
                "content": [
                    {
                        "username": "ashish030899",
                        "content": "If I do inorder traversal and store it in an array and then check if it is palindrome or not . Will it be a good approach ??"
                    },
                    {
                        "username": "Prashanth_Upputuri",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        return symmetric(root.left,root.right);\\n        \\n    }\\n    static boolean symmetric(TreeNode leftroot,TreeNode rightroot){\\n        if(rightroot == null && leftroot == null)\\n          return true;\\n        if(rightroot == null && leftroot != null)\\n          return false;\\n        if(rightroot != null && leftroot == null)\\n          return false;\\n        \\n        return (leftroot.val == rightroot.val)&&symmetric(leftroot.left,rightroot.right)&&symmetric(leftroot.right,rightroot.left);\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dynamic099",
                        "content": "I will say it is kind of a easy medium ."
                    },
                    {
                        "username": "amadouadiah",
                        "content": "NeetCode helped me understand how easy it actually is. You can create a different method that does a Depth First Search on both subtrees at the same time and recursively compares their children nodes."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nDFS Traversal C++ Easy solution \\n\\n--------------------------------------------\\n# Approach\\n\\n1. Define a recursive function `rec` that takes in two `TreeNode` pointers, `l` and `r`, and returns a boolean value.\\n2. Inside the `rec` function:\\n   a. Check if both `l` and `r` are `NULL` (indicating leaf nodes). If true, return `true` as the tree is symmetric at this level.\\n   b. Check if either `l` or `r` is `NULL`, but not both. If true, return `false` as the tree is not symmetric at this level.\\n   c. Check if the values of `l` and `r` are different. If true, return `false` as the tree is not symmetric at this level.\\n   d. Recursively call `rec` with `l->left` and `r->right` as arguments, and check if the subtrees starting from these nodes are symmetric.\\n   e. Recursively call `rec` with `l->right` and `r->left` as arguments, and check if the subtrees starting from these nodes are symmetric.\\n   f. Return the logical AND of the two recursive calls from steps d and e. This indicates whether the left and right subtrees are symmetric.\\n\\n3. Define the function `isSymmetric` that takes in a `TreeNode` pointer `root` and returns a boolean value.\\n4. Inside the `isSymmetric` function:\\n   a. Check if `root` is `NULL`. If true, return `true` as the tree is empty and thus symmetric.\\n   b. Return the result of calling `rec` with `root->left` and `root->right` as arguments. This checks if the entire tree is symmetric.\\n\\n---------------------------------\\n# Complexity\\n- Time complexity:\\nO(n) in worst case we have to visit all nodes. \\n\\n- Space complexity:\\nO(h) h=height of tree.\\n-----------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3700735/dfs-traversal-c-easy-solution/"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I want someone's insights on my approach. So i tried Level-Order Traversal with BFS using Queue.\n\nIn my 2D vector i have the elements stored in each of my level.\n\nLet us take the 2 examples given in the description\n\nRoot -> [1,2,2,3,4,4,3] \nResulting 2D Vector -> [[1],[2,2],[3,4,4,3]] \n\nRoot -> [1,2,2,null,3,null,3]\nResulting 2D Vector -> [[1],[2,2],[3,3]] \n\nNow I should be working around my 2D Vectors to determine if my tree is symmetric or not.\n\nSo, for every level in my 2D Vector i need to check if the element on the left-most side is equal to the right-most element if they are then i increment my left pointer and decrement my right pointer and do this until my right pointer is less than the left pointer. \n\nFocusing on the 2nd example's resulting 2D Vector i.e. [[1],[2,2],[3,3]] even though my approach would give me the answer that this tree is symmetric about the root node but it is not as both of these 3s are Right Sub Nodes of 2. Therefore giving me wrong answer.\n\nIs there a way i can put 0 in my internal Vector when i do not have a node either on the left of the parent node or on the right of the parent node. That might solve my problem.\n\nAny help is appreciated."
                    },
                    {
                        "username": "vardbabayan",
                        "content": "No, it will lead to Time Limit on big trees"
                    },
                    {
                        "username": "YshxGupta",
                        "content": "How to solve it iteratively ?\\n"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Using BFS Level-Order Traversal with the help of Queues."
                    },
                    {
                        "username": "SLDDL",
                        "content": "Quite funny seeing people saying its too hard, \\nJust do a recursive fonction that switches left and right  starting from the first left node then compare root.left and root.right"
                    },
                    {
                        "username": "jcodes5",
                        "content": "Interesting idea, does anyone know of any applications of symmetric/mirror binary trees?\\n\\nThe first thing that comes to mind is possible space saving hack by only saving one half of the tree, since you know the values of the other half by a change in traversal of the existing side? Can\\'t think of any real-world applications though."
                    },
                    {
                        "username": "aguilakrakatoa",
                        "content": "Should it be Mirror Tree? shouldn\\'t be? it\\'s a bit confusing."
                    }
                ]
            },
            {
                "id": 1930350,
                "content": [
                    {
                        "username": "ashish030899",
                        "content": "If I do inorder traversal and store it in an array and then check if it is palindrome or not . Will it be a good approach ??"
                    },
                    {
                        "username": "Prashanth_Upputuri",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        return symmetric(root.left,root.right);\\n        \\n    }\\n    static boolean symmetric(TreeNode leftroot,TreeNode rightroot){\\n        if(rightroot == null && leftroot == null)\\n          return true;\\n        if(rightroot == null && leftroot != null)\\n          return false;\\n        if(rightroot != null && leftroot == null)\\n          return false;\\n        \\n        return (leftroot.val == rightroot.val)&&symmetric(leftroot.left,rightroot.right)&&symmetric(leftroot.right,rightroot.left);\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dynamic099",
                        "content": "I will say it is kind of a easy medium ."
                    },
                    {
                        "username": "amadouadiah",
                        "content": "NeetCode helped me understand how easy it actually is. You can create a different method that does a Depth First Search on both subtrees at the same time and recursively compares their children nodes."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nDFS Traversal C++ Easy solution \\n\\n--------------------------------------------\\n# Approach\\n\\n1. Define a recursive function `rec` that takes in two `TreeNode` pointers, `l` and `r`, and returns a boolean value.\\n2. Inside the `rec` function:\\n   a. Check if both `l` and `r` are `NULL` (indicating leaf nodes). If true, return `true` as the tree is symmetric at this level.\\n   b. Check if either `l` or `r` is `NULL`, but not both. If true, return `false` as the tree is not symmetric at this level.\\n   c. Check if the values of `l` and `r` are different. If true, return `false` as the tree is not symmetric at this level.\\n   d. Recursively call `rec` with `l->left` and `r->right` as arguments, and check if the subtrees starting from these nodes are symmetric.\\n   e. Recursively call `rec` with `l->right` and `r->left` as arguments, and check if the subtrees starting from these nodes are symmetric.\\n   f. Return the logical AND of the two recursive calls from steps d and e. This indicates whether the left and right subtrees are symmetric.\\n\\n3. Define the function `isSymmetric` that takes in a `TreeNode` pointer `root` and returns a boolean value.\\n4. Inside the `isSymmetric` function:\\n   a. Check if `root` is `NULL`. If true, return `true` as the tree is empty and thus symmetric.\\n   b. Return the result of calling `rec` with `root->left` and `root->right` as arguments. This checks if the entire tree is symmetric.\\n\\n---------------------------------\\n# Complexity\\n- Time complexity:\\nO(n) in worst case we have to visit all nodes. \\n\\n- Space complexity:\\nO(h) h=height of tree.\\n-----------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3700735/dfs-traversal-c-easy-solution/"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I want someone's insights on my approach. So i tried Level-Order Traversal with BFS using Queue.\n\nIn my 2D vector i have the elements stored in each of my level.\n\nLet us take the 2 examples given in the description\n\nRoot -> [1,2,2,3,4,4,3] \nResulting 2D Vector -> [[1],[2,2],[3,4,4,3]] \n\nRoot -> [1,2,2,null,3,null,3]\nResulting 2D Vector -> [[1],[2,2],[3,3]] \n\nNow I should be working around my 2D Vectors to determine if my tree is symmetric or not.\n\nSo, for every level in my 2D Vector i need to check if the element on the left-most side is equal to the right-most element if they are then i increment my left pointer and decrement my right pointer and do this until my right pointer is less than the left pointer. \n\nFocusing on the 2nd example's resulting 2D Vector i.e. [[1],[2,2],[3,3]] even though my approach would give me the answer that this tree is symmetric about the root node but it is not as both of these 3s are Right Sub Nodes of 2. Therefore giving me wrong answer.\n\nIs there a way i can put 0 in my internal Vector when i do not have a node either on the left of the parent node or on the right of the parent node. That might solve my problem.\n\nAny help is appreciated."
                    },
                    {
                        "username": "vardbabayan",
                        "content": "No, it will lead to Time Limit on big trees"
                    },
                    {
                        "username": "YshxGupta",
                        "content": "How to solve it iteratively ?\\n"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Using BFS Level-Order Traversal with the help of Queues."
                    },
                    {
                        "username": "SLDDL",
                        "content": "Quite funny seeing people saying its too hard, \\nJust do a recursive fonction that switches left and right  starting from the first left node then compare root.left and root.right"
                    },
                    {
                        "username": "jcodes5",
                        "content": "Interesting idea, does anyone know of any applications of symmetric/mirror binary trees?\\n\\nThe first thing that comes to mind is possible space saving hack by only saving one half of the tree, since you know the values of the other half by a change in traversal of the existing side? Can\\'t think of any real-world applications though."
                    },
                    {
                        "username": "aguilakrakatoa",
                        "content": "Should it be Mirror Tree? shouldn\\'t be? it\\'s a bit confusing."
                    }
                ]
            },
            {
                "id": 1921348,
                "content": [
                    {
                        "username": "ashish030899",
                        "content": "If I do inorder traversal and store it in an array and then check if it is palindrome or not . Will it be a good approach ??"
                    },
                    {
                        "username": "Prashanth_Upputuri",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        return symmetric(root.left,root.right);\\n        \\n    }\\n    static boolean symmetric(TreeNode leftroot,TreeNode rightroot){\\n        if(rightroot == null && leftroot == null)\\n          return true;\\n        if(rightroot == null && leftroot != null)\\n          return false;\\n        if(rightroot != null && leftroot == null)\\n          return false;\\n        \\n        return (leftroot.val == rightroot.val)&&symmetric(leftroot.left,rightroot.right)&&symmetric(leftroot.right,rightroot.left);\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dynamic099",
                        "content": "I will say it is kind of a easy medium ."
                    },
                    {
                        "username": "amadouadiah",
                        "content": "NeetCode helped me understand how easy it actually is. You can create a different method that does a Depth First Search on both subtrees at the same time and recursively compares their children nodes."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nDFS Traversal C++ Easy solution \\n\\n--------------------------------------------\\n# Approach\\n\\n1. Define a recursive function `rec` that takes in two `TreeNode` pointers, `l` and `r`, and returns a boolean value.\\n2. Inside the `rec` function:\\n   a. Check if both `l` and `r` are `NULL` (indicating leaf nodes). If true, return `true` as the tree is symmetric at this level.\\n   b. Check if either `l` or `r` is `NULL`, but not both. If true, return `false` as the tree is not symmetric at this level.\\n   c. Check if the values of `l` and `r` are different. If true, return `false` as the tree is not symmetric at this level.\\n   d. Recursively call `rec` with `l->left` and `r->right` as arguments, and check if the subtrees starting from these nodes are symmetric.\\n   e. Recursively call `rec` with `l->right` and `r->left` as arguments, and check if the subtrees starting from these nodes are symmetric.\\n   f. Return the logical AND of the two recursive calls from steps d and e. This indicates whether the left and right subtrees are symmetric.\\n\\n3. Define the function `isSymmetric` that takes in a `TreeNode` pointer `root` and returns a boolean value.\\n4. Inside the `isSymmetric` function:\\n   a. Check if `root` is `NULL`. If true, return `true` as the tree is empty and thus symmetric.\\n   b. Return the result of calling `rec` with `root->left` and `root->right` as arguments. This checks if the entire tree is symmetric.\\n\\n---------------------------------\\n# Complexity\\n- Time complexity:\\nO(n) in worst case we have to visit all nodes. \\n\\n- Space complexity:\\nO(h) h=height of tree.\\n-----------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3700735/dfs-traversal-c-easy-solution/"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I want someone's insights on my approach. So i tried Level-Order Traversal with BFS using Queue.\n\nIn my 2D vector i have the elements stored in each of my level.\n\nLet us take the 2 examples given in the description\n\nRoot -> [1,2,2,3,4,4,3] \nResulting 2D Vector -> [[1],[2,2],[3,4,4,3]] \n\nRoot -> [1,2,2,null,3,null,3]\nResulting 2D Vector -> [[1],[2,2],[3,3]] \n\nNow I should be working around my 2D Vectors to determine if my tree is symmetric or not.\n\nSo, for every level in my 2D Vector i need to check if the element on the left-most side is equal to the right-most element if they are then i increment my left pointer and decrement my right pointer and do this until my right pointer is less than the left pointer. \n\nFocusing on the 2nd example's resulting 2D Vector i.e. [[1],[2,2],[3,3]] even though my approach would give me the answer that this tree is symmetric about the root node but it is not as both of these 3s are Right Sub Nodes of 2. Therefore giving me wrong answer.\n\nIs there a way i can put 0 in my internal Vector when i do not have a node either on the left of the parent node or on the right of the parent node. That might solve my problem.\n\nAny help is appreciated."
                    },
                    {
                        "username": "vardbabayan",
                        "content": "No, it will lead to Time Limit on big trees"
                    },
                    {
                        "username": "YshxGupta",
                        "content": "How to solve it iteratively ?\\n"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Using BFS Level-Order Traversal with the help of Queues."
                    },
                    {
                        "username": "SLDDL",
                        "content": "Quite funny seeing people saying its too hard, \\nJust do a recursive fonction that switches left and right  starting from the first left node then compare root.left and root.right"
                    },
                    {
                        "username": "jcodes5",
                        "content": "Interesting idea, does anyone know of any applications of symmetric/mirror binary trees?\\n\\nThe first thing that comes to mind is possible space saving hack by only saving one half of the tree, since you know the values of the other half by a change in traversal of the existing side? Can\\'t think of any real-world applications though."
                    },
                    {
                        "username": "aguilakrakatoa",
                        "content": "Should it be Mirror Tree? shouldn\\'t be? it\\'s a bit confusing."
                    }
                ]
            },
            {
                "id": 1905553,
                "content": [
                    {
                        "username": "ashish030899",
                        "content": "If I do inorder traversal and store it in an array and then check if it is palindrome or not . Will it be a good approach ??"
                    },
                    {
                        "username": "Prashanth_Upputuri",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        return symmetric(root.left,root.right);\\n        \\n    }\\n    static boolean symmetric(TreeNode leftroot,TreeNode rightroot){\\n        if(rightroot == null && leftroot == null)\\n          return true;\\n        if(rightroot == null && leftroot != null)\\n          return false;\\n        if(rightroot != null && leftroot == null)\\n          return false;\\n        \\n        return (leftroot.val == rightroot.val)&&symmetric(leftroot.left,rightroot.right)&&symmetric(leftroot.right,rightroot.left);\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dynamic099",
                        "content": "I will say it is kind of a easy medium ."
                    },
                    {
                        "username": "amadouadiah",
                        "content": "NeetCode helped me understand how easy it actually is. You can create a different method that does a Depth First Search on both subtrees at the same time and recursively compares their children nodes."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nDFS Traversal C++ Easy solution \\n\\n--------------------------------------------\\n# Approach\\n\\n1. Define a recursive function `rec` that takes in two `TreeNode` pointers, `l` and `r`, and returns a boolean value.\\n2. Inside the `rec` function:\\n   a. Check if both `l` and `r` are `NULL` (indicating leaf nodes). If true, return `true` as the tree is symmetric at this level.\\n   b. Check if either `l` or `r` is `NULL`, but not both. If true, return `false` as the tree is not symmetric at this level.\\n   c. Check if the values of `l` and `r` are different. If true, return `false` as the tree is not symmetric at this level.\\n   d. Recursively call `rec` with `l->left` and `r->right` as arguments, and check if the subtrees starting from these nodes are symmetric.\\n   e. Recursively call `rec` with `l->right` and `r->left` as arguments, and check if the subtrees starting from these nodes are symmetric.\\n   f. Return the logical AND of the two recursive calls from steps d and e. This indicates whether the left and right subtrees are symmetric.\\n\\n3. Define the function `isSymmetric` that takes in a `TreeNode` pointer `root` and returns a boolean value.\\n4. Inside the `isSymmetric` function:\\n   a. Check if `root` is `NULL`. If true, return `true` as the tree is empty and thus symmetric.\\n   b. Return the result of calling `rec` with `root->left` and `root->right` as arguments. This checks if the entire tree is symmetric.\\n\\n---------------------------------\\n# Complexity\\n- Time complexity:\\nO(n) in worst case we have to visit all nodes. \\n\\n- Space complexity:\\nO(h) h=height of tree.\\n-----------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3700735/dfs-traversal-c-easy-solution/"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I want someone's insights on my approach. So i tried Level-Order Traversal with BFS using Queue.\n\nIn my 2D vector i have the elements stored in each of my level.\n\nLet us take the 2 examples given in the description\n\nRoot -> [1,2,2,3,4,4,3] \nResulting 2D Vector -> [[1],[2,2],[3,4,4,3]] \n\nRoot -> [1,2,2,null,3,null,3]\nResulting 2D Vector -> [[1],[2,2],[3,3]] \n\nNow I should be working around my 2D Vectors to determine if my tree is symmetric or not.\n\nSo, for every level in my 2D Vector i need to check if the element on the left-most side is equal to the right-most element if they are then i increment my left pointer and decrement my right pointer and do this until my right pointer is less than the left pointer. \n\nFocusing on the 2nd example's resulting 2D Vector i.e. [[1],[2,2],[3,3]] even though my approach would give me the answer that this tree is symmetric about the root node but it is not as both of these 3s are Right Sub Nodes of 2. Therefore giving me wrong answer.\n\nIs there a way i can put 0 in my internal Vector when i do not have a node either on the left of the parent node or on the right of the parent node. That might solve my problem.\n\nAny help is appreciated."
                    },
                    {
                        "username": "vardbabayan",
                        "content": "No, it will lead to Time Limit on big trees"
                    },
                    {
                        "username": "YshxGupta",
                        "content": "How to solve it iteratively ?\\n"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Using BFS Level-Order Traversal with the help of Queues."
                    },
                    {
                        "username": "SLDDL",
                        "content": "Quite funny seeing people saying its too hard, \\nJust do a recursive fonction that switches left and right  starting from the first left node then compare root.left and root.right"
                    },
                    {
                        "username": "jcodes5",
                        "content": "Interesting idea, does anyone know of any applications of symmetric/mirror binary trees?\\n\\nThe first thing that comes to mind is possible space saving hack by only saving one half of the tree, since you know the values of the other half by a change in traversal of the existing side? Can\\'t think of any real-world applications though."
                    },
                    {
                        "username": "aguilakrakatoa",
                        "content": "Should it be Mirror Tree? shouldn\\'t be? it\\'s a bit confusing."
                    }
                ]
            },
            {
                "id": 1896306,
                "content": [
                    {
                        "username": "ashish030899",
                        "content": "If I do inorder traversal and store it in an array and then check if it is palindrome or not . Will it be a good approach ??"
                    },
                    {
                        "username": "Prashanth_Upputuri",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        return symmetric(root.left,root.right);\\n        \\n    }\\n    static boolean symmetric(TreeNode leftroot,TreeNode rightroot){\\n        if(rightroot == null && leftroot == null)\\n          return true;\\n        if(rightroot == null && leftroot != null)\\n          return false;\\n        if(rightroot != null && leftroot == null)\\n          return false;\\n        \\n        return (leftroot.val == rightroot.val)&&symmetric(leftroot.left,rightroot.right)&&symmetric(leftroot.right,rightroot.left);\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dynamic099",
                        "content": "I will say it is kind of a easy medium ."
                    },
                    {
                        "username": "amadouadiah",
                        "content": "NeetCode helped me understand how easy it actually is. You can create a different method that does a Depth First Search on both subtrees at the same time and recursively compares their children nodes."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nDFS Traversal C++ Easy solution \\n\\n--------------------------------------------\\n# Approach\\n\\n1. Define a recursive function `rec` that takes in two `TreeNode` pointers, `l` and `r`, and returns a boolean value.\\n2. Inside the `rec` function:\\n   a. Check if both `l` and `r` are `NULL` (indicating leaf nodes). If true, return `true` as the tree is symmetric at this level.\\n   b. Check if either `l` or `r` is `NULL`, but not both. If true, return `false` as the tree is not symmetric at this level.\\n   c. Check if the values of `l` and `r` are different. If true, return `false` as the tree is not symmetric at this level.\\n   d. Recursively call `rec` with `l->left` and `r->right` as arguments, and check if the subtrees starting from these nodes are symmetric.\\n   e. Recursively call `rec` with `l->right` and `r->left` as arguments, and check if the subtrees starting from these nodes are symmetric.\\n   f. Return the logical AND of the two recursive calls from steps d and e. This indicates whether the left and right subtrees are symmetric.\\n\\n3. Define the function `isSymmetric` that takes in a `TreeNode` pointer `root` and returns a boolean value.\\n4. Inside the `isSymmetric` function:\\n   a. Check if `root` is `NULL`. If true, return `true` as the tree is empty and thus symmetric.\\n   b. Return the result of calling `rec` with `root->left` and `root->right` as arguments. This checks if the entire tree is symmetric.\\n\\n---------------------------------\\n# Complexity\\n- Time complexity:\\nO(n) in worst case we have to visit all nodes. \\n\\n- Space complexity:\\nO(h) h=height of tree.\\n-----------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3700735/dfs-traversal-c-easy-solution/"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I want someone's insights on my approach. So i tried Level-Order Traversal with BFS using Queue.\n\nIn my 2D vector i have the elements stored in each of my level.\n\nLet us take the 2 examples given in the description\n\nRoot -> [1,2,2,3,4,4,3] \nResulting 2D Vector -> [[1],[2,2],[3,4,4,3]] \n\nRoot -> [1,2,2,null,3,null,3]\nResulting 2D Vector -> [[1],[2,2],[3,3]] \n\nNow I should be working around my 2D Vectors to determine if my tree is symmetric or not.\n\nSo, for every level in my 2D Vector i need to check if the element on the left-most side is equal to the right-most element if they are then i increment my left pointer and decrement my right pointer and do this until my right pointer is less than the left pointer. \n\nFocusing on the 2nd example's resulting 2D Vector i.e. [[1],[2,2],[3,3]] even though my approach would give me the answer that this tree is symmetric about the root node but it is not as both of these 3s are Right Sub Nodes of 2. Therefore giving me wrong answer.\n\nIs there a way i can put 0 in my internal Vector when i do not have a node either on the left of the parent node or on the right of the parent node. That might solve my problem.\n\nAny help is appreciated."
                    },
                    {
                        "username": "vardbabayan",
                        "content": "No, it will lead to Time Limit on big trees"
                    },
                    {
                        "username": "YshxGupta",
                        "content": "How to solve it iteratively ?\\n"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Using BFS Level-Order Traversal with the help of Queues."
                    },
                    {
                        "username": "SLDDL",
                        "content": "Quite funny seeing people saying its too hard, \\nJust do a recursive fonction that switches left and right  starting from the first left node then compare root.left and root.right"
                    },
                    {
                        "username": "jcodes5",
                        "content": "Interesting idea, does anyone know of any applications of symmetric/mirror binary trees?\\n\\nThe first thing that comes to mind is possible space saving hack by only saving one half of the tree, since you know the values of the other half by a change in traversal of the existing side? Can\\'t think of any real-world applications though."
                    },
                    {
                        "username": "aguilakrakatoa",
                        "content": "Should it be Mirror Tree? shouldn\\'t be? it\\'s a bit confusing."
                    }
                ]
            },
            {
                "id": 1894040,
                "content": [
                    {
                        "username": "ashish030899",
                        "content": "If I do inorder traversal and store it in an array and then check if it is palindrome or not . Will it be a good approach ??"
                    },
                    {
                        "username": "Prashanth_Upputuri",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        return symmetric(root.left,root.right);\\n        \\n    }\\n    static boolean symmetric(TreeNode leftroot,TreeNode rightroot){\\n        if(rightroot == null && leftroot == null)\\n          return true;\\n        if(rightroot == null && leftroot != null)\\n          return false;\\n        if(rightroot != null && leftroot == null)\\n          return false;\\n        \\n        return (leftroot.val == rightroot.val)&&symmetric(leftroot.left,rightroot.right)&&symmetric(leftroot.right,rightroot.left);\\n\\n\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "dynamic099",
                        "content": "I will say it is kind of a easy medium ."
                    },
                    {
                        "username": "amadouadiah",
                        "content": "NeetCode helped me understand how easy it actually is. You can create a different method that does a Depth First Search on both subtrees at the same time and recursively compares their children nodes."
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nDFS Traversal C++ Easy solution \\n\\n--------------------------------------------\\n# Approach\\n\\n1. Define a recursive function `rec` that takes in two `TreeNode` pointers, `l` and `r`, and returns a boolean value.\\n2. Inside the `rec` function:\\n   a. Check if both `l` and `r` are `NULL` (indicating leaf nodes). If true, return `true` as the tree is symmetric at this level.\\n   b. Check if either `l` or `r` is `NULL`, but not both. If true, return `false` as the tree is not symmetric at this level.\\n   c. Check if the values of `l` and `r` are different. If true, return `false` as the tree is not symmetric at this level.\\n   d. Recursively call `rec` with `l->left` and `r->right` as arguments, and check if the subtrees starting from these nodes are symmetric.\\n   e. Recursively call `rec` with `l->right` and `r->left` as arguments, and check if the subtrees starting from these nodes are symmetric.\\n   f. Return the logical AND of the two recursive calls from steps d and e. This indicates whether the left and right subtrees are symmetric.\\n\\n3. Define the function `isSymmetric` that takes in a `TreeNode` pointer `root` and returns a boolean value.\\n4. Inside the `isSymmetric` function:\\n   a. Check if `root` is `NULL`. If true, return `true` as the tree is empty and thus symmetric.\\n   b. Return the result of calling `rec` with `root->left` and `root->right` as arguments. This checks if the entire tree is symmetric.\\n\\n---------------------------------\\n# Complexity\\n- Time complexity:\\nO(n) in worst case we have to visit all nodes. \\n\\n- Space complexity:\\nO(h) h=height of tree.\\n-----------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/symmetric-tree/solutions/3700735/dfs-traversal-c-easy-solution/"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "I want someone's insights on my approach. So i tried Level-Order Traversal with BFS using Queue.\n\nIn my 2D vector i have the elements stored in each of my level.\n\nLet us take the 2 examples given in the description\n\nRoot -> [1,2,2,3,4,4,3] \nResulting 2D Vector -> [[1],[2,2],[3,4,4,3]] \n\nRoot -> [1,2,2,null,3,null,3]\nResulting 2D Vector -> [[1],[2,2],[3,3]] \n\nNow I should be working around my 2D Vectors to determine if my tree is symmetric or not.\n\nSo, for every level in my 2D Vector i need to check if the element on the left-most side is equal to the right-most element if they are then i increment my left pointer and decrement my right pointer and do this until my right pointer is less than the left pointer. \n\nFocusing on the 2nd example's resulting 2D Vector i.e. [[1],[2,2],[3,3]] even though my approach would give me the answer that this tree is symmetric about the root node but it is not as both of these 3s are Right Sub Nodes of 2. Therefore giving me wrong answer.\n\nIs there a way i can put 0 in my internal Vector when i do not have a node either on the left of the parent node or on the right of the parent node. That might solve my problem.\n\nAny help is appreciated."
                    },
                    {
                        "username": "vardbabayan",
                        "content": "No, it will lead to Time Limit on big trees"
                    },
                    {
                        "username": "YshxGupta",
                        "content": "How to solve it iteratively ?\\n"
                    },
                    {
                        "username": "aakashsrh",
                        "content": "Using BFS Level-Order Traversal with the help of Queues."
                    },
                    {
                        "username": "SLDDL",
                        "content": "Quite funny seeing people saying its too hard, \\nJust do a recursive fonction that switches left and right  starting from the first left node then compare root.left and root.right"
                    },
                    {
                        "username": "jcodes5",
                        "content": "Interesting idea, does anyone know of any applications of symmetric/mirror binary trees?\\n\\nThe first thing that comes to mind is possible space saving hack by only saving one half of the tree, since you know the values of the other half by a change in traversal of the existing side? Can\\'t think of any real-world applications though."
                    },
                    {
                        "username": "aguilakrakatoa",
                        "content": "Should it be Mirror Tree? shouldn\\'t be? it\\'s a bit confusing."
                    }
                ]
            },
            {
                "id": 1881616,
                "content": [
                    {
                        "username": "ShivamSingh101",
                        "content": "this is simple problem and same to  two tree are identical or not\nsame logic appiled to  (root->left and root->right)\n"
                    },
                    {
                        "username": "alprose11",
                        "content": "how to do it iteratively?"
                    },
                    {
                        "username": "vardbabayan",
                        "content": "[@silentgeek6](/silentgeek6) yes, it will definitely help\\njust do only tree section and practice DFS/BSF aproaches"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "How to do it recursively iteratively is easier to think but i am unable to think recurively  what do you think is practicing different types of question will help me to be good solving tree questions?"
                    },
                    {
                        "username": "arf01",
                        "content": "[1,2,2,2,null,2]   can anyone draw me this tree,please??"
                    },
                    {
                        "username": "hrishyak17",
                        "content": "I am trying to solve the question using level order traversal.\\ni am storing each level elements in a vector and checking if they are palindromic , if no return false else continue.\\nI got wrong answer in this test case:-\\nInput\\nroot =\\n[1,2,2,null,3,null,3]\\nOutput\\ntrue\\nExpected\\nfalse\\n\\n Anyone please help me out where i gone wrong .\\nAnd my code is below: \\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint height(TreeNode*root){\\n    if(root==NULL)return 0;\\n    else{\\n       int lheight =height(root->left);\\n       int rheight=height(root->right);\\n       if(lheight>rheight)return lheight+1;\\n       else return rheight+1;\\n    }\\n}\\nvoid currentLevel(TreeNode*root,int level,vector<int>&v){\\n            if(root==NULL)v.push_back(101);\\n\\n    if(level==1){\\n        v.push_back(root->val);\\n    }\\n    if(level>1){\\n        currentLevel(root->left,level-1,v);\\n        currentLevel(root->right,level-1,v);\\n    }\\n   \\n}\\n\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==NULL)return true;\\n        int h=height(root);\\n        for(int i=1;i<h;i++){\\n            vector<int>v;\\n            currentLevel(root,i,v);\\n            for(int j=0;j<v.size()/2;j++){\\n                if(v[j]!=v[v.size()-1-j])return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "geekyshubh",
                        "content": "How is this an easy question? :\\'( \\nPlease dont break my spirit leetcode."
                    },
                    {
                        "username": "rohitaharwar2003",
                        "content": "binary tree  queue"
                    },
                    {
                        "username": "Ardonite",
                        "content": "I am trying to perform Inorder traversal for entire tree and checking the equality of original list vs reversed list. It failed for 4 test cases. Could anyone achieve 100% test cases success using inorder traversal and let me know what I am missing "
                    },
                    {
                        "username": "eduard92",
                        "content": "I am new to Trees and I feel like I hit my first wall on Leetcode.\\nBut this question I think I can solve it by splitting the tree in two trees, left and right, and go with both Inorder, left and right "
                    },
                    {
                        "username": "kennyhml",
                        "content": "The trick is to break the tree down into two seperate trees and then perform checks for the value, but mirror the direction."
                    },
                    {
                        "username": "hammeramr",
                        "content": "Any hints for non recursive solution? I solved it recursively.\n\nPlease dont give the answer or recipe just want a hint - thanks "
                    },
                    {
                        "username": "raimundo82",
                        "content": "it dependes the solution u have in mind...for instance, u can iterate through the left tree and the right tree simultaneously, (since there is a direct relation between both) and take the conclusions"
                    }
                ]
            },
            {
                "id": 1881260,
                "content": [
                    {
                        "username": "ShivamSingh101",
                        "content": "this is simple problem and same to  two tree are identical or not\nsame logic appiled to  (root->left and root->right)\n"
                    },
                    {
                        "username": "alprose11",
                        "content": "how to do it iteratively?"
                    },
                    {
                        "username": "vardbabayan",
                        "content": "[@silentgeek6](/silentgeek6) yes, it will definitely help\\njust do only tree section and practice DFS/BSF aproaches"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "How to do it recursively iteratively is easier to think but i am unable to think recurively  what do you think is practicing different types of question will help me to be good solving tree questions?"
                    },
                    {
                        "username": "arf01",
                        "content": "[1,2,2,2,null,2]   can anyone draw me this tree,please??"
                    },
                    {
                        "username": "hrishyak17",
                        "content": "I am trying to solve the question using level order traversal.\\ni am storing each level elements in a vector and checking if they are palindromic , if no return false else continue.\\nI got wrong answer in this test case:-\\nInput\\nroot =\\n[1,2,2,null,3,null,3]\\nOutput\\ntrue\\nExpected\\nfalse\\n\\n Anyone please help me out where i gone wrong .\\nAnd my code is below: \\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint height(TreeNode*root){\\n    if(root==NULL)return 0;\\n    else{\\n       int lheight =height(root->left);\\n       int rheight=height(root->right);\\n       if(lheight>rheight)return lheight+1;\\n       else return rheight+1;\\n    }\\n}\\nvoid currentLevel(TreeNode*root,int level,vector<int>&v){\\n            if(root==NULL)v.push_back(101);\\n\\n    if(level==1){\\n        v.push_back(root->val);\\n    }\\n    if(level>1){\\n        currentLevel(root->left,level-1,v);\\n        currentLevel(root->right,level-1,v);\\n    }\\n   \\n}\\n\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==NULL)return true;\\n        int h=height(root);\\n        for(int i=1;i<h;i++){\\n            vector<int>v;\\n            currentLevel(root,i,v);\\n            for(int j=0;j<v.size()/2;j++){\\n                if(v[j]!=v[v.size()-1-j])return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "geekyshubh",
                        "content": "How is this an easy question? :\\'( \\nPlease dont break my spirit leetcode."
                    },
                    {
                        "username": "rohitaharwar2003",
                        "content": "binary tree  queue"
                    },
                    {
                        "username": "Ardonite",
                        "content": "I am trying to perform Inorder traversal for entire tree and checking the equality of original list vs reversed list. It failed for 4 test cases. Could anyone achieve 100% test cases success using inorder traversal and let me know what I am missing "
                    },
                    {
                        "username": "eduard92",
                        "content": "I am new to Trees and I feel like I hit my first wall on Leetcode.\\nBut this question I think I can solve it by splitting the tree in two trees, left and right, and go with both Inorder, left and right "
                    },
                    {
                        "username": "kennyhml",
                        "content": "The trick is to break the tree down into two seperate trees and then perform checks for the value, but mirror the direction."
                    },
                    {
                        "username": "hammeramr",
                        "content": "Any hints for non recursive solution? I solved it recursively.\n\nPlease dont give the answer or recipe just want a hint - thanks "
                    },
                    {
                        "username": "raimundo82",
                        "content": "it dependes the solution u have in mind...for instance, u can iterate through the left tree and the right tree simultaneously, (since there is a direct relation between both) and take the conclusions"
                    }
                ]
            },
            {
                "id": 1867453,
                "content": [
                    {
                        "username": "ShivamSingh101",
                        "content": "this is simple problem and same to  two tree are identical or not\nsame logic appiled to  (root->left and root->right)\n"
                    },
                    {
                        "username": "alprose11",
                        "content": "how to do it iteratively?"
                    },
                    {
                        "username": "vardbabayan",
                        "content": "[@silentgeek6](/silentgeek6) yes, it will definitely help\\njust do only tree section and practice DFS/BSF aproaches"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "How to do it recursively iteratively is easier to think but i am unable to think recurively  what do you think is practicing different types of question will help me to be good solving tree questions?"
                    },
                    {
                        "username": "arf01",
                        "content": "[1,2,2,2,null,2]   can anyone draw me this tree,please??"
                    },
                    {
                        "username": "hrishyak17",
                        "content": "I am trying to solve the question using level order traversal.\\ni am storing each level elements in a vector and checking if they are palindromic , if no return false else continue.\\nI got wrong answer in this test case:-\\nInput\\nroot =\\n[1,2,2,null,3,null,3]\\nOutput\\ntrue\\nExpected\\nfalse\\n\\n Anyone please help me out where i gone wrong .\\nAnd my code is below: \\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint height(TreeNode*root){\\n    if(root==NULL)return 0;\\n    else{\\n       int lheight =height(root->left);\\n       int rheight=height(root->right);\\n       if(lheight>rheight)return lheight+1;\\n       else return rheight+1;\\n    }\\n}\\nvoid currentLevel(TreeNode*root,int level,vector<int>&v){\\n            if(root==NULL)v.push_back(101);\\n\\n    if(level==1){\\n        v.push_back(root->val);\\n    }\\n    if(level>1){\\n        currentLevel(root->left,level-1,v);\\n        currentLevel(root->right,level-1,v);\\n    }\\n   \\n}\\n\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==NULL)return true;\\n        int h=height(root);\\n        for(int i=1;i<h;i++){\\n            vector<int>v;\\n            currentLevel(root,i,v);\\n            for(int j=0;j<v.size()/2;j++){\\n                if(v[j]!=v[v.size()-1-j])return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "geekyshubh",
                        "content": "How is this an easy question? :\\'( \\nPlease dont break my spirit leetcode."
                    },
                    {
                        "username": "rohitaharwar2003",
                        "content": "binary tree  queue"
                    },
                    {
                        "username": "Ardonite",
                        "content": "I am trying to perform Inorder traversal for entire tree and checking the equality of original list vs reversed list. It failed for 4 test cases. Could anyone achieve 100% test cases success using inorder traversal and let me know what I am missing "
                    },
                    {
                        "username": "eduard92",
                        "content": "I am new to Trees and I feel like I hit my first wall on Leetcode.\\nBut this question I think I can solve it by splitting the tree in two trees, left and right, and go with both Inorder, left and right "
                    },
                    {
                        "username": "kennyhml",
                        "content": "The trick is to break the tree down into two seperate trees and then perform checks for the value, but mirror the direction."
                    },
                    {
                        "username": "hammeramr",
                        "content": "Any hints for non recursive solution? I solved it recursively.\n\nPlease dont give the answer or recipe just want a hint - thanks "
                    },
                    {
                        "username": "raimundo82",
                        "content": "it dependes the solution u have in mind...for instance, u can iterate through the left tree and the right tree simultaneously, (since there is a direct relation between both) and take the conclusions"
                    }
                ]
            },
            {
                "id": 1863134,
                "content": [
                    {
                        "username": "ShivamSingh101",
                        "content": "this is simple problem and same to  two tree are identical or not\nsame logic appiled to  (root->left and root->right)\n"
                    },
                    {
                        "username": "alprose11",
                        "content": "how to do it iteratively?"
                    },
                    {
                        "username": "vardbabayan",
                        "content": "[@silentgeek6](/silentgeek6) yes, it will definitely help\\njust do only tree section and practice DFS/BSF aproaches"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "How to do it recursively iteratively is easier to think but i am unable to think recurively  what do you think is practicing different types of question will help me to be good solving tree questions?"
                    },
                    {
                        "username": "arf01",
                        "content": "[1,2,2,2,null,2]   can anyone draw me this tree,please??"
                    },
                    {
                        "username": "hrishyak17",
                        "content": "I am trying to solve the question using level order traversal.\\ni am storing each level elements in a vector and checking if they are palindromic , if no return false else continue.\\nI got wrong answer in this test case:-\\nInput\\nroot =\\n[1,2,2,null,3,null,3]\\nOutput\\ntrue\\nExpected\\nfalse\\n\\n Anyone please help me out where i gone wrong .\\nAnd my code is below: \\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint height(TreeNode*root){\\n    if(root==NULL)return 0;\\n    else{\\n       int lheight =height(root->left);\\n       int rheight=height(root->right);\\n       if(lheight>rheight)return lheight+1;\\n       else return rheight+1;\\n    }\\n}\\nvoid currentLevel(TreeNode*root,int level,vector<int>&v){\\n            if(root==NULL)v.push_back(101);\\n\\n    if(level==1){\\n        v.push_back(root->val);\\n    }\\n    if(level>1){\\n        currentLevel(root->left,level-1,v);\\n        currentLevel(root->right,level-1,v);\\n    }\\n   \\n}\\n\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==NULL)return true;\\n        int h=height(root);\\n        for(int i=1;i<h;i++){\\n            vector<int>v;\\n            currentLevel(root,i,v);\\n            for(int j=0;j<v.size()/2;j++){\\n                if(v[j]!=v[v.size()-1-j])return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "geekyshubh",
                        "content": "How is this an easy question? :\\'( \\nPlease dont break my spirit leetcode."
                    },
                    {
                        "username": "rohitaharwar2003",
                        "content": "binary tree  queue"
                    },
                    {
                        "username": "Ardonite",
                        "content": "I am trying to perform Inorder traversal for entire tree and checking the equality of original list vs reversed list. It failed for 4 test cases. Could anyone achieve 100% test cases success using inorder traversal and let me know what I am missing "
                    },
                    {
                        "username": "eduard92",
                        "content": "I am new to Trees and I feel like I hit my first wall on Leetcode.\\nBut this question I think I can solve it by splitting the tree in two trees, left and right, and go with both Inorder, left and right "
                    },
                    {
                        "username": "kennyhml",
                        "content": "The trick is to break the tree down into two seperate trees and then perform checks for the value, but mirror the direction."
                    },
                    {
                        "username": "hammeramr",
                        "content": "Any hints for non recursive solution? I solved it recursively.\n\nPlease dont give the answer or recipe just want a hint - thanks "
                    },
                    {
                        "username": "raimundo82",
                        "content": "it dependes the solution u have in mind...for instance, u can iterate through the left tree and the right tree simultaneously, (since there is a direct relation between both) and take the conclusions"
                    }
                ]
            },
            {
                "id": 1858893,
                "content": [
                    {
                        "username": "ShivamSingh101",
                        "content": "this is simple problem and same to  two tree are identical or not\nsame logic appiled to  (root->left and root->right)\n"
                    },
                    {
                        "username": "alprose11",
                        "content": "how to do it iteratively?"
                    },
                    {
                        "username": "vardbabayan",
                        "content": "[@silentgeek6](/silentgeek6) yes, it will definitely help\\njust do only tree section and practice DFS/BSF aproaches"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "How to do it recursively iteratively is easier to think but i am unable to think recurively  what do you think is practicing different types of question will help me to be good solving tree questions?"
                    },
                    {
                        "username": "arf01",
                        "content": "[1,2,2,2,null,2]   can anyone draw me this tree,please??"
                    },
                    {
                        "username": "hrishyak17",
                        "content": "I am trying to solve the question using level order traversal.\\ni am storing each level elements in a vector and checking if they are palindromic , if no return false else continue.\\nI got wrong answer in this test case:-\\nInput\\nroot =\\n[1,2,2,null,3,null,3]\\nOutput\\ntrue\\nExpected\\nfalse\\n\\n Anyone please help me out where i gone wrong .\\nAnd my code is below: \\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint height(TreeNode*root){\\n    if(root==NULL)return 0;\\n    else{\\n       int lheight =height(root->left);\\n       int rheight=height(root->right);\\n       if(lheight>rheight)return lheight+1;\\n       else return rheight+1;\\n    }\\n}\\nvoid currentLevel(TreeNode*root,int level,vector<int>&v){\\n            if(root==NULL)v.push_back(101);\\n\\n    if(level==1){\\n        v.push_back(root->val);\\n    }\\n    if(level>1){\\n        currentLevel(root->left,level-1,v);\\n        currentLevel(root->right,level-1,v);\\n    }\\n   \\n}\\n\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==NULL)return true;\\n        int h=height(root);\\n        for(int i=1;i<h;i++){\\n            vector<int>v;\\n            currentLevel(root,i,v);\\n            for(int j=0;j<v.size()/2;j++){\\n                if(v[j]!=v[v.size()-1-j])return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "geekyshubh",
                        "content": "How is this an easy question? :\\'( \\nPlease dont break my spirit leetcode."
                    },
                    {
                        "username": "rohitaharwar2003",
                        "content": "binary tree  queue"
                    },
                    {
                        "username": "Ardonite",
                        "content": "I am trying to perform Inorder traversal for entire tree and checking the equality of original list vs reversed list. It failed for 4 test cases. Could anyone achieve 100% test cases success using inorder traversal and let me know what I am missing "
                    },
                    {
                        "username": "eduard92",
                        "content": "I am new to Trees and I feel like I hit my first wall on Leetcode.\\nBut this question I think I can solve it by splitting the tree in two trees, left and right, and go with both Inorder, left and right "
                    },
                    {
                        "username": "kennyhml",
                        "content": "The trick is to break the tree down into two seperate trees and then perform checks for the value, but mirror the direction."
                    },
                    {
                        "username": "hammeramr",
                        "content": "Any hints for non recursive solution? I solved it recursively.\n\nPlease dont give the answer or recipe just want a hint - thanks "
                    },
                    {
                        "username": "raimundo82",
                        "content": "it dependes the solution u have in mind...for instance, u can iterate through the left tree and the right tree simultaneously, (since there is a direct relation between both) and take the conclusions"
                    }
                ]
            },
            {
                "id": 1852928,
                "content": [
                    {
                        "username": "ShivamSingh101",
                        "content": "this is simple problem and same to  two tree are identical or not\nsame logic appiled to  (root->left and root->right)\n"
                    },
                    {
                        "username": "alprose11",
                        "content": "how to do it iteratively?"
                    },
                    {
                        "username": "vardbabayan",
                        "content": "[@silentgeek6](/silentgeek6) yes, it will definitely help\\njust do only tree section and practice DFS/BSF aproaches"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "How to do it recursively iteratively is easier to think but i am unable to think recurively  what do you think is practicing different types of question will help me to be good solving tree questions?"
                    },
                    {
                        "username": "arf01",
                        "content": "[1,2,2,2,null,2]   can anyone draw me this tree,please??"
                    },
                    {
                        "username": "hrishyak17",
                        "content": "I am trying to solve the question using level order traversal.\\ni am storing each level elements in a vector and checking if they are palindromic , if no return false else continue.\\nI got wrong answer in this test case:-\\nInput\\nroot =\\n[1,2,2,null,3,null,3]\\nOutput\\ntrue\\nExpected\\nfalse\\n\\n Anyone please help me out where i gone wrong .\\nAnd my code is below: \\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint height(TreeNode*root){\\n    if(root==NULL)return 0;\\n    else{\\n       int lheight =height(root->left);\\n       int rheight=height(root->right);\\n       if(lheight>rheight)return lheight+1;\\n       else return rheight+1;\\n    }\\n}\\nvoid currentLevel(TreeNode*root,int level,vector<int>&v){\\n            if(root==NULL)v.push_back(101);\\n\\n    if(level==1){\\n        v.push_back(root->val);\\n    }\\n    if(level>1){\\n        currentLevel(root->left,level-1,v);\\n        currentLevel(root->right,level-1,v);\\n    }\\n   \\n}\\n\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==NULL)return true;\\n        int h=height(root);\\n        for(int i=1;i<h;i++){\\n            vector<int>v;\\n            currentLevel(root,i,v);\\n            for(int j=0;j<v.size()/2;j++){\\n                if(v[j]!=v[v.size()-1-j])return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "geekyshubh",
                        "content": "How is this an easy question? :\\'( \\nPlease dont break my spirit leetcode."
                    },
                    {
                        "username": "rohitaharwar2003",
                        "content": "binary tree  queue"
                    },
                    {
                        "username": "Ardonite",
                        "content": "I am trying to perform Inorder traversal for entire tree and checking the equality of original list vs reversed list. It failed for 4 test cases. Could anyone achieve 100% test cases success using inorder traversal and let me know what I am missing "
                    },
                    {
                        "username": "eduard92",
                        "content": "I am new to Trees and I feel like I hit my first wall on Leetcode.\\nBut this question I think I can solve it by splitting the tree in two trees, left and right, and go with both Inorder, left and right "
                    },
                    {
                        "username": "kennyhml",
                        "content": "The trick is to break the tree down into two seperate trees and then perform checks for the value, but mirror the direction."
                    },
                    {
                        "username": "hammeramr",
                        "content": "Any hints for non recursive solution? I solved it recursively.\n\nPlease dont give the answer or recipe just want a hint - thanks "
                    },
                    {
                        "username": "raimundo82",
                        "content": "it dependes the solution u have in mind...for instance, u can iterate through the left tree and the right tree simultaneously, (since there is a direct relation between both) and take the conclusions"
                    }
                ]
            },
            {
                "id": 1844478,
                "content": [
                    {
                        "username": "ShivamSingh101",
                        "content": "this is simple problem and same to  two tree are identical or not\nsame logic appiled to  (root->left and root->right)\n"
                    },
                    {
                        "username": "alprose11",
                        "content": "how to do it iteratively?"
                    },
                    {
                        "username": "vardbabayan",
                        "content": "[@silentgeek6](/silentgeek6) yes, it will definitely help\\njust do only tree section and practice DFS/BSF aproaches"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "How to do it recursively iteratively is easier to think but i am unable to think recurively  what do you think is practicing different types of question will help me to be good solving tree questions?"
                    },
                    {
                        "username": "arf01",
                        "content": "[1,2,2,2,null,2]   can anyone draw me this tree,please??"
                    },
                    {
                        "username": "hrishyak17",
                        "content": "I am trying to solve the question using level order traversal.\\ni am storing each level elements in a vector and checking if they are palindromic , if no return false else continue.\\nI got wrong answer in this test case:-\\nInput\\nroot =\\n[1,2,2,null,3,null,3]\\nOutput\\ntrue\\nExpected\\nfalse\\n\\n Anyone please help me out where i gone wrong .\\nAnd my code is below: \\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint height(TreeNode*root){\\n    if(root==NULL)return 0;\\n    else{\\n       int lheight =height(root->left);\\n       int rheight=height(root->right);\\n       if(lheight>rheight)return lheight+1;\\n       else return rheight+1;\\n    }\\n}\\nvoid currentLevel(TreeNode*root,int level,vector<int>&v){\\n            if(root==NULL)v.push_back(101);\\n\\n    if(level==1){\\n        v.push_back(root->val);\\n    }\\n    if(level>1){\\n        currentLevel(root->left,level-1,v);\\n        currentLevel(root->right,level-1,v);\\n    }\\n   \\n}\\n\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==NULL)return true;\\n        int h=height(root);\\n        for(int i=1;i<h;i++){\\n            vector<int>v;\\n            currentLevel(root,i,v);\\n            for(int j=0;j<v.size()/2;j++){\\n                if(v[j]!=v[v.size()-1-j])return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "geekyshubh",
                        "content": "How is this an easy question? :\\'( \\nPlease dont break my spirit leetcode."
                    },
                    {
                        "username": "rohitaharwar2003",
                        "content": "binary tree  queue"
                    },
                    {
                        "username": "Ardonite",
                        "content": "I am trying to perform Inorder traversal for entire tree and checking the equality of original list vs reversed list. It failed for 4 test cases. Could anyone achieve 100% test cases success using inorder traversal and let me know what I am missing "
                    },
                    {
                        "username": "eduard92",
                        "content": "I am new to Trees and I feel like I hit my first wall on Leetcode.\\nBut this question I think I can solve it by splitting the tree in two trees, left and right, and go with both Inorder, left and right "
                    },
                    {
                        "username": "kennyhml",
                        "content": "The trick is to break the tree down into two seperate trees and then perform checks for the value, but mirror the direction."
                    },
                    {
                        "username": "hammeramr",
                        "content": "Any hints for non recursive solution? I solved it recursively.\n\nPlease dont give the answer or recipe just want a hint - thanks "
                    },
                    {
                        "username": "raimundo82",
                        "content": "it dependes the solution u have in mind...for instance, u can iterate through the left tree and the right tree simultaneously, (since there is a direct relation between both) and take the conclusions"
                    }
                ]
            },
            {
                "id": 1840628,
                "content": [
                    {
                        "username": "ShivamSingh101",
                        "content": "this is simple problem and same to  two tree are identical or not\nsame logic appiled to  (root->left and root->right)\n"
                    },
                    {
                        "username": "alprose11",
                        "content": "how to do it iteratively?"
                    },
                    {
                        "username": "vardbabayan",
                        "content": "[@silentgeek6](/silentgeek6) yes, it will definitely help\\njust do only tree section and practice DFS/BSF aproaches"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "How to do it recursively iteratively is easier to think but i am unable to think recurively  what do you think is practicing different types of question will help me to be good solving tree questions?"
                    },
                    {
                        "username": "arf01",
                        "content": "[1,2,2,2,null,2]   can anyone draw me this tree,please??"
                    },
                    {
                        "username": "hrishyak17",
                        "content": "I am trying to solve the question using level order traversal.\\ni am storing each level elements in a vector and checking if they are palindromic , if no return false else continue.\\nI got wrong answer in this test case:-\\nInput\\nroot =\\n[1,2,2,null,3,null,3]\\nOutput\\ntrue\\nExpected\\nfalse\\n\\n Anyone please help me out where i gone wrong .\\nAnd my code is below: \\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint height(TreeNode*root){\\n    if(root==NULL)return 0;\\n    else{\\n       int lheight =height(root->left);\\n       int rheight=height(root->right);\\n       if(lheight>rheight)return lheight+1;\\n       else return rheight+1;\\n    }\\n}\\nvoid currentLevel(TreeNode*root,int level,vector<int>&v){\\n            if(root==NULL)v.push_back(101);\\n\\n    if(level==1){\\n        v.push_back(root->val);\\n    }\\n    if(level>1){\\n        currentLevel(root->left,level-1,v);\\n        currentLevel(root->right,level-1,v);\\n    }\\n   \\n}\\n\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==NULL)return true;\\n        int h=height(root);\\n        for(int i=1;i<h;i++){\\n            vector<int>v;\\n            currentLevel(root,i,v);\\n            for(int j=0;j<v.size()/2;j++){\\n                if(v[j]!=v[v.size()-1-j])return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "geekyshubh",
                        "content": "How is this an easy question? :\\'( \\nPlease dont break my spirit leetcode."
                    },
                    {
                        "username": "rohitaharwar2003",
                        "content": "binary tree  queue"
                    },
                    {
                        "username": "Ardonite",
                        "content": "I am trying to perform Inorder traversal for entire tree and checking the equality of original list vs reversed list. It failed for 4 test cases. Could anyone achieve 100% test cases success using inorder traversal and let me know what I am missing "
                    },
                    {
                        "username": "eduard92",
                        "content": "I am new to Trees and I feel like I hit my first wall on Leetcode.\\nBut this question I think I can solve it by splitting the tree in two trees, left and right, and go with both Inorder, left and right "
                    },
                    {
                        "username": "kennyhml",
                        "content": "The trick is to break the tree down into two seperate trees and then perform checks for the value, but mirror the direction."
                    },
                    {
                        "username": "hammeramr",
                        "content": "Any hints for non recursive solution? I solved it recursively.\n\nPlease dont give the answer or recipe just want a hint - thanks "
                    },
                    {
                        "username": "raimundo82",
                        "content": "it dependes the solution u have in mind...for instance, u can iterate through the left tree and the right tree simultaneously, (since there is a direct relation between both) and take the conclusions"
                    }
                ]
            },
            {
                "id": 1838364,
                "content": [
                    {
                        "username": "ShivamSingh101",
                        "content": "this is simple problem and same to  two tree are identical or not\nsame logic appiled to  (root->left and root->right)\n"
                    },
                    {
                        "username": "alprose11",
                        "content": "how to do it iteratively?"
                    },
                    {
                        "username": "vardbabayan",
                        "content": "[@silentgeek6](/silentgeek6) yes, it will definitely help\\njust do only tree section and practice DFS/BSF aproaches"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "How to do it recursively iteratively is easier to think but i am unable to think recurively  what do you think is practicing different types of question will help me to be good solving tree questions?"
                    },
                    {
                        "username": "arf01",
                        "content": "[1,2,2,2,null,2]   can anyone draw me this tree,please??"
                    },
                    {
                        "username": "hrishyak17",
                        "content": "I am trying to solve the question using level order traversal.\\ni am storing each level elements in a vector and checking if they are palindromic , if no return false else continue.\\nI got wrong answer in this test case:-\\nInput\\nroot =\\n[1,2,2,null,3,null,3]\\nOutput\\ntrue\\nExpected\\nfalse\\n\\n Anyone please help me out where i gone wrong .\\nAnd my code is below: \\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint height(TreeNode*root){\\n    if(root==NULL)return 0;\\n    else{\\n       int lheight =height(root->left);\\n       int rheight=height(root->right);\\n       if(lheight>rheight)return lheight+1;\\n       else return rheight+1;\\n    }\\n}\\nvoid currentLevel(TreeNode*root,int level,vector<int>&v){\\n            if(root==NULL)v.push_back(101);\\n\\n    if(level==1){\\n        v.push_back(root->val);\\n    }\\n    if(level>1){\\n        currentLevel(root->left,level-1,v);\\n        currentLevel(root->right,level-1,v);\\n    }\\n   \\n}\\n\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==NULL)return true;\\n        int h=height(root);\\n        for(int i=1;i<h;i++){\\n            vector<int>v;\\n            currentLevel(root,i,v);\\n            for(int j=0;j<v.size()/2;j++){\\n                if(v[j]!=v[v.size()-1-j])return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "geekyshubh",
                        "content": "How is this an easy question? :\\'( \\nPlease dont break my spirit leetcode."
                    },
                    {
                        "username": "rohitaharwar2003",
                        "content": "binary tree  queue"
                    },
                    {
                        "username": "Ardonite",
                        "content": "I am trying to perform Inorder traversal for entire tree and checking the equality of original list vs reversed list. It failed for 4 test cases. Could anyone achieve 100% test cases success using inorder traversal and let me know what I am missing "
                    },
                    {
                        "username": "eduard92",
                        "content": "I am new to Trees and I feel like I hit my first wall on Leetcode.\\nBut this question I think I can solve it by splitting the tree in two trees, left and right, and go with both Inorder, left and right "
                    },
                    {
                        "username": "kennyhml",
                        "content": "The trick is to break the tree down into two seperate trees and then perform checks for the value, but mirror the direction."
                    },
                    {
                        "username": "hammeramr",
                        "content": "Any hints for non recursive solution? I solved it recursively.\n\nPlease dont give the answer or recipe just want a hint - thanks "
                    },
                    {
                        "username": "raimundo82",
                        "content": "it dependes the solution u have in mind...for instance, u can iterate through the left tree and the right tree simultaneously, (since there is a direct relation between both) and take the conclusions"
                    }
                ]
            },
            {
                "id": 1834928,
                "content": [
                    {
                        "username": "ShivamSingh101",
                        "content": "this is simple problem and same to  two tree are identical or not\nsame logic appiled to  (root->left and root->right)\n"
                    },
                    {
                        "username": "alprose11",
                        "content": "how to do it iteratively?"
                    },
                    {
                        "username": "vardbabayan",
                        "content": "[@silentgeek6](/silentgeek6) yes, it will definitely help\\njust do only tree section and practice DFS/BSF aproaches"
                    },
                    {
                        "username": "silentgeek6",
                        "content": "How to do it recursively iteratively is easier to think but i am unable to think recurively  what do you think is practicing different types of question will help me to be good solving tree questions?"
                    },
                    {
                        "username": "arf01",
                        "content": "[1,2,2,2,null,2]   can anyone draw me this tree,please??"
                    },
                    {
                        "username": "hrishyak17",
                        "content": "I am trying to solve the question using level order traversal.\\ni am storing each level elements in a vector and checking if they are palindromic , if no return false else continue.\\nI got wrong answer in this test case:-\\nInput\\nroot =\\n[1,2,2,null,3,null,3]\\nOutput\\ntrue\\nExpected\\nfalse\\n\\n Anyone please help me out where i gone wrong .\\nAnd my code is below: \\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint height(TreeNode*root){\\n    if(root==NULL)return 0;\\n    else{\\n       int lheight =height(root->left);\\n       int rheight=height(root->right);\\n       if(lheight>rheight)return lheight+1;\\n       else return rheight+1;\\n    }\\n}\\nvoid currentLevel(TreeNode*root,int level,vector<int>&v){\\n            if(root==NULL)v.push_back(101);\\n\\n    if(level==1){\\n        v.push_back(root->val);\\n    }\\n    if(level>1){\\n        currentLevel(root->left,level-1,v);\\n        currentLevel(root->right,level-1,v);\\n    }\\n   \\n}\\n\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==NULL)return true;\\n        int h=height(root);\\n        for(int i=1;i<h;i++){\\n            vector<int>v;\\n            currentLevel(root,i,v);\\n            for(int j=0;j<v.size()/2;j++){\\n                if(v[j]!=v[v.size()-1-j])return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};"
                    },
                    {
                        "username": "geekyshubh",
                        "content": "How is this an easy question? :\\'( \\nPlease dont break my spirit leetcode."
                    },
                    {
                        "username": "rohitaharwar2003",
                        "content": "binary tree  queue"
                    },
                    {
                        "username": "Ardonite",
                        "content": "I am trying to perform Inorder traversal for entire tree and checking the equality of original list vs reversed list. It failed for 4 test cases. Could anyone achieve 100% test cases success using inorder traversal and let me know what I am missing "
                    },
                    {
                        "username": "eduard92",
                        "content": "I am new to Trees and I feel like I hit my first wall on Leetcode.\\nBut this question I think I can solve it by splitting the tree in two trees, left and right, and go with both Inorder, left and right "
                    },
                    {
                        "username": "kennyhml",
                        "content": "The trick is to break the tree down into two seperate trees and then perform checks for the value, but mirror the direction."
                    },
                    {
                        "username": "hammeramr",
                        "content": "Any hints for non recursive solution? I solved it recursively.\n\nPlease dont give the answer or recipe just want a hint - thanks "
                    },
                    {
                        "username": "raimundo82",
                        "content": "it dependes the solution u have in mind...for instance, u can iterate through the left tree and the right tree simultaneously, (since there is a direct relation between both) and take the conclusions"
                    }
                ]
            },
            {
                "id": 1833080,
                "content": [
                    {
                        "username": "sominski",
                        "content": "1. \\nIn my solution I used ```map()``` to get an array in a shape I wanted. As a result I got ```TypeError: root.map is not a function```. Since this error occurs when map() is applied to data other than array, I explicitly converted root into array: ```let array = new Array(root)``` The error disappeared. \\n\\nBut why?! `root` here is an array already, isn\\'t it?! (F.e. ```\\u05B0Array.isArray(root)``` here ```== true```).\\n\\n2. \\nAfter solving the previous problem, I got \"Wrong Answer\" error: \"root = [1,2,2,3,4,4,3] error. Output: false. Expected: true\". -- But in VSC, where I\\'ve wrote and tested my code, running the code with this value gives the correct result: \"true\". What could be the problem? \\n\\n(I apologize for maybe asking a dumb question. It\\'s only my second or third day on Leetcode). `your inline code...your inline code..."
                    },
                    {
                        "username": "sominski",
                        "content": "[@user9456g](/user9456g) Thank you!"
                    },
                    {
                        "username": "raimundo82",
                        "content": "Hi. root is of type TreeNode, ie, new TreeNode(1, new TreeNode(....), new TreeNode(....))"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "Jjonah27",
                        "content": "Horray!!!"
                    },
                    {
                        "username": "catchups",
                        "content": "[1,2,2,2,null,2]\\nsame coding I paste\\nI ran code in my own VScode, it returns False,\\nI ran here it outputs True\\nwhat? why?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "\\nvar isSymmetric = function(root) {\\n    let p1 = [];\\n    let p2 = [];\\n\\n    for(let i = 0; i < Math.floor(root.length / 2); i++){\\n        if( (i%2) != 0){\\n            let l = ((2 * i) + 1);\\n            let left = data[l];\\n            let r = ((2 * i) + 2);\\n            let right = data[r];\\n            p1.push(left);\\n            p1.push(right);\\n        }else{\\n            let l = ((2 * i) + 1);\\n            let left = data[l];\\n            let r = ((2 * i) + 2);\\n            let right = data[r];\\n            p2.push(left);\\n            p2.push(right);\\n        }\\n    }\\n    for(let i = 0; i < p1.length; i++){\\n        if(p1[i] != p2[i]){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\nhere is the complete iterative solution but i dont know why the leetcode is not runninng.. looks like scamming..."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easiest solution in 6 min,recursion with live coding and dry run , just try and leave your valuable comment https://youtu.be/bbUTmu-A0q8"
                    },
                    {
                        "username": "lucianoinso",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "Can we solve it using Inorder traversal? I tried doing it but not passing all TC.\n\n```class Solution {\n    private ArrayList <Integer> list1 = new ArrayList<>();\n    private ArrayList <Integer> list2 = new ArrayList<>();\n    static ArrayList<Integer> inorder(TreeNode root){\n        ArrayList <Integer> list = new ArrayList<>();\n        if(root==null){\n            return list;\n        }\n        if(root.left==null){\n            list.add(null);\n        }\n        else{\n            list.addAll(inorder(root.left));\n            list.add(root.val);\n        }   \n         list.addAll(inorder(root.right));\n        if(root.right==null){\n            list.add(null);\n        }\n        else{\n            list.addAll(inorder(root.right));\n            list.add(root.val);\n        }    \n        return list;\n    }\n    public boolean isSymmetric(TreeNode root) {\n        \n        if(root==null)return true;\n        list1 = inorder(root);\n        list2 = inorder(root); \n        Collections.reverse(list2);\n        if(list1.equals(list2)){\n            return true;\n        }\n        else{\n            return false;\n        }\n    }    \n}\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jems1123",
                        "content": "I did bfs and everytime I\\'m checking wheather the array is palindrome or not but it gave me TLE only"
                    },
                    {
                        "username": "dimitryku",
                        "content": "While trying to solve, I decided to push everything in vector. But in the first testcase, while root = [1,2,2,3,4,4,3], and pushing like:\\n```\\nstep.push_back(lastStep[i]->left);\\nstep.push_back(lastStep[i]->right);\\n```\\nAnd printing:\\n```\\nfor(int i = 0; i < step.size(); ++i)\\n    if(!step[i])\\n        cout << step[i];\\n    else \\n        cout << step[i]->val;\\n```\\nI got stdout as 3434\\njust... why? And it is consistent..."
                    },
                    {
                        "username": "truckup7",
                        "content": "Wrong Answer\\n\\n195 / 199 testcases passed\\nInput\\nroot =[1,2,2,2,null,2]\\n\\nOutput: true\\nExpected:false\\n\\nthis should\\'ve been true can some one explain\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "If you draw the tree you can see that the last level is not mirrored. The right side of the left subtree is `null` and the left side of the right subtree is `2`\n"
                    },
                    {
                        "username": "Gydronium",
                        "content": "On the second level of tree we should have 2,null,null,2 to symmetry around center. But we have 2,null,2"
                    }
                ]
            },
            {
                "id": 1831816,
                "content": [
                    {
                        "username": "sominski",
                        "content": "1. \\nIn my solution I used ```map()``` to get an array in a shape I wanted. As a result I got ```TypeError: root.map is not a function```. Since this error occurs when map() is applied to data other than array, I explicitly converted root into array: ```let array = new Array(root)``` The error disappeared. \\n\\nBut why?! `root` here is an array already, isn\\'t it?! (F.e. ```\\u05B0Array.isArray(root)``` here ```== true```).\\n\\n2. \\nAfter solving the previous problem, I got \"Wrong Answer\" error: \"root = [1,2,2,3,4,4,3] error. Output: false. Expected: true\". -- But in VSC, where I\\'ve wrote and tested my code, running the code with this value gives the correct result: \"true\". What could be the problem? \\n\\n(I apologize for maybe asking a dumb question. It\\'s only my second or third day on Leetcode). `your inline code...your inline code..."
                    },
                    {
                        "username": "sominski",
                        "content": "[@user9456g](/user9456g) Thank you!"
                    },
                    {
                        "username": "raimundo82",
                        "content": "Hi. root is of type TreeNode, ie, new TreeNode(1, new TreeNode(....), new TreeNode(....))"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "Jjonah27",
                        "content": "Horray!!!"
                    },
                    {
                        "username": "catchups",
                        "content": "[1,2,2,2,null,2]\\nsame coding I paste\\nI ran code in my own VScode, it returns False,\\nI ran here it outputs True\\nwhat? why?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "\\nvar isSymmetric = function(root) {\\n    let p1 = [];\\n    let p2 = [];\\n\\n    for(let i = 0; i < Math.floor(root.length / 2); i++){\\n        if( (i%2) != 0){\\n            let l = ((2 * i) + 1);\\n            let left = data[l];\\n            let r = ((2 * i) + 2);\\n            let right = data[r];\\n            p1.push(left);\\n            p1.push(right);\\n        }else{\\n            let l = ((2 * i) + 1);\\n            let left = data[l];\\n            let r = ((2 * i) + 2);\\n            let right = data[r];\\n            p2.push(left);\\n            p2.push(right);\\n        }\\n    }\\n    for(let i = 0; i < p1.length; i++){\\n        if(p1[i] != p2[i]){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\nhere is the complete iterative solution but i dont know why the leetcode is not runninng.. looks like scamming..."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easiest solution in 6 min,recursion with live coding and dry run , just try and leave your valuable comment https://youtu.be/bbUTmu-A0q8"
                    },
                    {
                        "username": "lucianoinso",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "Can we solve it using Inorder traversal? I tried doing it but not passing all TC.\n\n```class Solution {\n    private ArrayList <Integer> list1 = new ArrayList<>();\n    private ArrayList <Integer> list2 = new ArrayList<>();\n    static ArrayList<Integer> inorder(TreeNode root){\n        ArrayList <Integer> list = new ArrayList<>();\n        if(root==null){\n            return list;\n        }\n        if(root.left==null){\n            list.add(null);\n        }\n        else{\n            list.addAll(inorder(root.left));\n            list.add(root.val);\n        }   \n         list.addAll(inorder(root.right));\n        if(root.right==null){\n            list.add(null);\n        }\n        else{\n            list.addAll(inorder(root.right));\n            list.add(root.val);\n        }    \n        return list;\n    }\n    public boolean isSymmetric(TreeNode root) {\n        \n        if(root==null)return true;\n        list1 = inorder(root);\n        list2 = inorder(root); \n        Collections.reverse(list2);\n        if(list1.equals(list2)){\n            return true;\n        }\n        else{\n            return false;\n        }\n    }    \n}\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jems1123",
                        "content": "I did bfs and everytime I\\'m checking wheather the array is palindrome or not but it gave me TLE only"
                    },
                    {
                        "username": "dimitryku",
                        "content": "While trying to solve, I decided to push everything in vector. But in the first testcase, while root = [1,2,2,3,4,4,3], and pushing like:\\n```\\nstep.push_back(lastStep[i]->left);\\nstep.push_back(lastStep[i]->right);\\n```\\nAnd printing:\\n```\\nfor(int i = 0; i < step.size(); ++i)\\n    if(!step[i])\\n        cout << step[i];\\n    else \\n        cout << step[i]->val;\\n```\\nI got stdout as 3434\\njust... why? And it is consistent..."
                    },
                    {
                        "username": "truckup7",
                        "content": "Wrong Answer\\n\\n195 / 199 testcases passed\\nInput\\nroot =[1,2,2,2,null,2]\\n\\nOutput: true\\nExpected:false\\n\\nthis should\\'ve been true can some one explain\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "If you draw the tree you can see that the last level is not mirrored. The right side of the left subtree is `null` and the left side of the right subtree is `2`\n"
                    },
                    {
                        "username": "Gydronium",
                        "content": "On the second level of tree we should have 2,null,null,2 to symmetry around center. But we have 2,null,2"
                    }
                ]
            },
            {
                "id": 1831576,
                "content": [
                    {
                        "username": "sominski",
                        "content": "1. \\nIn my solution I used ```map()``` to get an array in a shape I wanted. As a result I got ```TypeError: root.map is not a function```. Since this error occurs when map() is applied to data other than array, I explicitly converted root into array: ```let array = new Array(root)``` The error disappeared. \\n\\nBut why?! `root` here is an array already, isn\\'t it?! (F.e. ```\\u05B0Array.isArray(root)``` here ```== true```).\\n\\n2. \\nAfter solving the previous problem, I got \"Wrong Answer\" error: \"root = [1,2,2,3,4,4,3] error. Output: false. Expected: true\". -- But in VSC, where I\\'ve wrote and tested my code, running the code with this value gives the correct result: \"true\". What could be the problem? \\n\\n(I apologize for maybe asking a dumb question. It\\'s only my second or third day on Leetcode). `your inline code...your inline code..."
                    },
                    {
                        "username": "sominski",
                        "content": "[@user9456g](/user9456g) Thank you!"
                    },
                    {
                        "username": "raimundo82",
                        "content": "Hi. root is of type TreeNode, ie, new TreeNode(1, new TreeNode(....), new TreeNode(....))"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "Jjonah27",
                        "content": "Horray!!!"
                    },
                    {
                        "username": "catchups",
                        "content": "[1,2,2,2,null,2]\\nsame coding I paste\\nI ran code in my own VScode, it returns False,\\nI ran here it outputs True\\nwhat? why?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "\\nvar isSymmetric = function(root) {\\n    let p1 = [];\\n    let p2 = [];\\n\\n    for(let i = 0; i < Math.floor(root.length / 2); i++){\\n        if( (i%2) != 0){\\n            let l = ((2 * i) + 1);\\n            let left = data[l];\\n            let r = ((2 * i) + 2);\\n            let right = data[r];\\n            p1.push(left);\\n            p1.push(right);\\n        }else{\\n            let l = ((2 * i) + 1);\\n            let left = data[l];\\n            let r = ((2 * i) + 2);\\n            let right = data[r];\\n            p2.push(left);\\n            p2.push(right);\\n        }\\n    }\\n    for(let i = 0; i < p1.length; i++){\\n        if(p1[i] != p2[i]){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\nhere is the complete iterative solution but i dont know why the leetcode is not runninng.. looks like scamming..."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easiest solution in 6 min,recursion with live coding and dry run , just try and leave your valuable comment https://youtu.be/bbUTmu-A0q8"
                    },
                    {
                        "username": "lucianoinso",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "Can we solve it using Inorder traversal? I tried doing it but not passing all TC.\n\n```class Solution {\n    private ArrayList <Integer> list1 = new ArrayList<>();\n    private ArrayList <Integer> list2 = new ArrayList<>();\n    static ArrayList<Integer> inorder(TreeNode root){\n        ArrayList <Integer> list = new ArrayList<>();\n        if(root==null){\n            return list;\n        }\n        if(root.left==null){\n            list.add(null);\n        }\n        else{\n            list.addAll(inorder(root.left));\n            list.add(root.val);\n        }   \n         list.addAll(inorder(root.right));\n        if(root.right==null){\n            list.add(null);\n        }\n        else{\n            list.addAll(inorder(root.right));\n            list.add(root.val);\n        }    \n        return list;\n    }\n    public boolean isSymmetric(TreeNode root) {\n        \n        if(root==null)return true;\n        list1 = inorder(root);\n        list2 = inorder(root); \n        Collections.reverse(list2);\n        if(list1.equals(list2)){\n            return true;\n        }\n        else{\n            return false;\n        }\n    }    \n}\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jems1123",
                        "content": "I did bfs and everytime I\\'m checking wheather the array is palindrome or not but it gave me TLE only"
                    },
                    {
                        "username": "dimitryku",
                        "content": "While trying to solve, I decided to push everything in vector. But in the first testcase, while root = [1,2,2,3,4,4,3], and pushing like:\\n```\\nstep.push_back(lastStep[i]->left);\\nstep.push_back(lastStep[i]->right);\\n```\\nAnd printing:\\n```\\nfor(int i = 0; i < step.size(); ++i)\\n    if(!step[i])\\n        cout << step[i];\\n    else \\n        cout << step[i]->val;\\n```\\nI got stdout as 3434\\njust... why? And it is consistent..."
                    },
                    {
                        "username": "truckup7",
                        "content": "Wrong Answer\\n\\n195 / 199 testcases passed\\nInput\\nroot =[1,2,2,2,null,2]\\n\\nOutput: true\\nExpected:false\\n\\nthis should\\'ve been true can some one explain\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "If you draw the tree you can see that the last level is not mirrored. The right side of the left subtree is `null` and the left side of the right subtree is `2`\n"
                    },
                    {
                        "username": "Gydronium",
                        "content": "On the second level of tree we should have 2,null,null,2 to symmetry around center. But we have 2,null,2"
                    }
                ]
            },
            {
                "id": 1831529,
                "content": [
                    {
                        "username": "sominski",
                        "content": "1. \\nIn my solution I used ```map()``` to get an array in a shape I wanted. As a result I got ```TypeError: root.map is not a function```. Since this error occurs when map() is applied to data other than array, I explicitly converted root into array: ```let array = new Array(root)``` The error disappeared. \\n\\nBut why?! `root` here is an array already, isn\\'t it?! (F.e. ```\\u05B0Array.isArray(root)``` here ```== true```).\\n\\n2. \\nAfter solving the previous problem, I got \"Wrong Answer\" error: \"root = [1,2,2,3,4,4,3] error. Output: false. Expected: true\". -- But in VSC, where I\\'ve wrote and tested my code, running the code with this value gives the correct result: \"true\". What could be the problem? \\n\\n(I apologize for maybe asking a dumb question. It\\'s only my second or third day on Leetcode). `your inline code...your inline code..."
                    },
                    {
                        "username": "sominski",
                        "content": "[@user9456g](/user9456g) Thank you!"
                    },
                    {
                        "username": "raimundo82",
                        "content": "Hi. root is of type TreeNode, ie, new TreeNode(1, new TreeNode(....), new TreeNode(....))"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "Jjonah27",
                        "content": "Horray!!!"
                    },
                    {
                        "username": "catchups",
                        "content": "[1,2,2,2,null,2]\\nsame coding I paste\\nI ran code in my own VScode, it returns False,\\nI ran here it outputs True\\nwhat? why?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "\\nvar isSymmetric = function(root) {\\n    let p1 = [];\\n    let p2 = [];\\n\\n    for(let i = 0; i < Math.floor(root.length / 2); i++){\\n        if( (i%2) != 0){\\n            let l = ((2 * i) + 1);\\n            let left = data[l];\\n            let r = ((2 * i) + 2);\\n            let right = data[r];\\n            p1.push(left);\\n            p1.push(right);\\n        }else{\\n            let l = ((2 * i) + 1);\\n            let left = data[l];\\n            let r = ((2 * i) + 2);\\n            let right = data[r];\\n            p2.push(left);\\n            p2.push(right);\\n        }\\n    }\\n    for(let i = 0; i < p1.length; i++){\\n        if(p1[i] != p2[i]){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\nhere is the complete iterative solution but i dont know why the leetcode is not runninng.. looks like scamming..."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easiest solution in 6 min,recursion with live coding and dry run , just try and leave your valuable comment https://youtu.be/bbUTmu-A0q8"
                    },
                    {
                        "username": "lucianoinso",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "Can we solve it using Inorder traversal? I tried doing it but not passing all TC.\n\n```class Solution {\n    private ArrayList <Integer> list1 = new ArrayList<>();\n    private ArrayList <Integer> list2 = new ArrayList<>();\n    static ArrayList<Integer> inorder(TreeNode root){\n        ArrayList <Integer> list = new ArrayList<>();\n        if(root==null){\n            return list;\n        }\n        if(root.left==null){\n            list.add(null);\n        }\n        else{\n            list.addAll(inorder(root.left));\n            list.add(root.val);\n        }   \n         list.addAll(inorder(root.right));\n        if(root.right==null){\n            list.add(null);\n        }\n        else{\n            list.addAll(inorder(root.right));\n            list.add(root.val);\n        }    \n        return list;\n    }\n    public boolean isSymmetric(TreeNode root) {\n        \n        if(root==null)return true;\n        list1 = inorder(root);\n        list2 = inorder(root); \n        Collections.reverse(list2);\n        if(list1.equals(list2)){\n            return true;\n        }\n        else{\n            return false;\n        }\n    }    \n}\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jems1123",
                        "content": "I did bfs and everytime I\\'m checking wheather the array is palindrome or not but it gave me TLE only"
                    },
                    {
                        "username": "dimitryku",
                        "content": "While trying to solve, I decided to push everything in vector. But in the first testcase, while root = [1,2,2,3,4,4,3], and pushing like:\\n```\\nstep.push_back(lastStep[i]->left);\\nstep.push_back(lastStep[i]->right);\\n```\\nAnd printing:\\n```\\nfor(int i = 0; i < step.size(); ++i)\\n    if(!step[i])\\n        cout << step[i];\\n    else \\n        cout << step[i]->val;\\n```\\nI got stdout as 3434\\njust... why? And it is consistent..."
                    },
                    {
                        "username": "truckup7",
                        "content": "Wrong Answer\\n\\n195 / 199 testcases passed\\nInput\\nroot =[1,2,2,2,null,2]\\n\\nOutput: true\\nExpected:false\\n\\nthis should\\'ve been true can some one explain\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "If you draw the tree you can see that the last level is not mirrored. The right side of the left subtree is `null` and the left side of the right subtree is `2`\n"
                    },
                    {
                        "username": "Gydronium",
                        "content": "On the second level of tree we should have 2,null,null,2 to symmetry around center. But we have 2,null,2"
                    }
                ]
            },
            {
                "id": 1831516,
                "content": [
                    {
                        "username": "sominski",
                        "content": "1. \\nIn my solution I used ```map()``` to get an array in a shape I wanted. As a result I got ```TypeError: root.map is not a function```. Since this error occurs when map() is applied to data other than array, I explicitly converted root into array: ```let array = new Array(root)``` The error disappeared. \\n\\nBut why?! `root` here is an array already, isn\\'t it?! (F.e. ```\\u05B0Array.isArray(root)``` here ```== true```).\\n\\n2. \\nAfter solving the previous problem, I got \"Wrong Answer\" error: \"root = [1,2,2,3,4,4,3] error. Output: false. Expected: true\". -- But in VSC, where I\\'ve wrote and tested my code, running the code with this value gives the correct result: \"true\". What could be the problem? \\n\\n(I apologize for maybe asking a dumb question. It\\'s only my second or third day on Leetcode). `your inline code...your inline code..."
                    },
                    {
                        "username": "sominski",
                        "content": "[@user9456g](/user9456g) Thank you!"
                    },
                    {
                        "username": "raimundo82",
                        "content": "Hi. root is of type TreeNode, ie, new TreeNode(1, new TreeNode(....), new TreeNode(....))"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "Jjonah27",
                        "content": "Horray!!!"
                    },
                    {
                        "username": "catchups",
                        "content": "[1,2,2,2,null,2]\\nsame coding I paste\\nI ran code in my own VScode, it returns False,\\nI ran here it outputs True\\nwhat? why?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "\\nvar isSymmetric = function(root) {\\n    let p1 = [];\\n    let p2 = [];\\n\\n    for(let i = 0; i < Math.floor(root.length / 2); i++){\\n        if( (i%2) != 0){\\n            let l = ((2 * i) + 1);\\n            let left = data[l];\\n            let r = ((2 * i) + 2);\\n            let right = data[r];\\n            p1.push(left);\\n            p1.push(right);\\n        }else{\\n            let l = ((2 * i) + 1);\\n            let left = data[l];\\n            let r = ((2 * i) + 2);\\n            let right = data[r];\\n            p2.push(left);\\n            p2.push(right);\\n        }\\n    }\\n    for(let i = 0; i < p1.length; i++){\\n        if(p1[i] != p2[i]){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\nhere is the complete iterative solution but i dont know why the leetcode is not runninng.. looks like scamming..."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easiest solution in 6 min,recursion with live coding and dry run , just try and leave your valuable comment https://youtu.be/bbUTmu-A0q8"
                    },
                    {
                        "username": "lucianoinso",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "Can we solve it using Inorder traversal? I tried doing it but not passing all TC.\n\n```class Solution {\n    private ArrayList <Integer> list1 = new ArrayList<>();\n    private ArrayList <Integer> list2 = new ArrayList<>();\n    static ArrayList<Integer> inorder(TreeNode root){\n        ArrayList <Integer> list = new ArrayList<>();\n        if(root==null){\n            return list;\n        }\n        if(root.left==null){\n            list.add(null);\n        }\n        else{\n            list.addAll(inorder(root.left));\n            list.add(root.val);\n        }   \n         list.addAll(inorder(root.right));\n        if(root.right==null){\n            list.add(null);\n        }\n        else{\n            list.addAll(inorder(root.right));\n            list.add(root.val);\n        }    \n        return list;\n    }\n    public boolean isSymmetric(TreeNode root) {\n        \n        if(root==null)return true;\n        list1 = inorder(root);\n        list2 = inorder(root); \n        Collections.reverse(list2);\n        if(list1.equals(list2)){\n            return true;\n        }\n        else{\n            return false;\n        }\n    }    \n}\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jems1123",
                        "content": "I did bfs and everytime I\\'m checking wheather the array is palindrome or not but it gave me TLE only"
                    },
                    {
                        "username": "dimitryku",
                        "content": "While trying to solve, I decided to push everything in vector. But in the first testcase, while root = [1,2,2,3,4,4,3], and pushing like:\\n```\\nstep.push_back(lastStep[i]->left);\\nstep.push_back(lastStep[i]->right);\\n```\\nAnd printing:\\n```\\nfor(int i = 0; i < step.size(); ++i)\\n    if(!step[i])\\n        cout << step[i];\\n    else \\n        cout << step[i]->val;\\n```\\nI got stdout as 3434\\njust... why? And it is consistent..."
                    },
                    {
                        "username": "truckup7",
                        "content": "Wrong Answer\\n\\n195 / 199 testcases passed\\nInput\\nroot =[1,2,2,2,null,2]\\n\\nOutput: true\\nExpected:false\\n\\nthis should\\'ve been true can some one explain\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "If you draw the tree you can see that the last level is not mirrored. The right side of the left subtree is `null` and the left side of the right subtree is `2`\n"
                    },
                    {
                        "username": "Gydronium",
                        "content": "On the second level of tree we should have 2,null,null,2 to symmetry around center. But we have 2,null,2"
                    }
                ]
            },
            {
                "id": 1831509,
                "content": [
                    {
                        "username": "sominski",
                        "content": "1. \\nIn my solution I used ```map()``` to get an array in a shape I wanted. As a result I got ```TypeError: root.map is not a function```. Since this error occurs when map() is applied to data other than array, I explicitly converted root into array: ```let array = new Array(root)``` The error disappeared. \\n\\nBut why?! `root` here is an array already, isn\\'t it?! (F.e. ```\\u05B0Array.isArray(root)``` here ```== true```).\\n\\n2. \\nAfter solving the previous problem, I got \"Wrong Answer\" error: \"root = [1,2,2,3,4,4,3] error. Output: false. Expected: true\". -- But in VSC, where I\\'ve wrote and tested my code, running the code with this value gives the correct result: \"true\". What could be the problem? \\n\\n(I apologize for maybe asking a dumb question. It\\'s only my second or third day on Leetcode). `your inline code...your inline code..."
                    },
                    {
                        "username": "sominski",
                        "content": "[@user9456g](/user9456g) Thank you!"
                    },
                    {
                        "username": "raimundo82",
                        "content": "Hi. root is of type TreeNode, ie, new TreeNode(1, new TreeNode(....), new TreeNode(....))"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "Jjonah27",
                        "content": "Horray!!!"
                    },
                    {
                        "username": "catchups",
                        "content": "[1,2,2,2,null,2]\\nsame coding I paste\\nI ran code in my own VScode, it returns False,\\nI ran here it outputs True\\nwhat? why?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "\\nvar isSymmetric = function(root) {\\n    let p1 = [];\\n    let p2 = [];\\n\\n    for(let i = 0; i < Math.floor(root.length / 2); i++){\\n        if( (i%2) != 0){\\n            let l = ((2 * i) + 1);\\n            let left = data[l];\\n            let r = ((2 * i) + 2);\\n            let right = data[r];\\n            p1.push(left);\\n            p1.push(right);\\n        }else{\\n            let l = ((2 * i) + 1);\\n            let left = data[l];\\n            let r = ((2 * i) + 2);\\n            let right = data[r];\\n            p2.push(left);\\n            p2.push(right);\\n        }\\n    }\\n    for(let i = 0; i < p1.length; i++){\\n        if(p1[i] != p2[i]){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\nhere is the complete iterative solution but i dont know why the leetcode is not runninng.. looks like scamming..."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easiest solution in 6 min,recursion with live coding and dry run , just try and leave your valuable comment https://youtu.be/bbUTmu-A0q8"
                    },
                    {
                        "username": "lucianoinso",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "Can we solve it using Inorder traversal? I tried doing it but not passing all TC.\n\n```class Solution {\n    private ArrayList <Integer> list1 = new ArrayList<>();\n    private ArrayList <Integer> list2 = new ArrayList<>();\n    static ArrayList<Integer> inorder(TreeNode root){\n        ArrayList <Integer> list = new ArrayList<>();\n        if(root==null){\n            return list;\n        }\n        if(root.left==null){\n            list.add(null);\n        }\n        else{\n            list.addAll(inorder(root.left));\n            list.add(root.val);\n        }   \n         list.addAll(inorder(root.right));\n        if(root.right==null){\n            list.add(null);\n        }\n        else{\n            list.addAll(inorder(root.right));\n            list.add(root.val);\n        }    \n        return list;\n    }\n    public boolean isSymmetric(TreeNode root) {\n        \n        if(root==null)return true;\n        list1 = inorder(root);\n        list2 = inorder(root); \n        Collections.reverse(list2);\n        if(list1.equals(list2)){\n            return true;\n        }\n        else{\n            return false;\n        }\n    }    \n}\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jems1123",
                        "content": "I did bfs and everytime I\\'m checking wheather the array is palindrome or not but it gave me TLE only"
                    },
                    {
                        "username": "dimitryku",
                        "content": "While trying to solve, I decided to push everything in vector. But in the first testcase, while root = [1,2,2,3,4,4,3], and pushing like:\\n```\\nstep.push_back(lastStep[i]->left);\\nstep.push_back(lastStep[i]->right);\\n```\\nAnd printing:\\n```\\nfor(int i = 0; i < step.size(); ++i)\\n    if(!step[i])\\n        cout << step[i];\\n    else \\n        cout << step[i]->val;\\n```\\nI got stdout as 3434\\njust... why? And it is consistent..."
                    },
                    {
                        "username": "truckup7",
                        "content": "Wrong Answer\\n\\n195 / 199 testcases passed\\nInput\\nroot =[1,2,2,2,null,2]\\n\\nOutput: true\\nExpected:false\\n\\nthis should\\'ve been true can some one explain\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "If you draw the tree you can see that the last level is not mirrored. The right side of the left subtree is `null` and the left side of the right subtree is `2`\n"
                    },
                    {
                        "username": "Gydronium",
                        "content": "On the second level of tree we should have 2,null,null,2 to symmetry around center. But we have 2,null,2"
                    }
                ]
            },
            {
                "id": 1831318,
                "content": [
                    {
                        "username": "sominski",
                        "content": "1. \\nIn my solution I used ```map()``` to get an array in a shape I wanted. As a result I got ```TypeError: root.map is not a function```. Since this error occurs when map() is applied to data other than array, I explicitly converted root into array: ```let array = new Array(root)``` The error disappeared. \\n\\nBut why?! `root` here is an array already, isn\\'t it?! (F.e. ```\\u05B0Array.isArray(root)``` here ```== true```).\\n\\n2. \\nAfter solving the previous problem, I got \"Wrong Answer\" error: \"root = [1,2,2,3,4,4,3] error. Output: false. Expected: true\". -- But in VSC, where I\\'ve wrote and tested my code, running the code with this value gives the correct result: \"true\". What could be the problem? \\n\\n(I apologize for maybe asking a dumb question. It\\'s only my second or third day on Leetcode). `your inline code...your inline code..."
                    },
                    {
                        "username": "sominski",
                        "content": "[@user9456g](/user9456g) Thank you!"
                    },
                    {
                        "username": "raimundo82",
                        "content": "Hi. root is of type TreeNode, ie, new TreeNode(1, new TreeNode(....), new TreeNode(....))"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "Jjonah27",
                        "content": "Horray!!!"
                    },
                    {
                        "username": "catchups",
                        "content": "[1,2,2,2,null,2]\\nsame coding I paste\\nI ran code in my own VScode, it returns False,\\nI ran here it outputs True\\nwhat? why?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "\\nvar isSymmetric = function(root) {\\n    let p1 = [];\\n    let p2 = [];\\n\\n    for(let i = 0; i < Math.floor(root.length / 2); i++){\\n        if( (i%2) != 0){\\n            let l = ((2 * i) + 1);\\n            let left = data[l];\\n            let r = ((2 * i) + 2);\\n            let right = data[r];\\n            p1.push(left);\\n            p1.push(right);\\n        }else{\\n            let l = ((2 * i) + 1);\\n            let left = data[l];\\n            let r = ((2 * i) + 2);\\n            let right = data[r];\\n            p2.push(left);\\n            p2.push(right);\\n        }\\n    }\\n    for(let i = 0; i < p1.length; i++){\\n        if(p1[i] != p2[i]){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\nhere is the complete iterative solution but i dont know why the leetcode is not runninng.. looks like scamming..."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easiest solution in 6 min,recursion with live coding and dry run , just try and leave your valuable comment https://youtu.be/bbUTmu-A0q8"
                    },
                    {
                        "username": "lucianoinso",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "Can we solve it using Inorder traversal? I tried doing it but not passing all TC.\n\n```class Solution {\n    private ArrayList <Integer> list1 = new ArrayList<>();\n    private ArrayList <Integer> list2 = new ArrayList<>();\n    static ArrayList<Integer> inorder(TreeNode root){\n        ArrayList <Integer> list = new ArrayList<>();\n        if(root==null){\n            return list;\n        }\n        if(root.left==null){\n            list.add(null);\n        }\n        else{\n            list.addAll(inorder(root.left));\n            list.add(root.val);\n        }   \n         list.addAll(inorder(root.right));\n        if(root.right==null){\n            list.add(null);\n        }\n        else{\n            list.addAll(inorder(root.right));\n            list.add(root.val);\n        }    \n        return list;\n    }\n    public boolean isSymmetric(TreeNode root) {\n        \n        if(root==null)return true;\n        list1 = inorder(root);\n        list2 = inorder(root); \n        Collections.reverse(list2);\n        if(list1.equals(list2)){\n            return true;\n        }\n        else{\n            return false;\n        }\n    }    \n}\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jems1123",
                        "content": "I did bfs and everytime I\\'m checking wheather the array is palindrome or not but it gave me TLE only"
                    },
                    {
                        "username": "dimitryku",
                        "content": "While trying to solve, I decided to push everything in vector. But in the first testcase, while root = [1,2,2,3,4,4,3], and pushing like:\\n```\\nstep.push_back(lastStep[i]->left);\\nstep.push_back(lastStep[i]->right);\\n```\\nAnd printing:\\n```\\nfor(int i = 0; i < step.size(); ++i)\\n    if(!step[i])\\n        cout << step[i];\\n    else \\n        cout << step[i]->val;\\n```\\nI got stdout as 3434\\njust... why? And it is consistent..."
                    },
                    {
                        "username": "truckup7",
                        "content": "Wrong Answer\\n\\n195 / 199 testcases passed\\nInput\\nroot =[1,2,2,2,null,2]\\n\\nOutput: true\\nExpected:false\\n\\nthis should\\'ve been true can some one explain\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "If you draw the tree you can see that the last level is not mirrored. The right side of the left subtree is `null` and the left side of the right subtree is `2`\n"
                    },
                    {
                        "username": "Gydronium",
                        "content": "On the second level of tree we should have 2,null,null,2 to symmetry around center. But we have 2,null,2"
                    }
                ]
            },
            {
                "id": 1831153,
                "content": [
                    {
                        "username": "sominski",
                        "content": "1. \\nIn my solution I used ```map()``` to get an array in a shape I wanted. As a result I got ```TypeError: root.map is not a function```. Since this error occurs when map() is applied to data other than array, I explicitly converted root into array: ```let array = new Array(root)``` The error disappeared. \\n\\nBut why?! `root` here is an array already, isn\\'t it?! (F.e. ```\\u05B0Array.isArray(root)``` here ```== true```).\\n\\n2. \\nAfter solving the previous problem, I got \"Wrong Answer\" error: \"root = [1,2,2,3,4,4,3] error. Output: false. Expected: true\". -- But in VSC, where I\\'ve wrote and tested my code, running the code with this value gives the correct result: \"true\". What could be the problem? \\n\\n(I apologize for maybe asking a dumb question. It\\'s only my second or third day on Leetcode). `your inline code...your inline code..."
                    },
                    {
                        "username": "sominski",
                        "content": "[@user9456g](/user9456g) Thank you!"
                    },
                    {
                        "username": "raimundo82",
                        "content": "Hi. root is of type TreeNode, ie, new TreeNode(1, new TreeNode(....), new TreeNode(....))"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "Jjonah27",
                        "content": "Horray!!!"
                    },
                    {
                        "username": "catchups",
                        "content": "[1,2,2,2,null,2]\\nsame coding I paste\\nI ran code in my own VScode, it returns False,\\nI ran here it outputs True\\nwhat? why?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "\\nvar isSymmetric = function(root) {\\n    let p1 = [];\\n    let p2 = [];\\n\\n    for(let i = 0; i < Math.floor(root.length / 2); i++){\\n        if( (i%2) != 0){\\n            let l = ((2 * i) + 1);\\n            let left = data[l];\\n            let r = ((2 * i) + 2);\\n            let right = data[r];\\n            p1.push(left);\\n            p1.push(right);\\n        }else{\\n            let l = ((2 * i) + 1);\\n            let left = data[l];\\n            let r = ((2 * i) + 2);\\n            let right = data[r];\\n            p2.push(left);\\n            p2.push(right);\\n        }\\n    }\\n    for(let i = 0; i < p1.length; i++){\\n        if(p1[i] != p2[i]){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\nhere is the complete iterative solution but i dont know why the leetcode is not runninng.. looks like scamming..."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easiest solution in 6 min,recursion with live coding and dry run , just try and leave your valuable comment https://youtu.be/bbUTmu-A0q8"
                    },
                    {
                        "username": "lucianoinso",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "Can we solve it using Inorder traversal? I tried doing it but not passing all TC.\n\n```class Solution {\n    private ArrayList <Integer> list1 = new ArrayList<>();\n    private ArrayList <Integer> list2 = new ArrayList<>();\n    static ArrayList<Integer> inorder(TreeNode root){\n        ArrayList <Integer> list = new ArrayList<>();\n        if(root==null){\n            return list;\n        }\n        if(root.left==null){\n            list.add(null);\n        }\n        else{\n            list.addAll(inorder(root.left));\n            list.add(root.val);\n        }   \n         list.addAll(inorder(root.right));\n        if(root.right==null){\n            list.add(null);\n        }\n        else{\n            list.addAll(inorder(root.right));\n            list.add(root.val);\n        }    \n        return list;\n    }\n    public boolean isSymmetric(TreeNode root) {\n        \n        if(root==null)return true;\n        list1 = inorder(root);\n        list2 = inorder(root); \n        Collections.reverse(list2);\n        if(list1.equals(list2)){\n            return true;\n        }\n        else{\n            return false;\n        }\n    }    \n}\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jems1123",
                        "content": "I did bfs and everytime I\\'m checking wheather the array is palindrome or not but it gave me TLE only"
                    },
                    {
                        "username": "dimitryku",
                        "content": "While trying to solve, I decided to push everything in vector. But in the first testcase, while root = [1,2,2,3,4,4,3], and pushing like:\\n```\\nstep.push_back(lastStep[i]->left);\\nstep.push_back(lastStep[i]->right);\\n```\\nAnd printing:\\n```\\nfor(int i = 0; i < step.size(); ++i)\\n    if(!step[i])\\n        cout << step[i];\\n    else \\n        cout << step[i]->val;\\n```\\nI got stdout as 3434\\njust... why? And it is consistent..."
                    },
                    {
                        "username": "truckup7",
                        "content": "Wrong Answer\\n\\n195 / 199 testcases passed\\nInput\\nroot =[1,2,2,2,null,2]\\n\\nOutput: true\\nExpected:false\\n\\nthis should\\'ve been true can some one explain\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "If you draw the tree you can see that the last level is not mirrored. The right side of the left subtree is `null` and the left side of the right subtree is `2`\n"
                    },
                    {
                        "username": "Gydronium",
                        "content": "On the second level of tree we should have 2,null,null,2 to symmetry around center. But we have 2,null,2"
                    }
                ]
            },
            {
                "id": 1831144,
                "content": [
                    {
                        "username": "sominski",
                        "content": "1. \\nIn my solution I used ```map()``` to get an array in a shape I wanted. As a result I got ```TypeError: root.map is not a function```. Since this error occurs when map() is applied to data other than array, I explicitly converted root into array: ```let array = new Array(root)``` The error disappeared. \\n\\nBut why?! `root` here is an array already, isn\\'t it?! (F.e. ```\\u05B0Array.isArray(root)``` here ```== true```).\\n\\n2. \\nAfter solving the previous problem, I got \"Wrong Answer\" error: \"root = [1,2,2,3,4,4,3] error. Output: false. Expected: true\". -- But in VSC, where I\\'ve wrote and tested my code, running the code with this value gives the correct result: \"true\". What could be the problem? \\n\\n(I apologize for maybe asking a dumb question. It\\'s only my second or third day on Leetcode). `your inline code...your inline code..."
                    },
                    {
                        "username": "sominski",
                        "content": "[@user9456g](/user9456g) Thank you!"
                    },
                    {
                        "username": "raimundo82",
                        "content": "Hi. root is of type TreeNode, ie, new TreeNode(1, new TreeNode(....), new TreeNode(....))"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "Jjonah27",
                        "content": "Horray!!!"
                    },
                    {
                        "username": "catchups",
                        "content": "[1,2,2,2,null,2]\\nsame coding I paste\\nI ran code in my own VScode, it returns False,\\nI ran here it outputs True\\nwhat? why?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "\\nvar isSymmetric = function(root) {\\n    let p1 = [];\\n    let p2 = [];\\n\\n    for(let i = 0; i < Math.floor(root.length / 2); i++){\\n        if( (i%2) != 0){\\n            let l = ((2 * i) + 1);\\n            let left = data[l];\\n            let r = ((2 * i) + 2);\\n            let right = data[r];\\n            p1.push(left);\\n            p1.push(right);\\n        }else{\\n            let l = ((2 * i) + 1);\\n            let left = data[l];\\n            let r = ((2 * i) + 2);\\n            let right = data[r];\\n            p2.push(left);\\n            p2.push(right);\\n        }\\n    }\\n    for(let i = 0; i < p1.length; i++){\\n        if(p1[i] != p2[i]){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\nhere is the complete iterative solution but i dont know why the leetcode is not runninng.. looks like scamming..."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easiest solution in 6 min,recursion with live coding and dry run , just try and leave your valuable comment https://youtu.be/bbUTmu-A0q8"
                    },
                    {
                        "username": "lucianoinso",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "Can we solve it using Inorder traversal? I tried doing it but not passing all TC.\n\n```class Solution {\n    private ArrayList <Integer> list1 = new ArrayList<>();\n    private ArrayList <Integer> list2 = new ArrayList<>();\n    static ArrayList<Integer> inorder(TreeNode root){\n        ArrayList <Integer> list = new ArrayList<>();\n        if(root==null){\n            return list;\n        }\n        if(root.left==null){\n            list.add(null);\n        }\n        else{\n            list.addAll(inorder(root.left));\n            list.add(root.val);\n        }   \n         list.addAll(inorder(root.right));\n        if(root.right==null){\n            list.add(null);\n        }\n        else{\n            list.addAll(inorder(root.right));\n            list.add(root.val);\n        }    \n        return list;\n    }\n    public boolean isSymmetric(TreeNode root) {\n        \n        if(root==null)return true;\n        list1 = inorder(root);\n        list2 = inorder(root); \n        Collections.reverse(list2);\n        if(list1.equals(list2)){\n            return true;\n        }\n        else{\n            return false;\n        }\n    }    \n}\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jems1123",
                        "content": "I did bfs and everytime I\\'m checking wheather the array is palindrome or not but it gave me TLE only"
                    },
                    {
                        "username": "dimitryku",
                        "content": "While trying to solve, I decided to push everything in vector. But in the first testcase, while root = [1,2,2,3,4,4,3], and pushing like:\\n```\\nstep.push_back(lastStep[i]->left);\\nstep.push_back(lastStep[i]->right);\\n```\\nAnd printing:\\n```\\nfor(int i = 0; i < step.size(); ++i)\\n    if(!step[i])\\n        cout << step[i];\\n    else \\n        cout << step[i]->val;\\n```\\nI got stdout as 3434\\njust... why? And it is consistent..."
                    },
                    {
                        "username": "truckup7",
                        "content": "Wrong Answer\\n\\n195 / 199 testcases passed\\nInput\\nroot =[1,2,2,2,null,2]\\n\\nOutput: true\\nExpected:false\\n\\nthis should\\'ve been true can some one explain\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "If you draw the tree you can see that the last level is not mirrored. The right side of the left subtree is `null` and the left side of the right subtree is `2`\n"
                    },
                    {
                        "username": "Gydronium",
                        "content": "On the second level of tree we should have 2,null,null,2 to symmetry around center. But we have 2,null,2"
                    }
                ]
            },
            {
                "id": 1831075,
                "content": [
                    {
                        "username": "sominski",
                        "content": "1. \\nIn my solution I used ```map()``` to get an array in a shape I wanted. As a result I got ```TypeError: root.map is not a function```. Since this error occurs when map() is applied to data other than array, I explicitly converted root into array: ```let array = new Array(root)``` The error disappeared. \\n\\nBut why?! `root` here is an array already, isn\\'t it?! (F.e. ```\\u05B0Array.isArray(root)``` here ```== true```).\\n\\n2. \\nAfter solving the previous problem, I got \"Wrong Answer\" error: \"root = [1,2,2,3,4,4,3] error. Output: false. Expected: true\". -- But in VSC, where I\\'ve wrote and tested my code, running the code with this value gives the correct result: \"true\". What could be the problem? \\n\\n(I apologize for maybe asking a dumb question. It\\'s only my second or third day on Leetcode). `your inline code...your inline code..."
                    },
                    {
                        "username": "sominski",
                        "content": "[@user9456g](/user9456g) Thank you!"
                    },
                    {
                        "username": "raimundo82",
                        "content": "Hi. root is of type TreeNode, ie, new TreeNode(1, new TreeNode(....), new TreeNode(....))"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "Jjonah27",
                        "content": "Horray!!!"
                    },
                    {
                        "username": "catchups",
                        "content": "[1,2,2,2,null,2]\\nsame coding I paste\\nI ran code in my own VScode, it returns False,\\nI ran here it outputs True\\nwhat? why?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "\\nvar isSymmetric = function(root) {\\n    let p1 = [];\\n    let p2 = [];\\n\\n    for(let i = 0; i < Math.floor(root.length / 2); i++){\\n        if( (i%2) != 0){\\n            let l = ((2 * i) + 1);\\n            let left = data[l];\\n            let r = ((2 * i) + 2);\\n            let right = data[r];\\n            p1.push(left);\\n            p1.push(right);\\n        }else{\\n            let l = ((2 * i) + 1);\\n            let left = data[l];\\n            let r = ((2 * i) + 2);\\n            let right = data[r];\\n            p2.push(left);\\n            p2.push(right);\\n        }\\n    }\\n    for(let i = 0; i < p1.length; i++){\\n        if(p1[i] != p2[i]){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n};\\n\\n\\nhere is the complete iterative solution but i dont know why the leetcode is not runninng.. looks like scamming..."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easiest solution in 6 min,recursion with live coding and dry run , just try and leave your valuable comment https://youtu.be/bbUTmu-A0q8"
                    },
                    {
                        "username": "lucianoinso",
                        "content": "Discussion Rules\\n\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mayank_codes16",
                        "content": "Can we solve it using Inorder traversal? I tried doing it but not passing all TC.\n\n```class Solution {\n    private ArrayList <Integer> list1 = new ArrayList<>();\n    private ArrayList <Integer> list2 = new ArrayList<>();\n    static ArrayList<Integer> inorder(TreeNode root){\n        ArrayList <Integer> list = new ArrayList<>();\n        if(root==null){\n            return list;\n        }\n        if(root.left==null){\n            list.add(null);\n        }\n        else{\n            list.addAll(inorder(root.left));\n            list.add(root.val);\n        }   \n         list.addAll(inorder(root.right));\n        if(root.right==null){\n            list.add(null);\n        }\n        else{\n            list.addAll(inorder(root.right));\n            list.add(root.val);\n        }    \n        return list;\n    }\n    public boolean isSymmetric(TreeNode root) {\n        \n        if(root==null)return true;\n        list1 = inorder(root);\n        list2 = inorder(root); \n        Collections.reverse(list2);\n        if(list1.equals(list2)){\n            return true;\n        }\n        else{\n            return false;\n        }\n    }    \n}\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "jems1123",
                        "content": "I did bfs and everytime I\\'m checking wheather the array is palindrome or not but it gave me TLE only"
                    },
                    {
                        "username": "dimitryku",
                        "content": "While trying to solve, I decided to push everything in vector. But in the first testcase, while root = [1,2,2,3,4,4,3], and pushing like:\\n```\\nstep.push_back(lastStep[i]->left);\\nstep.push_back(lastStep[i]->right);\\n```\\nAnd printing:\\n```\\nfor(int i = 0; i < step.size(); ++i)\\n    if(!step[i])\\n        cout << step[i];\\n    else \\n        cout << step[i]->val;\\n```\\nI got stdout as 3434\\njust... why? And it is consistent..."
                    },
                    {
                        "username": "truckup7",
                        "content": "Wrong Answer\\n\\n195 / 199 testcases passed\\nInput\\nroot =[1,2,2,2,null,2]\\n\\nOutput: true\\nExpected:false\\n\\nthis should\\'ve been true can some one explain\\n"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "If you draw the tree you can see that the last level is not mirrored. The right side of the left subtree is `null` and the left side of the right subtree is `2`\n"
                    },
                    {
                        "username": "Gydronium",
                        "content": "On the second level of tree we should have 2,null,null,2 to symmetry around center. But we have 2,null,2"
                    }
                ]
            },
            {
                "id": 1831058,
                "content": [
                    {
                        "username": "toan28082003",
                        "content": "My mistake is used Inorder Traversal to check..."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "and now everytime I look in the mirror, I will be reminded of this symmetric tree."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Finally Linked List is over \\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "basic tree traversal problem. \\npaying attention to null checks and value comparison made it into a child\\'s play"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Ez week \\uD83D\\uDE4F"
                    },
                    {
                        "username": "anwendeng",
                        "content": "A mirror problem."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "NICE!! free point I\\'ve solved this from 2 weeks, thank you LeetCode"
                    },
                    {
                        "username": "simranbarnwal",
                        "content": "I have done found the inorder traversal and stored it in a global vector and then just compared if the vector is palindrome or not. I am getting error in test case 195. Please help \\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83D\\uDE4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "kanikawarman",
                        "content": "What would be the space and time complexity if we use the iterative approach? I know time complexity would be better than recursion in case of large binary trees, but how can we measure that?"
                    },
                    {
                        "username": "vikash190",
                        "content": "M1: \\n\\nsubproblem : \\nroot.left == null && root.right == null  return true;\\nroot.left == null || root.right =null || root.left.val != root.right.val  return false;\\n\\nnow call this subproblem\\nsubproblem(root.left.left ,root.right.right ) && subproblem(root.left.right,root.right.left)\\n\\n\\nM2: \\nrotate(root.left)\\nequal(root.right,root.left)\\n\\nM3:\\nAt each level value same from mid \\ntraverse level wise and check from mid if val is same  \\n"
                    }
                ]
            },
            {
                "id": 1831051,
                "content": [
                    {
                        "username": "toan28082003",
                        "content": "My mistake is used Inorder Traversal to check..."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "and now everytime I look in the mirror, I will be reminded of this symmetric tree."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Finally Linked List is over \\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "basic tree traversal problem. \\npaying attention to null checks and value comparison made it into a child\\'s play"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Ez week \\uD83D\\uDE4F"
                    },
                    {
                        "username": "anwendeng",
                        "content": "A mirror problem."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "NICE!! free point I\\'ve solved this from 2 weeks, thank you LeetCode"
                    },
                    {
                        "username": "simranbarnwal",
                        "content": "I have done found the inorder traversal and stored it in a global vector and then just compared if the vector is palindrome or not. I am getting error in test case 195. Please help \\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83D\\uDE4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "kanikawarman",
                        "content": "What would be the space and time complexity if we use the iterative approach? I know time complexity would be better than recursion in case of large binary trees, but how can we measure that?"
                    },
                    {
                        "username": "vikash190",
                        "content": "M1: \\n\\nsubproblem : \\nroot.left == null && root.right == null  return true;\\nroot.left == null || root.right =null || root.left.val != root.right.val  return false;\\n\\nnow call this subproblem\\nsubproblem(root.left.left ,root.right.right ) && subproblem(root.left.right,root.right.left)\\n\\n\\nM2: \\nrotate(root.left)\\nequal(root.right,root.left)\\n\\nM3:\\nAt each level value same from mid \\ntraverse level wise and check from mid if val is same  \\n"
                    }
                ]
            },
            {
                "id": 1830905,
                "content": [
                    {
                        "username": "toan28082003",
                        "content": "My mistake is used Inorder Traversal to check..."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "and now everytime I look in the mirror, I will be reminded of this symmetric tree."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Finally Linked List is over \\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "basic tree traversal problem. \\npaying attention to null checks and value comparison made it into a child\\'s play"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Ez week \\uD83D\\uDE4F"
                    },
                    {
                        "username": "anwendeng",
                        "content": "A mirror problem."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "NICE!! free point I\\'ve solved this from 2 weeks, thank you LeetCode"
                    },
                    {
                        "username": "simranbarnwal",
                        "content": "I have done found the inorder traversal and stored it in a global vector and then just compared if the vector is palindrome or not. I am getting error in test case 195. Please help \\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83D\\uDE4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "kanikawarman",
                        "content": "What would be the space and time complexity if we use the iterative approach? I know time complexity would be better than recursion in case of large binary trees, but how can we measure that?"
                    },
                    {
                        "username": "vikash190",
                        "content": "M1: \\n\\nsubproblem : \\nroot.left == null && root.right == null  return true;\\nroot.left == null || root.right =null || root.left.val != root.right.val  return false;\\n\\nnow call this subproblem\\nsubproblem(root.left.left ,root.right.right ) && subproblem(root.left.right,root.right.left)\\n\\n\\nM2: \\nrotate(root.left)\\nequal(root.right,root.left)\\n\\nM3:\\nAt each level value same from mid \\ntraverse level wise and check from mid if val is same  \\n"
                    }
                ]
            },
            {
                "id": 1830849,
                "content": [
                    {
                        "username": "toan28082003",
                        "content": "My mistake is used Inorder Traversal to check..."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "and now everytime I look in the mirror, I will be reminded of this symmetric tree."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Finally Linked List is over \\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "basic tree traversal problem. \\npaying attention to null checks and value comparison made it into a child\\'s play"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Ez week \\uD83D\\uDE4F"
                    },
                    {
                        "username": "anwendeng",
                        "content": "A mirror problem."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "NICE!! free point I\\'ve solved this from 2 weeks, thank you LeetCode"
                    },
                    {
                        "username": "simranbarnwal",
                        "content": "I have done found the inorder traversal and stored it in a global vector and then just compared if the vector is palindrome or not. I am getting error in test case 195. Please help \\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83D\\uDE4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "kanikawarman",
                        "content": "What would be the space and time complexity if we use the iterative approach? I know time complexity would be better than recursion in case of large binary trees, but how can we measure that?"
                    },
                    {
                        "username": "vikash190",
                        "content": "M1: \\n\\nsubproblem : \\nroot.left == null && root.right == null  return true;\\nroot.left == null || root.right =null || root.left.val != root.right.val  return false;\\n\\nnow call this subproblem\\nsubproblem(root.left.left ,root.right.right ) && subproblem(root.left.right,root.right.left)\\n\\n\\nM2: \\nrotate(root.left)\\nequal(root.right,root.left)\\n\\nM3:\\nAt each level value same from mid \\ntraverse level wise and check from mid if val is same  \\n"
                    }
                ]
            },
            {
                "id": 1830826,
                "content": [
                    {
                        "username": "toan28082003",
                        "content": "My mistake is used Inorder Traversal to check..."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "and now everytime I look in the mirror, I will be reminded of this symmetric tree."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Finally Linked List is over \\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "basic tree traversal problem. \\npaying attention to null checks and value comparison made it into a child\\'s play"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Ez week \\uD83D\\uDE4F"
                    },
                    {
                        "username": "anwendeng",
                        "content": "A mirror problem."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "NICE!! free point I\\'ve solved this from 2 weeks, thank you LeetCode"
                    },
                    {
                        "username": "simranbarnwal",
                        "content": "I have done found the inorder traversal and stored it in a global vector and then just compared if the vector is palindrome or not. I am getting error in test case 195. Please help \\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83D\\uDE4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "kanikawarman",
                        "content": "What would be the space and time complexity if we use the iterative approach? I know time complexity would be better than recursion in case of large binary trees, but how can we measure that?"
                    },
                    {
                        "username": "vikash190",
                        "content": "M1: \\n\\nsubproblem : \\nroot.left == null && root.right == null  return true;\\nroot.left == null || root.right =null || root.left.val != root.right.val  return false;\\n\\nnow call this subproblem\\nsubproblem(root.left.left ,root.right.right ) && subproblem(root.left.right,root.right.left)\\n\\n\\nM2: \\nrotate(root.left)\\nequal(root.right,root.left)\\n\\nM3:\\nAt each level value same from mid \\ntraverse level wise and check from mid if val is same  \\n"
                    }
                ]
            },
            {
                "id": 1830803,
                "content": [
                    {
                        "username": "toan28082003",
                        "content": "My mistake is used Inorder Traversal to check..."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "and now everytime I look in the mirror, I will be reminded of this symmetric tree."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Finally Linked List is over \\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "basic tree traversal problem. \\npaying attention to null checks and value comparison made it into a child\\'s play"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Ez week \\uD83D\\uDE4F"
                    },
                    {
                        "username": "anwendeng",
                        "content": "A mirror problem."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "NICE!! free point I\\'ve solved this from 2 weeks, thank you LeetCode"
                    },
                    {
                        "username": "simranbarnwal",
                        "content": "I have done found the inorder traversal and stored it in a global vector and then just compared if the vector is palindrome or not. I am getting error in test case 195. Please help \\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83D\\uDE4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "kanikawarman",
                        "content": "What would be the space and time complexity if we use the iterative approach? I know time complexity would be better than recursion in case of large binary trees, but how can we measure that?"
                    },
                    {
                        "username": "vikash190",
                        "content": "M1: \\n\\nsubproblem : \\nroot.left == null && root.right == null  return true;\\nroot.left == null || root.right =null || root.left.val != root.right.val  return false;\\n\\nnow call this subproblem\\nsubproblem(root.left.left ,root.right.right ) && subproblem(root.left.right,root.right.left)\\n\\n\\nM2: \\nrotate(root.left)\\nequal(root.right,root.left)\\n\\nM3:\\nAt each level value same from mid \\ntraverse level wise and check from mid if val is same  \\n"
                    }
                ]
            },
            {
                "id": 1830793,
                "content": [
                    {
                        "username": "toan28082003",
                        "content": "My mistake is used Inorder Traversal to check..."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "and now everytime I look in the mirror, I will be reminded of this symmetric tree."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Finally Linked List is over \\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "basic tree traversal problem. \\npaying attention to null checks and value comparison made it into a child\\'s play"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Ez week \\uD83D\\uDE4F"
                    },
                    {
                        "username": "anwendeng",
                        "content": "A mirror problem."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "NICE!! free point I\\'ve solved this from 2 weeks, thank you LeetCode"
                    },
                    {
                        "username": "simranbarnwal",
                        "content": "I have done found the inorder traversal and stored it in a global vector and then just compared if the vector is palindrome or not. I am getting error in test case 195. Please help \\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83D\\uDE4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "kanikawarman",
                        "content": "What would be the space and time complexity if we use the iterative approach? I know time complexity would be better than recursion in case of large binary trees, but how can we measure that?"
                    },
                    {
                        "username": "vikash190",
                        "content": "M1: \\n\\nsubproblem : \\nroot.left == null && root.right == null  return true;\\nroot.left == null || root.right =null || root.left.val != root.right.val  return false;\\n\\nnow call this subproblem\\nsubproblem(root.left.left ,root.right.right ) && subproblem(root.left.right,root.right.left)\\n\\n\\nM2: \\nrotate(root.left)\\nequal(root.right,root.left)\\n\\nM3:\\nAt each level value same from mid \\ntraverse level wise and check from mid if val is same  \\n"
                    }
                ]
            },
            {
                "id": 1817539,
                "content": [
                    {
                        "username": "toan28082003",
                        "content": "My mistake is used Inorder Traversal to check..."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "and now everytime I look in the mirror, I will be reminded of this symmetric tree."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Finally Linked List is over \\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "basic tree traversal problem. \\npaying attention to null checks and value comparison made it into a child\\'s play"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Ez week \\uD83D\\uDE4F"
                    },
                    {
                        "username": "anwendeng",
                        "content": "A mirror problem."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "NICE!! free point I\\'ve solved this from 2 weeks, thank you LeetCode"
                    },
                    {
                        "username": "simranbarnwal",
                        "content": "I have done found the inorder traversal and stored it in a global vector and then just compared if the vector is palindrome or not. I am getting error in test case 195. Please help \\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83D\\uDE4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "kanikawarman",
                        "content": "What would be the space and time complexity if we use the iterative approach? I know time complexity would be better than recursion in case of large binary trees, but how can we measure that?"
                    },
                    {
                        "username": "vikash190",
                        "content": "M1: \\n\\nsubproblem : \\nroot.left == null && root.right == null  return true;\\nroot.left == null || root.right =null || root.left.val != root.right.val  return false;\\n\\nnow call this subproblem\\nsubproblem(root.left.left ,root.right.right ) && subproblem(root.left.right,root.right.left)\\n\\n\\nM2: \\nrotate(root.left)\\nequal(root.right,root.left)\\n\\nM3:\\nAt each level value same from mid \\ntraverse level wise and check from mid if val is same  \\n"
                    }
                ]
            },
            {
                "id": 1771190,
                "content": [
                    {
                        "username": "toan28082003",
                        "content": "My mistake is used Inorder Traversal to check..."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "and now everytime I look in the mirror, I will be reminded of this symmetric tree."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Finally Linked List is over \\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "basic tree traversal problem. \\npaying attention to null checks and value comparison made it into a child\\'s play"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Ez week \\uD83D\\uDE4F"
                    },
                    {
                        "username": "anwendeng",
                        "content": "A mirror problem."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "NICE!! free point I\\'ve solved this from 2 weeks, thank you LeetCode"
                    },
                    {
                        "username": "simranbarnwal",
                        "content": "I have done found the inorder traversal and stored it in a global vector and then just compared if the vector is palindrome or not. I am getting error in test case 195. Please help \\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83D\\uDE4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "kanikawarman",
                        "content": "What would be the space and time complexity if we use the iterative approach? I know time complexity would be better than recursion in case of large binary trees, but how can we measure that?"
                    },
                    {
                        "username": "vikash190",
                        "content": "M1: \\n\\nsubproblem : \\nroot.left == null && root.right == null  return true;\\nroot.left == null || root.right =null || root.left.val != root.right.val  return false;\\n\\nnow call this subproblem\\nsubproblem(root.left.left ,root.right.right ) && subproblem(root.left.right,root.right.left)\\n\\n\\nM2: \\nrotate(root.left)\\nequal(root.right,root.left)\\n\\nM3:\\nAt each level value same from mid \\ntraverse level wise and check from mid if val is same  \\n"
                    }
                ]
            },
            {
                "id": 1770161,
                "content": [
                    {
                        "username": "toan28082003",
                        "content": "My mistake is used Inorder Traversal to check..."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "and now everytime I look in the mirror, I will be reminded of this symmetric tree."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Finally Linked List is over \\uD83D\\uDE2D\\n"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "basic tree traversal problem. \\npaying attention to null checks and value comparison made it into a child\\'s play"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Ez week \\uD83D\\uDE4F"
                    },
                    {
                        "username": "anwendeng",
                        "content": "A mirror problem."
                    },
                    {
                        "username": "UchihaKim",
                        "content": "NICE!! free point I\\'ve solved this from 2 weeks, thank you LeetCode"
                    },
                    {
                        "username": "simranbarnwal",
                        "content": "I have done found the inorder traversal and stored it in a global vector and then just compared if the vector is palindrome or not. I am getting error in test case 195. Please help \\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83D\\uDE4F\\uD83C\\uDFFB"
                    },
                    {
                        "username": "kanikawarman",
                        "content": "What would be the space and time complexity if we use the iterative approach? I know time complexity would be better than recursion in case of large binary trees, but how can we measure that?"
                    },
                    {
                        "username": "vikash190",
                        "content": "M1: \\n\\nsubproblem : \\nroot.left == null && root.right == null  return true;\\nroot.left == null || root.right =null || root.left.val != root.right.val  return false;\\n\\nnow call this subproblem\\nsubproblem(root.left.left ,root.right.right ) && subproblem(root.left.right,root.right.left)\\n\\n\\nM2: \\nrotate(root.left)\\nequal(root.right,root.left)\\n\\nM3:\\nAt each level value same from mid \\ntraverse level wise and check from mid if val is same  \\n"
                    }
                ]
            },
            {
                "id": 1759395,
                "content": [
                    {
                        "username": "mishraaarul",
                        "content": "\\uD83D\\uDCA1 Mirror property is    left == right and right == left\\n\\uD83D\\uDCA1 pre-order traversal on root->left subtree, (root, left, right)\\n\\uD83D\\uDCA1 modified pre-order traversal on root->right subtree, (root, right, left) \\n\\uD83D\\uDCA1 compare the node val\\'s if they are the same \\n\\uD83D\\uDCA1 Do both traversals at the same time\\n\\uD83D\\uDCA1 if left is null or right is null, then both sides must match and return true (base case)"
                    },
                    {
                        "username": "Avijit_Rana80",
                        "content": "This code is same as mirror Tree. So if you done previously mirror Tree code . Then you can easily solve this Question."
                    },
                    {
                        "username": "Avijit_Rana80",
                        "content": "Hints:- The question is same to mirror Tree , so if you done mirror Tree question , Then you can solve this question easily."
                    },
                    {
                        "username": "jimmiejohnsson84",
                        "content": "There are probably many ways of solving this, but I did not find it to be easy.\\n\\nMy approach was to use breadth first traverse on both left and right subtrees of the root and do a symmetry check of the children. Making sure to swap left/right when adding them into the queue (left child from root->left should be compared to right child of root->right).\\nFeels like this should be bumped to medium as it was not trivial to solve it, dont think I would have made it during an interview call (was fine doing at home like all other leetcode questions are...)"
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "it\\'s just the same question of \"compare two tree\\'\\'"
                    },
                    {
                        "username": "sanketdawange6",
                        "content": "Use level order traversal.\\nAppend each level node to a vector\\nIf that vector is not palindrome return false;\\nRepeat yet the the tree finished finally return true;"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "class Solution {\\npublic:\\nbool check(TreeNode* root1,TreeNode* root2){\\n    //base case\\n    if(root1==NULL && root2==NULL)\\n    return true;\\n    if(root1==NULL && root2!=NULL)\\n    return false;\\n    if(root1!=NULL && root2==NULL)\\n    return false;\\n    if(root1->val!=root2->val)\\n    return false;\\n    bool op1=check(root1->left,root2->right);\\n    bool op2=check(root1->right,root2->left);\\n    bool final= op1 && op2;\\n    return final;\\n}\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==NULL)\\n        return true;\\n        return check(root->left,root->right);\\n         }\\n};"
                    },
                    {
                        "username": "_tofu_",
                        "content": "The new UI is ugly"
                    },
                    {
                        "username": "aman3091",
                        "content": "Please help me I am not able to clear [1,2,2,2,null,2] test case. what is wrong with my code i have use vertical order traversal for this.\\nbool isSymmetric(TreeNode* root) {\\n        if(root==NULL){\\n            return 1;\\n        }\\n        map<int,map<int,multiset<int>>>mp;\\n        queue<pair<TreeNode*,pair<int,int>>>q;\\n        q.push({root,{0,0}});\\n        int z=0;\\n        while(!q.empty()){\\n            auto p=q.front();\\n            q.pop();\\n        TreeNode* temp=p.first;\\n        int x=p.second.first;\\n        int y=p.second.second;\\n        mp[x][y].insert(temp->val);\\n        z=max(z,x);\\n        if(temp->left!=NULL){\\n            q.push({temp->left,{x-1,y+1}});\\n        }\\n        if(temp->right!=NULL){\\n            q.push({temp->right,{x+1,y+1}});\\n        }\\n        }\\n     for(int i=0;i<=z;i++){\\n         if(mp[i]!=mp[-1*i]){\\n             return 0;\\n         }\\n     }\\n        return 1;\\n\\n    }"
                    }
                ]
            },
            {
                "id": 1758489,
                "content": [
                    {
                        "username": "mishraaarul",
                        "content": "\\uD83D\\uDCA1 Mirror property is    left == right and right == left\\n\\uD83D\\uDCA1 pre-order traversal on root->left subtree, (root, left, right)\\n\\uD83D\\uDCA1 modified pre-order traversal on root->right subtree, (root, right, left) \\n\\uD83D\\uDCA1 compare the node val\\'s if they are the same \\n\\uD83D\\uDCA1 Do both traversals at the same time\\n\\uD83D\\uDCA1 if left is null or right is null, then both sides must match and return true (base case)"
                    },
                    {
                        "username": "Avijit_Rana80",
                        "content": "This code is same as mirror Tree. So if you done previously mirror Tree code . Then you can easily solve this Question."
                    },
                    {
                        "username": "Avijit_Rana80",
                        "content": "Hints:- The question is same to mirror Tree , so if you done mirror Tree question , Then you can solve this question easily."
                    },
                    {
                        "username": "jimmiejohnsson84",
                        "content": "There are probably many ways of solving this, but I did not find it to be easy.\\n\\nMy approach was to use breadth first traverse on both left and right subtrees of the root and do a symmetry check of the children. Making sure to swap left/right when adding them into the queue (left child from root->left should be compared to right child of root->right).\\nFeels like this should be bumped to medium as it was not trivial to solve it, dont think I would have made it during an interview call (was fine doing at home like all other leetcode questions are...)"
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "it\\'s just the same question of \"compare two tree\\'\\'"
                    },
                    {
                        "username": "sanketdawange6",
                        "content": "Use level order traversal.\\nAppend each level node to a vector\\nIf that vector is not palindrome return false;\\nRepeat yet the the tree finished finally return true;"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "class Solution {\\npublic:\\nbool check(TreeNode* root1,TreeNode* root2){\\n    //base case\\n    if(root1==NULL && root2==NULL)\\n    return true;\\n    if(root1==NULL && root2!=NULL)\\n    return false;\\n    if(root1!=NULL && root2==NULL)\\n    return false;\\n    if(root1->val!=root2->val)\\n    return false;\\n    bool op1=check(root1->left,root2->right);\\n    bool op2=check(root1->right,root2->left);\\n    bool final= op1 && op2;\\n    return final;\\n}\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==NULL)\\n        return true;\\n        return check(root->left,root->right);\\n         }\\n};"
                    },
                    {
                        "username": "_tofu_",
                        "content": "The new UI is ugly"
                    },
                    {
                        "username": "aman3091",
                        "content": "Please help me I am not able to clear [1,2,2,2,null,2] test case. what is wrong with my code i have use vertical order traversal for this.\\nbool isSymmetric(TreeNode* root) {\\n        if(root==NULL){\\n            return 1;\\n        }\\n        map<int,map<int,multiset<int>>>mp;\\n        queue<pair<TreeNode*,pair<int,int>>>q;\\n        q.push({root,{0,0}});\\n        int z=0;\\n        while(!q.empty()){\\n            auto p=q.front();\\n            q.pop();\\n        TreeNode* temp=p.first;\\n        int x=p.second.first;\\n        int y=p.second.second;\\n        mp[x][y].insert(temp->val);\\n        z=max(z,x);\\n        if(temp->left!=NULL){\\n            q.push({temp->left,{x-1,y+1}});\\n        }\\n        if(temp->right!=NULL){\\n            q.push({temp->right,{x+1,y+1}});\\n        }\\n        }\\n     for(int i=0;i<=z;i++){\\n         if(mp[i]!=mp[-1*i]){\\n             return 0;\\n         }\\n     }\\n        return 1;\\n\\n    }"
                    }
                ]
            },
            {
                "id": 1758253,
                "content": [
                    {
                        "username": "mishraaarul",
                        "content": "\\uD83D\\uDCA1 Mirror property is    left == right and right == left\\n\\uD83D\\uDCA1 pre-order traversal on root->left subtree, (root, left, right)\\n\\uD83D\\uDCA1 modified pre-order traversal on root->right subtree, (root, right, left) \\n\\uD83D\\uDCA1 compare the node val\\'s if they are the same \\n\\uD83D\\uDCA1 Do both traversals at the same time\\n\\uD83D\\uDCA1 if left is null or right is null, then both sides must match and return true (base case)"
                    },
                    {
                        "username": "Avijit_Rana80",
                        "content": "This code is same as mirror Tree. So if you done previously mirror Tree code . Then you can easily solve this Question."
                    },
                    {
                        "username": "Avijit_Rana80",
                        "content": "Hints:- The question is same to mirror Tree , so if you done mirror Tree question , Then you can solve this question easily."
                    },
                    {
                        "username": "jimmiejohnsson84",
                        "content": "There are probably many ways of solving this, but I did not find it to be easy.\\n\\nMy approach was to use breadth first traverse on both left and right subtrees of the root and do a symmetry check of the children. Making sure to swap left/right when adding them into the queue (left child from root->left should be compared to right child of root->right).\\nFeels like this should be bumped to medium as it was not trivial to solve it, dont think I would have made it during an interview call (was fine doing at home like all other leetcode questions are...)"
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "it\\'s just the same question of \"compare two tree\\'\\'"
                    },
                    {
                        "username": "sanketdawange6",
                        "content": "Use level order traversal.\\nAppend each level node to a vector\\nIf that vector is not palindrome return false;\\nRepeat yet the the tree finished finally return true;"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "class Solution {\\npublic:\\nbool check(TreeNode* root1,TreeNode* root2){\\n    //base case\\n    if(root1==NULL && root2==NULL)\\n    return true;\\n    if(root1==NULL && root2!=NULL)\\n    return false;\\n    if(root1!=NULL && root2==NULL)\\n    return false;\\n    if(root1->val!=root2->val)\\n    return false;\\n    bool op1=check(root1->left,root2->right);\\n    bool op2=check(root1->right,root2->left);\\n    bool final= op1 && op2;\\n    return final;\\n}\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==NULL)\\n        return true;\\n        return check(root->left,root->right);\\n         }\\n};"
                    },
                    {
                        "username": "_tofu_",
                        "content": "The new UI is ugly"
                    },
                    {
                        "username": "aman3091",
                        "content": "Please help me I am not able to clear [1,2,2,2,null,2] test case. what is wrong with my code i have use vertical order traversal for this.\\nbool isSymmetric(TreeNode* root) {\\n        if(root==NULL){\\n            return 1;\\n        }\\n        map<int,map<int,multiset<int>>>mp;\\n        queue<pair<TreeNode*,pair<int,int>>>q;\\n        q.push({root,{0,0}});\\n        int z=0;\\n        while(!q.empty()){\\n            auto p=q.front();\\n            q.pop();\\n        TreeNode* temp=p.first;\\n        int x=p.second.first;\\n        int y=p.second.second;\\n        mp[x][y].insert(temp->val);\\n        z=max(z,x);\\n        if(temp->left!=NULL){\\n            q.push({temp->left,{x-1,y+1}});\\n        }\\n        if(temp->right!=NULL){\\n            q.push({temp->right,{x+1,y+1}});\\n        }\\n        }\\n     for(int i=0;i<=z;i++){\\n         if(mp[i]!=mp[-1*i]){\\n             return 0;\\n         }\\n     }\\n        return 1;\\n\\n    }"
                    }
                ]
            },
            {
                "id": 1749894,
                "content": [
                    {
                        "username": "mishraaarul",
                        "content": "\\uD83D\\uDCA1 Mirror property is    left == right and right == left\\n\\uD83D\\uDCA1 pre-order traversal on root->left subtree, (root, left, right)\\n\\uD83D\\uDCA1 modified pre-order traversal on root->right subtree, (root, right, left) \\n\\uD83D\\uDCA1 compare the node val\\'s if they are the same \\n\\uD83D\\uDCA1 Do both traversals at the same time\\n\\uD83D\\uDCA1 if left is null or right is null, then both sides must match and return true (base case)"
                    },
                    {
                        "username": "Avijit_Rana80",
                        "content": "This code is same as mirror Tree. So if you done previously mirror Tree code . Then you can easily solve this Question."
                    },
                    {
                        "username": "Avijit_Rana80",
                        "content": "Hints:- The question is same to mirror Tree , so if you done mirror Tree question , Then you can solve this question easily."
                    },
                    {
                        "username": "jimmiejohnsson84",
                        "content": "There are probably many ways of solving this, but I did not find it to be easy.\\n\\nMy approach was to use breadth first traverse on both left and right subtrees of the root and do a symmetry check of the children. Making sure to swap left/right when adding them into the queue (left child from root->left should be compared to right child of root->right).\\nFeels like this should be bumped to medium as it was not trivial to solve it, dont think I would have made it during an interview call (was fine doing at home like all other leetcode questions are...)"
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "it\\'s just the same question of \"compare two tree\\'\\'"
                    },
                    {
                        "username": "sanketdawange6",
                        "content": "Use level order traversal.\\nAppend each level node to a vector\\nIf that vector is not palindrome return false;\\nRepeat yet the the tree finished finally return true;"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "class Solution {\\npublic:\\nbool check(TreeNode* root1,TreeNode* root2){\\n    //base case\\n    if(root1==NULL && root2==NULL)\\n    return true;\\n    if(root1==NULL && root2!=NULL)\\n    return false;\\n    if(root1!=NULL && root2==NULL)\\n    return false;\\n    if(root1->val!=root2->val)\\n    return false;\\n    bool op1=check(root1->left,root2->right);\\n    bool op2=check(root1->right,root2->left);\\n    bool final= op1 && op2;\\n    return final;\\n}\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==NULL)\\n        return true;\\n        return check(root->left,root->right);\\n         }\\n};"
                    },
                    {
                        "username": "_tofu_",
                        "content": "The new UI is ugly"
                    },
                    {
                        "username": "aman3091",
                        "content": "Please help me I am not able to clear [1,2,2,2,null,2] test case. what is wrong with my code i have use vertical order traversal for this.\\nbool isSymmetric(TreeNode* root) {\\n        if(root==NULL){\\n            return 1;\\n        }\\n        map<int,map<int,multiset<int>>>mp;\\n        queue<pair<TreeNode*,pair<int,int>>>q;\\n        q.push({root,{0,0}});\\n        int z=0;\\n        while(!q.empty()){\\n            auto p=q.front();\\n            q.pop();\\n        TreeNode* temp=p.first;\\n        int x=p.second.first;\\n        int y=p.second.second;\\n        mp[x][y].insert(temp->val);\\n        z=max(z,x);\\n        if(temp->left!=NULL){\\n            q.push({temp->left,{x-1,y+1}});\\n        }\\n        if(temp->right!=NULL){\\n            q.push({temp->right,{x+1,y+1}});\\n        }\\n        }\\n     for(int i=0;i<=z;i++){\\n         if(mp[i]!=mp[-1*i]){\\n             return 0;\\n         }\\n     }\\n        return 1;\\n\\n    }"
                    }
                ]
            },
            {
                "id": 1741083,
                "content": [
                    {
                        "username": "mishraaarul",
                        "content": "\\uD83D\\uDCA1 Mirror property is    left == right and right == left\\n\\uD83D\\uDCA1 pre-order traversal on root->left subtree, (root, left, right)\\n\\uD83D\\uDCA1 modified pre-order traversal on root->right subtree, (root, right, left) \\n\\uD83D\\uDCA1 compare the node val\\'s if they are the same \\n\\uD83D\\uDCA1 Do both traversals at the same time\\n\\uD83D\\uDCA1 if left is null or right is null, then both sides must match and return true (base case)"
                    },
                    {
                        "username": "Avijit_Rana80",
                        "content": "This code is same as mirror Tree. So if you done previously mirror Tree code . Then you can easily solve this Question."
                    },
                    {
                        "username": "Avijit_Rana80",
                        "content": "Hints:- The question is same to mirror Tree , so if you done mirror Tree question , Then you can solve this question easily."
                    },
                    {
                        "username": "jimmiejohnsson84",
                        "content": "There are probably many ways of solving this, but I did not find it to be easy.\\n\\nMy approach was to use breadth first traverse on both left and right subtrees of the root and do a symmetry check of the children. Making sure to swap left/right when adding them into the queue (left child from root->left should be compared to right child of root->right).\\nFeels like this should be bumped to medium as it was not trivial to solve it, dont think I would have made it during an interview call (was fine doing at home like all other leetcode questions are...)"
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "it\\'s just the same question of \"compare two tree\\'\\'"
                    },
                    {
                        "username": "sanketdawange6",
                        "content": "Use level order traversal.\\nAppend each level node to a vector\\nIf that vector is not palindrome return false;\\nRepeat yet the the tree finished finally return true;"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "class Solution {\\npublic:\\nbool check(TreeNode* root1,TreeNode* root2){\\n    //base case\\n    if(root1==NULL && root2==NULL)\\n    return true;\\n    if(root1==NULL && root2!=NULL)\\n    return false;\\n    if(root1!=NULL && root2==NULL)\\n    return false;\\n    if(root1->val!=root2->val)\\n    return false;\\n    bool op1=check(root1->left,root2->right);\\n    bool op2=check(root1->right,root2->left);\\n    bool final= op1 && op2;\\n    return final;\\n}\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==NULL)\\n        return true;\\n        return check(root->left,root->right);\\n         }\\n};"
                    },
                    {
                        "username": "_tofu_",
                        "content": "The new UI is ugly"
                    },
                    {
                        "username": "aman3091",
                        "content": "Please help me I am not able to clear [1,2,2,2,null,2] test case. what is wrong with my code i have use vertical order traversal for this.\\nbool isSymmetric(TreeNode* root) {\\n        if(root==NULL){\\n            return 1;\\n        }\\n        map<int,map<int,multiset<int>>>mp;\\n        queue<pair<TreeNode*,pair<int,int>>>q;\\n        q.push({root,{0,0}});\\n        int z=0;\\n        while(!q.empty()){\\n            auto p=q.front();\\n            q.pop();\\n        TreeNode* temp=p.first;\\n        int x=p.second.first;\\n        int y=p.second.second;\\n        mp[x][y].insert(temp->val);\\n        z=max(z,x);\\n        if(temp->left!=NULL){\\n            q.push({temp->left,{x-1,y+1}});\\n        }\\n        if(temp->right!=NULL){\\n            q.push({temp->right,{x+1,y+1}});\\n        }\\n        }\\n     for(int i=0;i<=z;i++){\\n         if(mp[i]!=mp[-1*i]){\\n             return 0;\\n         }\\n     }\\n        return 1;\\n\\n    }"
                    }
                ]
            },
            {
                "id": 1736561,
                "content": [
                    {
                        "username": "mishraaarul",
                        "content": "\\uD83D\\uDCA1 Mirror property is    left == right and right == left\\n\\uD83D\\uDCA1 pre-order traversal on root->left subtree, (root, left, right)\\n\\uD83D\\uDCA1 modified pre-order traversal on root->right subtree, (root, right, left) \\n\\uD83D\\uDCA1 compare the node val\\'s if they are the same \\n\\uD83D\\uDCA1 Do both traversals at the same time\\n\\uD83D\\uDCA1 if left is null or right is null, then both sides must match and return true (base case)"
                    },
                    {
                        "username": "Avijit_Rana80",
                        "content": "This code is same as mirror Tree. So if you done previously mirror Tree code . Then you can easily solve this Question."
                    },
                    {
                        "username": "Avijit_Rana80",
                        "content": "Hints:- The question is same to mirror Tree , so if you done mirror Tree question , Then you can solve this question easily."
                    },
                    {
                        "username": "jimmiejohnsson84",
                        "content": "There are probably many ways of solving this, but I did not find it to be easy.\\n\\nMy approach was to use breadth first traverse on both left and right subtrees of the root and do a symmetry check of the children. Making sure to swap left/right when adding them into the queue (left child from root->left should be compared to right child of root->right).\\nFeels like this should be bumped to medium as it was not trivial to solve it, dont think I would have made it during an interview call (was fine doing at home like all other leetcode questions are...)"
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "it\\'s just the same question of \"compare two tree\\'\\'"
                    },
                    {
                        "username": "sanketdawange6",
                        "content": "Use level order traversal.\\nAppend each level node to a vector\\nIf that vector is not palindrome return false;\\nRepeat yet the the tree finished finally return true;"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "class Solution {\\npublic:\\nbool check(TreeNode* root1,TreeNode* root2){\\n    //base case\\n    if(root1==NULL && root2==NULL)\\n    return true;\\n    if(root1==NULL && root2!=NULL)\\n    return false;\\n    if(root1!=NULL && root2==NULL)\\n    return false;\\n    if(root1->val!=root2->val)\\n    return false;\\n    bool op1=check(root1->left,root2->right);\\n    bool op2=check(root1->right,root2->left);\\n    bool final= op1 && op2;\\n    return final;\\n}\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==NULL)\\n        return true;\\n        return check(root->left,root->right);\\n         }\\n};"
                    },
                    {
                        "username": "_tofu_",
                        "content": "The new UI is ugly"
                    },
                    {
                        "username": "aman3091",
                        "content": "Please help me I am not able to clear [1,2,2,2,null,2] test case. what is wrong with my code i have use vertical order traversal for this.\\nbool isSymmetric(TreeNode* root) {\\n        if(root==NULL){\\n            return 1;\\n        }\\n        map<int,map<int,multiset<int>>>mp;\\n        queue<pair<TreeNode*,pair<int,int>>>q;\\n        q.push({root,{0,0}});\\n        int z=0;\\n        while(!q.empty()){\\n            auto p=q.front();\\n            q.pop();\\n        TreeNode* temp=p.first;\\n        int x=p.second.first;\\n        int y=p.second.second;\\n        mp[x][y].insert(temp->val);\\n        z=max(z,x);\\n        if(temp->left!=NULL){\\n            q.push({temp->left,{x-1,y+1}});\\n        }\\n        if(temp->right!=NULL){\\n            q.push({temp->right,{x+1,y+1}});\\n        }\\n        }\\n     for(int i=0;i<=z;i++){\\n         if(mp[i]!=mp[-1*i]){\\n             return 0;\\n         }\\n     }\\n        return 1;\\n\\n    }"
                    }
                ]
            },
            {
                "id": 1728206,
                "content": [
                    {
                        "username": "mishraaarul",
                        "content": "\\uD83D\\uDCA1 Mirror property is    left == right and right == left\\n\\uD83D\\uDCA1 pre-order traversal on root->left subtree, (root, left, right)\\n\\uD83D\\uDCA1 modified pre-order traversal on root->right subtree, (root, right, left) \\n\\uD83D\\uDCA1 compare the node val\\'s if they are the same \\n\\uD83D\\uDCA1 Do both traversals at the same time\\n\\uD83D\\uDCA1 if left is null or right is null, then both sides must match and return true (base case)"
                    },
                    {
                        "username": "Avijit_Rana80",
                        "content": "This code is same as mirror Tree. So if you done previously mirror Tree code . Then you can easily solve this Question."
                    },
                    {
                        "username": "Avijit_Rana80",
                        "content": "Hints:- The question is same to mirror Tree , so if you done mirror Tree question , Then you can solve this question easily."
                    },
                    {
                        "username": "jimmiejohnsson84",
                        "content": "There are probably many ways of solving this, but I did not find it to be easy.\\n\\nMy approach was to use breadth first traverse on both left and right subtrees of the root and do a symmetry check of the children. Making sure to swap left/right when adding them into the queue (left child from root->left should be compared to right child of root->right).\\nFeels like this should be bumped to medium as it was not trivial to solve it, dont think I would have made it during an interview call (was fine doing at home like all other leetcode questions are...)"
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "it\\'s just the same question of \"compare two tree\\'\\'"
                    },
                    {
                        "username": "sanketdawange6",
                        "content": "Use level order traversal.\\nAppend each level node to a vector\\nIf that vector is not palindrome return false;\\nRepeat yet the the tree finished finally return true;"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "class Solution {\\npublic:\\nbool check(TreeNode* root1,TreeNode* root2){\\n    //base case\\n    if(root1==NULL && root2==NULL)\\n    return true;\\n    if(root1==NULL && root2!=NULL)\\n    return false;\\n    if(root1!=NULL && root2==NULL)\\n    return false;\\n    if(root1->val!=root2->val)\\n    return false;\\n    bool op1=check(root1->left,root2->right);\\n    bool op2=check(root1->right,root2->left);\\n    bool final= op1 && op2;\\n    return final;\\n}\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==NULL)\\n        return true;\\n        return check(root->left,root->right);\\n         }\\n};"
                    },
                    {
                        "username": "_tofu_",
                        "content": "The new UI is ugly"
                    },
                    {
                        "username": "aman3091",
                        "content": "Please help me I am not able to clear [1,2,2,2,null,2] test case. what is wrong with my code i have use vertical order traversal for this.\\nbool isSymmetric(TreeNode* root) {\\n        if(root==NULL){\\n            return 1;\\n        }\\n        map<int,map<int,multiset<int>>>mp;\\n        queue<pair<TreeNode*,pair<int,int>>>q;\\n        q.push({root,{0,0}});\\n        int z=0;\\n        while(!q.empty()){\\n            auto p=q.front();\\n            q.pop();\\n        TreeNode* temp=p.first;\\n        int x=p.second.first;\\n        int y=p.second.second;\\n        mp[x][y].insert(temp->val);\\n        z=max(z,x);\\n        if(temp->left!=NULL){\\n            q.push({temp->left,{x-1,y+1}});\\n        }\\n        if(temp->right!=NULL){\\n            q.push({temp->right,{x+1,y+1}});\\n        }\\n        }\\n     for(int i=0;i<=z;i++){\\n         if(mp[i]!=mp[-1*i]){\\n             return 0;\\n         }\\n     }\\n        return 1;\\n\\n    }"
                    }
                ]
            },
            {
                "id": 1724579,
                "content": [
                    {
                        "username": "mishraaarul",
                        "content": "\\uD83D\\uDCA1 Mirror property is    left == right and right == left\\n\\uD83D\\uDCA1 pre-order traversal on root->left subtree, (root, left, right)\\n\\uD83D\\uDCA1 modified pre-order traversal on root->right subtree, (root, right, left) \\n\\uD83D\\uDCA1 compare the node val\\'s if they are the same \\n\\uD83D\\uDCA1 Do both traversals at the same time\\n\\uD83D\\uDCA1 if left is null or right is null, then both sides must match and return true (base case)"
                    },
                    {
                        "username": "Avijit_Rana80",
                        "content": "This code is same as mirror Tree. So if you done previously mirror Tree code . Then you can easily solve this Question."
                    },
                    {
                        "username": "Avijit_Rana80",
                        "content": "Hints:- The question is same to mirror Tree , so if you done mirror Tree question , Then you can solve this question easily."
                    },
                    {
                        "username": "jimmiejohnsson84",
                        "content": "There are probably many ways of solving this, but I did not find it to be easy.\\n\\nMy approach was to use breadth first traverse on both left and right subtrees of the root and do a symmetry check of the children. Making sure to swap left/right when adding them into the queue (left child from root->left should be compared to right child of root->right).\\nFeels like this should be bumped to medium as it was not trivial to solve it, dont think I would have made it during an interview call (was fine doing at home like all other leetcode questions are...)"
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "it\\'s just the same question of \"compare two tree\\'\\'"
                    },
                    {
                        "username": "sanketdawange6",
                        "content": "Use level order traversal.\\nAppend each level node to a vector\\nIf that vector is not palindrome return false;\\nRepeat yet the the tree finished finally return true;"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "class Solution {\\npublic:\\nbool check(TreeNode* root1,TreeNode* root2){\\n    //base case\\n    if(root1==NULL && root2==NULL)\\n    return true;\\n    if(root1==NULL && root2!=NULL)\\n    return false;\\n    if(root1!=NULL && root2==NULL)\\n    return false;\\n    if(root1->val!=root2->val)\\n    return false;\\n    bool op1=check(root1->left,root2->right);\\n    bool op2=check(root1->right,root2->left);\\n    bool final= op1 && op2;\\n    return final;\\n}\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==NULL)\\n        return true;\\n        return check(root->left,root->right);\\n         }\\n};"
                    },
                    {
                        "username": "_tofu_",
                        "content": "The new UI is ugly"
                    },
                    {
                        "username": "aman3091",
                        "content": "Please help me I am not able to clear [1,2,2,2,null,2] test case. what is wrong with my code i have use vertical order traversal for this.\\nbool isSymmetric(TreeNode* root) {\\n        if(root==NULL){\\n            return 1;\\n        }\\n        map<int,map<int,multiset<int>>>mp;\\n        queue<pair<TreeNode*,pair<int,int>>>q;\\n        q.push({root,{0,0}});\\n        int z=0;\\n        while(!q.empty()){\\n            auto p=q.front();\\n            q.pop();\\n        TreeNode* temp=p.first;\\n        int x=p.second.first;\\n        int y=p.second.second;\\n        mp[x][y].insert(temp->val);\\n        z=max(z,x);\\n        if(temp->left!=NULL){\\n            q.push({temp->left,{x-1,y+1}});\\n        }\\n        if(temp->right!=NULL){\\n            q.push({temp->right,{x+1,y+1}});\\n        }\\n        }\\n     for(int i=0;i<=z;i++){\\n         if(mp[i]!=mp[-1*i]){\\n             return 0;\\n         }\\n     }\\n        return 1;\\n\\n    }"
                    }
                ]
            },
            {
                "id": 1707973,
                "content": [
                    {
                        "username": "mishraaarul",
                        "content": "\\uD83D\\uDCA1 Mirror property is    left == right and right == left\\n\\uD83D\\uDCA1 pre-order traversal on root->left subtree, (root, left, right)\\n\\uD83D\\uDCA1 modified pre-order traversal on root->right subtree, (root, right, left) \\n\\uD83D\\uDCA1 compare the node val\\'s if they are the same \\n\\uD83D\\uDCA1 Do both traversals at the same time\\n\\uD83D\\uDCA1 if left is null or right is null, then both sides must match and return true (base case)"
                    },
                    {
                        "username": "Avijit_Rana80",
                        "content": "This code is same as mirror Tree. So if you done previously mirror Tree code . Then you can easily solve this Question."
                    },
                    {
                        "username": "Avijit_Rana80",
                        "content": "Hints:- The question is same to mirror Tree , so if you done mirror Tree question , Then you can solve this question easily."
                    },
                    {
                        "username": "jimmiejohnsson84",
                        "content": "There are probably many ways of solving this, but I did not find it to be easy.\\n\\nMy approach was to use breadth first traverse on both left and right subtrees of the root and do a symmetry check of the children. Making sure to swap left/right when adding them into the queue (left child from root->left should be compared to right child of root->right).\\nFeels like this should be bumped to medium as it was not trivial to solve it, dont think I would have made it during an interview call (was fine doing at home like all other leetcode questions are...)"
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "it\\'s just the same question of \"compare two tree\\'\\'"
                    },
                    {
                        "username": "sanketdawange6",
                        "content": "Use level order traversal.\\nAppend each level node to a vector\\nIf that vector is not palindrome return false;\\nRepeat yet the the tree finished finally return true;"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "class Solution {\\npublic:\\nbool check(TreeNode* root1,TreeNode* root2){\\n    //base case\\n    if(root1==NULL && root2==NULL)\\n    return true;\\n    if(root1==NULL && root2!=NULL)\\n    return false;\\n    if(root1!=NULL && root2==NULL)\\n    return false;\\n    if(root1->val!=root2->val)\\n    return false;\\n    bool op1=check(root1->left,root2->right);\\n    bool op2=check(root1->right,root2->left);\\n    bool final= op1 && op2;\\n    return final;\\n}\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==NULL)\\n        return true;\\n        return check(root->left,root->right);\\n         }\\n};"
                    },
                    {
                        "username": "_tofu_",
                        "content": "The new UI is ugly"
                    },
                    {
                        "username": "aman3091",
                        "content": "Please help me I am not able to clear [1,2,2,2,null,2] test case. what is wrong with my code i have use vertical order traversal for this.\\nbool isSymmetric(TreeNode* root) {\\n        if(root==NULL){\\n            return 1;\\n        }\\n        map<int,map<int,multiset<int>>>mp;\\n        queue<pair<TreeNode*,pair<int,int>>>q;\\n        q.push({root,{0,0}});\\n        int z=0;\\n        while(!q.empty()){\\n            auto p=q.front();\\n            q.pop();\\n        TreeNode* temp=p.first;\\n        int x=p.second.first;\\n        int y=p.second.second;\\n        mp[x][y].insert(temp->val);\\n        z=max(z,x);\\n        if(temp->left!=NULL){\\n            q.push({temp->left,{x-1,y+1}});\\n        }\\n        if(temp->right!=NULL){\\n            q.push({temp->right,{x+1,y+1}});\\n        }\\n        }\\n     for(int i=0;i<=z;i++){\\n         if(mp[i]!=mp[-1*i]){\\n             return 0;\\n         }\\n     }\\n        return 1;\\n\\n    }"
                    }
                ]
            },
            {
                "id": 1672775,
                "content": [
                    {
                        "username": "mishraaarul",
                        "content": "\\uD83D\\uDCA1 Mirror property is    left == right and right == left\\n\\uD83D\\uDCA1 pre-order traversal on root->left subtree, (root, left, right)\\n\\uD83D\\uDCA1 modified pre-order traversal on root->right subtree, (root, right, left) \\n\\uD83D\\uDCA1 compare the node val\\'s if they are the same \\n\\uD83D\\uDCA1 Do both traversals at the same time\\n\\uD83D\\uDCA1 if left is null or right is null, then both sides must match and return true (base case)"
                    },
                    {
                        "username": "Avijit_Rana80",
                        "content": "This code is same as mirror Tree. So if you done previously mirror Tree code . Then you can easily solve this Question."
                    },
                    {
                        "username": "Avijit_Rana80",
                        "content": "Hints:- The question is same to mirror Tree , so if you done mirror Tree question , Then you can solve this question easily."
                    },
                    {
                        "username": "jimmiejohnsson84",
                        "content": "There are probably many ways of solving this, but I did not find it to be easy.\\n\\nMy approach was to use breadth first traverse on both left and right subtrees of the root and do a symmetry check of the children. Making sure to swap left/right when adding them into the queue (left child from root->left should be compared to right child of root->right).\\nFeels like this should be bumped to medium as it was not trivial to solve it, dont think I would have made it during an interview call (was fine doing at home like all other leetcode questions are...)"
                    },
                    {
                        "username": "jacksonyyy",
                        "content": "it\\'s just the same question of \"compare two tree\\'\\'"
                    },
                    {
                        "username": "sanketdawange6",
                        "content": "Use level order traversal.\\nAppend each level node to a vector\\nIf that vector is not palindrome return false;\\nRepeat yet the the tree finished finally return true;"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "sumantaraj",
                        "content": "class Solution {\\npublic:\\nbool check(TreeNode* root1,TreeNode* root2){\\n    //base case\\n    if(root1==NULL && root2==NULL)\\n    return true;\\n    if(root1==NULL && root2!=NULL)\\n    return false;\\n    if(root1!=NULL && root2==NULL)\\n    return false;\\n    if(root1->val!=root2->val)\\n    return false;\\n    bool op1=check(root1->left,root2->right);\\n    bool op2=check(root1->right,root2->left);\\n    bool final= op1 && op2;\\n    return final;\\n}\\n    bool isSymmetric(TreeNode* root) {\\n        if(root==NULL)\\n        return true;\\n        return check(root->left,root->right);\\n         }\\n};"
                    },
                    {
                        "username": "_tofu_",
                        "content": "The new UI is ugly"
                    },
                    {
                        "username": "aman3091",
                        "content": "Please help me I am not able to clear [1,2,2,2,null,2] test case. what is wrong with my code i have use vertical order traversal for this.\\nbool isSymmetric(TreeNode* root) {\\n        if(root==NULL){\\n            return 1;\\n        }\\n        map<int,map<int,multiset<int>>>mp;\\n        queue<pair<TreeNode*,pair<int,int>>>q;\\n        q.push({root,{0,0}});\\n        int z=0;\\n        while(!q.empty()){\\n            auto p=q.front();\\n            q.pop();\\n        TreeNode* temp=p.first;\\n        int x=p.second.first;\\n        int y=p.second.second;\\n        mp[x][y].insert(temp->val);\\n        z=max(z,x);\\n        if(temp->left!=NULL){\\n            q.push({temp->left,{x-1,y+1}});\\n        }\\n        if(temp->right!=NULL){\\n            q.push({temp->right,{x+1,y+1}});\\n        }\\n        }\\n     for(int i=0;i<=z;i++){\\n         if(mp[i]!=mp[-1*i]){\\n             return 0;\\n         }\\n     }\\n        return 1;\\n\\n    }"
                    }
                ]
            }
        ]
    },
    {
        "title": "Valid Triangle Number",
        "question_content": "<p>Given an integer array <code>nums</code>, return <em>the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,2,3,4]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> Valid combinations are: \n2,3,4 (using the first 2)\n2,3,4 (using the second 2)\n2,2,3\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [4,2,3,4]\n<strong>Output:</strong> 4\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 128135,
                "title": "a-similar-o-n-2-solution-to-3-sum",
                "content": "This problem is very similar to 3-Sum, in 3-Sum, we can use three pointers (i, j, k and i < j < k) to solve the problem in O(n^2) time for a sorted array, the way we do in 3-Sum is that we first lock pointer i and then scan j and k, if nums[j] + nums[k] is too large, k--, otherwise j++, once we complete the scan, increase pointer i and repeat.\\n\\nFor this problem, once we sort the input array nums, the key to solve the problem is that given nums[k], count the combination of i and j where nums[i] + nums[j] > nums[k] (so that they can form a triangle). If nums[i] + nums[j] is larger than nums[k], we know that there will be j - i combination.\\n\\nLet\\'s take the following array for example, let\\'s mark the three pointers:\\n```\\n i                  j   k\\n[3, 19, 22, 24, 35, 82, 84]\\n```\\nbecause 3 + 82 > 84 and the numbers between 3 and 82 are always larger than 3, so we can quickly tell that there will be j - i combination which can form the triangle, and they are:\\n```\\n3,  82, 84\\n19, 82, 84\\n22, 82, 84\\n24, 82, 84\\n35, 82, 84\\n```\\nNow let\\'s lock k and point to 35:\\n```\\n i          j   k\\n[3, 19, 22, 24, 35, 82, 84]\\n```\\nbecause 3 + 24 < 35, if we move j to the left, the sum will become even smaller, so we have to move pointer i to the next number 19, and now we found that 19 + 24 > 35, and we don\\'t need to scan 22, we know that 22 must be ok!\\n\\nFollowing is the JavaScript solution:\\n```\\nconst triangleNumber = nums => {\\n  nums.sort((a, b) => a - b);\\n\\n  let count = 0;\\n\\n  for (let k = nums.length - 1; k > 1; k--) {\\n    for (let i = 0, j = k - 1; i < j;) {\\n      if (nums[i] + nums[j] > nums[k]) {\\n        count += j - i;\\n        j--;\\n      } else {\\n        i++;\\n      }\\n    }\\n  }\\n\\n  return count;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n i                  j   k\\n[3, 19, 22, 24, 35, 82, 84]\\n```\n```\\n3,  82, 84\\n19, 82, 84\\n22, 82, 84\\n24, 82, 84\\n35, 82, 84\\n```\n```\\n i          j   k\\n[3, 19, 22, 24, 35, 82, 84]\\n```\n```\\nconst triangleNumber = nums => {\\n  nums.sort((a, b) => a - b);\\n\\n  let count = 0;\\n\\n  for (let k = nums.length - 1; k > 1; k--) {\\n    for (let i = 0, j = k - 1; i < j;) {\\n      if (nums[i] + nums[j] > nums[k]) {\\n        count += j - i;\\n        j--;\\n      } else {\\n        i++;\\n      }\\n    }\\n  }\\n\\n  return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 104174,
                "title": "java-o-n-2-time-o-1-space",
                "content": "```\\npublic static int triangleNumber(int[] A) {\\n    Arrays.sort(A);\\n    int count = 0, n = A.length;\\n    for (int i=n-1;i>=2;i--) {\\n        int l = 0, r = i-1;\\n        while (l < r) {\\n            if (A[l] + A[r] > A[i]) {\\n                count += r-l;\\n                r--;\\n            }\\n            else l++;\\n        }\\n    }\\n    return count;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic static int triangleNumber(int[] A) {\\n    Arrays.sort(A);\\n    int count = 0, n = A.length;\\n    for (int i=n-1;i>=2;i--) {\\n        int l = 0, r = i-1;\\n        while (l < r) {\\n            if (A[l] + A[r] > A[i]) {\\n                count += r-l;\\n                r--;\\n            }\\n            else l++;\\n        }\\n    }\\n    return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1339340,
                "title": "c-java-python-two-pointers-picture-explain-clean-concise-o-n-2",
                "content": "**\\u2714\\uFE0F Solution 1: Two Pointer**\\n\\n**Theorem**:  In a triangle, the length of any side is less than the sum of the other two sides.\\n![image](https://assets.leetcode.com/users/images/3a8ebfd1-b8e4-4931-a525-29f8b7a08a54_1626365313.7172236.png)\\n- So 3 side lengths `a`, `b`, `c` can form a Triangle if and only if `a + b > c` && `a + c > b` && `b + c > a`.\\n- To make it simple, let `c` present maximum side among 3 sides `a`, `b`, `c`, it means `c >= a` and `c >= b`, so we have:\\n\\t- `a + c > b`, since `c >= b` and `a, b, c > 0` (prove all side of triangle must be greater than zero?)\\n\\t- `b + c > a`, since `c >= a` and `a, b, c > 0` (prove all side of triangle must be greater than zero?)\\n- All we need to do is that we find number of pairs `a`, `b` so that `a + b > c` and `c >= a`, `c >= b`.\\n\\n**Prove all side of triangle must be greater than zero?**\\n- If one side of triangle is zero, let the smallest side is zero, so `a = 0`.\\n- To form a valid triangle, `a + b > c` <=> `0 + b > c` <=> `b > c`, which is incorrect. Since `c` is the largest side.\\n\\n**Algorithm**\\n- Let sort `nums` in increasing order.\\n- Let `nums[i]` is the smallest element, `nums[j]` is the middle element, `nums[k]` is the largest element `(i < j < k)`. Then `nums[i], nums[j], nums[k]` can form a valid **Triangle** if and only if **nums[i] + nums[j] > nums[k]**.\\n\\nNow, the problem become the same with **[259. 3Sum Smaller](https://leetcode.com/problems/3sum-smaller/)**\\n- We fix `nums[k]`, by iterating `k` in range `[2..n-1]`, the answer is the total number of pairs `(nums[i]`, `nums[j])` for each `nums[k]`, `(i < j < k)`, so that `nums[i] + nums[j] > nums[k]`.\\n\\t- We start with` i = 0`, `j = k - 1`\\n\\t- If `nums[i] + nums[j] > nums[k]` then:\\n\\t\\t-  There are `j-i` valid pairs, because in that case, when `nums[k]` and `nums[j]` are fixed, moving `i` to the right side always causes `nums[i] + nums[j] > nums[k]`.\\n\\t\\t-  Try another `nums[j]` by decreasing `j` by one, so `j -= 1`.\\n\\t- Else if `nums[i] + nums[j] <= nums[k]` then:\\n\\t\\t- Because `nums[k]` is fixed, to make the inequality correct, we need to increase sum of `nums[i] + nums[j]`.\\n\\t\\t- There is only one choice is to increase `nums[i]`, so `i += 1`.\\n\\n![image](https://assets.leetcode.com/users/images/494bd84a-a716-41d9-9d21-cee1a4cb1df5_1626399365.2078004.png)\\n\\n\\n<iframe src=\"https://leetcode.com/playground/CjfWgLo9/shared\" frameBorder=\"0\" width=\"100%\" height=\"400\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N^2)`, where `N <= 1000` is number of elements in the array `nums`.\\n- Space: `O(sorting)`\\n\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "**\\u2714\\uFE0F Solution 1: Two Pointer**\\n\\n**Theorem**:  In a triangle, the length of any side is less than the sum of the other two sides.\\n![image](https://assets.leetcode.com/users/images/3a8ebfd1-b8e4-4931-a525-29f8b7a08a54_1626365313.7172236.png)\\n- So 3 side lengths `a`, `b`, `c` can form a Triangle if and only if `a + b > c` && `a + c > b` && `b + c > a`.\\n- To make it simple, let `c` present maximum side among 3 sides `a`, `b`, `c`, it means `c >= a` and `c >= b`, so we have:\\n\\t- `a + c > b`, since `c >= b` and `a, b, c > 0` (prove all side of triangle must be greater than zero?)\\n\\t- `b + c > a`, since `c >= a` and `a, b, c > 0` (prove all side of triangle must be greater than zero?)\\n- All we need to do is that we find number of pairs `a`, `b` so that `a + b > c` and `c >= a`, `c >= b`.\\n\\n**Prove all side of triangle must be greater than zero?**\\n- If one side of triangle is zero, let the smallest side is zero, so `a = 0`.\\n- To form a valid triangle, `a + b > c` <=> `0 + b > c` <=> `b > c`, which is incorrect. Since `c` is the largest side.\\n\\n**Algorithm**\\n- Let sort `nums` in increasing order.\\n- Let `nums[i]` is the smallest element, `nums[j]` is the middle element, `nums[k]` is the largest element `(i < j < k)`. Then `nums[i], nums[j], nums[k]` can form a valid **Triangle** if and only if **nums[i] + nums[j] > nums[k]**.\\n\\nNow, the problem become the same with **[259. 3Sum Smaller](https://leetcode.com/problems/3sum-smaller/)**\\n- We fix `nums[k]`, by iterating `k` in range `[2..n-1]`, the answer is the total number of pairs `(nums[i]`, `nums[j])` for each `nums[k]`, `(i < j < k)`, so that `nums[i] + nums[j] > nums[k]`.\\n\\t- We start with` i = 0`, `j = k - 1`\\n\\t- If `nums[i] + nums[j] > nums[k]` then:\\n\\t\\t-  There are `j-i` valid pairs, because in that case, when `nums[k]` and `nums[j]` are fixed, moving `i` to the right side always causes `nums[i] + nums[j] > nums[k]`.\\n\\t\\t-  Try another `nums[j]` by decreasing `j` by one, so `j -= 1`.\\n\\t- Else if `nums[i] + nums[j] <= nums[k]` then:\\n\\t\\t- Because `nums[k]` is fixed, to make the inequality correct, we need to increase sum of `nums[i] + nums[j]`.\\n\\t\\t- There is only one choice is to increase `nums[i]`, so `i += 1`.\\n\\n![image](https://assets.leetcode.com/users/images/494bd84a-a716-41d9-9d21-cee1a4cb1df5_1626399365.2078004.png)\\n\\n\\n<iframe src=\"https://leetcode.com/playground/CjfWgLo9/shared\" frameBorder=\"0\" width=\"100%\" height=\"400\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N^2)`, where `N <= 1000` is number of elements in the array `nums`.\\n- Space: `O(sorting)`\\n\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "codeTag": "Unknown"
            },
            {
                "id": 1339248,
                "title": "python-sort-2-pointers-solution-explained",
                "content": "Let `n` be number of our numbers. Then bruteforce solution is `O(n^3)`. Another approach is to sort numbers and for each pair `a_i` and `a_j`, where `i<j` we need to find the biggest index `k`, such that `a_k < a_i + a_j`. It can be done with binary search with overall complexity `O(n^2 * log n)`.\\n\\nThere is even better solution, using two pointers approach. Let us choose first index `i`. Then we need to find number of pairs `(left, right)` where `left < right < i` and `a_{left} + a_{right} > a_i`. Let us start with `left = 1` and `right = i-1`. Then we can use **Two Pointers** approach to find number of desired pairs in`O(n)` for fixed `i`. Note, that it is very similar to all **2Sum** or **3Sum** problems.\\n\\n#### Complexity\\nTime complexity is `O(n^2)`, space complexity is `O(1)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def triangleNumber(self, nums):\\n        nums, count, n = sorted(nums), 0, len(nums)\\n        for i in range(2, n):\\n            left, right = 0, i-1\\n            while left < right:\\n                if nums[left] + nums[right] > nums[i]:\\n                    count += (right - left)\\n                    right -= 1\\n                else:\\n                    left += 1\\n        return count\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```python\\nclass Solution:\\n    def triangleNumber(self, nums):\\n        nums, count, n = sorted(nums), 0, len(nums)\\n        for i in range(2, n):\\n            left, right = 0, i-1\\n            while left < right:\\n                if nums[left] + nums[right] > nums[i]:\\n                    count += (right - left)\\n                    right -= 1\\n                else:\\n                    left += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 104169,
                "title": "java-solution-3-pointers",
                "content": "Same as https://leetcode.com/problems/3sum-closest\\n\\nAssume ```a``` is the longest edge, ```b``` and ```c``` are shorter ones, to form a triangle, they need to satisfy ```len(b) + len(c) > len(a)```.\\n\\n```\\npublic class Solution {\\n    public int triangleNumber(int[] nums) {\\n        int result = 0;\\n        if (nums.length < 3) return result;\\n        \\n        Arrays.sort(nums);\\n\\n        for (int i = 2; i < nums.length; i++) {\\n            int left = 0, right = i - 1;\\n            while (left < right) {\\n                if (nums[left] + nums[right] > nums[i]) {\\n                    result += (right - left);\\n                    right--;\\n                }\\n                else {\\n                    left++;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```a```\n```b```\n```c```\n```len(b) + len(c) > len(a)```\n```\\npublic class Solution {\\n    public int triangleNumber(int[] nums) {\\n        int result = 0;\\n        if (nums.length < 3) return result;\\n        \\n        Arrays.sort(nums);\\n\\n        for (int i = 2; i < nums.length; i++) {\\n            int left = 0, right = i - 1;\\n            while (left < right) {\\n                if (nums[left] + nums[right] > nums[i]) {\\n                    result += (right - left);\\n                    right--;\\n                }\\n                else {\\n                    left++;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339071,
                "title": "c-simple-and-clean-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        int res = 0, n = nums.size();\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        for (int i = n-1; i >= 0; i--) {\\n            int lo = 0, hi = i-1;\\n            \\n            while (lo < hi) {\\n                if (nums[lo] + nums[hi] > nums[i]) {\\n                    res += hi - lo;\\n                    hi--;\\n                }\\n                \\n                else lo++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        int res = 0, n = nums.size();\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        for (int i = n-1; i >= 0; i--) {\\n            int lo = 0, hi = i-1;\\n            \\n            while (lo < hi) {\\n                if (nums[lo] + nums[hi] > nums[i]) {\\n                    res += hi - lo;\\n                    hi--;\\n                }\\n                \\n                else lo++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 199315,
                "title": "python3-o-n-2-pointer-solution",
                "content": "```\\nclass Solution:\\n    def triangleNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        c = 0\\n        n = len(nums)\\n        nums.sort()\\n        for i in range(n-1,1,-1):\\n            lo = 0\\n            hi = i - 1\\n            while lo < hi:\\n                if nums[hi]+nums[lo] > nums[i]:\\n                    c += hi-lo\\n                    hi -= 1\\n                else:\\n                    lo += 1\\n        return c\\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def triangleNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        c = 0\\n        n = len(nums)\\n        nums.sort()\\n        for i in range(n-1,1,-1):\\n            lo = 0\\n            hi = i - 1\\n            while lo < hi:\\n                if nums[hi]+nums[lo] > nums[i]:\\n                    c += hi-lo\\n                    hi -= 1\\n                else:\\n                    lo += 1\\n        return c\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 104177,
                "title": "o-n-2-solution-for-c-python",
                "content": "c++\\n```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        vector<int> snums(nums);\\n        sort(snums.begin(), snums.end());\\n        int count = 0;\\n        for ( int n = nums.size(), k = n - 1; k > 1; --k ) {\\n            int i = 0, j = k - 1;\\n            while ( i < j ) {\\n                // any value x between i...j will satisfy snums[x] + snums[j] > snums[k]\\n                // and because snums[k] > snums[j] > snums[x] >= 0, they will always satisfy\\n                // snums[k] + snums[x] > snums[j] and snums[k] + snums[j] > snums[x]\\n                if ( snums[i] + snums[j] > snums[k] )\\n                    count += --j - i + 1;\\n                else\\n                    ++i;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n// 243 / 243 test cases passed.\\n// Status: Accepted\\n// Runtime: 59 ms\\n```\\npython solution, sometimes it might fail TLE\\n```\\nclass Solution(object):\\n    def triangleNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums, count, n = sorted(nums, reverse=1), 0, len(nums)\\n        for i in xrange(n):\\n            j, k = i + 1, n - 1\\n            while j < k:\\n                # any value x between j...k will satisfy nums[j] + nums[x] > nums[i]\\n                # and because nums[i] > nums[j] > nums[x] >= 0, they will always satisfy\\n                # nums[i] + nums[x] > nums[j] and nums[i] + nums[j] > nums[x]\\n                if nums[j] + nums[k] > nums[i]:\\n                    count += k - j\\n                    j += 1\\n                else:\\n                    k -= 1\\n        return count\\n\\n# 243 / 243 test cases passed.\\n# Status: Accepted\\n# Runtime: 1855 ms\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        vector<int> snums(nums);\\n        sort(snums.begin(), snums.end());\\n        int count = 0;\\n        for ( int n = nums.size(), k = n - 1; k > 1; --k ) {\\n            int i = 0, j = k - 1;\\n            while ( i < j ) {\\n                // any value x between i...j will satisfy snums[x] + snums[j] > snums[k]\\n                // and because snums[k] > snums[j] > snums[x] >= 0, they will always satisfy\\n                // snums[k] + snums[x] > snums[j] and snums[k] + snums[j] > snums[x]\\n                if ( snums[i] + snums[j] > snums[k] )\\n                    count += --j - i + 1;\\n                else\\n                    ++i;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n// 243 / 243 test cases passed.\\n// Status: Accepted\\n// Runtime: 59 ms\\n```\n```\\nclass Solution(object):\\n    def triangleNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums, count, n = sorted(nums, reverse=1), 0, len(nums)\\n        for i in xrange(n):\\n            j, k = i + 1, n - 1\\n            while j < k:\\n                # any value x between j...k will satisfy nums[j] + nums[x] > nums[i]\\n                # and because nums[i] > nums[j] > nums[x] >= 0, they will always satisfy\\n                # nums[i] + nums[x] > nums[j] and nums[i] + nums[j] > nums[x]\\n                if nums[j] + nums[k] > nums[i]:\\n                    count += k - j\\n                    j += 1\\n                else:\\n                    k -= 1\\n        return count\\n\\n# 243 / 243 test cases passed.\\n# Status: Accepted\\n# Runtime: 1855 ms\\n```",
                "codeTag": "Java"
            },
            {
                "id": 284875,
                "title": "python3-solution-in-o-n-2-log-n-using-bisect-left",
                "content": "```\\nfrom bisect import bisect_left\\n\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        ans = 0\\n        for i in range(n):\\n            for j in range(i+1, n):\\n                k = bisect_left(nums, nums[i] + nums[j])\\n                ans += max(0, k - 1 - j)\\n        return ans\\n```\\t\\t",
                "solutionTags": [],
                "code": "```\\nfrom bisect import bisect_left\\n\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        ans = 0\\n        for i in range(n):\\n            for j in range(i+1, n):\\n                k = bisect_left(nums, nums[i] + nums[j])\\n                ans += max(0, k - 1 - j)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929541,
                "title": "c-detailed-explanation-two-pointer-clear-intuitions",
                "content": "# ****INTUITIONS:\\n## We will understand with an example [1 , 2 , 3 , 5 , 6 , 7, 9]\\n## After sorting , Take pointer left as 0 , take right as n-1 (intially as loop will be going for it from n-1 to 2) . Take mid as right-1 intially . \\n\\n## while(left<mid) , now check the nums[left] + nums[mid] > nums[right] , if this exists then for all ( p=left to p=mid-1) there exist possibility as all the values after the nums[left] are greater than nums[left] .\\n\\n## Possibilities are as follows :\\n## {left , mid , right} , {left+1 , mid , right} , {left+2 , mid , right} , ..... {mid-1 , mid , right} .  ans +=(mid-left) and also decrese mid as all possible possibility of (  [] , mid , right) has been taken. so mid--;\\n\\n\\n\\n## when nums[left]+nums[mid] > nums[right] , not exists in this case we increment the left as to see the possibility of existing the condition . U may think why would are not changing mid , as decresing mid will lead to decrementing the (nums[l]+nums[mid]) value , it does not leads to our required condition .\\n\\n## [1 , 2 , 3 , 4 , 6 , 7, 9] right at 9 , left at 1 , mid at 7 . so sum = 1 + 7 > 9 : FALSE (left++)\\n## left at 2 , mid at 7 , right at 9 sum=2+7>9 :false\\n## left at 3, mid at 7 , right at 9 sum=3+7>9 :true ans+=(mid-left) {3,7,9} , {5,7,9} , {6,7,9}\\n# after taking it decrease mid-- . \\n## left at 3 , mid at 6 , right at 9 . 3+6>9:false . so , left++\\n## left at 4 , mid at 6 , right at 9 , 4+6>9 : true ans+=(mid-left) { 4 , 6 , 9} .\\n\\n## while loop will run till(left<mid) \\n\\n## for loop of right will ru from right=n-1 to 2.\\n\\n# **IF U FIND IT HEPLFUL , PLEASE UPVOTE!!!**\\n\\n\\n\\n\\n```\\n int triangleNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        int ans=0;\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n\\t\\t/*taking left -> leftmost number  , mid -> middle element , right -> rightmost elemnt\\n        left is smallest one , mid -> middle element , right is largest one*/\\n        \\n        for(int right=n-1 ; right>=2 ;right--)\\n        {\\n            int left=0;\\n            int mid=right-1;\\n            while(left<mid)\\n            {\\n                \\n                 if(nums[left]+nums[mid]>nums[right])\\n                 {\\n                       ans+=(mid-left);\\n                       mid--;\\n                 }\\n                 else\\n                 {\\n                      left++;\\n                 }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\n int triangleNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n        int ans=0;\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n\\t\\t/*taking left -> leftmost number  , mid -> middle element , right -> rightmost elemnt\\n        left is smallest one , mid -> middle element , right is largest one*/\\n        \\n        for(int right=n-1 ; right>=2 ;right--)\\n        {\\n            int left=0;\\n            int mid=right-1;\\n            while(left<mid)\\n            {\\n                \\n                 if(nums[left]+nums[mid]>nums[right])\\n                 {\\n                       ans+=(mid-left);\\n                       mid--;\\n                 }\\n                 else\\n                 {\\n                      left++;\\n                 }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 487683,
                "title": "python-o-n-2-sol-based-on-sliding-window-and-sorting-85-with-explanation",
                "content": "Python O( n^2 ) sol. based on sliding window and sorting.\\n\\nMain idea:\\n1. [ Pre-processing ] Use in-place nums.**sort()** to **keep numbers in ascending order**\\n\\n2. First **fix third edge with current largest one**, then **maintain a sliding window** to **compute all valid pairs** of **first edge** and **second edge**\\n\\n3. Catch valid edges with **triangle\\'s basic property**: **a + b > c must be True** for **any two edges a, b**\\n\\n4. This algorithm is making triplets with the rule: **smallest edge A + medium edge B> largest edge C**, \\nand also guarantees that other two cases must be True, \\ni.e., \\nsmallest edge A + largest edge C > medium edge B, and \\nmedium edge B+ largest edge C > smallest edge A\\n\\n---\\n\\n```\\n\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        \\n        # sort in-place\\n        # keep numbers in ascending order\\n        nums.sort()\\n        \\n        # counter for valid triplet to make triangle\\n        valid_triplet = 0\\n        \\n        for index_i in range( len(nums)-1, 1, -1):\\n            \\n            third_edge = nums[index_i]\\n            \\n            index_of_first_edge, index_of_second_edge = 0, index_i - 1\\n            \\n            while index_of_first_edge < index_of_second_edge:\\n                \\n                first_edge = nums[index_of_first_edge]\\n                second_edge = nums[index_of_second_edge]\\n                \\n                if first_edge + second_edge > third_edge:\\n                    \\n                    # valid triplets\\n                    # first_edge    : from nums[index_of_first_edge] to nums[(index_of_second_edge-1)]\\n                    # second edge   : nums[index_of_second_edge]\\n                    # third edge    : nums[index_i]\\n                    valid_triplet += ( index_of_second_edge - index_of_first_edge )\\n        \\n                    # second edge large enough\\n                    # make it smaller and try next run\\n                    index_of_second_edge -= 1\\n                else:\\n                    # first edge is too small\\n                    # make it larger and try next run\\n                    index_of_first_edge += 1\\n        \\n        \\n        \\n        return valid_triplet\\n        \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```\\n\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        \\n        # sort in-place\\n        # keep numbers in ascending order\\n        nums.sort()\\n        \\n        # counter for valid triplet to make triangle\\n        valid_triplet = 0\\n        \\n        for index_i in range( len(nums)-1, 1, -1):\\n            \\n            third_edge = nums[index_i]\\n            \\n            index_of_first_edge, index_of_second_edge = 0, index_i - 1\\n            \\n            while index_of_first_edge < index_of_second_edge:\\n                \\n                first_edge = nums[index_of_first_edge]\\n                second_edge = nums[index_of_second_edge]\\n                \\n                if first_edge + second_edge > third_edge:\\n                    \\n                    # valid triplets\\n                    # first_edge    : from nums[index_of_first_edge] to nums[(index_of_second_edge-1)]\\n                    # second edge   : nums[index_of_second_edge]\\n                    # third edge    : nums[index_i]\\n                    valid_triplet += ( index_of_second_edge - index_of_first_edge )\\n        \\n                    # second edge large enough\\n                    # make it smaller and try next run\\n                    index_of_second_edge -= 1\\n                else:\\n                    # first edge is too small\\n                    # make it larger and try next run\\n                    index_of_first_edge += 1\\n        \\n        \\n        \\n        return valid_triplet\\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2218105,
                "title": "c-brut-force-to-optimal-faster-then-100-00",
                "content": "**Theorem**: In a triangle, the length of any side is less than the sum of the other two sides.\\n![image](https://assets.leetcode.com/users/images/3e1c1958-53ca-4f57-8058-23fbe524cf97_1656587820.0885897.png)\\n\\n**Brut-Force solutions:**\\nit  give **TLE**\\n```\\nclass Solution {\\npublic:\\n// If the sum of any two side lengths is greater than the third in every combination\\n    int triangleNumber(vector<int>& a) {\\n        sort(a.begin(), a.end());\\n        int ans=0, n = a.size();\\n        for(int i=0; i<n; i++){\\n            for(int j=i+1; j<n; j++){\\n                    for(int k=j+1; k<n; k++){\\n                        if(a[i]+a[j]>a[k]){\\n                            // cout<<a[i]<<\" \"<<a[j]<<\" \"<<a[k]<<\"  \";\\n                             ans++;\\n                        }\\n                        else    break;\\n                    }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n* **optimal approch** :-**\\n* So 3 side lengths a, b, c can form a Triangle if and only if a + b > c && a + c > b && b + c > a.\\n* To make it simple, we can sort nums in increasing order.\\n* Let nums[i] is the smallest element, nums[j] is the middle element, nums[k] is the largest element (i < j < k). Then nums[i], nums[j], nums[k] can form a valid Triangle if and only if **nums[i] + nums[j] > nums[k].**\\n\\n* We fix nums[k], by iterating k in range [2..n-1], the answer is the total number of pairs (nums[i], nums[j]) for each nums[k], (i < j < k), so that nums[i] + nums[j] > nums[k].\\n\\n* We start withi = 0, j = k - 1\\n* If nums[i] + nums[j] > nums[k] then:\\n* There are j-i valid pairs, because in that case, when nums[k] and nums[j] are fixed, moving i to the right side always causes nums[i] + nums[j] > nums[k].\\n* Try another nums[j] by decreasing j by one, so j -= 1.\\n* Else if nums[i] + nums[j] <= nums[k] then:\\n* Because nums[k] is fixed, to make the inequality correct, we need to increase sum of nums[i] + nums[j].\\n* There is only one choice is to increase nums[i], so i += 1.\\n*\\n\\n![image](https://assets.leetcode.com/users/images/af2c8e79-4f0a-4032-9a10-6185e0672f7a_1656587940.645748.png)\\n\\n**C++ Code**\\n\\n```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size(), ans = 0;\\n        for (int k = 2; k < n; ++k) {\\n            int i = 0, j = k - 1;\\n            while (i < j) {\\n                if (nums[i] + nums[j] > nums[k]) {\\n                    ans += j - i;\\n                    j -= 1;\\n                } else {\\n                    i += 1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**If you think this post is useful, I\\'m happy if you give a vote. Any questions or discussions are welcome! Thank a lot. Balence the number of view and upvote\\uD83D\\uDE01**\\n\\n**Complexity**\\n\\n* Time: O(N^2), where N <= 1000 is number of elements in the array nums.\\n* Space: O(logN), logN is the space complexity for sorting.\\n\\n**If you think this post is useful, I\\'m happy if you give a vote. Any questions or discussions are welcome! Thank a lot.**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n// If the sum of any two side lengths is greater than the third in every combination\\n    int triangleNumber(vector<int>& a) {\\n        sort(a.begin(), a.end());\\n        int ans=0, n = a.size();\\n        for(int i=0; i<n; i++){\\n            for(int j=i+1; j<n; j++){\\n                    for(int k=j+1; k<n; k++){\\n                        if(a[i]+a[j]>a[k]){\\n                            // cout<<a[i]<<\" \"<<a[j]<<\" \"<<a[k]<<\"  \";\\n                             ans++;\\n                        }\\n                        else    break;\\n                    }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size(), ans = 0;\\n        for (int k = 2; k < n; ++k) {\\n            int i = 0, j = k - 1;\\n            while (i < j) {\\n                if (nums[i] + nums[j] > nums[k]) {\\n                    ans += j - i;\\n                    j -= 1;\\n                } else {\\n                    i += 1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 104200,
                "title": "solution-similar-to-leetcode-259-3sum-smaller",
                "content": " /** we need to find 3 number,  i < j < k, and a[i] + a[j] > a[k];\\n\\t *  if we sort the array, then we can easily use two pointer to find all the pairs we need.\\n\\t *  if at some point a[left] + a[right] > a[i], all the elements from left to right-1 are valid.\\n\\t *  because they are all greater then a[left];\\n\\t *  so we do count += right - left;  and right--\\n\\t *  \\n\\t *  otherwise, we increment left till we get a valid pair.\\n\\n\\n```\\npublic int triangleNumber(int[] nums) {\\n\\t\\tif (nums == null || nums.length <= 2) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tArrays.sort(nums);\\n\\t\\tint count = 0;\\n\\t\\t\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tint left = 0, right = i-1;\\n\\t\\t\\twhile (left < right) {\\n\\t\\t\\t\\tif (nums[left] + nums[right] > nums[i]) {\\n\\t\\t\\t\\t\\tcount += right - left;\\n\\t\\t\\t\\t\\tright--;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int triangleNumber(int[] nums) {\\n\\t\\tif (nums == null || nums.length <= 2) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tArrays.sort(nums);\\n\\t\\tint count = 0;\\n\\t\\t\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tint left = 0, right = i-1;\\n\\t\\t\\twhile (left < right) {\\n\\t\\t\\t\\tif (nums[left] + nums[right] > nums[i]) {\\n\\t\\t\\t\\t\\tcount += right - left;\\n\\t\\t\\t\\t\\tright--;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tleft++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 321367,
                "title": "java-binary-search-log-n-n-2-and-two-pointer-o-n-2",
                "content": "````\\nBinary search: \\nloop all the combination of the first two edges, and then binary search the position of third edge. It should be the last index that smaller than sum(edge1 + edge2).  \\nIf there is no edge meet the a+b> c, then return -1. Count will not include return value of -1\\n\\nclass Solution {\\n    public int triangleNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int count = 0;\\n        for (int i = 0; i < n - 2; i++) {\\n            for (int j = i + 1; j < n - 1; j++) {\\n                int sum = nums[i] + nums[j];\\n                // find the first number < sum, return the index\\n                int temp = binarySearch(j + 1, sum, nums);\\n                // System.out.println(\"\\xEF: \" + nums[i] + \" j: \" + nums[j]);\\n                // System.out.println(temp);\\n                if (temp != -1) {\\n                    count += temp - j;\\n                } \\n            }\\n        }\\n        return count;\\n    }\\n    \\n  \\n    private int binarySearch(int begin, int sum, int[] nums) {\\n        int end = nums.length - 1;\\n        int start = begin;\\n        while (start + 1 < end) {\\n            int mid = start + (end - start)/2;\\n            if (nums[mid] < sum) {\\n                start = mid;\\n            } else {\\n                end = mid;\\n            }\\n        }\\n        if (nums[end] < sum) return end;\\n        if (nums[start] < sum) return start;\\n        return -1;\\n    }\\n}\\n\\nTwo pointer: inspired by 3 sum by using 2 sum two pointer \\nLoop the third edge from the end, and then use Two pointer from start and end\\nif nums[start] + nums[end] < third edge, move start\\nelse move end\\nJust find the boundary, j - i is all the possible combination that ended at j e.g. (3,7), (5,7),(6,7)\\n{3,5,6,7,9}\\n i       j\\nclass Solution {\\n    public int triangleNumber(int[] nums) {\\n        if (nums == null || nums.length < 3) return 0;\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int count = 0;\\n        for (int i = 2; i < n; i++) {\\n            int start = 0;\\n            int end = n - i;\\n            System.out.println(end);\\n            while(start < end) {\\n                if (nums[start] + nums[end] <= nums[n + 1 - i]) {\\n                    start++;\\n                } \\n                if (nums[start] + nums[end] > nums[n + 1 - i]) {\\n                    count += end - start;\\n                    end--;      \\n                } \\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int triangleNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int count = 0;\\n        for (int i = 0; i < n - 2; i++) {\\n            for (int j = i + 1; j < n - 1; j++) {\\n                int sum = nums[i] + nums[j];\\n                // find the first number < sum, return the index\\n                int temp = binarySearch(j + 1, sum, nums);\\n                // System.out.println(\"\\xEF: \" + nums[i] + \" j: \" + nums[j]);\\n                // System.out.println(temp);\\n                if (temp != -1) {\\n                    count += temp - j;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1750976,
                "title": "c-o-n-2-solution-with-explanation-easy-to-understand",
                "content": "So we have to give the count of all the 3 numbers from the array such that they form a triangle;\\nFor 3 sides to form a triangle there are 3 main conditions:\\n1) **s1+s2>s3**\\n2) **s2+s3>s1**\\n3) **s3+s1>s2** (where s1, s2, s3 are the sides of triangle).\\n\\nIf you haven\\'t tried the bruteforce method just take 3 \"for\" loops, iterating the array in each different loop and increment the count if you find a suitable triplet that satisfies the condition;\\nSo assume there are three sides and sort the array(I will tell you why) to get the size in increasing order;\\nWhat will happen is we will get the triplet in form of the **s1<s2<s3**;\\n\\nHere we can notice that since s1 is smaller than s2 and s3, sum of both s2 and s3 will be greater than s1, i.e., **s2+s3>s1**; (1 condition \\u2705)\\nAlso since s3>s2 so even if we add s1 to s3 it will still be greater than s2, i.e., **s3+s1>s2**; (2 condition \\u2705)\\n**All we need to do now is to find the last condition s1+s2>s3 to get our required triplet and that is why we sorted the array;**\\n\\nSo we first start iterating(**variable I**) through the second element to the last element so that index 0 and index 1 elements can be considered;\\nWe intialize the left_pointer(**variable L**) to 0 and right_pointer(**variable R**) just previous to one we are iterating through, in simple words we consider the range of elements previous to where we are currently iterating; (Keep in note **nums[L]<nums[R]<nums[I]** because array is sorted and **I>R>L**)\\nSince the array is sorted nums[I] element will be the largest so we will check if sum of nums[L] and nums[R] is greater than nums[I];\\n\\nIf **no**, then we simply increment the left_pointer to check if the sum of next element and the element at **Rth** index can beat Rth index;\\nIf **yes**, then we **add R-L** to aur answer(I will tell you why) and decrement the right_pointer to check if the sum of element at **Lth** index and the element at previous index to R can still beat** Ith** index;\\n\\n**Big Revelation**: Now why have we taken the **R-L** into our consideration? See if the **sum of element at Lth index** and the **element at Rth index** is larger than **element at Ith index** then, if we take the **sum of next element to Lth index** and the **element at Rth Index** it will still be larger than **element at Ith index**; Reading this makes mind go \\uD83E\\uDD2F? Let\\'s understand this;\\n\\nTake already sorted array [7, 8, 9, 15, 20]; (Assume 0 based indexing in the examples)\\nExample 1: Suppose **Ith** index is 3, **Lth** index is 0 and **Rth** index is 2; (nums[I] = 15, nums[L] = 7, nums[R] = 9)\\nSo we check if nums[L]+nums[R]>nums[I], yes it is, and we have found one triplet but wait we can see that if we go to the next element of left_pointer that is 8 and 8+9>15 which still satisfies our condition; **So we actually got 2 triplets that can form a triangle**; Still scratching your head?\\n\\nExample 2: Suppose **Ith** index is 4, **Lth** index is 0 and **Rth** index is 3; (nums[I] = 20, nums[L] = 7, nums[R] = 15)\\nSo we check if nums[L]+nums[R]>nums[I], yes it is, and we have found one triplet but wait we can see that if we go to the next element of left_pointer it still satisfies our condition(8+15>20) and so on (9+15>20) to next element; \\n**VVIP: So we can conclude if the element at Lth and Rth index satisfy our required condition all the elements between Lth index and Rth index satisfy the same condition too since the array is in increasing order**;\\n\\nHence I have added the range R-L to our answer directly to save time;That\\'s it you have reached the end of this long explanation; \\nIf you do find this solution or it helped you in any way **please upvote this :\")**\\n\\n\\n\\n\\n\\n```\\nif(nums.size()<3) return 0; // you can\\'t form a triangle without 3 sides :\")\\nint res = 0;\\nsort(nums.begin(), nums.end()); // sorted the array so the sides get in increasing order\\n\\nfor(int i = 2; i<nums.size(); i++){\\n\\t// we have started from index 2 so that the index 0 and index 1 elements \\n\\t// can be considered in the iteration.\\n\\tint l = 0, r = i - 1;\\n\\twhile(l < r){\\n\\t\\tif(nums[l] + nums[r] > nums[i]){\\n\\t\\t\\t// if the element at Lth and Rth index satisfy our required condition \\n\\t\\t\\t// all the elements between Lth index and Rth index satisfy the same \\n\\t\\t\\t// condition too since the array is in increasing order\\n\\t\\t\\tres += (r - l);\\n\\t\\t\\tr--;\\n\\t\\t}else{\\n\\t\\t\\tl++;\\n\\t\\t}\\n\\t}\\n}\\nreturn res;\\n```\\n",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nif(nums.size()<3) return 0; // you can\\'t form a triangle without 3 sides :\")\\nint res = 0;\\nsort(nums.begin(), nums.end()); // sorted the array so the sides get in increasing order\\n\\nfor(int i = 2; i<nums.size(); i++){\\n\\t// we have started from index 2 so that the index 0 and index 1 elements \\n\\t// can be considered in the iteration.\\n\\tint l = 0, r = i - 1;\\n\\twhile(l < r){\\n\\t\\tif(nums[l] + nums[r] > nums[i]){\\n\\t\\t\\t// if the element at Lth and Rth index satisfy our required condition \\n\\t\\t\\t// all the elements between Lth index and Rth index satisfy the same \\n\\t\\t\\t// condition too since the array is in increasing order\\n\\t\\t\\tres += (r - l);\\n\\t\\t\\tr--;\\n\\t\\t}else{\\n\\t\\t\\tl++;\\n\\t\\t}\\n\\t}\\n}\\nreturn res;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2101589,
                "title": "c-optimal-solution-easy-to-understand-beginner-s-friendly",
                "content": "**Please Upvote the solution if it helped you because it motivate the creators like us to produce more such content...........**\\n\\n**Happy Coding :-)**\\nCode->\\n```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n         int n=nums.size();\\n        if(n<3) return 0;\\n        sort(nums.begin(),nums.end());\\n       \\n        int count=0;\\n        for(int i=2;i<n;i++){\\n            int s=0;\\n            int e=i-1;\\n            while(s<e){\\n                if(nums[s]+nums[e]>nums[i]){\\n                    count+=e-s;\\n                    e--;\\n                    }\\n                else\\n                    s++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n         int n=nums.size();\\n        if(n<3) return 0;\\n        sort(nums.begin(),nums.end());\\n       \\n        int count=0;\\n        for(int i=2;i<n;i++){\\n            int s=0;\\n            int e=i-1;\\n            while(s<e){\\n                if(nums[s]+nums[e]>nums[i]){\\n                    count+=e-s;\\n                    e--;\\n                    }\\n                else\\n                    s++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 734186,
                "title": "python-o-n-2-explanation-with-diagram",
                "content": "1. Let\\'s assume that a triplet for-loop (i, j, k) is used. Now, consider the following case.\\n\\n![image](https://assets.leetcode.com/users/images/cdcf7fab-b679-4bc8-bcec-d2490386f2f1_1594647564.0569782.png)\\n\\n2. What should we do next? We can either\\n\\n\\t* Advance j, then bring k to j + 1, or - O(N)\\n\\t* Advance j, then hold k where it is - O(1)\\n\\n3. Notice that if `num[i] + num[j] > num[k]`, then all numbers from [j + 1, k - 1] (the green area) must meet the condition. There is no need to drag k all the back to j + 1 and scan the elements all over again.\\n\\n4. Instead, we can set **increment count by the length of the green area** for every j value that we try.\\n\\n```\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        count = 0\\n        nums = sorted(nums)\\n        \\n        # I REPRESENTS OUR 1ST (LHS) NUMBER\\n        for i in range(len(nums) - 2):\\n            \\n            # K REPRESENTS OUR 3RD (RHS) NUMBER\\n            k = i + 2\\n            \\n            # J REPRESENTS OUR 2ND (MID) NUMBER\\n            for j in range(i + 1, len(nums) - 1):\\n                \\n                # KEEP ADVANCING K UNTIL K > SUM(I, J)\\n                while k < len(nums) and nums[k] < nums[i] + nums[j]:\\n                    k += 1\\n                    \\n                # AS SOON AS K > SUM(I, J), RECORD THE COUNT\\n                count += max(0, k - j - 1)\\n                \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        count = 0\\n        nums = sorted(nums)\\n        \\n        # I REPRESENTS OUR 1ST (LHS) NUMBER\\n        for i in range(len(nums) - 2):\\n            \\n            # K REPRESENTS OUR 3RD (RHS) NUMBER\\n            k = i + 2\\n            \\n            # J REPRESENTS OUR 2ND (MID) NUMBER\\n            for j in range(i + 1, len(nums) - 1):\\n                \\n                # KEEP ADVANCING K UNTIL K > SUM(I, J)\\n                while k < len(nums) and nums[k] < nums[i] + nums[j]:\\n                    k += 1\\n                    \\n                # AS SOON AS K > SUM(I, J), RECORD THE COUNT\\n                count += max(0, k - j - 1)\\n                \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 358274,
                "title": "easy-peasy-python-solution-o-n-2-time-o-1-space-with-explanation-very-similar-to-3sum-smaller",
                "content": "\\tdef triangleNumber(self, nums: List[int]) -> int:\\n        ln = len(nums)\\n        if ln < 3:\\n            return 0\\n        res = 0\\n        nums.sort()\\n        \\n        # target(nums[i]) is till index 2, because start and end should be different\\n        # for i == 2, start 0 and end = 1\\n        for i in range(ln-1, 1, -1):\\n            start, end = 0, i-1\\n            target = nums[i]\\n            while start < end:\\n                if nums[start] + nums[end] > target:\\n                    # assuming I fix the end and take all the elements from star to end-1 one by one\\n                    # because, if nums[start] + nums[end] > target then nums[start+k] + nums[end],\\n                    # where k < end is also greater than target\\n                    # so now move on and try with end-1\\n                    res += (end - start)\\n                    end -= 1\\n                else:\\n                    # I need to increase the nums[start] + nums[end], so move forward\\n                    start += 1\\n        \\n        return res\\n\\t\\t\\n\\n#3 sum solution, very similar\\nhttps://leetcode.com/problems/3sum-smaller/discuss/358262/easy-peasy-python-solution-using-sort-O(n2)-with-comments",
                "solutionTags": [],
                "code": "\\tdef triangleNumber(self, nums: List[int]) -> int:\\n        ln = len(nums)\\n        if ln < 3:\\n            return 0\\n        res = 0\\n        nums.sort()\\n        \\n        # target(nums[i]) is till index 2, because start and end should be different\\n        # for i == 2, start 0 and end = 1\\n        for i in range(ln-1, 1, -1):\\n            start, end = 0, i-1\\n            target = nums[i]\\n            while start < end:\\n                if nums[start] + nums[end] > target:\\n                    # assuming I fix the end and take all the elements from star to end-1 one by one\\n                    # because, if nums[start] + nums[end] > target then nums[start+k] + nums[end],\\n                    # where k < end is also greater than target\\n                    # so now move on and try with end-1\\n                    res += (end - start)\\n                    end -= 1\\n                else:\\n                    # I need to increase the nums[start] + nums[end], so move forward\\n                    start += 1\\n        \\n        return res\\n\\t\\t\\n\\n#3 sum solution, very similar\\nhttps://leetcode.com/problems/3sum-smaller/discuss/358262/easy-peasy-python-solution-using-sort-O(n2)-with-comments",
                "codeTag": "Python3"
            },
            {
                "id": 2725111,
                "title": "python-o-n-3-o-n-2-logn-o-n-2",
                "content": "## **1. BRUTE FORCE - O(N^3)**\\n\\nThe most straightforward way is to have three nested loops and try to find all the combinations of sides a,b and c such that - \\n\\t\\t\\n\\t\\t\\ta + b > c\\n\\t\\t\\ta + c > b\\n\\t\\t\\tb + c > a\\n\\t\\t\\t\\nWill give TLE for large inputs.\\n\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        count = 0\\n        \\n        nums.sort()\\n        \\n        for i1 in range(len(nums)):\\n            for i2 in range(i1 + 1, len(nums)):\\n                for i3 in range(i2 + 1, len(nums)):\\n                    \\n                    condition1 = nums[i1] +  nums[i2] >  nums[i3]\\n                    condition2 = nums[i1] +  nums[i3] >  nums[i2]\\n                    condition3 = nums[i2] +  nums[i3] >  nums[i1]\\n                    \\n                    if condition1 and condition2 and condition3:  count += 1\\n                        \\n        return count\\n\\t\\t\\n## **2. BINARY SEARCH - O(N^2 * LogN) (TLE in Python, works in Java)**\\n\\nIf we sort the given list, then we can use Binary search to get the time complexity down from O(N^3) to O(N^2 * LogN). As you can notice, we will do that by using Binary Search on the inner most loop instead of linear search i.e., O(N) to O(LogN)\\n\\n\\tLets take  nums = [2,2,3,4]\\n\\t\\n\\tSo, we will still have two nested for loops for two sides. So initially,\\n\\t\\n\\twe have \\n\\t\\n\\t\\ta = 2\\n\\t\\tb = 2\\n\\t\\t\\n\\tAnd we want to search a side c. \\n\\nWhat should be the criteria to search side c? How can we say if a particular side \"c\" is valid?\\n\\t\\n\\tNotice the conditions - \\n\\t\\n\\t\\t\\ta + b > c\\n\\t\\t\\ta + c > b\\n\\t\\t\\tb + c > a\\n\\t\\n\\tSince we have sorted our list, that means \"c\" will always be bigger or equal to a and b. \\n\\t\\n\\tThat also means, \\n\\t\\t\\t\\n\\t\\t\\t\\ta + c > b \\n\\t\\t\\t\\t  and \\n\\t\\t\\t\\tb + c > a\\n\\t\\t\\t\\t\\n\\twill always be true for any value of \"c\" because c is >= a and c >= b\\n\\t\\n\\t\\n\\tSo the only condition left is a + b > c\\n\\t\\n\\tSince the array is sorted, that means if we can find the largest possible value of \"c\" \\n\\tsuch that it is still smaller than \"a +b\", \\n\\tthen all the numbers in between will be all the value values of third side.\\n\\t\\n\\te.g. [2,2,3,4]\\n\\t\\n\\tSince a = 2 and b = 2\\n\\t\\n\\tWe start binary search from value 3 (index = 2)\\n\\t\\n\\tWe get mid = index 2 at which we have 3. \\n\\t\\n\\tNow we check if a + b > c or not.\\n\\t\\n\\tSince 2 + 2 > 3, that means, 3 is a valid value for a third side if first and second side is 2 and 2 respectively.\\n\\t\\n\\tBut we won\\'t stop here. Can we find a value bigger than 3 that also satisfies this condition? \\n\\t\\n\\tSo we continue. Next, mid = index 3 at which we have value = 4\\n\\t\\n\\tNow we check if a + b > c. \\n\\t\\n\\tSince 2 + 2 > 4 is not correct, that means, 4 cannot be a valid third side length if a = 2 and b = 2\\n\\t\\n\\tHence, for a = 2 and b = 2, we can have only one valid value as third side.\\n\\n\\nThis means, once we find the largest value for third side such that a + b > c, we can use any value that is between the index of b and the largest value we found via binary search (both included) to make a triangle. Hence, we increment our count by the number of values between \"b\" index and the index of the largest valid value we got via Binary Search.\\n\\n### **IN PYTHON, IT GIVES TLE**\\n\\n```\\ndef triangleNumber(self, nums: List[int]) -> int:\\n        count = 0\\n        \\n        # Sort the list in increasing order\\n        nums.sort()\\n        \\n        n = len(nums)\\n        \\n        for i in range(n - 2):\\n            for j in range(i + 1, n - 1):\\n                \\n                # Binary Search for the third side\\n                start = j + 1\\n                end = n - 1\\n                res = None\\n                \\n                while start <= end:\\n                    mid = start + (end - start) // 2\\n                \\n                    if nums[i] + nums[j] > nums[mid]:\\n                        res = mid\\n                        start = mid + 1\\n                    else: end = mid - 1\\n\\n                if res: count += res - j\\n                \\n        return count\\n```\\n\\t\\n### **IN JAVA, IT WORKS**\\t\\n\\n```\\npublic int triangleNumber(int[] nums) {\\n        int count = 0;\\n            \\n        Arrays.sort(nums);\\n        \\n        int n = nums.length;\\n        \\n        \\n        for (int i = 0; i < n - 2; i++){\\n            for (int j = i + 1; j < n - 1; j++){\\n                \\n                int start = j + 1;\\n                int end = n - 1;\\n                int res = -1;\\n                \\n                while (start <= end){\\n                    int mid = start + ((end - start) / 2);\\n                    \\n                    if(nums[i] + nums[j] > nums[mid]){\\n                        res = mid;\\n                        start = mid + 1;\\n                    } else {\\n                        end = mid - 1;\\n                    }\\n                        \\n                }\\n                \\n                if (res != -1) count += res - j;\\n            }\\n        }\\n        \\n        return count;\\n```\\n\\t\\n\\t\\n### **OPTIMIZATION TO MAKE THE BINARY SEACH SOLUTION FASTER**\\t\\n\\n\\nWe see that in the Binary Search code, for every new \"j\" value, we are again starting our binary search from \"j+1\" to the \"last index\", even if \"i\" is still the same. \\n\\nSo to make it better, we can pick off form where we left in previous \"j\" value. That is, reuse the previous \"k\" value in each iteration of the for loop for \"j\" value.\\n\\n```\\n\\ndef triangleNumber(self, nums: List[int]) -> int:\\n        count = 0\\n        \\n        # Sort the list in increasing order\\n        nums.sort()\\n        \\n        n = len(nums)\\n        \\n        for i in range(n - 2):\\n            k = i + 2\\n            if nums[i] != 0:\\n                for j in range(i + 1, n - 1):\\n\\n                    # Binary Search for the third side\\n                    start = k\\n                    end = n - 1\\n                    res = None\\n\\n                    while start <= end:\\n                        mid = start + (end - start) // 2\\n\\n                        if nums[i] + nums[j] > nums[mid]:\\n                            res = mid\\n                            start = mid + 1\\n                        else: end = mid - 1\\n\\n                    if res: \\n                        k = res\\n                        count += res - j\\n                \\n        return count\\n```\\n\\n\\n\\n## **3. TWO POINTERS (OR RATHER THREE) - O(N^2 )**\\n\\n```\\ndef triangleNumber(self, nums: List[int]) -> int:\\n        count = 0\\n        \\n        # Sort the list in increasing order\\n        nums.sort()\\n        \\n        n = len(nums)\\n        \\n        \\n        # Initially, \"c\" points to the largest value in the list i.e., last index\\n        # a points to the smallest value in the list i.e., first index\\n        # b points to the value just before \"c\" i.e., last index - 1\\n        i = n - 1\\n        while i >= 2:\\n            # a => first side\\n            # b => second side\\n            # c => third side (largest of two)\\n            a,b,c = 0, i - 1, i\\n            \\n            \\n            while a < b: \\n                side1,side2,side3 = nums[a], nums[b], nums[c]\\n                \\n                # If this is true for any \"a\" and \"b\"\\n                # Then this will be true for any value between \"a\" and \"b\" as well\\n                # Because list is sorted\\n                if side1 + side2 > side3:\\n                    # Hence, increment count by number of values between \"b\" and \"a\" indices (both included)\\n                    count += b - a\\n                    # Decrement \"b\" pointer\\n                    b -= 1\\n                else:\\n                    # Otherwise, increment \"a\" pointer\\n                    a += 1\\n            \\n            # After each iteration, decrement the \"c\" pointer\\n            i -= 1\\n                    \\n        return count\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\ndef triangleNumber(self, nums: List[int]) -> int:\\n        count = 0\\n        \\n        # Sort the list in increasing order\\n        nums.sort()\\n        \\n        n = len(nums)\\n        \\n        for i in range(n - 2):\\n            for j in range(i + 1, n - 1):\\n                \\n                # Binary Search for the third side\\n                start = j + 1\\n                end = n - 1\\n                res = None\\n                \\n                while start <= end:\\n                    mid = start + (end - start) // 2\\n                \\n                    if nums[i] + nums[j] > nums[mid]:\\n                        res = mid\\n                        start = mid + 1\\n                    else: end = mid - 1\\n\\n                if res: count += res - j\\n                \\n        return count\\n```\n```\\npublic int triangleNumber(int[] nums) {\\n        int count = 0;\\n            \\n        Arrays.sort(nums);\\n        \\n        int n = nums.length;\\n        \\n        \\n        for (int i = 0; i < n - 2; i++){\\n            for (int j = i + 1; j < n - 1; j++){\\n                \\n                int start = j + 1;\\n                int end = n - 1;\\n                int res = -1;\\n                \\n                while (start <= end){\\n                    int mid = start + ((end - start) / 2);\\n                    \\n                    if(nums[i] + nums[j] > nums[mid]){\\n                        res = mid;\\n                        start = mid + 1;\\n                    } else {\\n                        end = mid - 1;\\n                    }\\n                        \\n                }\\n                \\n                if (res != -1) count += res - j;\\n            }\\n        }\\n        \\n        return count;\\n```\n```\\n\\ndef triangleNumber(self, nums: List[int]) -> int:\\n        count = 0\\n        \\n        # Sort the list in increasing order\\n        nums.sort()\\n        \\n        n = len(nums)\\n        \\n        for i in range(n - 2):\\n            k = i + 2\\n            if nums[i] != 0:\\n                for j in range(i + 1, n - 1):\\n\\n                    # Binary Search for the third side\\n                    start = k\\n                    end = n - 1\\n                    res = None\\n\\n                    while start <= end:\\n                        mid = start + (end - start) // 2\\n\\n                        if nums[i] + nums[j] > nums[mid]:\\n                            res = mid\\n                            start = mid + 1\\n                        else: end = mid - 1\\n\\n                    if res: \\n                        k = res\\n                        count += res - j\\n                \\n        return count\\n```\n```\\ndef triangleNumber(self, nums: List[int]) -> int:\\n        count = 0\\n        \\n        # Sort the list in increasing order\\n        nums.sort()\\n        \\n        n = len(nums)\\n        \\n        \\n        # Initially, \"c\" points to the largest value in the list i.e., last index\\n        # a points to the smallest value in the list i.e., first index\\n        # b points to the value just before \"c\" i.e., last index - 1\\n        i = n - 1\\n        while i >= 2:\\n            # a => first side\\n            # b => second side\\n            # c => third side (largest of two)\\n            a,b,c = 0, i - 1, i\\n            \\n            \\n            while a < b: \\n                side1,side2,side3 = nums[a], nums[b], nums[c]\\n                \\n                # If this is true for any \"a\" and \"b\"\\n                # Then this will be true for any value between \"a\" and \"b\" as well\\n                # Because list is sorted\\n                if side1 + side2 > side3:\\n                    # Hence, increment count by number of values between \"b\" and \"a\" indices (both included)\\n                    count += b - a\\n                    # Decrement \"b\" pointer\\n                    b -= 1\\n                else:\\n                    # Otherwise, increment \"a\" pointer\\n                    a += 1\\n            \\n            # After each iteration, decrement the \"c\" pointer\\n            i -= 1\\n                    \\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1340938,
                "title": "c-basic-simple-solution-without-upper-lower-bound",
                "content": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        sort(nums.begin() , nums.end()) ;\\n        int ans = 0 ;\\n        int n = nums.size() ;\\n        for(int k = 2 ; k < n ; k++)\\n        {\\n            int i = 0 , j = k - 1 ;\\n            while(i < j)\\n            {\\n                if(nums[i] + nums[j] <= nums[k])\\n                {\\n                    i++ ;\\n                }\\n                else\\n                {\\n                    ans += (j - i) ;\\n                    j-- ;\\n                }\\n            }\\n        }\\n        return ans ;    \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        sort(nums.begin() , nums.end()) ;\\n        int ans = 0 ;\\n        int n = nums.size() ;\\n        for(int k = 2 ; k < n ; k++)\\n        {\\n            int i = 0 , j = k - 1 ;\\n            while(i < j)\\n            {\\n                if(nums[i] + nums[j] <= nums[k])\\n                {\\n                    i++ ;\\n                }\\n                else\\n                {\\n                    ans += (j - i) ;\\n                    j-- ;\\n                }\\n            }\\n        }\\n        return ans ;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1340416,
                "title": "c-binary-search-o-n-2logn",
                "content": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n        int count = 0, len = nums.size(), wanted;\\n        for (int i = 0; i < len - 2; i++) {\\n            for (int j = i + 1; j < len - 1; j++) {\\n                wanted = nums[i] + nums[j];\\n                int index = binarySearch(wanted, j + 1, len, nums);\\n                if (index != -1) {\\n                    count += index - 1 - j;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    // Return the left most number \"c\" such that a + b > c, return -1 otherwise\\n    int binarySearch(int target, int start, int &len, vector<int> &nums) {\\n        int l = start, r = len, mid;\\n        while (l < r) {\\n            mid = (l + r) / 2;\\n            if (nums[mid] < target) {\\n                l = mid + 1;\\n            }\\n            else {\\n                r = mid;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        sort(begin(nums), end(nums));\\n        int count = 0, len = nums.size(), wanted;\\n        for (int i = 0; i < len - 2; i++) {\\n            for (int j = i + 1; j < len - 1; j++) {\\n                wanted = nums[i] + nums[j];\\n                int index = binarySearch(wanted, j + 1, len, nums);\\n                if (index != -1) {\\n                    count += index - 1 - j;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    // Return the left most number \"c\" such that a + b > c, return -1 otherwise\\n    int binarySearch(int target, int start, int &len, vector<int> &nums) {\\n        int l = start, r = len, mid;\\n        while (l < r) {\\n            mid = (l + r) / 2;\\n            if (nums[mid] < target) {\\n                l = mid + 1;\\n            }\\n            else {\\n                r = mid;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 906559,
                "title": "python-two-solutions-with-explanations",
                "content": "Sol 1. Binary Search\\n**Prior**: If we know `a < b < c` , we know if `a + b > c` , then `a, b, c` can compose a valid triangle.\\n**Explanations**: If we know the first two numbers (`a, b`), then `c < a + b`. Since `nums` is sorted, we can find the left most upper bound and calculate the number of `c` that can compose valid triangle based on the other two sides is `a, b`.\\n```\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        res = 0\\n        for i, a in enumerate(nums):\\n            for j in range(i + 1, len(nums)):\\n                b = nums[j]\\n                # a + b > c\\n                k = bisect.bisect_left(nums, a + b)\\n                res += max(k - j - 1, 0)\\n        return res\\n```\\n**Complexity Analysis**: Time is O(N ^2 * logN), N is the length of `nums`. Space is O(logN), since sorting.\\n\\nSol 2. Two pointers\\n**Explanations**: Sol 1 takes `a, b` as fixed term to find `c`, but we can fix `c` to find `a, b`.\\nSince `nums` is sorted, we travrse backwards. If we find `nums[left] + nums[right] > nums[i]`, we know at index `left, right, i` have a triangle. Moreover, we know all indexs before `left` can combine with `right, i` to build a triangle. Hence, the number of valid triangles is `(right - left)`. If `nums[left] + nums[right] <= nums[i]`, we need to find bigger sum.\\n```\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        res = 0\\n        for i in range(len(nums) - 1, 1, -1):\\n            left, right = 0, i - 1\\n            while left < right:\\n                if nums[left] + nums[right] > nums[i]:\\n                    res += (right - left)\\n                    right -= 1\\n                else:\\n                    left += 1\\n        return res\\n```\\n**Complexity Analysis**: Time is O(N ^2), N is the length of `nums`. Space is O(logN), since sorting.",
                "solutionTags": [
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        res = 0\\n        for i, a in enumerate(nums):\\n            for j in range(i + 1, len(nums)):\\n                b = nums[j]\\n                # a + b > c\\n                k = bisect.bisect_left(nums, a + b)\\n                res += max(k - j - 1, 0)\\n        return res\\n```\n```\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        res = 0\\n        for i in range(len(nums) - 1, 1, -1):\\n            left, right = 0, i - 1\\n            while left < right:\\n                if nums[left] + nums[right] > nums[i]:\\n                    res += (right - left)\\n                    right -= 1\\n                else:\\n                    left += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 104183,
                "title": "c-clean-code",
                "content": "**Binary Search O(N<sup>2</sup>lgN)**\\n```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& a) {\\n        int n = a.size();\\n        sort(a.begin(), a.end());\\n        int res = 0;\\n        for (int i = 0; i < n - 2; i++) {\\n            for (int j = i + 1; j < n - 1; j++) {\\n                int sum = a[i] + a[j];   // the sum of 2 shortest sides;\\n                int firstGE = firstGreatOrEqual(a, j + 1, sum);\\n                res += firstGE - 1 - j;\\n            }\\n        }\\n        return res;\\n    }\\n\\nprivate:\\n    int firstGreatOrEqual(vector<int>& a, int i0, int target) {\\n        int lo = i0, hi = a.size();\\n        while (lo < hi) {\\n            int mid = (lo + hi) / 2;\\n            if (a[mid] < target) {\\n                lo = mid + 1;\\n            }\\n            else {\\n                hi = mid;\\n            }\\n        }\\n        return hi;\\n    }\\n};\\n```\\n**2 Pointers O(N<sup>2</sup>)**\\n```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& a) {\\n        int res = 0;\\n        sort(a.begin(), a.end());\\n        reverse(a.begin(), a.end());    // a is decreasing\\n        for (int i = 0; i + 2 < a.size(); i++) {\\n            for (int j = i + 1, k = a.size() - 1; j < k; j++) {\\n                while (j < k && a[j] + a[k] <= a[i]) {\\n                    k--;\\n                }\\n                res += k - j;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& a) {\\n        int n = a.size();\\n        sort(a.begin(), a.end());\\n        int res = 0;\\n        for (int i = 0; i < n - 2; i++) {\\n            for (int j = i + 1; j < n - 1; j++) {\\n                int sum = a[i] + a[j];   // the sum of 2 shortest sides;\\n                int firstGE = firstGreatOrEqual(a, j + 1, sum);\\n                res += firstGE - 1 - j;\\n            }\\n        }\\n        return res;\\n    }\\n\\nprivate:\\n    int firstGreatOrEqual(vector<int>& a, int i0, int target) {\\n        int lo = i0, hi = a.size();\\n        while (lo < hi) {\\n            int mid = (lo + hi) / 2;\\n            if (a[mid] < target) {\\n                lo = mid + 1;\\n            }\\n            else {\\n                hi = mid;\\n            }\\n        }\\n        return hi;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& a) {\\n        int res = 0;\\n        sort(a.begin(), a.end());\\n        reverse(a.begin(), a.end());    // a is decreasing\\n        for (int i = 0; i + 2 < a.size(); i++) {\\n            for (int j = i + 1, k = a.size() - 1; j < k; j++) {\\n                while (j < k && a[j] + a[k] <= a[i]) {\\n                    k--;\\n                }\\n                res += k - j;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1341026,
                "title": "java-using-two-pointer-easy-and-clean-code",
                "content": "```\\nclass Solution {\\n    public int triangleNumber(int[] a) {\\n        Arrays.sort(a);\\n        int n=a.length;\\n        int count=0;\\n        for(int i=n-1;i>=1;i--){\\n            int left=0,right=i-1;\\n            while(left<right){\\n                if(a[left]+a[right]>a[i]){\\n                    count+=right-left;\\n                    right--;\\n                }\\n                else\\n                left++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int triangleNumber(int[] a) {\\n        Arrays.sort(a);\\n        int n=a.length;\\n        int count=0;\\n        for(int i=n-1;i>=1;i--){\\n            int left=0,right=i-1;\\n            while(left<right){\\n                if(a[left]+a[right]>a[i]){\\n                    count+=right-left;\\n                    right--;\\n                }\\n                else\\n                left++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1340261,
                "title": "python3-clean-using-bisect-left-binary-search",
                "content": "This is the binary search solution using python module [bisect_left()](https://docs.python.org/3/library/bisect.html)\\n```\\nimport bisect as bs\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        a= sorted(nums)\\n        count = 0\\n        for i in range(n):\\n            for j in range(i+1, n-1):\\n                k = bs.bisect_left(a, a[i] + a[j], lo = j+1)\\n                count += k - j - 1\\n        return count\\n```\\n\\n**Time complexity:** O(N^2 logN)\\n**Space complexity:** O(1)\\n\\nPlease upvote and share if this helps.!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nimport bisect as bs\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        a= sorted(nums)\\n        count = 0\\n        for i in range(n):\\n            for j in range(i+1, n-1):\\n                k = bs.bisect_left(a, a[i] + a[j], lo = j+1)\\n                count += k - j - 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339083,
                "title": "c-easy-clean-solution-in-o-n-2",
                "content": "**Solution:**\\n```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ans = 0;\\n        for(int i = 2; i < nums.size(); i++){\\n            int l = 0, r = i - 1;\\n            while(l < r){\\n                if(nums[l] + nums[r] > nums[i]){\\n                    ans += r - l;\\n                    r--;\\n                }\\n                else\\n                    l++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Time Complexity:** `O(n^2)`\\n\\n**Feel free to share your ideas or any improvements as well.**",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ans = 0;\\n        for(int i = 2; i < nums.size(); i++){\\n            int l = 0, r = i - 1;\\n            while(l < r){\\n                if(nums[l] + nums[r] > nums[i]){\\n                    ans += r - l;\\n                    r--;\\n                }\\n                else\\n                    l++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 398569,
                "title": "c-o-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int res = 0;\\n        for (int i = nums.size() - 1; i > 1; i--) {\\n            int l = 0;\\n            int r = i - 1;\\n            while (l < r) {\\n                if (nums[l] + nums[r] > nums[i]) {\\n                    res += r - l;\\n                    r--;\\n                } else {\\n                    l++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int res = 0;\\n        for (int i = nums.size() - 1; i > 1; i--) {\\n            int l = 0;\\n            int r = i - 1;\\n            while (l < r) {\\n                if (nums[l] + nums[r] > nums[i]) {\\n                    res += r - l;\\n                    r--;\\n                } else {\\n                    l++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2888023,
                "title": "c-two-pointer-easy-understanding-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTWO POINTER APPROACH ON DESCENDING ORDER ARRAY\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe all know that two pointer approach works easily on sorted array, but here is a trick we have to sort in descending order,\\nsince if sum of two sides is greater than the larger side ,then our triangle is valid and this is a sufficient condition .No need to check any two sides....\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.end());\\n        \\n        int n=nums.size();\\n        int cnt=0;\\n        \\n        for(int i=0;i<n;i++){\\n            int j=i+1,k=n-1;\\n         \\n            while(j<k){\\n                int a=nums[i],b=nums[j],c=nums[k];\\n                if(b+c > a){\\n                    cnt+=k-j;\\n                    j++;\\n                }\\n                else{\\n                    k--;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        reverse(nums.begin(),nums.end());\\n        \\n        int n=nums.size();\\n        int cnt=0;\\n        \\n        for(int i=0;i<n;i++){\\n            int j=i+1,k=n-1;\\n         \\n            while(j<k){\\n                int a=nums[i],b=nums[j],c=nums[k];\\n                if(b+c > a){\\n                    cnt+=k-j;\\n                    j++;\\n                }\\n                else{\\n                    k--;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2771320,
                "title": "c-similar-to-3sum-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        int count = 0;\\n        for(int k = nums.size() - 1; k > 1; k--)\\n        {\\n            int j = k - 1;\\n            int i = 0;\\n            while(i < j)\\n            {\\n                if(nums[i] + nums[j] > nums[k]){\\n                    count += j - i;\\n                    j--;\\n                }\\n                else\\n                    i++;\\n            } \\n        }\\n        return count;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        int count = 0;\\n        for(int k = nums.size() - 1; k > 1; k--)\\n        {\\n            int j = k - 1;\\n            int i = 0;\\n            while(i < j)\\n            {\\n                if(nums[i] + nums[j] > nums[k]){\\n                    count += j - i;\\n                    j--;\\n                }\\n                else\\n                    i++;\\n            } \\n        }\\n        return count;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1341919,
                "title": "valid-triangle-number-java-solution-explanatory-comments",
                "content": "```\\nclass Solution {\\n    public int triangleNumber(int[] nums) {\\n        int result = 0;                                     // A var to keep the count of valid triangles\\n        \\n        if(nums.length < 3)                                 // First check if there are atleast 3 numbers in the array or not\\n            return result;                                  // If Not, then return 0 as no triangle can be formed with less than 3 elements\\n        \\n        Arrays.sort(nums);                                  // Else, Sort the array\\n        \\n        for(int i = 2; i < nums.length; i++){               // Start traversing from the 2nd index of the array\\n            int left = 0;                                   // Assign a left pointer pointing at the 1st index\\n            int right = i-1;                                // Assign a right pointer pointing at \\'i\\'-1\\n            \\n            while(left < right){                            // Run a loop till \\'left\\' is less than \\'right\\'\\n                if(nums[i] < (nums[left]+nums[right])){     // If the summed value of the index at \\'left\\' & \\'right\\' are greater than the value at index \\'i\\'\\n                    result += (right-left);                 // Then there are total \\'right\\'-\\'left\\' vaild triangles\\n                    right--;                                // And, decrease the value of \\'right\\'\\n                }\\n                else\\n                    left++;                                 // Else, increase the value of \\'left\\'\\n            }\\n        }\\n        return result;                                      // Finally, return the value of \\'result\\'\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int triangleNumber(int[] nums) {\\n        int result = 0;                                     // A var to keep the count of valid triangles\\n        \\n        if(nums.length < 3)                                 // First check if there are atleast 3 numbers in the array or not\\n            return result;                                  // If Not, then return 0 as no triangle can be formed with less than 3 elements\\n        \\n        Arrays.sort(nums);                                  // Else, Sort the array\\n        \\n        for(int i = 2; i < nums.length; i++){               // Start traversing from the 2nd index of the array\\n            int left = 0;                                   // Assign a left pointer pointing at the 1st index\\n            int right = i-1;                                // Assign a right pointer pointing at \\'i\\'-1\\n            \\n            while(left < right){                            // Run a loop till \\'left\\' is less than \\'right\\'\\n                if(nums[i] < (nums[left]+nums[right])){     // If the summed value of the index at \\'left\\' & \\'right\\' are greater than the value at index \\'i\\'\\n                    result += (right-left);                 // Then there are total \\'right\\'-\\'left\\' vaild triangles\\n                    right--;                                // And, decrease the value of \\'right\\'\\n                }\\n                else\\n                    left++;                                 // Else, increase the value of \\'left\\'\\n            }\\n        }\\n        return result;                                      // Finally, return the value of \\'result\\'\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1341220,
                "title": "small-and-simple-c-solution-8-lines-with-detailed-explanation",
                "content": "Let us assume there are 3 sides of a triangle named a ,b ,c \\nand we are going to choose a,b,c in such an order, so that **a<b<c**\\nNow we know condition to make a traingle is \\n(1).  **a+b>c**     \\n(2).  **b+c>a**     \\n(3).  **c+a>b**     \\nSince a<b<c , the inequalities (2) and (3) are always satisfied irrespective of their values (as long as a<b<c is satisfied). So we need not check them and **All we need to check is inequality (1)**\\nWe first sort the vector/array using STL for our simplicity \\nSo we traverse the given vector/array backwards (from larger to smaller value)\\nThe first for loop is for side c and the second for loop is for side b (placed before side  c in the sorted array)\\nNow we need some side a such that  a+b>c or  **a>c-b**  \\nAnd we use upper_bound function to find the occurence of first such valid side a \\nAnd we simply add all such side a elements to our answer(Note that in this case even duplicate values get handled very well)\\n\\n##### *C++ Code*\\n```\\n\\t//nums has been named v here\\n\\t  sort(v.begin(),v.end());\\n        int ans=0;\\n        for(int i=v.size()-1; i>=2; i--)  {\\n\\t\\t\\tfor(int j=i-1; j>=1; j--) {\\n\\t\\t\\t\\tauto itr=upper_bound(v.begin(), v.end(), v[i]-v[j]);  \\n\\t\\t\\t\\tint ind=itr-v.begin(); \\n\\t\\t\\t\\tif(ind<=j)    //To make sure  the side a we get is before the side b in the sorted array \\n\\t\\t\\t\\t{ ans+=(j-ind); }\\n\\t\\t}   \\n        }   \\n        return ans;\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\n\\t//nums has been named v here\\n\\t  sort(v.begin(),v.end());\\n        int ans=0;\\n        for(int i=v.size()-1; i>=2; i--)  {\\n\\t\\t\\tfor(int j=i-1; j>=1; j--) {\\n\\t\\t\\t\\tauto itr=upper_bound(v.begin(), v.end(), v[i]-v[j]);  \\n\\t\\t\\t\\tint ind=itr-v.begin(); \\n\\t\\t\\t\\tif(ind<=j)    //To make sure  the side a we get is before the side b in the sorted array \\n\\t\\t\\t\\t{ ans+=(j-ind); }\\n\\t\\t}   \\n        }   \\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1339692,
                "title": "611-sort-solution-sort-with-binary-search-solution",
                "content": "---\\n**Algo**\\n\\n- **Core rule** for making a triangle from sides `s1`, `s2` and `s3` is one of the following\\n  - s1 + s2 > s3\\n  - s2 + s3 > s1\\n  - s3 + s1 > s2\\n    - That means, `sum of 2 sides is greater than 3rd side`\\n- **Sort solution 1**\\n  - By sorting we can go ahead to right side only like\\n    - i goes from 0 to n-1\\n      - j goes from i+1 to n-1\\n        - k goes from j+1 to n-1\\n          - Now select A[i] + A[j] > A[k]    like a+b>c\\n    - This reduces a lot of computation because all smaller elements are on left & bigger on right\\n- **Sort solution 2 - with break**\\n  - This only adds one condition to **break** early that\\n    - Once a+b>c is condition fails, then it will fail for all c on the right, because of increasing c\\n- **Sort solution 3 - with Binary search**\\n  - Since we sorted we should be able do a binary search\\n\\n---\\n\\n**Sort solution 1**\\n\\n```\\nvar triangleNumber = function (A) {\\n    let n = A.length;\\n\\n    A.sort((a, b) => a - b);\\n\\n    let count = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = i + 1; j < n; j++) {\\n            for (let k = j + 1; k < n; k++) {\\n                let s1 = A[i];\\n                let s2 = A[j];\\n                let s3 = A[k];\\n                if (s1 + s2 > s3) count++;\\n            }\\n        }\\n    }\\n\\n    return count;\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/02912da6-c7ac-4951-ac9e-16a8fa5dcb15_1626346508.0630078.png)\\n\\n---\\n\\n**Sort solution 2 - with break**\\n\\n```\\nvar triangleNumber = function (A) {\\n    let n = A.length;\\n\\n    A.sort((a, b) => a - b);\\n\\n    let count = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = i + 1; j < n; j++) {\\n            let sum = A[i] + A[j];\\n            for (let k = j + 1; k < n; k++) {\\n                if (sum > A[k]) count++;\\n                else break;\\n            }\\n        }\\n    }\\n\\n    return count;\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/b38c735f-00ff-41a9-abb3-1fd6a04772d3_1626346531.6189334.png)\\n\\n---\\n\\n**Sort solution 3 - with Binary search**\\n\\n```\\nvar triangleNumber = function (A) {\\n    let n = A.length;\\n\\n    A.sort((a, b) => a - b);\\n\\n    let count = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = i + 1; j < n; j++) {\\n            let lessThanTarget = A[i] + A[j];\\n            // need x(A[mid]) = A[j+1] ..x.. A[n-1],  x<lessThanTarget,  last lessThanTarget\\n\\n            let [lo, hi, mid] = [j + 1, n - 1, undefined];\\n            while (lo < hi) {\\n                mid = lo + Math.trunc((hi - lo) / 2);\\n                if (A[mid] == lessThanTarget) {\\n                    lo = mid;\\n                    break;\\n                } else if (A[mid] < lessThanTarget) lo = mid + 1;\\n                else hi = mid - 1;\\n            }\\n            if (j + 1 <= lo && lo <= n - 1) {\\n                while (A[lo] >= lessThanTarget) lo--;\\n                if (lo >= j + 1) {\\n                    count += lo - (j + 1) + 1;\\n                }\\n            }\\n        }\\n    }\\n    return count;\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/b33e4bcd-86e6-40d4-9cc9-ecaa2eed16b8_1626346551.2125816.png)\\n\\n---\\n",
                "solutionTags": [],
                "code": "```\\nvar triangleNumber = function (A) {\\n    let n = A.length;\\n\\n    A.sort((a, b) => a - b);\\n\\n    let count = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = i + 1; j < n; j++) {\\n            for (let k = j + 1; k < n; k++) {\\n                let s1 = A[i];\\n                let s2 = A[j];\\n                let s3 = A[k];\\n                if (s1 + s2 > s3) count++;\\n            }\\n        }\\n    }\\n\\n    return count;\\n};\\n```\n```\\nvar triangleNumber = function (A) {\\n    let n = A.length;\\n\\n    A.sort((a, b) => a - b);\\n\\n    let count = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = i + 1; j < n; j++) {\\n            let sum = A[i] + A[j];\\n            for (let k = j + 1; k < n; k++) {\\n                if (sum > A[k]) count++;\\n                else break;\\n            }\\n        }\\n    }\\n\\n    return count;\\n};\\n```\n```\\nvar triangleNumber = function (A) {\\n    let n = A.length;\\n\\n    A.sort((a, b) => a - b);\\n\\n    let count = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = i + 1; j < n; j++) {\\n            let lessThanTarget = A[i] + A[j];\\n            // need x(A[mid]) = A[j+1] ..x.. A[n-1],  x<lessThanTarget,  last lessThanTarget\\n\\n            let [lo, hi, mid] = [j + 1, n - 1, undefined];\\n            while (lo < hi) {\\n                mid = lo + Math.trunc((hi - lo) / 2);\\n                if (A[mid] == lessThanTarget) {\\n                    lo = mid;\\n                    break;\\n                } else if (A[mid] < lessThanTarget) lo = mid + 1;\\n                else hi = mid - 1;\\n            }\\n            if (j + 1 <= lo && lo <= n - 1) {\\n                while (A[lo] >= lessThanTarget) lo--;\\n                if (lo >= j + 1) {\\n                    count += lo - (j + 1) + 1;\\n                }\\n            }\\n        }\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 857062,
                "title": "swift-2-pointers",
                "content": "```\\nclass Solution {\\n    func triangleNumber(_ nums: [Int]) -> Int {\\n        let sorted = nums.sorted()\\n        let count = sorted.count\\n        var result = 0\\n        \\n        for c in stride(from: count - 1, through: 2, by: -1) {\\n            var a = 0, b = c - 1\\n            while a < b {\\n                if sorted[a] + sorted[b] > sorted[c] {\\n                    result += b - a\\n                    b -= 1\\n                } else {\\n                    a += 1\\n                }\\n            }\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func triangleNumber(_ nums: [Int]) -> Int {\\n        let sorted = nums.sorted()\\n        let count = sorted.count\\n        var result = 0\\n        \\n        for c in stride(from: count - 1, through: 2, by: -1) {\\n            var a = 0, b = c - 1\\n            while a < b {\\n                if sorted[a] + sorted[b] > sorted[c] {\\n                    result += b - a\\n                    b -= 1\\n                } else {\\n                    a += 1\\n                }\\n            }\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 846239,
                "title": "java-binary-search-solution-2",
                "content": "The implementation of approach 2 in official solution.\\n\\n```\\nclass Solution {\\n    public int triangleNumber(int[] nums) {\\n        \\n    Arrays.sort(nums);\\n    int res = 0;\\n        \\n    for (int i = 0; i < nums.length - 2; i++) {\\n      for (int j = i + 1; j < nums.length - 1; j++) {\\n        int sum = nums[i] + nums[j];\\n        int left = j + 1, right = nums.length - 1;\\n          \\n        // find the largest element smaller than sum;\\n        while (left < right - 1) {\\n          int mid = left + (right - left) / 2;\\n          if (nums[mid] >= sum) right = mid - 1;\\n          else left = mid;\\n        }\\n          \\n        // post-processing: determine left or right is the largest element smaller than sum\\n        // or both left & right are not.\\n        if (nums[right] < sum) {\\n          res += (right - j);\\n        } else if (nums[left] < sum) {\\n          res += (left - j);\\n        }\\n      }\\n    }\\n    return res;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int triangleNumber(int[] nums) {\\n        \\n    Arrays.sort(nums);\\n    int res = 0;\\n        \\n    for (int i = 0; i < nums.length - 2; i++) {\\n      for (int j = i + 1; j < nums.length - 1; j++) {\\n        int sum = nums[i] + nums[j];\\n        int left = j + 1, right = nums.length - 1;\\n          \\n        // find the largest element smaller than sum;\\n        while (left < right - 1) {\\n          int mid = left + (right - left) / 2;\\n          if (nums[mid] >= sum) right = mid - 1;\\n          else left = mid;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3308463,
                "title": "611-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Sort the input array \"nums\" in ascending order.\\n2. Initialize a variable \"count\" to 0, which will keep track of the number of valid triangles.\\n3. Loop through all possible triplets in the array, using two pointers \"i\" and \"j\".\\n4. For each triplet, initialize a third pointer \"k\" to \"i + 2\".\\n5. If the first element of the triplet is 0, skip to the next element by using the \"continue\" statement.\\n6. If all remaining elements in the array are zero, break out of the loop by using the \"break\" statement.\\n7. Loop through all possible second elements of the triplet, starting at \"j = i + 1\" and ending at \"len(nums) - 1\".\\n8. Move the third pointer \"k\" to the first element that is greater than or equal to the sum of the first two elements.\\n9. Calculate the number of valid triangles that can be formed with the current pair of first two elements as \"k - j - 1\", and add it to the \"count\" variable.\\n10. Return the final value of \"count\", which represents the total number of valid triangles that can be formed from the input array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        nums.sort() # Sort the input array\\n        count = 0 # Initialize count of valid triangles\\n        \\n        # Loop through all possible triplets using two pointers\\n        for i in range(len(nums) - 2):\\n            k = i + 2 # Initialize third pointer to i + 2\\n            \\n            # If the first element of the triplet is 0, move to the next element\\n            if nums[i] == 0:\\n                continue\\n                \\n            # If all remaining elements in the array are zero, break out of the loop\\n            if nums[i+1] == 0 and nums[-1] == 0:\\n                break\\n            \\n            # Loop through all possible second elements of the triplet\\n            for j in range(i + 1, len(nums) - 1):\\n                \\n                # Move the third pointer to the first element that is greater than or equal to the sum of the first two elements\\n                while k < len(nums) and nums[i] + nums[j] > nums[k]:\\n                    k += 1\\n                \\n                # The number of valid triangles that can be formed with the current pair of first two elements is the difference between the third pointer and the second pointer minus 1\\n                count += k - j - 1\\n        \\n        return count\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        nums.sort() # Sort the input array\\n        count = 0 # Initialize count of valid triangles\\n        \\n        # Loop through all possible triplets using two pointers\\n        for i in range(len(nums) - 2):\\n            k = i + 2 # Initialize third pointer to i + 2\\n            \\n            # If the first element of the triplet is 0, move to the next element\\n            if nums[i] == 0:\\n                continue\\n                \\n            # If all remaining elements in the array are zero, break out of the loop\\n            if nums[i+1] == 0 and nums[-1] == 0:\\n                break\\n            \\n            # Loop through all possible second elements of the triplet\\n            for j in range(i + 1, len(nums) - 1):\\n                \\n                # Move the third pointer to the first element that is greater than or equal to the sum of the first two elements\\n                while k < len(nums) and nums[i] + nums[j] > nums[k]:\\n                    k += 1\\n                \\n                # The number of valid triangles that can be formed with the current pair of first two elements is the difference between the third pointer and the second pointer minus 1\\n                count += k - j - 1\\n        \\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206278,
                "title": "simple-c-solution-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        int ans=0;\\n        int n = nums.size();\\n//sorting the given array\\n        sort(nums.begin(),nums.end());\\n//iterating from end to 2nd element\\n        for(int i=n-1;i>=2;i--){\\n            int low=0;\\n            int high=i-1;\\n//setting high as previous of greater element\\n            while(low<high){\\n\\n                if(nums[low]+nums[high]>nums[i]){\\n//if element at low and high index is greater than largest element\\n                    ans += (high-low);\\n//then setting ans as high-low i.e, all elemnt between this range is \\n//counted\\n                    high--;\\n                }\\n                else{\\n                    low++;\\n                }\\n            }\\n        }\\n        return ans;\\n//at last we return the answer\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        int ans=0;\\n        int n = nums.size();\\n//sorting the given array\\n        sort(nums.begin(),nums.end());\\n//iterating from end to 2nd element\\n        for(int i=n-1;i>=2;i--){\\n            int low=0;\\n            int high=i-1;\\n//setting high as previous of greater element\\n            while(low<high){\\n\\n                if(nums[low]+nums[high]>nums[i]){\\n//if element at low and high index is greater than largest element\\n                    ans += (high-low);\\n//then setting ans as high-low i.e, all elemnt between this range is \\n//counted\\n                    high--;\\n                }\\n                else{\\n                    low++;\\n                }\\n            }\\n        }\\n        return ans;\\n//at last we return the answer\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180734,
                "title": "c-code-binary-search",
                "content": "# Complexity\\n- Time complexity: **O(n*n(logn))**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int t=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n              int h = abs(nums[i]-nums[j]) + 1;\\n              h = lower_bound(nums.begin(),nums.end(),h) - nums.begin();\\n              int g = nums[i] + nums[j];\\n              g = lower_bound(nums.begin(),nums.end(),g) - nums.begin();\\n              g--;\\n              if(g>j)\\n              t+=g-(j+1)+1;\\n            }\\n        }\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int t=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n              int h = abs(nums[i]-nums[j]) + 1;\\n              h = lower_bound(nums.begin(),nums.end(),h) - nums.begin();\\n              int g = nums[i] + nums[j];\\n              g = lower_bound(nums.begin(),nums.end(),g) - nums.begin();\\n              g--;\\n              if(g>j)\\n              t+=g-(j+1)+1;\\n            }\\n        }\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2920436,
                "title": "c-binary-search-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:O(N*N*logN)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ans=0;\\n        for(int i=0; i<nums.size(); i++){\\n            for(int j=i+1; j<nums.size(); j++){\\n                int num=nums[i]+nums[j];\\n                int st=j+1, en=nums.size()-1;\\n                while(st<=en){\\n                    int mid=st+(en-st)/2;\\n                    if(nums[mid]<num){\\n                        st=mid+1;\\n                    }\\n                    else{en=mid-1;}\\n                }\\n                //cout<<st<<endl;\\n                ans+=en-j;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ans=0;\\n        for(int i=0; i<nums.size(); i++){\\n            for(int j=i+1; j<nums.size(); j++){\\n                int num=nums[i]+nums[j];\\n                int st=j+1, en=nums.size()-1;\\n                while(st<=en){\\n                    int mid=st+(en-st)/2;\\n                    if(nums[mid]<num){\\n                        st=mid+1;\\n                    }\\n                    else{en=mid-1;}\\n                }\\n                //cout<<st<<endl;\\n                ans+=en-j;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2820762,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int triangleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int size = nums.length;\\n        int result = 0;\\n        for(int i=size-1;i>=0;i--){\\n            int start = 0;\\n            int end = i-1;\\n            while(start<end){\\n                if(nums[start]+nums[end] > nums[i]){\\n                    result+= end-start;\\n                    end--;\\n                }\\n                else{\\n                    start++;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int triangleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int size = nums.length;\\n        int result = 0;\\n        for(int i=size-1;i>=0;i--){\\n            int start = 0;\\n            int end = i-1;\\n            while(start<end){\\n                if(nums[start]+nums[end] > nums[i]){\\n                    result+= end-start;\\n                    end--;\\n                }\\n                else{\\n                    start++;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2709531,
                "title": "python3-binary-search",
                "content": "```\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        ans=0\\n        nums.sort()\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                s2s=nums[i]+nums[j]\\n                ind=bisect.bisect_left(nums,s2s)\\n                ans+=max(0,ind-j-1)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        ans=0\\n        nums.sort()\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                s2s=nums[i]+nums[j]\\n                ind=bisect.bisect_left(nums,s2s)\\n                ans+=max(0,ind-j-1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2572468,
                "title": "faster-3-pointer-solution-dry-run-and-explanation",
                "content": "Please find the below explained and details dry run solution for the problem - (dry run at the below after the code)\\n\\n**Theorem of triangle:**\\n\\nLets first understand the given condition - the property of triangle says that \\'sum of the lengths of two sides of the triangle shall be greater than thrid side\\' i.e `(a + b > c) && (b + c > a) && (c + a > b)` if this condition is correct we can say that the given triplet can form the triangle and its valid ans.\\n\\n**Explanation:**\\n\\nNow how can we determine the same - \\n\\nlets assume - \\n\\n```\\nlength  a   and   b are smaller\\nwhile\\nlength  c is greater\\n\\nnums[a] + nums[b] > nums[c]\\n```\\n```\\n\\n```\\nSteps:\\n\\n1 Sort the array in increasing order \\n2 now the starting element will be the smallest element while nth element will be the largest\\n3 We initiate our 3 pointers with\\n```\\na with starting element \\n\\nb with the n-1 th element\\n\\nc with nth element\\n```\\nNow the imp condition we check here is\\n```\\nif(nums[a] + nums[b] > nums[c])\\n                {\\n                    count = count + (b - a);\\n                    \\n                    b--;\\n                }\\n                else\\n                {\\n                    a++;\\n                }\\n```\\nIntution behind this check-\\n* if condtion: if the `nums[a] + nums[b] > nums[c]` satisfies we will increament the counter with `count + (b - a)` what this indicate? - so this count condition tells you that the triangle condition is fullfiled by the elements before b it is valid triangle.\\n* and else check we will increament the sum and for that we will need higher a value.\\n\\n\\n\\n**Code:**\\n\\n```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n      \\n        // 3 pointer approach\\n        \\n        sort(nums.begin() , nums.end());\\n        \\n        int count = 0;\\n        \\n        //consider -> a and b are sides while c is the largest length of the triangle\\n        \\n        for(int c = nums.size() - 1 ; c >= 0 ; c-- ) // as array is sorted the maximum length will be the last element\\n        {\\n            int a = 0 , b = c - 1;  \\n            \\n            // starting a from start\\n            // starting b from the element before c\\n            \\n            while(a < b)\\n            {\\n                if(nums[a] + nums[b] > nums[c])\\n                {\\n                    count = count + (b - a);\\n                    \\n                    b--;\\n                }\\n                else\\n                {\\n                    a++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n**Dry run:**\\n![image](https://assets.leetcode.com/users/images/0efc1881-b07c-4f1d-9bb1-c9d38c132a9d_1663095880.3957877.jpeg)\\n\\n-----------------------------------------------------------------------\\n\\n**If you like the solution and found it useful please do upvote and share!**\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Two Pointers",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nlength  a   and   b are smaller\\nwhile\\nlength  c is greater\\n\\nnums[a] + nums[b] > nums[c]\\n```\n```\\n\\n```\n```\\na with starting element \\n\\nb with the n-1 th element\\n\\nc with nth element\\n```\n```\\nif(nums[a] + nums[b] > nums[c])\\n                {\\n                    count = count + (b - a);\\n                    \\n                    b--;\\n                }\\n                else\\n                {\\n                    a++;\\n                }\\n```\n```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n      \\n        // 3 pointer approach\\n        \\n        sort(nums.begin() , nums.end());\\n        \\n        int count = 0;\\n        \\n        //consider -> a and b are sides while c is the largest length of the triangle\\n        \\n        for(int c = nums.size() - 1 ; c >= 0 ; c-- ) // as array is sorted the maximum length will be the last element\\n        {\\n            int a = 0 , b = c - 1;  \\n            \\n            // starting a from start\\n            // starting b from the element before c\\n            \\n            while(a < b)\\n            {\\n                if(nums[a] + nums[b] > nums[c])\\n                {\\n                    count = count + (b - a);\\n                    \\n                    b--;\\n                }\\n                else\\n                {\\n                    a++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1901940,
                "title": "using-binary-search",
                "content": "````\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        int ans = 0;\\n        sort(nums.begin(), nums.end());\\n        for(int i = 0; i < nums.size(); i++) {\\n            for(int j = i+1; j < nums.size(); j++) {\\n                int sum = nums[i] + nums[j];\\n                int idx = lower_bound(nums.begin() + j+1, nums.end(), sum) - nums.begin();\\n                ans += idx - j - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        int ans = 0;\\n        sort(nums.begin(), nums.end());\\n        for(int i = 0; i < nums.size(); i++) {\\n            for(int j = i+1; j < nums.size(); j++) {\\n                int sum = nums[i] + nums[j];\\n                int idx = lower_bound(nums.begin() + j+1, nums.end(), sum) - nums.begin();\\n                ans += idx - j - 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1885950,
                "title": "c-8-line-simple-code-easy-to-understand-tc-o-n-2-sc-o-1",
                "content": "#### *Please Upvote if it helps\\u2B06\\uFE0F*\\n```\\n\\tint triangleNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size(),triplets=0;\\n        for(int i=n-1;i>=0;--i){\\n            int l=0, r=i-1;\\n            while(l<r){\\n                if(nums[l]+nums[r]>nums[i]) triplets+=r-l,r--;\\n                else l++;\\n            }\\n        }\\n        return triplets;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n\\tint triangleNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size(),triplets=0;\\n        for(int i=n-1;i>=0;--i){\\n            int l=0, r=i-1;\\n            while(l<r){\\n                if(nums[l]+nums[r]>nums[i]) triplets+=r-l,r--;\\n                else l++;\\n            }\\n        }\\n        return triplets;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1573503,
                "title": "c-better-optimal-clean-code",
                "content": "## 1.  Binary Search Solution \\n\\n###### Time Complexity : :  O ( n*n log n )\\n###### Space Complexity : : O ( 1 ) \\n\\n```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        int i,j;\\n        int n=nums.size();\\n        int c=0;\\n     for(i=0;i<n;i++)\\n     {\\n         for(j=i+1;j<n;j++)\\n         {\\n             auto it=lower_bound(nums.begin()+j+1,nums.end(),nums[i]+nums[j])-nums.begin()-1;\\n             \\n             c+=(it-j);\\n         }\\n        }\\n        return  c;\\n    }\\n};\\n```\\n\\n## 2.  Two Pointer Approach \\n\\n###### Time Complexity : :  O ( n*n )\\n###### Space Complexity : : O ( 1 ) \\n \\n ``` \\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        int i;\\n        int n=nums.size();\\n        int c=0;\\n        for(i=n-1;i>=2;i--)\\n        {\\n            int left=0;\\n            int right=i-1;\\n            \\n            while(left<right)\\n            {\\n                if(nums[left]+nums[right]>nums[i])\\n                {\\n                    c+=(right-left);\\n                    right--;\\n                }\\n                else left++;\\n                \\n            }\\n        }\\n        return  c;\\n    }\\n};\\n```\\n\\n**Please Upvote if you found helpful**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        int i,j;\\n        int n=nums.size();\\n        int c=0;\\n     for(i=0;i<n;i++)\\n     {\\n         for(j=i+1;j<n;j++)\\n         {\\n             auto it=lower_bound(nums.begin()+j+1,nums.end(),nums[i]+nums[j])-nums.begin()-1;\\n             \\n             c+=(it-j);\\n         }\\n        }\\n        return  c;\\n    }\\n};\\n```\n``` \\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        int i;\\n        int n=nums.size();\\n        int c=0;\\n        for(i=n-1;i>=2;i--)\\n        {\\n            int left=0;\\n            int right=i-1;\\n            \\n            while(left<right)\\n            {\\n                if(nums[left]+nums[right]>nums[i])\\n                {\\n                    c+=(right-left);\\n                    right--;\\n                }\\n                else left++;\\n                \\n            }\\n        }\\n        return  c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1340218,
                "title": "c-simple-0ms",
                "content": "\\t\\n\\tint triangleNumber(vector<int>& nums) {\\n        \\n\\t\\tint count = 0;\\n        if(nums.size() < 3) return count;\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        for(int i=2; i<nums.size() ; i++){\\n            int left = 0, right = i-1; //left pointer from 0, right pointer from 1(i-1)\\n            \\n            while(left < right){\\n                if(nums[left] + nums[right] > nums[i]){\\n                    count += right - left;\\n                    right--;\\n                }\\n                else\\n                    left++;\\n            }\\n        }\\n        return count;\\n    }\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "\\t\\n\\tint triangleNumber(vector<int>& nums) {\\n        \\n\\t\\tint count = 0;\\n        if(nums.size() < 3) return count;\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        for(int i=2; i<nums.size() ; i++){\\n            int left = 0, right = i-1; //left pointer from 0, right pointer from 1(i-1)\\n            \\n            while(left < right){\\n                if(nums[left] + nums[right] > nums[i]){\\n                    count += right - left;\\n                    right--;\\n                }\\n                else\\n                    left++;\\n            }\\n        }\\n        return count;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1305720,
                "title": "2-solutions-brute-force-n-3-and-2-pointer-approach",
                "content": "**Solution 1**\\nGiven that we need to sum 2 numbers and the result must be greater than a 3rd number, i got the feeling that sorting the input first would help us alot. This way we can have small values in the front and large ones on the back. \\n\\nIn a way you can sort of think of this as a 3sum problem where the question is essentially asking us to find 3 pairs of numbers where\\nthe following must be true: `num1 + num2 > num3 `\\n\\nImagine an array that looks like this, where we have our pointers like this:\\n```\\n[2  4  6  8   9]\\n a        b   c     ----> a + b > c, then solutions_count += b-a, which is 3..3 possible solutions from index b to a\\n a     b  c         ----> a + b > c, then solutions_count += b-a which is  2..2possible solutions from index b to a\\n```\\n\\nHigh level steps\\n- sort the input\\n- use 2 pointer approach\\n- start for loop from the end (call this side_c_index)\\n  - create a side_a_index and side_b_index inside the for loop\\n\\n\\n\\n```\\nvar triangleNumber = function (nums) {\\n    if(nums.length < 3) return 0;\\n    \\n    nums.sort((a,b) => a-b)\\n    let solutions_count = 0;\\n    \\n    for(let side_c_index=nums.length-1; side_c_index >= 2; side_c_index--){\\n        let side_a_index =0;\\n        let side_b_index = side_c_index-1;\\n\\n        while(side_a_index < side_b_index){\\n            if(nums[side_a_index] + nums[side_b_index] > nums[side_c_index]){\\n                solutions_count += side_b_index - side_a_index;\\n                side_b_index -= 1\\n            }\\n            else {\\n                side_a_index +=1;\\n            }\\n        }\\n    }\\n\\n    return solutions_count;\\n};\\n```\\n\\n\\n**Solution 2: Brute Force**\\n- use 3 loops (nested) to test triplets\\n- slow n^3\\n\\n```\\nvar triangleNumber = function (nums) {\\n    if(nums.length < 3) return 0;\\n    let solutions_count = 0;\\n    \\n    for(let i=0; i < nums.length; i++){\\n        for(let j=i+1; j < nums.length; j++){\\n            for(let k=j+1; k < nums.length; k++){\\n                const [side_a, side_b, side_c] = [ nums[i], nums[j], nums[k] ];\\n                \\n                if(is_valid_triangle(side_a, side_b, side_c)){\\n                    solutions_count += 1\\n                }\\n            }\\n        }\\n    }\\n    return solutions_count;\\n};\\n\\nfunction is_valid_triangle(side_a, side_b, side_c){\\n    return (\\n        side_a + side_b  > side_c && \\n        side_a + side_c > side_b && \\n        side_c + side_b > side_a\\n    )\\n}\\n```\\n\\n\\nNote\\n- this problem has  similarities to [3sum smaller](https://leetcode.com/problems/3sum-smaller/submissions/). Specifically the part where once we find a solution that works, we subtract to indices to indicate this and solutions within this index range also work",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\n[2  4  6  8   9]\\n a        b   c     ----> a + b > c, then solutions_count += b-a, which is 3..3 possible solutions from index b to a\\n a     b  c         ----> a + b > c, then solutions_count += b-a which is  2..2possible solutions from index b to a\\n```\n```\\nvar triangleNumber = function (nums) {\\n    if(nums.length < 3) return 0;\\n    \\n    nums.sort((a,b) => a-b)\\n    let solutions_count = 0;\\n    \\n    for(let side_c_index=nums.length-1; side_c_index >= 2; side_c_index--){\\n        let side_a_index =0;\\n        let side_b_index = side_c_index-1;\\n\\n        while(side_a_index < side_b_index){\\n            if(nums[side_a_index] + nums[side_b_index] > nums[side_c_index]){\\n                solutions_count += side_b_index - side_a_index;\\n                side_b_index -= 1\\n            }\\n            else {\\n                side_a_index +=1;\\n            }\\n        }\\n    }\\n\\n    return solutions_count;\\n};\\n```\n```\\nvar triangleNumber = function (nums) {\\n    if(nums.length < 3) return 0;\\n    let solutions_count = 0;\\n    \\n    for(let i=0; i < nums.length; i++){\\n        for(let j=i+1; j < nums.length; j++){\\n            for(let k=j+1; k < nums.length; k++){\\n                const [side_a, side_b, side_c] = [ nums[i], nums[j], nums[k] ];\\n                \\n                if(is_valid_triangle(side_a, side_b, side_c)){\\n                    solutions_count += 1\\n                }\\n            }\\n        }\\n    }\\n    return solutions_count;\\n};\\n\\nfunction is_valid_triangle(side_a, side_b, side_c){\\n    return (\\n        side_a + side_b  > side_c && \\n        side_a + side_c > side_b && \\n        side_c + side_b > side_a\\n    )\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1119594,
                "title": "using-efficient-mthd-to-find-number-of-triangles-in-o-n-2-and-o-1-beats-96",
                "content": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int count=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=n-1;i>0;i--){\\n                \\n            int l=0;\\n            int r=i-1;\\n            \\n            while(l<r){\\n                    if(nums[l]+nums[r]>nums[i]){\\n                        count+=r-l;\\n                        r--;\\n                        \\n                    }else{\\n                        l++;\\n                    }\\n            }\\n        }\\n    \\n\\n        return count;\\n    }\\n};\\n```\\n\\nmethod 2 ......................................................\\n```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int count=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n-2;i++){\\n            \\n            for(int j=i+1;j<n-1;j++){\\n                \\n                int k=j+1;\\n                while(k<n){\\n                    if(nums[i]+nums[j]>nums[k]){\\n                        k++;\\n                    }else{ break;}\\n                }\\n                count+=k-j-1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int count=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=n-1;i>0;i--){\\n                \\n            int l=0;\\n            int r=i-1;\\n            \\n            while(l<r){\\n                    if(nums[l]+nums[r]>nums[i]){\\n                        count+=r-l;\\n                        r--;\\n                        \\n                    }else{\\n                        l++;\\n                    }\\n            }\\n        }\\n    \\n\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int count=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n-2;i++){\\n            \\n            for(int j=i+1;j<n-1;j++){\\n                \\n                int k=j+1;\\n                while(k<n){\\n                    if(nums[i]+nums[j]>nums[k]){\\n                        k++;\\n                    }else{ break;}\\n                }\\n                count+=k-j-1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1103046,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        int count = 0;\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        for (int i = 0; i < n - 2; i++) {\\n            int k = i + 2;\\n            for (int j = i + 1; j < n - 1 && nums[i] != 0; j++) {\\n                while (k < n && nums[i] + nums[j] > nums[k])\\n                    k++;\\n                count += k - j - 1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        int count = 0;\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        for (int i = 0; i < n - 2; i++) {\\n            int k = i + 2;\\n            for (int j = i + 1; j < n - 1 && nums[i] != 0; j++) {\\n                while (k < n && nums[i] + nums[j] > nums[k])\\n                    k++;\\n                count += k - j - 1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 884373,
                "title": "python3-o-n-2-time-solution",
                "content": "`O(N^2)` 94.94%\\n```\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        ans = 0\\n        for i in range(len(nums)): \\n            lo, hi = 0, i-1\\n            while lo < hi: \\n                if nums[lo] + nums[hi] > nums[i]:\\n                    ans += hi - lo \\n                    hi -= 1\\n                else: lo += 1\\n        return ans \\n```\\n\\n```\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        ans = 0\\n        for i in range(len(nums)):\\n            k = i+2\\n            for j in range(i+1, len(nums)):\\n                while k < len(nums) and nums[i] + nums[j] > nums[k]: k += 1\\n                if j < k: ans += k-1-j\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        ans = 0\\n        for i in range(len(nums)): \\n            lo, hi = 0, i-1\\n            while lo < hi: \\n                if nums[lo] + nums[hi] > nums[i]:\\n                    ans += hi - lo \\n                    hi -= 1\\n                else: lo += 1\\n        return ans \\n```\n```\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        ans = 0\\n        for i in range(len(nums)):\\n            k = i+2\\n            for j in range(i+1, len(nums)):\\n                while k < len(nums) and nums[i] + nums[j] > nums[k]: k += 1\\n                if j < k: ans += k-1-j\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 354606,
                "title": "two-solutions-in-python-3-bisect-and-linear-scan",
                "content": "_Bisect (Binary Search):_ ( O( n\\xB2 log n ) ) (about 750 ms)\\n```\\nclass Solution:\\n    def triangleNumber(self, T: List[int]) -> int:\\n    \\tL, t, _ = len(T), 0, T.sort()\\n    \\tfor i in range(L-2):\\n    \\t\\tk = i + 2\\n    \\t\\tfor j in range(i+1,L-1):\\n    \\t\\t\\tM = T[i] + T[j] - 1\\n    \\t\\t\\tif M < T[j]: continue\\n    \\t\\t\\tk = bisect.bisect_right(T, M, k)\\n    \\t\\t\\tt += min(k, L) - (j + 1)\\n    \\treturn t\\n\\t\\t\\n\\n```\\n_Linear Scan:_ ( O( n\\xB2 ) ) (about 620 ms)\\n```\\nclass Solution:\\n    def triangleNumber(self, T: List[int]) -> int:\\n    \\tL, t, _ = len(T), 0, T.sort()\\n    \\tfor i in range(L-2):\\n    \\t\\tk = i + 2\\n    \\t\\tfor j in range(i+1,L-1):\\n    \\t\\t\\tM = T[i] + T[j] - 1\\n    \\t\\t\\tif M < T[j]: continue\\n    \\t\\t\\twhile k < L and T[k] <= M: k += 1\\n    \\t\\t\\tt += min(k, L) - (j + 1)\\n    \\treturn t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def triangleNumber(self, T: List[int]) -> int:\\n    \\tL, t, _ = len(T), 0, T.sort()\\n    \\tfor i in range(L-2):\\n    \\t\\tk = i + 2\\n    \\t\\tfor j in range(i+1,L-1):\\n    \\t\\t\\tM = T[i] + T[j] - 1\\n    \\t\\t\\tif M < T[j]: continue\\n    \\t\\t\\tk = bisect.bisect_right(T, M, k)\\n    \\t\\t\\tt += min(k, L) - (j + 1)\\n    \\treturn t\\n\\t\\t\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 104204,
                "title": "python-straightforward-with-explanation",
                "content": "Sort the array.  For every pair of sticks u, v with stick u occuring before v (u <= v), we want to know how many w occuring after v have w < u + v.\\n\\nFor every middle stick B[j] = v, we can use two pointers: one pointer i going down from j to 0, and one pointer k going from the end to j.  This is because if we have all w such that w < u + v, then decreasing u cannot make this set larger.\\n\\nLet's look at an extension where our sorted array is grouped into counts of it's values.  For example, instead of dealing with A = [2,2,2,2,3,3,3,3,3,4,4,4], we should deal with only B = [2, 3, 4] and keep a sidecount of C[2] = 4, C[3] = 5, C[4] = 3.  We'll also keep a prefix sum P[k] = C[B[0]] + C[B[1]] + ... + C[B[k-1]]  (and P[0] = 0.)\\n\\nWhen we are done setting our pointers and want to add the result, we need to add the result taking into account multiplicities (how many times each kind of triangle occurs.)  When i == j or j == k, this is a little tricky, so let's break it down case by case.\\n\\n* When i < j, we have C[B[i]] * C[B[j]] * (P[k+1] - P[j+1]) triangles where the last stick has a value > B[j].  Then, we have another C[B[i]] * (C[B[j]] choose 2) triangles where the last stick has value B[j].\\n* When i == j, we have (C[B[i]] choose 2) * (P[k+1] - P[j+1]) triangles where the last stick has value > B[j].  Then, we have another (C[B[i]] choose 3) triangles where the last stick has value B[j].\\n\\n```\\ndef triangleNumber(self, A):\\n    C = collections.Counter(A)\\n    C.pop(0, None)\\n    B = sorted(C.keys())\\n    P = [0]\\n    for x in B:\\n        P.append(P[-1] + C[x])\\n        \\n    ans = 0\\n    for j, v in enumerate(B):\\n        k = len(B) - 1\\n        i = j\\n        while 0 <= i <= j <= k:\\n            while k > j and B[i] + B[j] <= B[k]:\\n                k -= 1\\n            if i < j:\\n                ans += C[B[i]] * C[B[j]] * (P[k+1] - P[j+1])\\n                ans += C[B[i]] * C[B[j]] * (C[B[j]] - 1) / 2\\n            else:\\n                ans += C[B[i]] * (C[B[i]] - 1) / 2 * (P[k+1] - P[j+1])\\n                ans += C[B[i]] * (C[B[i]] - 1) * (C[B[i]] - 2) / 6\\n            i -= 1\\n    return ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef triangleNumber(self, A):\\n    C = collections.Counter(A)\\n    C.pop(0, None)\\n    B = sorted(C.keys())\\n    P = [0]\\n    for x in B:\\n        P.append(P[-1] + C[x])\\n        \\n    ans = 0\\n    for j, v in enumerate(B):\\n        k = len(B) - 1\\n        i = j\\n        while 0 <= i <= j <= k:\\n            while k > j and B[i] + B[j] <= B[k]:\\n                k -= 1\\n            if i < j:\\n                ans += C[B[i]] * C[B[j]] * (P[k+1] - P[j+1])\\n                ans += C[B[i]] * C[B[j]] * (C[B[j]] - 1) / 2\\n            else:\\n                ans += C[B[i]] * (C[B[i]] - 1) / 2 * (P[k+1] - P[j+1])\\n                ans += C[B[i]] * (C[B[i]] - 1) * (C[B[i]] - 2) / 6\\n            i -= 1\\n    return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4012498,
                "title": "valid-triangle-number-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        sort(nums.rbegin(), nums.rend());\\n        int n = nums.size();\\n        int cnt = 0;\\n        for(int i = 0; i < n; i++){\\n            int j = i + 1;\\n            int k = n - 1;\\n            while(j < k){\\n                int a = nums[i];\\n                int b = nums[j];\\n                int c = nums[k];\\n                if(b + c > a){\\n                    cnt += k - j;\\n                    j++;\\n                }\\n                else{\\n                    k--;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        sort(nums.rbegin(), nums.rend());\\n        int n = nums.size();\\n        int cnt = 0;\\n        for(int i = 0; i < n; i++){\\n            int j = i + 1;\\n            int k = n - 1;\\n            while(j < k){\\n                int a = nums[i];\\n                int b = nums[j];\\n                int c = nums[k];\\n                if(b + c > a){\\n                    cnt += k - j;\\n                    j++;\\n                }\\n                else{\\n                    k--;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3562279,
                "title": "full-explanation-python-2-line",
                "content": "## Solution 1 :\\n## What Q asked to do :\\n```\\nnums = [0,0,10,15,17,19,20,22,25,26,30,31,37] (sorted version)\\n\\nIf nums[i] is not 0 as with 0 length a triangle is not possible :\\n_________________________________________________________________\\n\\nfor a triangle we need 3 length and if a+b>c and a+c>b and b+c>a BUT since we are \\'sorting\\'\\nwe need to check only one condition, \"a+b>c\"\\n\\n        nums[2] + nums[3] = 10 + 15 = 25. \\n    Now with this summation of these TWO FIXED VALUE we will compare it with other values :\\n        \\nnums = [0,0, 10,15, 17,19,20,22,  25,26,30,31,37] (sorted version)\\n             |___|  |__________|   |\\n               |          |        |_____ We stop here as it defies the rule \"a+b>c\"\\nFixed Value ---|    These 4 values        (25>25 -- False)\\nSummation = 25      are less than 25\\n                    and satisfy the \\n                    rule a+b>c\\n\\nSince the list is sorted, we can find the FIRST VALUE WHICH IS EQUAL OR GREATER THAN THE \\nSUMMATION with lower_bound IN CPP and bisect_left in Python.\\n\\nWe checked for 10,15,17  10,15,19  10,15,20 ...... what about for 10,17,19  10,17,20?\\n\\nI believe you got the idea now.\\n```\\n```CPP []\\nclass Solution \\n{\\npublic:\\n    int triangleNumber(vector<int>& nums) \\n    {\\n        sort(begin(nums), end(nums));\\n        int lb, count = 0, ni = nums.size()-2, nj = nums.size()-1;\\n        for(int i=0; i<ni; i++)\\n        {\\n            for(int j=i+1; j<nj ;j++)\\n            {\\n                lb = lower_bound(nums.begin()+j+1, nums.end(), nums[i]+nums[j]) - nums.begin();\\n                count += lb - j -1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n```Python []\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return sum( bisect_left(nums, nums[i]+nums[j]) - j-1 for i in range(len(nums)-2) if nums[i]!=0 for j in range(i+1, len(nums)-1) )\\n```\\n```\\nTime  complexity : O(n^2 logn) as for every O(n^2) we did logn operation\\nSpace complexity : O(1)\\n```\\n\\n## Modification in solution 1\\n```\\nnums = [0,0, 10,15, 17,19,20,22,  25,26,30,31,37] (sorted version)\\n             |___|  |__________|   |\\n               |                   |_____ We stop here.\\n              25 \\n\\nnums = [0,0, 10,15,17,19,20,22,  25,26,30,31,37] (sorted version)\\n              |_____|             |\\n                 |                |_____ For 27 start from here.\\n                 27\\n\\nIf for the summation of 25, 17,19,20,22 are true, then for 27 19,20,22 already true as 27>25\\n                            |_________|\\nso start from previous inside the loop of \\'j\\'. for every \\'i\\', lb = i+2.\\nNow the lower_bound won\\'t even run O(n) inside the nested loop till j stops, so TC is O(n^2) \\n\\nfor testcases : nums = [1,2,3,4,5]\\nfor i = 0, j = 1 : bisect_left/lower_bound will return 1 for searching 1+2 = 3\\nsince the index of 3 is 2, then j will be 2 also, but we don\\'t want to start our\\nlower_bound/bisect_left at the same index of j, so I added (lb == j) which will handle this. \\n```               \\n```CPP []\\nclass Solution \\n{\\npublic:\\n    int triangleNumber(vector<int>& nums) \\n    {\\n        sort(begin(nums), end(nums));\\n        int lb = 0, count = 0, ni = nums.size()-2, nj = nums.size()-1;\\n        for(int i=0; i<ni; i++)\\n        {\\n            if(nums[i] == 0) continue;\\n            lb = i+2;\\n            for(int j=i+1; j<nj; j++)\\n            {\\n                lb = lower_bound(begin(nums)+lb+(lb==j), end(nums), nums[i]+nums[j]) - begin(nums);\\n                count += lb - j-1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n```CPP []\\nclass Solution \\n{\\npublic:\\n    int triangleNumber(vector<int>& nums) \\n    {\\n        sort(begin(nums), end(nums));\\n        int lb = 0, count = 0, ni = nums.size()-2, nj = nums.size()-1;\\n        for(int i=0; i<ni; i++)\\n        {\\n            if(nums[i] == 0) continue;\\n            lb = i+2;\\n            for(int j=i+1; j<nj; j++)\\n            {\\n                // without lower bound\\n                while(lb<nums.size() && nums[i]+nums[j]>nums[lb])\\n                    lb++;\\n                count += lb - j-1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n```Python []\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        count = lb = 0\\n        for i in range(len(nums)-2):\\n            if nums[i] == 0: continue\\n            lb = i + 2\\n            for j in range(i+1, len(nums)-1):\\n                lb = bisect_left(nums, nums[i]+nums[j], lb+(lb==j))\\n                count += lb - j - 1\\n        \\n        return count\\n```\\n```\\nTime  Complexity : O(n^2) which i explained why.\\nSpace Complexity : O(1)\\n```\\n## If the post was helpful to you, an upvote will really make me happy:)",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\nnums = [0,0,10,15,17,19,20,22,25,26,30,31,37] (sorted version)\\n\\nIf nums[i] is not 0 as with 0 length a triangle is not possible :\\n_________________________________________________________________\\n\\nfor a triangle we need 3 length and if a+b>c and a+c>b and b+c>a BUT since we are \\'sorting\\'\\nwe need to check only one condition, \"a+b>c\"\\n\\n        nums[2] + nums[3] = 10 + 15 = 25. \\n    Now with this summation of these TWO FIXED VALUE we will compare it with other values :\\n        \\nnums = [0,0, 10,15, 17,19,20,22,  25,26,30,31,37] (sorted version)\\n             |___|  |__________|   |\\n               |          |        |_____ We stop here as it defies the rule \"a+b>c\"\\nFixed Value ---|    These 4 values        (25>25 -- False)\\nSummation = 25      are less than 25\\n                    and satisfy the \\n                    rule a+b>c\\n\\nSince the list is sorted, we can find the FIRST VALUE WHICH IS EQUAL OR GREATER THAN THE \\nSUMMATION with lower_bound IN CPP and bisect_left in Python.\\n\\nWe checked for 10,15,17  10,15,19  10,15,20 ...... what about for 10,17,19  10,17,20?\\n\\nI believe you got the idea now.\\n```\n```CPP []\\nclass Solution \\n{\\npublic:\\n    int triangleNumber(vector<int>& nums) \\n    {\\n        sort(begin(nums), end(nums));\\n        int lb, count = 0, ni = nums.size()-2, nj = nums.size()-1;\\n        for(int i=0; i<ni; i++)\\n        {\\n            for(int j=i+1; j<nj ;j++)\\n            {\\n                lb = lower_bound(nums.begin()+j+1, nums.end(), nums[i]+nums[j]) - nums.begin();\\n                count += lb - j -1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\n```Python []\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return sum( bisect_left(nums, nums[i]+nums[j]) - j-1 for i in range(len(nums)-2) if nums[i]!=0 for j in range(i+1, len(nums)-1) )\\n```\n```\\nTime  complexity : O(n^2 logn) as for every O(n^2) we did logn operation\\nSpace complexity : O(1)\\n```\n```\\nnums = [0,0, 10,15, 17,19,20,22,  25,26,30,31,37] (sorted version)\\n             |___|  |__________|   |\\n               |                   |_____ We stop here.\\n              25 \\n\\nnums = [0,0, 10,15,17,19,20,22,  25,26,30,31,37] (sorted version)\\n              |_____|             |\\n                 |                |_____ For 27 start from here.\\n                 27\\n\\nIf for the summation of 25, 17,19,20,22 are true, then for 27 19,20,22 already true as 27>25\\n                            |_________|\\nso start from previous inside the loop of \\'j\\'. for every \\'i\\', lb = i+2.\\nNow the lower_bound won\\'t even run O(n) inside the nested loop till j stops, so TC is O(n^2) \\n\\nfor testcases : nums = [1,2,3,4,5]\\nfor i = 0, j = 1 : bisect_left/lower_bound will return 1 for searching 1+2 = 3\\nsince the index of 3 is 2, then j will be 2 also, but we don\\'t want to start our\\nlower_bound/bisect_left at the same index of j, so I added (lb == j) which will handle this. \\n```\n```CPP []\\nclass Solution \\n{\\npublic:\\n    int triangleNumber(vector<int>& nums) \\n    {\\n        sort(begin(nums), end(nums));\\n        int lb = 0, count = 0, ni = nums.size()-2, nj = nums.size()-1;\\n        for(int i=0; i<ni; i++)\\n        {\\n            if(nums[i] == 0) continue;\\n            lb = i+2;\\n            for(int j=i+1; j<nj; j++)\\n            {\\n                lb = lower_bound(begin(nums)+lb+(lb==j), end(nums), nums[i]+nums[j]) - begin(nums);\\n                count += lb - j-1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\n```CPP []\\nclass Solution \\n{\\npublic:\\n    int triangleNumber(vector<int>& nums) \\n    {\\n        sort(begin(nums), end(nums));\\n        int lb = 0, count = 0, ni = nums.size()-2, nj = nums.size()-1;\\n        for(int i=0; i<ni; i++)\\n        {\\n            if(nums[i] == 0) continue;\\n            lb = i+2;\\n            for(int j=i+1; j<nj; j++)\\n            {\\n                // without lower bound\\n                while(lb<nums.size() && nums[i]+nums[j]>nums[lb])\\n                    lb++;\\n                count += lb - j-1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\n```Python []\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        count = lb = 0\\n        for i in range(len(nums)-2):\\n            if nums[i] == 0: continue\\n            lb = i + 2\\n            for j in range(i+1, len(nums)-1):\\n                lb = bisect_left(nums, nums[i]+nums[j], lb+(lb==j))\\n                count += lb - j - 1\\n        \\n        return count\\n```\n```\\nTime  Complexity : O(n^2) which i explained why.\\nSpace Complexity : O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470324,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ans = 0;\\n        for(int k = nums.size() - 1; k > 1; k--) {\\n            int i = 0, j = k-1;\\n            while(i < j) {\\n                if(nums[i] + nums[j] > nums[k]) {\\n                    ans += j - i;\\n                    j--;\\n                } \\n                else i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ans = 0;\\n        for(int k = nums.size() - 1; k > 1; k--) {\\n            int i = 0, j = k-1;\\n            while(i < j) {\\n                if(nums[i] + nums[j] > nums[k]) {\\n                    ans += j - i;\\n                    j--;\\n                } \\n                else i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260309,
                "title": "two-pointer-solution-beats-96-people",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n       \\n        int ans=0;\\n\\n        for(int i=nums.size()-1;i>=2;i--)\\n        {\\n            int low=0;\\n            int high=i-1;\\n            while(low<high)\\n            {\\n                if(nums[i]<nums[low]+nums[high])\\n                {\\n                    ans+=(high-low);\\n                    high--;\\n                }\\n                else{\\n                    low++;\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n       \\n        int ans=0;\\n\\n        for(int i=nums.size()-1;i>=2;i--)\\n        {\\n            int low=0;\\n            int high=i-1;\\n            while(low<high)\\n            {\\n                if(nums[i]<nums[low]+nums[high])\\n                {\\n                    ans+=(high-low);\\n                    high--;\\n                }\\n                else{\\n                    low++;\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3102326,
                "title": "simple-easy-c-solution",
                "content": "## Code\\n```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        int cnt=0;\\n        sort(nums.begin(),nums.end());\\n        int n= nums.size();\\n        for (int k=n-1; k>=2; k--){\\n            int left=0; int right= k-1;\\n            while (left<right){\\n                if (nums[left]+nums[right]<=nums[k]){\\n                    left++;\\n                }\\n                else{\\n                    cnt+= (right-left);\\n                    right--;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        int cnt=0;\\n        sort(nums.begin(),nums.end());\\n        int n= nums.size();\\n        for (int k=n-1; k>=2; k--){\\n            int left=0; int right= k-1;\\n            while (left<right){\\n                if (nums[left]+nums[right]<=nums[k]){\\n                    left++;\\n                }\\n                else{\\n                    cnt+= (right-left);\\n                    right--;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097891,
                "title": "simple-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int triangleNumber(int[] a) {\\n        Arrays.sort(a);\\n        int n=a.length;\\n        int count=0;\\n        for(int i=n-1;i>=1;i--){\\n            int left=0,right=i-1;\\n            while(left<right){\\n                if(a[left]+a[right]>a[i]){\\n                    count+=right-left;\\n                    right--;\\n                }\\n                else\\n                left++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int triangleNumber(int[] a) {\\n        Arrays.sort(a);\\n        int n=a.length;\\n        int count=0;\\n        for(int i=n-1;i>=1;i--){\\n            int left=0,right=i-1;\\n            while(left<right){\\n                if(a[left]+a[right]>a[i]){\\n                    count+=right-left;\\n                    right--;\\n                }\\n                else\\n                left++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945182,
                "title": "java-solution-with-nested-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We know that the sum of any two sides should always be greater than the third side alone.\\n- We need to sort from lowest to highest, then find 2 lower numbers on the left that can be greater than a higher number on the right.\\n- If `nums[i] + nums[j]` is larger than locked `nums[k]`, we know that there will be `j - i` combination. \\n- In other words, for given `j`, every `i` from `i` onwards to `j` will be `> k`\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$ - nested loop\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ - constant variables\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int triangleNumber(int[] nums) {\\n        int count = 0;\\n        Arrays.sort(nums); // sort so we can easily compare nums[i] + nums[j] > nums[k]\\n        // k >= 2, because i and j at the minimum will take up index 0 and 1\\n        for (int k = nums.length-1; k >= 2; k--) { // start outer loop at k since we are LOCKING this single number for comparison \\n            int i = 0;\\n            int j = k-1; // needs to be to the left of k\\n\\n            // loop all possible combinations of i and j until nums[i] + nums[j] no longer greater than k\\n            while (i < j) { \\n                if (nums[i] + nums[j] > nums[k]) {\\n                    count += j-i; // for given j, every i from i onwards to j will be > k\\n                    j--; // decrease upper numbers bound to see if we can have: nums[i] + nums[j] > nums[k]\\n                }\\n                if (nums[i] + nums[j] <= nums[k]) {\\n                    i++; // increase lower numbers bound to see if we can have: nums[i] + nums[j] > nums[k]\\n                }              \\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int triangleNumber(int[] nums) {\\n        int count = 0;\\n        Arrays.sort(nums); // sort so we can easily compare nums[i] + nums[j] > nums[k]\\n        // k >= 2, because i and j at the minimum will take up index 0 and 1\\n        for (int k = nums.length-1; k >= 2; k--) { // start outer loop at k since we are LOCKING this single number for comparison \\n            int i = 0;\\n            int j = k-1; // needs to be to the left of k\\n\\n            // loop all possible combinations of i and j until nums[i] + nums[j] no longer greater than k\\n            while (i < j) { \\n                if (nums[i] + nums[j] > nums[k]) {\\n                    count += j-i; // for given j, every i from i onwards to j will be > k\\n                    j--; // decrease upper numbers bound to see if we can have: nums[i] + nums[j] > nums[k]\\n                }\\n                if (nums[i] + nums[j] <= nums[k]) {\\n                    i++; // increase lower numbers bound to see if we can have: nums[i] + nums[j] > nums[k]\\n                }              \\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2911267,
                "title": "short-clean-java-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int triangleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int count = 0;\\n        for(int k=nums.length-1; k>1; k--){\\n            int i=0, j=k-1;\\n            while(i<j){\\n                if(nums[i] + nums[j] > nums[k]){\\n                    count += j-i;\\n                    j--;\\n                } \\n                else i++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int triangleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int count = 0;\\n        for(int k=nums.length-1; k>1; k--){\\n            int i=0, j=k-1;\\n            while(i<j){\\n                if(nums[i] + nums[j] > nums[k]){\\n                    count += j-i;\\n                    j--;\\n                } \\n                else i++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2080621,
                "title": "python-very-simple-binary-search-with-explanation",
                "content": "```\\nclass Solution(object):\\n    \\'\\'\\'\\n       As we know inorder to check if a triangle is valid or not, if its sides are given:=>\\n       A triangle is a valid triangle, If and only If, the sum of any two sides of a triangle is \\n       greater than the third side. For Example, let A, B and C are three sides of a triangle. \\n       Then, A + B > C, B + C > A and C + A > B.\\n       Following the same we can apply this in code... \\n    \\'\\'\\'\\n    def isValidTriangle(self,index,nums):\\n        l,r = 0, index-1\\n        ans  = 0\\n        while l < r:\\n            if nums[l] + nums[r] > nums[index]:\\n                ans += r - l\\n                r -= 1\\n            else:\\n                l += 1    \\n        return ans\\n    \\n    def triangleNumber(self, nums):\\n        if len(nums) < 3:\\n            return 0\\n        \\n        nums.sort()\\n        res = 0\\n        for i in range(2, len(nums)):\\n            res += self.isValidTriangle(i, nums) \\n        \\n        return res\\n    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution(object):\\n    \\'\\'\\'\\n       As we know inorder to check if a triangle is valid or not, if its sides are given:=>\\n       A triangle is a valid triangle, If and only If, the sum of any two sides of a triangle is \\n       greater than the third side. For Example, let A, B and C are three sides of a triangle. \\n       Then, A + B > C, B + C > A and C + A > B.\\n       Following the same we can apply this in code... \\n    \\'\\'\\'\\n    def isValidTriangle(self,index,nums):\\n        l,r = 0, index-1\\n        ans  = 0\\n        while l < r:\\n            if nums[l] + nums[r] > nums[index]:\\n                ans += r - l\\n                r -= 1\\n            else:\\n                l += 1    \\n        return ans\\n    \\n    def triangleNumber(self, nums):\\n        if len(nums) < 3:\\n            return 0\\n        \\n        nums.sort()\\n        res = 0\\n        for i in range(2, len(nums)):\\n            res += self.isValidTriangle(i, nums) \\n        \\n        return res\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1940846,
                "title": "accepted-solution-for-swift",
                "content": "```swift\\nclass Solution {\\n    func triangleNumber(_ nums: [Int]) -> Int {\\n        if nums.count < 3 { return 0 }\\n        let srt = nums.sorted()\\n        var val = 0\\n        for i in (2..<srt.count).reversed() {\\n            var lhs = 0, rhs = i - 1\\n            while lhs < rhs {\\n                if srt[lhs] + srt[rhs] > srt[i] {\\n                    val += rhs - lhs\\n                    rhs -= 1\\n                } else {\\n                    lhs += 1\\n                }\\n            }\\n        }\\n        return val\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 2 tests, with 0 failures (0 unexpected) in 0.010 (0.012) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n\\n    private let solution = Solution()\\n    \\n    // Valid combinations are:\\n    // 2,3,4 (using the first 2)\\n    // 2,3,4 (using the second 2)\\n    // 2,2,3\\n    func test0() {\\n        let value = solution.triangleNumber([2,2,3,4])\\n        XCTAssertEqual(value, 3)\\n    }\\n    \\n    func test1() {\\n        let value = solution.triangleNumber([4,2,3,4])\\n        XCTAssertEqual(value, 4)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func triangleNumber(_ nums: [Int]) -> Int {\\n        if nums.count < 3 { return 0 }\\n        let srt = nums.sorted()\\n        var val = 0\\n        for i in (2..<srt.count).reversed() {\\n            var lhs = 0, rhs = i - 1\\n            while lhs < rhs {\\n                if srt[lhs] + srt[rhs] > srt[i] {\\n                    val += rhs - lhs\\n                    rhs -= 1\\n                } else {\\n                    lhs += 1\\n                }\\n            }\\n        }\\n        return val\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n\\n    private let solution = Solution()\\n    \\n    // Valid combinations are:\\n    // 2,3,4 (using the first 2)\\n    // 2,3,4 (using the second 2)\\n    // 2,2,3\\n    func test0() {\\n        let value = solution.triangleNumber([2,2,3,4])\\n        XCTAssertEqual(value, 3)\\n    }\\n    \\n    func test1() {\\n        let value = solution.triangleNumber([4,2,3,4])\\n        XCTAssertEqual(value, 4)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499603,
                "title": "python-2-pointers-o-n-2-solution",
                "content": "```\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        count = 0\\n        \\n        for i in range(2, len(nums)):\\n            left, right = 0, i - 1\\n            while left < right:\\n                if nums[left] + nums[right] > nums[i]:\\n                    count += right - left\\n                    right -= 1\\n                else:\\n                    left += 1            \\n        \\n        return count\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        count = 0\\n        \\n        for i in range(2, len(nums)):\\n            left, right = 0, i - 1\\n            while left < right:\\n                if nums[left] + nums[right] > nums[i]:\\n                    count += right - left\\n                    right -= 1\\n                else:\\n                    left += 1            \\n        \\n        return count\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1456523,
                "title": "java-two-pointer-approach",
                "content": "```\\nclass Solution {\\n    public int triangleNumber(int[] nums) \\n    {\\n        int n = nums.length;\\n        if(n <= 2)\\n            return 0;\\n        \\n        Arrays.sort(nums);\\n        int total = 0;\\n        for(int i = n-1; i >= 2; i--)\\n        {\\n            int l = 0, r = i-1;\\n            \\n            while(l < r)\\n            {\\n                if(nums[l] + nums[r] > nums[i])\\n                {\\n                    total += r - l;\\n                    r--;\\n                }\\n                else\\n                    l++;\\n            }\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int triangleNumber(int[] nums) \\n    {\\n        int n = nums.length;\\n        if(n <= 2)\\n            return 0;\\n        \\n        Arrays.sort(nums);\\n        int total = 0;\\n        for(int i = n-1; i >= 2; i--)\\n        {\\n            int l = 0, r = i-1;\\n            \\n            while(l < r)\\n            {\\n                if(nums[l] + nums[r] > nums[i])\\n                {\\n                    total += r - l;\\n                    r--;\\n                }\\n                else\\n                    l++;\\n            }\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345715,
                "title": "c-solution-binary-search-approach",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& v) {\\n        sort(v.begin(),v.end());\\n        int g=0,n=v.size(),l,h;\\n        for(int i=n-1;i>=0;i--){\\n            l=0;\\n            h=i-1;\\n            while(l<h){\\n                if(v[l]+v[h]>v[i]){\\n                    g+=(h-l);\\n                    h--;\\n                }\\n                else\\n                    l++;\\n            }\\n        }\\n        return g;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& v) {\\n        sort(v.begin(),v.end());\\n        int g=0,n=v.size(),l,h;\\n        for(int i=n-1;i>=0;i--){\\n            l=0;\\n            h=i-1;\\n            while(l<h){\\n                if(v[l]+v[h]>v[i]){\\n                    g+=(h-l);\\n                    h--;\\n                }\\n                else\\n                    l++;\\n            }\\n        }\\n        return g;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1340888,
                "title": "very-simple-two-pointer-binary-search-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        int ans =0;\\n        for(int i=0;i<nums.size();i++){\\n            \\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]!=0 && nums[j]!=0){\\n                int sum = nums[i] + nums[j];\\n                \\n                int lb = lower_bound(nums.begin()+j+1,nums.end(),sum) - nums.begin();\\n                \\n                    \\n                ans = ans+lb-j-1;\\n                    \\n                }\\n                \\n            }\\n            \\n        }\\n       return ans<=0?0:ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        \\n        sort(nums.begin(),nums.end());\\n        int ans =0;\\n        for(int i=0;i<nums.size();i++){\\n            \\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i]!=0 && nums[j]!=0){\\n                int sum = nums[i] + nums[j];\\n                \\n                int lb = lower_bound(nums.begin()+j+1,nums.end(),sum) - nums.begin();\\n                \\n                    \\n                ans = ans+lb-j-1;\\n                    \\n                }\\n                \\n            }\\n            \\n        }\\n       return ans<=0?0:ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339743,
                "title": "c-2-approaches-o-n-2log-n-o-n-2",
                "content": "More about Interview Questions : https://github.com/MAZHARMIK/Interview_DS_Algo\\nFull July Challenge Solution : https://github.com/MAZHARMIK/Leetcode-July-Challenge-2021/blob/main/README.md\\n\\n```\\n//Approach-1 (Using Binary Search)\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n < 3)\\n            return 0;\\n        \\n        sort(begin(nums), end(nums));\\n        int count = 0;\\n        for(int i = 0; i<n-2; i++) {\\n            for(int j = i+1; j<n-1; j++) {\\n                int k = j+1;\\n                int sum = nums[i] + nums[j];\\n                \\n                if(k < n) {\\n                    int idx = lower_bound(begin(nums)+k, end(nums), sum) - begin(nums);\\n                    count += (idx-j-1);\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (O(n^2) Using concept similar two 3-Sum)\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n < 3)\\n            return 0;\\n        \\n        sort(begin(nums), end(nums));\\n        int count = 0;\\n        for(int i = n-1; i>1; i--) {\\n            int l = 0, r = i-1;\\n            \\n            while(l < r) {\\n                if(nums[l] + nums[r] > nums[i]) {\\n                    count += (r-l);\\n                    r--;\\n                } else {\\n                    l++;\\n                }\\n            }\\n        }     \\n        return count;\\n    }\\n};\\n\\n/*\\nNote : If we use 3-SUM approach like as shown below :\\nfor(int i = 0; i<n-2;  i++) {\\n            int l = i+1,  r = n-1;\\n\\t\\t\\twhile(l < r) {\\n\\t\\t\\t///code\\n\\t\\t\\t}\\n}\\n\\nWe won\\'t be getting correct result.\\nExample : \\n    2     2    3    4\\n\\ti     l         r\\n\\t\\n\\tnums[l]+nums[r] is not greater than nums[r]\\n\\tSo, we increase l\\n\\t\\n\\t2     2    3    4\\n\\ti          l    r\\n\\tnums[l]+nums[r] > nums[r], we increment count by 1\\n\\t\\n\\tBut if you notice we missed the triplet {2, 2, 3} XXXXXXXX ALERT!!!!!\\n\\t\\n\\t-----------------------------\\n\\t\\n\\tSo, let\\'s take same example with Approach-2\\n\\t 2     2    3    4\\n\\t l\\t\\t    r    i\\n\\t\\n\\tnums[l]+nums[r] is greater than nums[r], \\n\\tAlso, it means nums[l+1]+nums[r]  > nums[r] or sure\\n\\tAlso, nums[l+2]+nums[r]  > nums[r] or sure and so on until l < r\\n\\tSo, {2, 3, 4}, {2, 3, 4} are counted as well\\n\\t\\n\\tNow, we decrement i--\\n\\t\\n\\t2     2    3    4\\n\\tl     r    i\\n\\tHere also, {2, 2, 3} is valid until l < r\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (Using Binary Search)\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n < 3)\\n            return 0;\\n        \\n        sort(begin(nums), end(nums));\\n        int count = 0;\\n        for(int i = 0; i<n-2; i++) {\\n            for(int j = i+1; j<n-1; j++) {\\n                int k = j+1;\\n                int sum = nums[i] + nums[j];\\n                \\n                if(k < n) {\\n                    int idx = lower_bound(begin(nums)+k, end(nums), sum) - begin(nums);\\n                    count += (idx-j-1);\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\n```\\n//Approach-2 (O(n^2) Using concept similar two 3-Sum)\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n < 3)\\n            return 0;\\n        \\n        sort(begin(nums), end(nums));\\n        int count = 0;\\n        for(int i = n-1; i>1; i--) {\\n            int l = 0, r = i-1;\\n            \\n            while(l < r) {\\n                if(nums[l] + nums[r] > nums[i]) {\\n                    count += (r-l);\\n                    r--;\\n                } else {\\n                    l++;\\n                }\\n            }\\n        }     \\n        return count;\\n    }\\n};\\n\\n/*\\nNote : If we use 3-SUM approach like as shown below :\\nfor(int i = 0; i<n-2;  i++) {\\n            int l = i+1,  r = n-1;\\n\\t\\t\\twhile(l < r) {\\n\\t\\t\\t///code\\n\\t\\t\\t}\\n}\\n\\nWe won\\'t be getting correct result.\\nExample : \\n    2     2    3    4\\n\\ti     l         r\\n\\t\\n\\tnums[l]+nums[r] is not greater than nums[r]\\n\\tSo, we increase l\\n\\t\\n\\t2     2    3    4\\n\\ti          l    r\\n\\tnums[l]+nums[r] > nums[r], we increment count by 1\\n\\t\\n\\tBut if you notice we missed the triplet {2, 2, 3} XXXXXXXX ALERT!!!!!\\n\\t\\n\\t-----------------------------\\n\\t\\n\\tSo, let\\'s take same example with Approach-2\\n\\t 2     2    3    4\\n\\t l\\t\\t    r    i\\n\\t\\n\\tnums[l]+nums[r] is greater than nums[r], \\n\\tAlso, it means nums[l+1]+nums[r]  > nums[r] or sure\\n\\tAlso, nums[l+2]+nums[r]  > nums[r] or sure and so on until l < r\\n\\tSo, {2, 3, 4}, {2, 3, 4} are counted as well\\n\\t\\n\\tNow, we decrement i--\\n\\t\\n\\t2     2    3    4\\n\\tl     r    i\\n\\tHere also, {2, 2, 3} is valid until l < r\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339728,
                "title": "rust-translated-28ms",
                "content": "```rust\\nimpl Solution {\\n    pub fn triangle_number(nums: Vec<i32>) -> i32 {\\n        let mut nums = nums.iter().filter(|&n| *n > 0).collect::<Vec<_>>();\\n        if nums.len() < 3 {\\n            return 0;\\n        }\\n        nums.sort_unstable();\\n        let mut answer = 0;\\n        for i in 0..nums.len() - 2 {\\n            let mut k = i + 2;\\n            for j in i + 1..nums.len() - 1 {\\n                while k < nums.len() && nums[i] + nums[j] > *nums[k] {\\n                    k += 1;\\n                }\\n                answer += k - j - 1;\\n            }\\n        }\\n        answer as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn triangle_number(nums: Vec<i32>) -> i32 {\\n        let mut nums = nums.iter().filter(|&n| *n > 0).collect::<Vec<_>>();\\n        if nums.len() < 3 {\\n            return 0;\\n        }\\n        nums.sort_unstable();\\n        let mut answer = 0;\\n        for i in 0..nums.len() - 2 {\\n            let mut k = i + 2;\\n            for j in i + 1..nums.len() - 1 {\\n                while k < nums.len() && nums[i] + nums[j] > *nums[k] {\\n                    k += 1;\\n                }\\n                answer += k - j - 1;\\n            }\\n        }\\n        answer as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1339672,
                "title": "python-o-n-2-solution",
                "content": "```\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        count=0\\n        for i in reversed(range(2,len(nums))):\\n            r=i-1\\n            l=0\\n            while l<r:\\n                if(nums[r]+nums[l]>nums[i]):\\n                    count+=r-l\\n                    r-=1\\n                else:\\n                    l+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        count=0\\n        for i in reversed(range(2,len(nums))):\\n            r=i-1\\n            l=0\\n            while l<r:\\n                if(nums[r]+nums[l]>nums[i]):\\n                    count+=r-l\\n                    r-=1\\n                else:\\n                    l+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339351,
                "title": "c-o-n-2-time",
                "content": "Two pointer approach\\n```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int count=0;\\n        for(int i=nums.size()-1;i>=0;i--){\\n            int low= 0, high=i-1;\\n            while(low<=high){\\n                if(nums[low]+nums[high]>nums[i])\\n                {\\n                    count+= high-low;\\n                    high--;\\n                }\\n                else\\n                    low++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int count=0;\\n        for(int i=nums.size()-1;i>=0;i--){\\n            int low= 0, high=i-1;\\n            while(low<=high){\\n                if(nums[low]+nums[high]>nums[i])\\n                {\\n                    count+= high-low;\\n                    high--;\\n                }\\n                else\\n                    low++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339064,
                "title": "valid-triangle-expalined-short-code",
                "content": "guys if u find my answer helful please do upvote it motivates me to write quality answers thanks\\n```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        int len = nums.size();\\n        // fistly sort the array\\n        sort(nums.begin(),nums.end());\\n        \\n        int ans = 0;\\n        for(int i = 0;i<len-2;i++)\\n        {\\n          // i here is for first side\\n          for(int j = i+1;j<len-1;j++)\\n          {\\n            // j for second side\\n            \\n            // since its property of traingle that sum of any two side of triagle is greater third side  so we will find lower bound of sum of first two sides\\n            // and then subtract the index with j-1 and we will us all sides that are smaller than nuns[i]+nums[j]\\n            \\n            int index =       lower_bound(nums.begin(),nums.end(),nums[j]+nums[i])-nums.begin();\\n             if(index>j)\\n             {\\n                ans+=index-j-1; \\n             }\\n          \\n          }\\n        }\\n      \\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        int len = nums.size();\\n        // fistly sort the array\\n        sort(nums.begin(),nums.end());\\n        \\n        int ans = 0;\\n        for(int i = 0;i<len-2;i++)\\n        {\\n          // i here is for first side\\n          for(int j = i+1;j<len-1;j++)\\n          {\\n            // j for second side\\n            \\n            // since its property of traingle that sum of any two side of triagle is greater third side  so we will find lower bound of sum of first two sides\\n            // and then subtract the index with j-1 and we will us all sides that are smaller than nuns[i]+nums[j]\\n            \\n            int index =       lower_bound(nums.begin(),nums.end(),nums[j]+nums[i])-nums.begin();\\n             if(index>j)\\n             {\\n                ans+=index-j-1; \\n             }\\n          \\n          }\\n        }\\n      \\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1117824,
                "title": "c-concise-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n    sort(nums.begin(),nums.end());\\n    int n = nums.size();\\n    int ans =0;\\n    for(int i = n-1; i>=2; i--){\\n     \\n    int l =0;\\n    int r =i-1;\\n    while(l<r){\\n        \\n        if(nums[l]+nums[r]>nums[i]){\\n            ans+=r-l;\\n            r--;\\n        }\\n        \\n        else {\\n            l++;\\n        }\\n    }\\n        \\n        \\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n    sort(nums.begin(),nums.end());\\n    int n = nums.size();\\n    int ans =0;\\n    for(int i = n-1; i>=2; i--){\\n     \\n    int l =0;\\n    int r =i-1;\\n    while(l<r){\\n        \\n        if(nums[l]+nums[r]>nums[i]){\\n            ans+=r-l;\\n            r--;\\n        }\\n        \\n        else {\\n            l++;\\n        }\\n    }\\n        \\n        \\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 998966,
                "title": "python-solution-beats-99-sort-array-and-start-from-end",
                "content": "```\\nclass Solution(object):\\n    def triangleNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        nums.sort()\\n        for i in range(len(nums)-1, -1, -1):\\n            cur = nums[i]\\n            left, right = 0, i-1\\n            while left < right:\\n                if nums[left] + nums[right] > cur:\\n                    res += right - left\\n                    right -= 1\\n                else:\\n                    left += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def triangleNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        nums.sort()\\n        for i in range(len(nums)-1, -1, -1):\\n            cur = nums[i]\\n            left, right = 0, i-1\\n            while left < right:\\n                if nums[left] + nums[right] > cur:\\n                    res += right - left\\n                    right -= 1\\n                else:\\n                    left += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 994982,
                "title": "simple-c-using-two-pointers",
                "content": "```\\nint triangleNumber(vector<int>& nums) {\\n\\tif(nums.size()<3)\\n\\t\\treturn 0;\\n\\tsort(nums.begin(),nums.end());\\n\\tint count=0;\\n\\tfor(int i=2;i<nums.size();i++)\\n\\t{\\n\\t\\tint left=0,right=i-1;\\n\\t\\twhile(left<right)\\n\\t\\t{\\n\\t\\t\\tif(nums[left]+nums[right]>nums[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tcount=count+right-left;\\n\\t\\t\\t\\tright--;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tleft++;\\n\\t\\t}\\n\\t}\\n\\treturn count;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint triangleNumber(vector<int>& nums) {\\n\\tif(nums.size()<3)\\n\\t\\treturn 0;\\n\\tsort(nums.begin(),nums.end());\\n\\tint count=0;\\n\\tfor(int i=2;i<nums.size();i++)\\n\\t{\\n\\t\\tint left=0,right=i-1;\\n\\t\\twhile(left<right)\\n\\t\\t{\\n\\t\\t\\tif(nums[left]+nums[right]>nums[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tcount=count+right-left;\\n\\t\\t\\t\\tright--;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tleft++;\\n\\t\\t}\\n\\t}\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 902287,
                "title": "c-solution",
                "content": "The idea here is: 1, to sort the array first, and for l < r < i, array[l] < array[r] < array[i], so array[i] + array[r] > array[l] and array[i] + array[r] > array[l] are always true. As long as array[l] + array[r] > array[i], a legit triangle can exist.\\n                              2, Any element between legit l and r can also form a triangle with i. \\n```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int result = 0;\\n        for(int i = nums.size() - 1; i >= 2; i--){\\n            int l = 0, r = i - 1;\\n            while(l < r){\\n                if(nums[l] + nums[r] > nums[i]){\\n                    result += r - l;\\n                    r--;\\n                }\\n                else\\n                    l++;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int result = 0;\\n        for(int i = nums.size() - 1; i >= 2; i--){\\n            int l = 0, r = i - 1;\\n            while(l < r){\\n                if(nums[l] + nums[r] > nums[i]){\\n                    result += r - l;\\n                    r--;\\n                }\\n                else\\n                    l++;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 783012,
                "title": "611-valid-triangle-number-most-optimized-solution-and-with-detailed-explanation-c",
                "content": "**Approach**: First sort the array, and run a nested loop, fix an index and then try to fix an upper and lower index within which we can use all the lengths to form a triangle with that fixed index.\\n\\n**Algorithm:**\\n\\n\\t1. Sort the array and then take three variables l, r and i, pointing to start, end-1 and array   \\n\\t      element starting from end of the array.\\n\\t2. Traverse the array from end (n-1 to 1), and for each iteration keep the value of l = 0 and r = i-1.\\n    3. Now if a triangle can be formed using arr[l] and arr[r] then triangles can obviously formed\\n      from a[l+1], a[l+2]\\u2026..a[r-1], arr[r] and a[i], because the array is sorted , which can be directly \\n\\t  calculated using (r-l). and then decrement the value of r and continue the loop till l is less than r\\n    4.If triangle cannot be formed using arr[l] and arr[r] then increment the value of r and continue \\n      the loop till l is less than r\\n    5.So the overall complexity of iterating\\n       through all array elements reduces.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& A) {\\n        int n = A.size(); \\n  \\n        sort(A.begin(), A.end()); \\n\\n        int count = 0; \\n\\n        for (int i = n - 1; i >= 1; i--) { \\n            int l = 0, r = i - 1; \\n            while (l < r) { \\n                if (A[l] + A[r] > A[i]) { \\n\\n                    // If it is possible with a[l], a[r] \\n                    // and a[i] then it is also possible \\n                    // with a[l+1]..a[r-1], a[r] and a[i] \\n                    count += r - l; \\n\\n                    // checking for more possible solutions \\n                    r--; \\n                } \\n                else\\n\\n                    // if not possible check for \\n                    // higher values of arr[l] \\n                    l++; \\n            } \\n        }\\n    return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& A) {\\n        int n = A.size(); \\n  \\n        sort(A.begin(), A.end()); \\n\\n        int count = 0; \\n\\n        for (int i = n - 1; i >= 1; i--) { \\n            int l = 0, r = i - 1; \\n            while (l < r) { \\n                if (A[l] + A[r] > A[i]) { \\n\\n                    // If it is possible with a[l], a[r] \\n                    // and a[i] then it is also possible \\n                    // with a[l+1]..a[r-1], a[r] and a[i] \\n                    count += r - l; \\n\\n                    // checking for more possible solutions \\n                    r--; \\n                } \\n                else\\n\\n                    // if not possible check for \\n                    // higher values of arr[l] \\n                    l++; \\n            } \\n        }\\n    return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 770567,
                "title": "beats-97-submissions",
                "content": "```\\nint triangleNumber(vector<int> &v) {\\n  int n = v.size();\\n  sort(v.begin(), v.end());\\n  int ans = 0;\\n  for (int i = n - 1; i >= 0; i--) {\\n\\t int l = 0, r = i - 1;\\n\\t while (l < r) {\\n\\t\\tif (v[l] + v[r] > v[i]) {\\n\\t\\t   ans += (r - l);\\n\\t\\t   r--;\\n\\t\\t} else {\\n\\t\\t   l++;\\n\\t\\t}\\n\\t }\\n  }\\n  return ans;\\n}\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nint triangleNumber(vector<int> &v) {\\n  int n = v.size();\\n  sort(v.begin(), v.end());\\n  int ans = 0;\\n  for (int i = n - 1; i >= 0; i--) {\\n\\t int l = 0, r = i - 1;\\n\\t while (l < r) {\\n\\t\\tif (v[l] + v[r] > v[i]) {\\n\\t\\t   ans += (r - l);\\n\\t\\t   r--;\\n\\t\\t} else {\\n\\t\\t   l++;\\n\\t\\t}\\n\\t }\\n  }\\n  return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 738888,
                "title": "c-o-n-2-time-and-o-1-space-similar-to-3-sum",
                "content": "In a triangle, sum of any 2 side is always greater tha the 3rd side\\na+b > c\\n```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n     sort(nums.begin(),nums.end());\\n     int count=0;\\n     for(int i=nums.size()-1;i>=2;i--)\\n     {\\n         int st=0;\\n         int en=i-1;\\n         while(st<en)\\n         {\\n            if(nums[st]+nums[en]>nums[i]) //Condition for a triangle ie. a + b > c \\n            {\\n            //Fix point b as nums[en]\\n             count=count+(en-st);\\n            //Point b fixed.So Add the number of ways of choosing a.a can be chosen as any number from nums[st] till nums[en]\\n             en--;\\n            }\\n            else\\n            {\\n              st++;\\n            }\\n         }\\n     }\\n    return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n     sort(nums.begin(),nums.end());\\n     int count=0;\\n     for(int i=nums.size()-1;i>=2;i--)\\n     {\\n         int st=0;\\n         int en=i-1;\\n         while(st<en)\\n         {\\n            if(nums[st]+nums[en]>nums[i]) //Condition for a triangle ie. a + b > c \\n            {\\n            //Fix point b as nums[en]\\n             count=count+(en-st);\\n            //Point b fixed.So Add the number of ways of choosing a.a can be chosen as any number from nums[st] till nums[en]\\n             en--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 648819,
                "title": "java-5-ms-faster-than-99-04",
                "content": "class Solution {\\n    \\n    public int triangleNumber(int[] A) {\\n        int n = A.length;\\n        Arrays.sort(A);\\n        int count = 0;\\n        for (int i = n - 1; i > 1; i--) {\\n            int l = 0, r = i - 1;\\n            while (l < r) {\\n                if (A[l] + A[r] > A[i]) {\\n                    count += r - l;\\n                    r--;\\n                } \\n                {\\n                    l++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    public int triangleNumber(int[] A) {\\n        int n = A.length;\\n        Arrays.sort(A);\\n        int count = 0;\\n        for (int i = n - 1; i > 1; i--) {\\n            int l = 0, r = i - 1;\\n            while (l < r) {\\n                if (A[l] + A[r] > A[i]) {\\n                    count += r - l;\\n                    r--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 465636,
                "title": "python-2-lines-with-explanations",
                "content": "```\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        dic=collections.Counter(i for i in nums if i)\\n        return sum(sum((n-1)*(n-2)//2 for n in range(3,i+1)) for i in dic.values())+sum((dic[a]-1)*dic[a]//2*dic[b] for a,b in itertools.permutations(dic,2) if dic[a]>1 and a*2>b)+sum(dic[a]*dic[b]*dic[c] for a,b,c in itertools.combinations(dic,3) if a+b>c and b+c>a and c+a>b)\\n```\\n\\nEasy-read:\\n\\n```\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        dic=collections.Counter(i for i in nums if i)\\n        return (\\n            sum(sum((n-1)*(n-2)//2 for n in range(3,i+1)) for i in dic.values())\\n            +sum(\\n                (dic[a]-1)*dic[a]//2*dic[b]\\n                for a,b in itertools.permutations(dic,2)\\n\\t\\t\\t\\tif dic[a]>1 and a*2>b\\n            )\\n            +sum(\\n                dic[a]*dic[b]*dic[c]\\n                for a,b,c in itertools.combinations(dic,3)\\n                if a+b>c and b+c>a and c+a>b\\n            )\\n        )\\n```\\n\\nExplanation:\\n```sum((n-1)*(n-2)//2 for n in range(3,i+1))``` \\nFor counting the number of regular triangle.\\nIf we have 3 equal number , then we have 1 regular triangle;\\nIf we have 4 equal number , then we have 4 regular triangle;\\nIf we have 5 equal number , then we have 10 regular triangle ..\\nSo on, we get a form like this:\\n![image](https://assets.leetcode.com/users/koten0224/image_1577731000.png)\\nHere we can find out that is the **sumation** of Trapezoid Formula (start+end)*H//2 .\\nhere we got start=1 , end=H=n-2 (because this is triangle) , \\nTherefore, we have (1+n-2)*(n-2)//2 \\nand goes in (n-1)*(n-2)//2\\n\\n```(dic[a]-1)*dic[a]//2*dic[b]``` \\nFor counting the number of Isosceles triangle.\\nAgain, we get a form for Isosceles triangle:\\n![image](https://assets.leetcode.com/users/koten0224/image_1577732566.png)\\n\\nHere we can find out that is truely Trapezoid Formula but for **f(n-1)**\\nTherefore, we have (1+n-1)*(n-1)//2 \\nand goes in (n)*(n-1)//2.\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        dic=collections.Counter(i for i in nums if i)\\n        return sum(sum((n-1)*(n-2)//2 for n in range(3,i+1)) for i in dic.values())+sum((dic[a]-1)*dic[a]//2*dic[b] for a,b in itertools.permutations(dic,2) if dic[a]>1 and a*2>b)+sum(dic[a]*dic[b]*dic[c] for a,b,c in itertools.combinations(dic,3) if a+b>c and b+c>a and c+a>b)\\n```\n```\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        dic=collections.Counter(i for i in nums if i)\\n        return (\\n            sum(sum((n-1)*(n-2)//2 for n in range(3,i+1)) for i in dic.values())\\n            +sum(\\n                (dic[a]-1)*dic[a]//2*dic[b]\\n                for a,b in itertools.permutations(dic,2)\\n\\t\\t\\t\\tif dic[a]>1 and a*2>b\\n            )\\n            +sum(\\n                dic[a]*dic[b]*dic[c]\\n                for a,b,c in itertools.combinations(dic,3)\\n                if a+b>c and b+c>a and c+a>b\\n            )\\n        )\\n```\n```sum((n-1)*(n-2)//2 for n in range(3,i+1))```\n```(dic[a]-1)*dic[a]//2*dic[b]```",
                "codeTag": "Java"
            },
            {
                "id": 244596,
                "title": "c-solution-o-n-2-time-o-1-space-10lines-beat-100",
                "content": "The idea is simple. For each pair (nums[lo], nums[hi]), we only count those valid triangle numbers (mid) between lo and hi. And mid is the index of the first number which can make triangle with nums[lo] and nums[hi]. So mid increase as hi increase, and the time consume is O(n^2) not O(n^3).\\n\\n```\\n    int triangleNumber(vector<int>& nums) {\\n        if (nums.size() < 3) return 0;\\n        int res = 0;\\n        sort(nums.begin(), nums.end());\\n        for (int lo = 0; lo < nums.size() - 2; lo++) {\\n            for (int hi = lo + 2, mid = lo + 1; hi < nums.size(); hi++) {\\n                while (nums[mid] <= nums[hi] - nums[lo] && mid < hi) mid++;\\n                res = res + hi - mid;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int triangleNumber(vector<int>& nums) {\\n        if (nums.size() < 3) return 0;\\n        int res = 0;\\n        sort(nums.begin(), nums.end());\\n        for (int lo = 0; lo < nums.size() - 2; lo++) {\\n            for (int hi = lo + 2, mid = lo + 1; hi < nums.size(); hi++) {\\n                while (nums[mid] <= nums[hi] - nums[lo] && mid < hi) mid++;\\n                res = res + hi - mid;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 137692,
                "title": "why-this-version-of-greedy-doesn-t-work",
                "content": "https://leetcode.com/problems/valid-triangle-number/discuss/104174/Java-O(n2)-Time-O(1)-Space\\n\\nThe above accepted greedy version is first sort the whole array, then fix the biggest number, and for 2 smaller number use 2 pointer method.\\n\\n```\\ni = from n - 1 to  2\\n\\n left                                 right   i\\n[a0, a1, ............................, an-1, an]\\n```\\nHowever, if I fixed the smallest number first, and for 2 bigger numbers use 2 pointer method, it won\\'t work.\\n\\n```\\ni = from 0 to n - 3\\n\\n i  left                                   right\\n[a0, a1, ............................, an-1, an]\\n```\\n\\n{2, 2, 3, 4} will only count 2.\\n\\nMy question is, why fixed smallest number first won\\'t work? From my perspective the logic seems the same, fixed one side, and use 2 pointers to find the rest.\\n\\nHere is my code\\n```\\npublic int triangleNumber(int[] nums) {\\n  Arrays.sort(nums);\\n  int count = 0;\\n  int len = nums.length;\\n  for (int i = 0; i < len - 2; ++i) {\\n    int left = i + 1;\\n    int right = len - 1;\\n    while (left < right) {\\n      if (nums[i] + nums[left] > nums[right]) {\\n        count += right - left;\\n        --right;\\n      } else {\\n        ++left;\\n      }\\n  }\\n  return count;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ni = from n - 1 to  2\\n\\n left                                 right   i\\n[a0, a1, ............................, an-1, an]\\n```\n```\\ni = from 0 to n - 3\\n\\n i  left                                   right\\n[a0, a1, ............................, an-1, an]\\n```\n```\\npublic int triangleNumber(int[] nums) {\\n  Arrays.sort(nums);\\n  int count = 0;\\n  int len = nums.length;\\n  for (int i = 0; i < len - 2; ++i) {\\n    int left = i + 1;\\n    int right = len - 1;\\n    while (left < right) {\\n      if (nums[i] + nums[left] > nums[right]) {\\n        count += right - left;\\n        --right;\\n      } else {\\n        ++left;\\n      }\\n  }\\n  return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 112387,
                "title": "sort-and-then-two-pointers-c-solution-15ms",
                "content": "```\\n/*\\n1, sort first.\\n2, set tail as the target position chosen from the end of the sorted vector (the largest number)\\n3, set two poiters: j = 0, k = tail - 1, every loop:\\n   1> if nums[j] + nums[k] > nums[tail], it means {num[tail], nums[k], nums[j]}, \\n      {num[tail], nums[k], nums[j+1]} ... {num[tail], nums[k], nums[k-1]} are valid, \\n      the count is k-j\\n   2> if nums[j] + nums[k] <= nums[tail], it means all the combinations of \\n      {nums[tail], nums[j], nums[x] (j < x <= k)} are invalid, so let j++\\n4, let tail--, repeat 1-3\\n\\ntime complexity: 1: O(nlgn), 2,3,4: O(n^2), so it's O(n^2)\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n    \\tint res = 0;\\n        int n = nums.size();\\n        if (n < 3) return res;\\n\\n        sort(nums.begin(), nums.end());\\n\\n        for (int tail = n - 1; tail > 1; tail--) {\\n        \\tint k = tail - 1, j = 0;\\n        \\twhile (j < k) {\\n        \\t\\tif (nums[j] + nums[k] > nums[tail]) {\\n        \\t\\t\\tres += (k - j);\\n        \\t\\t\\tk--;\\n        \\t\\t} else\\n        \\t\\t\\tj++;\\n        \\t}\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n1, sort first.\\n2, set tail as the target position chosen from the end of the sorted vector (the largest number)\\n3, set two poiters: j = 0, k = tail - 1, every loop:\\n   1> if nums[j] + nums[k] > nums[tail], it means {num[tail], nums[k], nums[j]}, \\n      {num[tail], nums[k], nums[j+1]} ... {num[tail], nums[k], nums[k-1]} are valid, \\n      the count is k-j\\n   2> if nums[j] + nums[k] <= nums[tail], it means all the combinations of \\n      {nums[tail], nums[j], nums[x] (j < x <= k)} are invalid, so let j++\\n4, let tail--, repeat 1-3\\n\\ntime complexity: 1: O(nlgn), 2,3,4: O(n^2), so it's O(n^2)\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n    \\tint res = 0;\\n        int n = nums.size();\\n        if (n < 3) return res;\\n\\n        sort(nums.begin(), nums.end());\\n\\n        for (int tail = n - 1; tail > 1; tail--) {\\n        \\tint k = tail - 1, j = 0;\\n        \\twhile (j < k) {\\n        \\t\\tif (nums[j] + nums[k] > nums[tail]) {\\n        \\t\\t\\tres += (k - j);\\n        \\t\\t\\tk--;\\n        \\t\\t} else\\n        \\t\\t\\tj++;\\n        \\t}\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 104187,
                "title": "python-o-n-2-solution-526-ms",
                "content": "  \\n    def triangleNumber(self, nums):\\n        nums = sorted(nums)\\n        total = 0\\n        for i in range(len(nums)-2):\\n            if nums[i] == 0:\\n                continue\\n            end = i + 2\\n            for j in range(i+1, len(nums)-1):\\n                while end < len(nums) and nums[end] < (nums[i] + nums[j]):\\n                    end += 1\\n                total += end - j - 1\\n        return total",
                "solutionTags": [],
                "code": "  \\n    def triangleNumber(self, nums):\\n        nums = sorted(nums)\\n        total = 0\\n        for i in range(len(nums)-2):\\n            if nums[i] == 0:\\n                continue\\n            end = i + 2\\n            for j in range(i+1, len(nums)-1):\\n                while end < len(nums) and nums[end] < (nums[i] + nums[j]):\\n                    end += 1\\n                total += end - j - 1\\n        return total",
                "codeTag": "Python3"
            },
            {
                "id": 104201,
                "title": "o-n2-time-complexity-java-2-pointers-w-explaination",
                "content": "a, b, a and are triangle sides when a + b > c, a+c > b, and b+c > a. If a, b, c in ascending order then only thing needs to check is a+b < c.\\n\\nSorting array helps reduce number of checks and can use 2 pointers. Same as 3sum problem.\\nlo and hi pointer only visits nums elements once. For each lo increasing, hi doesn't need to be reset because if nums[i] + nums[lo] < nums[hi] then of course nums[i] + nums[lo+1] < nums[hi]. So when increase lo, hi should try to go further to the end of array.\\n\\n\\n````\\n    public int triangleNumber(int[] nums) {\\n        if (nums.length < 3)\\n            return 0;\\n        \\n        int count = 0;    \\n        Arrays.sort(nums);\\n        for (int i = 0; i < nums.length - 2; i ++){\\n            \\n            int lo = i + 1;\\n            int hi = lo;\\n            \\n            while(lo < nums.length - 1){\\n\\n                while(hi + 1 < nums.length && nums[hi + 1] < nums[i] + nums[lo])\\n                    hi++;\\n                if (hi - lo > 0)\\n                    count += hi - lo;\\n                \\n                lo++;\\n                \\n            }    \\n        }\\n            \\n        return count;\\n            \\n    }\\n\\n````",
                "solutionTags": [],
                "code": "````\\n    public int triangleNumber(int[] nums) {\\n        if (nums.length < 3)\\n            return 0;\\n        \\n        int count = 0;    \\n        Arrays.sort(nums);\\n        for (int i = 0; i < nums.length - 2; i ++){\\n            \\n            int lo = i + 1;\\n            int hi = lo;\\n            \\n            while(lo < nums.length - 1){\\n\\n                while(hi + 1 < nums.length && nums[hi + 1] < nums[i] + nums[lo])\\n                    hi++;\\n                if (hi - lo > 0)\\n                    count += hi - lo;\\n                \\n                lo++;\\n                \\n            }    \\n        }\\n            \\n        return count;\\n            \\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4008587,
                "title": "easy-java-code",
                "content": "\\n```\\nclass Solution {\\n    public int triangleNumber(int[] nums) {\\n        int n=nums.length;\\n        int count=0;\\n        Arrays.sort(nums);\\n        for(int i=0; i<n-2; i++)\\n        {\\n            for(int j=i+1; j<n-1; j++)\\n            {\\n                for(int k=j+1; k<n; k++)\\n                {\\n                    if(nums[i]+nums[j]>nums[k])\\n                    {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int triangleNumber(int[] nums) {\\n        int n=nums.length;\\n        int count=0;\\n        Arrays.sort(nums);\\n        for(int i=0; i<n-2; i++)\\n        {\\n            for(int j=i+1; j<n-1; j++)\\n            {\\n                for(int k=j+1; k<n; k++)\\n                {\\n                    if(nums[i]+nums[j]>nums[k])\\n                    {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899775,
                "title": "c-short-intuitive-code-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ans = 0, n = nums.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                int idx = lower_bound(nums.begin(), nums.end(), nums[i] + nums[j]) - nums.begin();\\n                ans += max(0, idx-j-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ans = 0, n = nums.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                int idx = lower_bound(nums.begin(), nums.end(), nums[i] + nums[j]) - nums.begin();\\n                ans += max(0, idx-j-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3792283,
                "title": "java-solution-using-two-pointers",
                "content": "# Intuition\\nFor right angled triangle, it should satisfy following 3 conditions (a,b and c are sides of triangle)\\na+b>c\\na+c>b\\nb+c>a\\n\\nSuppose c>a+b then 2nd and 3rd condition is going to satisfy automatically so always keep the c at index with value greater than a and b\\n\\n# Approach\\nSteps:\\n1.Sort the array in increasing order\\n2.After sorting ,initially c as n-1 (intially as loop will be going for c from n-1 to 2 as at last c can be at 2nd, b at 1st and a at 0th index. \\n  b=c-1 , a=0\\n  (Keeping c at fixed index, we will be moving a and b in order to satisfy the condition a+b>c) .\\n3.while(a<b) \\n  check the nums[a] + nums[b] > nums[c] , \\n  if this exists then \\n    -for all the values after the nums[left],the condition nums[a] + nums[b] > nums[c] is going to satisfy, store (b-a) count in ans\\n    -decrement b\\n  else\\n    -increment a as we need to maximize sum so that it becoms greater than nums[c]\\n4.return ans\\n\\n\\n# Complexity\\n- Time complexity: O(N2)\\n- Space complexity:O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int triangleNumber(int[] nums) {\\n        int n=nums.length;\\n        Arrays.sort(nums);\\n        int count=0;\\n        for(int c=n-1;c>=2;c--){\\n            int a=0;\\n            int b=c-1;\\n            while(a<b){\\n                if(nums[a]+nums[b]>nums[c]){\\n                    count+=(b-a);\\n                    b--;\\n                }\\n                else{\\n                    a++;\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int triangleNumber(int[] nums) {\\n        int n=nums.length;\\n        Arrays.sort(nums);\\n        int count=0;\\n        for(int c=n-1;c>=2;c--){\\n            int a=0;\\n            int b=c-1;\\n            while(a<b){\\n                if(nums[a]+nums[b]>nums[c]){\\n                    count+=(b-a);\\n                    b--;\\n                }\\n                else{\\n                    a++;\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3675998,
                "title": "triangle-statement-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRecall the valid Triangle statement....!!!\\n\\n**sum of two Lower sides > sum of Maximum side**\\nto Apply this statement sort the given array, now it becomes easy to compute all the triplets.\\n\\n\\n\\n# Complexity\\n- Time complexity:O(N* N* log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& arr) {\\n\\n        int n = arr.size(),ans = 0;\\n        sort(arr.begin(),arr.end());\\n\\n        if(n<=2) return 0;\\n        if(n==3) return (arr[0]+arr[1]>arr[2]);\\n        int i = 0;\\n        \\n        while(!arr[i]) i++;\\n\\n        for(;i<n-2;i++)\\n        {\\n            for(int j = i+1;j<n-1;j++)\\n            {\\n               int sum = arr[i]+arr[j];\\n               int num = lower_bound(arr.begin(),arr.end(),sum)-arr.begin();\\n               ans+=(num-j-1);\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/8202ba30-409a-4520-8289-c6d8e5fb14e6_1687588943.976554.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& arr) {\\n\\n        int n = arr.size(),ans = 0;\\n        sort(arr.begin(),arr.end());\\n\\n        if(n<=2) return 0;\\n        if(n==3) return (arr[0]+arr[1]>arr[2]);\\n        int i = 0;\\n        \\n        while(!arr[i]) i++;\\n\\n        for(;i<n-2;i++)\\n        {\\n            for(int j = i+1;j<n-1;j++)\\n            {\\n               int sum = arr[i]+arr[j];\\n               int num = lower_bound(arr.begin(),arr.end(),sum)-arr.begin();\\n               ans+=(num-j-1);\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3614460,
                "title": "best-approaches-for-beginner-to-expert",
                "content": "# Intuition\\nWe have 3 solution to approach this problem\\n\\n# Approach\\n1. Bruteforce\\n2. Sorting the array\\n3. Two pointer\\n\\n# Complexity\\n- Time complexity:\\n1. Bruteforce: O(n^3)\\n2. Sorting the array: O(n^3)\\n3. Two pointer: O(n^2)\\n\\n# Code\\n```\\n1. Bruteforce\\nclass Solution{\\n    public int triangleNumber(int[] nums) {\\n                int n = nums.length;\\n                int count = 0;\\n\\n                for (int i = 0; i < n - 2; i++)\\n                    for (int j = i + 1; j < n - 1; j++)\\n                        for (int k = j + 1; k < n; k++)\\n                            if (nums[i] + nums[j] > nums[k] && nums[i] + nums[k] > nums[j] && nums[j] + nums[k] > nums[i])\\n                                count++;\\n\\n                return count;\\n        }\\n}\\n2. Sorting the array\\nclass Solution{\\n    public int triangleNumber(int[] nums) {\\n                Arrays.Sort(nums);\\n                int n = nums.length;\\n                int count = 0;\\n\\n                for (int i = 0; i < n - 2; i++)\\n                    for (int j = i + 1; j < n - 1; j++)\\n                        for (int k = j + 1; k < n; k++)\\n                            if (nums[i] + nums[j] > nums[k])\\n                                count++;\\n\\n                return count;\\n        }\\n}\\n3. Two pointer\\nclass Solution {\\n    public int triangleNumber(int[] nums) {\\n        int n = nums.length;\\n            int count = 0;\\n            Arrays.sort(nums);\\n            for (int i = n - 1; i >= 2; i--) {\\n                int j = 0, k = i - 1;\\n                while (j < k) {\\n                    if (nums[j] + nums[k] > nums[i]) {\\n                        count += k - j;\\n                        k--;\\n                    } else {\\n                        j++;\\n                    }\\n                }\\n            }\\n\\n            return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\n1. Bruteforce\\nclass Solution{\\n    public int triangleNumber(int[] nums) {\\n                int n = nums.length;\\n                int count = 0;\\n\\n                for (int i = 0; i < n - 2; i++)\\n                    for (int j = i + 1; j < n - 1; j++)\\n                        for (int k = j + 1; k < n; k++)\\n                            if (nums[i] + nums[j] > nums[k] && nums[i] + nums[k] > nums[j] && nums[j] + nums[k] > nums[i])\\n                                count++;\\n\\n                return count;\\n        }\\n}\\n2. Sorting the array\\nclass Solution{\\n    public int triangleNumber(int[] nums) {\\n                Arrays.Sort(nums);\\n                int n = nums.length;\\n                int count = 0;\\n\\n                for (int i = 0; i < n - 2; i++)\\n                    for (int j = i + 1; j < n - 1; j++)\\n                        for (int k = j + 1; k < n; k++)\\n                            if (nums[i] + nums[j] > nums[k])\\n                                count++;\\n\\n                return count;\\n        }\\n}\\n3. Two pointer\\nclass Solution {\\n    public int triangleNumber(int[] nums) {\\n        int n = nums.length;\\n            int count = 0;\\n            Arrays.sort(nums);\\n            for (int i = n - 1; i >= 2; i--) {\\n                int j = 0, k = i - 1;\\n                while (j < k) {\\n                    if (nums[j] + nums[k] > nums[i]) {\\n                        count += k - j;\\n                        k--;\\n                    } else {\\n                        j++;\\n                    }\\n                }\\n            }\\n\\n            return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547788,
                "title": "solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        // a+b>c and b+c>a and a+c>b\\n        int count =0;\\n        sort(nums.begin(),nums.end());\\n        \\n        for(int k = nums.size()-1; k>1; k--){\\n            int i=0; int j = k-1;\\n            while(i<j){\\n                if(nums[i]+nums[j]>nums[k]){\\n                    count+=j-i;\\n                    j--;\\n                }\\n                else{\\n                    i++;\\n                }\\n            }\\n        }\\n\\n        return count;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        // a+b>c and b+c>a and a+c>b\\n        int count =0;\\n        sort(nums.begin(),nums.end());\\n        \\n        for(int k = nums.size()-1; k>1; k--){\\n            int i=0; int j = k-1;\\n            while(i<j){\\n                if(nums[i]+nums[j]>nums[k]){\\n                    count+=j-i;\\n                    j--;\\n                }\\n                else{\\n                    i++;\\n                }\\n            }\\n        }\\n\\n        return count;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456252,
                "title": "valid-triangle-number-two-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n/*\\n basically for a triangle we should have sum of any two sides greater than 3rd side.\\n but if take a side from the end of array that is max ,\\n then we need to check only that the sum of first two sides is greater than max or not,\\n for other two pairs it will be correct only.\\n       arr[i]+arr[j]<arr[k]  conditon for answer,\\n       where k would be pointing to the maximum number only.\\n       and for all pairs betwen j and i it will be true as numbers in i and j are increasing order.\\n       so we take that count in consideration.\\n*/\\n\\n\\n\\nclass Solution\\n{\\npublic:\\n    int triangleNumber(vector<int> &nums)\\n    {\\n        vector<int> arr = nums;\\n        vector<vector<int>> ans;\\n        sort(arr.begin(), arr.end());\\n        // taking each element.\\n        // always shifting to the upper bound of the elements if they exists\\n        int n = nums.size();\\n        int count=0;\\n        for(int k=n-1;k>=2;k--) // k pointing to the largest element always\\n        {\\n            int i=0,j=k-1; // i will be start, and j will be just before k.\\n            while(i<j) // donot want to take the same element\\n            {\\n              if(arr[i]+arr[j]>arr[k])\\n              {\\n                  count+=(j-i);//taken all the elements less than j and greater or equal to i.\\n                  j--; // taken this, now taking it\\'s previous\\n              }\\n              else\\n              {\\n                i++;\\n              }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\n\\n/*\\n basically for a triangle we should have sum of any two sides greater than 3rd side.\\n but if take a side from the end of array that is max ,\\n then we need to check only that the sum of first two sides is greater than max or not,\\n for other two pairs it will be correct only.\\n       arr[i]+arr[j]<arr[k]  conditon for answer,\\n       where k would be pointing to the maximum number only.\\n       and for all pairs betwen j and i it will be true as numbers in i and j are increasing order.\\n       so we take that count in consideration.\\n*/\\n\\n\\n\\nclass Solution\\n{\\npublic:\\n    int triangleNumber(vector<int> &nums)\\n    {\\n        vector<int> arr = nums;\\n        vector<vector<int>> ans;\\n        sort(arr.begin(), arr.end());\\n        // taking each element.\\n        // always shifting to the upper bound of the elements if they exists\\n        int n = nums.size();\\n        int count=0;\\n        for(int k=n-1;k>=2;k--) // k pointing to the largest element always\\n        {\\n            int i=0,j=k-1; // i will be start, and j will be just before k.\\n            while(i<j) // donot want to take the same element\\n            {\\n              if(arr[i]+arr[j]>arr[k])\\n              {\\n                  count+=(j-i);//taken all the elements less than j and greater or equal to i.\\n                  j--; // taken this, now taking it\\'s previous\\n              }\\n              else\\n              {\\n                i++;\\n              }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3410968,
                "title": "solution",
                "content": "```C++ []\\ntypedef vector<int>::iterator vit;\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        if ( nums.size() < 3 ) return 0;\\n        vit b = nums.begin(), e = nums.end();\\n        sort(b, e);\\n        int res = 0;\\n        for ( vit k = b+2; k != e; ++k ){\\n            vit i = b, j = k-1;\\n            while ( i < j ){\\n                if ( *i + *j > *k ){\\n                    res += j - i;\\n                    --j;\\n                }\\n                else{\\n                    ++i;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        \\n        fgtoe = [-1] * (2000+1)\\n        j = 0\\n        for i in range(len(fgtoe)):\\n            while j < len(nums) and nums[j] < i:\\n                j += 1\\n            fgtoe[i] = j\\n        \\n        ctr = 0\\n        rs = len(nums) * (len(nums) - 1) // 2 - 1\\n        rss = 0\\n        for ai in range(0, len(nums)-2):\\n            nai = nums[ai]\\n            if nai != 0:\\n                ctr += sum(fgtoe[nai + nums[bi]] for bi in range(ai+1, len(nums)-1))\\n                rss += rs\\n            rs -= ai+2\\n        return ctr - rss\\n```\\n\\n```Java []\\nclass Solution {\\n    public int triangleNumber(int[] nums) {\\n        if (nums == null || nums.length <= 2) {\\n            return 0;\\n        }\\n        Arrays.sort(nums);\\n\\n        int[] indexMap = new int[2001];\\n        for (int i = 0; i < indexMap.length; ++i) {\\n            indexMap[i] = -1;\\n        }\\n        for (int i = 0; i < nums.length; ++i) {\\n            indexMap[nums[i]] = i;\\n        }\\n        for (int i = 1; i < indexMap.length; ++i) {\\n            if (indexMap[i] == -1) {\\n                indexMap[i] = indexMap[i - 1];\\n            }\\n        }\\n        int res = 0;\\n        for (int i = 0; i < nums.length; ++i) {\\n            for (int j = i + 1; j < nums.length; ++j) {\\n                if (nums[i] + nums[j] - 1 >= 0 && nums[i] + nums[j] - 1 <= 2000) {\\n                    res += Math.max(0, indexMap[nums[i] + nums[j] - 1] - j);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\ntypedef vector<int>::iterator vit;\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        if ( nums.size() < 3 ) return 0;\\n        vit b = nums.begin(), e = nums.end();\\n        sort(b, e);\\n        int res = 0;\\n        for ( vit k = b+2; k != e; ++k ){\\n            vit i = b, j = k-1;\\n            while ( i < j ){\\n                if ( *i + *j > *k ){\\n                    res += j - i;\\n                    --j;\\n                }\\n                else{\\n                    ++i;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        \\n        fgtoe = [-1] * (2000+1)\\n        j = 0\\n        for i in range(len(fgtoe)):\\n            while j < len(nums) and nums[j] < i:\\n                j += 1\\n            fgtoe[i] = j\\n        \\n        ctr = 0\\n        rs = len(nums) * (len(nums) - 1) // 2 - 1\\n        rss = 0\\n        for ai in range(0, len(nums)-2):\\n            nai = nums[ai]\\n            if nai != 0:\\n                ctr += sum(fgtoe[nai + nums[bi]] for bi in range(ai+1, len(nums)-1))\\n                rss += rs\\n            rs -= ai+2\\n        return ctr - rss\\n```\n```Java []\\nclass Solution {\\n    public int triangleNumber(int[] nums) {\\n        if (nums == null || nums.length <= 2) {\\n            return 0;\\n        }\\n        Arrays.sort(nums);\\n\\n        int[] indexMap = new int[2001];\\n        for (int i = 0; i < indexMap.length; ++i) {\\n            indexMap[i] = -1;\\n        }\\n        for (int i = 0; i < nums.length; ++i) {\\n            indexMap[nums[i]] = i;\\n        }\\n        for (int i = 1; i < indexMap.length; ++i) {\\n            if (indexMap[i] == -1) {\\n                indexMap[i] = indexMap[i - 1];\\n            }\\n        }\\n        int res = 0;\\n        for (int i = 0; i < nums.length; ++i) {\\n            for (int j = i + 1; j < nums.length; ++j) {\\n                if (nums[i] + nums[j] - 1 >= 0 && nums[i] + nums[j] - 1 <= 2000) {\\n                    res += Math.max(0, indexMap[nums[i] + nums[j] - 1] - j);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3068017,
                "title": "simple-and-short-java-code-very-fast",
                "content": "# Complexity\\n- Time complexity:$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int triangleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int res = 0, n = nums.length, i, j, k;\\n        for(i = 0; i<n ; i++) {\\n            for(j = i+1, k = j+1; j<(n - 1) && k<=n;) {\\n                if(k == n || nums[i]+nums[j] <= nums[k]){\\n                    if(k > (j+1))\\n                        res += k - j - 1;\\n                    j++;\\n                }else k++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int triangleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int res = 0, n = nums.length, i, j, k;\\n        for(i = 0; i<n ; i++) {\\n            for(j = i+1, k = j+1; j<(n - 1) && k<=n;) {\\n                if(k == n || nums[i]+nums[j] <= nums[k]){\\n                    if(k > (j+1))\\n                        res += k - j - 1;\\n                    j++;\\n                }else k++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2703671,
                "title": "c-o-n-2-using-3-sum-optimal",
                "content": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& arr) {\\n        sort(arr.begin(), arr.end());\\n        int ans = 0;\\n        for(int i = arr.size()-1;i>=2;i--){\\n            int j = 0, k = i-1;\\n            while(j<k){\\n                if(arr[j] + arr[k] > arr[i]){\\n                    ans += k-j;\\n                    k--;\\n                }\\n                else j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n/* If you like the soluiton please upvote */\\n```\\n\\nIf you like the soluiton please upvote",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& arr) {\\n        sort(arr.begin(), arr.end());\\n        int ans = 0;\\n        for(int i = arr.size()-1;i>=2;i--){\\n            int j = 0, k = i-1;\\n            while(j<k){\\n                if(arr[j] + arr[k] > arr[i]){\\n                    ans += k-j;\\n                    k--;\\n                }\\n                else j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n/* If you like the soluiton please upvote */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666546,
                "title": "c-solution-using-binary-search-and-linear-scan-with-explanation",
                "content": "**Approach 1:**\\n# Intuition\\nWe can\\'t run brute force, or else we get TLE error\\n\\n# Approach\\nFirst sort the array, so that we can be sure that any number ahead of current number is greater than or equal to current. So if we run two loop for i and j and have a sum = nums[i]+nums[j], we can be sure that if we find nums[k]>nums[i]+nums[j], all the elements to the right to k will never be an answer as k in itself is not an answer. The gist is that we need to find an element in the array that is JUST greater than or equal to nums[i]+nums[j]. In tha case all the elements from j+1 to k-1 will be the satisfying answers for the pair (i, j). So we find the JUST greater element with binary search.\\nThe insides of binary search are explained as follows: if nums[mid]>=sum, obviously that\\'s not one of the valid k for which nums[k]<nums[i]+nums[j] so do r = mid-1, remember we return l. If nums[mid]<sum, do l = mid+1 as we need to find JUST greater element. If it is indeed just greater element, if there are any further while iterations, they will do r = mid-1 so as to terminate when r<l. Atlast return l.\\nNow that we found JUST greater element, do k-1-j = number of satisfying elements. Notice that there is additional nums[i]!=0 condition. Not only it optimises, but is also required for correctness of algorithm for the following reasons:\\nOptimisation: if nums[i]=0, than we will have nums[k]>=nums[j], in which case, triangle equality does NOT hold\\nCorrectness: if we let nums[i]=0 pass, than k and j might be equal after running binary search, in which case we are subtracting -1 from ans. \\nTake this case - [0, 0, 0, 7].\\n\\n# Complexity\\n- Time complexity:\\nO(N^2 * logN)\\n\\n- Space complexity:\\nO(logN) -> C++ sorting algo is (mostly) quicksort whose space complexity is logN\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binarySearch(vector<int> &nums, int l, int r, int sum)\\n    {\\n        while(r>=l && r<nums.size())\\n        {\\n            int mid = (r-l)/2+l;\\n            if(nums[mid]>=sum)\\n                r = mid-1;\\n            else\\n                l = mid+1;\\n        }\\n        return l;\\n    }\\n    int triangleNumber(vector<int>& nums) {\\n        int ans = 0;\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        for(int i=0; i<n-2; i++)\\n        {\\n            int k = i+2;\\n            for(int j=i+1; j<n-1 && nums[i]!=0; j++)\\n            {\\n                k = binarySearch(nums, k, n-1, nums[i]+nums[j]);\\n                ans+=k-j-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Approach 2:**\\nThere is another approach that felt like a O(N^3) at first, but is faster.\\nHow? Thing is, by previous logic that if we have found a JUST greater element nums[k] for the pair i and j, for j+1, k will be same or greater hence, we can start search for current k from former k directly. Using the same logic, just scan linearly, until we find a just greater element. Now why is complexity O(N^2), Because notice that while loop for k will run only once until N while the for loop for j is running. So complexity becomes more like O(N * (N + N)) = O(2* N^2) = O(N^2).\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nO(logN)\\n```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        int ans = 0;\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        for(int i=0; i<n-2; i++)\\n        {\\n            int k = i+2;\\n            for(int j=i+1; j<n-1 && nums[i]!=0; j++)\\n            {\\n                while(k<n && nums[k]<nums[i]+nums[j])\\n                    k++;\\n                ans+=k-1-j;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binarySearch(vector<int> &nums, int l, int r, int sum)\\n    {\\n        while(r>=l && r<nums.size())\\n        {\\n            int mid = (r-l)/2+l;\\n            if(nums[mid]>=sum)\\n                r = mid-1;\\n            else\\n                l = mid+1;\\n        }\\n        return l;\\n    }\\n    int triangleNumber(vector<int>& nums) {\\n        int ans = 0;\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        for(int i=0; i<n-2; i++)\\n        {\\n            int k = i+2;\\n            for(int j=i+1; j<n-1 && nums[i]!=0; j++)\\n            {\\n                k = binarySearch(nums, k, n-1, nums[i]+nums[j]);\\n                ans+=k-j-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        int ans = 0;\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        for(int i=0; i<n-2; i++)\\n        {\\n            int k = i+2;\\n            for(int j=i+1; j<n-1 && nums[i]!=0; j++)\\n            {\\n                while(k<n && nums[k]<nums[i]+nums[j])\\n                    k++;\\n                ans+=k-1-j;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2575771,
                "title": "c-easy-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int bsearch(vector<int>& nums,int i,int j,int val,int ans){\\n        if(i>j) return ans;\\n        int m=(i+j)/2;\\n        if(nums[m]==val) return bsearch(nums,i,m-1,val,m);\\n        else if(nums[m]<val) return bsearch(nums,m+1,j,val,ans);\\n        else return bsearch(nums,i,m-1,val,m);\\n    }\\n    int triangleNumber(vector<int>& nums) {\\n        if(nums.size()<=2) return 0;\\n        sort(nums.begin(),nums.end());\\n        int count=0;\\n        for(int i=0;i<nums.size()-2;i++){\\n            int sum=nums[i];\\n            for(int j=i+1;j<nums.size()-1;j++){\\n                int u=bsearch(nums,j+1,nums.size()-1,sum+nums[j],-1);\\n                if(u!=-1) count+=(u-1-j);\\n                else count+=(nums.size()-1-j);\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bsearch(vector<int>& nums,int i,int j,int val,int ans){\\n        if(i>j) return ans;\\n        int m=(i+j)/2;\\n        if(nums[m]==val) return bsearch(nums,i,m-1,val,m);\\n        else if(nums[m]<val) return bsearch(nums,m+1,j,val,ans);\\n        else return bsearch(nums,i,m-1,val,m);\\n    }\\n    int triangleNumber(vector<int>& nums) {\\n        if(nums.size()<=2) return 0;\\n        sort(nums.begin(),nums.end());\\n        int count=0;\\n        for(int i=0;i<nums.size()-2;i++){\\n            int sum=nums[i];\\n            for(int j=i+1;j<nums.size()-1;j++){\\n                int u=bsearch(nums,j+1,nums.size()-1,sum+nums[j],-1);\\n                if(u!=-1) count+=(u-1-j);\\n                else count+=(nums.size()-1-j);\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2566597,
                "title": "c-using-linear-search",
                "content": "class Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        \\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        int count = 0;\\n        \\n        for(int i = 0; i<n-2; i++){\\n            int k = i + 2;\\n            for(int j = i+1; j<n-1 && nums[i] != 0; j++){\\n                while(k<n && nums[i] + nums[j] > nums[k])\\n                    k++;\\n                count += k-j-1;\\n            }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        \\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        int count = 0;\\n        \\n        for(int i = 0; i<n-2; i++){\\n            int k = i + 2;\\n            for(int j = i+1; j<n-1 && nums[i] != 0; j++){\\n                while(k<n && nums[i] + nums[j] > nums[k])\\n                    k++;\\n                count += k-j-1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2552930,
                "title": "c-two-solutions-lower-bound-linear-scan-o-n-2-logn-o-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n    //triange condition: sum of smaller side > longet side\\n    //(s1+s2)>s3\\n    //we have to find s3 < s1+s2\\n    //O(N^2*logN)\\n    int triangleNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        int count =  0;\\n        //traversing every two pairs for shortest sides\\n        for(int i = 0;i<n-2;i++){\\n            for(int j = i+1;j<n-1;j++){\\n                //finding no of element < sum of shortest sides\\n                int it = (lower_bound(nums.begin()+j+1,nums.end(),nums[i]+nums[j])) - (nums.begin()+j+1);\\n                count += it;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n\\t------------------------------------------------------------------------------------------------------------------\\n\\t\\n    //Optimized O(N^2) linear scan for longest side first\\n    //finding smaller sides\\n    int triangleNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int count = 0;\\n        for ( int k = n - 1; k > 1; --k ) {\\n            int i = 0, j = k - 1;\\n            while ( i < j ) {\\n                \\n                if ( nums[i] + nums[j] > nums[k] ){\\n                    count += j - i;\\n                    --j;\\n                }\\n                else{\\n                    ++i;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //triange condition: sum of smaller side > longet side\\n    //(s1+s2)>s3\\n    //we have to find s3 < s1+s2\\n    //O(N^2*logN)\\n    int triangleNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        int count =  0;\\n        //traversing every two pairs for shortest sides\\n        for(int i = 0;i<n-2;i++){\\n            for(int j = i+1;j<n-1;j++){\\n                //finding no of element < sum of shortest sides\\n                int it = (lower_bound(nums.begin()+j+1,nums.end(),nums[i]+nums[j])) - (nums.begin()+j+1);\\n                count += it;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n\\t------------------------------------------------------------------------------------------------------------------\\n\\t\\n    //Optimized O(N^2) linear scan for longest side first\\n    //finding smaller sides\\n    int triangleNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int count = 0;\\n        for ( int k = n - 1; k > 1; --k ) {\\n            int i = 0, j = k - 1;\\n            while ( i < j ) {\\n                \\n                if ( nums[i] + nums[j] > nums[k] ){\\n                    count += j - i;\\n                    --j;\\n                }\\n                else{\\n                    ++i;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2503572,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        nums=sorted(nums)\\n        c=0\\n        for i in range(len(nums)-1,-1,-1):\\n            j,k=0,i-1\\n            while j<k:\\n                if nums[j]+nums[k]>nums[i]:\\n                    c+=k-j\\n                    k-=1\\n                else:\\n                     j+=1\\n        return c\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        nums=sorted(nums)\\n        c=0\\n        for i in range(len(nums)-1,-1,-1):\\n            j,k=0,i-1\\n            while j<k:\\n                if nums[j]+nums[k]>nums[i]:\\n                    c+=k-j\\n                    k-=1\\n                else:\\n                     j+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2494364,
                "title": "c-easy-solution",
                "content": "\\t\\tint count=0, n=nums.size();;\\n        sort(nums.begin(),nums.end());\\n        if(n<3) return 0;\\n        for(int i=n-1;i>=2;i--){\\n            int j=0, k=i-1;\\n            while(j<k){\\n                if(nums[j]+nums[k]>nums[i]){\\n                    count+=k-j;\\n                    k--;\\n                }\\n                else j++;\\n            }\\n        }\\n        return count;",
                "solutionTags": [],
                "code": "\\t\\tint count=0, n=nums.size();;\\n        sort(nums.begin(),nums.end());\\n        if(n<3) return 0;\\n        for(int i=n-1;i>=2;i--){\\n            int j=0, k=i-1;\\n            while(j<k){\\n                if(nums[j]+nums[k]>nums[i]){\\n                    count+=k-j;\\n                    k--;\\n                }\\n                else j++;\\n            }\\n        }\\n        return count;",
                "codeTag": "Unknown"
            },
            {
                "id": 2422892,
                "title": "java-easy-two-pointer-solution-o-n-2",
                "content": "```\\nclass Solution {\\n    public int triangleNumber(int[] a) {\\n        int n = a.length;\\n        int cnt = 0;\\n        Arrays.sort(a);\\n        for(int k = n - 1; k >= 0; k--){\\n            int i = 0;\\n            int j = k - 1;\\n            while(i < j){\\n                if(a[i] + a[j] > a[k]){\\n                    cnt += j - i;\\n                    j--;\\n                }\\n                else {\\n                    i++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public int triangleNumber(int[] a) {\\n        int n = a.length;\\n        int cnt = 0;\\n        Arrays.sort(a);\\n        for(int k = n - 1; k >= 0; k--){\\n            int i = 0;\\n            int j = k - 1;\\n            while(i < j){\\n                if(a[i] + a[j] > a[k]){\\n                    cnt += j - i;\\n                    j--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2411023,
                "title": "c-binary-search",
                "content": "# If you think this post is useful, then please Upvote it!!\\n```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        int cnt = 0;\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i=2;i<n;i++)\\n        {\\n            int l = 0;\\n            int h = i-1;\\n            while(l<h)\\n            {\\n                if(nums[l]+nums[h] > nums[i])\\n                {\\n                    cnt += (h-l);\\n                    h--;\\n                }\\n                else\\n                {\\n                    l++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        int cnt = 0;\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i=2;i<n;i++)\\n        {\\n            int l = 0;\\n            int h = i-1;\\n            while(l<h)\\n            {\\n                if(nums[l]+nums[h] > nums[i])\\n                {\\n                    cnt += (h-l);\\n                    h--;\\n                }\\n                else\\n                {\\n                    l++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2382242,
                "title": "c-binary-search-o-n-2-x-logn-detailed-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        //if size is 1 or 2 then we cant make triangle\\n        if(n==1 || n==2) return 0;\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=0;i<n-2;i++){\\n           for(int j=i+2;j<n;j++){\\n               // taking the smallest and the largest side\\n               // then by binary search checking the number which is greater than the\\n               // difference of smallest and greatest\\n               // as we need small+med > greatest =>  med>greatest-smallest\\n               // numbers after that will also be larger as we have sorted the array\\n               int x = nums[j]-nums[i];\\n               int k=0;\\n               int s = i+1, e=j-1;\\n               while(s<=e){\\n                   int m = (s+e)/2;\\n                   if(nums[m]>x){\\n                      k = (j-m);\\n                       e=m-1;\\n                   }else{\\n                       s=m+1;\\n                   }\\n               }\\n               ans+=k;\\n           } \\n        }\\n        return ans;\\n\\t\\t//Please Upvote if you like the solution\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        //if size is 1 or 2 then we cant make triangle\\n        if(n==1 || n==2) return 0;\\n        sort(nums.begin(),nums.end());\\n        int ans=0;\\n        for(int i=0;i<n-2;i++){\\n           for(int j=i+2;j<n;j++){\\n               // taking the smallest and the largest side\\n               // then by binary search checking the number which is greater than the\\n               // difference of smallest and greatest\\n               // as we need small+med > greatest =>  med>greatest-smallest\\n               // numbers after that will also be larger as we have sorted the array\\n               int x = nums[j]-nums[i];\\n               int k=0;\\n               int s = i+1, e=j-1;\\n               while(s<=e){\\n                   int m = (s+e)/2;\\n                   if(nums[m]>x){\\n                      k = (j-m);\\n                       e=m-1;\\n                   }else{\\n                       s=m+1;\\n                   }\\n               }\\n               ans+=k;\\n           } \\n        }\\n        return ans;\\n\\t\\t//Please Upvote if you like the solution\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2203786,
                "title": "binary-search-solution-c-o-n-2logn-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int findIdx(int lo, int hi, int target, vector<int> &nums){\\n        while(lo <= hi){\\n            int mid = (lo + hi) / 2;\\n            \\n            if(nums[mid] >= target){\\n                hi = mid - 1;\\n            }\\n            else{\\n                lo = mid + 1;\\n            }\\n        }\\n        \\n        return hi;\\n    }\\n    \\n    int triangleNumber(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        \\n        int n = nums.size();\\n        \\n        // 3 sides of triangle are valid if a + b > c\\n        // We can select a & b using 2 for loops\\n        // To check the third side, we first sort the given array\\n        // Since c > a && c > b, we definitely know that c will lie beyond b\\'s index\\n        // So, we search for c such that it is the largest value less than (a + b) and return its index\\n        // From the b\\'s index upto this index will be the choices we can have for our side\\n        \\n        int ans = 0;\\n        for(int i = 0; i < n; i++){\\n            for(int j = i + 1; j < n; j++){\\n                int idx = findIdx(j + 1, n - 1, nums[i] + nums[j], nums);\\n                \\n                int k = idx - j;\\n                ans += k;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int findIdx(int lo, int hi, int target, vector<int> &nums){\\n        while(lo <= hi){\\n            int mid = (lo + hi) / 2;\\n            \\n            if(nums[mid] >= target){\\n                hi = mid - 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2188063,
                "title": "c-binary-search-approach",
                "content": "# Observation\\nWhen a <= b <= c\\nif a+b > c, then \\n(1) a+c > b\\n(2) b+c > a\\nSo, we just need to find a<=b, and search maximum c s.t. a+b>c for all valid triplet. \\n# Solution\\n```C++\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n\\t\\n        vector<int> &a = nums;\\n        int n = a.size();\\n        sort(a.begin(), a.end());\\n        int ans = 0;\\n        for(int i =0;i<n;i++) {\\n            for(int j = i+1;j<n;j++) {\\n                int t = a[i]+a[j];//t = a+b\\n                int L = j, R = n-1;\\n                //find maximum c=a[M] s.t. t=a+b and  a[M] < t <=a [M+1] by binary search\\n                while(L<=R) { \\n                    int M = L+(R-L)/2;\\n                    if( (M==j||t>a[M]) &&  (M+1>=n||t<=a[M+1])) {\\n                        ans+=M-j;\\n                        break;\\n                    }  \\n                    if( (M==j||t>a[M]) ) L=M+1; else R=M-1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n\\t\\n        vector<int> &a = nums;\\n        int n = a.size();\\n        sort(a.begin(), a.end());\\n        int ans = 0;\\n        for(int i =0;i<n;i++) {\\n            for(int j = i+1;j<n;j++) {\\n                int t = a[i]+a[j];//t = a+b\\n                int L = j, R = n-1;\\n                //find maximum c=a[M] s.t. t=a+b and  a[M] < t <=a [M+1] by binary search\\n                while(L<=R) { \\n                    int M = L+(R-L)/2;\\n                    if( (M==j||t>a[M]) &&  (M+1>=n||t<=a[M+1])) {\\n                        ans+=M-j;\\n                        break;\\n                    }  \\n                    if( (M==j||t>a[M]) ) L=M+1; else R=M-1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2162346,
                "title": "easy-well-commented-solution-c-implementation",
                "content": "```\\nclass Solution {\\npublic://condition of valid trianle sum of any two sides always greater than the third\\n    int triangleNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int c=0;\\n        int ans=0;\\n        for(int i=nums.size()-1;i>=0;i--)//fixing the largest side of the triangle\\n        {\\n            int l1=0,l2=i-1;//l1 is the smallest side in the beginning and l2 is the largest side just smaller than i\\n            while(l1<l2)\\n            {\\n                if(nums[l1]+nums[l2]>nums[i])\\n                {\\n                    ans+=(l2-l1);//if l1 and l2 are valid than any combination of the numbers between them will be valid\\n                    l2--;\\n                }\\n                else \\n                    l1++;//if its not the case that it is valid then lets increase the smallest side\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic://condition of valid trianle sum of any two sides always greater than the third\\n    int triangleNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int c=0;\\n        int ans=0;\\n        for(int i=nums.size()-1;i>=0;i--)//fixing the largest side of the triangle\\n        {\\n            int l1=0,l2=i-1;//l1 is the smallest side in the beginning and l2 is the largest side just smaller than i\\n            while(l1<l2)\\n            {\\n                if(nums[l1]+nums[l2]>nums[i])\\n                {\\n                    ans+=(l2-l1);//if l1 and l2 are valid than any combination of the numbers between them will be valid\\n                    l2--;\\n                }\\n                else \\n                    l1++;//if its not the case that it is valid then lets increase the smallest side\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2159417,
                "title": "611-valid-triangle-number-simple-solution-using-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        int count=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=nums.size()-1;i>=1;i--){\\n            int l=0,r=i-1;\\n            while(l<r)\\n            {\\n                if(nums[l]+nums[r]>nums[i]){\\n                    count+=r-l;\\n                    r--;\\n                }\\n                else\\n                {\\n                    l++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        int count=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=nums.size()-1;i>=1;i--){\\n            int l=0,r=i-1;\\n            while(l<r)\\n            {\\n                if(nums[l]+nums[r]>nums[i]){\\n                    count+=r-l;\\n                    r--;\\n                }\\n                else\\n                {\\n                    l++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2152304,
                "title": "simple-intuition-explained-binary-search-approach-easy-to-understand",
                "content": "**Approach** :\\nApproach is similar to any basic search questions on leetcode where you want to find value in array without traversing(in our case third valid side call it \\'c\\').\\nSo there are 2 ways to do this\\n1) Hashmap get required value in O(1)\\n2) Binary search O(log n)\\n\\nCase 1 doesnot work for us as we dont want exact sum but elements less than certain threshold(a+b).\\nSo to conclude for every side a we need to find b,c such that it forms valid triangle thats where 2 pointer comes into picture.\\n\\n**Code** :\\n```\\nint triangleNumber(vector<int>& nums) {\\n        int n=size(nums),count=0;\\n        sort(nums.begin(), nums.end());\\n        \\n        //basically we will be finding valid pair for ith value\\n        for(int i=2;i<n;i++){\\n            int left=0,right=i-1;\\n            while(left < right){\\n                if(nums[left]+nums[right] > nums[i]){\\n                    count += right-left;\\n                    right--; // imp to note check explanation\\n                }\\n                else{\\n                    left++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```\\n\\nQuestions you might get after seeing it.\\n1) why sort?\\n simple because we will be applying bin search({x,x1,x2...} where x1<=x2)\\n \\n2) what is left,right,i and why they are initialised the way they are.\\n-> Before you go to left right lets see significance of \\'i\\'. So basically as typical search ques has one variable and requires you to search other but as triangle requires three we tend to fix i as first value and find other two.\\n->coming back to left & right think like this for any window left --> right is all valid set of valuesfor i.\\nhow come?\\nlets take one eg : [2,3,4,5,6]\\nith element be  - 6 \\nleft th - 2\\nright th - 5\\nso all elements left to right index are valid thats why we add (right-left) for valid window. (This is very common approach especially if you have solved sliding window problems). \\n->As element at i is max of three need not check sum for other pairs(remember array is sorted).\\n-> i =2 because minimum sides is 3, right has max possible value at i-1 and for all left starts with 0.\\n\\n3) why left++?\\n-> for [1,2,3,4] with i pointing to 4, right pointing to 3 a+b ie 1+3 is not more than 4 so inorder to increase a+b we have to increase the left pointer.\\n\\n4) why right--?\\n-> If you have understood above points one thing might pop your head is why right--; even after counting for other indices. Well thats tricky and you will get it try dryrun for [2,3,4,4] with i=3,right=2,left =1.\\n",
                "solutionTags": [
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nint triangleNumber(vector<int>& nums) {\\n        int n=size(nums),count=0;\\n        sort(nums.begin(), nums.end());\\n        \\n        //basically we will be finding valid pair for ith value\\n        for(int i=2;i<n;i++){\\n            int left=0,right=i-1;\\n            while(left < right){\\n                if(nums[left]+nums[right] > nums[i]){\\n                    count += right-left;\\n                    right--; // imp to note check explanation\\n                }\\n                else{\\n                    left++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2111303,
                "title": "c-very-easy-tc-o-n2log-n-4-line-of-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n-1;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                int it=lower_bound(nums.begin(),nums.end(),nums[i]+nums[j])-nums.begin();\\n                if(it>j)\\n                {\\n                    ans+=(it-1-j);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n-1;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                int it=lower_bound(nums.begin(),nums.end(),nums[i]+nums[j])-nums.begin();\\n                if(it>j)\\n                {\\n                    ans+=(it-1-j);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2080996,
                "title": "c-very-simple-soln-tc-o-n-2-logn-sc-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        int ans = 0;\\n        sort(nums.begin(),nums.end());\\n        for(int center = 1 ; center <= nums.size()-1 ; ++center){\\n            for(int left = 0 ; left < center ; left++){\\n                int sum = nums[center] + nums[left];\\n                int low = lower_bound(nums.begin()+center+1,nums.end(),sum) - nums.begin();\\n                ans += (low-1-center);   \\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        int ans = 0;\\n        sort(nums.begin(),nums.end());\\n        for(int center = 1 ; center <= nums.size()-1 ; ++center){\\n            for(int left = 0 ; left < center ; left++){\\n                int sum = nums[center] + nums[left];\\n                int low = lower_bound(nums.begin()+center+1,nums.end(),sum) - nums.begin();\\n                ans += (low-1-center);   \\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1999087,
                "title": "java-beats-50-easy-brute-force-approach",
                "content": "```\\nclass Solution {\\n    public int triangleNumber(int[] nums) {\\n        int count = 0;\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        for(int i=0 ; i<n-2 ; i++){\\n            int k = i+2;\\n            for(int j=i+1 ; j<n-1 && nums[i]!=0 ; j++){\\n                while(k<nums.length && nums[i]+nums[j]>nums[k]){\\n                    k++;\\n                }\\n                count+=k-j-1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int triangleNumber(int[] nums) {\\n        int count = 0;\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        for(int i=0 ; i<n-2 ; i++){\\n            int k = i+2;\\n            for(int j=i+1 ; j<n-1 && nums[i]!=0 ; j++){\\n                while(k<nums.length && nums[i]+nums[j]>nums[k]){\\n                    k++;\\n                }\\n                count+=k-j-1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980297,
                "title": "c-two-pointers",
                "content": "```\\nint triangleNumber(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        int ctr=0;\\n        sort(nums.begin(), nums.end());\\n        \\n        for(int i=n-1; i>=0; i--)\\n        {\\n            int j=0, k=i-1;\\n            while(j<k)\\n            {\\n                if(nums[j]+nums[k]>nums[i])\\n                {\\n                    ctr+=k-j;\\n                    k--;\\n                }\\n                else\\n                    j++;\\n            }\\n        }\\n        return ctr;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nint triangleNumber(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        int ctr=0;\\n        sort(nums.begin(), nums.end());\\n        \\n        for(int i=n-1; i>=0; i--)\\n        {\\n            int j=0, k=i-1;\\n            while(j<k)\\n            {\\n                if(nums[j]+nums[k]>nums[i])\\n                {\\n                    ctr+=k-j;\\n                    k--;\\n                }\\n                else\\n                    j++;\\n            }\\n        }\\n        return ctr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1973165,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "\\n    class Solution {\\n\\n    public int triangleNumber(int[] nums) {\\n        \\n    Arrays.sort(nums);\\n    int res = 0;\\n        \\n    for (int i = 0; i < nums.length - 2; i++) {\\n      for (int j = i + 1; j < nums.length - 1; j++) {\\n        int sum = nums[i] + nums[j];\\n        int left = j + 1, right = nums.length - 1;\\n          \\n        // find the largest element smaller than sum;\\n        while (left < right - 1) {\\n          int mid = left + (right - left) / 2;\\n          if (nums[mid] >= sum) right = mid - 1;\\n          else left = mid;\\n        }\\n          \\n        // post-processing: determine left or right is the largest element smaller than sum\\n        // or both left & right are not.\\n        if (nums[right] < sum) {\\n          res += (right - j);\\n        } else if (nums[left] < sum) {\\n          res += (left - j);\\n        }\\n      }\\n    }\\n    return res;\\n    }\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int triangleNumber(int[] nums) {\\n        \\n    Arrays.sort(nums);\\n    int res = 0;\\n        \\n    for (int i = 0; i < nums.length - 2; i++) {\\n      for (int j = i + 1; j < nums.length - 1; j++) {\\n        int sum = nums[i] + nums[j];\\n        int left = j + 1, right = nums.length - 1;\\n          \\n        // find the largest element smaller than sum;\\n        while (left < right - 1) {\\n          int mid = left + (right - left) / 2;\\n          if (nums[mid] >= sum) right = mid - 1;\\n          else left = mid;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1935616,
                "title": "simple-java-solution",
                "content": "Solution - 1 (Brute force)\\n```\\nclass Solution {\\n    public int triangleNumber(int[] a) {\\n        Arrays.sort(a);\\n        int c=0,k=a.length;\\n        for(int i=k-1;i>=2;i--)\\n        {\\n            for(int j=i-1;j>=1;j--)\\n            {\\n                for(int p=j-1;p>=0;p--)\\n                {\\n                    if(a[j]+a[p]>a[i])\\n                    {\\n                        c++;\\n                    }\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```\\n\\nSolution - 2 (Two pointer)\\n```\\nclass Solution {\\n    public int triangleNumber(int[] n) {\\n        Arrays.sort(n);\\n        int k=n.length,s=0;\\n        for(int i=k-1;i>=2;i--)\\n        {\\n            int j=0,p=i-1;\\n            while(j<p)\\n            {\\n                if(n[j]+n[p]>n[i])\\n                {\\n                    s+=(p-j);\\n                    p--;\\n                }\\n                else\\n                    j++;\\n            }\\n        }\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int triangleNumber(int[] a) {\\n        Arrays.sort(a);\\n        int c=0,k=a.length;\\n        for(int i=k-1;i>=2;i--)\\n        {\\n            for(int j=i-1;j>=1;j--)\\n            {\\n                for(int p=j-1;p>=0;p--)\\n                {\\n                    if(a[j]+a[p]>a[i])\\n                    {\\n                        c++;\\n                    }\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int triangleNumber(int[] n) {\\n        Arrays.sort(n);\\n        int k=n.length,s=0;\\n        for(int i=k-1;i>=2;i--)\\n        {\\n            int j=0,p=i-1;\\n            while(j<p)\\n            {\\n                if(n[j]+n[p]>n[i])\\n                {\\n                    s+=(p-j);\\n                    p--;\\n                }\\n                else\\n                    j++;\\n            }\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826811,
                "title": "python-solution-with-bisect-module",
                "content": "```\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        total = 0\\n        for i in range(len(nums)):\\n            for j in range(i+1, len(nums)-1):\\n                two_sum = nums[i] + nums[j]\\n                third = bisect.bisect_left(nums, two_sum, j+1)                    \\n                if third - j - 1 > 0:\\n                    total += third - j - 1\\n\\n        return total",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        total = 0\\n        for i in range(len(nums)):\\n            for j in range(i+1, len(nums)-1):\\n                two_sum = nums[i] + nums[j]\\n                third = bisect.bisect_left(nums, two_sum, j+1)                    \\n                if third - j - 1 > 0:\\n                    total += third - j - 1\\n\\n        return total",
                "codeTag": "Java"
            },
            {
                "id": 1647154,
                "title": "python-easy-solution-two-pointer-approach",
                "content": "\\t# Two Pointer Approach\\n\\t# Time: O(n^2*logn)\\n\\tclass Solution:\\n\\t\\tdef triangleNumber(self, nums: List[int]) -> int:\\n\\t\\t\\tres = 0\\n\\t\\t\\tnums.sort # O(nlogn)\\n\\t\\t\\t# Loop till (n-2) elements, coz we need to fix one number every time and deal with the other two!\\n\\t\\t\\t# O(n^2)\\n\\t\\t\\tfor i in range(len(nums)-1, 1, -1): \\n\\t\\t\\t\\tfix = nums[i] # Fix a number\\n\\t\\t\\t\\tstrt = 0\\n\\t\\t\\t\\tend = i-1\\n\\t\\t\\t\\t# Deal with the other two numbers every time!\\n\\t\\t\\t\\twhile strt < end:\\n\\t\\t\\t\\t\\tif nums[strt]+nums[end] > fix:\\n\\t\\t\\t\\t\\t\\tres += end-strt\\n\\t\\t\\t\\t\\t\\tend -= 1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tstrt += 1\\n\\t\\t\\treturn res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "\\t# Two Pointer Approach\\n\\t# Time: O(n^2*logn)\\n\\tclass Solution:\\n\\t\\tdef triangleNumber(self, nums: List[int]) -> int:\\n\\t\\t\\tres = 0\\n\\t\\t\\tnums.sort # O(nlogn)\\n\\t\\t\\t# Loop till (n-2) elements, coz we need to fix one number every time and deal with the other two!\\n\\t\\t\\t# O(n^2)\\n\\t\\t\\tfor i in range(len(nums)-1, 1, -1): \\n\\t\\t\\t\\tfix = nums[i] # Fix a number\\n\\t\\t\\t\\tstrt = 0\\n\\t\\t\\t\\tend = i-1\\n\\t\\t\\t\\t# Deal with the other two numbers every time!\\n\\t\\t\\t\\twhile strt < end:\\n\\t\\t\\t\\t\\tif nums[strt]+nums[end] > fix:\\n\\t\\t\\t\\t\\t\\tres += end-strt\\n\\t\\t\\t\\t\\t\\tend -= 1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tstrt += 1\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 1625937,
                "title": "c-o-n-log-n-n-2",
                "content": "```\\npublic class Solution {\\n    public int TriangleNumber(int[] nums) {\\n        \\n        int result = 0;\\n        Array.Sort(nums);\\n        \\n        for (int k = 2; k < nums.Length; k++)\\n        {\\n            int i = 0;\\n            int j = k - 1;\\n            while (i < j)\\n            {\\n                if (nums[i] + nums[j] > nums[k])\\n                {\\n                    result += (j - i);\\n                    j -= 1;\\n                }\\n                else\\n                {\\n                    i += 1;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int TriangleNumber(int[] nums) {\\n        \\n        int result = 0;\\n        Array.Sort(nums);\\n        \\n        for (int k = 2; k < nums.Length; k++)\\n        {\\n            int i = 0;\\n            int j = k - 1;\\n            while (i < j)\\n            {\\n                if (nums[i] + nums[j] > nums[k])\\n                {\\n                    result += (j - i);\\n                    j -= 1;\\n                }\\n                else\\n                {\\n                    i += 1;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513804,
                "title": "python-solution-o-n-2-time",
                "content": "```\\n\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        if nums is None or len(nums) < 3:\\n            return 0\\n        nums.sort()\\n        count = 0\\n        # assume a <= b <= c \\n        # The sum of any two sides must be greater than the other side\\n        # So if we can proof the sum of two shorter sides is greater than the long side, then we can gurantee a triangle\\n        # a + b > c is a sufficient and necessary condition to make a triangle  \\n        for c in range(len(nums)):\\n            a, b = 0, c - 1\\n            while a < b:\\n                two_sum = nums[a] + nums[b]\\n                if two_sum > nums[c]:               # Eg. 1\\uFF0C2\\uFF0C3\\uFF0C5\\uFF0C7\\uFF0C9   \\n                    count += b - a                  #     ^            ^  if c = 10, 1 + 9 <= c then 1 + any <= c so we skip 1 => a++\\n                                                    # if c = 9, 1 + 9 > c then 9 + any > c so we add count and skip 9 => b-- \\n                    b -= 1\\n                else:\\n                    a += 1\\n        return count       \\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        if nums is None or len(nums) < 3:\\n            return 0\\n        nums.sort()\\n        count = 0\\n        # assume a <= b <= c \\n        # The sum of any two sides must be greater than the other side\\n        # So if we can proof the sum of two shorter sides is greater than the long side, then we can gurantee a triangle\\n        # a + b > c is a sufficient and necessary condition to make a triangle  \\n        for c in range(len(nums)):\\n            a, b = 0, c - 1\\n            while a < b:\\n                two_sum = nums[a] + nums[b]\\n                if two_sum > nums[c]:               # Eg. 1\\uFF0C2\\uFF0C3\\uFF0C5\\uFF0C7\\uFF0C9   \\n                    count += b - a                  #     ^            ^  if c = 10, 1 + 9 <= c then 1 + any <= c so we skip 1 => a++\\n                                                    # if c = 9, 1 + 9 > c then 9 + any > c so we add count and skip 9 => b-- \\n                    b -= 1\\n                else:\\n                    a += 1\\n        return count       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1492660,
                "title": "valid-triangle-number",
                "content": "```\\nclass Solution {\\n    public int triangleNumber(int[] nums) {\\n       Arrays.sort(nums);\\n        int c=0;\\n        \\n        //1.Sort the array\\n        //2. To make triangle we check sum of 2 sides is greater thena 3rd side or not\\n    \\n       for(int i=nums.length-1;i>=0;i--){ \\n           int l=0,r=i-1;\\n           //i have fixed l ,r and i\\n           //If sum of l+r is coming greater than last element then obviously elements inside l and r will also be able to make triangles \\n           while(l<r){\\n           if(nums[l]+nums[r]>nums[i]){\\n               c=c+(r-l);\\n               r--;\\n           }\\n               // if sum is coming lesser then do l++\\n           else{\\n               l++;\\n           }\\n       }\\n       }\\n       \\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int triangleNumber(int[] nums) {\\n       Arrays.sort(nums);\\n        int c=0;\\n        \\n        //1.Sort the array\\n        //2. To make triangle we check sum of 2 sides is greater thena 3rd side or not\\n    \\n       for(int i=nums.length-1;i>=0;i--){ \\n           int l=0,r=i-1;\\n           //i have fixed l ,r and i\\n           //If sum of l+r is coming greater than last element then obviously elements inside l and r will also be able to make triangles \\n           while(l<r){\\n           if(nums[l]+nums[r]>nums[i]){\\n               c=c+(r-l);\\n               r--;\\n           }\\n               // if sum is coming lesser then do l++\\n           else{\\n               l++;\\n           }\\n       }\\n       }\\n       \\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1383354,
                "title": "python-o-n-2-two-pointers-solution",
                "content": "time: O(n^2)\\n\\n```python\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        ans = 0\\n        nums.sort()\\n\\n        n = len(nums)\\n        for k in range(n-1, -1, -1):\\n            i, j = 0, k-1\\n            while i < j:\\n                if nums[i]+nums[j] > nums[k]:\\n                    ans += j-i\\n                    j -= 1\\n                else:\\n                    i += 1\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        ans = 0\\n        nums.sort()\\n\\n        n = len(nums)\\n        for k in range(n-1, -1, -1):\\n            i, j = 0, k-1\\n            while i < j:\\n                if nums[i]+nums[j] > nums[k]:\\n                    ans += j-i\\n                    j -= 1\\n                else:\\n                    i += 1\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1362669,
                "title": "c-binary-search-newbie-oriented-explanation-o-n-2-log-n",
                "content": "***#3 conditions to be checked***\\n\\na+b>c        ....(1)\\nb+c>a        ....(2)\\na+c>b        ....(3)\\n\\nNot the best approach [like](https://leetcode.com/problems/valid-triangle-number/discuss/104174/Java-O(n2)-Time-O(1)-Space)  where notion is of checking  only one condition out of 3 condition is checked each time and all cases are covered (other 2 are automatically checked) \\n\\n.... but still in my approach I am **checking 2 conditions instead of 3** which brings the T.C. from O(n^3) to **O(n^2 log(n))** ...\\n\\n ***Notion/Intution/proof of solution***\\n equation (2) and (3) can be written as,\\n\\t\\t\\t\\t                                 c>a-b\\n\\t\\t\\t\\t                                 c>b-a\\nso                                            c>max(a-b,b-a) ........(4)\\nAlso since,                              c<a+b\\n\\nTo make our work do-able sort the array so that we can get a relation\\n                                              a<b<c  ......(5)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  \\nFrom (4) and (5), we finally get a relation for side -\\'c\\'\\n                                         b-a<c<a+b  ..........(6)\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\n\\n***Implementation***\\nSo actually we have to find triplets a,b,c which satisfies equation (6) (or both equation(4) and (1) Think? ) \\n \\n 1. We can generate all combinations of (a,b) in n^2 using nested for loop \\n 2. And for each of the generated combination we have to count how many \\'c\\' are satisfying this conditioin. \\n 3. That is for each (a,b) we have (b-a, a+b) and using binary search we can found all elements in array lying between \\'b-a\\' and \\'a+b\\' which will be our valid \\'c\\' \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    #define all(x) x.begin(),x.end()\\n    \\n    int triangleNumber(vector<int>& tri) {\\n        \\n        int i,j,k,ans=0,a,b,n=tri.size();\\n        \\n        sort(all(tri));\\n        \\n        //a,b,c - 3 sides of triangle\\n        //   b-a<c<a+b\\n        \\n        for(i=0;i<n-2;i++){\\n            \\n             a = tri[i];\\n            \\n            for(j=i+1;j<n-1;j++){\\n                \\n                b = tri[j];\\n                \\n                int lo=j+1, hi=n-1, c1=-1, c2=-1;\\n                \\n                while(lo<=hi){\\n                    int mid = lo+(hi-lo)/2;\\n                    \\n                    if(b-a<tri[mid]){\\n                        c1=mid;\\n                        hi=mid-1;\\n                    }\\n                    else{\\n                        lo=mid+1;\\n                    }\\n                }\\n                \\n                lo = j+1, hi = n-1;\\n                \\n                while(lo<=hi){\\n                    int mid = lo+(hi-lo)/2;\\n                    \\n                    if(tri[mid]<a+b){\\n                        c2=mid;\\n                         lo=mid+1;\\n                    }\\n                    else{\\n                        hi=mid-1;\\n                    }\\n                }\\n                \\n                if(c1!=-1 || c2!=-1)\\n                ans+= max(0,c2-c1+1);\\n            }\\n        }\\n        \\n        ans = max(ans,0);\\n        return ans;\\n        \\n    }\\n};\\n\\n\\n```\\n\\n/*\\n[0,1,1,1]\\n[0,0,0]\\n[1,2,2,4,4,5,6,7]\\n[1,1,1,1,1,1,1]\\n[2,2,3,4]\\n[4,2,3,4]\\n[1,1,2,2]\\n[2,1,3,3,3,1,3,5,7,2]\\n[4,6,2,4,3,1,2,5]\\n[1,2,3,4]\\n[4,3,2,1]\\n[1,2,3,4,1,2,3,4]\\n[4,3,2,1,4,3,2,1,1]\\n*/\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  \\n\\n",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    #define all(x) x.begin(),x.end()\\n    \\n    int triangleNumber(vector<int>& tri) {\\n        \\n        int i,j,k,ans=0,a,b,n=tri.size();\\n        \\n        sort(all(tri));\\n        \\n        //a,b,c - 3 sides of triangle\\n        //   b-a<c<a+b\\n        \\n        for(i=0;i<n-2;i++){\\n            \\n             a = tri[i];\\n            \\n            for(j=i+1;j<n-1;j++){\\n                \\n                b = tri[j];\\n                \\n                int lo=j+1, hi=n-1, c1=-1, c2=-1;\\n                \\n                while(lo<=hi){\\n                    int mid = lo+(hi-lo)/2;\\n                    \\n                    if(b-a<tri[mid]){\\n                        c1=mid;\\n                        hi=mid-1;\\n                    }\\n                    else{\\n                        lo=mid+1;\\n                    }\\n                }\\n                \\n                lo = j+1, hi = n-1;\\n                \\n                while(lo<=hi){\\n                    int mid = lo+(hi-lo)/2;\\n                    \\n                    if(tri[mid]<a+b){\\n                        c2=mid;\\n                         lo=mid+1;\\n                    }\\n                    else{\\n                        hi=mid-1;\\n                    }\\n                }\\n                \\n                if(c1!=-1 || c2!=-1)\\n                ans+= max(0,c2-c1+1);\\n            }\\n        }\\n        \\n        ans = max(ans,0);\\n        return ans;\\n        \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1351422,
                "title": "c-solution-with-sorting-and-binary-search",
                "content": "Algorithm\\n1. sort\\n2. for every element  search other two using binary search in array\\n3. time complexity:  O(n2)\\n4. space Complexity: O(logn)\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    //Sorting\\n    int triangleNumber(vector<int>& nums) {\\n  \\n        sort(nums.begin(), nums.end());\\n        int result = 0;\\n        \\n        //for every element  search other two using binary search\\n        for (int i = nums.size()-1; i >= 0; i--) {\\n            \\n            int left = 0;\\n            int right = i-1;\\n            while (left < right) {\\n                if (nums[left] + nums[right] > nums[i]) {\\n                    \\n                    //all elements between left-right satisfies\\n                    result += right - left;\\n                    right--;\\n                }\\n                else {\\n                    left++;\\n                }\\n            }\\n        }\\n        return  result;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    //Sorting\\n    int triangleNumber(vector<int>& nums) {\\n  \\n        sort(nums.begin(), nums.end());\\n        int result = 0;\\n        \\n        //for every element  search other two using binary search\\n        for (int i = nums.size()-1; i >= 0; i--) {\\n            \\n            int left = 0;\\n            int right = i-1;\\n            while (left < right) {\\n                if (nums[left] + nums[right] > nums[i]) {\\n                    \\n                    //all elements between left-right satisfies\\n                    result += right - left;\\n                    right--;\\n                }\\n                else {\\n                    left++;\\n                }\\n            }\\n        }\\n        return  result;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1341067,
                "title": "explain-in-detail-c-binary-search",
                "content": "First, you should know how to check the triangle valid or not.\\nIf there are three sides a,b and c then triangle should valid when a+b > c , b+c>a , c+a>b.\\nmeans the sum of two sides is greater than the other side.\\n\\nNow, come to question:\\nWe find tripletes which have valid triangle.\\n\\n**Brute Force:**\\nMake all tripletes and check traingle is valid or not.\\nMaking all triples takes O(n<sup>3</sup>) and checking take O(1) which will give TLE.\\nCode:\\n```\\nclass Solution {\\npublic:\\n    \\n    bool fun(int a, int b,int c){\\n         if (a + b <= c || a + c <= b || b + c <= a)\\n            return false;\\n        else\\n            return true;\\n    }\\n    \\n    \\n    int triangleNumber(vector<int>& nums) {\\n  \\n        if(n<3)\\n            return 0;\\n        sort(nums.begin(),nums.end());\\n        int cntOfTriangle=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n               for(int k=j+1;k<nums.size();k++){\\n                   if(fun(nums[i],nums[j],nums[k])){\\n                       cntOfTriangle++;\\n                   }\\n               }\\n            }\\n        }\\n        return cntOfTriangle;\\n    }\\n};\\n```\\n\\n**Efficient Approch: O(n<sup>**2**</sup> log n)**\\n\\nNow, pick two small side and check the largest side.\\nSo, we sort the array and we start from left, we automatically pick two smallest element.\\n\\nNow, checking the largest side in efficient manner.\\nuse binary search algorithm to check the range of largest element.\\n\\nAfter the certain point , it always give false:\\nEx: [2,2,3,4,5,6]\\nwe pick 2 and 2 now i am picking the thrid side.\\n2+2 > 3 true , 2+2 > 4 false, 2+2 > 5 false, 2+2 > 6 false.\\n[ _ , _ ,T,F,F,F]\\n\\nYou see after the 2 index it gives false.\\nWe take the upper bound and substract from begining.\\nBinary search check it O(log n)\\n\\npicking two number takes O(n<sup>2</sup>) for every doublet use O(log n ).\\nTotal Time Complexity is :  **O(n<sup>**2**</sup> log n)**\\n\\nCode:\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool fun(int a, int b,int c){\\n         if (a + b <= c || a + c <= b || b + c <= a)\\n            return false;\\n        else\\n            return true;\\n    }\\n    \\n    \\n    int triangleNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n<3)\\n            return 0;\\n        sort(nums.begin(),nums.end());\\n        int cntOfTriangle=0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                \\n                /*now picking the third side*/\\n                int l=j+1,r = n-1,m;\\n                while(l<=r){\\n                    m = (l+r)/2;\\n                    if(fun(nums[i],nums[j],nums[m]))\\n                        l = m+1;\\n                    else\\n                        r = m-1;\\n                }\\n                cntOfTriangle += r-j;\\n            }\\n        }\\n        return cntOfTriangle;\\n    }\\n};\\n\\n\\n```\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool fun(int a, int b,int c){\\n         if (a + b <= c || a + c <= b || b + c <= a)\\n            return false;\\n        else\\n            return true;\\n    }\\n    \\n    \\n    int triangleNumber(vector<int>& nums) {\\n  \\n        if(n<3)\\n            return 0;\\n        sort(nums.begin(),nums.end());\\n        int cntOfTriangle=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n               for(int k=j+1;k<nums.size();k++){\\n                   if(fun(nums[i],nums[j],nums[k])){\\n                       cntOfTriangle++;\\n                   }\\n               }\\n            }\\n        }\\n        return cntOfTriangle;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    bool fun(int a, int b,int c){\\n         if (a + b <= c || a + c <= b || b + c <= a)\\n            return false;\\n        else\\n            return true;\\n    }\\n    \\n    \\n    int triangleNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n<3)\\n            return 0;\\n        sort(nums.begin(),nums.end());\\n        int cntOfTriangle=0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                \\n                /*now picking the third side*/\\n                int l=j+1,r = n-1,m;\\n                while(l<=r){\\n                    m = (l+r)/2;\\n                    if(fun(nums[i],nums[j],nums[m]))\\n                        l = m+1;\\n                    else\\n                        r = m-1;\\n                }\\n                cntOfTriangle += r-j;\\n            }\\n        }\\n        return cntOfTriangle;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1340409,
                "title": "c-easy-solution-using-upper-bound",
                "content": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums)\\n    {\\n        int n=nums.size();\\n        sort(nums.begin(), nums.end());\\n        int ans = 0;\\n\\n        for (int i=0 ; i<n-2; i++)\\n        {\\n               for (int j=i+1 ; j<n-1 ; j++)\\n               {\\n                   int s=nums[i]+nums[j]-1;\\n                   auto it = upper_bound(nums.begin()+j+1, nums.end(), s);\\n                   int index = distance(nums.begin()+j+1, it);\\n                   ans+=index;\\n               }\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums)\\n    {\\n        int n=nums.size();\\n        sort(nums.begin(), nums.end());\\n        int ans = 0;\\n\\n        for (int i=0 ; i<n-2; i++)\\n        {\\n               for (int j=i+1 ; j<n-1 ; j++)\\n               {\\n                   int s=nums[i]+nums[j]-1;\\n                   auto it = upper_bound(nums.begin()+j+1, nums.end(), s);\\n                   int index = distance(nums.begin()+j+1, it);\\n                   ans+=index;\\n               }\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1340357,
                "title": "java-solution-using-2-pointer-approach",
                "content": "``````\\n  int ans =0;\\n    public int triangleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int length = nums.length;\\n        int end = length-1;\\n        int sum =0;\\n        int index = end-1;\\n       \\n        for(int i =length-1; i >=1; i--){\\n             sum = nums[i];\\n          sum(nums, i-1, sum);\\n            \\n        }\\n        return ans;\\n        \\n    }\\n    \\n    void sum (int nums[], int end, int maxSum){\\n        int start=0;\\n        \\n        while(start<end)\\n        {\\n            int side1=nums[start];\\n            int side2=nums[end];\\n            if(side1+side2>maxSum)\\n            {\\n                ans+=(end-start);\\n                end--;\\n            }\\n            else\\n            {\\n                start++;\\n            }\\n        }\\n       \\n    }\\n    }",
                "solutionTags": [],
                "code": "``````",
                "codeTag": "Unknown"
            },
            {
                "id": 1340310,
                "title": "94-faster-clean-explained-o-n-2-soln",
                "content": "```\\npublic class Solution {\\n    // Time O(n^2) Space O(1), n = length of \\'nums\\' array\\n    public int TriangleNumber(int[] nums) {\\n        Array.Sort(nums);       // O(nlogn)\\n        int triplets = 0, left, right;\\n        for (int i = 2; i < nums.Length; i++)\\n        {\\n            left = 0; right = i - 1;\\n            while (left < right)\\n                if (nums[left] + nums[right] > nums[i])     // triangle can be formed\\n                    triplets += right-- - left;             // update count and reduce right by 1 to see again if more triplets can be formed,\\n                                                            // once we found a pair left,right,i we increament count by diff of right-left\\n                                                            // Bcoz all remaining nums between left to right can also form triplet\\n                else\\n                    left++;                                 // keep moving left towards right to increase value of left side\\n        }\\n        return triplets;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/fa7f3da8-11fe-4971-8e54-8ce1d1375997_1626377049.2510853.png)\\n",
                "solutionTags": [
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\npublic class Solution {\\n    // Time O(n^2) Space O(1), n = length of \\'nums\\' array\\n    public int TriangleNumber(int[] nums) {\\n        Array.Sort(nums);       // O(nlogn)\\n        int triplets = 0, left, right;\\n        for (int i = 2; i < nums.Length; i++)\\n        {\\n            left = 0; right = i - 1;\\n            while (left < right)\\n                if (nums[left] + nums[right] > nums[i])     // triangle can be formed\\n                    triplets += right-- - left;             // update count and reduce right by 1 to see again if more triplets can be formed,\\n                                                            // once we found a pair left,right,i we increament count by diff of right-left\\n                                                            // Bcoz all remaining nums between left to right can also form triplet\\n                else\\n                    left++;                                 // keep moving left towards right to increase value of left side\\n        }\\n        return triplets;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1340131,
                "title": "python-simple-and-81-faster-solution",
                "content": "```\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        count = 0\\n        nums.sort()\\n        for i in range(len(nums)-1,0,-1):\\n            start = 0\\n            mid = i-1\\n            while (start<mid):\\n                if nums[start]+nums[mid]>nums[i]:\\n                    count+=(mid-start)\\n                    mid-=1\\n                else:\\n                    start+=1\\n        return count\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        count = 0\\n        nums.sort()\\n        for i in range(len(nums)-1,0,-1):\\n            start = 0\\n            mid = i-1\\n            while (start<mid):\\n                if nums[start]+nums[mid]>nums[i]:\\n                    count+=(mid-start)\\n                    mid-=1\\n                else:\\n                    start+=1\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1340050,
                "title": "java-solution",
                "content": "eg: [1,3,4,5]  --- triangle elements (a, b, c)\\nThree for loops:\\nfirst: for element (a) in the triangle \\nsecond: for (b)\\nthird: for (c)\\n\\n\\n```\\nclass Solution {\\n    public int triangleNumber(int[] nums) {\\n        int count = 0;\\n        \\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length-2; i++) {\\n            for(int a = i+1; a < nums.length-1; a++) {\\n                for(int j = a+1; j < nums.length; j++) {\\n                    if(nums[i] + nums[a] > nums[j])\\n                        count++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int triangleNumber(int[] nums) {\\n        int count = 0;\\n        \\n        Arrays.sort(nums);\\n        for(int i = 0; i < nums.length-2; i++) {\\n            for(int a = i+1; a < nums.length-1; a++) {\\n                for(int j = a+1; j < nums.length; j++) {\\n                    if(nums[i] + nums[a] > nums[j])\\n                        count++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1340034,
                "title": "java-o-n-2-logn-solution-using-binary-search",
                "content": "Given 3 sides of a triangle , the equations that need to be satisfied are - \\n**a+b>c\\nb+c>a\\na+c>b**\\nWe can find the first two sides by the use of **nested for loops** and then can solve these three inequalites and can **calculate the minimum and maximum value of the third side and add all the values in that range to our answer.**\\n```\\nclass Solution {\\n    public static int binarySearch1(int nums[],int start,int end,int target) // binarysearch for calculating maximum value of x by the reference of equation 1\\n    {\\n        if(start>end)\\n            return -1;\\n        int mid=start+(end-start)/2;\\n        if(nums[mid]<target)\\n        {\\n            int t=binarySearch1(nums,mid+1,end,target);\\n            return t==-1?mid:t;\\n        }\\n        return binarySearch1(nums,start,mid-1,target);\\n    }\\n    public static int binarySearch2(int nums[],int start,int end,int target) // binarysearch for calculating minimum value of x by the reference of equation 2 and equation 3\\n    {\\n        if(start>end)\\n            return -1;\\n        int mid=start+(end-start)/2;\\n        if(nums[mid]>target)\\n        {\\n            int t=binarySearch2(nums,start,mid-1,target);\\n            return t==-1?mid:t;\\n        }\\n        return binarySearch2(nums,mid+1,end,target);\\n    }\\n    public int triangleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int total=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                int a=nums[i];\\n                int b=nums[j];\\n                int far=binarySearch1(nums,j+1,nums.length-1,a+b); // calculating the maximum value of x that can be!\\n                int near=binarySearch2(nums,j+1,nums.length-1,a-b); \\n                if(far==-1 || near==-1)\\n                    continue;\\n                near=Math.max(near,binarySearch2(nums,j+1,nums.length-1,b-a)); // calculating the minimum value of x that can be!\\n                total+=far-near+1; // adding the total number of indices that can make the triangle\\n            }\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public static int binarySearch1(int nums[],int start,int end,int target) // binarysearch for calculating maximum value of x by the reference of equation 1\\n    {\\n        if(start>end)\\n            return -1;\\n        int mid=start+(end-start)/2;\\n        if(nums[mid]<target)\\n        {\\n            int t=binarySearch1(nums,mid+1,end,target);\\n            return t==-1?mid:t;\\n        }\\n        return binarySearch1(nums,start,mid-1,target);\\n    }\\n    public static int binarySearch2(int nums[],int start,int end,int target) // binarysearch for calculating minimum value of x by the reference of equation 2 and equation 3\\n    {\\n        if(start>end)\\n            return -1;\\n        int mid=start+(end-start)/2;\\n        if(nums[mid]>target)\\n        {\\n            int t=binarySearch2(nums,start,mid-1,target);\\n            return t==-1?mid:t;\\n        }\\n        return binarySearch2(nums,mid+1,end,target);\\n    }\\n    public int triangleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int total=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                int a=nums[i];\\n                int b=nums[j];\\n                int far=binarySearch1(nums,j+1,nums.length-1,a+b); // calculating the maximum value of x that can be!\\n                int near=binarySearch2(nums,j+1,nums.length-1,a-b); \\n                if(far==-1 || near==-1)\\n                    continue;\\n                near=Math.max(near,binarySearch2(nums,j+1,nums.length-1,b-a)); // calculating the minimum value of x that can be!\\n                total+=far-near+1; // adding the total number of indices that can make the triangle\\n            }\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339889,
                "title": "a-few-solutions",
                "content": "I started off with a brute-force O(N<sup>3</sup>) solution which considers all possible edges `i`, `j`, `k` for the triangle.  This results in TLE since `N = 1000`.  However, we can reduce this runtime to O(N<sup>2</sup>logN) if we sort the input array `A` and consider each index pair `i`, `j` to see if there exists an index `k` such that `i < j < k` and `A[k] < A[i] + A[j]` (ie. these are necessary conditions to formulate a triangle).  Thus we use binary search to find the lower bound `k` in logarithmic time.\\n\\n\\uD83D\\uDC40 We can visualize this enhanced solution as 3 edges:  Using `A[i]` and `A[j]` as edge 1 and edge 2 correspondingly, then question is: \"How do we find the count of valid edge 3?\"  To find this count of edge 3, we use deductive reasoning.  Let `k` be the sum of the 1<sup>st</sup> and 2<sup>nd</sup> edge, (ie. `k = A[i] + A[j]`).  We know that we **cannot** formulate a triangle when the length of the 3<sup>rd</sup> edge matches or exceeds `k` (ie. the red section), thus it follows we **can** formulate a triangle with the green section, ie. all valid values for edge 3.  And so we accumulate and return the count of the green section.  Since `k` is non-inclusive, the count of the green section is `k - j - 1`.\\n\\n![image](https://assets.leetcode.com/users/images/1493998f-3a6a-485f-a94f-c9399ce03127_1626371162.9315197.png)\\n\\n---\\n\\n**Binary-Search O(N<sup>2</sup>logN):**\\n\\n*Kotlin*\\n```\\nfun lowerBound(A: IntArray, target: Int): Int {\\n    val N = A.size\\n    var i = 0\\n    var j = N\\n    while (i < j) {\\n        val k = (i + j) / 2\\n        if (A[k] < target)\\n            i = k + 1\\n        else\\n            j = k\\n    }\\n    return i\\n}\\nclass Solution {\\n    fun triangleNumber(A: IntArray): Int {\\n        var total = 0\\n        var N = A.size\\n        A.sort()\\n        for (i in 0 until N) {\\n            for (j in i + 1 until N) {\\n                var k = lowerBound(A, A[i] + A[j])\\n                if (j < k)\\n                    total += k - j - 1  // -1 since k is non-inclusive \\n            }\\n        }\\n        return total\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet triangleNumber = (A, N = A.length, total = 0) => {\\n    A.sort((a, b) => a - b);\\n    for (let i = 0; i < N; ++i) {\\n        for (let j = i + 1; j < N; ++j) {\\n            let k = _.sortedIndex(A, A[i] + A[j]);\\n            if (j < k)\\n                total += k - j - 1;  // -1 since k is non-inclusive\\n        }\\n    }\\n    return total;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def triangleNumber(self, A: List[int], total = 0) -> int:\\n        N = len(A)\\n        A.sort()\\n        for i in range(N):\\n            for j in range(i + 1, N):\\n                k = bisect_left(A, A[i] + A[j])\\n                if j < k:\\n                    total += k - j - 1  # -1 since k is non-inclusive\\n        return total\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int triangleNumber(VI& A, int total = 0) {\\n        int N = A.size();\\n        sort(A.begin(), A.end());\\n        for (auto i{ 0 }; i < N; ++i) {\\n            for (auto j{ i + 1 }; j < N; ++j) {\\n                int k = distance(A.begin(), lower_bound(A.begin(), A.end(), A[i] + A[j]));\\n                if (j < k)\\n                    total += k - j - 1;  // -1 since k is non-inclusive\\n            }\\n        }\\n        return total;\\n    }\\n};\\n```\\n\\n---\\n\\n**Brute-Force O(N<sup>3</sup>):**\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun triangleNumber(A: IntArray): Int {\\n        var total = 0\\n        var N = A.size\\n        A.sort()\\n        for (i in 0 until N)\\n            for (j in i + 1 until N)\\n                for (k in j + 1 until N)\\n                    if (A[k] < A[i] + A[j])\\n                        ++total\\n        return total\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet triangleNumber = (A, N = A.length, total = 0) => {\\n    A.sort((a, b) => a - b);\\n    for (let i = 0; i < N; ++i)\\n        for (let j = i + 1; j < N; ++j)\\n            for (let k = j + 1; k < N; ++k)\\n                if (A[k] < A[i] + A[j])\\n                    ++total;\\n    return total;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def triangleNumber(self, A: List[int], total = 0) -> int:\\n        N = len(A)\\n        A.sort()\\n        for i in range(N):\\n            for j in range(i + 1, N):\\n                for k in range(j + 1, N):\\n                    if A[k] < A[i] + A[j]:\\n                        total += 1\\n        return total\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int triangleNumber(VI& A, int total = 0) {\\n        int N = A.size();\\n        sort(A.begin(), A.end());\\n        for (auto i{ 0 }; i < N; ++i)\\n            for (auto j{ i + 1 }; j < N; ++j)\\n                for (auto k{ j + 1 }; k < N; ++k)\\n                    if (A[k] < A[i] + A[j])\\n                        ++total;\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfun lowerBound(A: IntArray, target: Int): Int {\\n    val N = A.size\\n    var i = 0\\n    var j = N\\n    while (i < j) {\\n        val k = (i + j) / 2\\n        if (A[k] < target)\\n            i = k + 1\\n        else\\n            j = k\\n    }\\n    return i\\n}\\nclass Solution {\\n    fun triangleNumber(A: IntArray): Int {\\n        var total = 0\\n        var N = A.size\\n        A.sort()\\n        for (i in 0 until N) {\\n            for (j in i + 1 until N) {\\n                var k = lowerBound(A, A[i] + A[j])\\n                if (j < k)\\n                    total += k - j - 1  // -1 since k is non-inclusive \\n            }\\n        }\\n        return total\\n    }\\n}\\n```\n```\\nlet triangleNumber = (A, N = A.length, total = 0) => {\\n    A.sort((a, b) => a - b);\\n    for (let i = 0; i < N; ++i) {\\n        for (let j = i + 1; j < N; ++j) {\\n            let k = _.sortedIndex(A, A[i] + A[j]);\\n            if (j < k)\\n                total += k - j - 1;  // -1 since k is non-inclusive\\n        }\\n    }\\n    return total;\\n};\\n```\n```\\nclass Solution:\\n    def triangleNumber(self, A: List[int], total = 0) -> int:\\n        N = len(A)\\n        A.sort()\\n        for i in range(N):\\n            for j in range(i + 1, N):\\n                k = bisect_left(A, A[i] + A[j])\\n                if j < k:\\n                    total += k - j - 1  # -1 since k is non-inclusive\\n        return total\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int triangleNumber(VI& A, int total = 0) {\\n        int N = A.size();\\n        sort(A.begin(), A.end());\\n        for (auto i{ 0 }; i < N; ++i) {\\n            for (auto j{ i + 1 }; j < N; ++j) {\\n                int k = distance(A.begin(), lower_bound(A.begin(), A.end(), A[i] + A[j]));\\n                if (j < k)\\n                    total += k - j - 1;  // -1 since k is non-inclusive\\n            }\\n        }\\n        return total;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    fun triangleNumber(A: IntArray): Int {\\n        var total = 0\\n        var N = A.size\\n        A.sort()\\n        for (i in 0 until N)\\n            for (j in i + 1 until N)\\n                for (k in j + 1 until N)\\n                    if (A[k] < A[i] + A[j])\\n                        ++total\\n        return total\\n    }\\n}\\n```\n```\\nlet triangleNumber = (A, N = A.length, total = 0) => {\\n    A.sort((a, b) => a - b);\\n    for (let i = 0; i < N; ++i)\\n        for (let j = i + 1; j < N; ++j)\\n            for (let k = j + 1; k < N; ++k)\\n                if (A[k] < A[i] + A[j])\\n                    ++total;\\n    return total;\\n};\\n```\n```\\nclass Solution:\\n    def triangleNumber(self, A: List[int], total = 0) -> int:\\n        N = len(A)\\n        A.sort()\\n        for i in range(N):\\n            for j in range(i + 1, N):\\n                for k in range(j + 1, N):\\n                    if A[k] < A[i] + A[j]:\\n                        total += 1\\n        return total\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int triangleNumber(VI& A, int total = 0) {\\n        int N = A.size();\\n        sort(A.begin(), A.end());\\n        for (auto i{ 0 }; i < N; ++i)\\n            for (auto j{ i + 1 }; j < N; ++j)\\n                for (auto k{ j + 1 }; k < N; ++k)\\n                    if (A[k] < A[i] + A[j])\\n                        ++total;\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339686,
                "title": "go-simple-solution-o-n-2-4ms-3-3-mb",
                "content": "```\\nfunc triangleNumber(nums []int) int {\\n    count := 0\\n    sort.Ints(nums)\\n    l := len(nums)\\n    \\n    for i:=l-1; i>=2; i-- {\\n        l, r := 0, i - 1\\n        for l < r {\\n            if nums[l] + nums[r] > nums[i] {\\n                count += (r - l)\\n                r--\\n            } else {\\n                l++\\n            }\\n        }\\n    }\\n    \\n    return count\\n}",
                "solutionTags": [
                    "Go",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nfunc triangleNumber(nums []int) int {\\n    count := 0\\n    sort.Ints(nums)\\n    l := len(nums)\\n    \\n    for i:=l-1; i>=2; i-- {\\n        l, r := 0, i - 1\\n        for l < r {\\n            if nums[l] + nums[r] > nums[i] {\\n                count += (r - l)\\n                r--\\n            } else {\\n                l++\\n            }\\n        }\\n    }\\n    \\n    return count\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1339507,
                "title": "java-easy-2-pointers",
                "content": "```\\nclass Solution {\\n    public int triangleNumber(int[] arr) {\\n      //Sort to avoid number of Comparisons\\n         Arrays.sort(arr);\\n         int count = 0;\\n      \\n      for(int i = arr.length - 1;i >= 2;i--){\\n        int l = 0;\\n        int r = i - 1;\\n       while(l < r){\\n          int sum = arr[l] + arr[r];\\n         \\n          if(sum > arr[i]){\\n            //if sum is greater than arr[i] than all the values greater than l can make valid triplets\\n            count += (r - l);\\n            r--;\\n          }\\n         //otherwise increase the left index to increase your sum\\n          else{\\n             l++;\\n          }\\n         \\n       }\\n      }\\n      return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int triangleNumber(int[] arr) {\\n      //Sort to avoid number of Comparisons\\n         Arrays.sort(arr);\\n         int count = 0;\\n      \\n      for(int i = arr.length - 1;i >= 2;i--){\\n        int l = 0;\\n        int r = i - 1;\\n       while(l < r){\\n          int sum = arr[l] + arr[r];\\n         \\n          if(sum > arr[i]){\\n            //if sum is greater than arr[i] than all the values greater than l can make valid triplets\\n            count += (r - l);\\n            r--;\\n          }\\n         //otherwise increase the left index to increase your sum\\n          else{\\n             l++;\\n          }\\n         \\n       }\\n      }\\n      return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339492,
                "title": "c-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& v) {\\n         int cnt=0;\\n        int n=v.size();\\n        sort(v.begin(),v.end());\\n        for(int i=n-1;i>=1;i--)\\n        {\\n           int l=0; int h=i-1;\\n            while(l<h){\\n                if(v[l]+v[h]>v[i]){\\n                    // If it is possible with v[l] and v[h] then triangles can obviously formed from v[l+1], v[l+2],v[l+3]\\u2026..v[h-1], \\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t//v[r] and v[i], because we have already sorted the array.\\n\\t\\t\\t\\t\\t\\n                    cnt+=h-l;\\n                    h--;\\n                }\\n                else{\\n                    l++;\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& v) {\\n         int cnt=0;\\n        int n=v.size();\\n        sort(v.begin(),v.end());\\n        for(int i=n-1;i>=1;i--)\\n        {\\n           int l=0; int h=i-1;\\n            while(l<h){\\n                if(v[l]+v[h]>v[i]){\\n                    // If it is possible with v[l] and v[h] then triangles can obviously formed from v[l+1], v[l+2],v[l+3]\\u2026..v[h-1], \\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t//v[r] and v[i], because we have already sorted the array.\\n\\t\\t\\t\\t\\t\\n                    cnt+=h-l;\\n                    h--;\\n                }\\n                else{\\n                    l++;\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339326,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& a) {\\n        sort(a.begin(),a.end());\\n        int n=a.size(),c=0;\\n        if(n<3)return 0;\\n        for(int i=0;i+2<n;i++){\\n            for(int j=i+1;j<n&&a[i]>0;j++){\\n                int k;\\n                auto it = lower_bound(a.begin(),a.end(),a[i]+a[j]);\\n                k = it-a.begin();\\n                c += (k-j-1);\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& a) {\\n        sort(a.begin(),a.end());\\n        int n=a.size(),c=0;\\n        if(n<3)return 0;\\n        for(int i=0;i+2<n;i++){\\n            for(int j=i+1;j<n&&a[i]>0;j++){\\n                int k;\\n                auto it = lower_bound(a.begin(),a.end(),a[i]+a[j]);\\n                k = it-a.begin();\\n                c += (k-j-1);\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339306,
                "title": "valid-triangle-number-solution-2-pointer-techniqe",
                "content": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int count=0;\\n        int n=nums.size();\\n        for(int i=n-1;i>=2;i--){\\n            int l=0,r=i-1;\\n            while(l<r){\\n                if(nums[l]+nums[r]>nums[i]){\\n                    count+=r-l;\\n                    r--;\\n                }else{\\n                    l++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int count=0;\\n        int n=nums.size();\\n        for(int i=n-1;i>=2;i--){\\n            int l=0,r=i-1;\\n            while(l<r){\\n                if(nums[l]+nums[r]>nums[i]){\\n                    count+=r-l;\\n                    r--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1339213,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int triangleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int count = 0;\\n        for(int i = n-1;i>=2;i--){\\n            int l = 0;\\n            int r = i-1;\\n            while(l<r){\\n                if(nums[l]+nums[r]>nums[i]){\\n                    count = count + r-l;\\n                    r--;\\n                }else{\\n                    l++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int triangleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int count = 0;\\n        for(int i = n-1;i>=2;i--){\\n            int l = 0;\\n            int r = i-1;\\n            while(l<r){\\n                if(nums[l]+nums[r]>nums[i]){\\n                    count = count + r-l;\\n                    r--;\\n                }else{\\n                    l++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339197,
                "title": "python3-easy-solution",
                "content": "```\\ndef triangleNumber(self, nums: List[int]) -> int:\\n        count =0\\n        nums.sort()\\n        for k in range(len(nums)-1,1,-1):\\n            i=0                        \\n            j=k-1\\n            while i<j:\\n                if nums[i]+nums[j]>nums[k]:\\n                    count+=j-i\\n                    j-=1\\n                else: \\n                    i+=1                   \\n        return count",
                "solutionTags": [],
                "code": "```\\ndef triangleNumber(self, nums: List[int]) -> int:\\n        count =0\\n        nums.sort()\\n        for k in range(len(nums)-1,1,-1):\\n            i=0                        \\n            j=k-1\\n            while i<j:\\n                if nums[i]+nums[j]>nums[k]:\\n                    count+=j-i\\n                    j-=1\\n                else: \\n                    i+=1                   \\n        return count",
                "codeTag": "Python3"
            },
            {
                "id": 1339128,
                "title": "c-o-n-2logn-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ctr = 0;\\n        for(int i=0;i<nums.size();++i) {\\n            for(int j=i+1;j<nums.size();++j) {\\n                int index = lower_bound(nums.begin()+j+1, nums.end(), nums[i] + nums[j]) - nums.begin() - 1;\\n                ctr += index - j;\\n            }\\n        }\\n        return ctr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ctr = 0;\\n        for(int i=0;i<nums.size();++i) {\\n            for(int j=i+1;j<nums.size();++j) {\\n                int index = lower_bound(nums.begin()+j+1, nums.end(), nums[i] + nums[j]) - nums.begin() - 1;\\n                ctr += index - j;\\n            }\\n        }\\n        return ctr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339104,
                "title": "c-o-n-2-solution",
                "content": "**intuition**\\nSay the 3 sides of the triangle are ```a```, ```b```,```c```.\\n* we don\\'t know which side has the longest length\\n   if ```a + b > c``` && ```a + c > b``` && ```b + c > a```, then ```a```, ```b```,```c``` can form a triangle. This is the brute force solution, which takes O(n^3).\\n* we know the longest side. For example, ```c``` is the longest length\\n  if```a + b > c```, then ```a```, ```b```,```c``` can form a triangle, because ```a + c > b``` && ```b + c > a``` are always satified.\\n\\n**complexity**\\n- time: O(n^2): (n - 1) + (n - 2) + (n -3) + ... + 1\\n- space: O(1)\\n\\n**implementation**\\n```\\npublic class Solution {\\n    public int TriangleNumber(int[] nums) {\\n     \\n        if(nums == null || nums.Length < 3)\\n            return 0;\\n        \\n        int res = 0;\\n\\t\\t// O(nlogn)\\n        Array.Sort(nums);\\n        \\n\\t\\t// O(n^2)\\n        for(int k = nums.Length - 1; k >= 2; k--)\\n        {\\n            int left = 0, right = k - 1;\\n            while(left < right)\\n            {\\n                if(nums[left] + nums[right] > nums[k])\\n                {\\n                    res += right - left;\\n                    right--;\\n                }\\n                else\\n                {\\n                    left++;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```a```\n```b```\n```c```\n```a + b > c```\n```a + c > b```\n```b + c > a```\n```a```\n```b```\n```c```\n```c```\n```a + b > c```\n```a```\n```b```\n```c```\n```a + c > b```\n```b + c > a```\n```\\npublic class Solution {\\n    public int TriangleNumber(int[] nums) {\\n     \\n        if(nums == null || nums.Length < 3)\\n            return 0;\\n        \\n        int res = 0;\\n\\t\\t// O(nlogn)\\n        Array.Sort(nums);\\n        \\n\\t\\t// O(n^2)\\n        for(int k = nums.Length - 1; k >= 2; k--)\\n        {\\n            int left = 0, right = k - 1;\\n            while(left < right)\\n            {\\n                if(nums[left] + nums[right] > nums[k])\\n                {\\n                    res += right - left;\\n                    right--;\\n                }\\n                else\\n                {\\n                    left++;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1294774,
                "title": "c-java-sorting-o-n-2-time-o-1-space",
                "content": "**C++ Solution :**\\n```\\n\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        \\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        int count = 0;\\n        \\n        for(int i=n-1; i>=2; i--)\\n        {\\n            int s = 0;\\n            int e = i-1;\\n            while(s<e)\\n            {\\n                if(nums[s]+nums[e] > nums[i])\\n                {\\n                    count += e-s;\\n                    e--;\\n                }\\n                else\\n                {\\n                    s++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n};\\n\\n```\\n\\n**Java Solution :**\\n\\n```\\n\\nclass Solution {\\n    public int triangleNumber(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int count = 0;\\n        \\n        for(int i=n-1; i>=2; i--)\\n        {\\n            int s = 0;\\n            int e = i-1;\\n            while(s<e)\\n            {\\n                if(nums[s]+nums[e] > nums[i])\\n                {\\n                    count += e-s;\\n                    e--;\\n                }\\n                else\\n                {\\n                    s++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Sorting"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int triangleNumber(vector<int>& nums) {\\n        \\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        int count = 0;\\n        \\n        for(int i=n-1; i>=2; i--)\\n        {\\n            int s = 0;\\n            int e = i-1;\\n            while(s<e)\\n            {\\n                if(nums[s]+nums[e] > nums[i])\\n                {\\n                    count += e-s;\\n                    e--;\\n                }\\n                else\\n                {\\n                    s++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n};\\n\\n```\n```\\n\\nclass Solution {\\n    public int triangleNumber(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int count = 0;\\n        \\n        for(int i=n-1; i>=2; i--)\\n        {\\n            int s = 0;\\n            int e = i-1;\\n            while(s<e)\\n            {\\n                if(nums[s]+nums[e] > nums[i])\\n                {\\n                    count += e-s;\\n                    e--;\\n                }\\n                else\\n                {\\n                    s++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1281974,
                "title": "python-3-with-explanations",
                "content": "class Solution:\\n\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        count =0\\n        nums.sort()\\n        for k in range(len(nums)-1,1,-1): #Triplet is (nums[i],nums[j],nums[k]), we decrement k to find next value for third coordinate of triplet\\n            i=0                        \\n            j=k-1\\n            while i<j:\\n                if nums[i]+nums[j]>nums[k]:#values at these indices from i to j-1 qualify to be first coordinate of the triplet. Then we decrement j to find next value for second coordinate of triplet\\n                    count+=j-i\\n                    j-=1\\n                else: #we incremenet i to find next value for first coordinate of triplet\\n                    i+=1                   \\n        return count",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        count =0\\n        nums.sort()\\n        for k in range(len(nums)-1,1,-1): #Triplet is (nums[i],nums[j],nums[k]), we decrement k to find next value for third coordinate of triplet\\n            i=0                        \\n            j=k-1\\n            while i<j:\\n                if nums[i]+nums[j]>nums[k]:#values at these indices from i to j-1 qualify to be first coordinate of the triplet. Then we decrement j to find next value for second coordinate of triplet\\n                    count+=j-i\\n                    j-=1\\n                else: #we incremenet i to find next value for first coordinate of triplet\\n                    i+=1                   \\n        return count",
                "codeTag": "Java"
            },
            {
                "id": 1280190,
                "title": "simple-java-solution-o-n-2-sorting",
                "content": "```\\nclass Solution {\\n    public int triangleNumber(int[] nums) {\\n        Arrays.sort(nums); \\n        int result =0;\\n        for(int i= nums.length-1;i>=2;i--){ // longest side is at nums[i].\\n            int start = 0;\\n            int end = i-1;\\n            \\n            while(start<end){\\n                if(nums[i]>= nums[start]+nums[end])start++; // not forming a triangle\\n                else {\\n                    result+=(end-start); // number of triangle that can be formed \\n                    end--;\\n                }\\n            } \\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int triangleNumber(int[] nums) {\\n        Arrays.sort(nums); \\n        int result =0;\\n        for(int i= nums.length-1;i>=2;i--){ // longest side is at nums[i].\\n            int start = 0;\\n            int end = i-1;\\n            \\n            while(start<end){\\n                if(nums[i]>= nums[start]+nums[end])start++; // not forming a triangle\\n                else {\\n                    result+=(end-start); // number of triangle that can be formed \\n                    end--;\\n                }\\n            } \\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218920,
                "title": "python-o-n-2-time",
                "content": "```\\nclass Solution(object):\\n    def triangleNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not nums:\\n            return 0\\n        \\n        nums = sorted(nums)\\n        ans = 0\\n        for i in range(2, len(nums)):\\n            ans+= self.isValidTriangle(i, nums)\\n        \\n        return ans\\n        \\n    def isValidTriangle(self,index,nums):\\n        left, right = 0, index-1\\n        ans  = 0\\n        while left < right:\\n            if nums[left]+nums[right] > nums[index]:\\n                ans+= right - left\\n                right-=1\\n            else:\\n                left+=1\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def triangleNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not nums:\\n            return 0\\n        \\n        nums = sorted(nums)\\n        ans = 0\\n        for i in range(2, len(nums)):\\n            ans+= self.isValidTriangle(i, nums)\\n        \\n        return ans\\n        \\n    def isValidTriangle(self,index,nums):\\n        left, right = 0, index-1\\n        ans  = 0\\n        while left < right:\\n            if nums[left]+nums[right] > nums[index]:\\n                ans+= right - left\\n                right-=1\\n            else:\\n                left+=1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1214007,
                "title": "simple-o-n-2-solution-in-python",
                "content": "```\\nclass Solution:\\n    def triangleNumber(self, nums):\\n        nums.sort()\\n        ans = 0 \\n        for i in range(len(nums)-1,1,-1):\\n            j = i-1\\n            k = 0 \\n            while(k<j):\\n                if nums[j] + nums[k]>nums[i]:\\n                    ans+=(j-k)\\n                    j-=1 \\n                else:\\n                    k+=1\\n        return ans \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def triangleNumber(self, nums):\\n        nums.sort()\\n        ans = 0 \\n        for i in range(len(nums)-1,1,-1):\\n            j = i-1\\n            k = 0 \\n            while(k<j):\\n                if nums[j] + nums[k]>nums[i]:\\n                    ans+=(j-k)\\n                    j-=1 \\n                else:\\n                    k+=1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1079605,
                "title": "two-pointers-cpp-solution",
                "content": "```\\n\\nclass Solution {\\npublic: \\n    int triangleNumber(vector<int>& nums) { // two pointers\\n        int ret = 0;\\n        sort(nums.begin(), nums.end());\\n        int i = 0; \\n        for(int k = 0; k < nums.size(); k++) {\\n            int i = 0; \\n            int j = k - 1;\\n            while(i < j) {\\n                if(nums[i] + nums[j] <= nums[k]) {\\n                    i++;\\n                }else {\\n                    ret += j - i; \\n                    j--;\\n                };\\n            }\\n        } \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic: \\n    int triangleNumber(vector<int>& nums) { // two pointers\\n        int ret = 0;\\n        sort(nums.begin(), nums.end());\\n        int i = 0; \\n        for(int k = 0; k < nums.size(); k++) {\\n            int i = 0; \\n            int j = k - 1;\\n            while(i < j) {\\n                if(nums[i] + nums[j] <= nums[k]) {\\n                    i++;\\n                }else {\\n                    ret += j - i; \\n                    j--;\\n                };\\n            }\\n        } \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1036746,
                "title": "python-solution-comments-for-better-understanding",
                "content": "```\\nclass Solution(object):\\n    def triangleNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # Sort the list from small to large\\n        nums.sort()\\n        n = len(nums)\\n        output = 0\\n        \\n        # Go in revers\\n        for i in range(n-1, 1, -1):\\n            # Go from start to end\\n            start = 0\\n            end = i-1\\n            # Check the range where the condition of the triangle sides satisfy\\n            while start <= end:\\n                # If the condition is satiesfied, there are (end-start) combinations\\n                if nums[start] + nums[end] > nums[i]:\\n                    output += (end - start)\\n                    end -= 1\\n                else:\\n                    start += 1\\n        \\n        return output\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def triangleNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # Sort the list from small to large\\n        nums.sort()\\n        n = len(nums)\\n        output = 0\\n        \\n        # Go in revers\\n        for i in range(n-1, 1, -1):\\n            # Go from start to end\\n            start = 0\\n            end = i-1\\n            # Check the range where the condition of the triangle sides satisfy\\n            while start <= end:\\n                # If the condition is satiesfied, there are (end-start) combinations\\n                if nums[start] + nums[end] > nums[i]:\\n                    output += (end - start)\\n                    end -= 1\\n                else:\\n                    start += 1\\n        \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1034215,
                "title": "python-3-93-49-time-complexity",
                "content": "```\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        count = 0\\n        nums.sort()\\n        for largest in range(len(nums) - 1, 1, -1):\\n            left = 0\\n            right = largest - 1\\n            while right > left:\\n                if nums[left] + nums[right] > nums[largest]:\\n                    count += right - left\\n                    right -= 1\\n                else:\\n                    left += 1\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        count = 0\\n        nums.sort()\\n        for largest in range(len(nums) - 1, 1, -1):\\n            left = 0\\n            right = largest - 1\\n            while right > left:\\n                if nums[left] + nums[right] > nums[largest]:\\n                    count += right - left\\n                    right -= 1\\n                else:\\n                    left += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 991501,
                "title": "java-o-n-2-solution-using-two-sum-greater-than-k",
                "content": "```\\nclass Solution {\\n    public int triangleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        \\n        int result = 0;\\n\\t\\t// Start with the largest number and find if there are tuples whose sum is greater than current number.\\n        for (int i = nums.length -1 ; i > 1; --i) {\\n            result += twoSumGreaterThanK(nums, i - 1, nums[i]);\\n        }\\n        return result;\\n    }\\n    \\n\\t// Two pointers based function to get count of tuples whose sum is greater than target.\\n    private int twoSumGreaterThanK(int[] nums, int endIdx, int target) {\\n        int count = 0;\\n        \\n        int left = 0;\\n        int right = endIdx;\\n        \\n        while (left < right) {\\n            int sum = nums[left] + nums[right];\\n            if (sum > target) {\\n\\t\\t\\t    // All numbers to the left of nums[right] add upto a sum greater than target.\\n                count += right - left;\\n                --right;\\n            } else {\\n                ++left;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int triangleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        \\n        int result = 0;\\n\\t\\t// Start with the largest number and find if there are tuples whose sum is greater than current number.\\n        for (int i = nums.length -1 ; i > 1; --i) {\\n            result += twoSumGreaterThanK(nums, i - 1, nums[i]);\\n        }\\n        return result;\\n    }\\n    \\n\\t// Two pointers based function to get count of tuples whose sum is greater than target.\\n    private int twoSumGreaterThanK(int[] nums, int endIdx, int target) {\\n        int count = 0;\\n        \\n        int left = 0;\\n        int right = endIdx;\\n        \\n        while (left < right) {\\n            int sum = nums[left] + nums[right];\\n            if (sum > target) {\\n\\t\\t\\t    // All numbers to the left of nums[right] add upto a sum greater than target.\\n                count += right - left;\\n                --right;\\n            } else {\\n                ++left;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 968009,
                "title": "o-n-2-clean-sliding-window-solution",
                "content": "Most of the solution is done by first picking a longest edge, then calculating valid pair of edges from the remaining array.(sorted)\\nIn this solution\\n1. Pick shortest edge\\n2. Find the other valid edges \\n\\nWhat is the constraint for finding larger 2 edges?\\n\\nSay, A be the shortest edge and B and C are the other ones.\\n```B - C > A```\\n\\nOh, it is kind of familiar to me...\\nYES! Sliding window problem, we have to find subsequence from the remaining array where last element-first element be the larger from A\\n\\n```\\nclass Solution(object):\\n    def triangleNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        res = 0\\n        \\n        for i in range(len(nums)-2):\\n            \\n            start = i+1\\n            end = i+2\\n            \\n            while end < len(nums):\\n                \\n                if start == end:\\n                    end += 1\\n                    \\n                elif nums[i] > nums[end] - nums[start]:\\n                    res += (end-start)  \\n                    end += 1\\n                    \\n                else:\\n                    start += 1\\n                \\n        return res\\n        \\n```\\n",
                "solutionTags": [],
                "code": "```B - C > A```\n```\\nclass Solution(object):\\n    def triangleNumber(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        res = 0\\n        \\n        for i in range(len(nums)-2):\\n            \\n            start = i+1\\n            end = i+2\\n            \\n            while end < len(nums):\\n                \\n                if start == end:\\n                    end += 1\\n                    \\n                elif nums[i] > nums[end] - nums[start]:\\n                    res += (end-start)  \\n                    end += 1\\n                    \\n                else:\\n                    start += 1\\n                \\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 929010,
                "title": "python-two-pointers-o-n-2",
                "content": "\\n```\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        \"\"\"\\n            a > c - b\\n        \"\"\"\\n        nums = [x for x in nums if x != 0]\\n        nums.sort()\\n        \\n        count = 0\\n        for i in range(len(nums)-2):\\n            j = i + 1\\n            k = i + 2\\n            while j < len(nums)-1:\\n                \\n                while k < len(nums) and nums[i] > nums[k] - nums[j]:\\n                    k += 1\\n                count += k-j-1\\n                j += 1\\n        \\n        return count\\n```\\n\\nTo practice:\\n259. 3Sum Smaller https://leetcode.com/problems/3sum-smaller/\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        \"\"\"\\n            a > c - b\\n        \"\"\"\\n        nums = [x for x in nums if x != 0]\\n        nums.sort()\\n        \\n        count = 0\\n        for i in range(len(nums)-2):\\n            j = i + 1\\n            k = i + 2\\n            while j < len(nums)-1:\\n                \\n                while k < len(nums) and nums[i] > nums[k] - nums[j]:\\n                    k += 1\\n                count += k-j-1\\n                j += 1\\n        \\n        return count\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566092,
                "content": [
                    {
                        "username": "iynaur87",
                        "content": "O(n^2) python solution got TLE.\\nI assume no faster solutions exist, right?"
                    },
                    {
                        "username": "ivsergeev",
                        "content": "O(N) is possible)"
                    },
                    {
                        "username": "speedyy",
                        "content": "Now I am curious, did the code run in 2017?"
                    },
                    {
                        "username": "speedyy",
                        "content": "[@sachin-123](/sachin-123) Today's python is not as it was 6 years ago, maybe it was 'snake' that time?"
                    },
                    {
                        "username": "sachin-123",
                        "content": "you must be doing something wrong ,  my n^2 log(n)  ran correctly"
                    },
                    {
                        "username": "odewolf",
                        "content": "Could someone explain the valid triangle number.\\nI thought it would be valid \\'pythagorian\\' numbers suchas (3, 4,5) because 3^2 + 4^2 = 5^2\\nBut here in the examples they claim that (2,2,3) or (2,3,4) are valid triangles.\\nI am very confused."
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "A traingle is valid only if sum of any two sides is greater than third side. This is what you actually need to check and count such possible triplets. "
                    },
                    {
                        "username": "shubhankar-naik",
                        "content": "pythagoras theorem is only for right angled triangle, here it asks for any valid triangle "
                    },
                    {
                        "username": "soufian19966",
                        "content": "to be honest i am testing the like that if a+b>c & a+c>b & c+b>: , but i keep getting TLE, i am loking for other solution"
                    },
                    {
                        "username": "the_GameChanger",
                        "content": "[@praveen_allam](/praveen_allam) yes correct\\n"
                    },
                    {
                        "username": "praveen_allam",
                        "content": "If a triangle of side lengths a,b and c is said to be valid if, a+b > c, b+c > a and a+c> b.\n"
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "O(n*n) Approach \\nhttps://youtu.be/ZVgYnL4m3Oo"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "what is Triangle number"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "it is a triplet (a,b,c) , where the condition (side1+side2 > side3) strictly holds true for all combinations.\ni.e, a+b >c\nb+c >a\na+c >b"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "As it states in the description: '...we take them (the numbers choosen) as side lengths of a triangle'. For instance (3,3,3) will give you an equilateral triangle, while (3,4,5) yields a right triangle (one of the angles is 90 degree)"
                    },
                    {
                        "username": "abhi1060",
                        "content": "here triangle is valid if two of its side sum is greater than third side.\\nto simplify it first sort sides.\\nthen from 2nd index apply binary seach ober left side of array.\\nadd each case answers and return.\\n![image](https://assets.leetcode.com/users/images/ed1a7b9f-2411-42d0-873e-b36a22ccaa07_1654699314.8672206.png)\\n"
                    },
                    {
                        "username": "AkAsH_Ydv",
                        "content": "I think the test case of this program is based on wrong logic ."
                    },
                    {
                        "username": "little_late",
                        "content": "1st attempt : thought question was talking about right angle triangles. So wrote such code to run in O(n*nlogn). If such question is there on leetcode, Please share link.\\n\\n2nd attempt : got the solution, but why this question is marked here in binary search study plan??"
                    },
                    {
                        "username": "pronit013",
                        "content": "Valid Triangle means if you added length of any 2 side it will be greater than 3rd side length"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "[2,2,3,4]\\nfor this input in the explanation, we can also get the set of [2,2,4] \\ncan anyone explain about that case"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "You can\\'t construct a triangle from [2,2,4] because 2+2 = 4, that\\'s mean, two sides only covers third with no angle (try to draw it on paper). In particular, for constructing a triangle sum of two sides should be greater than third"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Is it similar to 3sum? So tc will be O(n^2)"
                    }
                ]
            },
            {
                "id": 1575538,
                "content": [
                    {
                        "username": "iynaur87",
                        "content": "O(n^2) python solution got TLE.\\nI assume no faster solutions exist, right?"
                    },
                    {
                        "username": "ivsergeev",
                        "content": "O(N) is possible)"
                    },
                    {
                        "username": "speedyy",
                        "content": "Now I am curious, did the code run in 2017?"
                    },
                    {
                        "username": "speedyy",
                        "content": "[@sachin-123](/sachin-123) Today's python is not as it was 6 years ago, maybe it was 'snake' that time?"
                    },
                    {
                        "username": "sachin-123",
                        "content": "you must be doing something wrong ,  my n^2 log(n)  ran correctly"
                    },
                    {
                        "username": "odewolf",
                        "content": "Could someone explain the valid triangle number.\\nI thought it would be valid \\'pythagorian\\' numbers suchas (3, 4,5) because 3^2 + 4^2 = 5^2\\nBut here in the examples they claim that (2,2,3) or (2,3,4) are valid triangles.\\nI am very confused."
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "A traingle is valid only if sum of any two sides is greater than third side. This is what you actually need to check and count such possible triplets. "
                    },
                    {
                        "username": "shubhankar-naik",
                        "content": "pythagoras theorem is only for right angled triangle, here it asks for any valid triangle "
                    },
                    {
                        "username": "soufian19966",
                        "content": "to be honest i am testing the like that if a+b>c & a+c>b & c+b>: , but i keep getting TLE, i am loking for other solution"
                    },
                    {
                        "username": "the_GameChanger",
                        "content": "[@praveen_allam](/praveen_allam) yes correct\\n"
                    },
                    {
                        "username": "praveen_allam",
                        "content": "If a triangle of side lengths a,b and c is said to be valid if, a+b > c, b+c > a and a+c> b.\n"
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "O(n*n) Approach \\nhttps://youtu.be/ZVgYnL4m3Oo"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "what is Triangle number"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "it is a triplet (a,b,c) , where the condition (side1+side2 > side3) strictly holds true for all combinations.\ni.e, a+b >c\nb+c >a\na+c >b"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "As it states in the description: '...we take them (the numbers choosen) as side lengths of a triangle'. For instance (3,3,3) will give you an equilateral triangle, while (3,4,5) yields a right triangle (one of the angles is 90 degree)"
                    },
                    {
                        "username": "abhi1060",
                        "content": "here triangle is valid if two of its side sum is greater than third side.\\nto simplify it first sort sides.\\nthen from 2nd index apply binary seach ober left side of array.\\nadd each case answers and return.\\n![image](https://assets.leetcode.com/users/images/ed1a7b9f-2411-42d0-873e-b36a22ccaa07_1654699314.8672206.png)\\n"
                    },
                    {
                        "username": "AkAsH_Ydv",
                        "content": "I think the test case of this program is based on wrong logic ."
                    },
                    {
                        "username": "little_late",
                        "content": "1st attempt : thought question was talking about right angle triangles. So wrote such code to run in O(n*nlogn). If such question is there on leetcode, Please share link.\\n\\n2nd attempt : got the solution, but why this question is marked here in binary search study plan??"
                    },
                    {
                        "username": "pronit013",
                        "content": "Valid Triangle means if you added length of any 2 side it will be greater than 3rd side length"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "[2,2,3,4]\\nfor this input in the explanation, we can also get the set of [2,2,4] \\ncan anyone explain about that case"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "You can\\'t construct a triangle from [2,2,4] because 2+2 = 4, that\\'s mean, two sides only covers third with no angle (try to draw it on paper). In particular, for constructing a triangle sum of two sides should be greater than third"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Is it similar to 3sum? So tc will be O(n^2)"
                    }
                ]
            },
            {
                "id": 1566614,
                "content": [
                    {
                        "username": "iynaur87",
                        "content": "O(n^2) python solution got TLE.\\nI assume no faster solutions exist, right?"
                    },
                    {
                        "username": "ivsergeev",
                        "content": "O(N) is possible)"
                    },
                    {
                        "username": "speedyy",
                        "content": "Now I am curious, did the code run in 2017?"
                    },
                    {
                        "username": "speedyy",
                        "content": "[@sachin-123](/sachin-123) Today's python is not as it was 6 years ago, maybe it was 'snake' that time?"
                    },
                    {
                        "username": "sachin-123",
                        "content": "you must be doing something wrong ,  my n^2 log(n)  ran correctly"
                    },
                    {
                        "username": "odewolf",
                        "content": "Could someone explain the valid triangle number.\\nI thought it would be valid \\'pythagorian\\' numbers suchas (3, 4,5) because 3^2 + 4^2 = 5^2\\nBut here in the examples they claim that (2,2,3) or (2,3,4) are valid triangles.\\nI am very confused."
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "A traingle is valid only if sum of any two sides is greater than third side. This is what you actually need to check and count such possible triplets. "
                    },
                    {
                        "username": "shubhankar-naik",
                        "content": "pythagoras theorem is only for right angled triangle, here it asks for any valid triangle "
                    },
                    {
                        "username": "soufian19966",
                        "content": "to be honest i am testing the like that if a+b>c & a+c>b & c+b>: , but i keep getting TLE, i am loking for other solution"
                    },
                    {
                        "username": "the_GameChanger",
                        "content": "[@praveen_allam](/praveen_allam) yes correct\\n"
                    },
                    {
                        "username": "praveen_allam",
                        "content": "If a triangle of side lengths a,b and c is said to be valid if, a+b > c, b+c > a and a+c> b.\n"
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "O(n*n) Approach \\nhttps://youtu.be/ZVgYnL4m3Oo"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "what is Triangle number"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "it is a triplet (a,b,c) , where the condition (side1+side2 > side3) strictly holds true for all combinations.\ni.e, a+b >c\nb+c >a\na+c >b"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "As it states in the description: '...we take them (the numbers choosen) as side lengths of a triangle'. For instance (3,3,3) will give you an equilateral triangle, while (3,4,5) yields a right triangle (one of the angles is 90 degree)"
                    },
                    {
                        "username": "abhi1060",
                        "content": "here triangle is valid if two of its side sum is greater than third side.\\nto simplify it first sort sides.\\nthen from 2nd index apply binary seach ober left side of array.\\nadd each case answers and return.\\n![image](https://assets.leetcode.com/users/images/ed1a7b9f-2411-42d0-873e-b36a22ccaa07_1654699314.8672206.png)\\n"
                    },
                    {
                        "username": "AkAsH_Ydv",
                        "content": "I think the test case of this program is based on wrong logic ."
                    },
                    {
                        "username": "little_late",
                        "content": "1st attempt : thought question was talking about right angle triangles. So wrote such code to run in O(n*nlogn). If such question is there on leetcode, Please share link.\\n\\n2nd attempt : got the solution, but why this question is marked here in binary search study plan??"
                    },
                    {
                        "username": "pronit013",
                        "content": "Valid Triangle means if you added length of any 2 side it will be greater than 3rd side length"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "[2,2,3,4]\\nfor this input in the explanation, we can also get the set of [2,2,4] \\ncan anyone explain about that case"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "You can\\'t construct a triangle from [2,2,4] because 2+2 = 4, that\\'s mean, two sides only covers third with no angle (try to draw it on paper). In particular, for constructing a triangle sum of two sides should be greater than third"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Is it similar to 3sum? So tc will be O(n^2)"
                    }
                ]
            },
            {
                "id": 1687409,
                "content": [
                    {
                        "username": "iynaur87",
                        "content": "O(n^2) python solution got TLE.\\nI assume no faster solutions exist, right?"
                    },
                    {
                        "username": "ivsergeev",
                        "content": "O(N) is possible)"
                    },
                    {
                        "username": "speedyy",
                        "content": "Now I am curious, did the code run in 2017?"
                    },
                    {
                        "username": "speedyy",
                        "content": "[@sachin-123](/sachin-123) Today's python is not as it was 6 years ago, maybe it was 'snake' that time?"
                    },
                    {
                        "username": "sachin-123",
                        "content": "you must be doing something wrong ,  my n^2 log(n)  ran correctly"
                    },
                    {
                        "username": "odewolf",
                        "content": "Could someone explain the valid triangle number.\\nI thought it would be valid \\'pythagorian\\' numbers suchas (3, 4,5) because 3^2 + 4^2 = 5^2\\nBut here in the examples they claim that (2,2,3) or (2,3,4) are valid triangles.\\nI am very confused."
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "A traingle is valid only if sum of any two sides is greater than third side. This is what you actually need to check and count such possible triplets. "
                    },
                    {
                        "username": "shubhankar-naik",
                        "content": "pythagoras theorem is only for right angled triangle, here it asks for any valid triangle "
                    },
                    {
                        "username": "soufian19966",
                        "content": "to be honest i am testing the like that if a+b>c & a+c>b & c+b>: , but i keep getting TLE, i am loking for other solution"
                    },
                    {
                        "username": "the_GameChanger",
                        "content": "[@praveen_allam](/praveen_allam) yes correct\\n"
                    },
                    {
                        "username": "praveen_allam",
                        "content": "If a triangle of side lengths a,b and c is said to be valid if, a+b > c, b+c > a and a+c> b.\n"
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "O(n*n) Approach \\nhttps://youtu.be/ZVgYnL4m3Oo"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "what is Triangle number"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "it is a triplet (a,b,c) , where the condition (side1+side2 > side3) strictly holds true for all combinations.\ni.e, a+b >c\nb+c >a\na+c >b"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "As it states in the description: '...we take them (the numbers choosen) as side lengths of a triangle'. For instance (3,3,3) will give you an equilateral triangle, while (3,4,5) yields a right triangle (one of the angles is 90 degree)"
                    },
                    {
                        "username": "abhi1060",
                        "content": "here triangle is valid if two of its side sum is greater than third side.\\nto simplify it first sort sides.\\nthen from 2nd index apply binary seach ober left side of array.\\nadd each case answers and return.\\n![image](https://assets.leetcode.com/users/images/ed1a7b9f-2411-42d0-873e-b36a22ccaa07_1654699314.8672206.png)\\n"
                    },
                    {
                        "username": "AkAsH_Ydv",
                        "content": "I think the test case of this program is based on wrong logic ."
                    },
                    {
                        "username": "little_late",
                        "content": "1st attempt : thought question was talking about right angle triangles. So wrote such code to run in O(n*nlogn). If such question is there on leetcode, Please share link.\\n\\n2nd attempt : got the solution, but why this question is marked here in binary search study plan??"
                    },
                    {
                        "username": "pronit013",
                        "content": "Valid Triangle means if you added length of any 2 side it will be greater than 3rd side length"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "[2,2,3,4]\\nfor this input in the explanation, we can also get the set of [2,2,4] \\ncan anyone explain about that case"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "You can\\'t construct a triangle from [2,2,4] because 2+2 = 4, that\\'s mean, two sides only covers third with no angle (try to draw it on paper). In particular, for constructing a triangle sum of two sides should be greater than third"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Is it similar to 3sum? So tc will be O(n^2)"
                    }
                ]
            },
            {
                "id": 1576868,
                "content": [
                    {
                        "username": "iynaur87",
                        "content": "O(n^2) python solution got TLE.\\nI assume no faster solutions exist, right?"
                    },
                    {
                        "username": "ivsergeev",
                        "content": "O(N) is possible)"
                    },
                    {
                        "username": "speedyy",
                        "content": "Now I am curious, did the code run in 2017?"
                    },
                    {
                        "username": "speedyy",
                        "content": "[@sachin-123](/sachin-123) Today's python is not as it was 6 years ago, maybe it was 'snake' that time?"
                    },
                    {
                        "username": "sachin-123",
                        "content": "you must be doing something wrong ,  my n^2 log(n)  ran correctly"
                    },
                    {
                        "username": "odewolf",
                        "content": "Could someone explain the valid triangle number.\\nI thought it would be valid \\'pythagorian\\' numbers suchas (3, 4,5) because 3^2 + 4^2 = 5^2\\nBut here in the examples they claim that (2,2,3) or (2,3,4) are valid triangles.\\nI am very confused."
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "A traingle is valid only if sum of any two sides is greater than third side. This is what you actually need to check and count such possible triplets. "
                    },
                    {
                        "username": "shubhankar-naik",
                        "content": "pythagoras theorem is only for right angled triangle, here it asks for any valid triangle "
                    },
                    {
                        "username": "soufian19966",
                        "content": "to be honest i am testing the like that if a+b>c & a+c>b & c+b>: , but i keep getting TLE, i am loking for other solution"
                    },
                    {
                        "username": "the_GameChanger",
                        "content": "[@praveen_allam](/praveen_allam) yes correct\\n"
                    },
                    {
                        "username": "praveen_allam",
                        "content": "If a triangle of side lengths a,b and c is said to be valid if, a+b > c, b+c > a and a+c> b.\n"
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "O(n*n) Approach \\nhttps://youtu.be/ZVgYnL4m3Oo"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "what is Triangle number"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "it is a triplet (a,b,c) , where the condition (side1+side2 > side3) strictly holds true for all combinations.\ni.e, a+b >c\nb+c >a\na+c >b"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "As it states in the description: '...we take them (the numbers choosen) as side lengths of a triangle'. For instance (3,3,3) will give you an equilateral triangle, while (3,4,5) yields a right triangle (one of the angles is 90 degree)"
                    },
                    {
                        "username": "abhi1060",
                        "content": "here triangle is valid if two of its side sum is greater than third side.\\nto simplify it first sort sides.\\nthen from 2nd index apply binary seach ober left side of array.\\nadd each case answers and return.\\n![image](https://assets.leetcode.com/users/images/ed1a7b9f-2411-42d0-873e-b36a22ccaa07_1654699314.8672206.png)\\n"
                    },
                    {
                        "username": "AkAsH_Ydv",
                        "content": "I think the test case of this program is based on wrong logic ."
                    },
                    {
                        "username": "little_late",
                        "content": "1st attempt : thought question was talking about right angle triangles. So wrote such code to run in O(n*nlogn). If such question is there on leetcode, Please share link.\\n\\n2nd attempt : got the solution, but why this question is marked here in binary search study plan??"
                    },
                    {
                        "username": "pronit013",
                        "content": "Valid Triangle means if you added length of any 2 side it will be greater than 3rd side length"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "[2,2,3,4]\\nfor this input in the explanation, we can also get the set of [2,2,4] \\ncan anyone explain about that case"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "You can\\'t construct a triangle from [2,2,4] because 2+2 = 4, that\\'s mean, two sides only covers third with no angle (try to draw it on paper). In particular, for constructing a triangle sum of two sides should be greater than third"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Is it similar to 3sum? So tc will be O(n^2)"
                    }
                ]
            },
            {
                "id": 2060299,
                "content": [
                    {
                        "username": "iynaur87",
                        "content": "O(n^2) python solution got TLE.\\nI assume no faster solutions exist, right?"
                    },
                    {
                        "username": "ivsergeev",
                        "content": "O(N) is possible)"
                    },
                    {
                        "username": "speedyy",
                        "content": "Now I am curious, did the code run in 2017?"
                    },
                    {
                        "username": "speedyy",
                        "content": "[@sachin-123](/sachin-123) Today's python is not as it was 6 years ago, maybe it was 'snake' that time?"
                    },
                    {
                        "username": "sachin-123",
                        "content": "you must be doing something wrong ,  my n^2 log(n)  ran correctly"
                    },
                    {
                        "username": "odewolf",
                        "content": "Could someone explain the valid triangle number.\\nI thought it would be valid \\'pythagorian\\' numbers suchas (3, 4,5) because 3^2 + 4^2 = 5^2\\nBut here in the examples they claim that (2,2,3) or (2,3,4) are valid triangles.\\nI am very confused."
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "A traingle is valid only if sum of any two sides is greater than third side. This is what you actually need to check and count such possible triplets. "
                    },
                    {
                        "username": "shubhankar-naik",
                        "content": "pythagoras theorem is only for right angled triangle, here it asks for any valid triangle "
                    },
                    {
                        "username": "soufian19966",
                        "content": "to be honest i am testing the like that if a+b>c & a+c>b & c+b>: , but i keep getting TLE, i am loking for other solution"
                    },
                    {
                        "username": "the_GameChanger",
                        "content": "[@praveen_allam](/praveen_allam) yes correct\\n"
                    },
                    {
                        "username": "praveen_allam",
                        "content": "If a triangle of side lengths a,b and c is said to be valid if, a+b > c, b+c > a and a+c> b.\n"
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "O(n*n) Approach \\nhttps://youtu.be/ZVgYnL4m3Oo"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "what is Triangle number"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "it is a triplet (a,b,c) , where the condition (side1+side2 > side3) strictly holds true for all combinations.\ni.e, a+b >c\nb+c >a\na+c >b"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "As it states in the description: '...we take them (the numbers choosen) as side lengths of a triangle'. For instance (3,3,3) will give you an equilateral triangle, while (3,4,5) yields a right triangle (one of the angles is 90 degree)"
                    },
                    {
                        "username": "abhi1060",
                        "content": "here triangle is valid if two of its side sum is greater than third side.\\nto simplify it first sort sides.\\nthen from 2nd index apply binary seach ober left side of array.\\nadd each case answers and return.\\n![image](https://assets.leetcode.com/users/images/ed1a7b9f-2411-42d0-873e-b36a22ccaa07_1654699314.8672206.png)\\n"
                    },
                    {
                        "username": "AkAsH_Ydv",
                        "content": "I think the test case of this program is based on wrong logic ."
                    },
                    {
                        "username": "little_late",
                        "content": "1st attempt : thought question was talking about right angle triangles. So wrote such code to run in O(n*nlogn). If such question is there on leetcode, Please share link.\\n\\n2nd attempt : got the solution, but why this question is marked here in binary search study plan??"
                    },
                    {
                        "username": "pronit013",
                        "content": "Valid Triangle means if you added length of any 2 side it will be greater than 3rd side length"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "[2,2,3,4]\\nfor this input in the explanation, we can also get the set of [2,2,4] \\ncan anyone explain about that case"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "You can\\'t construct a triangle from [2,2,4] because 2+2 = 4, that\\'s mean, two sides only covers third with no angle (try to draw it on paper). In particular, for constructing a triangle sum of two sides should be greater than third"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Is it similar to 3sum? So tc will be O(n^2)"
                    }
                ]
            },
            {
                "id": 2033884,
                "content": [
                    {
                        "username": "iynaur87",
                        "content": "O(n^2) python solution got TLE.\\nI assume no faster solutions exist, right?"
                    },
                    {
                        "username": "ivsergeev",
                        "content": "O(N) is possible)"
                    },
                    {
                        "username": "speedyy",
                        "content": "Now I am curious, did the code run in 2017?"
                    },
                    {
                        "username": "speedyy",
                        "content": "[@sachin-123](/sachin-123) Today's python is not as it was 6 years ago, maybe it was 'snake' that time?"
                    },
                    {
                        "username": "sachin-123",
                        "content": "you must be doing something wrong ,  my n^2 log(n)  ran correctly"
                    },
                    {
                        "username": "odewolf",
                        "content": "Could someone explain the valid triangle number.\\nI thought it would be valid \\'pythagorian\\' numbers suchas (3, 4,5) because 3^2 + 4^2 = 5^2\\nBut here in the examples they claim that (2,2,3) or (2,3,4) are valid triangles.\\nI am very confused."
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "A traingle is valid only if sum of any two sides is greater than third side. This is what you actually need to check and count such possible triplets. "
                    },
                    {
                        "username": "shubhankar-naik",
                        "content": "pythagoras theorem is only for right angled triangle, here it asks for any valid triangle "
                    },
                    {
                        "username": "soufian19966",
                        "content": "to be honest i am testing the like that if a+b>c & a+c>b & c+b>: , but i keep getting TLE, i am loking for other solution"
                    },
                    {
                        "username": "the_GameChanger",
                        "content": "[@praveen_allam](/praveen_allam) yes correct\\n"
                    },
                    {
                        "username": "praveen_allam",
                        "content": "If a triangle of side lengths a,b and c is said to be valid if, a+b > c, b+c > a and a+c> b.\n"
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "O(n*n) Approach \\nhttps://youtu.be/ZVgYnL4m3Oo"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "what is Triangle number"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "it is a triplet (a,b,c) , where the condition (side1+side2 > side3) strictly holds true for all combinations.\ni.e, a+b >c\nb+c >a\na+c >b"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "As it states in the description: '...we take them (the numbers choosen) as side lengths of a triangle'. For instance (3,3,3) will give you an equilateral triangle, while (3,4,5) yields a right triangle (one of the angles is 90 degree)"
                    },
                    {
                        "username": "abhi1060",
                        "content": "here triangle is valid if two of its side sum is greater than third side.\\nto simplify it first sort sides.\\nthen from 2nd index apply binary seach ober left side of array.\\nadd each case answers and return.\\n![image](https://assets.leetcode.com/users/images/ed1a7b9f-2411-42d0-873e-b36a22ccaa07_1654699314.8672206.png)\\n"
                    },
                    {
                        "username": "AkAsH_Ydv",
                        "content": "I think the test case of this program is based on wrong logic ."
                    },
                    {
                        "username": "little_late",
                        "content": "1st attempt : thought question was talking about right angle triangles. So wrote such code to run in O(n*nlogn). If such question is there on leetcode, Please share link.\\n\\n2nd attempt : got the solution, but why this question is marked here in binary search study plan??"
                    },
                    {
                        "username": "pronit013",
                        "content": "Valid Triangle means if you added length of any 2 side it will be greater than 3rd side length"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "[2,2,3,4]\\nfor this input in the explanation, we can also get the set of [2,2,4] \\ncan anyone explain about that case"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "You can\\'t construct a triangle from [2,2,4] because 2+2 = 4, that\\'s mean, two sides only covers third with no angle (try to draw it on paper). In particular, for constructing a triangle sum of two sides should be greater than third"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Is it similar to 3sum? So tc will be O(n^2)"
                    }
                ]
            },
            {
                "id": 1909553,
                "content": [
                    {
                        "username": "iynaur87",
                        "content": "O(n^2) python solution got TLE.\\nI assume no faster solutions exist, right?"
                    },
                    {
                        "username": "ivsergeev",
                        "content": "O(N) is possible)"
                    },
                    {
                        "username": "speedyy",
                        "content": "Now I am curious, did the code run in 2017?"
                    },
                    {
                        "username": "speedyy",
                        "content": "[@sachin-123](/sachin-123) Today's python is not as it was 6 years ago, maybe it was 'snake' that time?"
                    },
                    {
                        "username": "sachin-123",
                        "content": "you must be doing something wrong ,  my n^2 log(n)  ran correctly"
                    },
                    {
                        "username": "odewolf",
                        "content": "Could someone explain the valid triangle number.\\nI thought it would be valid \\'pythagorian\\' numbers suchas (3, 4,5) because 3^2 + 4^2 = 5^2\\nBut here in the examples they claim that (2,2,3) or (2,3,4) are valid triangles.\\nI am very confused."
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "A traingle is valid only if sum of any two sides is greater than third side. This is what you actually need to check and count such possible triplets. "
                    },
                    {
                        "username": "shubhankar-naik",
                        "content": "pythagoras theorem is only for right angled triangle, here it asks for any valid triangle "
                    },
                    {
                        "username": "soufian19966",
                        "content": "to be honest i am testing the like that if a+b>c & a+c>b & c+b>: , but i keep getting TLE, i am loking for other solution"
                    },
                    {
                        "username": "the_GameChanger",
                        "content": "[@praveen_allam](/praveen_allam) yes correct\\n"
                    },
                    {
                        "username": "praveen_allam",
                        "content": "If a triangle of side lengths a,b and c is said to be valid if, a+b > c, b+c > a and a+c> b.\n"
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "O(n*n) Approach \\nhttps://youtu.be/ZVgYnL4m3Oo"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "what is Triangle number"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "it is a triplet (a,b,c) , where the condition (side1+side2 > side3) strictly holds true for all combinations.\ni.e, a+b >c\nb+c >a\na+c >b"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "As it states in the description: '...we take them (the numbers choosen) as side lengths of a triangle'. For instance (3,3,3) will give you an equilateral triangle, while (3,4,5) yields a right triangle (one of the angles is 90 degree)"
                    },
                    {
                        "username": "abhi1060",
                        "content": "here triangle is valid if two of its side sum is greater than third side.\\nto simplify it first sort sides.\\nthen from 2nd index apply binary seach ober left side of array.\\nadd each case answers and return.\\n![image](https://assets.leetcode.com/users/images/ed1a7b9f-2411-42d0-873e-b36a22ccaa07_1654699314.8672206.png)\\n"
                    },
                    {
                        "username": "AkAsH_Ydv",
                        "content": "I think the test case of this program is based on wrong logic ."
                    },
                    {
                        "username": "little_late",
                        "content": "1st attempt : thought question was talking about right angle triangles. So wrote such code to run in O(n*nlogn). If such question is there on leetcode, Please share link.\\n\\n2nd attempt : got the solution, but why this question is marked here in binary search study plan??"
                    },
                    {
                        "username": "pronit013",
                        "content": "Valid Triangle means if you added length of any 2 side it will be greater than 3rd side length"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "[2,2,3,4]\\nfor this input in the explanation, we can also get the set of [2,2,4] \\ncan anyone explain about that case"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "You can\\'t construct a triangle from [2,2,4] because 2+2 = 4, that\\'s mean, two sides only covers third with no angle (try to draw it on paper). In particular, for constructing a triangle sum of two sides should be greater than third"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Is it similar to 3sum? So tc will be O(n^2)"
                    }
                ]
            },
            {
                "id": 1906837,
                "content": [
                    {
                        "username": "iynaur87",
                        "content": "O(n^2) python solution got TLE.\\nI assume no faster solutions exist, right?"
                    },
                    {
                        "username": "ivsergeev",
                        "content": "O(N) is possible)"
                    },
                    {
                        "username": "speedyy",
                        "content": "Now I am curious, did the code run in 2017?"
                    },
                    {
                        "username": "speedyy",
                        "content": "[@sachin-123](/sachin-123) Today's python is not as it was 6 years ago, maybe it was 'snake' that time?"
                    },
                    {
                        "username": "sachin-123",
                        "content": "you must be doing something wrong ,  my n^2 log(n)  ran correctly"
                    },
                    {
                        "username": "odewolf",
                        "content": "Could someone explain the valid triangle number.\\nI thought it would be valid \\'pythagorian\\' numbers suchas (3, 4,5) because 3^2 + 4^2 = 5^2\\nBut here in the examples they claim that (2,2,3) or (2,3,4) are valid triangles.\\nI am very confused."
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "A traingle is valid only if sum of any two sides is greater than third side. This is what you actually need to check and count such possible triplets. "
                    },
                    {
                        "username": "shubhankar-naik",
                        "content": "pythagoras theorem is only for right angled triangle, here it asks for any valid triangle "
                    },
                    {
                        "username": "soufian19966",
                        "content": "to be honest i am testing the like that if a+b>c & a+c>b & c+b>: , but i keep getting TLE, i am loking for other solution"
                    },
                    {
                        "username": "the_GameChanger",
                        "content": "[@praveen_allam](/praveen_allam) yes correct\\n"
                    },
                    {
                        "username": "praveen_allam",
                        "content": "If a triangle of side lengths a,b and c is said to be valid if, a+b > c, b+c > a and a+c> b.\n"
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "O(n*n) Approach \\nhttps://youtu.be/ZVgYnL4m3Oo"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "what is Triangle number"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "it is a triplet (a,b,c) , where the condition (side1+side2 > side3) strictly holds true for all combinations.\ni.e, a+b >c\nb+c >a\na+c >b"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "As it states in the description: '...we take them (the numbers choosen) as side lengths of a triangle'. For instance (3,3,3) will give you an equilateral triangle, while (3,4,5) yields a right triangle (one of the angles is 90 degree)"
                    },
                    {
                        "username": "abhi1060",
                        "content": "here triangle is valid if two of its side sum is greater than third side.\\nto simplify it first sort sides.\\nthen from 2nd index apply binary seach ober left side of array.\\nadd each case answers and return.\\n![image](https://assets.leetcode.com/users/images/ed1a7b9f-2411-42d0-873e-b36a22ccaa07_1654699314.8672206.png)\\n"
                    },
                    {
                        "username": "AkAsH_Ydv",
                        "content": "I think the test case of this program is based on wrong logic ."
                    },
                    {
                        "username": "little_late",
                        "content": "1st attempt : thought question was talking about right angle triangles. So wrote such code to run in O(n*nlogn). If such question is there on leetcode, Please share link.\\n\\n2nd attempt : got the solution, but why this question is marked here in binary search study plan??"
                    },
                    {
                        "username": "pronit013",
                        "content": "Valid Triangle means if you added length of any 2 side it will be greater than 3rd side length"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "[2,2,3,4]\\nfor this input in the explanation, we can also get the set of [2,2,4] \\ncan anyone explain about that case"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "You can\\'t construct a triangle from [2,2,4] because 2+2 = 4, that\\'s mean, two sides only covers third with no angle (try to draw it on paper). In particular, for constructing a triangle sum of two sides should be greater than third"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Is it similar to 3sum? So tc will be O(n^2)"
                    }
                ]
            },
            {
                "id": 1897305,
                "content": [
                    {
                        "username": "iynaur87",
                        "content": "O(n^2) python solution got TLE.\\nI assume no faster solutions exist, right?"
                    },
                    {
                        "username": "ivsergeev",
                        "content": "O(N) is possible)"
                    },
                    {
                        "username": "speedyy",
                        "content": "Now I am curious, did the code run in 2017?"
                    },
                    {
                        "username": "speedyy",
                        "content": "[@sachin-123](/sachin-123) Today's python is not as it was 6 years ago, maybe it was 'snake' that time?"
                    },
                    {
                        "username": "sachin-123",
                        "content": "you must be doing something wrong ,  my n^2 log(n)  ran correctly"
                    },
                    {
                        "username": "odewolf",
                        "content": "Could someone explain the valid triangle number.\\nI thought it would be valid \\'pythagorian\\' numbers suchas (3, 4,5) because 3^2 + 4^2 = 5^2\\nBut here in the examples they claim that (2,2,3) or (2,3,4) are valid triangles.\\nI am very confused."
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "A traingle is valid only if sum of any two sides is greater than third side. This is what you actually need to check and count such possible triplets. "
                    },
                    {
                        "username": "shubhankar-naik",
                        "content": "pythagoras theorem is only for right angled triangle, here it asks for any valid triangle "
                    },
                    {
                        "username": "soufian19966",
                        "content": "to be honest i am testing the like that if a+b>c & a+c>b & c+b>: , but i keep getting TLE, i am loking for other solution"
                    },
                    {
                        "username": "the_GameChanger",
                        "content": "[@praveen_allam](/praveen_allam) yes correct\\n"
                    },
                    {
                        "username": "praveen_allam",
                        "content": "If a triangle of side lengths a,b and c is said to be valid if, a+b > c, b+c > a and a+c> b.\n"
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "O(n*n) Approach \\nhttps://youtu.be/ZVgYnL4m3Oo"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "what is Triangle number"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "it is a triplet (a,b,c) , where the condition (side1+side2 > side3) strictly holds true for all combinations.\ni.e, a+b >c\nb+c >a\na+c >b"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "As it states in the description: '...we take them (the numbers choosen) as side lengths of a triangle'. For instance (3,3,3) will give you an equilateral triangle, while (3,4,5) yields a right triangle (one of the angles is 90 degree)"
                    },
                    {
                        "username": "abhi1060",
                        "content": "here triangle is valid if two of its side sum is greater than third side.\\nto simplify it first sort sides.\\nthen from 2nd index apply binary seach ober left side of array.\\nadd each case answers and return.\\n![image](https://assets.leetcode.com/users/images/ed1a7b9f-2411-42d0-873e-b36a22ccaa07_1654699314.8672206.png)\\n"
                    },
                    {
                        "username": "AkAsH_Ydv",
                        "content": "I think the test case of this program is based on wrong logic ."
                    },
                    {
                        "username": "little_late",
                        "content": "1st attempt : thought question was talking about right angle triangles. So wrote such code to run in O(n*nlogn). If such question is there on leetcode, Please share link.\\n\\n2nd attempt : got the solution, but why this question is marked here in binary search study plan??"
                    },
                    {
                        "username": "pronit013",
                        "content": "Valid Triangle means if you added length of any 2 side it will be greater than 3rd side length"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "[2,2,3,4]\\nfor this input in the explanation, we can also get the set of [2,2,4] \\ncan anyone explain about that case"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "You can\\'t construct a triangle from [2,2,4] because 2+2 = 4, that\\'s mean, two sides only covers third with no angle (try to draw it on paper). In particular, for constructing a triangle sum of two sides should be greater than third"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Is it similar to 3sum? So tc will be O(n^2)"
                    }
                ]
            },
            {
                "id": 1566092,
                "content": [
                    {
                        "username": "iynaur87",
                        "content": "O(n^2) python solution got TLE.\\nI assume no faster solutions exist, right?"
                    },
                    {
                        "username": "ivsergeev",
                        "content": "O(N) is possible)"
                    },
                    {
                        "username": "speedyy",
                        "content": "Now I am curious, did the code run in 2017?"
                    },
                    {
                        "username": "speedyy",
                        "content": "[@sachin-123](/sachin-123) Today's python is not as it was 6 years ago, maybe it was 'snake' that time?"
                    },
                    {
                        "username": "sachin-123",
                        "content": "you must be doing something wrong ,  my n^2 log(n)  ran correctly"
                    },
                    {
                        "username": "odewolf",
                        "content": "Could someone explain the valid triangle number.\\nI thought it would be valid \\'pythagorian\\' numbers suchas (3, 4,5) because 3^2 + 4^2 = 5^2\\nBut here in the examples they claim that (2,2,3) or (2,3,4) are valid triangles.\\nI am very confused."
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "A traingle is valid only if sum of any two sides is greater than third side. This is what you actually need to check and count such possible triplets. "
                    },
                    {
                        "username": "shubhankar-naik",
                        "content": "pythagoras theorem is only for right angled triangle, here it asks for any valid triangle "
                    },
                    {
                        "username": "soufian19966",
                        "content": "to be honest i am testing the like that if a+b>c & a+c>b & c+b>: , but i keep getting TLE, i am loking for other solution"
                    },
                    {
                        "username": "the_GameChanger",
                        "content": "[@praveen_allam](/praveen_allam) yes correct\\n"
                    },
                    {
                        "username": "praveen_allam",
                        "content": "If a triangle of side lengths a,b and c is said to be valid if, a+b > c, b+c > a and a+c> b.\n"
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "O(n*n) Approach \\nhttps://youtu.be/ZVgYnL4m3Oo"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "what is Triangle number"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "it is a triplet (a,b,c) , where the condition (side1+side2 > side3) strictly holds true for all combinations.\ni.e, a+b >c\nb+c >a\na+c >b"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "As it states in the description: '...we take them (the numbers choosen) as side lengths of a triangle'. For instance (3,3,3) will give you an equilateral triangle, while (3,4,5) yields a right triangle (one of the angles is 90 degree)"
                    },
                    {
                        "username": "abhi1060",
                        "content": "here triangle is valid if two of its side sum is greater than third side.\\nto simplify it first sort sides.\\nthen from 2nd index apply binary seach ober left side of array.\\nadd each case answers and return.\\n![image](https://assets.leetcode.com/users/images/ed1a7b9f-2411-42d0-873e-b36a22ccaa07_1654699314.8672206.png)\\n"
                    },
                    {
                        "username": "AkAsH_Ydv",
                        "content": "I think the test case of this program is based on wrong logic ."
                    },
                    {
                        "username": "little_late",
                        "content": "1st attempt : thought question was talking about right angle triangles. So wrote such code to run in O(n*nlogn). If such question is there on leetcode, Please share link.\\n\\n2nd attempt : got the solution, but why this question is marked here in binary search study plan??"
                    },
                    {
                        "username": "pronit013",
                        "content": "Valid Triangle means if you added length of any 2 side it will be greater than 3rd side length"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "[2,2,3,4]\\nfor this input in the explanation, we can also get the set of [2,2,4] \\ncan anyone explain about that case"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "You can\\'t construct a triangle from [2,2,4] because 2+2 = 4, that\\'s mean, two sides only covers third with no angle (try to draw it on paper). In particular, for constructing a triangle sum of two sides should be greater than third"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Is it similar to 3sum? So tc will be O(n^2)"
                    }
                ]
            },
            {
                "id": 1575538,
                "content": [
                    {
                        "username": "iynaur87",
                        "content": "O(n^2) python solution got TLE.\\nI assume no faster solutions exist, right?"
                    },
                    {
                        "username": "ivsergeev",
                        "content": "O(N) is possible)"
                    },
                    {
                        "username": "speedyy",
                        "content": "Now I am curious, did the code run in 2017?"
                    },
                    {
                        "username": "speedyy",
                        "content": "[@sachin-123](/sachin-123) Today's python is not as it was 6 years ago, maybe it was 'snake' that time?"
                    },
                    {
                        "username": "sachin-123",
                        "content": "you must be doing something wrong ,  my n^2 log(n)  ran correctly"
                    },
                    {
                        "username": "odewolf",
                        "content": "Could someone explain the valid triangle number.\\nI thought it would be valid \\'pythagorian\\' numbers suchas (3, 4,5) because 3^2 + 4^2 = 5^2\\nBut here in the examples they claim that (2,2,3) or (2,3,4) are valid triangles.\\nI am very confused."
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "A traingle is valid only if sum of any two sides is greater than third side. This is what you actually need to check and count such possible triplets. "
                    },
                    {
                        "username": "shubhankar-naik",
                        "content": "pythagoras theorem is only for right angled triangle, here it asks for any valid triangle "
                    },
                    {
                        "username": "soufian19966",
                        "content": "to be honest i am testing the like that if a+b>c & a+c>b & c+b>: , but i keep getting TLE, i am loking for other solution"
                    },
                    {
                        "username": "the_GameChanger",
                        "content": "[@praveen_allam](/praveen_allam) yes correct\\n"
                    },
                    {
                        "username": "praveen_allam",
                        "content": "If a triangle of side lengths a,b and c is said to be valid if, a+b > c, b+c > a and a+c> b.\n"
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "O(n*n) Approach \\nhttps://youtu.be/ZVgYnL4m3Oo"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "what is Triangle number"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "it is a triplet (a,b,c) , where the condition (side1+side2 > side3) strictly holds true for all combinations.\ni.e, a+b >c\nb+c >a\na+c >b"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "As it states in the description: '...we take them (the numbers choosen) as side lengths of a triangle'. For instance (3,3,3) will give you an equilateral triangle, while (3,4,5) yields a right triangle (one of the angles is 90 degree)"
                    },
                    {
                        "username": "abhi1060",
                        "content": "here triangle is valid if two of its side sum is greater than third side.\\nto simplify it first sort sides.\\nthen from 2nd index apply binary seach ober left side of array.\\nadd each case answers and return.\\n![image](https://assets.leetcode.com/users/images/ed1a7b9f-2411-42d0-873e-b36a22ccaa07_1654699314.8672206.png)\\n"
                    },
                    {
                        "username": "AkAsH_Ydv",
                        "content": "I think the test case of this program is based on wrong logic ."
                    },
                    {
                        "username": "little_late",
                        "content": "1st attempt : thought question was talking about right angle triangles. So wrote such code to run in O(n*nlogn). If such question is there on leetcode, Please share link.\\n\\n2nd attempt : got the solution, but why this question is marked here in binary search study plan??"
                    },
                    {
                        "username": "pronit013",
                        "content": "Valid Triangle means if you added length of any 2 side it will be greater than 3rd side length"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "[2,2,3,4]\\nfor this input in the explanation, we can also get the set of [2,2,4] \\ncan anyone explain about that case"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "You can\\'t construct a triangle from [2,2,4] because 2+2 = 4, that\\'s mean, two sides only covers third with no angle (try to draw it on paper). In particular, for constructing a triangle sum of two sides should be greater than third"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Is it similar to 3sum? So tc will be O(n^2)"
                    }
                ]
            },
            {
                "id": 1566614,
                "content": [
                    {
                        "username": "iynaur87",
                        "content": "O(n^2) python solution got TLE.\\nI assume no faster solutions exist, right?"
                    },
                    {
                        "username": "ivsergeev",
                        "content": "O(N) is possible)"
                    },
                    {
                        "username": "speedyy",
                        "content": "Now I am curious, did the code run in 2017?"
                    },
                    {
                        "username": "speedyy",
                        "content": "[@sachin-123](/sachin-123) Today's python is not as it was 6 years ago, maybe it was 'snake' that time?"
                    },
                    {
                        "username": "sachin-123",
                        "content": "you must be doing something wrong ,  my n^2 log(n)  ran correctly"
                    },
                    {
                        "username": "odewolf",
                        "content": "Could someone explain the valid triangle number.\\nI thought it would be valid \\'pythagorian\\' numbers suchas (3, 4,5) because 3^2 + 4^2 = 5^2\\nBut here in the examples they claim that (2,2,3) or (2,3,4) are valid triangles.\\nI am very confused."
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "A traingle is valid only if sum of any two sides is greater than third side. This is what you actually need to check and count such possible triplets. "
                    },
                    {
                        "username": "shubhankar-naik",
                        "content": "pythagoras theorem is only for right angled triangle, here it asks for any valid triangle "
                    },
                    {
                        "username": "soufian19966",
                        "content": "to be honest i am testing the like that if a+b>c & a+c>b & c+b>: , but i keep getting TLE, i am loking for other solution"
                    },
                    {
                        "username": "the_GameChanger",
                        "content": "[@praveen_allam](/praveen_allam) yes correct\\n"
                    },
                    {
                        "username": "praveen_allam",
                        "content": "If a triangle of side lengths a,b and c is said to be valid if, a+b > c, b+c > a and a+c> b.\n"
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "O(n*n) Approach \\nhttps://youtu.be/ZVgYnL4m3Oo"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "what is Triangle number"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "it is a triplet (a,b,c) , where the condition (side1+side2 > side3) strictly holds true for all combinations.\ni.e, a+b >c\nb+c >a\na+c >b"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "As it states in the description: '...we take them (the numbers choosen) as side lengths of a triangle'. For instance (3,3,3) will give you an equilateral triangle, while (3,4,5) yields a right triangle (one of the angles is 90 degree)"
                    },
                    {
                        "username": "abhi1060",
                        "content": "here triangle is valid if two of its side sum is greater than third side.\\nto simplify it first sort sides.\\nthen from 2nd index apply binary seach ober left side of array.\\nadd each case answers and return.\\n![image](https://assets.leetcode.com/users/images/ed1a7b9f-2411-42d0-873e-b36a22ccaa07_1654699314.8672206.png)\\n"
                    },
                    {
                        "username": "AkAsH_Ydv",
                        "content": "I think the test case of this program is based on wrong logic ."
                    },
                    {
                        "username": "little_late",
                        "content": "1st attempt : thought question was talking about right angle triangles. So wrote such code to run in O(n*nlogn). If such question is there on leetcode, Please share link.\\n\\n2nd attempt : got the solution, but why this question is marked here in binary search study plan??"
                    },
                    {
                        "username": "pronit013",
                        "content": "Valid Triangle means if you added length of any 2 side it will be greater than 3rd side length"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "[2,2,3,4]\\nfor this input in the explanation, we can also get the set of [2,2,4] \\ncan anyone explain about that case"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "You can\\'t construct a triangle from [2,2,4] because 2+2 = 4, that\\'s mean, two sides only covers third with no angle (try to draw it on paper). In particular, for constructing a triangle sum of two sides should be greater than third"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Is it similar to 3sum? So tc will be O(n^2)"
                    }
                ]
            },
            {
                "id": 1687409,
                "content": [
                    {
                        "username": "iynaur87",
                        "content": "O(n^2) python solution got TLE.\\nI assume no faster solutions exist, right?"
                    },
                    {
                        "username": "ivsergeev",
                        "content": "O(N) is possible)"
                    },
                    {
                        "username": "speedyy",
                        "content": "Now I am curious, did the code run in 2017?"
                    },
                    {
                        "username": "speedyy",
                        "content": "[@sachin-123](/sachin-123) Today's python is not as it was 6 years ago, maybe it was 'snake' that time?"
                    },
                    {
                        "username": "sachin-123",
                        "content": "you must be doing something wrong ,  my n^2 log(n)  ran correctly"
                    },
                    {
                        "username": "odewolf",
                        "content": "Could someone explain the valid triangle number.\\nI thought it would be valid \\'pythagorian\\' numbers suchas (3, 4,5) because 3^2 + 4^2 = 5^2\\nBut here in the examples they claim that (2,2,3) or (2,3,4) are valid triangles.\\nI am very confused."
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "A traingle is valid only if sum of any two sides is greater than third side. This is what you actually need to check and count such possible triplets. "
                    },
                    {
                        "username": "shubhankar-naik",
                        "content": "pythagoras theorem is only for right angled triangle, here it asks for any valid triangle "
                    },
                    {
                        "username": "soufian19966",
                        "content": "to be honest i am testing the like that if a+b>c & a+c>b & c+b>: , but i keep getting TLE, i am loking for other solution"
                    },
                    {
                        "username": "the_GameChanger",
                        "content": "[@praveen_allam](/praveen_allam) yes correct\\n"
                    },
                    {
                        "username": "praveen_allam",
                        "content": "If a triangle of side lengths a,b and c is said to be valid if, a+b > c, b+c > a and a+c> b.\n"
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "O(n*n) Approach \\nhttps://youtu.be/ZVgYnL4m3Oo"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "what is Triangle number"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "it is a triplet (a,b,c) , where the condition (side1+side2 > side3) strictly holds true for all combinations.\ni.e, a+b >c\nb+c >a\na+c >b"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "As it states in the description: '...we take them (the numbers choosen) as side lengths of a triangle'. For instance (3,3,3) will give you an equilateral triangle, while (3,4,5) yields a right triangle (one of the angles is 90 degree)"
                    },
                    {
                        "username": "abhi1060",
                        "content": "here triangle is valid if two of its side sum is greater than third side.\\nto simplify it first sort sides.\\nthen from 2nd index apply binary seach ober left side of array.\\nadd each case answers and return.\\n![image](https://assets.leetcode.com/users/images/ed1a7b9f-2411-42d0-873e-b36a22ccaa07_1654699314.8672206.png)\\n"
                    },
                    {
                        "username": "AkAsH_Ydv",
                        "content": "I think the test case of this program is based on wrong logic ."
                    },
                    {
                        "username": "little_late",
                        "content": "1st attempt : thought question was talking about right angle triangles. So wrote such code to run in O(n*nlogn). If such question is there on leetcode, Please share link.\\n\\n2nd attempt : got the solution, but why this question is marked here in binary search study plan??"
                    },
                    {
                        "username": "pronit013",
                        "content": "Valid Triangle means if you added length of any 2 side it will be greater than 3rd side length"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "[2,2,3,4]\\nfor this input in the explanation, we can also get the set of [2,2,4] \\ncan anyone explain about that case"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "You can\\'t construct a triangle from [2,2,4] because 2+2 = 4, that\\'s mean, two sides only covers third with no angle (try to draw it on paper). In particular, for constructing a triangle sum of two sides should be greater than third"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Is it similar to 3sum? So tc will be O(n^2)"
                    }
                ]
            },
            {
                "id": 1576868,
                "content": [
                    {
                        "username": "iynaur87",
                        "content": "O(n^2) python solution got TLE.\\nI assume no faster solutions exist, right?"
                    },
                    {
                        "username": "ivsergeev",
                        "content": "O(N) is possible)"
                    },
                    {
                        "username": "speedyy",
                        "content": "Now I am curious, did the code run in 2017?"
                    },
                    {
                        "username": "speedyy",
                        "content": "[@sachin-123](/sachin-123) Today's python is not as it was 6 years ago, maybe it was 'snake' that time?"
                    },
                    {
                        "username": "sachin-123",
                        "content": "you must be doing something wrong ,  my n^2 log(n)  ran correctly"
                    },
                    {
                        "username": "odewolf",
                        "content": "Could someone explain the valid triangle number.\\nI thought it would be valid \\'pythagorian\\' numbers suchas (3, 4,5) because 3^2 + 4^2 = 5^2\\nBut here in the examples they claim that (2,2,3) or (2,3,4) are valid triangles.\\nI am very confused."
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "A traingle is valid only if sum of any two sides is greater than third side. This is what you actually need to check and count such possible triplets. "
                    },
                    {
                        "username": "shubhankar-naik",
                        "content": "pythagoras theorem is only for right angled triangle, here it asks for any valid triangle "
                    },
                    {
                        "username": "soufian19966",
                        "content": "to be honest i am testing the like that if a+b>c & a+c>b & c+b>: , but i keep getting TLE, i am loking for other solution"
                    },
                    {
                        "username": "the_GameChanger",
                        "content": "[@praveen_allam](/praveen_allam) yes correct\\n"
                    },
                    {
                        "username": "praveen_allam",
                        "content": "If a triangle of side lengths a,b and c is said to be valid if, a+b > c, b+c > a and a+c> b.\n"
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "O(n*n) Approach \\nhttps://youtu.be/ZVgYnL4m3Oo"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "what is Triangle number"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "it is a triplet (a,b,c) , where the condition (side1+side2 > side3) strictly holds true for all combinations.\ni.e, a+b >c\nb+c >a\na+c >b"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "As it states in the description: '...we take them (the numbers choosen) as side lengths of a triangle'. For instance (3,3,3) will give you an equilateral triangle, while (3,4,5) yields a right triangle (one of the angles is 90 degree)"
                    },
                    {
                        "username": "abhi1060",
                        "content": "here triangle is valid if two of its side sum is greater than third side.\\nto simplify it first sort sides.\\nthen from 2nd index apply binary seach ober left side of array.\\nadd each case answers and return.\\n![image](https://assets.leetcode.com/users/images/ed1a7b9f-2411-42d0-873e-b36a22ccaa07_1654699314.8672206.png)\\n"
                    },
                    {
                        "username": "AkAsH_Ydv",
                        "content": "I think the test case of this program is based on wrong logic ."
                    },
                    {
                        "username": "little_late",
                        "content": "1st attempt : thought question was talking about right angle triangles. So wrote such code to run in O(n*nlogn). If such question is there on leetcode, Please share link.\\n\\n2nd attempt : got the solution, but why this question is marked here in binary search study plan??"
                    },
                    {
                        "username": "pronit013",
                        "content": "Valid Triangle means if you added length of any 2 side it will be greater than 3rd side length"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "[2,2,3,4]\\nfor this input in the explanation, we can also get the set of [2,2,4] \\ncan anyone explain about that case"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "You can\\'t construct a triangle from [2,2,4] because 2+2 = 4, that\\'s mean, two sides only covers third with no angle (try to draw it on paper). In particular, for constructing a triangle sum of two sides should be greater than third"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Is it similar to 3sum? So tc will be O(n^2)"
                    }
                ]
            },
            {
                "id": 2060299,
                "content": [
                    {
                        "username": "iynaur87",
                        "content": "O(n^2) python solution got TLE.\\nI assume no faster solutions exist, right?"
                    },
                    {
                        "username": "ivsergeev",
                        "content": "O(N) is possible)"
                    },
                    {
                        "username": "speedyy",
                        "content": "Now I am curious, did the code run in 2017?"
                    },
                    {
                        "username": "speedyy",
                        "content": "[@sachin-123](/sachin-123) Today's python is not as it was 6 years ago, maybe it was 'snake' that time?"
                    },
                    {
                        "username": "sachin-123",
                        "content": "you must be doing something wrong ,  my n^2 log(n)  ran correctly"
                    },
                    {
                        "username": "odewolf",
                        "content": "Could someone explain the valid triangle number.\\nI thought it would be valid \\'pythagorian\\' numbers suchas (3, 4,5) because 3^2 + 4^2 = 5^2\\nBut here in the examples they claim that (2,2,3) or (2,3,4) are valid triangles.\\nI am very confused."
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "A traingle is valid only if sum of any two sides is greater than third side. This is what you actually need to check and count such possible triplets. "
                    },
                    {
                        "username": "shubhankar-naik",
                        "content": "pythagoras theorem is only for right angled triangle, here it asks for any valid triangle "
                    },
                    {
                        "username": "soufian19966",
                        "content": "to be honest i am testing the like that if a+b>c & a+c>b & c+b>: , but i keep getting TLE, i am loking for other solution"
                    },
                    {
                        "username": "the_GameChanger",
                        "content": "[@praveen_allam](/praveen_allam) yes correct\\n"
                    },
                    {
                        "username": "praveen_allam",
                        "content": "If a triangle of side lengths a,b and c is said to be valid if, a+b > c, b+c > a and a+c> b.\n"
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "O(n*n) Approach \\nhttps://youtu.be/ZVgYnL4m3Oo"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "what is Triangle number"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "it is a triplet (a,b,c) , where the condition (side1+side2 > side3) strictly holds true for all combinations.\ni.e, a+b >c\nb+c >a\na+c >b"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "As it states in the description: '...we take them (the numbers choosen) as side lengths of a triangle'. For instance (3,3,3) will give you an equilateral triangle, while (3,4,5) yields a right triangle (one of the angles is 90 degree)"
                    },
                    {
                        "username": "abhi1060",
                        "content": "here triangle is valid if two of its side sum is greater than third side.\\nto simplify it first sort sides.\\nthen from 2nd index apply binary seach ober left side of array.\\nadd each case answers and return.\\n![image](https://assets.leetcode.com/users/images/ed1a7b9f-2411-42d0-873e-b36a22ccaa07_1654699314.8672206.png)\\n"
                    },
                    {
                        "username": "AkAsH_Ydv",
                        "content": "I think the test case of this program is based on wrong logic ."
                    },
                    {
                        "username": "little_late",
                        "content": "1st attempt : thought question was talking about right angle triangles. So wrote such code to run in O(n*nlogn). If such question is there on leetcode, Please share link.\\n\\n2nd attempt : got the solution, but why this question is marked here in binary search study plan??"
                    },
                    {
                        "username": "pronit013",
                        "content": "Valid Triangle means if you added length of any 2 side it will be greater than 3rd side length"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "[2,2,3,4]\\nfor this input in the explanation, we can also get the set of [2,2,4] \\ncan anyone explain about that case"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "You can\\'t construct a triangle from [2,2,4] because 2+2 = 4, that\\'s mean, two sides only covers third with no angle (try to draw it on paper). In particular, for constructing a triangle sum of two sides should be greater than third"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Is it similar to 3sum? So tc will be O(n^2)"
                    }
                ]
            },
            {
                "id": 2033884,
                "content": [
                    {
                        "username": "iynaur87",
                        "content": "O(n^2) python solution got TLE.\\nI assume no faster solutions exist, right?"
                    },
                    {
                        "username": "ivsergeev",
                        "content": "O(N) is possible)"
                    },
                    {
                        "username": "speedyy",
                        "content": "Now I am curious, did the code run in 2017?"
                    },
                    {
                        "username": "speedyy",
                        "content": "[@sachin-123](/sachin-123) Today's python is not as it was 6 years ago, maybe it was 'snake' that time?"
                    },
                    {
                        "username": "sachin-123",
                        "content": "you must be doing something wrong ,  my n^2 log(n)  ran correctly"
                    },
                    {
                        "username": "odewolf",
                        "content": "Could someone explain the valid triangle number.\\nI thought it would be valid \\'pythagorian\\' numbers suchas (3, 4,5) because 3^2 + 4^2 = 5^2\\nBut here in the examples they claim that (2,2,3) or (2,3,4) are valid triangles.\\nI am very confused."
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "A traingle is valid only if sum of any two sides is greater than third side. This is what you actually need to check and count such possible triplets. "
                    },
                    {
                        "username": "shubhankar-naik",
                        "content": "pythagoras theorem is only for right angled triangle, here it asks for any valid triangle "
                    },
                    {
                        "username": "soufian19966",
                        "content": "to be honest i am testing the like that if a+b>c & a+c>b & c+b>: , but i keep getting TLE, i am loking for other solution"
                    },
                    {
                        "username": "the_GameChanger",
                        "content": "[@praveen_allam](/praveen_allam) yes correct\\n"
                    },
                    {
                        "username": "praveen_allam",
                        "content": "If a triangle of side lengths a,b and c is said to be valid if, a+b > c, b+c > a and a+c> b.\n"
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "O(n*n) Approach \\nhttps://youtu.be/ZVgYnL4m3Oo"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "what is Triangle number"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "it is a triplet (a,b,c) , where the condition (side1+side2 > side3) strictly holds true for all combinations.\ni.e, a+b >c\nb+c >a\na+c >b"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "As it states in the description: '...we take them (the numbers choosen) as side lengths of a triangle'. For instance (3,3,3) will give you an equilateral triangle, while (3,4,5) yields a right triangle (one of the angles is 90 degree)"
                    },
                    {
                        "username": "abhi1060",
                        "content": "here triangle is valid if two of its side sum is greater than third side.\\nto simplify it first sort sides.\\nthen from 2nd index apply binary seach ober left side of array.\\nadd each case answers and return.\\n![image](https://assets.leetcode.com/users/images/ed1a7b9f-2411-42d0-873e-b36a22ccaa07_1654699314.8672206.png)\\n"
                    },
                    {
                        "username": "AkAsH_Ydv",
                        "content": "I think the test case of this program is based on wrong logic ."
                    },
                    {
                        "username": "little_late",
                        "content": "1st attempt : thought question was talking about right angle triangles. So wrote such code to run in O(n*nlogn). If such question is there on leetcode, Please share link.\\n\\n2nd attempt : got the solution, but why this question is marked here in binary search study plan??"
                    },
                    {
                        "username": "pronit013",
                        "content": "Valid Triangle means if you added length of any 2 side it will be greater than 3rd side length"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "[2,2,3,4]\\nfor this input in the explanation, we can also get the set of [2,2,4] \\ncan anyone explain about that case"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "You can\\'t construct a triangle from [2,2,4] because 2+2 = 4, that\\'s mean, two sides only covers third with no angle (try to draw it on paper). In particular, for constructing a triangle sum of two sides should be greater than third"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Is it similar to 3sum? So tc will be O(n^2)"
                    }
                ]
            },
            {
                "id": 1909553,
                "content": [
                    {
                        "username": "iynaur87",
                        "content": "O(n^2) python solution got TLE.\\nI assume no faster solutions exist, right?"
                    },
                    {
                        "username": "ivsergeev",
                        "content": "O(N) is possible)"
                    },
                    {
                        "username": "speedyy",
                        "content": "Now I am curious, did the code run in 2017?"
                    },
                    {
                        "username": "speedyy",
                        "content": "[@sachin-123](/sachin-123) Today's python is not as it was 6 years ago, maybe it was 'snake' that time?"
                    },
                    {
                        "username": "sachin-123",
                        "content": "you must be doing something wrong ,  my n^2 log(n)  ran correctly"
                    },
                    {
                        "username": "odewolf",
                        "content": "Could someone explain the valid triangle number.\\nI thought it would be valid \\'pythagorian\\' numbers suchas (3, 4,5) because 3^2 + 4^2 = 5^2\\nBut here in the examples they claim that (2,2,3) or (2,3,4) are valid triangles.\\nI am very confused."
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "A traingle is valid only if sum of any two sides is greater than third side. This is what you actually need to check and count such possible triplets. "
                    },
                    {
                        "username": "shubhankar-naik",
                        "content": "pythagoras theorem is only for right angled triangle, here it asks for any valid triangle "
                    },
                    {
                        "username": "soufian19966",
                        "content": "to be honest i am testing the like that if a+b>c & a+c>b & c+b>: , but i keep getting TLE, i am loking for other solution"
                    },
                    {
                        "username": "the_GameChanger",
                        "content": "[@praveen_allam](/praveen_allam) yes correct\\n"
                    },
                    {
                        "username": "praveen_allam",
                        "content": "If a triangle of side lengths a,b and c is said to be valid if, a+b > c, b+c > a and a+c> b.\n"
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "O(n*n) Approach \\nhttps://youtu.be/ZVgYnL4m3Oo"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "what is Triangle number"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "it is a triplet (a,b,c) , where the condition (side1+side2 > side3) strictly holds true for all combinations.\ni.e, a+b >c\nb+c >a\na+c >b"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "As it states in the description: '...we take them (the numbers choosen) as side lengths of a triangle'. For instance (3,3,3) will give you an equilateral triangle, while (3,4,5) yields a right triangle (one of the angles is 90 degree)"
                    },
                    {
                        "username": "abhi1060",
                        "content": "here triangle is valid if two of its side sum is greater than third side.\\nto simplify it first sort sides.\\nthen from 2nd index apply binary seach ober left side of array.\\nadd each case answers and return.\\n![image](https://assets.leetcode.com/users/images/ed1a7b9f-2411-42d0-873e-b36a22ccaa07_1654699314.8672206.png)\\n"
                    },
                    {
                        "username": "AkAsH_Ydv",
                        "content": "I think the test case of this program is based on wrong logic ."
                    },
                    {
                        "username": "little_late",
                        "content": "1st attempt : thought question was talking about right angle triangles. So wrote such code to run in O(n*nlogn). If such question is there on leetcode, Please share link.\\n\\n2nd attempt : got the solution, but why this question is marked here in binary search study plan??"
                    },
                    {
                        "username": "pronit013",
                        "content": "Valid Triangle means if you added length of any 2 side it will be greater than 3rd side length"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "[2,2,3,4]\\nfor this input in the explanation, we can also get the set of [2,2,4] \\ncan anyone explain about that case"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "You can\\'t construct a triangle from [2,2,4] because 2+2 = 4, that\\'s mean, two sides only covers third with no angle (try to draw it on paper). In particular, for constructing a triangle sum of two sides should be greater than third"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Is it similar to 3sum? So tc will be O(n^2)"
                    }
                ]
            },
            {
                "id": 1906837,
                "content": [
                    {
                        "username": "iynaur87",
                        "content": "O(n^2) python solution got TLE.\\nI assume no faster solutions exist, right?"
                    },
                    {
                        "username": "ivsergeev",
                        "content": "O(N) is possible)"
                    },
                    {
                        "username": "speedyy",
                        "content": "Now I am curious, did the code run in 2017?"
                    },
                    {
                        "username": "speedyy",
                        "content": "[@sachin-123](/sachin-123) Today's python is not as it was 6 years ago, maybe it was 'snake' that time?"
                    },
                    {
                        "username": "sachin-123",
                        "content": "you must be doing something wrong ,  my n^2 log(n)  ran correctly"
                    },
                    {
                        "username": "odewolf",
                        "content": "Could someone explain the valid triangle number.\\nI thought it would be valid \\'pythagorian\\' numbers suchas (3, 4,5) because 3^2 + 4^2 = 5^2\\nBut here in the examples they claim that (2,2,3) or (2,3,4) are valid triangles.\\nI am very confused."
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "A traingle is valid only if sum of any two sides is greater than third side. This is what you actually need to check and count such possible triplets. "
                    },
                    {
                        "username": "shubhankar-naik",
                        "content": "pythagoras theorem is only for right angled triangle, here it asks for any valid triangle "
                    },
                    {
                        "username": "soufian19966",
                        "content": "to be honest i am testing the like that if a+b>c & a+c>b & c+b>: , but i keep getting TLE, i am loking for other solution"
                    },
                    {
                        "username": "the_GameChanger",
                        "content": "[@praveen_allam](/praveen_allam) yes correct\\n"
                    },
                    {
                        "username": "praveen_allam",
                        "content": "If a triangle of side lengths a,b and c is said to be valid if, a+b > c, b+c > a and a+c> b.\n"
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "O(n*n) Approach \\nhttps://youtu.be/ZVgYnL4m3Oo"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "what is Triangle number"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "it is a triplet (a,b,c) , where the condition (side1+side2 > side3) strictly holds true for all combinations.\ni.e, a+b >c\nb+c >a\na+c >b"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "As it states in the description: '...we take them (the numbers choosen) as side lengths of a triangle'. For instance (3,3,3) will give you an equilateral triangle, while (3,4,5) yields a right triangle (one of the angles is 90 degree)"
                    },
                    {
                        "username": "abhi1060",
                        "content": "here triangle is valid if two of its side sum is greater than third side.\\nto simplify it first sort sides.\\nthen from 2nd index apply binary seach ober left side of array.\\nadd each case answers and return.\\n![image](https://assets.leetcode.com/users/images/ed1a7b9f-2411-42d0-873e-b36a22ccaa07_1654699314.8672206.png)\\n"
                    },
                    {
                        "username": "AkAsH_Ydv",
                        "content": "I think the test case of this program is based on wrong logic ."
                    },
                    {
                        "username": "little_late",
                        "content": "1st attempt : thought question was talking about right angle triangles. So wrote such code to run in O(n*nlogn). If such question is there on leetcode, Please share link.\\n\\n2nd attempt : got the solution, but why this question is marked here in binary search study plan??"
                    },
                    {
                        "username": "pronit013",
                        "content": "Valid Triangle means if you added length of any 2 side it will be greater than 3rd side length"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "[2,2,3,4]\\nfor this input in the explanation, we can also get the set of [2,2,4] \\ncan anyone explain about that case"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "You can\\'t construct a triangle from [2,2,4] because 2+2 = 4, that\\'s mean, two sides only covers third with no angle (try to draw it on paper). In particular, for constructing a triangle sum of two sides should be greater than third"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Is it similar to 3sum? So tc will be O(n^2)"
                    }
                ]
            },
            {
                "id": 1897305,
                "content": [
                    {
                        "username": "iynaur87",
                        "content": "O(n^2) python solution got TLE.\\nI assume no faster solutions exist, right?"
                    },
                    {
                        "username": "ivsergeev",
                        "content": "O(N) is possible)"
                    },
                    {
                        "username": "speedyy",
                        "content": "Now I am curious, did the code run in 2017?"
                    },
                    {
                        "username": "speedyy",
                        "content": "[@sachin-123](/sachin-123) Today's python is not as it was 6 years ago, maybe it was 'snake' that time?"
                    },
                    {
                        "username": "sachin-123",
                        "content": "you must be doing something wrong ,  my n^2 log(n)  ran correctly"
                    },
                    {
                        "username": "odewolf",
                        "content": "Could someone explain the valid triangle number.\\nI thought it would be valid \\'pythagorian\\' numbers suchas (3, 4,5) because 3^2 + 4^2 = 5^2\\nBut here in the examples they claim that (2,2,3) or (2,3,4) are valid triangles.\\nI am very confused."
                    },
                    {
                        "username": "AnishKrSingh",
                        "content": "A traingle is valid only if sum of any two sides is greater than third side. This is what you actually need to check and count such possible triplets. "
                    },
                    {
                        "username": "shubhankar-naik",
                        "content": "pythagoras theorem is only for right angled triangle, here it asks for any valid triangle "
                    },
                    {
                        "username": "soufian19966",
                        "content": "to be honest i am testing the like that if a+b>c & a+c>b & c+b>: , but i keep getting TLE, i am loking for other solution"
                    },
                    {
                        "username": "the_GameChanger",
                        "content": "[@praveen_allam](/praveen_allam) yes correct\\n"
                    },
                    {
                        "username": "praveen_allam",
                        "content": "If a triangle of side lengths a,b and c is said to be valid if, a+b > c, b+c > a and a+c> b.\n"
                    },
                    {
                        "username": "Vishesh2308",
                        "content": "O(n*n) Approach \\nhttps://youtu.be/ZVgYnL4m3Oo"
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "what is Triangle number"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "it is a triplet (a,b,c) , where the condition (side1+side2 > side3) strictly holds true for all combinations.\ni.e, a+b >c\nb+c >a\na+c >b"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "As it states in the description: '...we take them (the numbers choosen) as side lengths of a triangle'. For instance (3,3,3) will give you an equilateral triangle, while (3,4,5) yields a right triangle (one of the angles is 90 degree)"
                    },
                    {
                        "username": "abhi1060",
                        "content": "here triangle is valid if two of its side sum is greater than third side.\\nto simplify it first sort sides.\\nthen from 2nd index apply binary seach ober left side of array.\\nadd each case answers and return.\\n![image](https://assets.leetcode.com/users/images/ed1a7b9f-2411-42d0-873e-b36a22ccaa07_1654699314.8672206.png)\\n"
                    },
                    {
                        "username": "AkAsH_Ydv",
                        "content": "I think the test case of this program is based on wrong logic ."
                    },
                    {
                        "username": "little_late",
                        "content": "1st attempt : thought question was talking about right angle triangles. So wrote such code to run in O(n*nlogn). If such question is there on leetcode, Please share link.\\n\\n2nd attempt : got the solution, but why this question is marked here in binary search study plan??"
                    },
                    {
                        "username": "pronit013",
                        "content": "Valid Triangle means if you added length of any 2 side it will be greater than 3rd side length"
                    },
                    {
                        "username": "SasiAttili",
                        "content": "[2,2,3,4]\\nfor this input in the explanation, we can also get the set of [2,2,4] \\ncan anyone explain about that case"
                    },
                    {
                        "username": "Xabchinsk",
                        "content": "You can\\'t construct a triangle from [2,2,4] because 2+2 = 4, that\\'s mean, two sides only covers third with no angle (try to draw it on paper). In particular, for constructing a triangle sum of two sides should be greater than third"
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Is it similar to 3sum? So tc will be O(n^2)"
                    }
                ]
            }
        ]
    }
]