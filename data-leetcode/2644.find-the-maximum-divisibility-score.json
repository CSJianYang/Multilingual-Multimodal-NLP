[
    {
        "title": "Find the Maximum Divisibility Score",
        "question_content": "You are given two 0-indexed integer arrays nums and divisors.\nThe divisibility score of divisors[i] is the number of indices j such that nums[j] is divisible by divisors[i].\nReturn the integer divisors[i] with the maximum divisibility score. If there is more than one integer with the maximum score, return the minimum of them.\n&nbsp;\nExample 1:\n\nInput: nums = [4,7,9,3,9], divisors = [5,2,3]\nOutput: 3\nExplanation: The divisibility score for every element in divisors is:\nThe divisibility score of divisors[0] is 0 since no number in nums is divisible by 5.\nThe divisibility score of divisors[1] is 1 since nums[0] is divisible by 2.\nThe divisibility score of divisors[2] is 3 since nums[2], nums[3], and nums[4] are divisible by 3.\nSince divisors[2] has the maximum divisibility score, we return it.\n\nExample 2:\n\nInput: nums = [20,14,21,10], divisors = [5,7,5]\nOutput: 5\nExplanation: The divisibility score for every element in divisors is:\nThe divisibility score of divisors[0] is 2 since nums[0] and nums[3] are divisible by 5.\nThe divisibility score of divisors[1] is 2 since nums[1] and nums[2] are divisible by 7.\nThe divisibility score of divisors[2] is 2 since nums[0] and nums[3] are divisible by 5.\nSince divisors[0], divisors[1], and divisors[2] all have the maximum divisibility score, we return the minimum of them (i.e., divisors[2]).\n\nExample 3:\n\nInput: nums = [12], divisors = [10,16]\nOutput: 10\nExplanation: The divisibility score for every element in divisors is:\nThe divisibility score of divisors[0] is 0 since no number in nums is divisible by 10.\nThe divisibility score of divisors[1] is 0 since no number in nums is divisible by 16.\nSince divisors[0] and divisors[1] both have the maximum divisibility score, we return the minimum of them (i.e., divisors[0]).\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length, divisors.length <= 1000\n\t1 <= nums[i], divisors[i] <= 109",
        "solutions": [
            {
                "id": 3422204,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "C++\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int ans = -1, mx_cnt = -1;\\n        // for each divisor\\n        for (auto d : divisors) {\\n            int cnt = 0;\\n            // we check each number `x`\\n            for (auto x : nums) {\\n                // to see if `x` can be divisible by `d`\\n                if (x % d == 0) {\\n                    // if so, increase the counter by 1\\n                    cnt += 1;\\n                }\\n            }\\n            // if the counter is greater than the current max\\n            if (cnt > mx_cnt) {\\n                // then update hte current max\\n                mx_cnt = cnt;\\n                // `d` will be the possible answer\\n                ans = d;\\n            } else if (cnt == mx_cnt) {\\n                // however, if the counter is same as the current max\\n                // then we need to take the min one\\n                ans = min(ans, d);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nPython\\n\\n```py\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        res = -1\\n        mx_cnt = -1\\n        # for each divisor\\n        for d in divisors:\\n            cnt = 0\\n            # we check each number `x`\\n            for x in nums:\\n                # to see if `x` can be divisible by `d`\\n                if x % d == 0:\\n                    # if so, increase the counter by 1\\n                    cnt += 1\\n            # if the counter is greater than the current max\\n            if cnt > mx_cnt:\\n                # then update hte current max\\n                mx_cnt = cnt\\n                # `d` will be the possible answer\\n                res = d\\n            elif cnt == mx_cnt:\\n                # however, if the counter is same as the current max\\n                # then we need to take the min one\\n                res = min(res, d)\\n        return res\\n```",
                "solutionTags": [
                    "C++",
                    "Python"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int ans = -1, mx_cnt = -1;\\n        // for each divisor\\n        for (auto d : divisors) {\\n            int cnt = 0;\\n            // we check each number `x`\\n            for (auto x : nums) {\\n                // to see if `x` can be divisible by `d`\\n                if (x % d == 0) {\\n                    // if so, increase the counter by 1\\n                    cnt += 1;\\n                }\\n            }\\n            // if the counter is greater than the current max\\n            if (cnt > mx_cnt) {\\n                // then update hte current max\\n                mx_cnt = cnt;\\n                // `d` will be the possible answer\\n                ans = d;\\n            } else if (cnt == mx_cnt) {\\n                // however, if the counter is same as the current max\\n                // then we need to take the min one\\n                ans = min(ans, d);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```py\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        res = -1\\n        mx_cnt = -1\\n        # for each divisor\\n        for d in divisors:\\n            cnt = 0\\n            # we check each number `x`\\n            for x in nums:\\n                # to see if `x` can be divisible by `d`\\n                if x % d == 0:\\n                    # if so, increase the counter by 1\\n                    cnt += 1\\n            # if the counter is greater than the current max\\n            if cnt > mx_cnt:\\n                # then update hte current max\\n                mx_cnt = cnt\\n                # `d` will be the possible answer\\n                res = d\\n            elif cnt == mx_cnt:\\n                # however, if the counter is same as the current max\\n                # then we need to take the min one\\n                res = min(res, d)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421736,
                "title": "clean-simple-java-solution",
                "content": "\\n```java []\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        Arrays.sort(divisors);\\n        int max = 0, res = divisors[0];\\n        for(int i=0; i<divisors.length; i++){\\n            int cnt = 0;\\n            for(int j=0; j<nums.length; j++){\\n                if(nums[j] % divisors[i] == 0)  cnt++;\\n            }\\n            if(cnt > max){\\n                max = cnt;\\n                res = divisors[i];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        Arrays.sort(divisors);\\n        int max = 0, res = divisors[0];\\n        for(int i=0; i<divisors.length; i++){\\n            int cnt = 0;\\n            for(int j=0; j<nums.length; j++){\\n                if(nums[j] % divisors[i] == 0)  cnt++;\\n            }\\n            if(cnt > max){\\n                max = cnt;\\n                res = divisors[i];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421687,
                "title": "c-bruteforce",
                "content": "**Approach Brute Force**\\n**Count number of perfect dividend and update the answer**\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int res = 0, curr = -1;\\n        for(auto &d: divisors){\\n            int score = 0;\\n            for(auto &it: nums)     \\n                score += (it % d == 0);\\n            if(score >= curr){\\n                if(score == curr)       \\n                    res = min(res, d);\\n                else                    \\n                    res = d;                    \\n                curr = score;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int res = 0, curr = -1;\\n        for(auto &d: divisors){\\n            int score = 0;\\n            for(auto &it: nums)     \\n                score += (it % d == 0);\\n            if(score >= curr){\\n                if(score == curr)       \\n                    res = min(res, d);\\n                else                    \\n                    res = d;                    \\n                curr = score;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421912,
                "title": "c-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int maxcount = 0;\\n        int best_divisor = divisors[0];\\n        for (int i = 0; i < divisors.size(); i++) {\\n            int count = 0;\\n            for (int j = 0; j < nums.size(); j++) {\\n                if (nums[j] % divisors[i] == 0) {\\n                    count++;\\n                }\\n            }\\n            if(count==maxcount){\\n               best_divisor = min(best_divisor,divisors[i]);\\n            }\\n            if (count > maxcount) {\\n                maxcount = count;\\n                best_divisor = divisors[i];\\n            }\\n        }\\n        return best_divisor;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int maxcount = 0;\\n        int best_divisor = divisors[0];\\n        for (int i = 0; i < divisors.size(); i++) {\\n            int count = 0;\\n            for (int j = 0; j < nums.size(); j++) {\\n                if (nums[j] % divisors[i] == 0) {\\n                    count++;\\n                }\\n            }\\n            if(count==maxcount){\\n               best_divisor = min(best_divisor,divisors[i]);\\n            }\\n            if (count > maxcount) {\\n                maxcount = count;\\n                best_divisor = divisors[i];\\n            }\\n        }\\n        return best_divisor;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421672,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(m*n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max=0,val=0;\\n        for(int i:divisors)\\n        {\\n            int count=0;\\n            for(int j:nums)\\n            {\\n                if(j%i==0)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count>max)\\n            {\\n                max=count;\\n                val=i;\\n            }\\n            if(count==max && i<val)\\n            {\\n                val=i;\\n            }\\n        }\\n        if(max==0 && val==0)\\n        {\\n            Arrays.sort(divisors);\\n            return divisors[0];\\n        }\\n        return val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max=0,val=0;\\n        for(int i:divisors)\\n        {\\n            int count=0;\\n            for(int j:nums)\\n            {\\n                if(j%i==0)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count>max)\\n            {\\n                max=count;\\n                val=i;\\n            }\\n            if(count==max && i<val)\\n            {\\n                val=i;\\n            }\\n        }\\n        if(max==0 && val==0)\\n        {\\n            Arrays.sort(divisors);\\n            return divisors[0];\\n        }\\n        return val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426856,
                "title": "golang-100-faster-easy-solution",
                "content": "# Code\\u2705\\n```\\nimport (\\n\\t\"sort\"\\n)\\nfunc maxDivScore(nums []int, divisors []int) int {\\n   max := 0\\n   maxDiv := 0\\n   for _, div := range divisors{\\n        currentMax := 0\\n        for _, num := range nums{\\n            if num % div == 0 {\\n                currentMax += 1\\n            } \\n        }\\n        if currentMax == max {\\n            if div < maxDiv {\\n                maxDiv = div\\n            }\\n        } else if currentMax > max {\\n            maxDiv = div\\n            max = currentMax\\n        }\\n   }\\n   \\n   if max == 0 {\\n       sort.Ints(divisors)\\n       return divisors[0] \\n   }\\n   return  maxDiv\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nimport (\\n\\t\"sort\"\\n)\\nfunc maxDivScore(nums []int, divisors []int) int {\\n   max := 0\\n   maxDiv := 0\\n   for _, div := range divisors{\\n        currentMax := 0\\n        for _, num := range nums{\\n            if num % div == 0 {\\n                currentMax += 1\\n            } \\n        }\\n        if currentMax == max {\\n            if div < maxDiv {\\n                maxDiv = div\\n            }\\n        } else if currentMax > max {\\n            maxDiv = div\\n            max = currentMax\\n        }\\n   }\\n   \\n   if max == 0 {\\n       sort.Ints(divisors)\\n       return divisors[0] \\n   }\\n   return  maxDiv\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3426109,
                "title": "one-liner",
                "content": "**Python 3**\\nWe negate the divisor to avoid lambda.\\n\\n```python\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divs: List[int]) -> int:\\n        return -max([sum(n % d == 0 for n in nums), -d] for d in divs)[1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divs: List[int]) -> int:\\n        return -max([sum(n % d == 0 for n in nums), -d] for d in divs)[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422465,
                "title": "c-brute-force",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n * m)$$\\nn = div.size(), m = nums.size()\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& div) {\\n        int count = 0, divisor = 0;\\n        for(int i = 0; i < div.size(); i++) {\\n            int div_count = 0;\\n            for(int j = 0; j < nums.size(); j++) {\\n                if(nums[j] % div[i] == 0) div_count++;\\n            }\\n            if(count == div_count) {\\n                divisor = divisor == 0 ? div[i] : min(divisor, div[i]);\\n            }\\n            else if(div_count > count) {\\n                count = div_count;\\n                divisor = div[i];\\n            }\\n        }\\n        return divisor;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& div) {\\n        int count = 0, divisor = 0;\\n        for(int i = 0; i < div.size(); i++) {\\n            int div_count = 0;\\n            for(int j = 0; j < nums.size(); j++) {\\n                if(nums[j] % div[i] == 0) div_count++;\\n            }\\n            if(count == div_count) {\\n                divisor = divisor == 0 ? div[i] : min(divisor, div[i]);\\n            }\\n            else if(div_count > count) {\\n                count = div_count;\\n                divisor = div[i];\\n            }\\n        }\\n        return divisor;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421776,
                "title": "easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int dLen = divisors.size(),n=nums.size(),c,maxVal=0,ans=INT_MAX;\\n        \\n        for(int i=0;i<dLen;i++){\\n            c=0;\\n            for(int j=0;j<n;j++){\\n                if(nums[j]%divisors[i] == 0){\\n                    c++;\\n                }\\n            }\\n            if(c==maxVal){\\n                ans = min(ans,divisors[i]);\\n            }\\n            else if(c > maxVal){\\n                maxVal = c;\\n                ans = divisors[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int dLen = divisors.size(),n=nums.size(),c,maxVal=0,ans=INT_MAX;\\n        \\n        for(int i=0;i<dLen;i++){\\n            c=0;\\n            for(int j=0;j<n;j++){\\n                if(nums[j]%divisors[i] == 0){\\n                    c++;\\n                }\\n            }\\n            if(c==maxVal){\\n                ans = min(ans,divisors[i]);\\n            }\\n            else if(c > maxVal){\\n                maxVal = c;\\n                ans = divisors[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442703,
                "title": "simple-python3-beats-91-6-quibler7",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        res = 0 \\n        count = -1\\n        for d in divisors:\\n            curr = sum(1 for i in nums if i%d == 0)\\n            if curr > count:\\n                count = curr\\n                res = d\\n            elif curr == count:\\n                res = min(res, d)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        res = 0 \\n        count = -1\\n        for d in divisors:\\n            curr = sum(1 for i in nums if i%d == 0)\\n            if curr > count:\\n                count = curr\\n                res = d\\n            elif curr == count:\\n                res = min(res, d)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435017,
                "title": "binary-search-java",
                "content": "# Approach\\nSort the nums, given the divisor , find an index that is equals or greater than divisor, then loop through the numbers starting from the index.\\n\\n# Complexity\\n- Time complexity:\\n$$O(DlogN)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    private int binarySearch(int[] nums, int target) {\\n        int i = 0;\\n        int j = nums.length;\\n        while(i < j) {\\n            int mid = i + (j - i) / 2;\\n            if(nums[mid] < target) {\\n                i = mid + 1;\\n            } else {\\n                j = mid;\\n            }\\n        }\\n        return i;\\n    }\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        Arrays.sort(nums);\\n        int max = 0;\\n        int res = divisors[0];\\n        for(int d : divisors) {\\n            int score = 0;\\n            for(int i = binarySearch(nums, d); i < nums.length; ++i) {\\n                if( nums[i] % d == 0) {\\n                    ++score;\\n                }\\n            }\\n            if(score > max) {\\n                max = score;\\n                res = d;\\n            } else if (score == max) {\\n                res = Math.min(res, d);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n### [Optimize] Sort both nums and divisors, and limit the lower bound.\\n\\n```java\\nclass Solution {\\n    private int binarySearch(int[] nums, int target, int lo) {\\n        int hi = nums.length;\\n        while(lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if(nums[mid] < target) {\\n                lo = mid + 1;\\n            } else {\\n                hi = mid;\\n            }\\n        }\\n        return lo;\\n    }\\n\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        Arrays.sort(nums);\\n        Arrays.sort(divisors);\\n        int max = 0;\\n        int res = divisors[0];\\n        int lo = 0;\\n        for(int d : divisors) {\\n            int score = 0;\\n            lo = binarySearch(nums, d, lo);\\n            if(lo >= nums.length) {\\n                break;\\n            }\\n            for(int i = lo; i < nums.length; ++i) {\\n                if( nums[i] % d == 0) {\\n                    ++score;\\n                }\\n            }\\n            if(score > max) {\\n                max = score;\\n                res = d;\\n            } else if (score == max) {\\n                res = Math.min(res, d);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int binarySearch(int[] nums, int target) {\\n        int i = 0;\\n        int j = nums.length;\\n        while(i < j) {\\n            int mid = i + (j - i) / 2;\\n            if(nums[mid] < target) {\\n                i = mid + 1;\\n            } else {\\n                j = mid;\\n            }\\n        }\\n        return i;\\n    }\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        Arrays.sort(nums);\\n        int max = 0;\\n        int res = divisors[0];\\n        for(int d : divisors) {\\n            int score = 0;\\n            for(int i = binarySearch(nums, d); i < nums.length; ++i) {\\n                if( nums[i] % d == 0) {\\n                    ++score;\\n                }\\n            }\\n            if(score > max) {\\n                max = score;\\n                res = d;\\n            } else if (score == max) {\\n                res = Math.min(res, d);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    private int binarySearch(int[] nums, int target, int lo) {\\n        int hi = nums.length;\\n        while(lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if(nums[mid] < target) {\\n                lo = mid + 1;\\n            } else {\\n                hi = mid;\\n            }\\n        }\\n        return lo;\\n    }\\n\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        Arrays.sort(nums);\\n        Arrays.sort(divisors);\\n        int max = 0;\\n        int res = divisors[0];\\n        int lo = 0;\\n        for(int d : divisors) {\\n            int score = 0;\\n            lo = binarySearch(nums, d, lo);\\n            if(lo >= nums.length) {\\n                break;\\n            }\\n            for(int i = lo; i < nums.length; ++i) {\\n                if( nums[i] % d == 0) {\\n                    ++score;\\n                }\\n            }\\n            if(score > max) {\\n                max = score;\\n                res = d;\\n            } else if (score == max) {\\n                res = Math.min(res, d);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427066,
                "title": "easy-python-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        l=[]\\n        divisors.sort()\\n        for i in divisors:\\n            c=0\\n            for j in nums:\\n                if j%i==0:\\n                    c+=1\\n            l.append(c)\\n        return divisors[l.index(max(l))]\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        l=[]\\n        divisors.sort()\\n        for i in divisors:\\n            c=0\\n            for j in nums:\\n                if j%i==0:\\n                    c+=1\\n            l.append(c)\\n        return divisors[l.index(max(l))]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478271,
                "title": "easy-faster-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int res = 0, curr = -1;\\n        for(auto &d: divisors){\\n            int score = 0;\\n            for(auto &it: nums)     \\n                score += (it % d == 0);\\n            if(score >= curr){\\n                if(score == curr)       \\n                    res = min(res, d);\\n                else                    \\n                    res = d;                    \\n                curr = score;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int res = 0, curr = -1;\\n        for(auto &d: divisors){\\n            int score = 0;\\n            for(auto &it: nums)     \\n                score += (it % d == 0);\\n            if(score >= curr){\\n                if(score == curr)       \\n                    res = min(res, d);\\n                else                    \\n                    res = d;                    \\n                curr = score;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444500,
                "title": "99-fast-c-best-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n       sort(nums.begin(), nums.end());\\n        int maxi = *max_element(nums.begin(), nums.end());\\n        map<int, int>mp;\\n       for(int i = 0; i<divisors.size(); i++)\\n       {\\n           int count = 0;\\n           for(int j = divisors[i]; j<=maxi; j = j+divisors[i])\\n           {\\n               int l = lower_bound(nums.begin(), nums.end(), j)-nums.begin();\\n               int u = upper_bound(nums.begin(), nums.end(), j)-nums.begin();\\n               if(nums[l] == j)\\n               {\\n                   count = count+(u-l);\\n               }\\n           }\\n           mp[divisors[i]] = count;\\n           //cout<<count<<\" \";\\n       }\\n        \\n        int ans = INT_MIN;\\n        int max = INT_MAX;\\n        for(auto i : mp)\\n        {\\n            if(i.second>ans)\\n            {\\n                ans = i.second;\\n                max = i.first;\\n            }\\n            else if(i.second==ans)\\n            {\\n                if(i.first < max)\\n                {\\n                    max = i.first;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n       sort(nums.begin(), nums.end());\\n        int maxi = *max_element(nums.begin(), nums.end());\\n        map<int, int>mp;\\n       for(int i = 0; i<divisors.size(); i++)\\n       {\\n           int count = 0;\\n           for(int j = divisors[i]; j<=maxi; j = j+divisors[i])\\n           {\\n               int l = lower_bound(nums.begin(), nums.end(), j)-nums.begin();\\n               int u = upper_bound(nums.begin(), nums.end(), j)-nums.begin();\\n               if(nums[l] == j)\\n               {\\n                   count = count+(u-l);\\n               }\\n           }\\n           mp[divisors[i]] = count;\\n           //cout<<count<<\" \";\\n       }\\n        \\n        int ans = INT_MIN;\\n        int max = INT_MAX;\\n        for(auto i : mp)\\n        {\\n            if(i.second>ans)\\n            {\\n                ans = i.second;\\n                max = i.first;\\n            }\\n            else if(i.second==ans)\\n            {\\n                if(i.first < max)\\n                {\\n                    max = i.first;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3423433,
                "title": "easiest-solution-using-two-for-loops",
                "content": "# Intuition\\nUsing two for loops to iterate through the arrays.\\n\\n# Approach\\nBy taking the divisors one by one we count how many of elements of nums array are divisible by the divisors. Bycomparing with maxScore we find the divisor element with max score.\\n\\n# Complexity\\n- Time complexity:\\nO(n2)\\n\\n- Space complexity:\\nO(0)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        Arrays.sort(divisors);\\n        int maxScore=0;\\n        int ans=0;\\n        for(int i=0; i<divisors.length; i++){\\n            int score=0;\\n            for(int j=0; j<nums.length;j++){\\n                if(nums[j]%divisors[i]==0){ //if the nums element is divisible by the divisor we increase the score by one\\n                    score++;\\n                }\\n            }\\n            if(score>maxScore){\\n//compare the score with maximum score\\n                maxScore=score;\\n                ans=divisors[i];\\n            }\\n        }\\n        \\n        if(ans==0) return divisors[0];\\n        \\n    return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        Arrays.sort(divisors);\\n        int maxScore=0;\\n        int ans=0;\\n        for(int i=0; i<divisors.length; i++){\\n            int score=0;\\n            for(int j=0; j<nums.length;j++){\\n                if(nums[j]%divisors[i]==0){ //if the nums element is divisible by the divisor we increase the score by one\\n                    score++;\\n                }\\n            }\\n            if(score>maxScore){\\n//compare the score with maximum score\\n                maxScore=score;\\n                ans=divisors[i];\\n            }\\n        }\\n        \\n        if(ans==0) return divisors[0];\\n        \\n    return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422013,
                "title": "simple-solution-in-go-and-c",
                "content": "\\n\\n# Complexity\\n- Time complexity: $$O(n*m)$$\\n<!-- Add your time complexity here, e.g.  -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc maxDivScore(nums []int, divisors []int) int {\\n    maxCount, index := 0, 0\\n    \\n    for i := 0; i < len(divisors); i++ {\\n        count := 0\\n        for j := 0; j < len(nums); j++ {\\n            if nums[j] % divisors[i] == 0 {\\n                count++\\n            }\\n        }\\n        \\n        if count > maxCount || (count == maxCount && divisors[i] < divisors[index]) {\\n            maxCount = count\\n            index = i\\n        }\\n    }\\n    \\n    return divisors[index]\\n}\\n```\\nC#\\n```\\npublic class Solution {\\n    public int MaxDivScore(int[] nums, int[] divisors) {\\n        int maxCount = 0;\\n        int index = 0;\\n        \\n        for (int i = 0; i < divisors.Length; i++) {\\n            int count = 0;\\n            for (int j = 0; j < nums.Length; j++) {\\n                if (nums[j] % divisors[i] == 0) {\\n                    count++;\\n                }\\n            }\\n            \\n            if (count > maxCount || (count == maxCount && divisors[i] < divisors[index])) {\\n                maxCount = count;\\n                index = i;\\n            }\\n        }\\n        \\n        return divisors[index];\\n    }\\n}\\n```\\n![a6c83c54-1d1a-4f26-8273-b687d119dd5b_1679889261.1494205.png](https://assets.leetcode.com/users/images/cc82e8aa-dc98-4f10-af4c-64b1528c0fb6_1680844232.130332.png)",
                "solutionTags": [
                    "C#",
                    "Go"
                ],
                "code": "```\\nfunc maxDivScore(nums []int, divisors []int) int {\\n    maxCount, index := 0, 0\\n    \\n    for i := 0; i < len(divisors); i++ {\\n        count := 0\\n        for j := 0; j < len(nums); j++ {\\n            if nums[j] % divisors[i] == 0 {\\n                count++\\n            }\\n        }\\n        \\n        if count > maxCount || (count == maxCount && divisors[i] < divisors[index]) {\\n            maxCount = count\\n            index = i\\n        }\\n    }\\n    \\n    return divisors[index]\\n}\\n```\n```\\npublic class Solution {\\n    public int MaxDivScore(int[] nums, int[] divisors) {\\n        int maxCount = 0;\\n        int index = 0;\\n        \\n        for (int i = 0; i < divisors.Length; i++) {\\n            int count = 0;\\n            for (int j = 0; j < nums.Length; j++) {\\n                if (nums[j] % divisors[i] == 0) {\\n                    count++;\\n                }\\n            }\\n            \\n            if (count > maxCount || (count == maxCount && divisors[i] < divisors[index])) {\\n                maxCount = count;\\n                index = i;\\n            }\\n        }\\n        \\n        return divisors[index];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421910,
                "title": "c-brute-force-easy-to-understand",
                "content": "````\\n\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int x = 0, y = 0,ans = INT_MAX;\\n        for(auto &i: divisors){\\n            x = 0;\\n            for(auto &j: nums){\\n                if(j%i==0){\\n                    x++;\\n                }\\n            }\\n            if(x>y){\\n                y = x;\\n                ans = i;\\n            }\\n            if(x==y){\\n                ans = min(ans,i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "````\\n\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int x = 0, y = 0,ans = INT_MAX;\\n        for(auto &i: divisors){\\n            x = 0;\\n            for(auto &j: nums){\\n                if(j%i==0){\\n                    x++;\\n                }\\n            }\\n            if(x>y){\\n                y = x;\\n                ans = i;\\n            }\\n            if(x==y){\\n                ans = min(ans,i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421860,
                "title": "c-easy-peasy-solution-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe function maxDivisor takes in two vectors nums and divisors. It first initializes an unordered map scores to map each divisor to its     score. It then loops through each divisor in divisors, counts its score by looping through each number in nums, and updates max_score and      max_divisor if the score is greater than max_score or equal to max_score and the divisor is less than max_divisor. Finally, it returns       max_divisor\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        \\n        unordered_map<int, int> scores; // map each divisor to its score\\n        \\n        int max_score = 0;\\n        int max_divisor = divisors[0];\\n        \\n        for (int divisor : divisors) \\n        {\\n            scores[divisor] = 0;\\n            \\n            for (int num : nums) \\n            {\\n                if (num % divisor == 0) \\n                    scores[divisor]++;\\n            }\\n            \\n            if (scores[divisor] > max_score || (scores[divisor] == max_score && divisor < max_divisor)) \\n            {\\n                max_score = scores[divisor];\\n                max_divisor = divisor;\\n            }\\n        }\\n        \\n        return max_divisor;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        \\n        unordered_map<int, int> scores; // map each divisor to its score\\n        \\n        int max_score = 0;\\n        int max_divisor = divisors[0];\\n        \\n        for (int divisor : divisors) \\n        {\\n            scores[divisor] = 0;\\n            \\n            for (int num : nums) \\n            {\\n                if (num % divisor == 0) \\n                    scores[divisor]++;\\n            }\\n            \\n            if (scores[divisor] > max_score || (scores[divisor] == max_score && divisor < max_divisor)) \\n            {\\n                max_score = scores[divisor];\\n                max_divisor = divisor;\\n            }\\n        }\\n        \\n        return max_divisor;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421846,
                "title": "c-easytounderstand-optimalsolution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int count = 0;\\n        int hold = INT_MAX;\\n        for(int i=0;i<divisors.size();i++){\\n            int curr = 0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%divisors[i] == 0) \\n                    curr++;\\n            }\\n            if(curr > count){\\n                count = curr;\\n                hold = divisors[i];\\n            }\\n            if(curr == count && divisors[i]<hold)\\n                hold = divisors[i];\\n        }\\n        return hold;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int count = 0;\\n        int hold = INT_MAX;\\n        for(int i=0;i<divisors.size();i++){\\n            int curr = 0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%divisors[i] == 0) \\n                    curr++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3421825,
                "title": "clean-easy-solution",
                "content": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        mD = 0\\n        res = min(divisors)\\n        for d in divisors:\\n            cntr = 0\\n            for num in nums:\\n                if num%d == 0:\\n                    cntr += 1\\n            if cntr > mD:\\n                res = d\\n                mD = cntr\\n            elif cntr == mD:\\n                res = min(res,d)\\n        return res",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        mD = 0\\n        res = min(divisors)\\n        for d in divisors:\\n            cntr = 0\\n            for num in nums:\\n                if num%d == 0:\\n                    cntr += 1\\n            if cntr > mD:\\n                res = d\\n                mD = cntr\\n            elif cntr == mD:\\n                res = min(res,d)\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 3421772,
                "title": "c-beginer-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n       int n=divisors.size();\\n        vector<int> s(n,0);\\n       vector<pair<int,int>> vec;\\n        for(int i=0;i<n;i++){\\n            int c=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%divisors[i]==0)c++;\\n            }\\n            vec.push_back({c,divisors[i]});\\n        }\\n        sort(vec.begin(),vec.end());\\n        int x=vec[vec.size()-1].first;\\n        for(auto it: vec){\\n            if(it.first==x){\\n                return it.second;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n       int n=divisors.size();\\n        vector<int> s(n,0);\\n       vector<pair<int,int>> vec;\\n        for(int i=0;i<n;i++){\\n            int c=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%divisors[i]==0)c++;\\n            }\\n            vec.push_back({c,divisors[i]});\\n        }\\n        sort(vec.begin(),vec.end());\\n        int x=vec[vec.size()-1].first;\\n        for(auto it: vec){\\n            if(it.first==x){\\n                return it.second;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3900329,
                "title": "java-beginner-bruteforce-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        \\n       \\n        int a=0;\\n        int aa=Integer.MAX_VALUE;\\n        for(int i=divisors.length-1;i>=0;i--){\\n            int d=divisors[i];\\n             int c=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%d==0)\\n                c++;\\n            }\\n            if(c==a){\\n                aa=Math.min(aa,d);\\n\\n            }\\n            if(c>a){\\n                a=c;\\n                aa=d;\\n\\n            }\\n        }\\n        return aa;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        \\n       \\n        int a=0;\\n        int aa=Integer.MAX_VALUE;\\n        for(int i=divisors.length-1;i>=0;i--){\\n            int d=divisors[i];\\n             int c=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%d==0)\\n                c++;\\n            }\\n            if(c==a){\\n                aa=Math.min(aa,d);\\n\\n            }\\n            if(c>a){\\n                a=c;\\n                aa=d;\\n\\n            }\\n        }\\n        return aa;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698119,
                "title": "python-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        count = 0\\n        maximal = 0\\n        result = []\\n        for divisor in divisors:\\n            for n in nums:\\n                if n % divisor == 0:\\n                    count += 1\\n            if count > maximal:\\n                maximal = count\\n                result = [divisor]\\n            elif count == maximal:\\n                result.append(divisor)\\n            count = 0\\n        return min(result)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        count = 0\\n        maximal = 0\\n        result = []\\n        for divisor in divisors:\\n            for n in nums:\\n                if n % divisor == 0:\\n                    count += 1\\n            if count > maximal:\\n                maximal = count\\n                result = [divisor]\\n            elif count == maximal:\\n                result.append(divisor)\\n            count = 0\\n        return min(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518098,
                "title": "find-the-maximum-divisibility-score-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int i, j, score, max=0, ans=divisors[0];\\n        for(i=0 ; i<divisors.size() ; i++)\\n        {\\n            score = 0;\\n            for(j=0 ; j<nums.size() ; j++)\\n            {\\n                if(nums[j]%divisors[i]==0)\\n                {\\n                    score++;\\n                }\\n            }\\n            if(score>max)\\n            {\\n                max = score;\\n                ans = divisors[i];\\n            }\\n            else if(score==max && divisors[i]<ans)\\n            {\\n                ans = divisors[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/e7d4450c-db89-4385-9fe3-6c42fad1000c_1683948810.613229.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int i, j, score, max=0, ans=divisors[0];\\n        for(i=0 ; i<divisors.size() ; i++)\\n        {\\n            score = 0;\\n            for(j=0 ; j<nums.size() ; j++)\\n            {\\n                if(nums[j]%divisors[i]==0)\\n                {\\n                    score++;\\n                }\\n            }\\n            if(score>max)\\n            {\\n                max = score;\\n                ans = divisors[i];\\n            }\\n            else if(score==max && divisors[i]<ans)\\n            {\\n                ans = divisors[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503665,
                "title": "easy-solution-with-50-beats-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n       ArrayList<Integer> list = new ArrayList<>();\\n       ArrayList<Integer> finalList = new ArrayList<>();\\n\\n       int j = 0;\\n       while(j<divisors.length){\\n           int i = 0;\\n           int count = 0;\\n           while(i<nums.length){\\n           if(nums[i]%divisors[j] == 0){\\n               count++;\\n           }\\n           i++;\\n        }\\n        list.add(count);\\n           j++;\\n        }\\n\\n        int a = Collections.max(list);\\n        for(int m =0 ; m<list.size(); m++){\\n            if(a == list.get(m)){\\n                finalList.add(divisors[m]);\\n            }\\n        }\\n\\n\\n\\n        return Collections.min(finalList);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n       ArrayList<Integer> list = new ArrayList<>();\\n       ArrayList<Integer> finalList = new ArrayList<>();\\n\\n       int j = 0;\\n       while(j<divisors.length){\\n           int i = 0;\\n           int count = 0;\\n           while(i<nums.length){\\n           if(nums[i]%divisors[j] == 0){\\n               count++;\\n           }\\n           i++;\\n        }\\n        list.add(count);\\n           j++;\\n        }\\n\\n        int a = Collections.max(list);\\n        for(int m =0 ; m<list.size(); m++){\\n            if(a == list.get(m)){\\n                finalList.add(divisors[m]);\\n            }\\n        }\\n\\n\\n\\n        return Collections.min(finalList);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499101,
                "title": "easy-java-solution-not-good-beats-though",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int score[][] = new int[divisors.length][2];\\n        for(int i=0; i<divisors.length; i++) {\\n            int count = 0;\\n            for(int j=0; j<nums.length; j++) {\\n                if(nums[j] % divisors[i] == 0) {\\n                    count++;\\n                }\\n            }\\n            score[i][0] = divisors[i];\\n            score[i][1] = count;\\n        }\\n        Arrays.sort(score, Comparator.comparingDouble(o -> o[1]));\\n\\n        ArrayList<Integer> ansList = new ArrayList<>();\\n        ansList.add(score[score.length-1][0]);\\n        for(int k=score.length-2; k>=0; k--) {\\n            if(score[score.length-1][1]==score[k][1]) {\\n                ansList.add(score[k][0]);\\n            }\\n        }\\n\\n        Collections.sort(ansList);\\n        return ansList.get(0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int score[][] = new int[divisors.length][2];\\n        for(int i=0; i<divisors.length; i++) {\\n            int count = 0;\\n            for(int j=0; j<nums.length; j++) {\\n                if(nums[j] % divisors[i] == 0) {\\n                    count++;\\n                }\\n            }\\n            score[i][0] = divisors[i];\\n            score[i][1] = count;\\n        }\\n        Arrays.sort(score, Comparator.comparingDouble(o -> o[1]));\\n\\n        ArrayList<Integer> ansList = new ArrayList<>();\\n        ansList.add(score[score.length-1][0]);\\n        for(int k=score.length-2; k>=0; k--) {\\n            if(score[score.length-1][1]==score[k][1]) {\\n                ansList.add(score[k][0]);\\n            }\\n        }\\n\\n        Collections.sort(ansList);\\n        return ansList.get(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436628,
                "title": "swift-functional-approach",
                "content": "**Functional Approach (accepted answer)**\\n```\\nclass Solution {\\n    func maxDivScore(_ nums: [Int], _ divisors: [Int]) -> Int {\\n        divisors.reduce((maxScore: -1, minDivisor: 0)) { result, divisor in\\n            let score = nums.reduce(0) { score, num in score + (num % divisor == 0 ? 1: 0) }\\n            let update = score > result.maxScore || (score == result.maxScore && divisor < result.minDivisor)\\n            return update ? (maxScore: score, minDivisor: divisor) : result\\n        }.minDivisor\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxDivScore(_ nums: [Int], _ divisors: [Int]) -> Int {\\n        divisors.reduce((maxScore: -1, minDivisor: 0)) { result, divisor in\\n            let score = nums.reduce(0) { score, num in score + (num % divisor == 0 ? 1: 0) }\\n            let update = score > result.maxScore || (score == result.maxScore && divisor < result.minDivisor)\\n            return update ? (maxScore: score, minDivisor: divisor) : result\\n        }.minDivisor\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426648,
                "title": "beats-100-java-simple-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe are takin a boolean  variable as false to check whether the count remains 0 case.\\nso what we did is we first ran the outer loop for divisor array then we run a inner loop for nums array and go on checking for the count of nums element those are divisible by divisor array element. Then we check for a condition if **(maxCount< count)** we will update it and mark as true. Else we will check for the **count==maxCount** and we will check that our res has updated or not by the help of boolean variable. if It is then we simply update res. If boolean variable remains false then we simply find min because it means no of count remains 0 for all the element.\\nAnd at last we will check boolean variable value if its true we simply return res else we return min.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nums.length*divisors.length)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        \\n  \\t\\tint maxCount = 0, res = 0,min=Integer.MAX_VALUE;\\n\\t\\tboolean isGreater=false;\\n\\n\\t\\tfor (int i = 0; i < divisors.length; i++) {\\n\\t\\t\\tint count = 0 ;\\n\\t\\t\\t//res = div[i];\\n\\n\\t\\t\\tfor (int j = 0; j < nums.length; j++) {\\n\\t\\t\\t\\tif (nums[j] % divisors[i] == 0) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (maxCount < count) {\\n\\t\\t\\t\\tmaxCount = count;\\n\\t\\t\\t\\tres = divisors[i];\\n\\t\\t\\t\\tisGreater=true;\\n\\t\\t\\t}\\n            if(maxCount == count) {\\n\\t\\t\\t\\tif(res > divisors[i] && isGreater) {\\n\\t\\t\\t\\t\\tres = divisors[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(min>divisors[i]) {\\n\\t\\t\\t\\t\\tmin=divisors[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn (isGreater)?res:min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        \\n  \\t\\tint maxCount = 0, res = 0,min=Integer.MAX_VALUE;\\n\\t\\tboolean isGreater=false;\\n\\n\\t\\tfor (int i = 0; i < divisors.length; i++) {\\n\\t\\t\\tint count = 0 ;\\n\\t\\t\\t//res = div[i];\\n\\n\\t\\t\\tfor (int j = 0; j < nums.length; j++) {\\n\\t\\t\\t\\tif (nums[j] % divisors[i] == 0) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (maxCount < count) {\\n\\t\\t\\t\\tmaxCount = count;\\n\\t\\t\\t\\tres = divisors[i];\\n\\t\\t\\t\\tisGreater=true;\\n\\t\\t\\t}\\n            if(maxCount == count) {\\n\\t\\t\\t\\tif(res > divisors[i] && isGreater) {\\n\\t\\t\\t\\t\\tres = divisors[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(min>divisors[i]) {\\n\\t\\t\\t\\t\\tmin=divisors[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn (isGreater)?res:min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425957,
                "title": "brute-force-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) \\n    {\\n        int score = 0;\\n        int ans   = *min_element(divisors.begin(),divisors.end());\\n\\n        for(int i=0;i<divisors.size();i++)\\n        {\\n            int count = 0;\\n            for(int j=0;j<nums.size();j++)\\n            {\\n                   if((nums[j] % divisors[i]) == 0)\\n                   {\\n                       count++;\\t\\n                   }\\t\\t\\n            }\\n            if(count > score)\\n            {\\n                ans = divisors[i];\\n                score = count;\\n            }\\n            else if(count == score and divisors[i] < ans)\\n            {\\n                 ans = divisors[i];\\n            }\\n        }\\n        return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) \\n    {\\n        int score = 0;\\n        int ans   = *min_element(divisors.begin(),divisors.end());\\n\\n        for(int i=0;i<divisors.size();i++)\\n        {\\n            int count = 0;\\n            for(int j=0;j<nums.size();j++)\\n            {\\n                   if((nums[j] % divisors[i]) == 0)\\n                   {\\n                       count++;\\t\\n                   }\\t\\t\\n            }\\n            if(count > score)\\n            {\\n                ans = divisors[i];\\n                score = count;\\n            }\\n            else if(count == score and divisors[i] < ans)\\n            {\\n                 ans = divisors[i];\\n            }\\n        }\\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424758,
                "title": "c-brute-force",
                "content": "# Complexity\\n- Time complexity: $$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n*m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int ans=0, ans2=0;\\n        for (int i=0; i<divisors.size(); i++){\\n            int curr=0;\\n            for (int j=0; j<nums.size(); j++){\\n                if (nums[j]%divisors[i]==0)curr++;\\n            }\\n            if (curr>ans){\\n                ans= curr;\\n                ans2= i;\\n            }\\n            else if (curr==ans && divisors[i]<divisors[ans2]){\\n                ans2=i;\\n                ans= curr;\\n            }\\n        }\\n        return divisors[ans2];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Matrix",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int ans=0, ans2=0;\\n        for (int i=0; i<divisors.size(); i++){\\n            int curr=0;\\n            for (int j=0; j<nums.size(); j++){\\n                if (nums[j]%divisors[i]==0)curr++;\\n            }\\n            if (curr>ans){\\n                ans= curr;\\n                ans2= i;\\n            }\\n            else if (curr==ans && divisors[i]<divisors[ans2]){\\n                ans2=i;\\n                ans= curr;\\n            }\\n        }\\n        return divisors[ans2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422931,
                "title": "easy-c-solution-brute-force-map",
                "content": "# Intuition\\nBrute force approach and  to reduce repeated calculation  map is used.\\n\\n# Approach\\nBrute force +map\\n\\n# Complexity\\n- Time complexity:\\nO(n*m)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        map<int,int>mp;\\n        int maxi=INT_MIN;\\n        int ans=0;\\n        for(auto it:divisors){\\n     //avoiding repeated divisors\\n            if(mp[it]==0){\\n                for(int i=0;i<nums.size();i++){\\n                if(nums[i]%it==0){\\n                    mp[it]+=1;\\n                }\\n            }\\n            }\\n        }\\n        for(auto it:mp){\\n            if(it.second>maxi){\\n                maxi=it.second;\\n                ans=it.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        map<int,int>mp;\\n        int maxi=INT_MIN;\\n        int ans=0;\\n        for(auto it:divisors){\\n     //avoiding repeated divisors\\n            if(mp[it]==0){\\n                for(int i=0;i<nums.size();i++){\\n                if(nums[i]%it==0){\\n                    mp[it]+=1;\\n                }\\n            }\\n            }\\n        }\\n        for(auto it:mp){\\n            if(it.second>maxi){\\n                maxi=it.second;\\n                ans=it.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422913,
                "title": "146-ms",
                "content": "```rust\\nimpl Solution {\\n    pub fn max_div_score(mut a: Vec<i32>, mut b: Vec<i32>) -> i32 {\\n        a.sort(); b.sort(); let az = a.len();\\n        let (mut r, mut m, mut s, mut p) = (0, -1, 0usize, 0);\\n        for d in b {\\n            if d == p { continue } else { p = d }\\n            while s < az && a[s] < d { s += 1 }\\n            if (az - s) as i32 <= m { break }\\n            let mut c = 0;\\n            for j in s..az {\\n                if a[j] % d == 0 { c += 1 }\\n            }\\n            if c > m { r = d; m = c }\\n        }\\n        r\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn max_div_score(mut a: Vec<i32>, mut b: Vec<i32>) -> i32 {\\n        a.sort(); b.sort(); let az = a.len();\\n        let (mut r, mut m, mut s, mut p) = (0, -1, 0usize, 0);\\n        for d in b {\\n            if d == p { continue } else { p = d }\\n            while s < az && a[s] < d { s += 1 }\\n            if (az - s) as i32 <= m { break }\\n            let mut c = 0;\\n            for j in s..az {\\n                if a[j] % d == 0 { c += 1 }\\n            }\\n            if c > m { r = d; m = c }\\n        }\\n        r\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3422695,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        ans=-1\\n        most=-1\\n        for d in divisors:\\n            cnt=sum(1 for n in nums if n%d==0)\\n            if cnt>most or cnt==most and d<ans:\\n                ans=d\\n                most=cnt\\n\\n        return ans        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        ans=-1\\n        most=-1\\n        for d in divisors:\\n            cnt=sum(1 for n in nums if n%d==0)\\n            if cnt>most or cnt==most and d<ans:\\n                ans=d\\n                most=cnt\\n\\n        return ans        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422287,
                "title": "no-brute-force-highly-optimized-enough-for-n-1e5",
                "content": "# Approach\\nsuppose n = 20\\nAll the prime factors of 30 = {2,3,5}\\nand all the divisors of 20 = {1,2,3,6,5,10,15,30}\\nwhich can be genrated by the combination from the prime numbers.\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    vector<int> allDivisor(int n){\\n        // calculate all prime factors of n\\n        map<int,int> primes;\\n        for(long long i=2; i<=sqrt(n); i++) {\\n            while(n%i == 0) {\\n                primes[i]++;\\n                n/=i;\\n            }\\n        }\\n        if (n > 1) primes[n]++;\\n\\n        // make all divisors by primes\\n        vector<int> divisors = {1};\\n        for(auto&p: primes) {\\n            int sz = divisors.size();\\n            int cur = 1;\\n            for (int i=0; i <p.second; i++) {\\n                cur *= p.first;\\n                for (int j = 0; j < sz; j++) {\\n                    divisors.push_back(divisors[j] * cur);\\n                }\\n            }\\n        }\\n        return divisors;\\n    }\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        map<int,int> freq; // used to store the frequency of each number which is the factor if nums[i]\\n        set<int> st(begin(divisors),end(divisors)); // It\\'s for like storing the frequency of elements which is only present in divisors array. (It\\'s for space optimisation)\\n\\n        // storing the divisors of all the elements of nums[i]\\n        for(int&num: nums){\\n            auto factors = allDivisor(num);\\n            for(int&factor: factors)\\n                if(st.count(factor)) freq[factor]++;\\n        }\\n\\n        // simply checking the freq of each divisors[i] in freq map\\n        int maxfreq = -1,ans = -1,mn = 1e9;\\n        for(int&e: divisors){\\n            if(freq.count(e)){\\n                int val = freq[e];\\n                if(maxfreq < val){\\n                    maxfreq = val;\\n                    ans = e;\\n                }else if(maxfreq == val){\\n                    ans = min(ans,e);\\n                }\\n            }\\n            mn = min(mn,e);\\n        }\\n        return ans == -1 ? mn : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int> allDivisor(int n){\\n        // calculate all prime factors of n\\n        map<int,int> primes;\\n        for(long long i=2; i<=sqrt(n); i++) {\\n            while(n%i == 0) {\\n                primes[i]++;\\n                n/=i;\\n            }\\n        }\\n        if (n > 1) primes[n]++;\\n\\n        // make all divisors by primes\\n        vector<int> divisors = {1};\\n        for(auto&p: primes) {\\n            int sz = divisors.size();\\n            int cur = 1;\\n            for (int i=0; i <p.second; i++) {\\n                cur *= p.first;\\n                for (int j = 0; j < sz; j++) {\\n                    divisors.push_back(divisors[j] * cur);\\n                }\\n            }\\n        }\\n        return divisors;\\n    }\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        map<int,int> freq; // used to store the frequency of each number which is the factor if nums[i]\\n        set<int> st(begin(divisors),end(divisors)); // It\\'s for like storing the frequency of elements which is only present in divisors array. (It\\'s for space optimisation)\\n\\n        // storing the divisors of all the elements of nums[i]\\n        for(int&num: nums){\\n            auto factors = allDivisor(num);\\n            for(int&factor: factors)\\n                if(st.count(factor)) freq[factor]++;\\n        }\\n\\n        // simply checking the freq of each divisors[i] in freq map\\n        int maxfreq = -1,ans = -1,mn = 1e9;\\n        for(int&e: divisors){\\n            if(freq.count(e)){\\n                int val = freq[e];\\n                if(maxfreq < val){\\n                    maxfreq = val;\\n                    ans = e;\\n                }else if(maxfreq == val){\\n                    ans = min(ans,e);\\n                }\\n            }\\n            mn = min(mn,e);\\n        }\\n        return ans == -1 ? mn : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422159,
                "title": "optimized-java-solution-easy-structured-with-comments-and-approach",
                "content": "# Approach\\nWe will iterate through all the divisors and check how many of the numbers they can divide. While doing this, we will keep track of the divisor which divided maximum of numbers.\\n\\nNote: The only thing that can cause error in this problem is the edge condition. i.e. if the maximum count is same, we need to return the minimum divisor that had that score. Hence, we need to add an extra condition for it.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(M*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int maxScore=-1;\\n        int maxElement=-1;\\n        for(int i=0;i<divisors.length;i++){\\n            // count of numbers ith divisor can divide\\n            int score=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%divisors[i]==0)\\n                    score++;\\n            }\\n\\n            // updating max count\\n            if(score==maxScore) // edge condition\\n                maxElement=Math.min(maxElement,divisors[i]);\\n            else if(score>maxScore){\\n                maxScore=score;\\n                maxElement=divisors[i];\\n            }\\n        }\\n        return maxElement;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int maxScore=-1;\\n        int maxElement=-1;\\n        for(int i=0;i<divisors.length;i++){\\n            // count of numbers ith divisor can divide\\n            int score=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%divisors[i]==0)\\n                    score++;\\n            }\\n\\n            // updating max count\\n            if(score==maxScore) // edge condition\\n                maxElement=Math.min(maxElement,divisors[i]);\\n            else if(score>maxScore){\\n                maxScore=score;\\n                maxElement=divisors[i];\\n            }\\n        }\\n        return maxElement;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422129,
                "title": "find-the-maximum-divisibility-score-simple-approach-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& div) {\\n        int maxcnt = 0;\\n        int ans=INT_MAX;\\n        for(int i=0;i<div.size();i++){\\n            int cnt=0;int f = 1;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%div[i]==0){\\n                    cnt++;\\n                }\\n            }\\n            if(cnt>maxcnt){\\n                ans = div[i];\\n                maxcnt = cnt;\\n            }else if(cnt==maxcnt){\\n                ans = min(ans,div[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& div) {\\n        int maxcnt = 0;\\n        int ans=INT_MAX;\\n        for(int i=0;i<div.size();i++){\\n            int cnt=0;int f = 1;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%div[i]==0){\\n                    cnt++;\\n                }\\n            }\\n            if(cnt>maxcnt){\\n                ans = div[i];\\n                maxcnt = cnt;\\n            }else if(cnt==maxcnt){\\n                ans = min(ans,div[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422083,
                "title": "easyapproach-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe initialize maxScore to -1 and maxDivisor to Integer.MAX_VALUE.\\n\\n Then, we loop through all the divisors in the array divisors. \\n\\nFor each divisor, we count the number of elements in the array nums that are divisible by that divisor. \\n\\nIf this count is greater than the current maximum score, we update maxScore and maxDivisor to the current divisor. \\n\\nIf the score is equal to the current maximum score, we update maxDivisor only if the current divisor is smaller than the current maximum divisor.\\n\\nFinally, we return maxDivisor as the integer with the maximum divisibility score.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO (nxn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO (1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n    int maxScore = -1;\\n    int maxDivisor = Integer.MAX_VALUE;\\n\\n    for (int divisor : divisors) {\\n        int score = 0;\\n        for (int num : nums) {\\n            if (num % divisor == 0) {\\n                score++;\\n            }\\n        }\\n        if (score > maxScore || (score == maxScore && divisor < maxDivisor)) {\\n            maxScore = score;\\n            maxDivisor = divisor;\\n        }\\n    }\\n\\n    return maxDivisor;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n    int maxScore = -1;\\n    int maxDivisor = Integer.MAX_VALUE;\\n\\n    for (int divisor : divisors) {\\n        int score = 0;\\n        for (int num : nums) {\\n            if (num % divisor == 0) {\\n                score++;\\n            }\\n        }\\n        if (score > maxScore || (score == maxScore && divisor < maxDivisor)) {\\n            maxScore = score;\\n            maxDivisor = divisor;\\n        }\\n    }\\n\\n    return maxDivisor;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422042,
                "title": "best-c-well-explained-brute-force",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntake divisor and check for every element of num is divisible or not and count the total number of divisible number.\\nafter that store it to the map. if same divisor come more then one time then we dont calculate it multiple time it is already stored in our map. simply skip same divisor.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n***O(N * M)***\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n***O(1)***\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        map<int, int> mp;\\n        for(int i=0; i<divisors.size(); i++)    {\\n            int cnt = 0;\\n            // same number comming then skip it ::\\n            if(mp.find(divisors[i]) != mp.end())    continue;\\n\\n            // count the number of divisible element in nums\\n            for(int j=0; j<nums.size(); j++)    \\n                if(nums[j] % divisors[i] == 0)  cnt++;\\n            \\n            mp[divisors[i]] = cnt;\\n        }\\n        int ans = *min_element(divisors.begin(), divisors.end());\\n        int cnt = mp[ans];\\n        for(auto it : mp)   {\\n            if(it.second > cnt) {\\n                cnt = it.second;\\n                ans = it.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        map<int, int> mp;\\n        for(int i=0; i<divisors.size(); i++)    {\\n            int cnt = 0;\\n            // same number comming then skip it ::\\n            if(mp.find(divisors[i]) != mp.end())    continue;\\n\\n            // count the number of divisible element in nums\\n            for(int j=0; j<nums.size(); j++)    \\n                if(nums[j] % divisors[i] == 0)  cnt++;\\n            \\n            mp[divisors[i]] = cnt;\\n        }\\n        int ans = *min_element(divisors.begin(), divisors.end());\\n        int cnt = mp[ans];\\n        for(auto it : mp)   {\\n            if(it.second > cnt) {\\n                cnt = it.second;\\n                ans = it.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422041,
                "title": "c-simple-divisibility-check",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCheck if a number divides another number.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor each divisors[i]--> if nums[j] is divisible by divisors[i], then increment the divisibiltiy score of divisors[i]\\n\\n# Complexity\\n- Time complexity: O(mn), m= length of divisors, n= length of nums\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& v, vector<int>& d) {\\n        int maxD= 0, ans=*min_element(d.begin(), d.end());\\n        for(int i=0;i<d.size();i++){\\n            int c=0;\\n            for(int j=0;j<v.size();j++){\\n                if(v[j]%d[i]==0) c++;\\n            }\\n            if(c>=maxD){\\n                if(c>maxD){\\n                maxD= c; ans= d[i];\\n                }\\n                else{\\n                    ans= min(ans, d[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& v, vector<int>& d) {\\n        int maxD= 0, ans=*min_element(d.begin(), d.end());\\n        for(int i=0;i<d.size();i++){\\n            int c=0;\\n            for(int j=0;j<v.size();j++){\\n                if(v[j]%d[i]==0) c++;\\n            }\\n            if(c>=maxD){\\n                if(c>maxD){\\n                maxD= c; ans= d[i];\\n                }\\n                else{\\n                    ans= min(ans, d[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421962,
                "title": "c-solutions-beginner-friendly-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int ans = 0, most = -1; \\n        for (auto& div : divisors) {\\n            int cnt = 0; \\n            for (auto & x : nums) {\\n                if (x % div == 0) ++ cnt; \\n            }\\n            if (cnt > most || cnt == most && div < ans) {ans = div, most = cnt; }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int ans = 0, most = -1; \\n        for (auto& div : divisors) {\\n            int cnt = 0; \\n            for (auto & x : nums) {\\n                if (x % div == 0) ++ cnt; \\n            }\\n            if (cnt > most || cnt == most && div < ans) {ans = div, most = cnt; }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421937,
                "title": "javascript-direct-way-516ms",
                "content": "```\\nconst maxDivScore = (a, b) => {\\n    let f = [];\\n    b.map((d, i) => {\\n        let cnt = 0;\\n        for (const x of a) {\\n            if (x % d == 0) cnt++;\\n        }\\n        f.push([cnt, d]);\\n    });\\n    f.sort((x, y) => y[0] - x[0] || x[1] - y[1]);\\n    return f[0][1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sort"
                ],
                "code": "```\\nconst maxDivScore = (a, b) => {\\n    let f = [];\\n    b.map((d, i) => {\\n        let cnt = 0;\\n        for (const x of a) {\\n            if (x % d == 0) cnt++;\\n        }\\n        f.push([cnt, d]);\\n    });\\n    f.sort((x, y) => y[0] - x[0] || x[1] - y[1]);\\n    return f[0][1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3421925,
                "title": "easy-c-solution-t-c-o-nm-s-c-o-m",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given problem asks us to find the divisor in the input array divisors that has the highest divisibility score in the input array nums.\\n\\nTo solve this problem, we need to iterate over each divisor and count the number of elements in nums that are divisible by the current divisor. We can store the score for each divisor in an unordered map. After calculating the score for each divisor, we can then find the divisor with the highest score and return it. If there are multiple divisors with the same highest score, we can break the tie by choosing the smallest divisor.\\n\\nThe intuition behind this approach is that the divisibility score for a divisor is simply the count of the number of elements in nums that are divisible by the divisor. By iterating over each divisor and counting the number of elements that are divisible by it, we can determine which divisor has the highest score. The use of an unordered map allows us to store the score for each divisor and quickly look up the score for a given divisor during the iteration.\\n\\nOverall, the approach is straightforward and efficient, with a time complexity of O(nm) and a space complexity of O(m).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach of the given code is to use a nested loop to calculate the divisibility score of each divisor by iterating over the input array nums.\\n\\nFor each divisor, the code iterates over each element of nums and checks if the element is divisible by the current divisor. If it is, it increments the score for the divisor. Finally, the code checks which divisor has the highest score and returns it. If there are multiple divisors with the same highest score, it returns the smallest of them.\\n\\n# Complexity\\n- Time complexity: O(nm)\\n-  where n is the length of nums and m is the length of divisors. This is because for each divisor in divisors, the code iterates over each element in nums. However, since the length of divisors is at most 1000, this code should run efficiently for most practical inputs.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m)\\n- where m is the length of divisors. This is because the code uses an unordered map to store the divisibility score for each divisor, which takes up space proportional to the number of divisors.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n          unordered_map<int, int> mp;\\n          int maxScore = 0, maxDivisor = INT_MAX;\\n\\n          for (int divisor : divisors) {\\n              mp[divisor] = 0;\\n          for (int num : nums) {\\n              if (num % divisor == 0) {\\n                mp[divisor]++;\\n              }\\n            }\\n         if (mp[divisor] > maxScore) {\\n            maxScore = mp[divisor];\\n            maxDivisor = divisor;\\n        }\\n        else if (mp[divisor] == maxScore) {\\n            maxDivisor = min(maxDivisor, divisor);\\n        }\\n      }\\n    return maxDivisor;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n          unordered_map<int, int> mp;\\n          int maxScore = 0, maxDivisor = INT_MAX;\\n\\n          for (int divisor : divisors) {\\n              mp[divisor] = 0;\\n          for (int num : nums) {\\n              if (num % divisor == 0) {\\n                mp[divisor]++;\\n              }\\n            }\\n         if (mp[divisor] > maxScore) {\\n            maxScore = mp[divisor];\\n            maxDivisor = divisor;\\n        }\\n        else if (mp[divisor] == maxScore) {\\n            maxDivisor = min(maxDivisor, divisor);\\n        }\\n      }\\n    return maxDivisor;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421905,
                "title": "ez-brute-force-again-c-java-python",
                "content": "# Intuition\\nJust count the number of divisors for each divisors[i] in nums array. Since the constraints are low, TC: O(m*n) is feasible solution.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(M*N)\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors)\\n    {\\n        int d = divisors.size();\\n        vector<int> res(d,0);\\n        int maxDiv = 0;\\n        for(int i=0; i<d; i++)\\n        {\\n            int div = divisors[i];\\n            for(auto x : nums)\\n            {\\n                if(x%div == 0){\\n                    res[i]++;\\n                }\\n            }\\n            maxDiv = max(maxDiv, res[i]);\\n        }\\n        \\n        int ans = INT_MAX;\\n        for(int i=0; i<d; i++)\\n        {\\n            if(res[i] == maxDiv){\\n                ans = min(ans, divisors[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int d = divisors.length;\\n        int[] res = new int[d];\\n        int maxDiv = 0;\\n        for(int i=0; i<d; i++) {\\n            int div = divisors[i];\\n            for(int x : nums) {\\n                if(x % div == 0) {\\n                    res[i]++;\\n                }\\n            }\\n            maxDiv = Math.max(maxDiv, res[i]);\\n        }\\n\\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0; i<d; i++) {\\n            if(res[i] == maxDiv) {\\n                ans = Math.min(ans, divisors[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        d = len(divisors)\\n        res = [0] * d\\n        maxDiv = 0\\n        for i in range(d):\\n            div = divisors[i]\\n            for x in nums:\\n                if x % div == 0:\\n                    res[i] += 1\\n            maxDiv = max(maxDiv, res[i])\\n\\n        ans = float(\\'inf\\')\\n        for i in range(d):\\n            if res[i] == maxDiv:\\n                ans = min(ans, divisors[i])\\n        return ans\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors)\\n    {\\n        int d = divisors.size();\\n        vector<int> res(d,0);\\n        int maxDiv = 0;\\n        for(int i=0; i<d; i++)\\n        {\\n            int div = divisors[i];\\n            for(auto x : nums)\\n            {\\n                if(x%div == 0){\\n                    res[i]++;\\n                }\\n            }\\n            maxDiv = max(maxDiv, res[i]);\\n        }\\n        \\n        int ans = INT_MAX;\\n        for(int i=0; i<d; i++)\\n        {\\n            if(res[i] == maxDiv){\\n                ans = min(ans, divisors[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int d = divisors.length;\\n        int[] res = new int[d];\\n        int maxDiv = 0;\\n        for(int i=0; i<d; i++) {\\n            int div = divisors[i];\\n            for(int x : nums) {\\n                if(x % div == 0) {\\n                    res[i]++;\\n                }\\n            }\\n            maxDiv = Math.max(maxDiv, res[i]);\\n        }\\n\\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0; i<d; i++) {\\n            if(res[i] == maxDiv) {\\n                ans = Math.min(ans, divisors[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        d = len(divisors)\\n        res = [0] * d\\n        maxDiv = 0\\n        for i in range(d):\\n            div = divisors[i]\\n            for x in nums:\\n                if x % div == 0:\\n                    res[i] += 1\\n            maxDiv = max(maxDiv, res[i])\\n\\n        ans = float(\\'inf\\')\\n        for i in range(d):\\n            if res[i] == maxDiv:\\n                ans = min(ans, divisors[i])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421901,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n*m)$$\\n\\n- Space complexity:$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& n, vector<int>& d) {\\n        int cnt1=0, cnt2=0;\\n        for (int i=0; i<d.size(); i++){\\n            int l=0;\\n            for (int j=0; j<n.size(); j++){\\n                if (n[j]%d[i]==0){\\n                    l++;\\n                }\\n            }\\n            if (l>cnt1){\\n                cnt1=l;\\n                cnt2=i;\\n            }\\n            else if (l==cnt1 && d[i]<d[cnt2]){\\n                cnt2=i;\\n                cnt1=l;\\n            }\\n        }\\n        return d[cnt2];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& n, vector<int>& d) {\\n        int cnt1=0, cnt2=0;\\n        for (int i=0; i<d.size(); i++){\\n            int l=0;\\n            for (int j=0; j<n.size(); j++){\\n                if (n[j]%d[i]==0){\\n                    l++;\\n                }\\n            }\\n            if (l>cnt1){\\n                cnt1=l;\\n                cnt2=i;\\n            }\\n            else if (l==cnt1 && d[i]<d[cnt2]){\\n                cnt2=i;\\n                cnt1=l;\\n            }\\n        }\\n        return d[cnt2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421851,
                "title": "simple-java-solution-faster-than-100",
                "content": "# **Just do simple calculation and count which is maximum.**\\n# If you like please upvote it.\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int n = nums.length;\\n        int m = divisors.length;\\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        int[] d = new int[m];\\n        for(int i=0;i<m;i++)\\n        {\\n            int count = 0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(nums[j]%divisors[i]==0)\\n                {\\n                    count++;\\n                }\\n            }\\n            d[i] = count;\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            if(d[i]>=max)\\n            {\\n                max = d[i];\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            if(d[i]==max)\\n                 min = Math.min(min,divisors[i]);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int n = nums.length;\\n        int m = divisors.length;\\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        int[] d = new int[m];\\n        for(int i=0;i<m;i++)\\n        {\\n            int count = 0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(nums[j]%divisors[i]==0)\\n                {\\n                    count++;\\n                }\\n            }\\n            d[i] = count;\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            if(d[i]>=max)\\n            {\\n                max = d[i];\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            if(d[i]==max)\\n                 min = Math.min(min,divisors[i]);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421845,
                "title": "java-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(n*m) where n is length of array nums and m is length of array divisors\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int maxScore = 0;\\n        int divisor = divisors[0];\\n        for(int i = 0; i < divisors.length; i++) {\\n            int currentScore = 0;\\n            \\n            for(int j = 0; j < nums.length; j++) {\\n                if(nums[j] % divisors[i] == 0) {\\n                    currentScore++;\\n                }\\n            }\\n            if(currentScore == maxScore) {\\n                divisor = Math.min(divisor, divisors[i]);\\n            }\\n            \\n            if(currentScore > maxScore) {\\n                maxScore = currentScore;\\n                divisor = divisors[i];\\n            }\\n        }\\n        return divisor;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int maxScore = 0;\\n        int divisor = divisors[0];\\n        for(int i = 0; i < divisors.length; i++) {\\n            int currentScore = 0;\\n            \\n            for(int j = 0; j < nums.length; j++) {\\n                if(nums[j] % divisors[i] == 0) {\\n                    currentScore++;\\n                }\\n            }\\n            if(currentScore == maxScore) {\\n                divisor = Math.min(divisor, divisors[i]);\\n            }\\n            \\n            if(currentScore > maxScore) {\\n                maxScore = currentScore;\\n                divisor = divisors[i];\\n            }\\n        }\\n        return divisor;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421844,
                "title": "c-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $O(n*m)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& div) {\\n        int n=nums.size(),m=div.size(),mx=0,ans=div[0];\\n        for(int i=0;i<m;i++){\\n            int a=0;\\n            for(int j=0;j<n;j++){\\n                if(nums[j]%div[i]==0) a++;\\n            }\\n            if(a>mx){\\n                mx=a;\\n                ans=div[i];\\n            }\\n            if(a==mx && div[i]<ans) ans=div[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& div) {\\n        int n=nums.size(),m=div.size(),mx=0,ans=div[0];\\n        for(int i=0;i<m;i++){\\n            int a=0;\\n            for(int j=0;j<n;j++){\\n                if(nums[j]%div[i]==0) a++;\\n            }\\n            if(a>mx){\\n                mx=a;\\n                ans=div[i];\\n            }\\n            if(a==mx && div[i]<ans) ans=div[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421791,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] div) {\\n        Arrays.sort(nums);\\n        int score=0;\\n        int ind=div[0];\\n        for(int i=0;i<div.length;i++){\\n            int count=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%div[i]==0){\\n                    count++;\\n                }\\n            }\\n            if(count>score){\\n                score=count;\\n                ind=div[i];\\n            }\\n            if(count==score)\\n                ind=Math.min(ind,div[i]);\\n        }\\n        return ind;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] div) {\\n        Arrays.sort(nums);\\n        int score=0;\\n        int ind=div[0];\\n        for(int i=0;i<div.length;i++){\\n            int count=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%div[i]==0){\\n                    count++;\\n                }\\n            }\\n            if(count>score){\\n                score=count;\\n                ind=div[i];\\n            }\\n            if(count==score)\\n                ind=Math.min(ind,div[i]);\\n        }\\n        return ind;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421789,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max= 0;\\n        int min=0;\\n     for(int j=0;j<divisors.length;j++)\\n        {\\n        int count=0;\\n            for(int i=0;i<nums.length;i++)\\n            { if((nums[i]%divisors[j])==0)\\n            {\\n                count++;\\n            }\\n            }\\n         if(max<=count)\\n         {\\n             if(count>max)\\n             {max=count;\\n             min=divisors[j];\\n             }\\n             else\\n             {\\n                if(min==0)\\n                {\\n                    min=divisors[j];\\n                    max=count;\\n                }\\n                 else\\n                 {\\n                     if(divisors[j]<min)\\n                         min=divisors[j];\\n                 }\\n             }\\n         }\\n        \\n         \\n        }\\n        \\n        \\n        return min;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max= 0;\\n        int min=0;\\n     for(int j=0;j<divisors.length;j++)\\n        {\\n        int count=0;\\n            for(int i=0;i<nums.length;i++)\\n            { if((nums[i]%divisors[j])==0)\\n            {\\n                count++;\\n            }\\n            }\\n         if(max<=count)\\n         {\\n             if(count>max)\\n             {max=count;\\n             min=divisors[j];\\n             }\\n             else\\n             {\\n                if(min==0)\\n                {\\n                    min=divisors[j];\\n                    max=count;\\n                }\\n                 else\\n                 {\\n                     if(divisors[j]<min)\\n                         min=divisors[j];\\n                 }\\n             }\\n         }\\n        \\n         \\n        }\\n        \\n        \\n        return min;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421758,
                "title": "easiest-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int min=0,max=0;\\n        for(int i=0;i<divisors.size();i++){\\n            int count=0;\\n            int div=divisors[i];\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%div==0)\\n                    count++;\\n            }\\n            if(count>=max){\\n                if(count>max){\\n                    max=count;\\n                    min=div;\\n                }\\n                else{\\n                    if(min==0)\\n                        min=div;\\n                    else{\\n                        if(div<min)\\n                            min=div;\\n                    }\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int min=0,max=0;\\n        for(int i=0;i<divisors.size();i++){\\n            int count=0;\\n            int div=divisors[i];\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%div==0)\\n                    count++;\\n            }\\n            if(count>=max){\\n                if(count>max){\\n                    max=count;\\n                    min=div;\\n                }\\n                else{\\n                    if(min==0)\\n                        min=div;\\n                    else{\\n                        if(div<min)\\n                            min=div;\\n                    }\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421742,
                "title": "c-brute-force-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int max_idx = 0;\\n        int maxi = INT_MIN;\\n        for(int i = 0; i < divisors.size(); i++)\\n        {\\n            int count = 0;\\n            for(int j = 0; j < nums.size(); j++)\\n            {\\n                if(nums[j] % divisors[i] == 0)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count > maxi)\\n            {\\n                maxi = count;\\n                max_idx = i;\\n            }\\n            else if(maxi == count)\\n            {\\n                maxi = count;\\n                if(divisors[max_idx] >= divisors[i])\\n                {\\n                    max_idx = i;\\n                }\\n            }\\n        }\\n        return divisors[max_idx];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int max_idx = 0;\\n        int maxi = INT_MIN;\\n        for(int i = 0; i < divisors.size(); i++)\\n        {\\n            int count = 0;\\n            for(int j = 0; j < nums.size(); j++)\\n            {\\n                if(nums[j] % divisors[i] == 0)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count > maxi)\\n            {\\n                maxi = count;\\n                max_idx = i;\\n            }\\n            else if(maxi == count)\\n            {\\n                maxi = count;\\n                if(divisors[max_idx] >= divisors[i])\\n                {\\n                    max_idx = i;\\n                }\\n            }\\n        }\\n        return divisors[max_idx];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421707,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int cnt=0,ans=INT_MAX;\\n        for(int i=0;i<divisors.size();i++){\\n            int c=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%divisors[i] == 0) c+=1;\\n            }\\n            if(c>cnt){\\n                cnt = c;\\n                ans = divisors[i];\\n            }\\n            if(c==cnt && divisors[i]<ans) ans = divisors[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int cnt=0,ans=INT_MAX;\\n        for(int i=0;i<divisors.size();i++){\\n            int c=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%divisors[i] == 0) c+=1;\\n            }\\n            if(c>cnt){\\n                cnt = c;\\n                ans = divisors[i];\\n            }\\n            if(c==cnt && divisors[i]<ans) ans = divisors[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4101892,
                "title": "one-line-solution",
                "content": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:  \\n        return reduce(lambda m, d: (s, d) if (s := sum(not n%d for n in nums)) > m[0] or s == m[0] and d < m[1] else m, divisors, (0, inf))[1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:  \\n        return reduce(lambda m, d: (s, d) if (s := sum(not n%d for n in nums)) > m[0] or s == m[0] and d < m[1] else m, divisors, (0, inf))[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4100103,
                "title": "python-dictionary",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        d = {}\\n        for i in range(len(divisors)):\\n            c = 0\\n            for j in nums:\\n                if j % divisors[i] == 0:\\n                    c += 1\\n            if c not in list(d.values()):\\n                d.update({divisors[i] : c})\\n            else:\\n                keys = list(d.keys())\\n                values = list(d.values())\\n                k = keys[values.index(c)]\\n                if k > divisors[i] :\\n                    del d[k]\\n                    d.update({divisors[i] : c})\\n        d = dict(sorted(d.items(), key = lambda t:t[1], reverse = True))\\n        return list(d.keys())[0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        d = {}\\n        for i in range(len(divisors)):\\n            c = 0\\n            for j in nums:\\n                if j % divisors[i] == 0:\\n                    c += 1\\n            if c not in list(d.values()):\\n                d.update({divisors[i] : c})\\n            else:\\n                keys = list(d.keys())\\n                values = list(d.values())\\n                k = keys[values.index(c)]\\n                if k > divisors[i] :\\n                    del d[k]\\n                    d.update({divisors[i] : c})\\n        d = dict(sorted(d.items(), key = lambda t:t[1], reverse = True))\\n        return list(d.keys())[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4099773,
                "title": "best-solution-tc-o-mn-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n\\n        int maxScore{-1}, divisor{};\\n\\n        for(auto i : divisors){\\n\\n            int currScore{};\\n\\n            for(auto j : nums) if(j % i == 0) currScore++;\\n            \\n            if(currScore >= maxScore){\\n                if(currScore == maxScore){\\n                    divisor = min(divisor, i);\\n                }\\n                else{\\n                    divisor = i;\\n                    maxScore = currScore;\\n                }          \\n            }\\n        }\\n\\n        return divisor;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n\\n        int maxScore{-1}, divisor{};\\n\\n        for(auto i : divisors){\\n\\n            int currScore{};\\n\\n            for(auto j : nums) if(j % i == 0) currScore++;\\n            \\n            if(currScore >= maxScore){\\n                if(currScore == maxScore){\\n                    divisor = min(divisor, i);\\n                }\\n                else{\\n                    divisor = i;\\n                    maxScore = currScore;\\n                }          \\n            }\\n        }\\n\\n        return divisor;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073612,
                "title": "basic-java-soln-97",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max=0,ans=divisors[0];\\n        for(int i:divisors){\\n            int c=0;\\n            for(int j:nums){\\n                if(j%i==0)\\n                    c++;\\n            }\\n            if(c>max||(c==max&&ans>i)){\\n                ans=i;\\n                max=c;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max=0,ans=divisors[0];\\n        for(int i:divisors){\\n            int c=0;\\n            for(int j:nums){\\n                if(j%i==0)\\n                    c++;\\n            }\\n            if(c>max||(c==max&&ans>i)){\\n                ans=i;\\n                max=c;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059500,
                "title": "beats-97-in-speed-91-in-memory",
                "content": "# Intuition\\n**just take care of current and highest score, if there is not any, return minimum of divisors**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int ans = 0,p=0;\\n        for(int i=0; i<divisors.length; i++){\\n            int c = 0;\\n            for(int j=0; j<nums.length; j++){\\n                if(nums[j] % divisors[i]==0){\\n                    c++;\\n                }\\n            }\\n            if(c>p){\\n                ans = divisors[i];\\n                p =c;\\n            }\\n            else if(c==p){\\n                ans = Math.min(ans,divisors[i]);\\n            }\\n        }\\n        if (p==0){\\n            int min = divisors[0];\\n            for(int i = 0; i<divisors.length; i++){\\n                if(min>divisors[i]){\\n                    min = divisors[i];\\n                }\\n            }\\n            return min;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int ans = 0,p=0;\\n        for(int i=0; i<divisors.length; i++){\\n            int c = 0;\\n            for(int j=0; j<nums.length; j++){\\n                if(nums[j] % divisors[i]==0){\\n                    c++;\\n                }\\n            }\\n            if(c>p){\\n                ans = divisors[i];\\n                p =c;\\n            }\\n            else if(c==p){\\n                ans = Math.min(ans,divisors[i]);\\n            }\\n        }\\n        if (p==0){\\n            int min = divisors[0];\\n            for(int i = 0; i<divisors.length; i++){\\n                if(min>divisors[i]){\\n                    min = divisors[i];\\n                }\\n            }\\n            return min;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055013,
                "title": "beat-97-in-memory-and-easy-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        m=-1\\n        ans=-1\\n        for i in divisors:\\n            d=0\\n            for j in nums:\\n                if j%i==0:\\n                    d+=1\\n            if d>m or d==m and i<ans:\\n                ans=i\\n                m=d\\n        return ans\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        m=-1\\n        ans=-1\\n        for i in divisors:\\n            d=0\\n            for j in nums:\\n                if j%i==0:\\n                    d+=1\\n            if d>m or d==m and i<ans:\\n                ans=i\\n                m=d\\n        return ans\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043958,
                "title": "java-98-beats-beginner-friendly-but-not-too-much-optimize",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max_div=Integer.MAX_VALUE;\\n        int prev_count=0;\\n        int res=0;\\n        boolean isGreater = false;\\n\\n\\n        for(int i=0; i<divisors.length; i++){\\n            int count=0;\\n            for(int j=0; j<nums.length; j++){\\n                if(nums[j]%divisors[i]==0) count++;\\n            }\\n            if(prev_count < count){\\n                prev_count = count;\\n                res = divisors[i];\\n                isGreater = true;\\n            }\\n            if(prev_count == count){\\n                if(res>divisors[i] && isGreater){\\n                    res = divisors[i];\\n                }\\n                if(max_div > divisors[i]){\\n                    max_div = divisors[i];\\n                }\\n            }\\n        }\\n\\n        return isGreater ? res:max_div;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max_div=Integer.MAX_VALUE;\\n        int prev_count=0;\\n        int res=0;\\n        boolean isGreater = false;\\n\\n\\n        for(int i=0; i<divisors.length; i++){\\n            int count=0;\\n            for(int j=0; j<nums.length; j++){\\n                if(nums[j]%divisors[i]==0) count++;\\n            }\\n            if(prev_count < count){\\n                prev_count = count;\\n                res = divisors[i];\\n                isGreater = true;\\n            }\\n            if(prev_count == count){\\n                if(res>divisors[i] && isGreater){\\n                    res = divisors[i];\\n                }\\n                if(max_div > divisors[i]){\\n                    max_div = divisors[i];\\n                }\\n            }\\n        }\\n\\n        return isGreater ? res:max_div;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024087,
                "title": "c-basic-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int mx=INT_MIN;\\n        vector<int> scores;\\n        for(int i=0; i<divisors.size(); i++){\\n            int score=0;\\n            for(int j=0; j<nums.size(); j++){\\n                if(nums[j]%divisors[i]==0){\\n                    score++;\\n                }\\n            }\\n            scores.push_back(score);\\n            mx=max(mx, score);\\n        }\\n        vector<int> mxScore;\\n        for(int i=0; i<scores.size(); i++){\\n            if(mx==scores[i]){\\n                mxScore.push_back(divisors[i]);\\n            }\\n        }\\n        int mn=INT_MAX;\\n        for(int i=0; i<mxScore.size(); i++){\\n            mn=min(mn, mxScore[i]);\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int mx=INT_MIN;\\n        vector<int> scores;\\n        for(int i=0; i<divisors.size(); i++){\\n            int score=0;\\n            for(int j=0; j<nums.size(); j++){\\n                if(nums[j]%divisors[i]==0){\\n                    score++;\\n                }\\n            }\\n            scores.push_back(score);\\n            mx=max(mx, score);\\n        }\\n        vector<int> mxScore;\\n        for(int i=0; i<scores.size(); i++){\\n            if(mx==scores[i]){\\n                mxScore.push_back(divisors[i]);\\n            }\\n        }\\n        int mn=INT_MAX;\\n        for(int i=0; i<mxScore.size(); i++){\\n            mn=min(mn, mxScore[i]);\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001741,
                "title": "count-map-c",
                "content": "\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int mx = 0, res = INT_MAX;\\n        map<int, int> mp;\\n        for(int d : divisors) {\\n            int cnt = 0;\\n            if(++mp[d] == 1) \\n                for(int n : nums) \\n                    cnt += (n % d == 0);\\n            if(mx == cnt) \\n                res = min(res, d);\\n            else if(mx < cnt) {\\n                res = d;\\n                mx = cnt;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int mx = 0, res = INT_MAX;\\n        map<int, int> mp;\\n        for(int d : divisors) {\\n            int cnt = 0;\\n            if(++mp[d] == 1) \\n                for(int n : nums) \\n                    cnt += (n % d == 0);\\n            if(mx == cnt) \\n                res = min(res, d);\\n            else if(mx < cnt) {\\n                res = d;\\n                mx = cnt;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988957,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        scores = {}\\n\\n        for d in divisors:\\n            count = 0\\n            for i in nums:\\n                if i % d == 0:\\n                    count += 1\\n            scores[d] = count\\n        scores = list(sorted(scores.items(), key = lambda x: (-x[1], x[0])))\\n        return scores[0][0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        scores = {}\\n\\n        for d in divisors:\\n            count = 0\\n            for i in nums:\\n                if i % d == 0:\\n                    count += 1\\n            scores[d] = count\\n        scores = list(sorted(scores.items(), key = lambda x: (-x[1], x[0])))\\n        return scores[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976713,
                "title": "find-the-maximum-divisibility-score",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max = Integer.MAX_VALUE;\\n        int maxi = 0;\\n        for(int i=0;i<divisors.length;i++)\\n        {\\n            int count = 0;\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                if(nums[j]%divisors[i]==0)\\n                count++;\\n            }\\n            if(count>maxi)\\n            {\\n                maxi = count;\\n                max = divisors[i];\\n            }\\n            else if(count==maxi)\\n            {\\n                max = Math.min(max,divisors[i]);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max = Integer.MAX_VALUE;\\n        int maxi = 0;\\n        for(int i=0;i<divisors.length;i++)\\n        {\\n            int count = 0;\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                if(nums[j]%divisors[i]==0)\\n                count++;\\n            }\\n            if(count>maxi)\\n            {\\n                maxi = count;\\n                max = divisors[i];\\n            }\\n            else if(count==maxi)\\n            {\\n                max = Math.min(max,divisors[i]);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957255,
                "title": "easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n       int mine=0,score=-1e8;\\n        for(auto it:divisors)\\n         {\\n           int ct=0;\\n           for(auto i:nums)\\n             {\\n               if(i%it==0)\\n                    ct++;\\n             }\\n                if(score<ct)\\n                 {\\n                   score=ct;\\n                    mine=it;\\n                 }\\n                 else if(score==ct)\\n                   {\\n                     mine=min((int)it,mine);\\n                   }\\n         }\\n         return mine;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n       int mine=0,score=-1e8;\\n        for(auto it:divisors)\\n         {\\n           int ct=0;\\n           for(auto i:nums)\\n             {\\n               if(i%it==0)\\n                    ct++;\\n             }\\n                if(score<ct)\\n                 {\\n                   score=ct;\\n                    mine=it;\\n                 }\\n                 else if(score==ct)\\n                   {\\n                     mine=min((int)it,mine);\\n                   }\\n         }\\n         return mine;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943009,
                "title": "python3-reversed-computation-of-divisibility-score-3-lines-376-ms-beats-100",
                "content": "# Approach\\nInstead of checking if elements of `nums` are evenly divisible by the current `divisor`, check if numbers `divisor * i` are in the list of `nums`,\\nwhere `i` is in range `[1, max(nums)//divisor]` \\n\\n**Note**: it is important to use `Counter` instead of `set` because `nums` can contain duplicate numbers.\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        max_num = max(nums)\\n        cnt = Counter(nums)\\n        return -max((sum(cnt[d * i] for i in range(1, max_num//d + 1)), -d) for d in divisors)[1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        max_num = max(nums)\\n        cnt = Counter(nums)\\n        return -max((sum(cnt[d * i] for i in range(1, max_num//d + 1)), -d) for d in divisors)[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939374,
                "title": "best-sollution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int c = 0;\\n        int res = 0;\\n        Arrays.sort(divisors);\\n        for(int i=0;i<divisors.length;i++){\\n            int count = 0;\\n            int x = divisors[i];\\n            for(int j=0;j<nums.length;j++){\\n                int y = nums[j];\\n                if(y%x==0){\\n                    count++;\\n                }\\n            }\\n            if(count>c){\\n                res = x;\\n                c = count;\\n            }\\n        }\\n        if(res==0){\\n            res = divisors[0];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int c = 0;\\n        int res = 0;\\n        Arrays.sort(divisors);\\n        for(int i=0;i<divisors.length;i++){\\n            int count = 0;\\n            int x = divisors[i];\\n            for(int j=0;j<nums.length;j++){\\n                int y = nums[j];\\n                if(y%x==0){\\n                    count++;\\n                }\\n            }\\n            if(count>c){\\n                res = x;\\n                c = count;\\n            }\\n        }\\n        if(res==0){\\n            res = divisors[0];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928796,
                "title": "best-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int m=0,ans;\\n        sort(divisors.begin(),divisors.end());\\n        set<int> s;\\n        for(int i=0;i<divisors.size();i++){\\n            int c=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%divisors[i]==0){\\n                    c++;\\n                }\\n            }\\n            s.insert(c);\\n            if(c>m){\\n                m=c;\\n                ans=divisors[i];\\n            }\\n        }\\n        if(s.size()==1){\\n            return divisors[0];\\n        }\\n        else{\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int m=0,ans;\\n        sort(divisors.begin(),divisors.end());\\n        set<int> s;\\n        for(int i=0;i<divisors.size();i++){\\n            int c=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%divisors[i]==0){\\n                    c++;\\n                }\\n            }\\n            s.insert(c);\\n            if(c>m){\\n                m=c;\\n                ans=divisors[i];\\n            }\\n        }\\n        if(s.size()==1){\\n            return divisors[0];\\n        }\\n        else{\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925063,
                "title": "o-m-n-java-solution",
                "content": "# Approach\\n1. Calculate the score for `ith` divisor\\n2. if the `score` > `maxScore`, update `maxScore` and `result`\\n3. if `score` == `maxScore`, update the `result` to the **minimum** of `ith divisor` (for which we just calculated the score) and `result`\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int maxScore = 0;\\n        int minValue = Integer.MAX_VALUE;\\n\\n        for (int divisor : divisors) {\\n            int score = 0;\\n            for (int num : nums) {\\n                if (num % divisor == 0) {\\n                    score++;\\n                }\\n            }\\n\\n            if (score > maxScore) {\\n                maxScore = score;\\n                minValue = divisor;\\n            } else if (score == maxScore) {\\n                minValue = Math.min(minValue, divisor);\\n            }\\n        }\\n\\n        return minValue;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int maxScore = 0;\\n        int minValue = Integer.MAX_VALUE;\\n\\n        for (int divisor : divisors) {\\n            int score = 0;\\n            for (int num : nums) {\\n                if (num % divisor == 0) {\\n                    score++;\\n                }\\n            }\\n\\n            if (score > maxScore) {\\n                maxScore = score;\\n                minValue = divisor;\\n            } else if (score == maxScore) {\\n                minValue = Math.min(minValue, divisor);\\n            }\\n        }\\n\\n        return minValue;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904749,
                "title": "purely-brute-force-but-easy-to-understandable-code",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n\\n        vector<int> ans;\\n        int max = INT_MIN;\\n\\n        sort(divisors.begin(),divisors.end());\\n\\n        for(int i=0;i<divisors.size();i++)\\n        {\\n            int count = 0;\\n            for(int j=0;j<nums.size();j++)\\n            {\\n                if(nums[j]%divisors[i]==0)\\n                    count++;\\n            }\\n            ans.push_back(count);\\n            if(max < count)\\n            {\\n                max = count;\\n            }\\n        }   \\n\\n        int result;\\n\\n        for(int i=0;i<ans.size();i++)\\n        {\\n                if (ans[i] == max) \\n                {\\n                result = divisors[i];\\n                break;\\n                }\\n        }\\n\\n    return result;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n\\n        vector<int> ans;\\n        int max = INT_MIN;\\n\\n        sort(divisors.begin(),divisors.end());\\n\\n        for(int i=0;i<divisors.size();i++)\\n        {\\n            int count = 0;\\n            for(int j=0;j<nums.size();j++)\\n            {\\n                if(nums[j]%divisors[i]==0)\\n                    count++;\\n            }\\n            ans.push_back(count);\\n            if(max < count)\\n            {\\n                max = count;\\n            }\\n        }   \\n\\n        int result;\\n\\n        for(int i=0;i<ans.size();i++)\\n        {\\n                if (ans[i] == max) \\n                {\\n                result = divisors[i];\\n                break;\\n                }\\n        }\\n\\n    return result;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890473,
                "title": "max-divisibility-score",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        num=0\\n        div=0\\n        for i in divisors:\\n            num1=0\\n            for j in nums:\\n                if j%i==0:\\n                    num1+=1\\n            if num1>num:\\n                div=i\\n                num=num1\\n            elif num1==num:\\n                div=div if div<i else i\\n        return div if div!=0 else min(divisors)\\n                    \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        num=0\\n        div=0\\n        for i in divisors:\\n            num1=0\\n            for j in nums:\\n                if j%i==0:\\n                    num1+=1\\n            if num1>num:\\n                div=i\\n                num=num1\\n            elif num1==num:\\n                div=div if div<i else i\\n        return div if div!=0 else min(divisors)\\n                    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887370,
                "title": "beginner-map-vector",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        vector<pair<int,int>>pq;\\n        int max_count=0;\\n        for(int i=0;i<divisors.size();i++){\\n            int count=0;\\n            pair<int,int>p;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%divisors[i]==0){\\n                    count++;\\n                }\\n            }\\n            max_count=max(max_count,count);\\n           p.first=count;\\n           p.second=divisors[i];\\n           pq.push_back(p);\\n        }\\n        vector<int>ans;\\n        for(auto it : pq){\\n            if(it.first==max_count){\\n                ans.push_back(it.second);\\n            }\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Hash Table",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        vector<pair<int,int>>pq;\\n        int max_count=0;\\n        for(int i=0;i<divisors.size();i++){\\n            int count=0;\\n            pair<int,int>p;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%divisors[i]==0){\\n                    count++;\\n                }\\n            }\\n            max_count=max(max_count,count);\\n           p.first=count;\\n           p.second=divisors[i];\\n           pq.push_back(p);\\n        }\\n        vector<int>ans;\\n        for(auto it : pq){\\n            if(it.first==max_count){\\n                ans.push_back(it.second);\\n            }\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877810,
                "title": "basic-java-solution-beats-98",
                "content": "# Intuition\\nthe basic intuition is that we have to find the maximum score of an element in divisors array, so we simply iterate through the array , with a variable name max (that stores the max count of an element) and a variable ans (that stores our result if any) \\nso we iterate through the array checking with the condition if the condition satisfies we will increase the count.\\n\\nafter the inner loops complete we will check if the count value is greater or equal to our max value, if it is equal we will store the smaller element in our ans variable. else if the count is greater than max then we\\'ll simply put that value of divisor in our array and take the max as count.\\n\\nat last the ans will be our desired ans;\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n\\n        int max = 0;\\n        int ans = divisors[0];\\n        for(int i = 0 ; i<divisors.length ; i++){\\n            int count = 0;\\n\\n            for(int j = 0 ; j < nums.length; j++){\\n                if(nums[j]%divisors[i]==0){\\n                    count++;\\n                }\\n            }\\n\\n            if(count>=max){\\n                if(count==max){\\n                    ans = Math.min(divisors[i],ans);\\n                    max = Math.max(max, count);\\n                }else{                    \\n                    ans = divisors[i];\\n                    max = Math.max(max, count);            \\n                }\\n            }\\n\\n        }\\n        return ans==-1?divisors[0]:ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n\\n        int max = 0;\\n        int ans = divisors[0];\\n        for(int i = 0 ; i<divisors.length ; i++){\\n            int count = 0;\\n\\n            for(int j = 0 ; j < nums.length; j++){\\n                if(nums[j]%divisors[i]==0){\\n                    count++;\\n                }\\n            }\\n\\n            if(count>=max){\\n                if(count==max){\\n                    ans = Math.min(divisors[i],ans);\\n                    max = Math.max(max, count);\\n                }else{                    \\n                    ans = divisors[i];\\n                    max = Math.max(max, count);            \\n                }\\n            }\\n\\n        }\\n        return ans==-1?divisors[0]:ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877597,
                "title": "python-solution-dictionary",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxDivScore(self, nums, divisors):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type divisors: List[int]\\n        :rtype: int\\n        \"\"\" \\n        divisors = sorted(set(divisors))\\n        d = {}\\n        for i in range(len(divisors)):\\n            c = 0\\n            for j in range(len(nums)):\\n                if nums[j] % divisors[i] == 0:\\n                    c += 1\\n            d[divisors[i]] = c\\n        print(d)\\n        v = max(d.values())\\n        print(d)\\n        sorted_items = sorted(d.items(), key=lambda x: x[0])\\n        print(sorted_items)\\n        for i in sorted_items:\\n            if i[1] == v:\\n                return i[0]\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxDivScore(self, nums, divisors):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type divisors: List[int]\\n        :rtype: int\\n        \"\"\" \\n        divisors = sorted(set(divisors))\\n        d = {}\\n        for i in range(len(divisors)):\\n            c = 0\\n            for j in range(len(nums)):\\n                if nums[j] % divisors[i] == 0:\\n                    c += 1\\n            d[divisors[i]] = c\\n        print(d)\\n        v = max(d.values())\\n        print(d)\\n        sorted_items = sorted(d.items(), key=lambda x: x[0])\\n        print(sorted_items)\\n        for i in sorted_items:\\n            if i[1] == v:\\n                return i[0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876754,
                "title": "fast-defaultdict-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        div_score = defaultdict(int)\\n        div_max = []\\n        for div in divisors:\\n            div_score[div] = sum(1 for x in nums if x % div == 0)\\n        mx = max(count for count in div_score.values())\\n        for div, count in div_score.items():\\n            if count == mx:\\n                div_max.append(div)\\n        return min(div_max)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        div_score = defaultdict(int)\\n        div_max = []\\n        for div in divisors:\\n            div_score[div] = sum(1 for x in nums if x % div == 0)\\n        mx = max(count for count in div_score.values())\\n        for div, count in div_score.items():\\n            if count == mx:\\n                div_max.append(div)\\n        return min(div_max)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874695,
                "title": "java-173ms-beats-98-45",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(mn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// 173ms Beats 98.45%\\n\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n\\n        int winningDivisor = -1;\\n        int winningScore = -1;\\n\\n        for (int i = divisors.length - 1; i >= 0; --i) {\\n\\n            int curScore = 0;\\n\\n            for (int j = 0; j < nums.length; ++j) {\\n                if (nums[j] % divisors[i] == 0) {\\n                    ++curScore;\\n                }\\n            }\\n\\n            if (curScore > winningScore) {\\n                winningDivisor = divisors[i];\\n                winningScore = curScore;\\n            } else if (curScore == winningScore) {\\n                if (divisors[i] < winningDivisor) {\\n                    winningDivisor = divisors[i];\\n                    winningScore = curScore;\\n                }\\n            }\\n        }\\n\\n        return winningDivisor;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// 173ms Beats 98.45%\\n\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n\\n        int winningDivisor = -1;\\n        int winningScore = -1;\\n\\n        for (int i = divisors.length - 1; i >= 0; --i) {\\n\\n            int curScore = 0;\\n\\n            for (int j = 0; j < nums.length; ++j) {\\n                if (nums[j] % divisors[i] == 0) {\\n                    ++curScore;\\n                }\\n            }\\n\\n            if (curScore > winningScore) {\\n                winningDivisor = divisors[i];\\n                winningScore = curScore;\\n            } else if (curScore == winningScore) {\\n                if (divisors[i] < winningDivisor) {\\n                    winningDivisor = divisors[i];\\n                    winningScore = curScore;\\n                }\\n            }\\n        }\\n\\n        return winningDivisor;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3871580,
                "title": "easy-java-solution-with-more-than-95-of-beats-please-vote-me-up",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max=0;\\n        int idx=0;\\n        for(int i=0;i<divisors.length;i++){\\n            int c=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%divisors[i]==0){\\n                    c++;\\n                }\\n            }\\n            if(c==max){\\n                if(divisors[i]<divisors[idx]){\\n                    idx=i;\\n                }\\n            }\\n            if(c>max){\\n                max=c;\\n                idx=i;\\n            }\\n        }\\n        if(idx==0){\\n            Arrays.sort(divisors);\\n            return divisors[0];\\n        }\\n        return divisors[idx];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max=0;\\n        int idx=0;\\n        for(int i=0;i<divisors.length;i++){\\n            int c=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%divisors[i]==0){\\n                    c++;\\n                }\\n            }\\n            if(c==max){\\n                if(divisors[i]<divisors[idx]){\\n                    idx=i;\\n                }\\n            }\\n            if(c>max){\\n                max=c;\\n                idx=i;\\n            }\\n        }\\n        if(idx==0){\\n            Arrays.sort(divisors);\\n            return divisors[0];\\n        }\\n        return divisors[idx];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861953,
                "title": "simple-solution-in-js",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} divisors\\n * @return {number}\\n */\\nvar maxDivScore = function(nums, divisors) {\\n    let max = [0];\\n    for(let i = 0; i < divisors.length; i++) {\\n        let curr = 0;\\n        for(let j = 0; j < nums.length; j++) {\\n            if(nums[j] % divisors[i] == 0) {\\n                curr++\\n            }\\n        } \\n        if(max[0] == curr && max[1] > divisors[i]) {\\n            max[1] = divisors[i]\\n        }else if(max[0] < curr) {\\n            max[0] = curr\\n            max[1] = divisors[i]\\n        }\\n    }\\n    if(!max[0]) return Math.min(...divisors)\\n    return max[1]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} divisors\\n * @return {number}\\n */\\nvar maxDivScore = function(nums, divisors) {\\n    let max = [0];\\n    for(let i = 0; i < divisors.length; i++) {\\n        let curr = 0;\\n        for(let j = 0; j < nums.length; j++) {\\n            if(nums[j] % divisors[i] == 0) {\\n                curr++\\n            }\\n        } \\n        if(max[0] == curr && max[1] > divisors[i]) {\\n            max[1] = divisors[i]\\n        }else if(max[0] < curr) {\\n            max[0] = curr\\n            max[1] = divisors[i]\\n        }\\n    }\\n    if(!max[0]) return Math.min(...divisors)\\n    return max[1]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3855236,
                "title": "java-93ms-beats-99-and-clean-code",
                "content": "# Approach\\n1. Sort the numbers in increasing order.\\n2. For each divisor, traverse nums backwards with j (n-1..0) WHILE nums[j] >= divisor.\\n3. For each traversal keep track of current divisor\\'s currentScore. \\n    - If currentScore > maxScore, set new maxScore and new minDivisor\\n    - If currentScore == maxScore, set new minDivisor the min between minDivisor and currentDivisor.\\n4. Return minDivisor.    \\n\\n# Complexity\\n- Time complexity:$$O(n*log(n) + n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int maxDivScore = 0, minDivisor = Integer.MAX_VALUE, currentDivScore;\\n        Arrays.sort(nums);\\n        for (int divisor : divisors) {\\n            currentDivScore = 0;\\n            for (int i = nums.length -1; i >= 0 && divisor <= nums[i]; i--) {\\n                if (nums[i] % divisor == 0){\\n                    currentDivScore++;\\n                }\\n            }\\n            if(currentDivScore > maxDivScore) {\\n                maxDivScore = currentDivScore;\\n                minDivisor = divisor;\\n            } else if (currentDivScore == maxDivScore) {\\n                minDivisor = Math.min(divisor, minDivisor);\\n            }\\n        }\\n        return minDivisor;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int maxDivScore = 0, minDivisor = Integer.MAX_VALUE, currentDivScore;\\n        Arrays.sort(nums);\\n        for (int divisor : divisors) {\\n            currentDivScore = 0;\\n            for (int i = nums.length -1; i >= 0 && divisor <= nums[i]; i--) {\\n                if (nums[i] % divisor == 0){\\n                    currentDivScore++;\\n                }\\n            }\\n            if(currentDivScore > maxDivScore) {\\n                maxDivScore = currentDivScore;\\n                minDivisor = divisor;\\n            } else if (currentDivScore == maxDivScore) {\\n                minDivisor = Math.min(divisor, minDivisor);\\n            }\\n        }\\n        return minDivisor;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849829,
                "title": "junior-ios-dev-solution-need-a-cheap-extremely-motivated-ios-dev-contact-me-pls",
                "content": "Sorry, no explanation. 10 p.m. junior ios straightforward dev solution. if you have work for me - contact pls.\\n\\n# Code\\n```\\nclass Solution {\\n    func maxDivScore(_ nums: [Int], _ divisors: [Int]) -> Int {\\n        var counter = 0\\n        var divisorValue = 0\\n\\n        for divisor in divisors {\\n            var tempCounter = 0\\n            for num in nums {\\n                if num % divisor == 0 {\\n                    tempCounter += 1\\n                }\\n            }\\n            if tempCounter == counter && divisorValue != 0 {\\n                counter = tempCounter\\n                divisorValue = min(divisorValue, divisor)\\n                continue\\n            }\\n            if tempCounter >= counter {\\n                divisorValue = divisor\\n                counter = tempCounter\\n            }\\n        }\\n\\n        return divisorValue\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxDivScore(_ nums: [Int], _ divisors: [Int]) -> Int {\\n        var counter = 0\\n        var divisorValue = 0\\n\\n        for divisor in divisors {\\n            var tempCounter = 0\\n            for num in nums {\\n                if num % divisor == 0 {\\n                    tempCounter += 1\\n                }\\n            }\\n            if tempCounter == counter && divisorValue != 0 {\\n                counter = tempCounter\\n                divisorValue = min(divisorValue, divisor)\\n                continue\\n            }\\n            if tempCounter >= counter {\\n                divisorValue = divisor\\n                counter = tempCounter\\n            }\\n        }\\n\\n        return divisorValue\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835385,
                "title": "c-solution",
                "content": "```\\nint maxDivScore(vector<int>& nums, vector<int>& div) {\\n\\tint res = div[0], maxScore = 0;\\n\\tfor (int d : div) {\\n\\t\\tint curScore = 0;\\n\\t\\tfor (int n : nums)\\n\\t\\t\\tif (n % d == 0)\\n\\t\\t\\t\\tcurScore++;\\n\\t\\tif (curScore > maxScore) {\\n\\t\\t\\tmaxScore = curScore;\\n\\t\\t\\tres = d;\\n\\t\\t}\\n\\t\\tif (curScore == maxScore)\\n\\t\\t\\tres = min(res, d);\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint maxDivScore(vector<int>& nums, vector<int>& div) {\\n\\tint res = div[0], maxScore = 0;\\n\\tfor (int d : div) {\\n\\t\\tint curScore = 0;\\n\\t\\tfor (int n : nums)\\n\\t\\t\\tif (n % d == 0)\\n\\t\\t\\t\\tcurScore++;\\n\\t\\tif (curScore > maxScore) {\\n\\t\\t\\tmaxScore = curScore;\\n\\t\\t\\tres = d;\\n\\t\\t}\\n\\t\\tif (curScore == maxScore)\\n\\t\\t\\tres = min(res, d);\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3833606,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        uint16_t i_u16 = 0, divSize = divisors.size(), maxDivisor = 0, maxScore = 0;\\n        int j_s32 = 0;\\n        int divScore = 0;\\n\\n        for(i_u16 = 0; i_u16 < divSize; i_u16++)\\n        {\\n            divScore = 0;\\n\\n            for(j_s32 = 0; j_s32 < nums.size(); j_s32++ )\\n            {\\n                if( nums[j_s32] % divisors[i_u16] == 0 )\\n                {\\n                    divScore++;\\n                }\\n            }\\n\\n            if(divScore > maxScore || (divScore == maxScore && divisors[i_u16] <= divisors[maxDivisor]))\\n            {\\n                maxScore = divScore;\\n                maxDivisor = i_u16;   \\n            }\\n        }\\n\\n        return divisors[maxDivisor];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        uint16_t i_u16 = 0, divSize = divisors.size(), maxDivisor = 0, maxScore = 0;\\n        int j_s32 = 0;\\n        int divScore = 0;\\n\\n        for(i_u16 = 0; i_u16 < divSize; i_u16++)\\n        {\\n            divScore = 0;\\n\\n            for(j_s32 = 0; j_s32 < nums.size(); j_s32++ )\\n            {\\n                if( nums[j_s32] % divisors[i_u16] == 0 )\\n                {\\n                    divScore++;\\n                }\\n            }\\n\\n            if(divScore > maxScore || (divScore == maxScore && divisors[i_u16] <= divisors[maxDivisor]))\\n            {\\n                maxScore = divScore;\\n                maxDivisor = i_u16;   \\n            }\\n        }\\n\\n        return divisors[maxDivisor];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812997,
                "title": "easy-solution-in-c",
                "content": "# Intuition\\n\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int ans=111111111;\\n        int maxcount=-111111111;\\n        for(int i=0;i<divisors.size();i++){\\n            int count=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%divisors[i]==0)\\n                count++;\\n            }\\n            if(maxcount<count){\\n                maxcount=count;\\n                ans=divisors[i];\\n            }\\n            else if(maxcount==count){\\n                ans=min(ans,divisors[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int ans=111111111;\\n        int maxcount=-111111111;\\n        for(int i=0;i<divisors.size();i++){\\n            int count=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%divisors[i]==0)\\n                count++;\\n            }\\n            if(maxcount<count){\\n                maxcount=count;\\n                ans=divisors[i];\\n            }\\n            else if(maxcount==count){\\n                ans=min(ans,divisors[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809363,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n * n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n + n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool compare(pair<int,int>a, pair<int,int>b)\\n    {\\n        if(a.first > b.first)\\n        return true;\\n        if(a.first == b.first)\\n        {\\n            return a.second < b.second;\\n        }\\n        return false;\\n    }\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n       map<int,int>mp;\\n       bool flag = false;\\n       int minDivisors = INT_MAX;\\n       for(int i = 0; i < divisors.size(); i++)\\n       {\\n           if(mp.find(divisors[i]) == mp.end())\\n           {\\n               for(int j = 0; j < nums.size(); j++)\\n                {\\n                    if(nums[j] % divisors[i] == 0)\\n                    {\\n                            mp[divisors[i]]++;\\n                            flag = true;\\n                    }\\n                }\\n           }\\n            minDivisors = min(minDivisors, divisors[i]);\\n       } \\n       if(flag == false)\\n       {\\n           return minDivisors;\\n       }\\n       vector<pair<int,int>>v;\\n       for(auto it : mp)\\n       {\\n           v.push_back({it.second, it.first});\\n       }\\n       sort(v.begin(), v.end(), compare);\\n       for(auto x : v)\\n       {\\n           cout<<x.first<<\"->\"<<x.second<<endl;\\n       }\\n       if(v.size() > 0)\\n       return v[0].second;\\n       return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool compare(pair<int,int>a, pair<int,int>b)\\n    {\\n        if(a.first > b.first)\\n        return true;\\n        if(a.first == b.first)\\n        {\\n            return a.second < b.second;\\n        }\\n        return false;\\n    }\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n       map<int,int>mp;\\n       bool flag = false;\\n       int minDivisors = INT_MAX;\\n       for(int i = 0; i < divisors.size(); i++)\\n       {\\n           if(mp.find(divisors[i]) == mp.end())\\n           {\\n               for(int j = 0; j < nums.size(); j++)\\n                {\\n                    if(nums[j] % divisors[i] == 0)\\n                    {\\n                            mp[divisors[i]]++;\\n                            flag = true;\\n                    }\\n                }\\n           }\\n            minDivisors = min(minDivisors, divisors[i]);\\n       } \\n       if(flag == false)\\n       {\\n           return minDivisors;\\n       }\\n       vector<pair<int,int>>v;\\n       for(auto it : mp)\\n       {\\n           v.push_back({it.second, it.first});\\n       }\\n       sort(v.begin(), v.end(), compare);\\n       for(auto x : v)\\n       {\\n           cout<<x.first<<\"->\"<<x.second<<endl;\\n       }\\n       if(v.size() > 0)\\n       return v[0].second;\\n       return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3803283,
                "title": "divisibility-score-js-count-scores-intuitive",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} divisors\\n * @return {number}\\n */\\nvar maxDivScore = function(nums, divisors) {\\n    divisors.sort((a, b) => a - b)\\n    scores = []\\n\\n    for (let i = 0; i < divisors.length; i++) {\\n        count = 0\\n        for (num of nums) {\\n            if (num % divisors[i] == 0) count ++\\n        }\\n        scores[i] = count\\n    }\\n\\n    maximum_score = Math.max(...scores)\\n\\n    return divisors[scores.indexOf(maximum_score)]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} divisors\\n * @return {number}\\n */\\nvar maxDivScore = function(nums, divisors) {\\n    divisors.sort((a, b) => a - b)\\n    scores = []\\n\\n    for (let i = 0; i < divisors.length; i++) {\\n        count = 0\\n        for (num of nums) {\\n            if (num % divisors[i] == 0) count ++\\n        }\\n        scores[i] = count\\n    }\\n\\n    maximum_score = Math.max(...scores)\\n\\n    return divisors[scores.indexOf(maximum_score)]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3799305,
                "title": "very-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>&n , vector<int>&d){\\n        int mx=INT_MIN;\\n        for(auto i:d){\\n            int c=0;\\n            for(auto j:n){\\n                if(j%i==0){\\n                    c++;\\n                }\\n            }\\n            if(mx<c){\\n                mx=c;\\n            }\\n        }\\n        vector<int>v;\\n        for(auto i:d){\\n            int c=0;\\n            for(auto j:n){\\n                if(j%i==0){\\n                    c++;\\n                }\\n            }\\n            if(mx==c){\\n                v.push_back(i);\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        return v[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>&n , vector<int>&d){\\n        int mx=INT_MIN;\\n        for(auto i:d){\\n            int c=0;\\n            for(auto j:n){\\n                if(j%i==0){\\n                    c++;\\n                }\\n            }\\n            if(mx<c){\\n                mx=c;\\n            }\\n        }\\n        vector<int>v;\\n        for(auto i:d){\\n            int c=0;\\n            for(auto j:n){\\n                if(j%i==0){\\n                    c++;\\n                }\\n            }\\n            if(mx==c){\\n                v.push_back(i);\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        return v[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779614,
                "title": "kotlin-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    fun maxDivScore(nums: IntArray, divisors: IntArray): Int {\\n        var maxDivisor = divisors.first()\\n        var maxDividedNums = 0\\n\\n        for (divisor in divisors) {\\n            var dividedNums = 0\\n\\n            for (num in nums) {\\n                if (num % divisor == 0)\\n                    dividedNums++\\n            }\\n\\n            if (dividedNums > maxDividedNums) {\\n                maxDividedNums = dividedNums\\n                maxDivisor = divisor\\n            }\\n            \\n            if (dividedNums == maxDividedNums && divisor < maxDivisor)\\n                maxDivisor = divisor\\n        }\\n\\n        return maxDivisor\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun maxDivScore(nums: IntArray, divisors: IntArray): Int {\\n        var maxDivisor = divisors.first()\\n        var maxDividedNums = 0\\n\\n        for (divisor in divisors) {\\n            var dividedNums = 0\\n\\n            for (num in nums) {\\n                if (num % divisor == 0)\\n                    dividedNums++\\n            }\\n\\n            if (dividedNums > maxDividedNums) {\\n                maxDividedNums = dividedNums\\n                maxDivisor = divisor\\n            }\\n            \\n            if (dividedNums == maxDividedNums && divisor < maxDivisor)\\n                maxDivisor = divisor\\n        }\\n\\n        return maxDivisor\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777918,
                "title": "tried-to-optimized",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        sorted_div = sorted(set(divisors))\\n        ans_d, ans_count = sorted_div[0], 0\\n        cnt_n = Counter(nums)\\n        for d in sorted_div:\\n            score = sum(n for num, n in cnt_n.items() if not num % d)\\n            if score > ans_count:\\n                ans_d = d\\n                ans_count = score\\n        return ans_d\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        sorted_div = sorted(set(divisors))\\n        ans_d, ans_count = sorted_div[0], 0\\n        cnt_n = Counter(nums)\\n        for d in sorted_div:\\n            score = sum(n for num, n in cnt_n.items() if not num % d)\\n            if score > ans_count:\\n                ans_d = d\\n                ans_count = score\\n        return ans_d\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757206,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} divisors\\n * @return {number}\\n */\\nvar maxDivScore = function(nums, divisors) {\\n    let maxScore = 0;\\n    let result = divisors[0];\\n    for(let divi of divisors){\\n        let score = 0;\\n        for(let num of nums){\\n            if(num % divi === 0) score++;\\n        }\\n        if (score === maxScore) result = Math.min(result, divi);\\n        if(score > maxScore){\\n            maxScore = score\\n            result = divi;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} divisors\\n * @return {number}\\n */\\nvar maxDivScore = function(nums, divisors) {\\n    let maxScore = 0;\\n    let result = divisors[0];\\n    for(let divi of divisors){\\n        let score = 0;\\n        for(let num of nums){\\n            if(num % divi === 0) score++;\\n        }\\n        if (score === maxScore) result = Math.min(result, divi);\\n        if(score > maxScore){\\n            maxScore = score\\n            result = divi;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3751919,
                "title": "java-solution-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n*n)\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int ans[]=new int[divisors.length];\\n        for(int i=0;i<divisors.length;i++){\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%divisors[i]==0){\\n                    ans[i]++;\\n                }\\n            }\\n        }\\n        int res=0,count=ans[0];\\n        for(int i=1;i<ans.length;i++){\\n            if(count<ans[i]){\\n                count=ans[i];\\n                res=i;\\n            }\\n            else if(count==ans[i]){\\n                if(divisors[res]>divisors[i]){\\n                    res=i;\\n                }\\n            }\\n        }\\n        return divisors[res];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int ans[]=new int[divisors.length];\\n        for(int i=0;i<divisors.length;i++){\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%divisors[i]==0){\\n                    ans[i]++;\\n                }\\n            }\\n        }\\n        int res=0,count=ans[0];\\n        for(int i=1;i<ans.length;i++){\\n            if(count<ans[i]){\\n                count=ans[i];\\n                res=i;\\n            }\\n            else if(count==ans[i]){\\n                if(divisors[res]>divisors[i]){\\n                    res=i;\\n                }\\n            }\\n        }\\n        return divisors[res];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739919,
                "title": "using-map",
                "content": "# Complexity\\n- Time complexity:\\nO(n*m)  where n=nums.size() and m=divisors.size()\\n\\n- Space complexity:\\nO(m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        map<int,int>m;\\n        int maxi=0,temp=0;\\n        for(int i=0;i<divisors.size();i++){\\n            int count=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j] % divisors[i] ==0)\\n                count++;\\n            }\\n            if(count!=0)\\n            m[divisors[i]]=count;\\n        }\\n        if(m.size()==0){\\n            sort(divisors.begin(),divisors.end());\\n            return divisors[0];\\n        }\\n        for(auto i:m){\\n            if(i.second>maxi){\\n            maxi=i.second;\\n            temp=i.first;\\n            }\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        map<int,int>m;\\n        int maxi=0,temp=0;\\n        for(int i=0;i<divisors.size();i++){\\n            int count=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j] % divisors[i] ==0)\\n                count++;\\n            }\\n            if(count!=0)\\n            m[divisors[i]]=count;\\n        }\\n        if(m.size()==0){\\n            sort(divisors.begin(),divisors.end());\\n            return divisors[0];\\n        }\\n        for(auto i:m){\\n            if(i.second>maxi){\\n            maxi=i.second;\\n            temp=i.first;\\n            }\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737982,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        map<int,int> mp;\\n        for(auto i: divisors){\\n            if(mp[i]>0){\\n                    continue;\\n                }\\n            for(int j: nums){\\n                \\n                if(j%i==0){\\n                    mp[i]++;\\n                }\\n            }\\n        }\\n        int maxi=0;\\n        int ans=INT_MAX;\\n        for(auto i: mp){\\n             maxi=max(maxi,i.second);\\n        }\\n        for(auto i: mp){\\n            if(i.second==maxi){\\n                ans=min(ans,i.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        map<int,int> mp;\\n        for(auto i: divisors){\\n            if(mp[i]>0){\\n                    continue;\\n                }\\n            for(int j: nums){\\n                \\n                if(j%i==0){\\n                    mp[i]++;\\n                }\\n            }\\n        }\\n        int maxi=0;\\n        int ans=INT_MAX;\\n        for(auto i: mp){\\n             maxi=max(maxi,i.second);\\n        }\\n        for(auto i: mp){\\n            if(i.second==maxi){\\n                ans=min(ans,i.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730311,
                "title": "python-simple-solution-using-zip-function",
                "content": "\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxDivScore(self, nums, divisors):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type divisors: List[int]\\n        :rtype: int\\n        \"\"\"\\n        a=[]\\n        for i in divisors:\\n            c=0\\n            for j in nums:\\n                if j%i==0:\\n                    c=c+1\\n            a.append(c)\\n        if len(set(a))==1:\\n            return min(divisors)\\n        else:\\n            m=10**10\\n            for k,l in zip(divisors,a):\\n                if l==max(a) and k<m:\\n                    m=k\\n            return m\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxDivScore(self, nums, divisors):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type divisors: List[int]\\n        :rtype: int\\n        \"\"\"\\n        a=[]\\n        for i in divisors:\\n            c=0\\n            for j in nums:\\n                if j%i==0:\\n                    c=c+1\\n            a.append(c)\\n        if len(set(a))==1:\\n            return min(divisors)\\n        else:\\n            m=10**10\\n            for k,l in zip(divisors,a):\\n                if l==max(a) and k<m:\\n                    m=k\\n            return m\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3728299,
                "title": "c-beginner-friendly-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        \\n        int ans = 0;\\n        int dev = INT_MAX;\\n\\n        for(int i=0; i<divisors.size(); i++){\\n            int cnt = 0;\\n            for(int j=0; j<nums.size(); j++){\\n                if(nums[j]%divisors[i] ==0){\\n                    cnt++;\\n                }\\n                if(cnt>ans){\\n                    dev = divisors[i];\\n                    ans = cnt;\\n                }\\n                if(ans == cnt){\\n                    dev = min(divisors[i],dev);\\n                }\\n            }\\n        }\\n        return dev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        \\n        int ans = 0;\\n        int dev = INT_MAX;\\n\\n        for(int i=0; i<divisors.size(); i++){\\n            int cnt = 0;\\n            for(int j=0; j<nums.size(); j++){\\n                if(nums[j]%divisors[i] ==0){\\n                    cnt++;\\n                }\\n                if(cnt>ans){\\n                    dev = divisors[i];\\n                    ans = cnt;\\n                }\\n                if(ans == cnt){\\n                    dev = min(divisors[i],dev);\\n                }\\n            }\\n        }\\n        return dev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716608,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int minInt = Integer.MAX_VALUE;\\n        int maxCount = 0;\\n        for(int x : divisors) {\\n            int count = 0;\\n            for(int y : nums) {\\n                count += y % x == 0 ? 1 : 0;\\n            }\\n            if(count > maxCount || (count == maxCount && x < minInt)) {\\n                maxCount = count;\\n                minInt = x;\\n            }\\n        }\\n        return minInt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int minInt = Integer.MAX_VALUE;\\n        int maxCount = 0;\\n        for(int x : divisors) {\\n            int count = 0;\\n            for(int y : nums) {\\n                count += y % x == 0 ? 1 : 0;\\n            }\\n            if(count > maxCount || (count == maxCount && x < minInt)) {\\n                maxCount = count;\\n                minInt = x;\\n            }\\n        }\\n        return minInt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713097,
                "title": "simplest-python-solution",
                "content": "# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        nums_count = Counter(nums)\\n        max_div = {}\\n        for d in list(set(divisors)):\\n            div_count = 0\\n            for num in list(set(nums)):\\n                if num%d==0:\\n                    div_count += nums_count[num]\\n            max_div[d] = div_count\\n        max_value = max(max_div.values())\\n        keys = []\\n        for key, value in max_div.items():\\n            if max_value == value:\\n                keys.append(key)\\n        \\n        return min(keys)\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        nums_count = Counter(nums)\\n        max_div = {}\\n        for d in list(set(divisors)):\\n            div_count = 0\\n            for num in list(set(nums)):\\n                if num%d==0:\\n                    div_count += nums_count[num]\\n            max_div[d] = div_count\\n        max_value = max(max_div.values())\\n        keys = []\\n        for key, value in max_div.items():\\n            if max_value == value:\\n                keys.append(key)\\n        \\n        return min(keys)\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3699616,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int current = 0;\\n        int output = Integer.MAX_VALUE;\\n        for (int i : divisors) {\\n            int count = 0;\\n            for (int j : nums) {\\n                if (j % i == 0) {\\n                    count++;\\n                }\\n            }\\n            if (count >= current) {\\n                if (count == current) {\\n                    output = Math.min(i, output);\\n                }\\n                if (count > current) {\\n                    current = count;\\n                    output = i;\\n                }\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int current = 0;\\n        int output = Integer.MAX_VALUE;\\n        for (int i : divisors) {\\n            int count = 0;\\n            for (int j : nums) {\\n                if (j % i == 0) {\\n                    count++;\\n                }\\n            }\\n            if (count >= current) {\\n                if (count == current) {\\n                    output = Math.min(i, output);\\n                }\\n                if (count > current) {\\n                    current = count;\\n                    output = i;\\n                }\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691564,
                "title": "c-brute-force-approach-for-beginners",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int flag=0, temp=0, ans=INT_MAX;\\n        for(int i=0; i<divisors.size(); i++){\\n            for(int j=0; j<nums.size(); j++){\\n                if(nums[j]%divisors[i] == 0) flag++;\\n            }\\n            if(flag>temp){\\n                temp=flag;\\n                ans = divisors[i];\\n            }\\n            if(flag == temp && divisors[i]<ans)\\n            ans = divisors[i];\\n            flag=0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int flag=0, temp=0, ans=INT_MAX;\\n        for(int i=0; i<divisors.size(); i++){\\n            for(int j=0; j<nums.size(); j++){\\n                if(nums[j]%divisors[i] == 0) flag++;\\n            }\\n            if(flag>temp){\\n                temp=flag;\\n                ans = divisors[i];\\n            }\\n            if(flag == temp && divisors[i]<ans)\\n            ans = divisors[i];\\n            flag=0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689076,
                "title": "java-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        \\n        ArrayList<Integer> list = new ArrayList<>();\\n       ArrayList<Integer> finalList = new ArrayList<>();\\n\\n       int j = 0;\\n       while(j<divisors.length){\\n           int i = 0;\\n           int count = 0;\\n           while(i<nums.length){\\n           if(nums[i]%divisors[j] == 0){\\n               count++;\\n           }\\n           i++;\\n        }\\n        list.add(count);\\n           j++;\\n        }\\n\\n        int a = Collections.max(list);\\n        for(int m =0 ; m<list.size(); m++){\\n            if(a == list.get(m)){\\n                finalList.add(divisors[m]);\\n            }\\n        }\\n\\n\\n\\n        return Collections.min(finalList);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        \\n        ArrayList<Integer> list = new ArrayList<>();\\n       ArrayList<Integer> finalList = new ArrayList<>();\\n\\n       int j = 0;\\n       while(j<divisors.length){\\n           int i = 0;\\n           int count = 0;\\n           while(i<nums.length){\\n           if(nums[i]%divisors[j] == 0){\\n               count++;\\n           }\\n           i++;\\n        }\\n        list.add(count);\\n           j++;\\n        }\\n\\n        int a = Collections.max(list);\\n        for(int m =0 ; m<list.size(); m++){\\n            if(a == list.get(m)){\\n                finalList.add(divisors[m]);\\n            }\\n        }\\n\\n\\n\\n        return Collections.min(finalList);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685114,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int c,max=0,d=0,min=Integer.MAX_VALUE;\\n        boolean e=false;\\n        int[] arr=new int[3];\\n        for(int i=0;i<divisors.length;i++)\\n        {\\n            c=0;\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                if(nums[j]%divisors[i]==0)\\n                {\\n                    c++;\\n                   \\n\\n                }\\n\\n            }  \\n             \\n                     if(max<c)\\n                     {\\n                       max=c;\\n                       d=divisors[i]; \\n                       e=true; \\n                     } \\n                     if(max==c)\\n                     {\\n                         if(d>divisors[i] && e)\\n                         d=divisors[i];\\n                     }\\n                     if(min>divisors[i])\\n                     min=divisors[i];\\n                    \\n            \\n        }\\n       \\n       return e?d:min;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int c,max=0,d=0,min=Integer.MAX_VALUE;\\n        boolean e=false;\\n        int[] arr=new int[3];\\n        for(int i=0;i<divisors.length;i++)\\n        {\\n            c=0;\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                if(nums[j]%divisors[i]==0)\\n                {\\n                    c++;\\n                   \\n\\n                }\\n\\n            }  \\n             \\n                     if(max<c)\\n                     {\\n                       max=c;\\n                       d=divisors[i]; \\n                       e=true; \\n                     } \\n                     if(max==c)\\n                     {\\n                         if(d>divisors[i] && e)\\n                         d=divisors[i];\\n                     }\\n                     if(min>divisors[i])\\n                     min=divisors[i];\\n                    \\n            \\n        }\\n       \\n       return e?d:min;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679420,
                "title": "easy-c-solution-beginner-friendly-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& div) {\\n        int ans = -1, val=-1;\\n        for(int i=0; i<div.size(); i++)\\n        {\\n            int count=0;\\n            for(int j=0; j<nums.size(); j++)\\n            {\\n                if((nums[j] % div[i])==0)\\n                    count++;\\n            }\\n            if(val < count){\\n                val = count;\\n                ans = div[i];\\n            }\\n            else if(val == count){\\n                ans = min(ans, div[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& div) {\\n        int ans = -1, val=-1;\\n        for(int i=0; i<div.size(); i++)\\n        {\\n            int count=0;\\n            for(int j=0; j<nums.size(); j++)\\n            {\\n                if((nums[j] % div[i])==0)\\n                    count++;\\n            }\\n            if(val < count){\\n                val = count;\\n                ans = div[i];\\n            }\\n            else if(val == count){\\n                ans = min(ans, div[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674633,
                "title": "my-java-solution-brute-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        Arrays.sort(divisors);\\n        int maxi=Integer.MIN_VALUE;int cnt=0;int ans=0;\\n       for(int i=0;i<divisors.length;i++){\\n       for(int j=0;j<nums.length;j++){\\n           if(nums[j]%divisors[i]==0){\\n               cnt++;\\n           }\\n       }\\n       if(maxi!=cnt){\\n           maxi=Math.max(maxi,cnt);\\n           if(maxi==cnt){\\nans=divisors[i];\\n           }\\n           }\\n           cnt=0; \\n    }\\n    return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        Arrays.sort(divisors);\\n        int maxi=Integer.MIN_VALUE;int cnt=0;int ans=0;\\n       for(int i=0;i<divisors.length;i++){\\n       for(int j=0;j<nums.length;j++){\\n           if(nums[j]%divisors[i]==0){\\n               cnt++;\\n           }\\n       }\\n       if(maxi!=cnt){\\n           maxi=Math.max(maxi,cnt);\\n           if(maxi==cnt){\\nans=divisors[i];\\n           }\\n           }\\n           cnt=0; \\n    }\\n    return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666026,
                "title": "java-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int count=0;\\n        int div=divisors[0];\\n        for(int i=0;i<divisors.length;i++){\\n            int m=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%divisors[i]==0){\\n                    m++;\\n                }\\n            }\\n            if(m>count){\\n                count=m;\\n                div=divisors[i];\\n            }\\n            if(m==count && divisors[i]<=div){\\n                div=divisors[i];\\n            }\\n        }\\n        return div;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int count=0;\\n        int div=divisors[0];\\n        for(int i=0;i<divisors.length;i++){\\n            int m=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%divisors[i]==0){\\n                    m++;\\n                }\\n            }\\n            if(m>count){\\n                count=m;\\n                div=divisors[i];\\n            }\\n            if(m==count && divisors[i]<=div){\\n                div=divisors[i];\\n            }\\n        }\\n        return div;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661629,
                "title": "python-simple-python-solution",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Approach 1 Using Hash Map :\\n# Runtime: 4896 ms, faster than 34.58% of Python3 online submissions for Find the Maximum Divisibility Score.\\n# Memory Usage: 16.7 MB, less than 5.97% of Python3 online submissions for Find the Maximum Divisibility Score.\\n\\n\\tclass Solution:\\n\\t\\tdef maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n\\n\\t\\t\\tresult , score = float(\\'inf\\') , 0\\n\\n\\t\\t\\thash_map = {}\\n\\n\\t\\t\\tfor num in nums:\\n\\n\\t\\t\\t\\tif num not in hash_map:\\n\\t\\t\\t\\t\\thash_map[num] = 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\thash_map[num] = hash_map[num] + 1\\n\\n\\t\\t\\tfor divisor in divisors:\\n\\n\\t\\t\\t\\tcurrent_score = 0\\n\\n\\t\\t\\t\\tfor key in hash_map:\\n\\n\\t\\t\\t\\t\\tif key % divisor == 0:\\n\\n\\t\\t\\t\\t\\t\\tcurrent_score = current_score + hash_map[key]\\n\\n\\t\\t\\t\\tif current_score == score:\\n\\t\\t\\t\\t\\tresult = min(result, divisor)\\n\\n\\t\\t\\t\\telif current_score > score:\\n\\t\\t\\t\\t\\tresult = divisor\\n\\n\\t\\t\\t\\tscore = max(score, current_score)\\n\\n\\t\\t\\treturn result\\n\\t\\t\\t\\n# Approach 2 Using Brute Force :\\n# Runtime: 4541 ms, faster than 38.63% of Python3 online submissions for Find the Maximum Divisibility Score.\\n# Memory Usage: 16.6 MB, less than 21.44% of Python3 online submissions for Find the Maximum Divisibility Score.\\n\\n\\tclass Solution:\\n\\t\\tdef maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n\\n\\t\\t\\tresult , score = float(\\'inf\\') , 0\\n\\n\\t\\t\\tfor divisor in divisors:\\n\\n\\t\\t\\t\\tcurrent_score = 0\\n\\n\\t\\t\\t\\tfor num in nums:\\n\\n\\t\\t\\t\\t\\tif num % divisor == 0:\\n\\n\\t\\t\\t\\t\\t\\tcurrent_score = current_score + 1\\n\\n\\t\\t\\t\\tif current_score == score:\\n\\t\\t\\t\\t\\tresult = min(result, divisor)\\n\\n\\t\\t\\t\\telif current_score > score:\\n\\t\\t\\t\\t\\tresult = divisor\\n\\n\\t\\t\\t\\tscore = max(score , current_score)\\n\\n\\t\\t\\treturn result\\n\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n\\t\\tdef maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n\\n\\t\\t\\tresult , score = float(\\'inf\\') , 0\\n\\n\\t\\t\\thash_map = {}",
                "codeTag": "Java"
            },
            {
                "id": 3657639,
                "title": "time-complexity-o-m-n-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} divisors\\n * @return {number}\\n */\\nvar maxDivScore = function(nums, divisors) {\\n    let maxTimeDvd = 0;\\n    let res = Infinity;\\n    \\n    for (let i = 0; i < divisors.length; i++){\\n        let currentDvd = 0;\\n        for (let j = 0; j < nums.length; j++){\\n            if (nums[j] % divisors[i] === 0) \\n                currentDvd++;\\n\\n            if (currentDvd > maxTimeDvd) {\\n                maxTimeDvd = currentDvd;\\n                res = divisors[i]\\n            }\\n            if (currentDvd === maxTimeDvd  && res > divisors[i])\\n                res = divisors[i]\\n        }\\n    }\\n\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} divisors\\n * @return {number}\\n */\\nvar maxDivScore = function(nums, divisors) {\\n    let maxTimeDvd = 0;\\n    let res = Infinity;\\n    \\n    for (let i = 0; i < divisors.length; i++){\\n        let currentDvd = 0;\\n        for (let j = 0; j < nums.length; j++){\\n            if (nums[j] % divisors[i] === 0) \\n                currentDvd++;\\n\\n            if (currentDvd > maxTimeDvd) {\\n                maxTimeDvd = currentDvd;\\n                res = divisors[i]\\n            }\\n            if (currentDvd === maxTimeDvd  && res > divisors[i])\\n                res = divisors[i]\\n        }\\n    }\\n\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3657333,
                "title": "java-beats-96-22-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int ans = divisors[0];\\n        int div = 0;\\n        for(int i = 0;i < divisors.length;i++){\\n            int n = 0;\\n            for(int j = 0;j < nums.length;j++){\\n                if(nums[j]%divisors[i] == 0)\\n                    n++;\\n            }\\n            if(div < n){\\n                div = n;\\n                ans = divisors[i];\\n            }\\n            else if(div == n && ans > divisors[i])\\n                ans = divisors[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int ans = divisors[0];\\n        int div = 0;\\n        for(int i = 0;i < divisors.length;i++){\\n            int n = 0;\\n            for(int j = 0;j < nums.length;j++){\\n                if(nums[j]%divisors[i] == 0)\\n                    n++;\\n            }\\n            if(div < n){\\n                div = n;\\n                ans = divisors[i];\\n            }\\n            else if(div == n && ans > divisors[i])\\n                ans = divisors[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647617,
                "title": "simple-and-easy-to-understand-clear-explanation-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO (n^2)\\n\\n- Space complexity:\\nO (1)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDivScore(self, nums, divisors):\\n        score=0\\n        val=divisors[0]    # taking val as first value , beacause if divisibility score of all elements is 0 we have to give one value\\n        for i in divisors:\\n            count=0\\n            for j in nums:\\n                if j%i==0:\\n                    count+=1\\n            if count>score:\\n                score=count\\n                val=i       # if divisbility score is greter than score then value will be element ,\\n            elif count==score:\\n                score=count\\n                val=min(val,i)   # if divisbility score is equal or both Zero , we take minimum element\\n        return val\\nobj=Solution()\\nobj.maxDivScore([20,14,21,10],[5,7,5])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums, divisors):\\n        score=0\\n        val=divisors[0]    # taking val as first value , beacause if divisibility score of all elements is 0 we have to give one value\\n        for i in divisors:\\n            count=0\\n            for j in nums:\\n                if j%i==0:\\n                    count+=1\\n            if count>score:\\n                score=count\\n                val=i       # if divisbility score is greter than score then value will be element ,\\n            elif count==score:\\n                score=count\\n                val=min(val,i)   # if divisbility score is equal or both Zero , we take minimum element\\n        return val\\nobj=Solution()\\nobj.maxDivScore([20,14,21,10],[5,7,5])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3645182,
                "title": "java-o-n-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n*n)\\n- Space complexity:\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n\\n        for(int i = 0 ; i < divisors.length ; i++){\\n            int score = 0;\\n            for(int j = 0 ; j < nums.length ; j++){\\n                if(nums[j] % divisors[i] == 0){\\n                    score++;\\n                }\\n            }\\n            map.put(divisors[i],score);\\n        }\\n\\n        int ans = -1;\\n        int max_score = 0;\\n\\n        for (Integer key : map.keySet()) {\\n            Integer value = map.get(key);\\n            if(value > max_score){\\n                max_score = value;\\n                ans = key;\\n            }else if(value == max_score && ans > key){\\n                ans = key;\\n            }\\n        }\\n\\n        if(ans == -1){\\n            return Arrays.stream(divisors).min().getAsInt();\\n        }\\n\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n\\n        for(int i = 0 ; i < divisors.length ; i++){\\n            int score = 0;\\n            for(int j = 0 ; j < nums.length ; j++){\\n                if(nums[j] % divisors[i] == 0){\\n                    score++;\\n                }\\n            }\\n            map.put(divisors[i],score);\\n        }\\n\\n        int ans = -1;\\n        int max_score = 0;\\n\\n        for (Integer key : map.keySet()) {\\n            Integer value = map.get(key);\\n            if(value > max_score){\\n                max_score = value;\\n                ans = key;\\n            }else if(value == max_score && ans > key){\\n                ans = key;\\n            }\\n        }\\n\\n        if(ans == -1){\\n            return Arrays.stream(divisors).min().getAsInt();\\n        }\\n\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3635185,
                "title": "trivial-c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        auto result = 0, ma = -1;\\n        sort(begin(divisors), end(divisors));\\n        for (const auto& divisor : divisors) {\\n            auto count = 0;\\n            for (const auto& num : nums)\\n                if (num % divisor == 0)\\n                    ++count;\\n            if (count > ma) {\\n                ma = count;\\n                result = divisor;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        auto result = 0, ma = -1;\\n        sort(begin(divisors), end(divisors));\\n        for (const auto& divisor : divisors) {\\n            auto count = 0;\\n            for (const auto& num : nums)\\n                if (num % divisor == 0)\\n                    ++count;\\n            if (count > ma) {\\n                ma = count;\\n                result = divisor;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3583234,
                "title": "easy-java-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max=-1;\\n        int ans=0;\\n        for(int i=0;i<divisors.length;i++){\\n            int div=divisors[i];\\n            int count=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%div==0)\\n                    count++;\\n            }\\n            \\n            if(count>max){\\n                max=count;\\n                ans=div;\\n            }\\n            if(count==max){\\n                if(div<ans)\\n                    ans=div;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max=-1;\\n        int ans=0;\\n        for(int i=0;i<divisors.length;i++){\\n            int div=divisors[i];\\n            int count=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%div==0)\\n                    count++;\\n            }\\n            \\n            if(count>max){\\n                max=count;\\n                ans=div;\\n            }\\n            if(count==max){\\n                if(div<ans)\\n                    ans=div;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567984,
                "title": "easy-to-understand-max-min",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& div) {\\n        int maxi=INT_MIN,x,m=INT_MAX;\\n       for(int i=0;i<div.size();i++)\\n       {\\n           int count=0;\\n           for(int j=0;j<nums.size();j++)\\n           {\\n               if(nums[j]%div[i]==0)\\n                count++;\\n           }\\n           if(maxi==count)\\n           {\\n               x=min(div[i],x);\\n           }\\n           if(maxi<count)\\n           {\\n               maxi=count;\\n               x=div[i];\\n           } \\n           \\n       } \\n       return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& div) {\\n        int maxi=INT_MIN,x,m=INT_MAX;\\n       for(int i=0;i<div.size();i++)\\n       {\\n           int count=0;\\n           for(int j=0;j<nums.size();j++)\\n           {\\n               if(nums[j]%div[i]==0)\\n                count++;\\n           }\\n           if(maxi==count)\\n           {\\n               x=min(div[i],x);\\n           }\\n           if(maxi<count)\\n           {\\n               maxi=count;\\n               x=div[i];\\n           } \\n           \\n       } \\n       return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3552046,
                "title": "find-the-maximum-divisibility-score",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        divisors = sorted(list(set(divisors)))\\n        res_divisor = divisors[0]\\n        res_score = 0\\n        for i in range(len(divisors)):\\n            score = 0\\n            for x in nums:\\n                if x % divisors[i] == 0:\\n                    score += 1\\n            if score > res_score:\\n                res_score = score\\n                res_divisor = divisors[i]\\n        return res_divisor\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        divisors = sorted(list(set(divisors)))\\n        res_divisor = divisors[0]\\n        res_score = 0\\n        for i in range(len(divisors)):\\n            score = 0\\n            for x in nums:\\n                if x % divisors[i] == 0:\\n                    score += 1\\n            if score > res_score:\\n                res_score = score\\n                res_divisor = divisors[i]\\n        return res_divisor\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538823,
                "title": "find-the-maximum-divisibility-score",
                "content": "# Intuition\\nEasy Solotion| Beats 94.23% in runtime\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max=divisors[0];\\n        int maxscore=0;\\n        for(int i=0;i<divisors.length;i++){\\n            int score=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%divisors[i] == 0){\\n                    score++;\\n                }\\n            }\\n            if(score>maxscore){\\n                maxscore=score;\\n                max=divisors[i];\\n            }else if(score==maxscore){\\n                max=Math.min(max,divisors[i]);\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max=divisors[0];\\n        int maxscore=0;\\n        for(int i=0;i<divisors.length;i++){\\n            int score=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%divisors[i] == 0){\\n                    score++;\\n                }\\n            }\\n            if(score>maxscore){\\n                maxscore=score;\\n                max=divisors[i];\\n            }else if(score==maxscore){\\n                max=Math.min(max,divisors[i]);\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535060,
                "title": "python3-nested-loop-based-solution-o-n-2-complexity-beats-97-3-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        res, lst = 0, []\\n        for div in set(divisors):\\n            curr = 0\\n            for n in nums:\\n                if not n % div:\\n                    curr += 1\\n            if curr > res:\\n                res = curr\\n                lst = [div]\\n            elif curr == res:\\n                lst.append(div)\\n        return min(lst)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        res, lst = 0, []\\n        for div in set(divisors):\\n            curr = 0\\n            for n in nums:\\n                if not n % div:\\n                    curr += 1\\n            if curr > res:\\n                res = curr\\n                lst = [div]\\n            elif curr == res:\\n                lst.append(div)\\n        return min(lst)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532399,
                "title": "c-simple-loop-372ms-935",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int MaxDivScore(int[] nums, int[] divisors) \\n    {\\n        var maxDivIdx = 0;\\n        var maxDivCount = int.MinValue;\\n\\n        for(var i = 0; i < divisors.Length; i++)    \\n        {\\n            var count = 0;\\n\\n            foreach(var n in nums)\\n                if(n % divisors[i] == 0) count++;\\n\\n            if(maxDivCount < count)\\n            {\\n                maxDivIdx = i;\\n                maxDivCount = count;\\n            }\\n            else if(maxDivCount == count && divisors[maxDivIdx] > divisors[i])\\n            {\\n                maxDivIdx = i;\\n            }\\n        }\\n\\n        return divisors[maxDivIdx];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxDivScore(int[] nums, int[] divisors) \\n    {\\n        var maxDivIdx = 0;\\n        var maxDivCount = int.MinValue;\\n\\n        for(var i = 0; i < divisors.Length; i++)    \\n        {\\n            var count = 0;\\n\\n            foreach(var n in nums)\\n                if(n % divisors[i] == 0) count++;\\n\\n            if(maxDivCount < count)\\n            {\\n                maxDivIdx = i;\\n                maxDivCount = count;\\n            }\\n            else if(maxDivCount == count && divisors[maxDivIdx] > divisors[i])\\n            {\\n                maxDivIdx = i;\\n            }\\n        }\\n\\n        return divisors[maxDivIdx];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531467,
                "title": "divisor-dilemma-score-more-soar-with-the-smallest-score",
                "content": "# Intuition\\nThe problem is asking us to calculate the divisibility score for each divisor, and return the one with the highest score. If there are multiple divisors with the highest score, we should return the smallest one. Given that we need to compare each number in the nums array with each number in the divisors array, a brute force approach with nested loops immediately comes to mind.\\n\\n# Approach\\nThe approach here involves iterating over each divisor, and for each divisor, iterating over each number in nums to check if it\\'s divisible by that divisor. We maintain two variables, maxScore and minDivisor to track the divisor with the maximum divisibility score and the minimum divisor (in case of a tie in scores).\\n\\nHere\\'s a step-by-step breakdown:\\n\\n1. Initialize maxScore to 0 and minDivisor to Infinity.\\n2. For each divisor in divisors, initialize score to 0.\\n3. For each num in nums, if num is divisible by divisor (num % divisor === 0), increment score.\\n4. After calculating score for a divisor, check if it is greater than maxScore, or if it is equal to maxScore and divisor is less than minDivisor. If either is true, update maxScore and minDivisor to the current score and divisor respectively.\\n5. After iterating over all divisors, return minDivisor.\\n\\n# Complexity\\n- Time complexity: The time complexity is O(n*m), where n is the length of the nums array and m is the length of the divisors array. This is because for each divisor, we iterate over all numbers.\\n\\n- Space complexity: The space complexity is O(1), because no additional space is used that scales with the input size. The variables maxScore, minDivisor, and score take constant space.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} divisors\\n * @return {number}\\n */\\nfunction maxDivScore (nums, divisors) {\\n    let maxScore = 0;\\n    let minDivisor = Infinity;\\n    for (let divisor of divisors) {\\n        let score = 0;\\n        for (let num of nums) {\\n            if (num % divisor === 0) {\\n                score++;\\n            }\\n        }\\n        if (score > maxScore || (score === maxScore && divisor < minDivisor)) {\\n            maxScore = score;\\n            minDivisor = divisor;\\n        }\\n    }\\n    return minDivisor;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} divisors\\n * @return {number}\\n */\\nfunction maxDivScore (nums, divisors) {\\n    let maxScore = 0;\\n    let minDivisor = Infinity;\\n    for (let divisor of divisors) {\\n        let score = 0;\\n        for (let num of nums) {\\n            if (num % divisor === 0) {\\n                score++;\\n            }\\n        }\\n        if (score > maxScore || (score === maxScore && divisor < minDivisor)) {\\n            maxScore = score;\\n            minDivisor = divisor;\\n        }\\n    }\\n    return minDivisor;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3523371,
                "title": "elixir-my-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndefmodule Solution do\\n  @spec max_div_score(nums :: [integer], divisors :: [integer]) :: integer\\n  def max_div_score(nums, divisors) do\\n    divisors |>\\n      Enum.reduce({-1, -1}, fn divisor, {ans, max_cnt} ->\\n        cnt =\\n          Enum.reduce(nums, 0, fn num, cnt ->\\n            if rem(num, divisor) == 0 do\\n              cnt + 1\\n            else\\n              cnt\\n            end\\n          end)\\n        cond do\\n          cnt > max_cnt ->\\n            {divisor, cnt}\\n          cnt == max_cnt ->\\n            {min(ans, divisor), cnt}\\n          true ->\\n            {ans, max_cnt}\\n        end\\n      end) |> elem(0)\\n  end\\nend\\n\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec max_div_score(nums :: [integer], divisors :: [integer]) :: integer\\n  def max_div_score(nums, divisors) do\\n    divisors |>\\n      Enum.reduce({-1, -1}, fn divisor, {ans, max_cnt} ->\\n        cnt =\\n          Enum.reduce(nums, 0, fn num, cnt ->\\n            if rem(num, divisor) == 0 do\\n              cnt + 1\\n            else\\n              cnt\\n            end\\n          end)\\n        cond do\\n          cnt > max_cnt ->\\n            {divisor, cnt}\\n          cnt == max_cnt ->\\n            {min(ans, divisor), cnt}\\n          true ->\\n            {ans, max_cnt}\\n        end\\n      end) |> elem(0)\\n  end\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3517404,
                "title": "js-solution",
                "content": "\\n```\\n\\nconst maxDivScore = function (nums, divisors) {\\n  let output = 0;\\n  let maxCount = 0\\n  let count = 0;\\n\\n  for (const div of divisors) {\\n    \\n    for (const num of nums) {\\n      if (num % div === 0) count++;\\n    }\\n    \\n    if (count > maxCount) {\\n      maxCount = count\\n      output = div\\n    }\\n\\n    else if (count === maxCount && div < output) {\\n      output = div\\n    }\\n\\n    count = 0;\\n  }\\n\\n  return output || Math.min(...divisors)\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nconst maxDivScore = function (nums, divisors) {\\n  let output = 0;\\n  let maxCount = 0\\n  let count = 0;\\n\\n  for (const div of divisors) {\\n    \\n    for (const num of nums) {\\n      if (num % div === 0) count++;\\n    }\\n    \\n    if (count > maxCount) {\\n      maxCount = count\\n      output = div\\n    }\\n\\n    else if (count === maxCount && div < output) {\\n      output = div\\n    }\\n\\n    count = 0;\\n  }\\n\\n  return output || Math.min(...divisors)\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3513370,
                "title": "very-easy-jebasraja",
                "content": "# Intuition:Karunya university:ACCENTURE\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) \\n    {\\n        \\n        int max=-1;\\n\\nint count=0;\\n\\nint dividing=0;\\n\\nint notdividebyanyvalue=2147483647;\\n\\nfor (int i = 0; i < divisors.length; i++)\\n {\\n    for (int j = 0; j < nums.length; j++) \\n    {\\n        if (nums[j]%divisors[i]==0) \\n        {\\n            \\n            count++;\\n        \\n            if (count==max) \\n            {\\n                if (divisors[i]<dividing) \\n                {\\n                  count=max;\\n                  dividing=divisors[i];  \\n                }\\n                //max=count;\\n            }\\n\\n            else if (count>max) \\n            {\\n                max=count;\\n                dividing=divisors[i];\\n            }\\n        }\\n        else\\n        {\\n            if (divisors[i]<notdividebyanyvalue) \\n            {\\n                notdividebyanyvalue=divisors[i];\\n            }\\n        }\\n    }\\n    count=0;\\n}\\n\\nif (dividing==0)\\n{\\n   //System.out.println(notdividebyanyvalue); \\n    \\n   return notdividebyanyvalue;\\n}\\nelse\\n{\\n    return dividing;\\n    //System.out.println(dividing);\\n    //System.out.println(dividing);\\n}\\n\\n\\n\\n\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) \\n    {\\n        \\n        int max=-1;\\n\\nint count=0;\\n\\nint dividing=0;\\n\\nint notdividebyanyvalue=2147483647;\\n\\nfor (int i = 0; i < divisors.length; i++)\\n {\\n    for (int j = 0; j < nums.length; j++) \\n    {\\n        if (nums[j]%divisors[i]==0) \\n        {\\n            \\n            count++;\\n        \\n            if (count==max) \\n            {\\n                if (divisors[i]<dividing) \\n                {\\n                  count=max;\\n                  dividing=divisors[i];  \\n                }\\n                //max=count;\\n            }\\n\\n            else if (count>max) \\n            {\\n                max=count;\\n                dividing=divisors[i];\\n            }\\n        }\\n        else\\n        {\\n            if (divisors[i]<notdividebyanyvalue) \\n            {\\n                notdividebyanyvalue=divisors[i];\\n            }\\n        }\\n    }\\n    count=0;\\n}\\n\\nif (dividing==0)\\n{\\n   //System.out.println(notdividebyanyvalue); \\n    \\n   return notdividebyanyvalue;\\n}\\nelse\\n{\\n    return dividing;\\n    //System.out.println(dividing);\\n    //System.out.println(dividing);\\n}\\n\\n\\n\\n\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509322,
                "title": "c-easy-linear-time-constant-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int n=nums.size(),m=divisors.size();\\n        int ans=1e9;\\n        int finalcount=-1e9;\\n        for(int i=0;i<m;i++){\\n            int cnt=0;\\n            for(int j=0;j<n;j++){\\n                if(nums[j]%divisors[i]==0) cnt++;\\n            }\\n            if(cnt>finalcount){\\n                ans=divisors[i];\\n                finalcount=cnt;\\n            }\\n            else if(cnt==finalcount) ans=min(ans,divisors[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int n=nums.size(),m=divisors.size();\\n        int ans=1e9;\\n        int finalcount=-1e9;\\n        for(int i=0;i<m;i++){\\n            int cnt=0;\\n            for(int j=0;j<n;j++){\\n                if(nums[j]%divisors[i]==0) cnt++;\\n            }\\n            if(cnt>finalcount){\\n                ans=divisors[i];\\n                finalcount=cnt;\\n            }\\n            else if(cnt==finalcount) ans=min(ans,divisors[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509175,
                "title": "optimized-solution-space-o-1-c-c",
                "content": "# Complexity\\n- Time complexity:\\n**O(N*K)**\\n- Space complexity:\\n**O(1)**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int max=INT_MIN,ans=INT_MAX;\\n        for(int i=0;i<divisors.size();i++){\\n            int count=0,x=divisors[i];\\n            for(int j:nums){\\n                if(j%x==0) count++;\\n            }\\n            if(count>max){\\n                max=count;\\n                ans=x;\\n            }\\n            else if(count==max){\\n                if(x<ans) ans=x;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int max=INT_MIN,ans=INT_MAX;\\n        for(int i=0;i<divisors.size();i++){\\n            int count=0,x=divisors[i];\\n            for(int j:nums){\\n                if(j%x==0) count++;\\n            }\\n            if(count>max){\\n                max=count;\\n                ans=x;\\n            }\\n            else if(count==max){\\n                if(x<ans) ans=x;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3504046,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int c,max,ans;\\n        max=Integer.MIN_VALUE;\\n        ans=0;\\n        Arrays.sort(divisors);\\n        for(int i=0;i<divisors.length;i++)\\n        {\\n            c=0;\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                if(nums[j]%divisors[i]==0)\\n                {\\n                    c++;\\n                }\\n            }\\n            if(c>max)\\n            {\\n                max=c;\\n                ans=divisors[i];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int c,max,ans;\\n        max=Integer.MIN_VALUE;\\n        ans=0;\\n        Arrays.sort(divisors);\\n        for(int i=0;i<divisors.length;i++)\\n        {\\n            c=0;\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                if(nums[j]%divisors[i]==0)\\n                {\\n                    c++;\\n                }\\n            }\\n            if(c>max)\\n            {\\n                max=c;\\n                ans=divisors[i];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502814,
                "title": "dictionary-sort-python-solution",
                "content": "This question is similar to [2404. Most Frequent Even Element](https://leetcode.com/problems/most-frequent-even-element/solutions/3502776/dictionary-sort-python-solution/).\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        d = {}\\n        for di in divisors:\\n            if di not in d:\\n                c = 0\\n                for n in nums:\\n                    if n % di == 0:\\n                        c += 1\\n                d[di] = c\\n        return sorted([[k, v] for k, v in d.items()], key=lambda x: (-x[1], x[0]))[0][0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        d = {}\\n        for di in divisors:\\n            if di not in d:\\n                c = 0\\n                for n in nums:\\n                    if n % di == 0:\\n                        c += 1\\n                d[di] = c\\n        return sorted([[k, v] for k, v in d.items()], key=lambda x: (-x[1], x[0]))[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3500317,
                "title": "c-brute-force-easy-understandable",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n            int ans=0;\\n            int maxi=0;\\n            vector<int>answ;\\n        for(int i =0; i<divisors.size(); i++){\\n              int count =0;\\n            int num = divisors[i];\\n            for(int j=0 ;j<nums.size();j++){\\n                if(nums[j]%num==0){\\n                    count++;\\n                }\\n            }\\n                if(ans == count){\\n                        maxi = maxi == 0 ? num : min(maxi,num);\\n                }\\n                else if(count>ans){\\n                        ans = count;\\n                        maxi = num;\\n                }\\n            \\n        }\\n    \\n        return maxi;\\n    }\\n}; \\n\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n            int ans=0;\\n            int maxi=0;\\n            vector<int>answ;\\n        for(int i =0; i<divisors.size(); i++){\\n              int count =0;\\n            int num = divisors[i];\\n            for(int j=0 ;j<nums.size();j++){\\n                if(nums[j]%num==0){\\n                    count++;\\n                }\\n            }\\n                if(ans == count){\\n                        maxi = maxi == 0 ? num : min(maxi,num);\\n                }\\n                else if(count>ans){\\n                        ans = count;\\n                        maxi = num;\\n                }\\n            \\n        }\\n    \\n        return maxi;\\n    }\\n}; \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489246,
                "title": "bruteforce-short-and-simple",
                "content": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) \\n    {\\n        int maxCount=Integer.MIN_VALUE;\\n        int ans=Integer.MIN_VALUE;\\n        for(int i=0;i<divisors.length;i++)\\n        {\\n            int count=0;\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                if(nums[j]%divisors[i]==0)\\n                    count++;\\n            }\\n            if(count>maxCount)\\n            {\\n                maxCount=count;\\n                ans=divisors[i];\\n            }\\n            else if(count==maxCount)\\n            {\\n                ans=Math.min(ans,divisors[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) \\n    {\\n        int maxCount=Integer.MIN_VALUE;\\n        int ans=Integer.MIN_VALUE;\\n        for(int i=0;i<divisors.length;i++)\\n        {\\n            int count=0;\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                if(nums[j]%divisors[i]==0)\\n                    count++;\\n            }\\n            if(count>maxCount)\\n            {\\n                maxCount=count;\\n                ans=divisors[i];\\n            }\\n            else if(count==maxCount)\\n            {\\n                ans=Math.min(ans,divisors[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484618,
                "title": "easy-to-understand-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int max_count = 0;\\n        int max_divisor = divisors[0];\\n        for(int divisor: divisors){\\n\\n            int count = 0;\\n            //checking for no of divisible nos.\\n            for(int number: nums){\\n                if(number % divisor == 0){\\n                    count ++;\\n                }\\n            }\\n            // checking is it the max count\\n            if(count > max_count ){\\n                max_count = count;\\n                max_divisor = divisor;\\n            }\\n            // if same count checking is it the minimum\\n            else if (count == max_count){\\n                if (max_divisor > divisor){\\n                    max_divisor = divisor;\\n                }\\n            }\\n        }\\n        return max_divisor;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int max_count = 0;\\n        int max_divisor = divisors[0];\\n        for(int divisor: divisors){\\n\\n            int count = 0;\\n            //checking for no of divisible nos.\\n            for(int number: nums){\\n                if(number % divisor == 0){\\n                    count ++;\\n                }\\n            }\\n            // checking is it the max count\\n            if(count > max_count ){\\n                max_count = count;\\n                max_divisor = divisor;\\n            }\\n            // if same count checking is it the minimum\\n            else if (count == max_count){\\n                if (max_divisor > divisor){\\n                    max_divisor = divisor;\\n                }\\n            }\\n        }\\n        return max_divisor;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483863,
                "title": "java-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int maxDivScore(int[] nums, int[] divisors) {\\n    int maxi = -1, div = -1;\\n\\n    for(int d: divisors){\\n      int t = 0;\\n      for(int n: nums)\\n        if(n % d == 0) ++t;\\n      if(t > maxi) {maxi = t; div = d;}\\n      else if(t == maxi) div = div > d ? d : div;\\n    }\\n\\n    return div;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int maxDivScore(int[] nums, int[] divisors) {\\n    int maxi = -1, div = -1;\\n\\n    for(int d: divisors){\\n      int t = 0;\\n      for(int n: nums)\\n        if(n % d == 0) ++t;\\n      if(t > maxi) {maxi = t; div = d;}\\n      else if(t == maxi) div = div > d ? d : div;\\n    }\\n\\n    return div;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483665,
                "title": "brute-force-functional-style",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(m * n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nfunction maxDivScore(nums: number[], divisors: number[]): number {\\n  // Calculate the number of elements in `nums` that are divisible by each divisor\\n  const scores = divisors.reduce(\\n    (score: number[], divisor, idx) => {\\n      // Iterate over each element in `nums` and check if it is divisible by the current divisor\\n      nums.forEach((num) => {\\n        if (num % divisor === 0) score[idx] += 1;\\n      });\\n\\n      return score;\\n    },\\n    // Initialize the `score` array with zeros\\n    Array.from({ length: divisors.length }).map((_) => 0)\\n  );\\n\\n  // Find the maximum score\\n  const maxScore = Math.max(...scores);\\n  // Find the indices of the scores that are tied for the maximum score\\n  const tiedScoresIdxs = scores.reduce((acc: number[], score, idx) => {\\n    score === maxScore ? acc.push(idx) : acc;\\n\\n    return acc;\\n  }, []);\\n  // Map the tied score indices to their corresponding divisors\\n  const tiedScores = tiedScoresIdxs.map((scoreIdx) => divisors[scoreIdx]);\\n\\n  // Return the smallest tied score\\n  return Math.min(...tiedScores);\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction maxDivScore(nums: number[], divisors: number[]): number {\\n  // Calculate the number of elements in `nums` that are divisible by each divisor\\n  const scores = divisors.reduce(\\n    (score: number[], divisor, idx) => {\\n      // Iterate over each element in `nums` and check if it is divisible by the current divisor\\n      nums.forEach((num) => {\\n        if (num % divisor === 0) score[idx] += 1;\\n      });\\n\\n      return score;\\n    },\\n    // Initialize the `score` array with zeros\\n    Array.from({ length: divisors.length }).map((_) => 0)\\n  );\\n\\n  // Find the maximum score\\n  const maxScore = Math.max(...scores);\\n  // Find the indices of the scores that are tied for the maximum score\\n  const tiedScoresIdxs = scores.reduce((acc: number[], score, idx) => {\\n    score === maxScore ? acc.push(idx) : acc;\\n\\n    return acc;\\n  }, []);\\n  // Map the tied score indices to their corresponding divisors\\n  const tiedScores = tiedScoresIdxs.map((scoreIdx) => divisors[scoreIdx]);\\n\\n  // Return the smallest tied score\\n  return Math.min(...tiedScores);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3480048,
                "title": "java-simple-solution-bruteforce-counting",
                "content": "# Complexity\\n- Time complexity: $$O(m * n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int maxScore = 0;\\n        int divisorWithMaxScore = divisors[0];\\n        for (int divisor : divisors) {\\n            int currentScore = 0;\\n            for (int num : nums) {\\n                if (num % divisor == 0) {\\n                    currentScore++;\\n                }\\n            }\\n\\n            if (currentScore > maxScore) {\\n                maxScore = currentScore;\\n                divisorWithMaxScore = divisor;\\n            } else if (currentScore == maxScore) {\\n                divisorWithMaxScore = Math.min(divisorWithMaxScore, divisor);\\n            }\\n        }\\n\\n        return divisorWithMaxScore;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int maxScore = 0;\\n        int divisorWithMaxScore = divisors[0];\\n        for (int divisor : divisors) {\\n            int currentScore = 0;\\n            for (int num : nums) {\\n                if (num % divisor == 0) {\\n                    currentScore++;\\n                }\\n            }\\n\\n            if (currentScore > maxScore) {\\n                maxScore = currentScore;\\n                divisorWithMaxScore = divisor;\\n            } else if (currentScore == maxScore) {\\n                divisorWithMaxScore = Math.min(divisorWithMaxScore, divisor);\\n            }\\n        }\\n\\n        return divisorWithMaxScore;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479671,
                "title": "brute-force-approach-easy-understanding",
                "content": "``\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& n, vector<int>& d) {\\n        int mxCnt=-1,ans=-1;\\n        for(int i=0;i<d.size();i++){\\n            int cnt=0;\\n            for(int j=0;j<n.size();j++){\\n                if(n[j]%d[i]==0){\\n                    cnt++;\\n                }\\n            }\\n            if(cnt>mxCnt){\\n                mxCnt=cnt;\\n                ans=d[i];\\n            }else if(mxCnt==cnt){\\n                ans=min(ans,d[i]);\\n            }\\n            cnt=0;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n    int maxDivScore(vector<int>& n, vector<int>& d) {\\n        int mxCnt=-1,ans=-1;\\n        for(int i=0;i<d.size();i++){\\n            int cnt=0;\\n            for(int j=0;j<n.size();j++){\\n                if(n[j]%d[i]==0){\\n                    cnt++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3479097,
                "title": "c-brute-force-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int maxi=-1;\\n        int ans=-1;\\n        for(auto div:divisors){\\n            int cnt=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]%div==0){\\n                cnt++;\\n            }\\n        }\\n        if(maxi<cnt){\\n            maxi=cnt;\\n            ans=div;\\n        }\\n        else if(maxi==cnt){\\n            ans=ans<div?ans:div;\\n        }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int maxi=-1;\\n        int ans=-1;\\n        for(auto div:divisors){\\n            int cnt=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]%div==0){\\n                cnt++;\\n            }\\n        }\\n        if(maxi<cnt){\\n            maxi=cnt;\\n            ans=div;\\n        }\\n        else if(maxi==cnt){\\n            ans=ans<div?ans:div;\\n        }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471227,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        \\n        int maxScore = -1;\\n        int ans = 0;\\n        \\n        for(int d: divisors){\\n            int count = 0;\\n            for(int i : nums){\\n                if(i % d == 0){\\n                    count++;\\n                }\\n            }\\n            if(count > maxScore){\\n                maxScore = count;\\n                ans = d;\\n            } else if(count == maxScore && ans > d){\\n                ans = d;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        \\n        int maxScore = -1;\\n        int ans = 0;\\n        \\n        for(int d: divisors){\\n            int count = 0;\\n            for(int i : nums){\\n                if(i % d == 0){\\n                    count++;\\n                }\\n            }\\n            if(count > maxScore){\\n                maxScore = count;\\n                ans = d;\\n            } else if(count == maxScore && ans > d){\\n                ans = d;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470255,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        Arrays.sort(divisors);\\n        int ans = 0;\\n        int ans1 = divisors[0];\\n        for(int i = 0; i < divisors.length; i++){\\n            int count = 0;\\n            for(int j = 0; j < nums.length; j++){\\n                    if(nums[j] % divisors[i] == 0){\\n                        count++;\\n                    }\\n                     if(ans < count){\\n                ans = count;\\n                ans1 = divisors[i];\\n            }\\n            }\\n           \\n        }\\n        return ans1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        Arrays.sort(divisors);\\n        int ans = 0;\\n        int ans1 = divisors[0];\\n        for(int i = 0; i < divisors.length; i++){\\n            int count = 0;\\n            for(int j = 0; j < nums.length; j++){\\n                    if(nums[j] % divisors[i] == 0){\\n                        count++;\\n                    }\\n                     if(ans < count){\\n                ans = count;\\n                ans1 = divisors[i];\\n            }\\n            }\\n           \\n        }\\n        return ans1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465651,
                "title": "easy-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int val = divisors[0];\\n        int max = -1;\\n\\n        for(int i : divisors){\\n            int count = 0;\\n            for(int j : nums){\\n                if(j%i == 0){\\n                    count++;\\n                }\\n            }\\n\\n            if(count == max){\\n                val = val > i ? i : val;\\n            }\\n\\n            if(count > max){\\n                max = count;\\n                val = i;\\n            }\\n        }\\n\\n        return val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int val = divisors[0];\\n        int max = -1;\\n\\n        for(int i : divisors){\\n            int count = 0;\\n            for(int j : nums){\\n                if(j%i == 0){\\n                    count++;\\n                }\\n            }\\n\\n            if(count == max){\\n                val = val > i ? i : val;\\n            }\\n\\n            if(count > max){\\n                max = count;\\n                val = i;\\n            }\\n        }\\n\\n        return val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464748,
                "title": "java-sorting-explained",
                "content": "**Idea:**\\n* Brute force count score for each divisor and take the min of such divisors which have the max score\\n* Extra space is taken by Arrays.sort. \\n* Sorting is not required but required for binary search\\n* Sorting doesn\\'t effect overall time complexity but makes the algo more efficient\\n>**T/S:** O(mn)/O(m), where m = size(nums), n = size(divisors)\\n```\\npublic int maxDivScore(int[] nums, int[] divisors) {\\n\\tvar maxScore = 0;\\n\\tvar winnerDivisor = Integer.MAX_VALUE;\\n\\tArrays.sort(nums);\\n\\n\\tfor (var divisor : divisors) {\\n\\t\\tvar i = Arrays.binarySearch(nums, divisor);\\n\\t\\tif (i < 0)\\n\\t\\t\\ti = ~i;\\n\\n\\t\\tvar score = 0;\\n\\t\\tfor (; i < nums.length; i++)\\n\\t\\t\\tif (nums[i] % divisor == 0)\\n\\t\\t\\t\\tscore++;\\n\\n\\t\\tif (score > maxScore) {\\n\\t\\t\\tmaxScore = score;\\n\\t\\t\\twinnerDivisor = divisor;\\n\\t\\t} else if (score == maxScore) {\\n\\t\\t\\twinnerDivisor = Math.min(winnerDivisor, divisor);\\n\\t\\t}\\n\\t}\\n\\n\\treturn winnerDivisor;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int maxDivScore(int[] nums, int[] divisors) {\\n\\tvar maxScore = 0;\\n\\tvar winnerDivisor = Integer.MAX_VALUE;\\n\\tArrays.sort(nums);\\n\\n\\tfor (var divisor : divisors) {\\n\\t\\tvar i = Arrays.binarySearch(nums, divisor);\\n\\t\\tif (i < 0)\\n\\t\\t\\ti = ~i;\\n\\n\\t\\tvar score = 0;\\n\\t\\tfor (; i < nums.length; i++)\\n\\t\\t\\tif (nums[i] % divisor == 0)\\n\\t\\t\\t\\tscore++;\\n\\n\\t\\tif (score > maxScore) {\\n\\t\\t\\tmaxScore = score;\\n\\t\\t\\twinnerDivisor = divisor;\\n\\t\\t} else if (score == maxScore) {\\n\\t\\t\\twinnerDivisor = Math.min(winnerDivisor, divisor);\\n\\t\\t}\\n\\t}\\n\\n\\treturn winnerDivisor;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3464334,
                "title": "find-the-maximum-divisibility-score",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxDivScore(self, nums, divisors):\\n        dict1={}\\n        for i in divisors:\\n            count1=0\\n            for j in nums:\\n                if(j%i==0):\\n                    print(j,i)\\n                    print(count1)\\n                    count1+=1\\n            dict1[i]=count1\\n        maxvalue=max(dict1.values())\\n        list2=[]\\n        for key in dict1:\\n            if(dict1[key]==maxvalue):\\n                list2.append(key)\\n        return min(list2)\\n    \\n    \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxDivScore(self, nums, divisors):\\n        dict1={}\\n        for i in divisors:\\n            count1=0\\n            for j in nums:\\n                if(j%i==0):\\n                    print(j,i)\\n                    print(count1)\\n                    count1+=1\\n            dict1[i]=count1\\n        maxvalue=max(dict1.values())\\n        list2=[]\\n        for key in dict1:\\n            if(dict1[key]==maxvalue):\\n                list2.append(key)\\n        return min(list2)\\n    \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455862,
                "title": "two-solutions-hashmaps-or-two-pass",
                "content": "# Two Pass\\n```\\nclass Solution{\\npublic int maxDivScore(int[] nums, int[] divisors) {\\n    int max = -1, val = -1;\\n    for (int i : divisors) {\\n        int count = 0;\\n        for (int j : nums) {\\n            if (j % i == 0) {\\n                count++;\\n            }\\n        }\\n        if (max < count) {\\n            max = count;\\n            val = i;\\n        } else if (max == count) {\\n            val = Math.min(val, i);\\n        }\\n    }\\n    return val;\\n}\\n}\\n```\\n# HashMaps\\n```\\nclass Solution{\\npublic int maxDivScore(int[] nums, int[] divisors) {\\n    Map<Integer, Integer> map = new HashMap<>();\\n    for (int divisor : divisors) {\\n        if (!map.containsKey(divisor)) {\\n            int count = 0;\\n            for (int num : nums) {\\n                if (num % divisor == 0) {\\n                    count++;\\n                }\\n            }\\n            map.put(divisor, count);\\n        }\\n    }\\n    int maxCount = -1;\\n    int minDivisor = -1;\\n    for (int divisor : map.keySet()) {\\n        int count = map.get(divisor);\\n        if (count > maxCount) {\\n            maxCount = count;\\n            minDivisor = divisor;\\n        } else if (count == maxCount && divisor < minDivisor) {\\n            minDivisor = divisor;\\n        }\\n    }\\n    return minDivisor;\\n}\\n}\\n```\\n# Do Upvote if you find it helpful",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution{\\npublic int maxDivScore(int[] nums, int[] divisors) {\\n    int max = -1, val = -1;\\n    for (int i : divisors) {\\n        int count = 0;\\n        for (int j : nums) {\\n            if (j % i == 0) {\\n                count++;\\n            }\\n        }\\n        if (max < count) {\\n            max = count;\\n            val = i;\\n        } else if (max == count) {\\n            val = Math.min(val, i);\\n        }\\n    }\\n    return val;\\n}\\n}\\n```\n```\\nclass Solution{\\npublic int maxDivScore(int[] nums, int[] divisors) {\\n    Map<Integer, Integer> map = new HashMap<>();\\n    for (int divisor : divisors) {\\n        if (!map.containsKey(divisor)) {\\n            int count = 0;\\n            for (int num : nums) {\\n                if (num % divisor == 0) {\\n                    count++;\\n                }\\n            }\\n            map.put(divisor, count);\\n        }\\n    }\\n    int maxCount = -1;\\n    int minDivisor = -1;\\n    for (int divisor : map.keySet()) {\\n        int count = map.get(divisor);\\n        if (count > maxCount) {\\n            maxCount = count;\\n            minDivisor = divisor;\\n        } else if (count == maxCount && divisor < minDivisor) {\\n            minDivisor = divisor;\\n        }\\n    }\\n    return minDivisor;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454920,
                "title": "easy-java-solution-leetcode-easy-explain",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n       int max=-1;\\n    int maxscore= Integer .MAX_VALUE;\\n    for(int d:divisors){\\n        int count=0;\\n        for(int n:nums){\\n            if(n%d==0)\\n            count++;\\n        }\\n        if(count>max){\\n            max=count;\\n            maxscore=d;\\n\\n        }\\n        else if(count==max){\\n         maxscore=Math.min(maxscore,d);\\n        }\\n    }\\n  return maxscore;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n       int max=-1;\\n    int maxscore= Integer .MAX_VALUE;\\n    for(int d:divisors){\\n        int count=0;\\n        for(int n:nums){\\n            if(n%d==0)\\n            count++;\\n        }\\n        if(count>max){\\n            max=count;\\n            maxscore=d;\\n\\n        }\\n        else if(count==max){\\n         maxscore=Math.min(maxscore,d);\\n        }\\n    }\\n  return maxscore;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448359,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors)\\n    {\\n        int len=nums.length;\\n        int lent=divisors.length;\\n        int min=0;\\n        int max=0;\\n        for(int i=0;i<lent;i++)\\n        {\\n            int count=0;\\n            int div=divisors[i];\\n            for(int j=0;j<len;j++)\\n            {\\n                if(nums[j]%div==0)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count>=max)\\n            {\\n                if(count>max)\\n                {\\n                    max=count;\\n                    min=div;\\n                }\\n                    \\n                    else\\n                    {\\n                        if(min==0)\\n                        {\\n                          min=div;\\n                            max=count;\\n                        }\\n                        else\\n                        {\\n                        if(div<min)\\n                        {\\n                            min=div;\\n                        }\\n                        }\\n                    }\\n                }\\n            }\\n        \\n        return min;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors)\\n    {\\n        int len=nums.length;\\n        int lent=divisors.length;\\n        int min=0;\\n        int max=0;\\n        for(int i=0;i<lent;i++)\\n        {\\n            int count=0;\\n            int div=divisors[i];\\n            for(int j=0;j<len;j++)\\n            {\\n                if(nums[j]%div==0)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count>=max)\\n            {\\n                if(count>max)\\n                {\\n                    max=count;\\n                    min=div;\\n                }\\n                    \\n                    else\\n                    {\\n                        if(min==0)\\n                        {\\n                          min=div;\\n                            max=count;\\n                        }\\n                        else\\n                        {\\n                        if(div<min)\\n                        {\\n                            min=div;\\n                        }\\n                        }\\n                    }\\n                }\\n            }\\n        \\n        return min;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447165,
                "title": "2644-easy-to-understand-c-code-two-for-loops-accepted",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& div) \\n    {\\n        int max=INT_MIN,ans=div[0];\\n        for(int i=0;i<div.size();i++){\\n            int sum=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%div[i]==0)\\n                    sum++;\\n            }\\n            if(sum>=max){\\n                if(sum==max)\\n                    ans=min(div[i],ans);\\n                else{\\n                    max=sum;\\n                    ans=div[i];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& div) \\n    {\\n        int max=INT_MIN,ans=div[0];\\n        for(int i=0;i<div.size();i++){\\n            int sum=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%div[i]==0)\\n                    sum++;\\n            }\\n            if(sum>=max){\\n                if(sum==max)\\n                    ans=min(div[i],ans);\\n                else{\\n                    max=sum;\\n                    ans=div[i];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446317,
                "title": "easy-to-understand-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int score=0, user = divisors[0];\\n        for(int i=0; i < divisors.size(); i++){\\n            int divided=0;\\n            for(int j=0; j < nums.size(); j++){\\n                if(nums[j] % divisors[i]==0) divided++;\\n            }\\n            if(divided >= score){\\n                if(divided==score){\\n                    if(user > divisors[i]) user = divisors[i];\\n                }\\n                else user = divisors[i];\\n                score = divided;\\n            }\\n        }\\n        return user;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int score=0, user = divisors[0];\\n        for(int i=0; i < divisors.size(); i++){\\n            int divided=0;\\n            for(int j=0; j < nums.size(); j++){\\n                if(nums[j] % divisors[i]==0) divided++;\\n            }\\n            if(divided >= score){\\n                if(divided==score){\\n                    if(user > divisors[i]) user = divisors[i];\\n                }\\n                else user = divisors[i];\\n                score = divided;\\n            }\\n        }\\n        return user;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444918,
                "title": "c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N*logN) + O(N^2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int ans = 0, ind = 0;\\n        sort(divisors.begin(), divisors.end());\\n        int m = nums.size(), n = divisors.size();\\n        for(int i = 0; i < n; i++){\\n            int score = 0;\\n            for(int j = 0; j < m; j++){\\n                if(nums[j] % divisors[i] == 0) score++;\\n            }\\n            if(score > ans){\\n                ans = score;\\n                ind = i;\\n            }\\n        }\\n        // if(ind == -1) return divisors[0];\\n        return divisors[ind];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int ans = 0, ind = 0;\\n        sort(divisors.begin(), divisors.end());\\n        int m = nums.size(), n = divisors.size();\\n        for(int i = 0; i < n; i++){\\n            int score = 0;\\n            for(int j = 0; j < m; j++){\\n                if(nums[j] % divisors[i] == 0) score++;\\n            }\\n            if(score > ans){\\n                ans = score;\\n                ind = i;\\n            }\\n        }\\n        // if(ind == -1) return divisors[0];\\n        return divisors[ind];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444258,
                "title": "simple-c-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(m*n), m == nums.size(), n == divisors.size()\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int ans, cnt = 0;\\n        for(int i = 0; i < divisors.size(); i++)\\n        {\\n            int cnt1 = 0;\\n            for(int j = 0; j < nums.size(); j++)\\n            {\\n                if(nums[j] % divisors[i] == 0)\\n                {\\n                    cnt1++;\\n                }\\n            }\\n            if(cnt1 > cnt)\\n            {\\n                cnt = cnt1;\\n                ans = divisors[i];\\n            }\\n            else if(cnt1 == cnt)\\n            {\\n                ans = min(ans, divisors[i]);\\n            }\\n        }\\n        if(cnt == 0)\\n        {\\n            sort(divisors.begin(), divisors.end());\\n            ans = divisors[0];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int ans, cnt = 0;\\n        for(int i = 0; i < divisors.size(); i++)\\n        {\\n            int cnt1 = 0;\\n            for(int j = 0; j < nums.size(); j++)\\n            {\\n                if(nums[j] % divisors[i] == 0)\\n                {\\n                    cnt1++;\\n                }\\n            }\\n            if(cnt1 > cnt)\\n            {\\n                cnt = cnt1;\\n                ans = divisors[i];\\n            }\\n            else if(cnt1 == cnt)\\n            {\\n                ans = min(ans, divisors[i]);\\n            }\\n        }\\n        if(cnt == 0)\\n        {\\n            sort(divisors.begin(), divisors.end());\\n            ans = divisors[0];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443219,
                "title": "beats-92-with-explanation-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe just Apply the brute force approach for each element in divisor we divide with each element in nums and if it is completely divisible by the divisor element we increase the count by 1 and check if the count of current pointer is less than or greater than the previous pointer (countC)\\nthen we assign the value of countC to CountP  and the highest pointer will be the item for which the count was more \\nand if the count of both the current pointer and the previous pointer are same then we check if the current highest is greater than the current item \\n(the problem says  If there is more than one integer with the maximum score, return the minimum of them.) so inorder to return the min we perform this check \\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} divisors\\n * @return {number}\\n */\\nvar maxDivScore = function(nums, d) {\\n    \\nlet countP = 0 ;\\n        let countC = 0 ;\\n        let highest = 0;\\n\\n        for(let i = 0 ; i < d.length ; i++)\\n            {\\n                let item = d[i];\\n                countC = 0 ;\\n                \\n\\n                for(let j = 0 ; j < nums.length ; j++)\\n                    {\\n                        if( nums[j] % item === 0 )\\n                        {\\n                            countC++;\\n                        }\\n                    }\\n\\n                if(countP < countC)\\n                {\\n                    countP = countC;\\n                    highest = item;\\n                }\\n                else if(countP === countC)\\n                {\\n                    if(highest > item )\\n                    {\\n                        highest = item ;\\n                    }\\n                }\\n            }\\n\\n// this check here means that if the counterP is 0 then we check the largest number on divisor array and return the highest\\n    if(!countP) return Math.min.apply(null,d);\\n    return highest;\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} divisors\\n * @return {number}\\n */\\nvar maxDivScore = function(nums, d) {\\n    \\nlet countP = 0 ;\\n        let countC = 0 ;\\n        let highest = 0;\\n\\n        for(let i = 0 ; i < d.length ; i++)\\n            {\\n                let item = d[i];\\n                countC = 0 ;\\n                \\n\\n                for(let j = 0 ; j < nums.length ; j++)\\n                    {\\n                        if( nums[j] % item === 0 )\\n                        {\\n                            countC++;\\n                        }\\n                    }\\n\\n                if(countP < countC)\\n                {\\n                    countP = countC;\\n                    highest = item;\\n                }\\n                else if(countP === countC)\\n                {\\n                    if(highest > item )\\n                    {\\n                        highest = item ;\\n                    }\\n                }\\n            }\\n\\n// this check here means that if the counterP is 0 then we check the largest number on divisor array and return the highest\\n    if(!countP) return Math.min.apply(null,d);\\n    return highest;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3443168,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int maxi = Integer.MIN_VALUE;\\n        int element = -1;\\n        for(int i = 0; i < divisors.length; i++)\\n        {\\n            int count = 0;\\n            for(int j = 0; j < nums.length; j++)\\n            {\\n                if(nums[j] % divisors[i] == 0)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count > maxi)\\n            {\\n                maxi = count;\\n                element = divisors[i];\\n            }\\n            else if(count == maxi)\\n            {\\n                element = Math.min(element, divisors[i]);\\n            }\\n        }\\n        return element;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int maxi = Integer.MIN_VALUE;\\n        int element = -1;\\n        for(int i = 0; i < divisors.length; i++)\\n        {\\n            int count = 0;\\n            for(int j = 0; j < nums.length; j++)\\n            {\\n                if(nums[j] % divisors[i] == 0)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count > maxi)\\n            {\\n                maxi = count;\\n                element = divisors[i];\\n            }\\n            else if(count == maxi)\\n            {\\n                element = Math.min(element, divisors[i]);\\n            }\\n        }\\n        return element;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442081,
                "title": "c-simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        sort(divisors.begin(),divisors.end());\\n        int ans=divisors[0];\\n        int maxi=0;\\n        for(int i=0;i<divisors.size();i++){\\n            int cnt=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%divisors[i]==0){\\n                    cnt++;\\n                }\\n            }\\n            if(cnt>maxi){\\n                ans=divisors[i];\\n                maxi=cnt;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        sort(divisors.begin(),divisors.end());\\n        int ans=divisors[0];\\n        int maxi=0;\\n        for(int i=0;i<divisors.size();i++){\\n            int cnt=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%divisors[i]==0){\\n                    cnt++;\\n                }\\n            }\\n            if(cnt>maxi){\\n                ans=divisors[i];\\n                maxi=cnt;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442024,
                "title": "c-478-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(const vector<int>& nums, const vector<int>& divisors) {\\n        unordered_set<int> unique_divisors;\\n        for(auto divisor : divisors) unique_divisors.insert(divisor);\\n\\n        int result = divisors[0], max_count = 0;\\n        for(auto divisor : unique_divisors) {\\n            int count = 0;\\n            for(auto num : nums) {\\n                if(num % divisor == 0) ++count;\\n            }\\n            if(max_count < count or max_count == count and divisor < result) {\\n                max_count = count;\\n                result = divisor;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(const vector<int>& nums, const vector<int>& divisors) {\\n        unordered_set<int> unique_divisors;\\n        for(auto divisor : divisors) unique_divisors.insert(divisor);\\n\\n        int result = divisors[0], max_count = 0;\\n        for(auto divisor : unique_divisors) {\\n            int count = 0;\\n            for(auto num : nums) {\\n                if(num % divisor == 0) ++count;\\n            }\\n            if(max_count < count or max_count == count and divisor < result) {\\n                max_count = count;\\n                result = divisor;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3441701,
                "title": "easy-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} divisors\\n * @return {number}\\n */\\nvar maxDivScore = function(nums, divisors) {\\n    let res = divisors[0];\\n    let count =0;\\n    let max = 0;\\n    for(let a of divisors){\\n        for(let b of nums){\\n            if(b%a==0){\\n                count++;\\n            }\\n        }\\n        if(count>max){\\n            max=count;\\n            res = a;\\n        }else if(count===max){\\n            if(res>a){\\n                res=a;\\n            }\\n        }\\n        count=0;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} divisors\\n * @return {number}\\n */\\nvar maxDivScore = function(nums, divisors) {\\n    let res = divisors[0];\\n    let count =0;\\n    let max = 0;\\n    for(let a of divisors){\\n        for(let b of nums){\\n            if(b%a==0){\\n                count++;\\n            }\\n        }\\n        if(count>max){\\n            max=count;\\n            res = a;\\n        }else if(count===max){\\n            if(res>a){\\n                res=a;\\n            }\\n        }\\n        count=0;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3441634,
                "title": "python-easy-begginers",
                "content": "**maximum divisor with lowest value when two or more have same score**\\n\\n```\\n\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        c=0\\n        val=0\\n        ele =0\\n        divisors =sorted(divisors, reverse = True)\\n        for n in divisors:\\n            c=0\\n            for i in nums:\\n                if i%n==0:\\n                    c+=1\\n            \\n            if val<=c:\\n                val = c\\n                ele = n\\n \\xA0 \\xA0 \\xA0 \\xA0return ele\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        c=0\\n        val=0\\n        ele =0\\n        divisors =sorted(divisors, reverse = True)\\n        for n in divisors:\\n            c=0\\n            for i in nums:\\n                if i%n==0:\\n                    c+=1\\n            \\n            if val<=c:\\n                val = c\\n                ele = n\\n \\xA0 \\xA0 \\xA0 \\xA0return ele\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440624,
                "title": "c-plain-brute-force-99-space-427ms-30-space-29-6mb",
                "content": "Without any more specific domain knowledge, in particular about the commposition of `divisors` (how often we can get repeated ones or numbers that are GCDs of several others) any attempt of optimisation does not seem worth it, so let\\'s go for a crude, brutal BF here.\\n\\nWe will start by declaring three support variables:\\n* `res` is our usual accumulator variable;\\n* `maxScore` is the highest score seen so far, initially set to `-1` (ie: one less the actual minimum we can expect, that is `0`);\\n* `tmp` will store the temporary score of each divisor we will parse.\\n\\nWe will then loop for each `d` in `divisors` and:\\n* (re)set `tmp` to an initial value of `0`;\\n* for each element `n` in `nums`, we will:\\n    * check if `d` is a divisor of `n` (ie: `n % d == 0`);\\n    * increase `tmp` by `1` if so;\\n* if we have a first case, a new maximum (ie: `tmp > maxScore`), in which case we will:\\n    * update `maxScore` to be `tmp`;\\n    * update `res` to be `d`;\\n* if we have another score `tmp` equal to the previous maximum `maxScore`, we will just update `res` to be the minimum between its current value and `d`.\\n\\nOnce done, we can `return` `res` :)\\n\\n# Complexity\\n- Time complexity: $$O(d * n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int> &nums, vector<int> &divs) {\\n        // support variables\\n        int res, maxScore = -1, tmp;\\n        for (int d: divs) {\\n            // computing d\\'s score\\n            tmp = 0;\\n            for (int n: nums) tmp += n % d == 0;\\n            // case 1: new maxScore\\n            if (tmp > maxScore) {\\n                maxScore = tmp;\\n                res = d;\\n            }\\n            // case 2: same as maxScore\\n            else if (tmp == maxScore) res = min(res, d);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Number Theory"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int> &nums, vector<int> &divs) {\\n        // support variables\\n        int res, maxScore = -1, tmp;\\n        for (int d: divs) {\\n            // computing d\\'s score\\n            tmp = 0;\\n            for (int n: nums) tmp += n % d == 0;\\n            // case 1: new maxScore\\n            if (tmp > maxScore) {\\n                maxScore = tmp;\\n                res = d;\\n            }\\n            // case 2: same as maxScore\\n            else if (tmp == maxScore) res = min(res, d);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3439087,
                "title": "ultra-easy-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        ans = 0\\n        maxi =-1\\n        for i in divisors:\\n            count = 0\\n            for j in nums:\\n                if j%i==0:\\n                    count += 1\\n            if count ==maxi:\\n                ans = min(ans,i)\\n            elif count>maxi:\\n                maxi = count\\n                ans = i\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        ans = 0\\n        maxi =-1\\n        for i in divisors:\\n            count = 0\\n            for j in nums:\\n                if j%i==0:\\n                    count += 1\\n            if count ==maxi:\\n                ans = min(ans,i)\\n            elif count>maxi:\\n                maxi = count\\n                ans = i\\n        return ans\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1865215,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "tricky tricky"
                    },
                    {
                        "username": "victCh",
                        "content": "most difficult in this problem is to understansd \"If there is more than one integer with the maximum score, return the minimum of them.\""
                    },
                    {
                        "username": "Dizzy099",
                        "content": "finally solved it by brute force , please someone explain optimized way"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don\\'t think there is an optimized way. That\\'s why it\\'s an easy problem, because the expected answer is just the brute force approach"
                    },
                    {
                        "username": "20311a0436",
                        "content": "Optimised approach other than brute force?"
                    },
                    {
                        "username": "bjhhar6475",
                        "content": "You can get significantly faster (10x ~400ms instead of 4000ms) performance if instead of iterating through nums, you through multiples of the divisor. Of course, stop once you exceed the max value in nums. Specifically, hash each number and given divisor like 6, check if 6, 12, ...  max(nums) is in nums. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was thinking there might be a way to avoid redundancies if some of the divisors divide each other... But checking for that already takes some time, and in the worst case anyway, divisors would all be prime numbers or something and there's no redundant information.\nIn the case where all numbers involved are primes, I don't think there's a better way to do it than brute force checking everything, because I don't see a good way to compress the information\n"
                    },
                    {
                        "username": "sooraj7",
                        "content": "At first the question seems to be confusing, but on grasping, it turns out to be pretty easy, just take care to return the smallest in case of conflict"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Look for optimization of your code !! \\nHash map can useful"
                    },
                    {
                        "username": "AsrielAries0704",
                        "content": "Done, but... 9500+ms :| brute force"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If anyone enjoys one-line solutions, I explain in great lenght one way to do it, to give beginners some syntaxic ideas to work with:\n[Check it out!](https://leetcode.com/problems/find-the-maximum-divisibility-score/solutions/3422676/python-one-liner-for-beginners/?orderBy=most_votes)"
                    }
                ]
            },
            {
                "id": 1899331,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "tricky tricky"
                    },
                    {
                        "username": "victCh",
                        "content": "most difficult in this problem is to understansd \"If there is more than one integer with the maximum score, return the minimum of them.\""
                    },
                    {
                        "username": "Dizzy099",
                        "content": "finally solved it by brute force , please someone explain optimized way"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don\\'t think there is an optimized way. That\\'s why it\\'s an easy problem, because the expected answer is just the brute force approach"
                    },
                    {
                        "username": "20311a0436",
                        "content": "Optimised approach other than brute force?"
                    },
                    {
                        "username": "bjhhar6475",
                        "content": "You can get significantly faster (10x ~400ms instead of 4000ms) performance if instead of iterating through nums, you through multiples of the divisor. Of course, stop once you exceed the max value in nums. Specifically, hash each number and given divisor like 6, check if 6, 12, ...  max(nums) is in nums. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was thinking there might be a way to avoid redundancies if some of the divisors divide each other... But checking for that already takes some time, and in the worst case anyway, divisors would all be prime numbers or something and there's no redundant information.\nIn the case where all numbers involved are primes, I don't think there's a better way to do it than brute force checking everything, because I don't see a good way to compress the information\n"
                    },
                    {
                        "username": "sooraj7",
                        "content": "At first the question seems to be confusing, but on grasping, it turns out to be pretty easy, just take care to return the smallest in case of conflict"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Look for optimization of your code !! \\nHash map can useful"
                    },
                    {
                        "username": "AsrielAries0704",
                        "content": "Done, but... 9500+ms :| brute force"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If anyone enjoys one-line solutions, I explain in great lenght one way to do it, to give beginners some syntaxic ideas to work with:\n[Check it out!](https://leetcode.com/problems/find-the-maximum-divisibility-score/solutions/3422676/python-one-liner-for-beginners/?orderBy=most_votes)"
                    }
                ]
            },
            {
                "id": 1865680,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "tricky tricky"
                    },
                    {
                        "username": "victCh",
                        "content": "most difficult in this problem is to understansd \"If there is more than one integer with the maximum score, return the minimum of them.\""
                    },
                    {
                        "username": "Dizzy099",
                        "content": "finally solved it by brute force , please someone explain optimized way"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don\\'t think there is an optimized way. That\\'s why it\\'s an easy problem, because the expected answer is just the brute force approach"
                    },
                    {
                        "username": "20311a0436",
                        "content": "Optimised approach other than brute force?"
                    },
                    {
                        "username": "bjhhar6475",
                        "content": "You can get significantly faster (10x ~400ms instead of 4000ms) performance if instead of iterating through nums, you through multiples of the divisor. Of course, stop once you exceed the max value in nums. Specifically, hash each number and given divisor like 6, check if 6, 12, ...  max(nums) is in nums. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was thinking there might be a way to avoid redundancies if some of the divisors divide each other... But checking for that already takes some time, and in the worst case anyway, divisors would all be prime numbers or something and there's no redundant information.\nIn the case where all numbers involved are primes, I don't think there's a better way to do it than brute force checking everything, because I don't see a good way to compress the information\n"
                    },
                    {
                        "username": "sooraj7",
                        "content": "At first the question seems to be confusing, but on grasping, it turns out to be pretty easy, just take care to return the smallest in case of conflict"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Look for optimization of your code !! \\nHash map can useful"
                    },
                    {
                        "username": "AsrielAries0704",
                        "content": "Done, but... 9500+ms :| brute force"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If anyone enjoys one-line solutions, I explain in great lenght one way to do it, to give beginners some syntaxic ideas to work with:\n[Check it out!](https://leetcode.com/problems/find-the-maximum-divisibility-score/solutions/3422676/python-one-liner-for-beginners/?orderBy=most_votes)"
                    }
                ]
            },
            {
                "id": 1864916,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "tricky tricky"
                    },
                    {
                        "username": "victCh",
                        "content": "most difficult in this problem is to understansd \"If there is more than one integer with the maximum score, return the minimum of them.\""
                    },
                    {
                        "username": "Dizzy099",
                        "content": "finally solved it by brute force , please someone explain optimized way"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don\\'t think there is an optimized way. That\\'s why it\\'s an easy problem, because the expected answer is just the brute force approach"
                    },
                    {
                        "username": "20311a0436",
                        "content": "Optimised approach other than brute force?"
                    },
                    {
                        "username": "bjhhar6475",
                        "content": "You can get significantly faster (10x ~400ms instead of 4000ms) performance if instead of iterating through nums, you through multiples of the divisor. Of course, stop once you exceed the max value in nums. Specifically, hash each number and given divisor like 6, check if 6, 12, ...  max(nums) is in nums. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was thinking there might be a way to avoid redundancies if some of the divisors divide each other... But checking for that already takes some time, and in the worst case anyway, divisors would all be prime numbers or something and there's no redundant information.\nIn the case where all numbers involved are primes, I don't think there's a better way to do it than brute force checking everything, because I don't see a good way to compress the information\n"
                    },
                    {
                        "username": "sooraj7",
                        "content": "At first the question seems to be confusing, but on grasping, it turns out to be pretty easy, just take care to return the smallest in case of conflict"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Look for optimization of your code !! \\nHash map can useful"
                    },
                    {
                        "username": "AsrielAries0704",
                        "content": "Done, but... 9500+ms :| brute force"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If anyone enjoys one-line solutions, I explain in great lenght one way to do it, to give beginners some syntaxic ideas to work with:\n[Check it out!](https://leetcode.com/problems/find-the-maximum-divisibility-score/solutions/3422676/python-one-liner-for-beginners/?orderBy=most_votes)"
                    }
                ]
            },
            {
                "id": 2045292,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "tricky tricky"
                    },
                    {
                        "username": "victCh",
                        "content": "most difficult in this problem is to understansd \"If there is more than one integer with the maximum score, return the minimum of them.\""
                    },
                    {
                        "username": "Dizzy099",
                        "content": "finally solved it by brute force , please someone explain optimized way"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don\\'t think there is an optimized way. That\\'s why it\\'s an easy problem, because the expected answer is just the brute force approach"
                    },
                    {
                        "username": "20311a0436",
                        "content": "Optimised approach other than brute force?"
                    },
                    {
                        "username": "bjhhar6475",
                        "content": "You can get significantly faster (10x ~400ms instead of 4000ms) performance if instead of iterating through nums, you through multiples of the divisor. Of course, stop once you exceed the max value in nums. Specifically, hash each number and given divisor like 6, check if 6, 12, ...  max(nums) is in nums. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was thinking there might be a way to avoid redundancies if some of the divisors divide each other... But checking for that already takes some time, and in the worst case anyway, divisors would all be prime numbers or something and there's no redundant information.\nIn the case where all numbers involved are primes, I don't think there's a better way to do it than brute force checking everything, because I don't see a good way to compress the information\n"
                    },
                    {
                        "username": "sooraj7",
                        "content": "At first the question seems to be confusing, but on grasping, it turns out to be pretty easy, just take care to return the smallest in case of conflict"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Look for optimization of your code !! \\nHash map can useful"
                    },
                    {
                        "username": "AsrielAries0704",
                        "content": "Done, but... 9500+ms :| brute force"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If anyone enjoys one-line solutions, I explain in great lenght one way to do it, to give beginners some syntaxic ideas to work with:\n[Check it out!](https://leetcode.com/problems/find-the-maximum-divisibility-score/solutions/3422676/python-one-liner-for-beginners/?orderBy=most_votes)"
                    }
                ]
            },
            {
                "id": 1938388,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "tricky tricky"
                    },
                    {
                        "username": "victCh",
                        "content": "most difficult in this problem is to understansd \"If there is more than one integer with the maximum score, return the minimum of them.\""
                    },
                    {
                        "username": "Dizzy099",
                        "content": "finally solved it by brute force , please someone explain optimized way"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don\\'t think there is an optimized way. That\\'s why it\\'s an easy problem, because the expected answer is just the brute force approach"
                    },
                    {
                        "username": "20311a0436",
                        "content": "Optimised approach other than brute force?"
                    },
                    {
                        "username": "bjhhar6475",
                        "content": "You can get significantly faster (10x ~400ms instead of 4000ms) performance if instead of iterating through nums, you through multiples of the divisor. Of course, stop once you exceed the max value in nums. Specifically, hash each number and given divisor like 6, check if 6, 12, ...  max(nums) is in nums. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was thinking there might be a way to avoid redundancies if some of the divisors divide each other... But checking for that already takes some time, and in the worst case anyway, divisors would all be prime numbers or something and there's no redundant information.\nIn the case where all numbers involved are primes, I don't think there's a better way to do it than brute force checking everything, because I don't see a good way to compress the information\n"
                    },
                    {
                        "username": "sooraj7",
                        "content": "At first the question seems to be confusing, but on grasping, it turns out to be pretty easy, just take care to return the smallest in case of conflict"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Look for optimization of your code !! \\nHash map can useful"
                    },
                    {
                        "username": "AsrielAries0704",
                        "content": "Done, but... 9500+ms :| brute force"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If anyone enjoys one-line solutions, I explain in great lenght one way to do it, to give beginners some syntaxic ideas to work with:\n[Check it out!](https://leetcode.com/problems/find-the-maximum-divisibility-score/solutions/3422676/python-one-liner-for-beginners/?orderBy=most_votes)"
                    }
                ]
            },
            {
                "id": 1867685,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "tricky tricky"
                    },
                    {
                        "username": "victCh",
                        "content": "most difficult in this problem is to understansd \"If there is more than one integer with the maximum score, return the minimum of them.\""
                    },
                    {
                        "username": "Dizzy099",
                        "content": "finally solved it by brute force , please someone explain optimized way"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don\\'t think there is an optimized way. That\\'s why it\\'s an easy problem, because the expected answer is just the brute force approach"
                    },
                    {
                        "username": "20311a0436",
                        "content": "Optimised approach other than brute force?"
                    },
                    {
                        "username": "bjhhar6475",
                        "content": "You can get significantly faster (10x ~400ms instead of 4000ms) performance if instead of iterating through nums, you through multiples of the divisor. Of course, stop once you exceed the max value in nums. Specifically, hash each number and given divisor like 6, check if 6, 12, ...  max(nums) is in nums. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was thinking there might be a way to avoid redundancies if some of the divisors divide each other... But checking for that already takes some time, and in the worst case anyway, divisors would all be prime numbers or something and there's no redundant information.\nIn the case where all numbers involved are primes, I don't think there's a better way to do it than brute force checking everything, because I don't see a good way to compress the information\n"
                    },
                    {
                        "username": "sooraj7",
                        "content": "At first the question seems to be confusing, but on grasping, it turns out to be pretty easy, just take care to return the smallest in case of conflict"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Look for optimization of your code !! \\nHash map can useful"
                    },
                    {
                        "username": "AsrielAries0704",
                        "content": "Done, but... 9500+ms :| brute force"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If anyone enjoys one-line solutions, I explain in great lenght one way to do it, to give beginners some syntaxic ideas to work with:\n[Check it out!](https://leetcode.com/problems/find-the-maximum-divisibility-score/solutions/3422676/python-one-liner-for-beginners/?orderBy=most_votes)"
                    }
                ]
            },
            {
                "id": 1865190,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "tricky tricky"
                    },
                    {
                        "username": "victCh",
                        "content": "most difficult in this problem is to understansd \"If there is more than one integer with the maximum score, return the minimum of them.\""
                    },
                    {
                        "username": "Dizzy099",
                        "content": "finally solved it by brute force , please someone explain optimized way"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don\\'t think there is an optimized way. That\\'s why it\\'s an easy problem, because the expected answer is just the brute force approach"
                    },
                    {
                        "username": "20311a0436",
                        "content": "Optimised approach other than brute force?"
                    },
                    {
                        "username": "bjhhar6475",
                        "content": "You can get significantly faster (10x ~400ms instead of 4000ms) performance if instead of iterating through nums, you through multiples of the divisor. Of course, stop once you exceed the max value in nums. Specifically, hash each number and given divisor like 6, check if 6, 12, ...  max(nums) is in nums. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was thinking there might be a way to avoid redundancies if some of the divisors divide each other... But checking for that already takes some time, and in the worst case anyway, divisors would all be prime numbers or something and there's no redundant information.\nIn the case where all numbers involved are primes, I don't think there's a better way to do it than brute force checking everything, because I don't see a good way to compress the information\n"
                    },
                    {
                        "username": "sooraj7",
                        "content": "At first the question seems to be confusing, but on grasping, it turns out to be pretty easy, just take care to return the smallest in case of conflict"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Look for optimization of your code !! \\nHash map can useful"
                    },
                    {
                        "username": "AsrielAries0704",
                        "content": "Done, but... 9500+ms :| brute force"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If anyone enjoys one-line solutions, I explain in great lenght one way to do it, to give beginners some syntaxic ideas to work with:\n[Check it out!](https://leetcode.com/problems/find-the-maximum-divisibility-score/solutions/3422676/python-one-liner-for-beginners/?orderBy=most_votes)"
                    }
                ]
            }
        ]
    }
]