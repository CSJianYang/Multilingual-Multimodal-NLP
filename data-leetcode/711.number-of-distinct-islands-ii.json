[
    {
        "title": "Maximal Square",
        "question_content": "Given an m x n binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.\n&nbsp;\nExample 1:\n\nInput: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\nOutput: 4\n\nExample 2:\n\nInput: matrix = [[\"0\",\"1\"],[\"1\",\"0\"]]\nOutput: 1\n\nExample 3:\n\nInput: matrix = [[\"0\"]]\nOutput: 0\n\n&nbsp;\nConstraints:\n\n\tm == matrix.length\n\tn == matrix[i].length\n\t1 <= m, n <= 300\n\tmatrix[i][j] is '0' or '1'.",
        "solutions": [
            {
                "id": 600149,
                "title": "python-thinking-process-diagrams-dp-approach",
                "content": "**Understanding basics**\\n![image](https://assets.leetcode.com/users/arkaung/image_1587997244.png)\\n\\n* Here I want to mention that we are drawing squares from top left corner to bottom right corner. Therefore, when I mention, \"surrounding elements\", I am saying cells above the corner cell and the cells on the left of the corner cell.\\n\\n**Building DP grid to memoize**\\n* We are going to create a `dp` grid with initial values of 0.\\n* We are going to update `dp` as described in the following figure. \\n\\n![image](https://assets.leetcode.com/users/arkaung/image_1587997873.png)\\n\\n**Bigger Example**\\n* Let\\'s try to see a bigger example.\\n* We go over one cell at a time row by row in the `matrix` and then update our `dp` grid accordingly. \\n* Update `max_side` with the maximum `dp` cell value as you update.\\n\\n![image](https://assets.leetcode.com/users/arkaung/image_1588005144.png)\\n\\n\\n\\nIn the code, I create a `dp` grid which has one additional column and one additional row. The reason is to facilitate the index dp[r-1][c] dp[r][c-1] and dp[r-1][c-1] for cells in first row and first column in `matrix`.\\n\\n``` python\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        if matrix is None or len(matrix) < 1:\\n            return 0\\n        \\n        rows = len(matrix)\\n        cols = len(matrix[0])\\n        \\n        dp = [[0]*(cols+1) for _ in range(rows+1)]\\n        max_side = 0\\n        \\n        for r in range(rows):\\n            for c in range(cols):\\n                if matrix[r][c] == \\'1\\':\\n                    dp[r+1][c+1] = min(dp[r][c], dp[r+1][c], dp[r][c+1]) + 1 # Be careful of the indexing since dp grid has additional row and column\\n                    max_side = max(max_side, dp[r+1][c+1])\\n                \\n        return max_side * max_side\\n                \\n```\\n\\n**Complexity Analysis**\\n\\nTime complexity : `O(mn)`. Single pass - `row x col (m=row; n=col)`\\nSpace complexity : `O(mn)`. Additional space for `dp` grid (don\\'t need to worry about additional 1 row and col).\\n\\n**Follow up**\\nSpace can be optimized as we don\\'t need to keep the whole `dp` grid as we progress down the rows in `matrix`.\\n\\nAren\\'t Dynamic Programming problems much like this joke? :D\\n![image](https://assets.leetcode.com/users/arkaung/image_1587998641.png)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "``` python\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        if matrix is None or len(matrix) < 1:\\n            return 0\\n        \\n        rows = len(matrix)\\n        cols = len(matrix[0])\\n        \\n        dp = [[0]*(cols+1) for _ in range(rows+1)]\\n        max_side = 0\\n        \\n        for r in range(rows):\\n            for c in range(cols):\\n                if matrix[r][c] == \\'1\\':\\n                    dp[r+1][c+1] = min(dp[r][c], dp[r+1][c], dp[r][c+1]) + 1 # Be careful of the indexing since dp grid has additional row and column\\n                    max_side = max(max_side, dp[r+1][c+1])\\n                \\n        return max_side * max_side\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 61803,
                "title": "c-space-optimized-dp",
                "content": "To appy DP, we define the state as the maximal **size** (square = size * size) of the square that can be formed till point `(i, j)`, denoted as `dp[i][j]`.\\n\\nFor the topmost row (`i = 0`) and the leftmost column (`j = 0`), we have `dp[i][j] = matrix[i][j] - \\'0\\'`, meaning that it can at most form a square of size 1 when the matrix has a `\\'1\\'` in that cell.\\n\\nWhen `i > 0` and `j > 0`, if `matrix[i][j] = \\'0\\'`, then `dp[i][j] = 0` since no square will be able to contain the `\\'0\\'` at that cell. If `matrix[i][j] = \\'1\\'`, we will have `dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1`, which means that the square will be limited by its left, upper and upper-left neighbors.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        if (matrix.empty()) {\\n            return 0;\\n        }\\n        int m = matrix.size(), n = matrix[0].size(), sz = 0;\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (!i || !j || matrix[i][j] == \\'0\\') {\\n                    dp[i][j] = matrix[i][j] - \\'0\\';\\n                } else {\\n                    dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1;\\n                }\\n                sz = max(dp[i][j], sz);\\n            }\\n        }\\n        return sz * sz;\\n    }\\n};\\n```\\n\\nIn the above code, it uses `O(mn)` space. Actually each time when we update `dp[i][j]`, we only need `dp[i-1][j-1]`, `dp[i-1][j]` (the previous row) and `dp[i][j-1]` (the current row). So we may just keep two rows.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        if (matrix.empty()) {\\n            return 0;\\n        }\\n        int m = matrix.size(), n = matrix[0].size(), sz = 0;\\n        vector<int> pre(n, 0), cur(n, 0);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (!i || !j || matrix[i][j] == \\'0\\') {\\n                    cur[j] = matrix[i][j] - \\'0\\';\\n                } else {\\n                    cur[j] = min(pre[j - 1], min(pre[j], cur[j - 1])) + 1;\\n                }\\n                sz = max(cur[j], sz);\\n            }\\n            fill(pre.begin(), pre.end(), 0);\\n            swap(pre, cur);\\n        }\\n        return sz * sz;\\n    }\\n};\\n```\\n\\nFurthermore, we may only use just one `vector` (thanks to @stellari for sharing the idea).\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        if (matrix.empty()) {\\n            return 0;\\n        }\\n        int m = matrix.size(), n = matrix[0].size(), sz = 0, pre;\\n        vector<int> cur(n, 0);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int temp = cur[j];\\n                if (!i || !j || matrix[i][j] == \\'0\\') {\\n                    cur[j] = matrix[i][j] - \\'0\\';\\n                } else {\\n                    cur[j] = min(pre, min(cur[j], cur[j - 1])) + 1;\\n                }\\n                sz = max(cur[j], sz);\\n                pre = temp;\\n            }\\n        }\\n        return sz * sz;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        if (matrix.empty()) {\\n            return 0;\\n        }\\n        int m = matrix.size(), n = matrix[0].size(), sz = 0;\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (!i || !j || matrix[i][j] == \\'0\\') {\\n                    dp[i][j] = matrix[i][j] - \\'0\\';\\n                } else {\\n                    dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1;\\n                }\\n                sz = max(dp[i][j], sz);\\n            }\\n        }\\n        return sz * sz;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        if (matrix.empty()) {\\n            return 0;\\n        }\\n        int m = matrix.size(), n = matrix[0].size(), sz = 0;\\n        vector<int> pre(n, 0), cur(n, 0);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (!i || !j || matrix[i][j] == \\'0\\') {\\n                    cur[j] = matrix[i][j] - \\'0\\';\\n                } else {\\n                    cur[j] = min(pre[j - 1], min(pre[j], cur[j - 1])) + 1;\\n                }\\n                sz = max(cur[j], sz);\\n            }\\n            fill(pre.begin(), pre.end(), 0);\\n            swap(pre, cur);\\n        }\\n        return sz * sz;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        if (matrix.empty()) {\\n            return 0;\\n        }\\n        int m = matrix.size(), n = matrix[0].size(), sz = 0, pre;\\n        vector<int> cur(n, 0);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int temp = cur[j];\\n                if (!i || !j || matrix[i][j] == \\'0\\') {\\n                    cur[j] = matrix[i][j] - \\'0\\';\\n                } else {\\n                    cur[j] = min(pre, min(cur[j], cur[j - 1])) + 1;\\n                }\\n                sz = max(cur[j], sz);\\n                pre = temp;\\n            }\\n        }\\n        return sz * sz;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61802,
                "title": "extremely-simple-java-solution",
                "content": "    public int maximalSquare(char[][] a) {\\n        if(a.length == 0) return 0;\\n        int m = a.length, n = a[0].length, result = 0;\\n        int[][] b = new int[m+1][n+1];\\n        for (int i = 1 ; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if(a[i-1][j-1] == '1') {\\n                    b[i][j] = Math.min(Math.min(b[i][j-1] , b[i-1][j-1]), b[i-1][j]) + 1;\\n                    result = Math.max(b[i][j], result); // update result\\n                }\\n            }\\n        }\\n        return result*result;\\n    }",
                "solutionTags": [],
                "code": "    public int maximalSquare(char[][] a) {\\n        if(a.length == 0) return 0;\\n        int m = a.length, n = a[0].length, result = 0;\\n        int[][] b = new int[m+1][n+1];\\n        for (int i = 1 ; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if(a[i-1][j-1] == '1') {\\n                    b[i][j] = Math.min(Math.min(b[i][j-1] , b[i-1][j-1]), b[i-1][j]) + 1;\\n                    result = Math.max(b[i][j], result); // update result\\n                }\\n            }\\n        }\\n        return result*result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1632376,
                "title": "c-python-6-simple-solution-w-explanation-optimizations-from-brute-force-to-dp",
                "content": "We are given a `mxn` matrix filled with `0` / `1` and we need to return the area of largest square consisting of all `1`s\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (Brute-Force)***\\n\\nTo start with brute-force approach, we can simply consider each possible starting cell (`row`, `col`) and side length (`sideLen`) of square starting at that cell. For each cell and `sideLen`, we will check if the corresponding square inside the matrix is valid or not (i.e, all cells are `\"1\"` or not). After checking each possible squares, we will return the one with maximum area.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& M) {\\n        auto isValidSquare = [&](int i, int j, int side) {\\n            return all_of(begin(M)+i, begin(M)+i+side, [&](auto& R){\\n                return all_of(begin(R)+j, begin(R)+j+side, [&](auto cell) { return cell == \\'1\\'; });\\n            });\\n        };\\n        int m = size(M), n = size(M[0]), ans = 0;\\n        for(int row = 0; row < m; row++)\\n            for(int col = 0; col < n; col++)\\n                for(int sideLen = 1; sideLen <= min(m-row, n-col); sideLen++) \\n                    if(isValidSquare(row, col, sideLen))\\n                        ans = ans = max(ans, sideLen*sideLen);\\n        return ans;\\n    }\\n};\\n```\\n\\nWe can slightly optimize the code by running from `sideLen = min(m, n)` down to `1` instead of the other way around. This ensures that we can return the area of sqaure as soon as we find the 1st valid square since that square would be the 1st valid square of maximum side length.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& M) {\\n        auto isValidSquare = [&](int i, int j, int side) {\\n            return all_of(begin(M)+i, begin(M)+i+side, [&](auto& R){\\n                return all_of(begin(R)+j, begin(R)+j+side, [&](auto cell) { return cell == \\'1\\'; });\\n            });\\n        };\\n        int m = size(M), n = size(M[0]);\\n        for(int sideLen = min(m, n); sideLen; sideLen--)\\n            for(int row = 0; row <= m-sideLen; row++)\\n                for(int col = 0; col <= n-sideLen; col++)\\n                    if(isValidSquare(row, col, sideLen))\\n                        return sideLen*sideLen;\\n        return 0;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def maximalSquare(self, M):\\n        def is_valid_sqaure(row, col, side):\\n            return all(all(M[i][j] == \\'1\\' for j in range(col, col+side)) for i in range(row, row+side))\\n        m, n = len(M), len(M[0])\\n        for side_len in range(min(m,n), 0, -1):\\n            for row in range(m - side_len + 1):\\n                for col in range(n - side_len + 1):\\n                    if is_valid_sqaure(row, col, side_len):\\n                        return side_len**2\\n        return 0\\n```\\n\\n***Time Complexity :*** <code>O(M\\\\*N*min(M,N)<sup>3</sup>)</code>\\n***Space Complexity :*** `O(1)`, only constant extra space is being used\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Optimized Brute-Force)***\\n\\nInstead of checking each possible side length for a square starting at a given cell, we can optimze the process by starting from `row` of that cell and expanding the side length for that row till it is possible. We will continue this for below rows as well, till consecutive ones found along rows (denoted by `allOnesRowLen`) > current row number. \\n\\nThe process is similar to the one shown in below diagram which I had used in my post for [85. Maximal Rectangle](https://leetcode.com/problems/maximal-rectangle/discuss/1604254/C%2B%2B-Simple-Solution-w-Explanation-or-Optimizations-from-Brute-Force-to-DP) with only change that we stop further iteration as soon as `allOnesRowLen` exceeds current row number (because we need to form square in this case & max possible side length is already know by now).\\n\\n<p align=middle>\\n  <img src=\"https://assets.leetcode.com/users/images/6a6c48d6-32be-4a61-8408-309b3217cb3c_1638279969.659467.png\" alt=\"Trulli\" width=600 />\\n  <p align=middle><i>Taken From  <b> <a href=\"https://leetcode.com/problems/maximal-rectangle/discuss/1604254/C%2B%2B-Simple-Solution-w-Explanation-or-Optimizations-from-Brute-Force-to-DP\" >&nbsp;85. Maximal Rectangle</a></b></i></p>\\n</p>\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int getMaxSquareLen(vector<vector<char>>& M, int row, int col) {\\n        int allOnesRowLen = min(size(M)-row, size(M[0])-col), sqLen = 0;\\n        for(int i = 0, j; i < allOnesRowLen; i++) {\\n            for(j = 0; j < allOnesRowLen && M[i+row][j+col] != \\'0\\'; j++);\\n            allOnesRowLen = j;\\n            sqLen = min(allOnesRowLen, i+1);\\n        }\\n        return sqLen;\\n    }\\n    int maximalSquare(vector<vector<char>>& M) {\\n        int m = size(M), n = size(M[0]), ans = 0;\\n        for(int row = 0; row < m; row++)\\n            for(int col = 0; col < n; col++) \\n                ans = max(ans, getMaxSquareLen(M, row, col));\\n        return ans * ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def maximalSquare(self, M):\\n        m, n, ans = len(M), len(M[0]), 0\\n        def get_max_square_len(row, col):\\n            all_ones_row_len, sq_len, i, j = min(m-row, n-col), 0, 0, 0\\n            while i < all_ones_row_len:\\n                j = 0\\n                while j < all_ones_row_len and M[i+row][j+col] != \\'0\\': \\n                    j += 1\\n                all_ones_row_len = j\\n                sq_len = min(all_ones_row_len, i := i + 1)\\n            return sq_len\\n        \\n        for row in range(m):\\n            for col in range(n):\\n                ans = max(ans, get_max_square_len(row, col))\\n        return ans * ans\\n```\\n\\n\\n***Time Complexity :*** <code>O(MN*min(M,N)<sup>2</sup>)</code>\\n***Space Complexity :*** `O(1)`\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Pre-processing / Dynamic Programming)***\\n\\nIn the previous approach, for computing the maximum square length that can be forme starting at `(row, col)` cell, we were iteratively calculating maximum consecutive ones in a given row (`allOnesRowLen`). This was done multiple times for each cell of the matrix. \\n\\nBut this can be optimized if we pre-compute the number of consecutive ones to the right for every cell. The following solution uses `ones` matrix where `ones[i][j]` denotes number of consecutive ones to the right of the `(i, j)` cell. \\n\\nNote that we could have also computed number of consecutive ones to the left or even number of consecutive ones to the top/bottom and modified the other code accordingly. It\\'s just based on how you model the problem.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int getMaxSquareLen(vector<vector<char>>& M, vector<vector<int>>& ones, int row, int col) {\\n        int allOnesRowLen = min(size(M)-row, size(M[0])-col), sqLen = 0;\\n        for(int i = 0, j; i < allOnesRowLen; i++) \\n            allOnesRowLen = min(allOnesRowLen, ones[i+row][col]),\\n            sqLen = min(allOnesRowLen, i+1);\\n        return sqLen;\\n    }\\n    int maximalSquare(vector<vector<char>>& M) {\\n        int m = size(M), n = size(M[0]), ans = 0;\\n        vector<vector<int>> ones(m, vector<int>(n+1));\\n        for(int i = m-1; ~i; i--)\\n            for(int j = n-1; ~j; j--)\\n                ones[i][j] = (M[i][j] == \\'1\\' ? 1 + ones[i][j+1] : 0);\\n        \\n        for(int row = 0; row < m; row++)\\n            for(int col = 0; col < n; col++) \\n                ans = max(ans, getMaxSquareLen(M, ones, row, col));\\n        return ans * ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def maximalSquare(self, M):\\n        m, n, ans = len(M), len(M[0]), 0\\n        ones = [[0]*(n+1) for i in range(m)]\\n        for i in range(m-1,-1,-1):\\n            for j in range(n-1,-1,-1):\\n                ones[i][j] = 1 + ones[i][j+1] if M[i][j] == \\'1\\' else 0\\n        \\n        def get_max_square_len(row, col):\\n            all_ones_row_len, sq_len, i, j = min(m-row, n-col), 0, 0, 0\\n            while i < all_ones_row_len:                \\n                all_ones_row_len = min(all_ones_row_len, ones[i+row][col])\\n                sq_len = min(all_ones_row_len, i := i + 1)\\n            return sq_len\\n        \\n        for row in range(m):\\n            for col in range(n):\\n                ans = max(ans, get_max_square_len(row, col))\\n        return ans * ans\\n```\\n\\n***Time Complexity :*** <code>O(MN*min(M,N))</code>\\n***Space Complexity :*** `O(1)`\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (Dynamic Programming)***\\n\\nWe pre-processed the number of consecutive ones in the previous approach. For each cell, that allowed us to eliminate search over columns for consecutive ones, but we still had to iterate over the rows to find number of consecutive ones for each row & thus we found maximum square\\'s side length starting at each cell.\\n\\nWe cannot simply precompute consecutive ones as well along each column. This may give us number of consecutive ones starting at `row` and `col` for a given cell, but we wouldnt be sure if every cell in the square thus formed will all be 1 as well.\\n\\n**So can we eliminate the need of search over rows?**\\n\\nEliminating this search would mean that we need to determine largest square starting at current cell by extending it from previous computations. As explained above, we cant only consider the consecutive ones along a row and column since we dont know if every other cell of square formed will also be `1`. This means that to know the max square length at a given cell `(row, col)`, we will also require to know if every cell in the subsquare (`row+1`, `col+1`) is also one. This directly means that we need to know the side length of square starting at cell `(row+1, col+1)`.\\n\\nSo, we can start from the last cells `(m, n)` of the given grid and iterate back till `(0, 0)` computing the side length of sqaure for each cell along the way. Since the length of side of square for current cell is determined by previous computations, this means we will be using **dynamic programming**.\\n\\nWe precompute `onesRow` and `onesCol` which give us the consecutive number of 1s starting at each cell (this is similar to `ones` computed previously). Then, we also use a `dp` matrix, where `dp[i][j]` denotes the maximum length of square starting at cell `(i, j)`. The current state can be computed using the state transition -\\n1. `dp[i][j] = 0`, if `M[i][j] == \\'0\\'`, since no square can be formed if current cell itself is `\\'0\\'`\\n2. `dp[i][j] = 1 + min(onesRow[i][j]-1, onesCol[i][j]-1, dp[i+1][j+1])`, if `M[i][j] == \\'1\\'`\\n\\nThe 2nd transition denotes that current cell is `\\'1\\'` so side length is atleast 1. On top of that, we will consider minimum amongst the number of consecutive ones along current row `i`, consecutive ones along current column `j` (`-1` in both case because we dont want to count current cell twice), and maximum valid square starting at `(i+1, j+1)`. This will give us the length of side of maximum square ensuring cells within it are all `\\'1\\'`.\\n\\nAfter we get side length of square at current cell, we can compute its area and finally return the maximum among all such areas found in the grid.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& M) {\\n        int m = size(M), n = size(M[0]), ans = 0;\\n        vector<vector<int>> dp(m+1, vector<int>(n+1)), onesRow(dp), onesCol(dp);\\n        for(int i = m-1; ~i; i--)\\n            for(int j = n-1; ~j; j--)\\n                onesRow[i][j] = (M[i][j] == \\'1\\' ? 1 + onesRow[i][j+1] : 0),\\n                onesCol[i][j] = (M[i][j] == \\'1\\' ? 1 + onesCol[i+1][j] : 0);\\n        \\n        for(int i = m-1; ~i; i--)\\n            for(int j = n-1; ~j; j--) \\n                dp[i][j] = (M[i][j] == \\'1\\' ? 1 + min({onesRow[i][j]-1, onesCol[i][j]-1, dp[i+1][j+1]}) : 0),\\n                ans = max(ans, dp[i][j]);\\n\\n        return ans * ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def maximalSquare(self, M):\\n        m, n, ans = len(M), len(M[0]), 0\\n        dp, onesRow, onesCol = ([[0]*(n+1) for i in range(m+1)] for cnt in range(3))\\n\\n        for i, j in product(range(m-1, -1, -1), range(n-1, -1, -1)):\\n            onesRow[i][j] = 1 + onesRow[i][j+1] if M[i][j] == \\'1\\' else 0\\n            onesCol[i][j] = 1 + onesCol[i+1][j] if M[i][j] == \\'1\\' else 0\\n            \\n        for i, j in product(range(m-1, -1, -1), range(n-1, -1, -1)):\\n            dp[i][j] = 1 + min(onesRow[i][j]-1, onesCol[i][j]-1, dp[i+1][j+1]) if M[i][j] == \\'1\\' else 0\\n            ans = max(ans, dp[i][j])\\n        return ans * ans\\n\\n```\\n\\nThe above solution can be futher optimized if we see that we don\\'t really need to separately maintain `onesRow` and `onesCol`. We can get those values from `dp` as well, more specifically from `dp[i+1][j]` and `dp[i][j+1]`. \\nRecall that we denoted `dp[i][j]` as maximum length of square starting at cell `(i, j)` which means they wont hold exact values of `onesRow` and `onesCol` (value maybe less in some cases) but it wont matter since we are taking minimum amongst the three anyway. (which means even if value in `onesRow / onesCol` was higher, we would have considered it if it wasnt forming a square).\\n\\nThus, the above solution is optimized as -\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& M) {\\n        int m = size(M), n = size(M[0]), ans = 0;\\n        vector<vector<int>> dp(m+1, vector<int>(n+1));\\n        for(int i = m-1; ~i; i--)\\n            for(int j = n-1; ~j; j--) \\n                dp[i][j] = (M[i][j] == \\'1\\' ? 1 + min({dp[i+1][j], dp[i][j+1], dp[i+1][j+1]}) : 0),\\n                ans = max(ans, dp[i][j]);\\n\\n        return ans * ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def maximalSquare(self, M):\\n        m, n, ans = len(M), len(M[0]), 0\\n        dp = [[0]*(n+1) for i in range(m+1)]\\n        \\n        for i, j in product(range(m-1, -1, -1), range(n-1, -1, -1)):\\n            dp[i][j] = 1 + min(dp[i+1][j], dp[i][j+1], dp[i+1][j+1]) if M[i][j] == \\'1\\' else 0\\n            ans = max(ans, dp[i][j])\\n        return ans * ans\\n```\\n\\n***Time Complexity :*** <code>O(MN)</code>\\n***Space Complexity :*** `O(MN)`\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - V (Space-Optimized Dynamic Programming)***\\n\\nWe can see that we are only ever accessing the current row and next row of `dp`. Thus we dont need to store every row of it and can do away with only storing two rows. \\n\\nA common and easy way to convert 2D dp to linear space usage is by defining 2 rows in `dp` and alternating between those rows for each computation. This basically ensures we are using previous computed row to compute the current row and we dont even need to change the previous solution by much. We can simply alternate between rows using the mod 2(`%2`) or AND 1 (`& 1`) operations.\\n\\nThus, we can optmize on space as below -\\n\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& M) {\\n        int m = size(M), n = size(M[0]), ans = 0;\\n        vector<vector<int>> dp(2, vector<int>(n+1));\\n        for(int i = m-1; ~i; i--)\\n            for(int j = n-1; ~j; j--) \\n                dp[i&1][j] = (M[i][j] == \\'1\\' ? 1 + min({dp[(i+1)&1][j], dp[i&1][j+1], dp[(i+1)&1][j+1]}) : 0),\\n                ans = max(ans, dp[i&1][j]);\\n\\n        return ans * ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def maximalSquare(self, M):\\n        m, n, ans = len(M), len(M[0]), 0\\n        dp = [[0]*(n+1) for i in range(2)]\\n        \\n        for i, j in product(range(m-1, -1, -1), range(n-1, -1, -1)):\\n            dp[i&1][j] = 1 + min(dp[(i+1)&1][j], dp[i&1][j+1], dp[(i+1)&1][j+1]) if M[i][j] == \\'1\\' else 0\\n            ans = max(ans, dp[i&1][j])\\n        return ans * ans\\n\\n```\\n\\n\\n***Time Complexity :*** <code>O(MN)</code>\\n***Space Complexity :*** `O(N)`, this can be further optimized to `O(min(M, N))` as well.\\n\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - VI (Space-Optimized Dynamic Programming - Inline using input Matrix)***\\n\\nWe can further optimize the code if we use the input matrix itself as a `dp` matrix. This is possible if input is allowed to be modified (or you can use the same code by simply making a copy of input matrix). \\n\\nThis type of solution will most likely fail in some languages (such as C++/Java) on addition on newer test cases due to char overflow, but it can work in language like python.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& M) {\\n        int m = size(M), n = size(M[0]), ans = 0;        \\n        for(int i = m-1; ~i; i--)\\n            for(int j = n-1; ~j; j--) \\n                if(i == m-1 or j == n-1)\\n                    ans = max(ans, int(M[i][j] -= \\'0\\'));\\n                else\\n                    M[i][j] = (M[i][j] == \\'1\\' ? 1+min({M[i+1][j], M[i][j+1], M[i+1][j+1]}) : 0),\\n                    ans = max(ans, int(M[i][j]));\\n\\n        return ans * ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def maximalSquare(self, M):\\n        m, n, ans = len(M), len(M[0]), 0\\n        for i, j in product(range(m-1, -1, -1), range(n-1, -1, -1)):\\n            if i == m-1 or j == n-1:\\n                M[i][j] = int(M[i][j])\\n                ans = max(ans, M[i][j])\\n            else:\\n                M[i][j] = 1 + min(M[i+1][j], M[i][j+1], M[i+1][j+1]) if M[i][j] == \\'1\\' else 0\\n                ans = max(ans, M[i][j])\\n        return ans * ans\\n```\\n\\n***Time Complexity :*** <code>O(MN)</code>\\n***Space Complexity :*** `O(1)`\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& M) {\\n        auto isValidSquare = [&](int i, int j, int side) {\\n            return all_of(begin(M)+i, begin(M)+i+side, [&](auto& R){\\n                return all_of(begin(R)+j, begin(R)+j+side, [&](auto cell) { return cell == \\'1\\'; });\\n            });\\n        };\\n        int m = size(M), n = size(M[0]), ans = 0;\\n        for(int row = 0; row < m; row++)\\n            for(int col = 0; col < n; col++)\\n                for(int sideLen = 1; sideLen <= min(m-row, n-col); sideLen++) \\n                    if(isValidSquare(row, col, sideLen))\\n                        ans = ans = max(ans, sideLen*sideLen);\\n        return ans;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& M) {\\n        auto isValidSquare = [&](int i, int j, int side) {\\n            return all_of(begin(M)+i, begin(M)+i+side, [&](auto& R){\\n                return all_of(begin(R)+j, begin(R)+j+side, [&](auto cell) { return cell == \\'1\\'; });\\n            });\\n        };\\n        int m = size(M), n = size(M[0]);\\n        for(int sideLen = min(m, n); sideLen; sideLen--)\\n            for(int row = 0; row <= m-sideLen; row++)\\n                for(int col = 0; col <= n-sideLen; col++)\\n                    if(isValidSquare(row, col, sideLen))\\n                        return sideLen*sideLen;\\n        return 0;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def maximalSquare(self, M):\\n        def is_valid_sqaure(row, col, side):\\n            return all(all(M[i][j] == \\'1\\' for j in range(col, col+side)) for i in range(row, row+side))\\n        m, n = len(M), len(M[0])\\n        for side_len in range(min(m,n), 0, -1):\\n            for row in range(m - side_len + 1):\\n                for col in range(n - side_len + 1):\\n                    if is_valid_sqaure(row, col, side_len):\\n                        return side_len**2\\n        return 0\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int getMaxSquareLen(vector<vector<char>>& M, int row, int col) {\\n        int allOnesRowLen = min(size(M)-row, size(M[0])-col), sqLen = 0;\\n        for(int i = 0, j; i < allOnesRowLen; i++) {\\n            for(j = 0; j < allOnesRowLen && M[i+row][j+col] != \\'0\\'; j++);\\n            allOnesRowLen = j;\\n            sqLen = min(allOnesRowLen, i+1);\\n        }\\n        return sqLen;\\n    }\\n    int maximalSquare(vector<vector<char>>& M) {\\n        int m = size(M), n = size(M[0]), ans = 0;\\n        for(int row = 0; row < m; row++)\\n            for(int col = 0; col < n; col++) \\n                ans = max(ans, getMaxSquareLen(M, row, col));\\n        return ans * ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def maximalSquare(self, M):\\n        m, n, ans = len(M), len(M[0]), 0\\n        def get_max_square_len(row, col):\\n            all_ones_row_len, sq_len, i, j = min(m-row, n-col), 0, 0, 0\\n            while i < all_ones_row_len:\\n                j = 0\\n                while j < all_ones_row_len and M[i+row][j+col] != \\'0\\': \\n                    j += 1\\n                all_ones_row_len = j\\n                sq_len = min(all_ones_row_len, i := i + 1)\\n            return sq_len\\n        \\n        for row in range(m):\\n            for col in range(n):\\n                ans = max(ans, get_max_square_len(row, col))\\n        return ans * ans\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int getMaxSquareLen(vector<vector<char>>& M, vector<vector<int>>& ones, int row, int col) {\\n        int allOnesRowLen = min(size(M)-row, size(M[0])-col), sqLen = 0;\\n        for(int i = 0, j; i < allOnesRowLen; i++) \\n            allOnesRowLen = min(allOnesRowLen, ones[i+row][col]),\\n            sqLen = min(allOnesRowLen, i+1);\\n        return sqLen;\\n    }\\n    int maximalSquare(vector<vector<char>>& M) {\\n        int m = size(M), n = size(M[0]), ans = 0;\\n        vector<vector<int>> ones(m, vector<int>(n+1));\\n        for(int i = m-1; ~i; i--)\\n            for(int j = n-1; ~j; j--)\\n                ones[i][j] = (M[i][j] == \\'1\\' ? 1 + ones[i][j+1] : 0);\\n        \\n        for(int row = 0; row < m; row++)\\n            for(int col = 0; col < n; col++) \\n                ans = max(ans, getMaxSquareLen(M, ones, row, col));\\n        return ans * ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def maximalSquare(self, M):\\n        m, n, ans = len(M), len(M[0]), 0\\n        ones = [[0]*(n+1) for i in range(m)]\\n        for i in range(m-1,-1,-1):\\n            for j in range(n-1,-1,-1):\\n                ones[i][j] = 1 + ones[i][j+1] if M[i][j] == \\'1\\' else 0\\n        \\n        def get_max_square_len(row, col):\\n            all_ones_row_len, sq_len, i, j = min(m-row, n-col), 0, 0, 0\\n            while i < all_ones_row_len:                \\n                all_ones_row_len = min(all_ones_row_len, ones[i+row][col])\\n                sq_len = min(all_ones_row_len, i := i + 1)\\n            return sq_len\\n        \\n        for row in range(m):\\n            for col in range(n):\\n                ans = max(ans, get_max_square_len(row, col))\\n        return ans * ans\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& M) {\\n        int m = size(M), n = size(M[0]), ans = 0;\\n        vector<vector<int>> dp(m+1, vector<int>(n+1)), onesRow(dp), onesCol(dp);\\n        for(int i = m-1; ~i; i--)\\n            for(int j = n-1; ~j; j--)\\n                onesRow[i][j] = (M[i][j] == \\'1\\' ? 1 + onesRow[i][j+1] : 0),\\n                onesCol[i][j] = (M[i][j] == \\'1\\' ? 1 + onesCol[i+1][j] : 0);\\n        \\n        for(int i = m-1; ~i; i--)\\n            for(int j = n-1; ~j; j--) \\n                dp[i][j] = (M[i][j] == \\'1\\' ? 1 + min({onesRow[i][j]-1, onesCol[i][j]-1, dp[i+1][j+1]}) : 0),\\n                ans = max(ans, dp[i][j]);\\n\\n        return ans * ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def maximalSquare(self, M):\\n        m, n, ans = len(M), len(M[0]), 0\\n        dp, onesRow, onesCol = ([[0]*(n+1) for i in range(m+1)] for cnt in range(3))\\n\\n        for i, j in product(range(m-1, -1, -1), range(n-1, -1, -1)):\\n            onesRow[i][j] = 1 + onesRow[i][j+1] if M[i][j] == \\'1\\' else 0\\n            onesCol[i][j] = 1 + onesCol[i+1][j] if M[i][j] == \\'1\\' else 0\\n            \\n        for i, j in product(range(m-1, -1, -1), range(n-1, -1, -1)):\\n            dp[i][j] = 1 + min(onesRow[i][j]-1, onesCol[i][j]-1, dp[i+1][j+1]) if M[i][j] == \\'1\\' else 0\\n            ans = max(ans, dp[i][j])\\n        return ans * ans\\n\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& M) {\\n        int m = size(M), n = size(M[0]), ans = 0;\\n        vector<vector<int>> dp(m+1, vector<int>(n+1));\\n        for(int i = m-1; ~i; i--)\\n            for(int j = n-1; ~j; j--) \\n                dp[i][j] = (M[i][j] == \\'1\\' ? 1 + min({dp[i+1][j], dp[i][j+1], dp[i+1][j+1]}) : 0),\\n                ans = max(ans, dp[i][j]);\\n\\n        return ans * ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def maximalSquare(self, M):\\n        m, n, ans = len(M), len(M[0]), 0\\n        dp = [[0]*(n+1) for i in range(m+1)]\\n        \\n        for i, j in product(range(m-1, -1, -1), range(n-1, -1, -1)):\\n            dp[i][j] = 1 + min(dp[i+1][j], dp[i][j+1], dp[i+1][j+1]) if M[i][j] == \\'1\\' else 0\\n            ans = max(ans, dp[i][j])\\n        return ans * ans\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& M) {\\n        int m = size(M), n = size(M[0]), ans = 0;\\n        vector<vector<int>> dp(2, vector<int>(n+1));\\n        for(int i = m-1; ~i; i--)\\n            for(int j = n-1; ~j; j--) \\n                dp[i&1][j] = (M[i][j] == \\'1\\' ? 1 + min({dp[(i+1)&1][j], dp[i&1][j+1], dp[(i+1)&1][j+1]}) : 0),\\n                ans = max(ans, dp[i&1][j]);\\n\\n        return ans * ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def maximalSquare(self, M):\\n        m, n, ans = len(M), len(M[0]), 0\\n        dp = [[0]*(n+1) for i in range(2)]\\n        \\n        for i, j in product(range(m-1, -1, -1), range(n-1, -1, -1)):\\n            dp[i&1][j] = 1 + min(dp[(i+1)&1][j], dp[i&1][j+1], dp[(i+1)&1][j+1]) if M[i][j] == \\'1\\' else 0\\n            ans = max(ans, dp[i&1][j])\\n        return ans * ans\\n\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& M) {\\n        int m = size(M), n = size(M[0]), ans = 0;        \\n        for(int i = m-1; ~i; i--)\\n            for(int j = n-1; ~j; j--) \\n                if(i == m-1 or j == n-1)\\n                    ans = max(ans, int(M[i][j] -= \\'0\\'));\\n                else\\n                    M[i][j] = (M[i][j] == \\'1\\' ? 1+min({M[i+1][j], M[i][j+1], M[i+1][j+1]}) : 0),\\n                    ans = max(ans, int(M[i][j]));\\n\\n        return ans * ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def maximalSquare(self, M):\\n        m, n, ans = len(M), len(M[0]), 0\\n        for i, j in product(range(m-1, -1, -1), range(n-1, -1, -1)):\\n            if i == m-1 or j == n-1:\\n                M[i][j] = int(M[i][j])\\n                ans = max(ans, M[i][j])\\n            else:\\n                M[i][j] = 1 + min(M[i+1][j], M[i][j+1], M[i+1][j+1]) if M[i][j] == \\'1\\' else 0\\n                ans = max(ans, M[i][j])\\n        return ans * ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61876,
                "title": "accepted-clean-java-dp-solution",
                "content": "    public int maximalSquare(char[][] a) {\\n      if (a == null || a.length == 0 || a[0].length == 0)\\n        return 0;\\n          \\n      int max = 0, n = a.length, m = a[0].length;\\n      \\n      // dp(i, j) represents the length of the square \\n      // whose lower-right corner is located at (i, j)\\n      // dp(i, j) = min{ dp(i-1, j-1), dp(i-1, j), dp(i, j-1) }\\n      int[][] dp = new int[n + 1][m + 1];\\n      \\n      for (int i = 1; i <= n; i++) {\\n        for (int j = 1; j <= m; j++) {\\n          if (a[i - 1][j - 1] == '1') {\\n            dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;\\n            max = Math.max(max, dp[i][j]);\\n          }\\n        }\\n      }\\n      \\n      // return the area\\n      return max * max;\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "    public int maximalSquare(char[][] a) {\\n      if (a == null || a.length == 0 || a[0].length == 0)\\n        return 0;\\n          \\n      int max = 0, n = a.length, m = a[0].length;\\n      \\n      // dp(i, j) represents the length of the square \\n      // whose lower-right corner is located at (i, j)\\n      // dp(i, j) = min{ dp(i-1, j-1), dp(i-1, j), dp(i, j-1) }\\n      int[][] dp = new int[n + 1][m + 1];\\n      \\n      for (int i = 1; i <= n; i++) {\\n        for (int j = 1; j <= m; j++) {\\n          if (a[i - 1][j - 1] == '1') {\\n            dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;\\n            max = Math.max(max, dp[i][j]);\\n          }\\n        }\\n      }\\n      \\n      // return the area\\n      return max * max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 61935,
                "title": "6-lines-visual-explanation-o-mn",
                "content": "**Explanation**\\n\\nWhat's the largest (full-of-ones-)square ending at (i,j), meaning lower right corner in row i, column j? Imagine there are 4x4 squares above, above-left and left of it:\\n\\n    above  above-left  left\\n    \\n     1111     1111\\n     1111     1111     1111\\n     1111     1111     1111\\n     1111     1111     1111\\n        *         *    1111*\\n\\nClearly, if cell (i,j) itself is 1 as well, then there's a 5x5 square ending at (i,j). And if there were 5x5 squares above, above-left and left of it, then we'd have a 6x6. So to find the largest square ending at (i,j), we just take the minimum size of squares ending at (i-1,j), (i-1,j-1) and (i,j-1), and add 1.\\n\\n---\\n\\n**Implementation** - 164 ms\\n\\nI write the maximum sizes directly into the input matrix `A`. Cell `A[i][j]` will tell the side length of the largest square ending at (i,j). I go top to bottom and left to right, so (i-1,j), (i-1,j-1) and (i,j-1) have all been handled already. First thing I do for each cell is turn it into an integer, and then if it's 1 and it's not on the top or left border of the matrix, I determine its largest-square size as explained above. In the end, I return 0 for the empty matrix and otherwise the area of the largest square ending anywhere.\\n\\n    class Solution:\\n        def maximalSquare(self, A):\\n            for i in range(len(A)):\\n                for j in range(len(A[i])):\\n                    A[i][j] = int(A[i][j])\\n                    if A[i][j] and i and j:\\n                        A[i][j] = min(A[i-1][j], A[i-1][j-1], A[i][j-1]) + 1\\n            return len(A) and max(map(max, A)) ** 2\\n\\n---\\n\\n**Smaller Version** - 132 ms\\n\\nThis version is a bit smaller and faster due to using more of Python and some \"tricks\":\\n\\n    class Solution:\\n        def maximalSquare(self, A):\\n            for i, r in enumerate(A):\\n                r = A[i] = map(int, r)\\n                for j, c in enumerate(r):\\n                    if i * j * c:\\n                        r[j] = min(A[i-1][j], r[j-1], A[i-1][j-1]) + 1\\n            return max(map(max, A + [[0]])) ** 2\\n\\n---\\n\\n**O(n) Extra Space** - 128 ms\\n\\nHere's a version that doesn't overwrite the input matrix but uses two integer lists: `s` tells the sizes of the squares ending it the current row and `p` does the same for the previous row.\\n\\n    class Solution:\\n        def maximalSquare(self, A):\\n            area = 0\\n            if A:\\n                p = [0] * len(A[0])\\n                for row in A:\\n                    s = map(int, row)\\n                    for j, c in enumerate(s[1:], 1):\\n                        s[j] *= min(p[j-1], p[j], s[j-1]) + 1\\n                    area = max(area, max(s) ** 2)\\n                    p = s\\n            return area\\n\\nNote that in Python with its integer and string objects, I'm not sure this actually saves space. But in other languages, overwriting the input array might not even be possible, and if it's possible, it might take more space than a \"O(n) Extra Space\" variant.",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "**Explanation**\\n\\nWhat's the largest (full-of-ones-)square ending at (i,j), meaning lower right corner in row i, column j? Imagine there are 4x4 squares above, above-left and left of it:\\n\\n    above  above-left  left\\n    \\n     1111     1111\\n     1111     1111     1111\\n     1111     1111     1111\\n     1111     1111     1111\\n        *         *    1111*\\n\\nClearly, if cell (i,j) itself is 1 as well, then there's a 5x5 square ending at (i,j). And if there were 5x5 squares above, above-left and left of it, then we'd have a 6x6. So to find the largest square ending at (i,j), we just take the minimum size of squares ending at (i-1,j), (i-1,j-1) and (i,j-1), and add 1.\\n\\n---\\n\\n**Implementation** - 164 ms\\n\\nI write the maximum sizes directly into the input matrix `A`. Cell `A[i][j]` will tell the side length of the largest square ending at (i,j). I go top to bottom and left to right, so (i-1,j), (i-1,j-1) and (i,j-1) have all been handled already. First thing I do for each cell is turn it into an integer, and then if it's 1 and it's not on the top or left border of the matrix, I determine its largest-square size as explained above. In the end, I return 0 for the empty matrix and otherwise the area of the largest square ending anywhere.\\n\\n    class Solution:\\n        def maximalSquare(self, A):\\n            for i in range(len(A)):\\n                for j in range(len(A[i])):\\n                    A[i][j] = int(A[i][j])\\n                    if A[i][j] and i and j:\\n                        A[i][j] = min(A[i-1][j], A[i-1][j-1], A[i][j-1]) + 1\\n            return len(A) and max(map(max, A)) ** 2\\n\\n---\\n\\n**Smaller Version** - 132 ms\\n\\nThis version is a bit smaller and faster due to using more of Python and some \"tricks\":\\n\\n    class Solution:\\n        def maximalSquare(self, A):\\n            for i, r in enumerate(A):\\n                r = A[i] = map(int, r)\\n                for j, c in enumerate(r):\\n                    if i * j * c:\\n                        r[j] = min(A[i-1][j], r[j-1], A[i-1][j-1]) + 1\\n            return max(map(max, A + [[0]])) ** 2\\n\\n---\\n\\n**O(n) Extra Space** - 128 ms\\n\\nHere's a version that doesn't overwrite the input matrix but uses two integer lists: `s` tells the sizes of the squares ending it the current row and `p` does the same for the previous row.\\n\\n    class Solution:\\n        def maximalSquare(self, A):\\n            area = 0\\n            if A:\\n                p = [0] * len(A[0])\\n                for row in A:\\n                    s = map(int, row)\\n                    for j, c in enumerate(s[1:], 1):\\n                        s[j] *= min(p[j-1], p[j], s[j-1]) + 1\\n                    area = max(area, max(s) ** 2)\\n                    p = s\\n            return area\\n\\nNote that in Python with its integer and string objects, I'm not sure this actually saves space. But in other languages, overwriting the input array might not even be possible, and if it's possible, it might take more space than a \"O(n) Extra Space\" variant.",
                "codeTag": "Java"
            },
            {
                "id": 1632145,
                "title": "c-java-python-easy-to-solve-detailed-explanation-of-dp-with-visualization-and-dry-run",
                "content": "# **Dynamic Programming || Memoization || Dynamic Doge Memoization**\\n\\n**Intuition:-**\\nAfter reading the question we understood that, we need to find largest square of 1\\'s and return it\\'s area( that will be maxSqr * maxSqr ). Also given that matrix is a binary matrix.\\n**There are two ways to solve this problem :-**\\n*  **Our Classical Recursion**\\n*  **DP**\\n\\nIn this type of questions we believe in supremacy of DP. Since in recursion the TLE error will hunt us. Ok, now let\\'s hunt the hunter .\\n\\n**Algorithm:-**\\n1. Let\\'s consider the base case that the size of matrix is 0 . So `return 0`.\\n2. Let\\'s declare some variables, I always try to declare self-explanatory variables like `maxSqr`[maximal area of square] , `rows`, `column` \\n3. Now the dp memorization matrix that we will be making needs to have `1 extra row and column` for the purpose of computing dp of first row and column .\\n4. Now we need to iterate the whole matrix and once we find a `1` we need to check the surrounding i.e left, uppper and upper left neighbours -> `(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])`\\n5. After we get the minimum value from neighbours we will be adding 1. You say why , I say we need `\"+ 1\"` for two reasons:\\n* If the surrounding 1\\'s are becoming part of our maximal square then we need to increase the maximal size by 1.\\n* If not then atleast we have our original 1x1 square matrix .\\n6. Now just find the max from our dp matrix and KABOOM we are done.\\n\\n**Let\\'s have our Doge run:-**\\n\\n![image](https://assets.leetcode.com/users/images/e26ae79f-165a-43f4-8e62-05b54c6d0596_1639710729.8337142.jpeg)\\n\\n\\n**Code:-**\\n**C++:**\\n```\\n//Upvote & Comment\\n\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        //base case\\n        if(matrix.size()==0) return 0;\\n        //initializing our sentinal variables\\n        int maxSqr = 0, rows = matrix.size() , column = matrix[0].size();\\n        //dp matrix that we will be making \\n        vector<vector<int>> dp(rows+1,vector<int>(column+1,0));\\n        \\n        //Iterate over the matrix\\n        for(int i=1;i<=rows;++i){\\n            for(int j=1;j<=column;++j){\\n                //we found the 1 in our binary matrix \\n                if(matrix[i-1][j-1]==\\'1\\'){\\n                    dp[i][j] = min({dp[i-1][j-1], dp[i-1][j], dp[i][j-1]})+ 1;\\n                    maxSqr=max(maxSqr,dp[i][j]);\\n                }\\n            }\\n        }\\n        return maxSqr*maxSqr;\\n    }\\n};\\n```\\n\\n**JAVA:**\\n*All the logic and variables are same :)*\\n```\\n//Upvote & Comment\\n\\nclass Solution {\\n    public int maximalSquare(char[][] matrix) {\\n        //initializing sentinal varibles\\n        int maxSqr=0 , rows=matrix.length , column=matrix[0].length;\\n        //base case\\n        if(rows==0) return 0;\\n        //dp matrix that we will be making\\n        int[][] dp=new int[rows+1][column+1];\\n\\t\\t\\n        //Iterate over the matrix\\n        for(int i=1;i<=rows;i++)\\n            for(int j=1;j<=column;j++) {\\n                ///we found the 1 in our binary matrix \\n                if(matrix[i-1][j-1]==\\'0\\') continue;\\n                dp[i][j]=Math.min(dp[i-1][j],Math.min(dp[i-1][j-1],dp[i][j-1])) + 1;\\n                maxSqr=Math.max(maxSqr,dp[i][j]);\\n            }\\n        return maxSqr*maxSqr;\\n    }\\n}\\n```\\n\\n\\n**Python:**\\n*All the logic and variables are same :)*\\n```\\n//Upvote & Comment\\n\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        #base case\\n        if matrix is None or len(matrix) < 1:\\n            return 0\\n        #initializing our sentinal variables\\n        rows = len(matrix)\\n        cols = len(matrix[0])\\n        maxSqr = 0\\n        #dp matrix that we will be making \\n        dp = [[0]*(cols+1) for _ in range(rows+1)]\\n        \\n        #Iterate over the matrix\\n        for i in range(rows):\\n            for j in range(cols):\\n                #we found the 1 in our binary matrix \\n                if matrix[i][j] == \\'1\\':\\n                    dp[i+1][j+1] = min(dp[i][j], dp[i+1][j], dp[i][j+1]) + 1 \\n                    maxSqr = max(maxSqr, dp[i+1][j+1])\\n                \\n        return maxSqr * maxSqr\\n```\\n\\n\\n**Time complexity : O(mn). [Single pass i.e rows x column]\\nSpace complexity : O(mn). [Additional space for dp grid].**\\n\\n***\\n\\n**[My Github Repo](https://github.com/Jatin-Shihora/LeetCode-Solutions) where I keep track of my solutions :)))**\\n\\n***\\n\\n.....*Continuation from previous posts*..\\n*After Yomru\\'s many tries, the door opened by 2-3cm but instantly closed . While Dogelina with her breathing mastery was trying to pick up some scents that may help to decode the passcode and thus leading to opening of the ancient ruins of Dr.Cheems Doge . While in the background Doggo, Dogenderous and JThree were thinking of how to crack this passcode. Doggo told to Dogenderous \"In all of the articles and from our life eperiences we never saw or heard of this huehuehue Dr.Cheems language, now what shall we do!?\" . Meanwhile JThree got a idea ...\\nTo be continued in the next post*.....\\n\\n**Feel free to comment if you have some suggestions or Upvote if you liked my post!! ^_^**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n//Upvote & Comment\\n\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        //base case\\n        if(matrix.size()==0) return 0;\\n        //initializing our sentinal variables\\n        int maxSqr = 0, rows = matrix.size() , column = matrix[0].size();\\n        //dp matrix that we will be making \\n        vector<vector<int>> dp(rows+1,vector<int>(column+1,0));\\n        \\n        //Iterate over the matrix\\n        for(int i=1;i<=rows;++i){\\n            for(int j=1;j<=column;++j){\\n                //we found the 1 in our binary matrix \\n                if(matrix[i-1][j-1]==\\'1\\'){\\n                    dp[i][j] = min({dp[i-1][j-1], dp[i-1][j], dp[i][j-1]})+ 1;\\n                    maxSqr=max(maxSqr,dp[i][j]);\\n                }\\n            }\\n        }\\n        return maxSqr*maxSqr;\\n    }\\n};\\n```\n```\\n//Upvote & Comment\\n\\nclass Solution {\\n    public int maximalSquare(char[][] matrix) {\\n        //initializing sentinal varibles\\n        int maxSqr=0 , rows=matrix.length , column=matrix[0].length;\\n        //base case\\n        if(rows==0) return 0;\\n        //dp matrix that we will be making\\n        int[][] dp=new int[rows+1][column+1];\\n\\t\\t\\n        //Iterate over the matrix\\n        for(int i=1;i<=rows;i++)\\n            for(int j=1;j<=column;j++) {\\n                ///we found the 1 in our binary matrix \\n                if(matrix[i-1][j-1]==\\'0\\') continue;\\n                dp[i][j]=Math.min(dp[i-1][j],Math.min(dp[i-1][j-1],dp[i][j-1])) + 1;\\n                maxSqr=Math.max(maxSqr,dp[i][j]);\\n            }\\n        return maxSqr*maxSqr;\\n    }\\n}\\n```\n```\\n//Upvote & Comment\\n\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        #base case\\n        if matrix is None or len(matrix) < 1:\\n            return 0\\n        #initializing our sentinal variables\\n        rows = len(matrix)\\n        cols = len(matrix[0])\\n        maxSqr = 0\\n        #dp matrix that we will be making \\n        dp = [[0]*(cols+1) for _ in range(rows+1)]\\n        \\n        #Iterate over the matrix\\n        for i in range(rows):\\n            for j in range(cols):\\n                #we found the 1 in our binary matrix \\n                if matrix[i][j] == \\'1\\':\\n                    dp[i+1][j+1] = min(dp[i][j], dp[i+1][j], dp[i][j+1]) + 1 \\n                    maxSqr = max(maxSqr, dp[i+1][j+1])\\n                \\n        return maxSqr * maxSqr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 468356,
                "title": "recursion-brute-force-memoization-dp",
                "content": "**Brute Force - Check at each appearance of 1 in the matrix**\\nIf you see a 1 at ```(i, j)```, then also check for ```(i + 1, j), (i, j + 1), (i + 1, j + 1)```\\n```\\n    def maximalSquare_rec(self, matrix):\\n        \"\"\"\\n            Time Complexity => Exponential => we are not making use of already computed values => memoize them\\n        \"\"\"\\n        def rec_helper(i, j):\\n            nonlocal rows, cols\\n            if 0 <= i < rows and 0 <= j < cols:\\n                if matrix[i][j] == 1:\\n                    return min(rec_helper(i,  j + 1), rec_helper(i + 1, j + 1), rec_helper(i + 1, j)) + 1\\n            return 0\\n\\n        rows = len(matrix)\\n        cols = len(matrix[0])\\n\\n        maximum = float(\\'-inf\\')\\n\\n        for i in range(rows):\\n            for j in range(cols):\\n                if matrix[i][j] == 1:\\n                    val = rec_helper(i, j)\\n                    maximum = max(maximum, val)\\n\\n        return maximum ** 2\\n```\\n\\n**Memoization:** What are the two changing factors in our recurence relation? ```->``` row and col ```=>``` so we need to memoize this.\\n```\\n    def maximalSquare_rec_memo(self, matrix):\\n        def rec_helper(i, j):\\n            nonlocal rows, cols, memo\\n            if 0 <= i < rows and 0 <= j < cols:\\n                if memo[i][j] != -1:\\n                    return memo[i][j]\\n\\n                if matrix[i][j] == 1:\\n                    memo[i][j] = min(rec_helper(i,  j + 1), rec_helper(i + 1, j + 1), rec_helper(i + 1, j)) + 1\\n                else:\\n                    memo[i][j] = 0\\n                return memo[i][j]\\n            return 0\\n\\n        rows = len(matrix)\\n        cols = len(matrix[0])\\n\\n        maximum = float(\\'-inf\\')\\n\\n        memo = [[-1 for _ in range(cols)] for _ in range(rows)]\\n\\n        for i in range(rows):\\n            for j in range(cols):\\n                if matrix[i][j] == 1:\\n                    val = rec_helper(i, j)\\n                    maximum = max(maximum, val)\\n\\n        return maximum ** 2\\n```\\n\\n**DP**\\n```\\ndef maximalSquare(self, matrix):\\n        rows = len(matrix)\\n        cols = len(matrix[0]) if rows > 0 else 0\\n\\n        dp = [[0 for _ in range(cols + 1)] for _ in range(rows + 1)]\\n        max_square_length = float(\\'-inf\\')\\n        for i in range(1, rows + 1):\\n            for j in range(1, cols + 1):\\n                if matrix[i - 1][j - 1] == 1:\\n                    dp[i][j] = min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]) + 1\\n                    max_square_length = max(max_square_length, dp[i][j])\\n        return max_square_length ** 2\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```(i, j)```\n```(i + 1, j), (i, j + 1), (i + 1, j + 1)```\n```\\n    def maximalSquare_rec(self, matrix):\\n        \"\"\"\\n            Time Complexity => Exponential => we are not making use of already computed values => memoize them\\n        \"\"\"\\n        def rec_helper(i, j):\\n            nonlocal rows, cols\\n            if 0 <= i < rows and 0 <= j < cols:\\n                if matrix[i][j] == 1:\\n                    return min(rec_helper(i,  j + 1), rec_helper(i + 1, j + 1), rec_helper(i + 1, j)) + 1\\n            return 0\\n\\n        rows = len(matrix)\\n        cols = len(matrix[0])\\n\\n        maximum = float(\\'-inf\\')\\n\\n        for i in range(rows):\\n            for j in range(cols):\\n                if matrix[i][j] == 1:\\n                    val = rec_helper(i, j)\\n                    maximum = max(maximum, val)\\n\\n        return maximum ** 2\\n```\n```->```\n```=>```\n```\\n    def maximalSquare_rec_memo(self, matrix):\\n        def rec_helper(i, j):\\n            nonlocal rows, cols, memo\\n            if 0 <= i < rows and 0 <= j < cols:\\n                if memo[i][j] != -1:\\n                    return memo[i][j]\\n\\n                if matrix[i][j] == 1:\\n                    memo[i][j] = min(rec_helper(i,  j + 1), rec_helper(i + 1, j + 1), rec_helper(i + 1, j)) + 1\\n                else:\\n                    memo[i][j] = 0\\n                return memo[i][j]\\n            return 0\\n\\n        rows = len(matrix)\\n        cols = len(matrix[0])\\n\\n        maximum = float(\\'-inf\\')\\n\\n        memo = [[-1 for _ in range(cols)] for _ in range(rows)]\\n\\n        for i in range(rows):\\n            for j in range(cols):\\n                if matrix[i][j] == 1:\\n                    val = rec_helper(i, j)\\n                    maximum = max(maximum, val)\\n\\n        return maximum ** 2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 61805,
                "title": "evolve-from-brute-force-to-dp",
                "content": "If we are not comfortable to start with dp, we may start from brute force. Identifying and fixing the problems in the naive approach can guide us to the optimal solution.\\n1. Brute force O(n^5), check all sizes starting at all points\\n* c++\\n```\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int r=matrix.size();\\n        if(!r) return 0;\\n        int c=matrix[0].size(), n=min(r,c);\\n        for(int s=n;s>0;s--)  //all sizes\\n            for(int i=0;i<=r-s;i++)  //each starting point\\n                for(int j=0;j<=c-s;j++) {\\n                    bool has0=false;\\n                    for(int p=i;p<i+s;p++) {\\n                        for(int q=j;q<j+s;q++)\\n                            if(matrix[p][q]==\\'0\\') {\\n                                has0=true;\\n                                break;\\n                            }\\n                        if(has0) break;\\n                    }\\n                    if (!has0) return s*s;\\n                }\\n        return 0;\\n    }\\n```\\n* java\\n```\\n public int maximalSquare(char[][] matrix) {\\n        int r=matrix.length;\\n        if(r==0) return 0;\\n        int c=matrix[0].length, n=Math.min(r,c);\\n        for(int s=n;s>0;s--)\\n            for(int i=0;i<=r-s;i++)\\n                for(int j=0;j<=c-s;j++) {\\n                    int p;\\n                    for(p=i;p<i+s;p++) {\\n                        int q;\\n                        for(q=j;q<j+s;q++)\\n                            if(matrix[p][q]==\\'0\\') break;\\n                        if(q<j+s) break;\\n                    }\\n                    if(p==i+s) return s*s;\\n                }\\n        return 0;\\n    }\\n```\\n2. O(n^3), check if a square contains all 1s can be improved to constant by preprocessing. ones[i][j] is the number of 1s in matrix(0,0,i-1,j-1)\\n```\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int r=matrix.size();\\n        if(!r) return 0;\\n        int c=matrix[0].size(), n=min(r,c);\\n        vector<vector<int>> ones(r+1,vector<int>(c+1));\\n        for(int i=1;i<=r;i++) \\n            for(int j=1;j<=c;j++) ones[i][j] = matrix[i-1][j-1]-\\'0\\' + ones[i-1][j]+ones[i][j-1]-ones[i-1][j-1];\\n        for(int s=n;s>0;s--)\\n            for(int i=0;i<=r-s;i++)\\n                for(int j=0;j<=c-s;j++) if(ones[i+s][j+s]-ones[i+s][j]-ones[i][j+s]+ones[i][j] == s*s) return s*s;\\n        return 0;\\n    }\\n```\\n3. Recursion O(mn3^n), #2 indicates the ones in (i,j) can be computed from (i-1,j), (i,j-1), (i-1,j-1). This hints for the recursive relation.\\n```\\n\\tpublic int maximalSquare(char[][] matrix) {\\n        int r=matrix.length;\\n        if(r==0) return 0;\\n        int edge=0;\\n        for(int i=0;i<r;i++)\\n            for(int j=0;j<matrix[0].length;j++)\\n                edge=Math.max(edge,maxSq(i,j,matrix));              \\n        return edge*edge;\\n    }\\n    private int maxSq(int i, int j, char[][] matrix) {\\n        if(i==0||j==0) \\n\\t\\t\\treturn matrix[i][j]-\\'0\\';//the maxSq edge length is 0 or 1 if the bottom right corner is at 0\\n        if(matrix[i][j]==\\'0\\') return 0;\\n        return Math.min(Math.min(maxSq(i,j-1,matrix),maxSq(i-1,j,matrix)),maxSq(i-1,j-1,matrix))+1;\\n    }\\n```\\n4. O(mn) Memoization\\n```\\n\\tpublic int maximalSquare(char[][] matrix) {\\n        int r=matrix.length;\\n        if(r==0) return 0;\\n        int c=matrix[0].length,edge=0;\\n        Integer[][] mem=new Integer[r][c];\\n        for(int i=0;i<r;i++)\\n            for(int j=0;j<c;j++)\\n                edge=Math.max(edge,maxSq(i,j,matrix,mem));              \\n        return edge*edge;\\n    }\\n    private int maxSq(int i, int j, char[][] matrix,Integer[][] mem) {\\n        if(i==0||j==0) return matrix[i][j]-\\'0\\';\\n        if(matrix[i][j]==\\'0\\') return 0;\\n        if(mem[i][j]!=null) return mem[i][j];\\n        return mem[i][j]=Math.min(Math.min(maxSq(i,j-1,matrix,mem),maxSq(i-1,j,matrix,mem)),maxSq(i-1,j-1,matrix,mem))+1;\\n    }\\n```\\n5. Dp O(mn). \\n* c++\\n```\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int r = matrix.size();\\n        if(!r) return 0;\\n        int c = matrix[0].size(), s = 0;\\n        vector<vector<int>> dp(r+1, vector<int>(c+1));\\n        for(int i=1;i<=r;i++) \\n            for(int j=1;j<=c;j++) {\\n                if(matrix[i-1][j-1]==\\'0\\') continue;\\n                s = max(s, dp[i][j] = 1 + min(dp[i-1][j],min(dp[i][j-1],dp[i-1][j-1]))); \\n\\t    }\\n        return s*s;\\n     }     \\n```\\n* java\\n```\\n public int maximalSquare(char[][] matrix) {\\n        int r=matrix.length;\\n        if(r==0) return 0;\\n        int c=matrix[0].length,edge=0;\\n        int[][] dp=new int[r+1][c+1];\\n        for(int i=1;i<=r;i++)\\n            for(int j=1;j<=c;j++) {\\n                if(matrix[i-1][j-1]==\\'0\\') continue;\\n                dp[i][j]=1+Math.min(dp[i-1][j],Math.min(dp[i-1][j-1],dp[i][j-1]));\\n                edge=Math.max(edge,dp[i][j]);\\n            }\\n        return edge*edge;\\n    }\\n```\\n6. O(mn). Same as #5 but optimize extra space to O(n).\\n```\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int r = matrix.size();\\n        if(!r) return 0;\\n        int c = matrix[0].size(), s = 0;\\n        vector<int> dp(c+1);\\n        for(int i=0;i<r;i++) {\\n            int temp = 0;\\n            for(int j=1;j<=c;j++) {\\n                int pre = dp[j];\\n                if(matrix[i][j-1]==\\'1\\') s = max(s, dp[j] = 1 + min(dp[j],min(temp,dp[j-1])));\\n                else dp[j] = 0;\\n                temp = pre;\\n            }\\n        }\\n        return s*s;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int r=matrix.size();\\n        if(!r) return 0;\\n        int c=matrix[0].size(), n=min(r,c);\\n        for(int s=n;s>0;s--)  //all sizes\\n            for(int i=0;i<=r-s;i++)  //each starting point\\n                for(int j=0;j<=c-s;j++) {\\n                    bool has0=false;\\n                    for(int p=i;p<i+s;p++) {\\n                        for(int q=j;q<j+s;q++)\\n                            if(matrix[p][q]==\\'0\\') {\\n                                has0=true;\\n                                break;\\n                            }\\n                        if(has0) break;\\n                    }\\n                    if (!has0) return s*s;\\n                }\\n        return 0;\\n    }\\n```\n```\\n public int maximalSquare(char[][] matrix) {\\n        int r=matrix.length;\\n        if(r==0) return 0;\\n        int c=matrix[0].length, n=Math.min(r,c);\\n        for(int s=n;s>0;s--)\\n            for(int i=0;i<=r-s;i++)\\n                for(int j=0;j<=c-s;j++) {\\n                    int p;\\n                    for(p=i;p<i+s;p++) {\\n                        int q;\\n                        for(q=j;q<j+s;q++)\\n                            if(matrix[p][q]==\\'0\\') break;\\n                        if(q<j+s) break;\\n                    }\\n                    if(p==i+s) return s*s;\\n                }\\n        return 0;\\n    }\\n```\n```\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int r=matrix.size();\\n        if(!r) return 0;\\n        int c=matrix[0].size(), n=min(r,c);\\n        vector<vector<int>> ones(r+1,vector<int>(c+1));\\n        for(int i=1;i<=r;i++) \\n            for(int j=1;j<=c;j++) ones[i][j] = matrix[i-1][j-1]-\\'0\\' + ones[i-1][j]+ones[i][j-1]-ones[i-1][j-1];\\n        for(int s=n;s>0;s--)\\n            for(int i=0;i<=r-s;i++)\\n                for(int j=0;j<=c-s;j++) if(ones[i+s][j+s]-ones[i+s][j]-ones[i][j+s]+ones[i][j] == s*s) return s*s;\\n        return 0;\\n    }\\n```\n```\\n\\tpublic int maximalSquare(char[][] matrix) {\\n        int r=matrix.length;\\n        if(r==0) return 0;\\n        int edge=0;\\n        for(int i=0;i<r;i++)\\n            for(int j=0;j<matrix[0].length;j++)\\n                edge=Math.max(edge,maxSq(i,j,matrix));              \\n        return edge*edge;\\n    }\\n    private int maxSq(int i, int j, char[][] matrix) {\\n        if(i==0||j==0) \\n\\t\\t\\treturn matrix[i][j]-\\'0\\';//the maxSq edge length is 0 or 1 if the bottom right corner is at 0\\n        if(matrix[i][j]==\\'0\\') return 0;\\n        return Math.min(Math.min(maxSq(i,j-1,matrix),maxSq(i-1,j,matrix)),maxSq(i-1,j-1,matrix))+1;\\n    }\\n```\n```\\n\\tpublic int maximalSquare(char[][] matrix) {\\n        int r=matrix.length;\\n        if(r==0) return 0;\\n        int c=matrix[0].length,edge=0;\\n        Integer[][] mem=new Integer[r][c];\\n        for(int i=0;i<r;i++)\\n            for(int j=0;j<c;j++)\\n                edge=Math.max(edge,maxSq(i,j,matrix,mem));              \\n        return edge*edge;\\n    }\\n    private int maxSq(int i, int j, char[][] matrix,Integer[][] mem) {\\n        if(i==0||j==0) return matrix[i][j]-\\'0\\';\\n        if(matrix[i][j]==\\'0\\') return 0;\\n        if(mem[i][j]!=null) return mem[i][j];\\n        return mem[i][j]=Math.min(Math.min(maxSq(i,j-1,matrix,mem),maxSq(i-1,j,matrix,mem)),maxSq(i-1,j-1,matrix,mem))+1;\\n    }\\n```\n```\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int r = matrix.size();\\n        if(!r) return 0;\\n        int c = matrix[0].size(), s = 0;\\n        vector<vector<int>> dp(r+1, vector<int>(c+1));\\n        for(int i=1;i<=r;i++) \\n            for(int j=1;j<=c;j++) {\\n                if(matrix[i-1][j-1]==\\'0\\') continue;\\n                s = max(s, dp[i][j] = 1 + min(dp[i-1][j],min(dp[i][j-1],dp[i-1][j-1]))); \\n\\t    }\\n        return s*s;\\n     }     \\n```\n```\\n public int maximalSquare(char[][] matrix) {\\n        int r=matrix.length;\\n        if(r==0) return 0;\\n        int c=matrix[0].length,edge=0;\\n        int[][] dp=new int[r+1][c+1];\\n        for(int i=1;i<=r;i++)\\n            for(int j=1;j<=c;j++) {\\n                if(matrix[i-1][j-1]==\\'0\\') continue;\\n                dp[i][j]=1+Math.min(dp[i-1][j],Math.min(dp[i-1][j-1],dp[i][j-1]));\\n                edge=Math.max(edge,dp[i][j]);\\n            }\\n        return edge*edge;\\n    }\\n```\n```\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int r = matrix.size();\\n        if(!r) return 0;\\n        int c = matrix[0].size(), s = 0;\\n        vector<int> dp(c+1);\\n        for(int i=0;i<r;i++) {\\n            int temp = 0;\\n            for(int j=1;j<=c;j++) {\\n                int pre = dp[j];\\n                if(matrix[i][j-1]==\\'1\\') s = max(s, dp[j] = 1 + min(dp[j],min(temp,dp[j-1])));\\n                else dp[j] = 0;\\n                temp = pre;\\n            }\\n        }\\n        return s*s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 473270,
                "title": "all-four-approaches-in-c-brute-force-recursive-dp-memoization-tabulation",
                "content": "The recursion equation used in the solution is slightly different from the officical article, but the idea is the same.\\n\\nOfficial article:\\n```\\ndp[i][j] = min(dp[i-1][j], dp[i-1][j-1], dp[i][j-1]) + 1\\nwhere dp[i][j] is the size of sqare with (i, j) as bottom-right corner.\\n```   \\nThis post:\\n```\\ndp[i][j] = min(dp[i+1][j], dp[i+1][j+1], dp[i][j+1]) + 1\\nwhere dp[i][j] is the size of sqare with (i, j) as upper-left corner.\\n```   \\n\\nFor the DP solution, the hardest part is to find the recursion equation :)\\nCode:\\n```C++\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        return tabulation(matrix);\\n    }\\n    \\n    // 1. Brute force\\n    int bruteForce(vector<vector<char>>& matrix) {\\n        int res = 0;\\n        \\n        for(int i = 0; i < matrix.size(); ++i) {\\n            for(int j = 0; j < matrix[0].size(); ++j) {\\n                if (matrix[i][j] == \\'0\\') continue;\\n                \\n                int area = 1;\\n                int right = j + 1, low = i + 1;\\n                while(right < matrix[0].size() && low < matrix.size()) {\\n                    bool valid = true;\\n                    for(int row = i; row <= low; ++row) {\\n                        if (matrix[row][right] == \\'0\\') {\\n                            valid = false;\\n                            break;\\n                        }\\n                    }\\n                    \\n                    for(int col = j; col <= right; ++col) {\\n                        if (matrix[low][col] == \\'0\\') {\\n                            valid = false;\\n                            break;\\n                        }\\n                    }\\n                    \\n                    if (valid) {\\n                        area = max(area, (low - i + 1) * (right - j + 1));\\n                    } else {\\n                        area = max(area, (low - i) * (right - j));\\n                        break;\\n                    }\\n                    \\n                    ++right;\\n                    ++low;\\n                }\\n                res = max(res, area);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    // 2. Recursive.\\n    // TLE.\\n    int recursive(vector<vector<char>>& matrix) {\\n        if (matrix.empty()) return 0;\\n        \\n        int res = 0;\\n        for(int i = 0; i < matrix.size(); ++i) {\\n            for(int j = 0; j < matrix[0].size(); ++j) {\\n                res = max(res, helper(matrix, i, j));\\n            }\\n        }\\n        return res * res;\\n    }\\n    \\n    // Return the area of maximum square with (i, j) as upper-left corner.\\n    int helper(vector<vector<char>>& matrix, int i, int j) {\\n        if (i >= matrix.size() || j >= matrix[0].size()) return 0;\\n        if (matrix[i][j] == \\'0\\') return 0;\\n        return min(min(helper(matrix, i, j+1), helper(matrix, i+1, j)), \\n                   helper(matrix, i+1, j+1)) + 1;\\n    }\\n    \\n    \\n    // 3. Memoization\\n    int memoization(vector<vector<char>>& matrix) {\\n        if (matrix.empty()) return 0;\\n        vector<vector<int>> mem(matrix.size(), vector<int>(matrix[0].size(), -1));\\n        \\n        int res = 0;\\n        for(int i = 0; i < matrix.size(); ++i) {\\n            for(int j = 0; j < matrix[0].size(); ++j) {\\n                res = max(res, solve(matrix, mem, i, j));\\n            }\\n        }\\n        return res * res;\\n    }\\n    \\n    int solve(vector<vector<char>>& matrix, vector<vector<int>>& mem, int i, int j) {\\n        if (i >= matrix.size() || j >= matrix[0].size()) return 0;\\n        if (mem[i][j] >= 0) return mem[i][j];\\n        if (matrix[i][j] == \\'0\\') return mem[i][j] = 0;\\n        mem[i][j] = min(min(solve(matrix, mem, i+1, j), solve(matrix, mem, i, j+1)),\\n                        solve(matrix, mem, i+1, j+1)) + 1;\\n        return mem[i][j];\\n    }\\n    \\n    \\n    // 4. Tabulation\\n    int tabulation(vector<vector<char>>& matrix) {\\n        if (matrix.empty()) return 0;\\n        \\n        int res = 0;\\n        vector<vector<int>> tab(matrix.size(), vector<int>(matrix[0].size()));\\n\\n        for(int row = tab.size() - 1; row >= 0; --row) {\\n            for(int col = tab[0].size() - 1; col >= 0; --col) {\\n                if (col == matrix[0].size() - 1) {\\n                    tab[row][col] = matrix[row][col] == \\'0\\' ? 0 : 1;\\n                } else if (row == matrix.size() - 1) {\\n                    tab[row][col] = matrix[row][col] == \\'0\\' ? 0 : 1;\\n                } else if (matrix[row][col] == \\'0\\') {\\n                    tab[row][col] = 0;\\n                } else {\\n                    tab[row][col] = min(min(tab[row+1][col], tab[row][col+1]),\\n                                        tab[row+1][col+1]) + 1;\\n                }\\n                res = max(res, tab[row][col]);\\n            }\\n        }\\n        \\n        return res * res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\ndp[i][j] = min(dp[i-1][j], dp[i-1][j-1], dp[i][j-1]) + 1\\nwhere dp[i][j] is the size of sqare with (i, j) as bottom-right corner.\\n```\n```\\ndp[i][j] = min(dp[i+1][j], dp[i+1][j+1], dp[i][j+1]) + 1\\nwhere dp[i][j] is the size of sqare with (i, j) as upper-left corner.\\n```\n```C++\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        return tabulation(matrix);\\n    }\\n    \\n    // 1. Brute force\\n    int bruteForce(vector<vector<char>>& matrix) {\\n        int res = 0;\\n        \\n        for(int i = 0; i < matrix.size(); ++i) {\\n            for(int j = 0; j < matrix[0].size(); ++j) {\\n                if (matrix[i][j] == \\'0\\') continue;\\n                \\n                int area = 1;\\n                int right = j + 1, low = i + 1;\\n                while(right < matrix[0].size() && low < matrix.size()) {\\n                    bool valid = true;\\n                    for(int row = i; row <= low; ++row) {\\n                        if (matrix[row][right] == \\'0\\') {\\n                            valid = false;\\n                            break;\\n                        }\\n                    }\\n                    \\n                    for(int col = j; col <= right; ++col) {\\n                        if (matrix[low][col] == \\'0\\') {\\n                            valid = false;\\n                            break;\\n                        }\\n                    }\\n                    \\n                    if (valid) {\\n                        area = max(area, (low - i + 1) * (right - j + 1));\\n                    } else {\\n                        area = max(area, (low - i) * (right - j));\\n                        break;\\n                    }\\n                    \\n                    ++right;\\n                    ++low;\\n                }\\n                res = max(res, area);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    // 2. Recursive.\\n    // TLE.\\n    int recursive(vector<vector<char>>& matrix) {\\n        if (matrix.empty()) return 0;\\n        \\n        int res = 0;\\n        for(int i = 0; i < matrix.size(); ++i) {\\n            for(int j = 0; j < matrix[0].size(); ++j) {\\n                res = max(res, helper(matrix, i, j));\\n            }\\n        }\\n        return res * res;\\n    }\\n    \\n    // Return the area of maximum square with (i, j) as upper-left corner.\\n    int helper(vector<vector<char>>& matrix, int i, int j) {\\n        if (i >= matrix.size() || j >= matrix[0].size()) return 0;\\n        if (matrix[i][j] == \\'0\\') return 0;\\n        return min(min(helper(matrix, i, j+1), helper(matrix, i+1, j)), \\n                   helper(matrix, i+1, j+1)) + 1;\\n    }\\n    \\n    \\n    // 3. Memoization\\n    int memoization(vector<vector<char>>& matrix) {\\n        if (matrix.empty()) return 0;\\n        vector<vector<int>> mem(matrix.size(), vector<int>(matrix[0].size(), -1));\\n        \\n        int res = 0;\\n        for(int i = 0; i < matrix.size(); ++i) {\\n            for(int j = 0; j < matrix[0].size(); ++j) {\\n                res = max(res, solve(matrix, mem, i, j));\\n            }\\n        }\\n        return res * res;\\n    }\\n    \\n    int solve(vector<vector<char>>& matrix, vector<vector<int>>& mem, int i, int j) {\\n        if (i >= matrix.size() || j >= matrix[0].size()) return 0;\\n        if (mem[i][j] >= 0) return mem[i][j];\\n        if (matrix[i][j] == \\'0\\') return mem[i][j] = 0;\\n        mem[i][j] = min(min(solve(matrix, mem, i+1, j), solve(matrix, mem, i, j+1)),\\n                        solve(matrix, mem, i+1, j+1)) + 1;\\n        return mem[i][j];\\n    }\\n    \\n    \\n    // 4. Tabulation\\n    int tabulation(vector<vector<char>>& matrix) {\\n        if (matrix.empty()) return 0;\\n        \\n        int res = 0;\\n        vector<vector<int>> tab(matrix.size(), vector<int>(matrix[0].size()));\\n\\n        for(int row = tab.size() - 1; row >= 0; --row) {\\n            for(int col = tab[0].size() - 1; col >= 0; --col) {\\n                if (col == matrix[0].size() - 1) {\\n                    tab[row][col] = matrix[row][col] == \\'0\\' ? 0 : 1;\\n                } else if (row == matrix.size() - 1) {\\n                    tab[row][col] = matrix[row][col] == \\'0\\' ? 0 : 1;\\n                } else if (matrix[row][col] == \\'0\\') {\\n                    tab[row][col] = 0;\\n                } else {\\n                    tab[row][col] = min(min(tab[row+1][col], tab[row][col+1]),\\n                                        tab[row+1][col+1]) + 1;\\n                }\\n                res = max(res, tab[row][col]);\\n            }\\n        }\\n        \\n        return res * res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61828,
                "title": "my-java-dp-ac-solution-simple-and-easy-to-understand-with-explanation",
                "content": "It's actually to keep recording the max n*n window at each cell of the matrix. \\nAt each cell, we define that the dynamic programming status at that cell is - if I am the most right-bottom guy of a square, how big the square I can build.  With this definition, this status will be transferrable to the guys, right, below, and right below me. \\n       \\n     public class Solution {\\n            public int maximalSquare(char[][] matrix) {\\n                \\n                //illegal check - no square can be formed\\n                if(matrix == null || matrix.length == 0) return 0;\\n                \\n                int result = 0;\\n                int[][] count = new int[matrix.length][matrix[0].length];\\n                \\n                //initialize first row and first column\\n                for(int i = 0; i < matrix.length; i ++) {\\n                    count[i][0] = matrix[i][0] == '0' ? 0 : 1;\\n                    result = Math.max(result, count[i][0]);\\n                }\\n                \\n                for(int i = 0; i < matrix[0].length; i ++) {\\n                    count[0][i] = matrix[0][i] == '0' ? 0 : 1;\\n                    result = Math.max(result, count[0][i]);\\n                }\\n                \\n                //start to transfer status to iterate each cell from (1, 1) to (m, n)\\n                //if i am a 0, the square stops, reset\\n                for(int i = 1; i < matrix.length; i++) {\\n                    for(int j = 1; j < matrix[0].length; j++) {\\n                        \\n                        //I break the square reset myself to zero\\n                        if(matrix[i][j] == '0') {\\n                            count[i][j] = 0;\\n                            continue;\\n                        }\\n                        \\n                        //if I am 1, it depends if I can grow the size of the square, if I have a 0 guy around me, \\n                        //I can only be a top left guy\\n                        if(count[i - 1][j - 1] == 0 || count[i - 1][j] == 0 || count[i][j - 1] == 0) {\\n                            count[i][j] = 1;\\n                        }\\n                        //if guys around are the same size, I can be the right-bottom guy of a bigger square\\n                        else if(count[i - 1][j - 1] == count[i - 1][j] && count[i - 1][j] == count[i][j - 1]) {\\n                            count[i][j] = count[i - 1][j - 1] + 1;\\n                        }\\n                        //guys around me not the same, I can only be the right-bottom guy of a least square\\n                        else {\\n                            count[i][j] = Math.min(Math.min(count[i - 1][j - 1], count[i - 1][j]), \\n                                                                                  count[i][j - 1]) + 1;\\n                        }\\n                        result = Math.max(result, count[i][j]);\\n                    }\\n                }\\n                return result * result;\\n            }\\n        }\\n\\nOf course, the last three if-else condition can be entirely removed by this line of code:\\nMath.min(Math.min(count[i - 1][j - 1], count[i - 1][j]), count[i][j - 1])  + 1, because it covers all situations we can think of. \\n\\n    public class Solution {\\n        public int maximalSquare(char[][] matrix) {\\n            \\n            if(matrix == null || matrix.length == 0) return 0;\\n            \\n            int result = 0;\\n            int[][] count = new int[matrix.length][matrix[0].length];\\n            \\n            for(int i = 0; i < matrix.length; i ++) {\\n                count[i][0] = matrix[i][0] == '0' ? 0 : 1;\\n                result = Math.max(result, count[i][0]);\\n            }\\n            \\n            for(int i = 0; i < matrix[0].length; i ++) {\\n                count[0][i] = matrix[0][i] == '0' ? 0 : 1;\\n                result = Math.max(result, count[0][i]);\\n            }\\n            \\n            \\n            for(int i = 1; i < matrix.length; i++) {\\n                for(int j = 1; j < matrix[0].length; j++) {\\n                    \\n                    if(matrix[i][j] == '0') {\\n                        count[i][j] = 0;\\n                        continue;\\n                    }\\n                    \\n                    count[i][j] = Math.min(Math.min(count[i - 1][j - 1], count[i - 1][j]), \\n                                                                          count[i][j - 1]) + 1;\\n                    result = Math.max(result, count[i][j]);\\n                }\\n            }\\n            return result * result;\\n        }\\n    }\\n\\nBut by breaking into the situation into sub pieces will help my think cautiously. \\n\\nIn addition, the space O(n^2) can be possibly downgraded to O(n)  or even O(1) with 3 pointers to the current value of guys to my left, left-above, and above, if needed.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n            public int maximalSquare(char[][] matrix) {\\n                \\n                //illegal check - no square can be formed\\n                if(matrix == null || matrix.length == 0) return 0;\\n                \\n                int result = 0;\\n                int[][] count = new int[matrix.length][matrix[0].length];\\n                \\n                //initialize first row and first column\\n                for(int i = 0; i < matrix.length; i ++) {\\n                    count[i][0] = matrix[i][0] == '0' ? 0 : 1;\\n                    result = Math.max(result, count[i][0]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 599908,
                "title": "c-solution-100-speed-and-space-with-detailed-explanation",
                "content": "```\\nWe use a dp matrix to solve.\\nthe ith,jth location tells us the length of the square formed.So finally I can return ans*ans to the caller function.\\nLet the input be:\\n\\t\\t\\n\\t\\t1 0 1 0 0\\n        1 0 1 1 1     <----------- INPUT MATRIX\\n        1 1 1 1 1\\n        1 0 0 1 0\\nHow to construct a dp matrix?\\nFirst try to figure out what you want. Here i want to find the maximum area(this can be found using max side as square are is side*side).\\nSo we buid the matrix by calculating the side length. \\nPosiible squares\\n\\n1\\n\\n11\\n11\\n\\n111\\n111\\n111\\n\\nAnd so on.We can build this bottom up using the formula if we encountered a 1 dp[i][j] =1+min(dp[i-1][j],min(dp[i-1][j-1],dp[i][j-1])).\\nSo what does the formula signify? Thig this visually->If i encounter a 1 i must know if there is a possibility for a bigger square length.\\n example\\n\\n 11\\n 11  here after encountering first 1 this is the maximal possible square however when encountering the last 1 use the formula and u get the side length.\\n  We have to create dp of size n+1 and m+1 cuz for the first row using the formula it will throw an error.You can solve this issue evn by usin if else statement.     \\n       0 0 0 0 0 0\\n       0 1 0 1 0 0\\n       0 1 0 1 1 1     <----------- DP MATRIX\\n       0 1 1 1 2 2\\n       0 1 0 0 1 0\\n\\n       We can see the maximum value is 2 thus the answer is 2*2 =4.\\n\\n\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n     int m = matrix.size();\\n    if(m==0) return 0;\\n    int n = matrix[0].size();\\n    \\n    vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\\n    \\n    int ret = 0;\\n    for(int i = 1; i <= m; i ++){\\n        for(int j = 1; j <= n; j ++){\\n            if(matrix[i-1][j-1] == \\'0\\'){\\n                dp[i][j] = 0;\\n            }else{\\n                dp[i][j] = 1 + min(dp[i-1][j], min(dp[i][j-1], dp[i-1][j-1]));\\n            }\\n            ret = max(ret, dp[i][j]);\\n        }\\n    }\\n    return ret*ret;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nWe use a dp matrix to solve.\\nthe ith,jth location tells us the length of the square formed.So finally I can return ans*ans to the caller function.\\nLet the input be:\\n\\t\\t\\n\\t\\t1 0 1 0 0\\n        1 0 1 1 1     <----------- INPUT MATRIX\\n        1 1 1 1 1\\n        1 0 0 1 0\\nHow to construct a dp matrix?\\nFirst try to figure out what you want. Here i want to find the maximum area(this can be found using max side as square are is side*side).\\nSo we buid the matrix by calculating the side length. \\nPosiible squares\\n\\n1\\n\\n11\\n11\\n\\n111\\n111\\n111\\n\\nAnd so on.We can build this bottom up using the formula if we encountered a 1 dp[i][j] =1+min(dp[i-1][j],min(dp[i-1][j-1],dp[i][j-1])).\\nSo what does the formula signify? Thig this visually->If i encounter a 1 i must know if there is a possibility for a bigger square length.\\n example\\n\\n 11\\n 11  here after encountering first 1 this is the maximal possible square however when encountering the last 1 use the formula and u get the side length.\\n  We have to create dp of size n+1 and m+1 cuz for the first row using the formula it will throw an error.You can solve this issue evn by usin if else statement.     \\n       0 0 0 0 0 0\\n       0 1 0 1 0 0\\n       0 1 0 1 1 1     <----------- DP MATRIX\\n       0 1 1 1 2 2\\n       0 1 0 0 1 0\\n\\n       We can see the maximum value is 2 thus the answer is 2*2 =4.\\n\\n\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n     int m = matrix.size();\\n    if(m==0) return 0;\\n    int n = matrix[0].size();\\n    \\n    vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\\n    \\n    int ret = 0;\\n    for(int i = 1; i <= m; i ++){\\n        for(int j = 1; j <= n; j ++){\\n            if(matrix[i-1][j-1] == \\'0\\'){\\n                dp[i][j] = 0;\\n            }else{\\n                dp[i][j] = 1 + min(dp[i-1][j], min(dp[i][j-1], dp[i-1][j-1]));\\n            }\\n            ret = max(ret, dp[i][j]);\\n        }\\n    }\\n    return ret*ret;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1632192,
                "title": "python-java-c-dp-image-visualized-explanation-o-mn-clean-and-easy-to-understand",
                "content": "* dp[i][j] denotes the side length of the square with (i, j) in the lower right corner\\n\\t* Intuitivly the 0-th row and the 0-th column of dp are exactly the same as matrix\\n\\t    *  **dp(0, j) = matrix(0, j)  for each j**\\n\\t\\t*  **dp(i, 0) = matrix(i, 0) for each i**\\n\\t* Recurrence formula is\\n\\t\\t*  **dp(i, j) = 0 if matrix(i, j) == 0 else min(dp(i - 1, j - 1), dp(i - 1, j), dp(i, j - 1)) + 1**\\n\\t*  Time Complexity: O(MN)\\n\\t*  **Space Complextiy: O(MN) or O(N) or O(min(M,N)) or O(1)**\\n\\t\\t*  Space Complextiy O(MN) is enough to AC, but if you are interested in space complexity optimization, you may continue to read.\\n\\t\\t*  Note that dp(i, ) only depends on dp(i - 1, ), so we only need to record the results of two rows of dp at most and reduce the space comlexity to O(N).\\n\\t\\t*  Furthermore we can rotate the matrix so that the number of columns is less than or equal to the number of rows, and then we reduce the space comlexity to O(min(M,N)).\\n\\t\\t*  **In python we can use matrix itself as dp and modify in-place, so that the extra space complexity is O(1)**\\n\\n* Note that base on the definition of dp, dp[-1][-1] is not always the maximum of dp\\n* In the picture, I only drew the case where the sides of the three squares are equal. If they are not equal, dp[i][j] will depend on the one with the smallest side of the three squares.\\n\\n![image](https://assets.leetcode.com/users/images/0f1b86ab-094c-42b2-afda-33010b9ab382_1639713376.5750165.jpeg)\\n![image](https://assets.leetcode.com/users/images/619c2b20-a453-4447-a99d-f7d16f11613f_1639713376.621323.jpeg)\\n\\n**If you hava any question, feel free to ask. If you like the solution or the explaination, Please UPVOTE!**\\n\\n**Python TC:O(MN) SC:O(MN)**\\n```\\nclass Solution(object):\\n    def maximalSquare(self, matrix):\\n        dp, ans = [[0] * len(matrix[0]) for row in matrix], 0\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if matrix[i][j] == \\'1\\':\\n                    dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1\\n                    ans = max(ans, dp[i][j] ** 2)\\n        return ans\\n```\\n**Python TC:O(MN) SC:O(N)**\\n```\\nclass Solution(object):\\n    def maximalSquare(self, matrix):\\n        dp, ans, dp_pre = [0] * len(matrix[0]), 0, 0\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if matrix[i][j] == \\'1\\':\\n                    if i == 0 or j == 0: \\n                        dp[j], dp_pre = 1, dp[j]\\n                    else:\\n                        dp[j], dp_pre = min(dp[j], dp[j - 1], dp_pre) + 1, dp[j]\\n                    ans = max(ans, dp[j] ** 2)\\n                else:\\n                    dp[j] = 0\\n        return ans\\n```\\n**Python TC:O(MN) SC:O(min(M, N))**\\n```\\nclass Solution(object):\\n    def maximalSquare(self, matrix):\\n        ans, dp_pre =  0, 0\\n        if len(matrix[0]) < len(matrix):\\n            dp = [0] * len(matrix[0])\\n            for i in range(len(matrix)):\\n                for j in range(len(matrix[0])):\\n                    if matrix[i][j] == \\'1\\':\\n                        if i == 0 or j == 0: \\n                            dp[j], dp_pre = 1, dp[j]\\n                        else:\\n                            dp[j], dp_pre = min(dp[j], dp[j - 1], dp_pre) + 1, dp[j]\\n                        ans = max(ans, dp[j] ** 2)\\n                    else:\\n                        dp[j] = 0\\n        else:\\n            dp = [0] * len(matrix)\\n            for i in range(len(matrix[0])):\\n                for j in range(len(matrix)):\\n                    if matrix[j][i] == \\'1\\':\\n                        if i == 0 or j == 0: \\n                            dp[j], dp_pre = 1, dp[j]\\n                        else:\\n                            dp[j], dp_pre = min(dp[j], dp[j - 1], dp_pre) + 1, dp[j]\\n                        ans = max(ans, dp[j] ** 2)\\n                    else:\\n                        dp[j] = 0\\n        return ans\\n```\\n**Python TC:O(MN) SC:O(1) In-Place**\\n```\\nclass Solution(object):\\n    def maximalSquare(self, matrix):\\n        dp, ans = matrix, 0\\n        for i in range(len(dp)):\\n            for j in range(len(dp[0])):\\n                dp[i][j] = int(dp[i][j])\\n                if i > 0 and j > 0 and dp[i][j]:\\n                    dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1\\n                ans = max(ans, dp[i][j] ** 2)\\n        return ans\\n```\\n\\n**C++ TC:O(MN) SC:O(MN)**\\n```\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        vector<vector<int>> dp(matrix.size(),vector<int>(matrix[0].size(),0));\\n        int ans = 0;\\n        for(int i = 0; i < matrix.size(); i++){\\n            for(int j = 0; j < matrix[0].size(); j ++){\\n                if(matrix[i][j] == \\'1\\'){\\n                    if(i == 0|| j == 0){\\n                        dp[i][j] = 1;\\n                    } else {\\n                        dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;\\n                    }\\n                    ans = max(ans, dp[i][j] * dp[i][j]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Java TC:O(MN) SC:O(MN)**\\n```\\nclass Solution {\\n    public int maximalSquare(char[][] matrix) {\\n        int[][] dp = new int[matrix.length][matrix[0].length];\\n        int ans = 0;\\n        for(int i = 0; i < matrix.length; i++){\\n            for(int j = 0; j < matrix[0].length; j ++){\\n                if(matrix[i][j] == \\'1\\'){\\n                    if(i == 0|| j == 0){\\n                        dp[i][j] = 1;\\n                    } else {\\n                        dp[i][j] = Math.min(Math.min(dp[i - 1][j - 1], dp[i - 1][j]), dp[i][j - 1]) + 1;\\n                    }\\n                    ans = Math.max(ans, dp[i][j] * dp[i][j]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n**Please UPVOTE!**",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maximalSquare(self, matrix):\\n        dp, ans = [[0] * len(matrix[0]) for row in matrix], 0\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if matrix[i][j] == \\'1\\':\\n                    dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1\\n                    ans = max(ans, dp[i][j] ** 2)\\n        return ans\\n```\n```\\nclass Solution(object):\\n    def maximalSquare(self, matrix):\\n        dp, ans, dp_pre = [0] * len(matrix[0]), 0, 0\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if matrix[i][j] == \\'1\\':\\n                    if i == 0 or j == 0: \\n                        dp[j], dp_pre = 1, dp[j]\\n                    else:\\n                        dp[j], dp_pre = min(dp[j], dp[j - 1], dp_pre) + 1, dp[j]\\n                    ans = max(ans, dp[j] ** 2)\\n                else:\\n                    dp[j] = 0\\n        return ans\\n```\n```\\nclass Solution(object):\\n    def maximalSquare(self, matrix):\\n        ans, dp_pre =  0, 0\\n        if len(matrix[0]) < len(matrix):\\n            dp = [0] * len(matrix[0])\\n            for i in range(len(matrix)):\\n                for j in range(len(matrix[0])):\\n                    if matrix[i][j] == \\'1\\':\\n                        if i == 0 or j == 0: \\n                            dp[j], dp_pre = 1, dp[j]\\n                        else:\\n                            dp[j], dp_pre = min(dp[j], dp[j - 1], dp_pre) + 1, dp[j]\\n                        ans = max(ans, dp[j] ** 2)\\n                    else:\\n                        dp[j] = 0\\n        else:\\n            dp = [0] * len(matrix)\\n            for i in range(len(matrix[0])):\\n                for j in range(len(matrix)):\\n                    if matrix[j][i] == \\'1\\':\\n                        if i == 0 or j == 0: \\n                            dp[j], dp_pre = 1, dp[j]\\n                        else:\\n                            dp[j], dp_pre = min(dp[j], dp[j - 1], dp_pre) + 1, dp[j]\\n                        ans = max(ans, dp[j] ** 2)\\n                    else:\\n                        dp[j] = 0\\n        return ans\\n```\n```\\nclass Solution(object):\\n    def maximalSquare(self, matrix):\\n        dp, ans = matrix, 0\\n        for i in range(len(dp)):\\n            for j in range(len(dp[0])):\\n                dp[i][j] = int(dp[i][j])\\n                if i > 0 and j > 0 and dp[i][j]:\\n                    dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1\\n                ans = max(ans, dp[i][j] ** 2)\\n        return ans\\n```\n```\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        vector<vector<int>> dp(matrix.size(),vector<int>(matrix[0].size(),0));\\n        int ans = 0;\\n        for(int i = 0; i < matrix.size(); i++){\\n            for(int j = 0; j < matrix[0].size(); j ++){\\n                if(matrix[i][j] == \\'1\\'){\\n                    if(i == 0|| j == 0){\\n                        dp[i][j] = 1;\\n                    } else {\\n                        dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;\\n                    }\\n                    ans = max(ans, dp[i][j] * dp[i][j]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int maximalSquare(char[][] matrix) {\\n        int[][] dp = new int[matrix.length][matrix[0].length];\\n        int ans = 0;\\n        for(int i = 0; i < matrix.length; i++){\\n            for(int j = 0; j < matrix[0].length; j ++){\\n                if(matrix[i][j] == \\'1\\'){\\n                    if(i == 0|| j == 0){\\n                        dp[i][j] = 1;\\n                    } else {\\n                        dp[i][j] = Math.min(Math.min(dp[i - 1][j - 1], dp[i - 1][j]), dp[i][j - 1]) + 1;\\n                    }\\n                    ans = Math.max(ans, dp[i][j] * dp[i][j]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 458717,
                "title": "javascript-solution-some-thoughts-on-breaking-down-dp-problems",
                "content": "### The idea\\nWe have seen many problems that are solved using the magic \"dp matrix\", but most of the explanations don\\'t quite explain what\\'s the intuition behind it all. After all, Dynamic programming is mostly a tool that serves to optimize recursions for better time complexity, and it is oftern called the bottom-up approach where recursion is called the top-down approach. But what does it mean by \"bottom-up\" and \"top-down\"? I will share my intuition on breaking down this particular dp problem, but I think the methodology can be shared with almost all dp problems.\\n1. Lets think of the recursive(top-down) apporach of this problem, the first thing comes to my mind is a dfs seach that explores from one number to the others. We can define `dfs(r, c)` and it should return the maximum square for a given row and column. Below is a very simple sample where we start the dfs from (0,0).\\n![image](https://assets.leetcode.com/users/aminick/image_1577089868.png)\\nWe see that the at (0,0), the result is 1, and it\\'s mainly because of the 0 gives it a constraint. We can do this for every number and find the maximum square.\\n\\n2. If you can understand the recursion apporach, you should automatically understand the dp because you already kind of did it. If I rotate the graph by 180 degree:\\n![image](https://assets.leetcode.com/users/aminick/image_1577090054.png)\\nEverything is exactly the same, except here, the original dfs(red), now becomes a simple up, left, diagonal check.\\nThe original backtracking(blue), now becomes the value for the cell. And the calculation is still the same. We are literally doing \"bottom-up\" work. We are building the result from the ground up.\\n\\n*please let me know if any of  these doesn\\'t make sense or possibly wrong! this is purely my own intuition.\\n\\n### Solution here\\n``` javascript\\nvar maximalSquare = function(matrix) {\\n    if (!matrix.length) return 0;\\n    let dp = new Array(matrix.length+1).fill(0).map(()=>new Array(matrix[0].length+1).fill(0));\\n    let max = 0;\\n    for (let r=1;r<dp.length;r++) { \\n        for (let c=1;c<dp[0].length;c++) {\\n            if (matrix[r-1][c-1]!=0) {\\n                dp[r][c] = Math.min(dp[r][c-1], dp[r-1][c], dp[r-1][c-1])+1;\\n                max = Math.max(dp[r][c], max);\\n            }\\n        }\\n    }\\n    return max**2;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\nvar maximalSquare = function(matrix) {\\n    if (!matrix.length) return 0;\\n    let dp = new Array(matrix.length+1).fill(0).map(()=>new Array(matrix[0].length+1).fill(0));\\n    let max = 0;\\n    for (let r=1;r<dp.length;r++) { \\n        for (let c=1;c<dp[0].length;c++) {\\n            if (matrix[r-1][c-1]!=0) {\\n                dp[r][c] = Math.min(dp[r][c-1], dp[r-1][c], dp[r-1][c-1])+1;\\n                max = Math.max(dp[r][c], max);\\n            }\\n        }\\n    }\\n    return max**2;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 61894,
                "title": "20-lines-c-solution-using-dynamic-programming",
                "content": "class Solution {\\n\\npublic:\\n\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        if(matrix.size()==0) return 0;\\n        int maxSq=0;\\n        int nRow=matrix.size();\\n        int nCol=matrix[0].size();\\n        vector<vector<int>> dp(nRow+1,vector<int>(nCol+1,0));\\n        //dp[i][j] represents max square ending at position (i-1, j-1)\\n        for(int i=1;i<=nRow;++i){\\n            for(int j=1;j<=nCol;++j){\\n                if(matrix[i-1][j-1]=='1'){\\n                    dp[i][j]=min(min(dp[i-1][j-1],dp[i-1][j]),dp[i][j-1])+1;\\n                    maxSq=max(maxSq,dp[i][j]);\\n                }\\n            }\\n        }\\n        return maxSq*maxSq;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n\\npublic:\\n\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        if(matrix.size()==0) return 0;\\n        int maxSq=0;\\n        int nRow=matrix.size();\\n        int nCol=matrix[0].size();\\n        vector<vector<int>> dp(nRow+1,vector<int>(nCol+1,0));\\n        //dp[i][j] represents max square ending at position (i-1, j-1)\\n        for(int i=1;i<=nRow;++i){\\n            for(int j=1;j<=nCol;++j){\\n                if(matrix[i-1][j-1]=='1'){\\n                    dp[i][j]=min(min(dp[i-1][j-1],dp[i-1][j]),dp[i][j-1])+1;\\n                    maxSq=max(maxSq,dp[i][j]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 710311,
                "title": "java-recursion-memo-iterative",
                "content": "At first,I looked at the grid as a graph:\\n\\n**1 0 1 0 0\\n1 0 1 1 1\\n1 1 1 1 1\\n1 0 0 1 0*\\n\\n![image](https://assets.leetcode.com/users/images/680a021e-c205-43bf-9022-a7d5669b1d1d_1593368038.1123123.png)\\n\\nConsider the 3x2 rectangle in above example shown in the figure above and enumerating them 1 to 6, we can see that starting at 1, it\\'ll be a complete square if all of its 3 neighbors, (2,4,and 5) are 1\\'s as well and continuing from them for each one of them individually the same things should follow, if any of the three neighbors dont exist it isnt a sqaure so you return the minimum of them, or if you visualize it as a graph you just have to find the the longest path among all the nodes where all the 3 neighbors exist, so basically the recurence relation comes down to F(current)=1+min(F(neighbor 1),F(neighbor 2), F(neighbor 3)), also as u can see from the graph, we have overlapping subproblems and hence the required memoization to prevent re-computing.\\n\\nThe top down approach to this question is like so:\\n\\n\\n```\\nclass Solution {\\n    Integer[][]c;\\n    public int maximalSquare(char[][] matrix) {\\n        if(matrix.length==0) return 0;\\n        int res=Integer.MIN_VALUE;\\n        c=new Integer[matrix.length][matrix[0].length];\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(matrix[i][j]==\\'1\\'){\\n                    res=Math.max(res,dfs(matrix,i,j));\\n                }\\n            }\\n        }\\n        return res*res;\\n        \\n    }\\n    public int dfs(char[][]matrix,int i,int j){\\n        if(i<0 || j<0 || i>=matrix.length || j>=matrix[0].length  || matrix[i][j]==\\'0\\') return 0;\\n        if(c[i][j]!=null) return c[i][j];\\n        return c[i][j]=1+Math.min(Math.min(dfs(matrix,i+1,j),dfs(matrix,i,j+1)),dfs(matrix,i+1,j+1));\\n        \\n    }\\n}\\n```\\n\\nIn iterative approach taking care of the topological ordering of states, you can notice that before calculating value of (i,j), we need values of states (i+1,j),(i,j+1),(i+1,j+1) computed, hence in iterative approach I start from the end as follows:\\n\\n```\\nclass Solution {\\n    public int maximalSquare(char[][] matrix) {\\n        if(matrix.length==0) return 0;\\n        int res=Integer.MIN_VALUE;\\n        int [][]d=new int[matrix.length+1][matrix[0].length+1];\\n        for(int i=d.length-2;i>=0;i--){\\n            for(int j=d[0].length-2;j>=0;j--){\\n                if(matrix[i][j]==\\'1\\'){\\n                    d[i][j]=1+Math.min(Math.min(d[i+1][j],d[i][j+1]),d[i+1][j+1]);\\n                    res=Math.max(res,d[i][j]);\\n                }\\n            }\\n        }\\n        return res*res;   \\n    }\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Integer[][]c;\\n    public int maximalSquare(char[][] matrix) {\\n        if(matrix.length==0) return 0;\\n        int res=Integer.MIN_VALUE;\\n        c=new Integer[matrix.length][matrix[0].length];\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(matrix[i][j]==\\'1\\'){\\n                    res=Math.max(res,dfs(matrix,i,j));\\n                }\\n            }\\n        }\\n        return res*res;\\n        \\n    }\\n    public int dfs(char[][]matrix,int i,int j){\\n        if(i<0 || j<0 || i>=matrix.length || j>=matrix[0].length  || matrix[i][j]==\\'0\\') return 0;\\n        if(c[i][j]!=null) return c[i][j];\\n        return c[i][j]=1+Math.min(Math.min(dfs(matrix,i+1,j),dfs(matrix,i,j+1)),dfs(matrix,i+1,j+1));\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maximalSquare(char[][] matrix) {\\n        if(matrix.length==0) return 0;\\n        int res=Integer.MIN_VALUE;\\n        int [][]d=new int[matrix.length+1][matrix[0].length+1];\\n        for(int i=d.length-2;i>=0;i--){\\n            for(int j=d[0].length-2;j>=0;j--){\\n                if(matrix[i][j]==\\'1\\'){\\n                    d[i][j]=1+Math.min(Math.min(d[i+1][j],d[i][j+1]),d[i+1][j+1]);\\n                    res=Math.max(res,d[i][j]);\\n                }\\n            }\\n        }\\n        return res*res;   \\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61811,
                "title": "clear-c-solution-no-extra-space-12-ms",
                "content": "A square with '1' means any '0' will interrupt counting of it's right/down/right-down, and '1' will 'inherit' the existing counting result. \\n\\nSine the target is a square, we shall take the smallest counting result from up/left/up-left.\\n\\nSo for each element '0', it doesn't inherit previous accumulated counting;<br>\\nAnd for each element '1', it takes the smallest number from left/up/left-up and add 1 to it \\n\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int rst = 0;\\n        for(int ii=0; ii<matrix.size(); ++ii)\\n        {\\n            for(int jj=0; jj<matrix[0].size(); ++jj)\\n            {\\n                int a = (ii&&jj) ? matrix[ii-1][jj-1] : 0;\\n                int b = (ii) ? matrix[ii-1][jj] : 0;\\n                int c = (jj) ? matrix[ii][jj-1] : 0;\\n\\n                matrix[ii][jj] = (matrix[ii][jj]>'0') ? (min(a, min(b, c))+1) : 0;\\n                \\n                rst = max(rst, matrix[ii][jj]*matrix[ii][jj]);\\n            }\\n        }\\n        return rst;\\n    }",
                "solutionTags": [],
                "code": "A square with '1' means any '0' will interrupt counting of it's right/down/right-down, and '1' will 'inherit' the existing counting result. \\n\\nSine the target is a square, we shall take the smallest counting result from up/left/up-left.\\n\\nSo for each element '0', it doesn't inherit previous accumulated counting;<br>\\nAnd for each element '1', it takes the smallest number from left/up/left-up and add 1 to it \\n\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int rst = 0;\\n        for(int ii=0; ii<matrix.size(); ++ii)\\n        {\\n            for(int jj=0; jj<matrix[0].size(); ++jj)\\n            {\\n                int a = (ii&&jj) ? matrix[ii-1][jj-1] : 0;\\n                int b = (ii) ? matrix[ii-1][jj] : 0;\\n                int c = (jj) ? matrix[ii][jj-1] : 0;\\n\\n                matrix[ii][jj] = (matrix[ii][jj]>'0') ? (min(a, min(b, c))+1) : 0;\\n                \\n                rst = max(rst, matrix[ii][jj]*matrix[ii][jj]);\\n            }\\n        }\\n        return rst;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 61845,
                "title": "9-lines-python-dp-solution-with-explaination",
                "content": "    def maximalSquare(self, matrix):\\n        dp, maxArea = [[0 for _1_ in range(len(matrix[0]))] for ___ in range(len(matrix))], 0\\n        for i in xrange(0, len(matrix)):\\n            for j in xrange(0, len(matrix[0])):\\n                if i == 0 or j == 0:\\n                    dp[i][j] = int(matrix[i][j])\\n                elif int(matrix[i][j]) == 1:\\n                    dp[i][j] = min(dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]) + 1\\n                maxArea = max(maxArea, dp[i][j])\\n        return maxArea*maxArea\\n\\n\\nWe define dp[i][j] the maximal ending at position (i, j). Thus, current state (`dp[i][j]`)depends on left (`dp[i][j - 1]`), up (`dp[i - 1][j]`), and left-up's (`dp[i - 1][j - 1]`) states. The current state equals to the minimum of these three states plus `matrix[i][j]` because any smaller value will lead to a smaller square (holes in somewhere). I use `maxArea` to track the maximal square. When `matrix[i][j] == '0'`, the maximal square ending at position (i, j) is obviously 0.\\n\\nRecurrence relation: \\n\\nFor `matrix[i][j] == 1`, `dp[i][j] = min(dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]) + int(matrix[i][j])`.\\n\\nFor `matrix[i][j] == 0`, `dp[i][j] = 0`",
                "solutionTags": [],
                "code": "    def maximalSquare(self, matrix):\\n        dp, maxArea = [[0 for _1_ in range(len(matrix[0]))] for ___ in range(len(matrix))], 0\\n        for i in xrange(0, len(matrix)):\\n            for j in xrange(0, len(matrix[0])):\\n                if i == 0 or j == 0:\\n                    dp[i][j] = int(matrix[i][j])\\n                elif int(matrix[i][j]) == 1:\\n                    dp[i][j] = min(dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]) + 1\\n                maxArea = max(maxArea, dp[i][j])\\n        return maxArea*maxArea\\n\\n\\nWe define dp[i][j] the maximal ending at position (i, j). Thus, current state (`dp[i][j]`)depends on left (`dp[i][j - 1]`), up (`dp[i - 1][j]`), and left-up's (`dp[i - 1][j - 1]`) states. The current state equals to the minimum of these three states plus `matrix[i][j]` because any smaller value will lead to a smaller square (holes in somewhere). I use `maxArea` to track the maximal square. When `matrix[i][j] == '0'`, the maximal square ending at position (i, j) is obviously 0.\\n\\nRecurrence relation: \\n\\nFor `matrix[i][j] == 1`, `dp[i][j] = min(dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]) + int(matrix[i][j])`.\\n\\nFor `matrix[i][j] == 0`, `dp[i][j] = 0`",
                "codeTag": "Python3"
            },
            {
                "id": 61925,
                "title": "share-my-concise-python-solution",
                "content": "    class Solution:\\n    # @param {character[][]} matrix\\n    # @return {integer}\\n    def maximalSquare(self, matrix):\\n        if not matrix: return 0\\n        m , n = len(matrix),len(matrix[0])\\n        dp = [[0 if matrix[i][j]=='0' else 1for j in xrange(n)]for i in xrange(m)]\\n        \\n        for i in xrange(1,m):\\n            for j in xrange(1,n):\\n                if matrix[i][j] =='1': dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1\\n                else: dp[i][j] = 0\\n        \\n        ans = max([max(i) for i in dp])\\n        return ans ** 2",
                "solutionTags": [],
                "code": "class Solution:\\n    # @param {character[][]}",
                "codeTag": "Java"
            },
            {
                "id": 1632285,
                "title": "python-1d-array-dp-optimisation-process-explained",
                "content": "### Introduction\\n\\nWe are given a `m x n` array `matrix` and we need to find the largest square such that all elements in this square is `\\'1\\'`.\\n\\n---\\n\\n### Approach 1: Brute Force\\n\\nSimple enough. For each coordinate `(x, y)` in `matrix`, we check if `matrix[x][y] == \\'1\\'`. If so, then we know that there exists a square at `(x, y)` that is at least `1 x 1` in size. We can then continue checking if a bigger square exists by looking at the adjacent coordinates of `(x, y)`.\\n\\n```python\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        result = 0\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                curr = 0  # current length of the square at (i, j)\\n                flag = True  # indicates if there still exists a valid square\\n                while flag:\\n                    for k in range(curr+1):\\n                        # check outer border of elements for \\'1\\'s.\\n                        \"\"\"\\n                        eg curr = 2, ie a valid 2x2 square exists\\n                        \\'O\\' is valid, check \\'X\\':\\n                        X X X\\n                        X O O\\n                        X O O\\n                        \"\"\"\\n                        if i < curr or j < curr or \\\\\\n                                matrix[i-curr][j-k] == \\'0\\' or \\\\\\n                                matrix[i-k][j-curr] == \\'0\\':\\n                            flag = False\\n                            break\\n                    curr += flag\\n                if curr > result:  # new maximum length of square obtained\\n                    result = curr\\n        return result*result  # area = length x length\\n```\\n\\n**TC: <img src=\"https://latex.codecogs.com/svg.image?O(mnk^{2})\" title=\"O(mnk^{2})\" />**, where `k` is the length of the maximal square, since the while loop will iterate from `curr = 0` to `curr = k+1`.\\n**SC: <img src=\"https://latex.codecogs.com/svg.image?O(1)\" title=\"O(1)\" />**, since no additional data structures were used.\\n\\n---\\n\\n### Approach 2: Obtaining DP Approach\\n\\nObviously, the brute force way of checking for valid squares isn\\'t very efficient. We need to think of another way to determine whether an `n x n` square is valid. For this, let\\'s start with the simplest non-trivial case: a `2 x 2` square.\\n\\nRecall from the brute force approach that the way we check for validity is by checking the outer border, i.e.:\\n\\n```text\\ne.g. curr = 1, i.e. a valid 1 x 1 square exists (matrix[x][y] == \\'1\\').\\n\\'O\\' is valid, check for \\'X\\':\\nX X\\nX O\\n```\\n\\nTo check for `\\'X\\'`, we would need to check if `matrix[x-1][y] == \\'1\\'`, `matrix[x][y-1] == \\'1\\'` and `matrix[x-1][y-1] == \\'1\\'`. Except, because of the way the outer for loops were written, note that **we have checked each of these before!** To reach `matrix[x][y]` would require us to loop over the previous indexes, which include all of `(x-1, y-1)`, `(x-1, y)` and `(x, y-1)`. If any of the previous indexes are `\\'0\\'`, then the maximal square that exists at `(x, y)` can only be a `1 x 1` square.\\n\\n```text\\nDifferent possible combinations of maximal square sizes in a 2x2 matrix\\ncomb   0 0   1 0   0 1   0 0   0 0   1 1   1 0   1 0   0 1   0 1   0 0   1 1   1 1   1 0   0 1   1 1\\n       0 0   0 0   0 0   1 0   0 1   0 0   1 0   0 1   1 0   0 1   1 1   1 0   0 1   1 1   1 1   1 1\\nno 1s  -0-   ----------1----------   ----------------2----------------   ----------3----------   -4-\\nsize   -------------------------------------------1-------------------------------------------   -2-\\n```\\n\\nNote the length of the maximal square for each possible combination. This can be **simplified and generalised** to the following equation:\\n\\n```text\\nLength of maximal square at:\\nmatrix[x-1][y-1]: a   matrix[x-1][y]: b\\n matrix[x][y-1]: c           \\'1\\'\\nLength of maximal square at matrix[x][y] (given matrix[x][y] == \\'1\\') is min(a, b, c) + 1\\n\\nExample matrix:\\n0 0 1 1 1\\n0 0 1 1 1\\n0 1 1 1 1\\n0 1 1 1 1\\nLength of maximal sqaures at:\\n\\tmatrix[2][3] = 2x2\\n\\tmatrix[2][4] = 3x3\\n\\tmatrix[3][3] = 2x2\\n\\tmatrix[3][4] = min(2x2, 3x3, 2x2) + 1 = 2x2 + 1 = 3x3\\n```\\n\\nTherefore, we can **store the length of the maximal squares at these coordinates in a separate matrix** and **retrieve it later for <img src=\"https://latex.codecogs.com/svg.image?O(1)\" title=\"O(1)\" /> computation**.\\n\\n```python\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        result = 0\\n        dp = [[0]*n for _ in range(m)]  # dp[x][y] is the length of the maximal square at (x, y)\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j] == \\'1\\':  # ensure this condition first\\n                    # perform computation, mind border restrictions\\n                    dp[i][j] = min(dp[i-1][j] if i > 0 else 0,\\n                                   dp[i][j-1] if j > 0 else 0,\\n                                   dp[i-1][j-1] if i > 0 and j > 0 else 0) + 1\\n                    if dp[i][j] > result:\\n                        result = dp[i][j]\\n        return result*result\\n```\\n\\n**TC: <img src=\"https://latex.codecogs.com/svg.image?O(mn)\" title=\"O(mn)\" />**, since the computation for valid maximal square takes <img src=\"https://latex.codecogs.com/svg.image?O(1)\" title=\"O(1)\" /> time.\\n**SC: <img src=\"https://latex.codecogs.com/svg.image?O(mn)\" title=\"O(mn)\" />**, due to the maintenance of the DP array.\\n\\n---\\n\\n### Approach 3: Intuitive Optimised DP\\n\\nIf we take some time to analyse the formula used for the computation of the length of the maximal square at `(x, y)`, we notice that we only ever use three different variables: `dp[x-1][y-1]`, `dp[x-1][y]` and `dp[x][y-1]`. These variables **only require 2 rows of DP arrays** for storage: the previous row `x - 1`, and the current row `x`. As such, instead of using a `m x n` DP array, we can use a `2 x n` DP array instead.\\n\\n```python\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        result = 0\\n        prev, curr = [0]*n, [0]*n\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j] == \\'1\\':\\n                    curr[j] = min(curr[j-1] if j > 0 else 0,\\n                                  prev[j-1] if j > 0 else 0,\\n                                  prev[j]) + 1\\n                    if curr[j] > result:\\n                        result = curr[j]\\n            prev, curr = curr, [0]*n\\n        return result*result\\n```\\n\\n**TC: <img src=\"https://latex.codecogs.com/svg.image?O(mn)\" title=\"O(mn)\" />**, as discussed previously.\\n**SC: <img src=\"https://latex.codecogs.com/svg.image?O(mn)\" title=\"O(mn)\" />**, due to the creation of `m` arrays of length `n`.\\n\\nThe implementation above does not actually optimise for space, but we can do so by setting `curr = prev`. Since the values in `prev` will not be used, we can simply override them.\\n\\n```python\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        result = 0\\n        prev, curr = [0]*n, [0]*n\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j] == \\'1\\':\\n                    curr[j] = min(curr[j-1] if j > 0 else 0,\\n                                  prev[j-1] if j > 0 else 0,\\n                                  prev[j]) + 1\\n                else:\\n                    curr[j] = 0  # reset curr[j]\\n                if curr[j] > result:\\n                    result = curr[j]\\n            prev, curr = curr, prev\\n        return result*result\\n```\\n\\n**TC: <img src=\"https://latex.codecogs.com/svg.image?O(mn)\" title=\"O(mn)\" />**, as discussed previously.\\n**SC: <img src=\"https://latex.codecogs.com/svg.image?O(2n)&space;\\\\approx&space;O(n)\" title=\"O(2n) \\\\approx O(n)\" />**. We only create 2 arrays of length `n` and alternate between them.\\n\\nWe can also write it in the following manner:\\n\\n```python\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        result = 0\\n        dp = [[0]*n for _ in range(2)]  # 2-rowed dp array\\n        for i in range(m):\\n            for j in range(n):\\n                # i%2 (or i&1) alternates between dp[0] and dp[1]\\n                dp[i%2][j] = 0 if matrix[i][j] == \\'0\\' else \\\\\\n                    (min(dp[i%2][j-1] if j > 0 else 0,\\n                        dp[1-i%2][j-1] if j > 0 else 0,\\n                        dp[1-i%2][j]) + 1)\\n                result = dp[i%2][j] if dp[i%2][j] > result else result\\n        return result*result\\n```\\n\\n**TC: <img src=\"https://latex.codecogs.com/svg.image?O(mn)\" title=\"O(mn)\" />**, as discussed previously.\\n**SC: <img src=\"https://latex.codecogs.com/svg.image?O(2n)&space;\\\\approx&space;O(n)\" title=\"O(2n) \\\\approx O(n)\" />**, as discussed previously.\\n\\n---\\n\\n### Approach 4: Optimised DP\\n\\nFinally, we can get rid of the need for 2D arrays. By applying the same computation on the same array, we can assert that the current value `dp[j]` points to the previous result `dp[i-1][j]`. `dp[j-1]` maps to `dp[i][j-1]`, since this value would have already been computed and replaced before we iterated to index `j`.\\n\\nThe only value which we do not have is `dp[i-1][j-1]`, which cannot simply be obtained from the array. As such, we will use **another variable to store `dp[i-1][j-1]]` specifically** for computation purposes.\\n\\n```python\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        m, n, result = len(matrix), len(matrix[0]), 0\\n        dp = [0]*n  # 1D array\\n        for i in range(m):\\n            prev = 0  # stores dp[i-1][j-1]\\n            for j in range(n):\\n                dp[j], prev = 0 if matrix[i][j] == \\'0\\' else \\\\\\n                    (min(dp[j],  # dp[j] -> dp[i-1][j]\\n                         dp[j-1] if j > 0 else 0,  # dp[j-1] -> dp[i][j-1]\\n                         prev)  # prev -> dp[i-1][j-1]\\n                    + 1), dp[j]\\n                result = dp[j] if dp[j] > result else result\\n        return result*result\\n```\\n\\n**TC: <img src=\"https://latex.codecogs.com/svg.image?O(mn)\" title=\"O(mn)\" />**, as discussed previously.\\n**SC: <img src=\"https://latex.codecogs.com/svg.image?O(n)\" title=\"O(n)\" />**, since we only maintain a 1D array.\\n\\n---\\n\\n### Conclusion\\n\\nPlease upvote if this has helped you! Appreciate any comments as well :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        result = 0\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                curr = 0  # current length of the square at (i, j)\\n                flag = True  # indicates if there still exists a valid square\\n                while flag:\\n                    for k in range(curr+1):\\n                        # check outer border of elements for \\'1\\'s.\\n                        \"\"\"\\n                        eg curr = 2, ie a valid 2x2 square exists\\n                        \\'O\\' is valid, check \\'X\\':\\n                        X X X\\n                        X O O\\n                        X O O\\n                        \"\"\"\\n                        if i < curr or j < curr or \\\\\\n                                matrix[i-curr][j-k] == \\'0\\' or \\\\\\n                                matrix[i-k][j-curr] == \\'0\\':\\n                            flag = False\\n                            break\\n                    curr += flag\\n                if curr > result:  # new maximum length of square obtained\\n                    result = curr\\n        return result*result  # area = length x length\\n```\n```text\\ne.g. curr = 1, i.e. a valid 1 x 1 square exists (matrix[x][y] == \\'1\\').\\n\\'O\\' is valid, check for \\'X\\':\\nX X\\nX O\\n```\n```text\\nDifferent possible combinations of maximal square sizes in a 2x2 matrix\\ncomb   0 0   1 0   0 1   0 0   0 0   1 1   1 0   1 0   0 1   0 1   0 0   1 1   1 1   1 0   0 1   1 1\\n       0 0   0 0   0 0   1 0   0 1   0 0   1 0   0 1   1 0   0 1   1 1   1 0   0 1   1 1   1 1   1 1\\nno 1s  -0-   ----------1----------   ----------------2----------------   ----------3----------   -4-\\nsize   -------------------------------------------1-------------------------------------------   -2-\\n```\n```text\\nLength of maximal square at:\\nmatrix[x-1][y-1]: a   matrix[x-1][y]: b\\n matrix[x][y-1]: c           \\'1\\'\\nLength of maximal square at matrix[x][y] (given matrix[x][y] == \\'1\\') is min(a, b, c) + 1\\n\\nExample matrix:\\n0 0 1 1 1\\n0 0 1 1 1\\n0 1 1 1 1\\n0 1 1 1 1\\nLength of maximal sqaures at:\\n\\tmatrix[2][3] = 2x2\\n\\tmatrix[2][4] = 3x3\\n\\tmatrix[3][3] = 2x2\\n\\tmatrix[3][4] = min(2x2, 3x3, 2x2) + 1 = 2x2 + 1 = 3x3\\n```\n```python\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        result = 0\\n        dp = [[0]*n for _ in range(m)]  # dp[x][y] is the length of the maximal square at (x, y)\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j] == \\'1\\':  # ensure this condition first\\n                    # perform computation, mind border restrictions\\n                    dp[i][j] = min(dp[i-1][j] if i > 0 else 0,\\n                                   dp[i][j-1] if j > 0 else 0,\\n                                   dp[i-1][j-1] if i > 0 and j > 0 else 0) + 1\\n                    if dp[i][j] > result:\\n                        result = dp[i][j]\\n        return result*result\\n```\n```python\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        result = 0\\n        prev, curr = [0]*n, [0]*n\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j] == \\'1\\':\\n                    curr[j] = min(curr[j-1] if j > 0 else 0,\\n                                  prev[j-1] if j > 0 else 0,\\n                                  prev[j]) + 1\\n                    if curr[j] > result:\\n                        result = curr[j]\\n            prev, curr = curr, [0]*n\\n        return result*result\\n```\n```python\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        result = 0\\n        prev, curr = [0]*n, [0]*n\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j] == \\'1\\':\\n                    curr[j] = min(curr[j-1] if j > 0 else 0,\\n                                  prev[j-1] if j > 0 else 0,\\n                                  prev[j]) + 1\\n                else:\\n                    curr[j] = 0  # reset curr[j]\\n                if curr[j] > result:\\n                    result = curr[j]\\n            prev, curr = curr, prev\\n        return result*result\\n```\n```python\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        result = 0\\n        dp = [[0]*n for _ in range(2)]  # 2-rowed dp array\\n        for i in range(m):\\n            for j in range(n):\\n                # i%2 (or i&1) alternates between dp[0] and dp[1]\\n                dp[i%2][j] = 0 if matrix[i][j] == \\'0\\' else \\\\\\n                    (min(dp[i%2][j-1] if j > 0 else 0,\\n                        dp[1-i%2][j-1] if j > 0 else 0,\\n                        dp[1-i%2][j]) + 1)\\n                result = dp[i%2][j] if dp[i%2][j] > result else result\\n        return result*result\\n```\n```python\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        m, n, result = len(matrix), len(matrix[0]), 0\\n        dp = [0]*n  # 1D array\\n        for i in range(m):\\n            prev = 0  # stores dp[i-1][j-1]\\n            for j in range(n):\\n                dp[j], prev = 0 if matrix[i][j] == \\'0\\' else \\\\\\n                    (min(dp[j],  # dp[j] -> dp[i-1][j]\\n                         dp[j-1] if j > 0 else 0,  # dp[j-1] -> dp[i][j-1]\\n                         prev)  # prev -> dp[i-1][j-1]\\n                    + 1), dp[j]\\n                result = dp[j] if dp[j] > result else result\\n        return result*result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519235,
                "title": "java-tc-o-mn-sc-o-min-m-n-space-optimized-dp-solution",
                "content": "```java\\n/**\\n * Space optimized Dynamic Programming solution\\n *\\n * DP[i][j] = Maximal size (square = size*size) of the square that can be formed ending at point (i,j).\\n *\\n * Time Complexity: O(M * N)\\n *\\n * Space Complexity: O(min(M, N))\\n *\\n * M = Number of rows. N = Number of columns.\\n */\\nclass Solution {\\n    public int maximalSquare(char[][] matrix) {\\n        if (matrix == null) {\\n            throw new IllegalArgumentException(\"Input is null\");\\n        }\\n        if (matrix.length == 0 || matrix[0].length == 0) {\\n            return 0;\\n        }\\n\\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n\\n        if (rows < cols) {\\n            return maximalSquareHelper(matrix, cols, rows, false);\\n        } else {\\n            return maximalSquareHelper(matrix, rows, cols, true);\\n        }\\n    }\\n\\n    private int maximalSquareHelper(char[][] matrix, int big, int small, boolean isColsSmall) {\\n        int[] dp = new int[small + 1];\\n        int maxSide = 0;\\n        for (int j = 1; j <= big; j++) {\\n            int prev = dp[0]; // Since we have added a padding in-front, dp[0] will always be zero\\n            for (int i = 1; i <= small; i++) {\\n                int temp = dp[i];\\n                if ((isColsSmall && matrix[j - 1][i - 1] == \\'0\\') || (!isColsSmall && matrix[i - 1][j - 1] == \\'0\\')) {\\n                    dp[i] = 0;\\n                } else {\\n                    dp[i] = Math.min(prev, Math.min(dp[i], dp[i - 1])) + 1;\\n                    maxSide = Math.max(maxSide, dp[i]);\\n                }\\n                prev = temp;\\n            }\\n        }\\n        return maxSide * maxSide;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other similar question on LeetCode:\\n- [72. Edit Distance](https://leetcode.com/problems/edit-distance/discuss/1519242/Java-or-TC:-O(MN)-or-SC:-O(min(MN))-or-Space-Optimized-DP-Solution)\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```java\\n/**\\n * Space optimized Dynamic Programming solution\\n *\\n * DP[i][j] = Maximal size (square = size*size) of the square that can be formed ending at point (i,j).\\n *\\n * Time Complexity: O(M * N)\\n *\\n * Space Complexity: O(min(M, N))\\n *\\n * M = Number of rows. N = Number of columns.\\n */\\nclass Solution {\\n    public int maximalSquare(char[][] matrix) {\\n        if (matrix == null) {\\n            throw new IllegalArgumentException(\"Input is null\");\\n        }\\n        if (matrix.length == 0 || matrix[0].length == 0) {\\n            return 0;\\n        }\\n\\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n\\n        if (rows < cols) {\\n            return maximalSquareHelper(matrix, cols, rows, false);\\n        } else {\\n            return maximalSquareHelper(matrix, rows, cols, true);\\n        }\\n    }\\n\\n    private int maximalSquareHelper(char[][] matrix, int big, int small, boolean isColsSmall) {\\n        int[] dp = new int[small + 1];\\n        int maxSide = 0;\\n        for (int j = 1; j <= big; j++) {\\n            int prev = dp[0]; // Since we have added a padding in-front, dp[0] will always be zero\\n            for (int i = 1; i <= small; i++) {\\n                int temp = dp[i];\\n                if ((isColsSmall && matrix[j - 1][i - 1] == \\'0\\') || (!isColsSmall && matrix[i - 1][j - 1] == \\'0\\')) {\\n                    dp[i] = 0;\\n                } else {\\n                    dp[i] = Math.min(prev, Math.min(dp[i], dp[i - 1])) + 1;\\n                    maxSide = Math.max(maxSide, dp[i]);\\n                }\\n                prev = temp;\\n            }\\n        }\\n        return maxSide * maxSide;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3227575,
                "title": "221-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis problem can be solved using dynamic programming. We can define a 2D array dp where dp[i][j] represents the maximum size of a square that can be formed at position (i, j) such that all its elements are 1\\'s. We can fill this array using the following recurrence relation:\\n\\n- dp[i][j] = 0 if matrix[i][j] == \\'0\\'\\n- dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 if matrix[i][j] == \\'1\\'\\n\\nThe first condition means that if the current cell has a value of 0, we can\\'t form a square with it. The second condition means that if the current cell has a value of 1, we can form a square with it, but we need to check the values of the cells to the left, top, and top-left of it to determine the maximum size of the square.\\n\\nWe also need to keep track of the maximum size of the square seen so far, and return its area.\\n\\n# Complexity\\n- Time complexity:\\nBeats\\n88.37% O(m*n), where m and n are the dimensions of the matrix.\\n\\n- Space complexity:\\nBeats\\n88.43% O(m*n), where m and n are the dimensions of the matrix, since we are using a 2D array of the same size as the matrix to store the dp values.\\n\\n# Code\\n```\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        # Get the dimensions of the matrix\\n        m, n = len(matrix), len(matrix[0])\\n        \\n        # Initialize the dp array\\n        dp = [[0] * n for _ in range(m)]\\n        \\n        # Initialize the max size of the square seen so far\\n        max_size = 0\\n        \\n        # Fill the dp array\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j] == \\'1\\':\\n                    if i == 0 or j == 0:\\n                        # First row or column, so the maximum size of the square is 1\\n                        dp[i][j] = 1\\n                    else:\\n                        # Check the values of the cells to the left, top, and top-left of the current cell\\n                        dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\\n                    \\n                    # Update the max size of the square seen so far\\n                    max_size = max(max_size, dp[i][j])\\n        \\n        # Return the area of the largest square\\n        return max_size * max_size\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        # Get the dimensions of the matrix\\n        m, n = len(matrix), len(matrix[0])\\n        \\n        # Initialize the dp array\\n        dp = [[0] * n for _ in range(m)]\\n        \\n        # Initialize the max size of the square seen so far\\n        max_size = 0\\n        \\n        # Fill the dp array\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j] == \\'1\\':\\n                    if i == 0 or j == 0:\\n                        # First row or column, so the maximum size of the square is 1\\n                        dp[i][j] = 1\\n                    else:\\n                        # Check the values of the cells to the left, top, and top-left of the current cell\\n                        dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\\n                    \\n                    # Update the max size of the square seen so far\\n                    max_size = max(max_size, dp[i][j])\\n        \\n        # Return the area of the largest square\\n        return max_size * max_size\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61912,
                "title": "my-c-code-8ms-dp-o-n-2-time-o-n-space",
                "content": "The basic idea is to do DP: scan the matrix row by row (top down) and colume by colume (left to right) and for the position [i][j], the maximum square with the bottom-right corner sitting at [i][j] will have the edge length of \\n\\n    area[i][j]  = 0 if matrix[i][j] = '0'\\n                   = min(area[i-1][j-1], area[i][j-1], area[i-1][j]) + 1 if matrix[i][j] = '1'\\n\\nFor the case that  matrix[i][j] = '1', the algorithm tries to grow the  square sitting at [i-1][j-1], area[i-1][j-1] by 1. However, it is also limitted by the bottom edge at row i and right edge at col j, which was represented by area[i][j-1] and area[i-1][j] repectively. We have to choose the min of those three values.\\n\\nThe DP table works on a ping-pong mode to save memory since the area recursive equation only relys on i and i-1 rows.\\n\\n    class Solution {\\n    public:\\n        int maximalSquare(vector<vector<char>>& matrix) {\\n            int maxA = 0;\\n            const int m = matrix.size();\\n            if(!m) return maxA;\\n            const int n = matrix[0].size();\\n            if(!n) return maxA;\\n            int area[2][n]; // DP table to save the maximum square (with bottom-right corner at [i][j]) edge length \\n            int cur = 0, next =1; // ping-pog switch index\\n            fill_n(area[0],n,0);\\n    \\n            int i, j;\\n            \\n            for(i=0;i<m;i++)\\n            {\\n                area[next][0] = matrix[i][0] == '1'; // the first colume\\n                for(j=1; j<n; j++)\\n                    area[next][j] = matrix[i][j]=='1'? (min(area[cur][j-1],min(area[next][j-1],area[cur][j])) + 1):0; //DP update\\n                for(j=0; j<n && maxA<=i; j++) if(maxA<area[next][j]) maxA = area[next][j]; // find the maximum square for the current row\\n                cur = next;\\n                next = 1-cur;\\n            }\\n            return maxA * maxA;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maximalSquare(vector<vector<char>>& matrix) {\\n            int maxA = 0;\\n            const int m = matrix.size();\\n            if(!m) return maxA;\\n            const int n = matrix[0].size();\\n            if(!n) return maxA;\\n            int area[2][n]; // DP table to save the maximum square (with bottom-right corner at [i][j]) edge length \\n            int cur = 0, next =1; // ping-pog switch index\\n            fill_n(area[0],n,0);\\n    \\n            int i, j;\\n            \\n            for(i=0;i<m;i++)\\n            {\\n                area[next][0] = matrix[i][0] == '1'; // the first colume\\n                for(j=1; j<n; j++)\\n                    area[next][j] = matrix[i][j]=='1'? (min(area[cur][j-1],min(area[next][j-1],area[cur][j])) + 1):0; //DP update\\n                for(j=0; j<n && maxA<=i; j++) if(maxA<area[next][j]) maxA = area[next][j]; // find the maximum square for the current row\\n                cur = next;\\n                next = 1-cur;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 600427,
                "title": "simplest-o-1-space-javascript-solution",
                "content": "```\\n/**\\n * @param {character[][]} matrix\\n * @return {number}\\n */\\nvar maximalSquare = function (matrix) {\\n  let max = 0\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[0].length; j++) {\\n      if (matrix[i][j] === \"0\") continue\\n      if(i > 0 && j > 0)\\n        matrix[i][j] = Math.min(matrix[i - 1][j], matrix[i][j - 1], matrix[i - 1][j - 1]) + 1\\n      max = Math.max(matrix[i][j], max)\\n    }\\n  }\\n  return max ** 2\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {character[][]} matrix\\n * @return {number}\\n */\\nvar maximalSquare = function (matrix) {\\n  let max = 0\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[0].length; j++) {\\n      if (matrix[i][j] === \"0\") continue\\n      if(i > 0 && j > 0)\\n        matrix[i][j] = Math.min(matrix[i - 1][j], matrix[i][j - 1], matrix[i - 1][j - 1]) + 1\\n      max = Math.max(matrix[i][j], max)\\n    }\\n  }\\n  return max ** 2\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 61909,
                "title": "python-solutions-o-m-n-o-2-n-space",
                "content": "        \\n    # O((m+1)*(n+1)) space, one pass\\n    def maximalSquare1(self, matrix):\\n        if not matrix:\\n            return 0\\n        r, c = len(matrix), len(matrix[0])\\n        dp = [[0 for i in xrange(c+1)] for j in xrange(r+1)]\\n        res = 0\\n        for i in xrange(r):\\n            for j in xrange(c):\\n                dp[i+1][j+1] = (min(dp[i][j], dp[i+1][j], dp[i][j+1])+1)*int(matrix[i][j])\\n                res = max(res, dp[i+1][j+1]**2)\\n        return res\\n        \\n    # O(m*n) space, one pass  \\n    def maximalSquare2(self, matrix):\\n        if not matrix:\\n            return 0\\n        r, c = len(matrix), len(matrix[0])\\n        dp = [[int(matrix[i][j]) for j in xrange(c)] for i in xrange(r)]\\n        res = max(max(dp))\\n        for i in xrange(1, r):\\n            for j in xrange(1, c):\\n                dp[i][j] = (min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j])+1)*int(matrix[i][j])\\n                res = max(res, dp[i][j]**2)\\n        return res\\n        \\n    # O(2*n) space    \\n    def maximalSquare(self, matrix):\\n        if not matrix:\\n            return 0\\n        r, c = len(matrix), len(matrix[0])\\n        pre = cur = [0] * (c+1)\\n        res = 0\\n        for i in xrange(r):\\n            for j in xrange(c):\\n                cur[j+1] = (min(pre[j], pre[j+1], cur[j])+1)*int(matrix[i][j])\\n                res = max(res, cur[j+1]**2)\\n            pre = cur\\n            cur = [0] * (c+1)\\n        return res",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "        \\n    # O((m+1)*(n+1)) space, one pass\\n    def maximalSquare1(self, matrix):\\n        if not matrix:\\n            return 0\\n        r, c = len(matrix), len(matrix[0])\\n        dp = [[0 for i in xrange(c+1)] for j in xrange(r+1)]\\n        res = 0\\n        for i in xrange(r):\\n            for j in xrange(c):\\n                dp[i+1][j+1] = (min(dp[i][j], dp[i+1][j], dp[i][j+1])+1)*int(matrix[i][j])\\n                res = max(res, dp[i+1][j+1]**2)\\n        return res\\n        \\n    # O(m*n) space, one pass  \\n    def maximalSquare2(self, matrix):\\n        if not matrix:\\n            return 0\\n        r, c = len(matrix), len(matrix[0])\\n        dp = [[int(matrix[i][j]) for j in xrange(c)] for i in xrange(r)]\\n        res = max(max(dp))\\n        for i in xrange(1, r):\\n            for j in xrange(1, c):\\n                dp[i][j] = (min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j])+1)*int(matrix[i][j])\\n                res = max(res, dp[i][j]**2)\\n        return res\\n        \\n    # O(2*n) space    \\n    def maximalSquare(self, matrix):\\n        if not matrix:\\n            return 0\\n        r, c = len(matrix), len(matrix[0])\\n        pre = cur = [0] * (c+1)\\n        res = 0\\n        for i in xrange(r):\\n            for j in xrange(c):\\n                cur[j+1] = (min(pre[j], pre[j+1], cur[j])+1)*int(matrix[i][j])\\n                res = max(res, cur[j+1]**2)\\n            pre = cur\\n            cur = [0] * (c+1)\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 1076341,
                "title": "python-3-dynamic-programming-using-both-top-down-and-bottom-up-approach-with-comments",
                "content": "class Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n\\n#TOP-DOWN = Recursion \\n\\n        ROWS, COLS = len(matrix), len(matrix[0])  # initialization\\n        dp = {} # initialization of map \\n        \\n        def helper(r,c) : \\n            if r>= ROWS or c>= COLS : return 0 # if the Val of Rows or Cols goes beyond the limit - > return 0 / Null Value \\n\\n            if (r,c) not in dp: # if the points which are to the right, down, digonally down right are not visited again traverse through them\\n                down = helper(r+1,c)\\n                right = helper(r,c+1) \\n                diag = helper(r+1, c+1) \\n\\n                dp[(r,c)] = 0 #basically initialize them with 0\\n\\n                if matrix[r][c] == \"1\" : # if the current node is 1\\n                    dp[(r,c)] = 1+min(down,right,diag) # add the cache value to the min value + 1, as the current val is also 1 \\n                    # if we add max value .. some other node value can be 0 and it will be missed\\n            return dp[(r,c)] #return the cache value\\n        \\n        helper(0,0)\\n        return max(dp.values()) **2 # from the cache we need to find the max and **2 as it is a square \\n        \\n#BOTTOM - UP = Using FOR LOOP \\n#Without using extra space \\n        \\n        m,n = len(matrix) , len(matrix[0]) \\n        Mx = 0 # initializing the max Value as 0\\n        \\n        for i in matrix[0] : #checking the first row, if it contains 1 the initialize the max value as 1\\n            if i == \"1\" : \\n                Mx = 1 \\n                break \\n        \\n        if Mx == 0: # if still the max value remains 0 \\n            for i in range(m) : # checking the first col\\n                if matrix[i][0] == \"1\" : \\n                    Mx = 1\\n                    break \\n        \\n        for i in range(1,m) :\\n            for j in range(1,n) : \\n                if matrix[i][j] == \"1\" : \\n                    \\'\\'\\'\\n                        if value is 1 : \\n                            check the left, top and top left diagonal \\n                            compute the min value and add 1(as it the current value)\\n                        compute the max of  the current node value and the Mx value\\n                    \\'\\'\\'\\n                    x = int(matrix[i-1][j])\\n                    y = int(matrix[i][j-1]) \\n                    z = int(matrix[i-1][j-1])\\n                    matrix[i][j] = str(1+min(x,y,z))\\n                Mx = max(int(matrix[i][j]),Mx)\\n        return Mx**2 # **2 as it is a square\\n            \\n            \\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "class Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n\\n#TOP-DOWN = Recursion \\n\\n        ROWS, COLS = len(matrix), len(matrix[0])  # initialization\\n        dp = {}",
                "codeTag": "Java"
            },
            {
                "id": 817156,
                "title": "python-easy-going-from-brute-force-to-dp-solution",
                "content": "# Brute Force thinking process:\\nInitial thought process when constructing the main function `maximalSquare`:\\n- Starting with visiting every element/node of the 2D array. This would take 2 for loops and for arbitray starting point I will start from top-left corner\\n- I am interested in the current 2D array element only if it\\'s 1 as if it\\'s 0 it will not contribute to any square.\\n- I will have a helper function which would return the length of square from the perspective of current  `(i, j)` index\\n- I will have max here for storing only the max length\\n- When we exhaust all indexes, return the square of max length for area\\n\\nConstructing the helper function `getLength`:\\n- As I am starting from top-left corner, I have to check other three boxes for 1\\'s. There will be a valid square at current index only if we have 1 at `(i, j)` and have 1 at `(i+1,j), (i, j+1), (i+1, j+1)`. So in code, I will have an outer if statement checking for current `(i, j)`  for 1 and the inside I can simply return `1 + min(three indexes we want to explore)`.\\n- As the matrix is always square we don\\'t have to worry about rectangle edge cases and can have a `default 0` return case at the end if the pointers go out of bounds.\\n\\nResult: Time Limit Exceeded (Would work in Java or C++)\\n```\\nclass Solution(object):\\n    def maximalSquare(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        if not matrix:\\n            return 0\\n        \\n        maxRows = len(matrix)\\n        maxCols = len(matrix[0])\\n        maxLength = 0\\n        for i in range(maxRows):\\n            for j in range(maxCols):\\n                if matrix[i][j] == \\'1\\':\\n                    length = self.getLength(matrix, i, j, maxRows, maxCols)\\n                    maxLength = max(length, maxLength)\\n        return maxLength**2\\n        \\n    def getLength(self, matrix, row, col, maxRows, maxCols):\\n        # We can get away with simple \\'and\\' condition as the matrix is always square and never a rectangle\\n        if 0 <= row < maxRows and 0 <= col < maxCols:\\n            if matrix[row][col] == \\'1\\':\\n                return 1 + min(\\n                                self.getLength(matrix, row+1, col, maxRows, maxCols),\\n                                self.getLength(matrix, row, col+1, maxRows, maxCols),\\n                                self.getLength(matrix, row+1, col+1, maxRows, maxCols)\\n                              )\\n            \\n        # if we are at the end of array or matrix[i][j] is zero, we don\\'t have to explore further and we can return 0\\n        return 0\\n```\\n\\n# Optimising by storing sub-values (Memoization) approach:\\n- Rather than solving same subproblems again at each location when we are explorating, we can instead store the results for future use\\n- Using a `memArr` of size matrix to store subproblem solution\\n- In the helper function (`getLength`) of the brute-force solution I will instead check if\\n\\t- `memArr(i, j)` is filled if so I will return the sub-answer as the problem is already solved\\n\\t- `memArr(i,j)` is not filled and the current entry is \\'1\\': Explore neighbours to get answer and store in `memArr(i,j)`\\n\\t- If entry is 0 or we if the row, col indexes are out of boundary, return 0\\n- Same logic of maxLength and returning square as above\\n\\n\\nResult: Accepted, faster than 30.64% of Python submission and memory usage less than 9.13% Python solutions\\n```\\nclass Solution(object):\\n    def maximalSquare(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        if not matrix:\\n            return 0\\n        \\n        maxRows = len(matrix)\\n        maxCols = len(matrix[0])\\n        maxLength = 0\\n        \\n        memArr = [[\\'-1\\' for _ in range(maxCols)] for _ in range(maxRows)]\\n        \\n        for i in range(maxRows):\\n            for j in range(maxCols):\\n                if matrix[i][j] == \\'1\\':\\n                    length = self.getLength(matrix, i, j, maxRows, maxCols, memArr)\\n                    maxLength = max(length, maxLength)\\n        return maxLength**2\\n        \\n    def getLength(self, matrix, row, col, maxRows, maxCols, memArr):\\n        # We can get away with simple \\'and\\' condition as the matrix is always square and never a rectangle\\n        if 0 <= row < maxRows and 0 <= col < maxCols:\\n            if memArr[row][col] != \\'-1\\':\\n                return memArr[row][col]\\n            \\n            if matrix[row][col] == \\'1\\':\\n                memArr[row][col] = 1 + min(\\n                                self.getLength(matrix, row+1, col, maxRows, maxCols, memArr),\\n                                self.getLength(matrix, row, col+1, maxRows, maxCols, memArr),\\n                                self.getLength(matrix, row+1, col+1, maxRows, maxCols, memArr)\\n                              )\\n            else:\\n                memArr[row][col] = 0\\n                \\n            return memArr[row][col]\\n\\n        return 0\\n```\\n\\n# Dyanamic Programming approach:\\n- I constructed a 2D array with size `(maxRows + 1, maxCols + 1)` and started solving Memoization way and how I can store the values in new array and use the previous values \\n```\\nclass Solution(object):\\n    def maximalSquare(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        if not matrix:\\n            return 0\\n        \\n        maxRows = len(matrix)\\n        maxCols = len(matrix[0])\\n        maxLength = 0\\n        dp = [[0 for _ in range(maxCols + 1)] for _ in range(maxRows + 1)]\\n        for row in range(1, maxRows + 1):\\n            for col in range(1, maxCols + 1):\\n                if matrix[row-1][col-1] == \\'1\\':\\n                    dp[row][col] = min(dp[row-1][col-1], dp[row-1][col], dp[row][col-1]) + 1\\n                    maxLength = max(maxLength, dp[row][col])\\n        return maxLength**2\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution(object):\\n    def maximalSquare(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        if not matrix:\\n            return 0\\n        \\n        maxRows = len(matrix)\\n        maxCols = len(matrix[0])\\n        maxLength = 0\\n        for i in range(maxRows):\\n            for j in range(maxCols):\\n                if matrix[i][j] == \\'1\\':\\n                    length = self.getLength(matrix, i, j, maxRows, maxCols)\\n                    maxLength = max(length, maxLength)\\n        return maxLength**2\\n        \\n    def getLength(self, matrix, row, col, maxRows, maxCols):\\n        # We can get away with simple \\'and\\' condition as the matrix is always square and never a rectangle\\n        if 0 <= row < maxRows and 0 <= col < maxCols:\\n            if matrix[row][col] == \\'1\\':\\n                return 1 + min(\\n                                self.getLength(matrix, row+1, col, maxRows, maxCols),\\n                                self.getLength(matrix, row, col+1, maxRows, maxCols),\\n                                self.getLength(matrix, row+1, col+1, maxRows, maxCols)\\n                              )\\n            \\n        # if we are at the end of array or matrix[i][j] is zero, we don\\'t have to explore further and we can return 0\\n        return 0\\n```\n```\\nclass Solution(object):\\n    def maximalSquare(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        if not matrix:\\n            return 0\\n        \\n        maxRows = len(matrix)\\n        maxCols = len(matrix[0])\\n        maxLength = 0\\n        \\n        memArr = [[\\'-1\\' for _ in range(maxCols)] for _ in range(maxRows)]\\n        \\n        for i in range(maxRows):\\n            for j in range(maxCols):\\n                if matrix[i][j] == \\'1\\':\\n                    length = self.getLength(matrix, i, j, maxRows, maxCols, memArr)\\n                    maxLength = max(length, maxLength)\\n        return maxLength**2\\n        \\n    def getLength(self, matrix, row, col, maxRows, maxCols, memArr):\\n        # We can get away with simple \\'and\\' condition as the matrix is always square and never a rectangle\\n        if 0 <= row < maxRows and 0 <= col < maxCols:\\n            if memArr[row][col] != \\'-1\\':\\n                return memArr[row][col]\\n            \\n            if matrix[row][col] == \\'1\\':\\n                memArr[row][col] = 1 + min(\\n                                self.getLength(matrix, row+1, col, maxRows, maxCols, memArr),\\n                                self.getLength(matrix, row, col+1, maxRows, maxCols, memArr),\\n                                self.getLength(matrix, row+1, col+1, maxRows, maxCols, memArr)\\n                              )\\n            else:\\n                memArr[row][col] = 0\\n                \\n            return memArr[row][col]\\n\\n        return 0\\n```\n```\\nclass Solution(object):\\n    def maximalSquare(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        if not matrix:\\n            return 0\\n        \\n        maxRows = len(matrix)\\n        maxCols = len(matrix[0])\\n        maxLength = 0\\n        dp = [[0 for _ in range(maxCols + 1)] for _ in range(maxRows + 1)]\\n        for row in range(1, maxRows + 1):\\n            for col in range(1, maxCols + 1):\\n                if matrix[row-1][col-1] == \\'1\\':\\n                    dp[row][col] = min(dp[row-1][col-1], dp[row-1][col], dp[row][col-1]) + 1\\n                    maxLength = max(maxLength, dp[row][col])\\n        return maxLength**2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 799521,
                "title": "python-short-recursive-solution-to-optimized-dp",
                "content": "Recursive solution:\\n\\n```\\n def maximalSquare(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        \\n        def helper(row, col):\\n            if row >= len(matrix) or col >= len(matrix[0]) or matrix[row][col] == \\'0\\':\\n                return 0\\n            return 1+min(helper(row+1, col), helper(row, col+1), helper(row+1, col+1))\\n        \\n        \\n        res = 0\\n        for r in range(len(matrix)):\\n            for c in range(len(matrix[0])):\\n                res = max(res, helper(r,c))\\n        return res**2\\n```\\n\\nDynamic Programming Solution (Captures the same logic as the recurrence)\\n```\\n def maximalSquare(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n\\n        if len(matrix) == 0:\\n            return 0\\n        \\n        res = 0\\n        rows = len(matrix)\\n        cols = len(matrix[0])\\n        dp = [[0 for i in range(cols+1)] for i in range(rows+1)]\\n        \\n        for r in range(rows,-1,-1):\\n            for c in range(cols,-1,-1):\\n                if r >= rows or c >= cols or matrix[r][c] == \\'0\\':\\n                    continue\\n                else:\\n                    dp[r][c] = 1+min(dp[r+1][c], dp[r][c+1],dp[r+1][c+1])\\n                    res = max(res, dp[r][c])\\n                    \\n        return res**2\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n def maximalSquare(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        \\n        def helper(row, col):\\n            if row >= len(matrix) or col >= len(matrix[0]) or matrix[row][col] == \\'0\\':\\n                return 0\\n            return 1+min(helper(row+1, col), helper(row, col+1), helper(row+1, col+1))\\n        \\n        \\n        res = 0\\n        for r in range(len(matrix)):\\n            for c in range(len(matrix[0])):\\n                res = max(res, helper(r,c))\\n        return res**2\\n```\n```\\n def maximalSquare(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n\\n        if len(matrix) == 0:\\n            return 0\\n        \\n        res = 0\\n        rows = len(matrix)\\n        cols = len(matrix[0])\\n        dp = [[0 for i in range(cols+1)] for i in range(rows+1)]\\n        \\n        for r in range(rows,-1,-1):\\n            for c in range(cols,-1,-1):\\n                if r >= rows or c >= cols or matrix[r][c] == \\'0\\':\\n                    continue\\n                else:\\n                    dp[r][c] = 1+min(dp[r+1][c], dp[r][c+1],dp[r+1][c+1])\\n                    res = max(res, dp[r][c])\\n                    \\n        return res**2\\n                \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 599797,
                "title": "python-dp",
                "content": "```\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        if len(matrix) == 0:\\n            return 0\\n    \\n        n, m = len(matrix), len(matrix[0])\\n        \\n        dp = [[0 for i in range(m+1)] for j in range(n+1)]\\n        \\n        max_square = 0\\n        for i in range(1, n+1):\\n            for j in range(1, m+1):\\n                if matrix[i-1][j-1] == \"1\":\\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\\n                    max_square = max(max_square, dp[i][j])    \\n        return max_square ** 2\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        if len(matrix) == 0:\\n            return 0\\n    \\n        n, m = len(matrix), len(matrix[0])\\n        \\n        dp = [[0 for i in range(m+1)] for j in range(n+1)]\\n        \\n        max_square = 0\\n        for i in range(1, n+1):\\n            for j in range(1, m+1):\\n                if matrix[i-1][j-1] == \"1\":\\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\\n                    max_square = max(max_square, dp[i][j])    \\n        return max_square ** 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2284710,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Approach 1 :- Using Recursion && Memoization***\\n\\n* ***Time Complexity :- O(N * M)***\\n\\n* ***Space Complexity :- O(N * M)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // declare a dp\\n    \\n    int dp[305][305];\\n    \\n    int dfs(vector<vector<char>>& matrix, int i, int j, int n, int m)\\n    {\\n        // base case\\n        \\n        if(i < 0 || i >= n || j < 0 || j >= m || matrix[i][j] == \\'0\\')\\n            return 0;\\n        \\n        // if already calculated\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        // call for right cell\\n        \\n        int right = dfs(matrix, i, j + 1, n, m);\\n        \\n        // call for down cell\\n        \\n        int down = dfs(matrix, i + 1, j, n, m);\\n        \\n        // call for digonal cell\\n        \\n        int diagonal = dfs(matrix, i + 1, j + 1, n, m);\\n        \\n        // return the possible side of square\\n        \\n        return dp[i][j] = 1 + min({right, down, diagonal});\\n    }\\n    \\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        \\n        int n = matrix.size();\\n        \\n        int m = matrix[0].size();\\n        \\n        // initialize the dp with -1\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        // find the max_area possible\\n        \\n        int max_area = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(matrix[i][j] == \\'1\\')\\n                {\\n                    int curr_side = dfs(matrix, i, j, n, m);\\n                    \\n                    int curr_area = curr_side * curr_side;\\n                    \\n                    max_area = max(max_area, curr_area);\\n                }\\n            }\\n        }\\n        \\n        return max_area;\\n    }\\n};\\n```\\n\\n* ***Approach 2 :- Using Bottom Up Dp***\\n\\n* ***Time Complexity :- O(N * M)***\\n\\n* ***Space Complexity :- O(N * M)***\\n\\n```\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        \\n        int n = matrix.size();\\n        \\n        int m = matrix[0].size();\\n        \\n        // declare a dp and initialize with 0\\n        \\n        vector<vector<int>> dp(n, vector<int> (m, 0));\\n        \\n        int max_side = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(matrix[i][j] == \\'1\\')\\n                {\\n                    // for 0th row and 0th col\\n                    \\n                    if(i == 0 || j == 0) \\n                    {\\n                        dp[i][j] = 1;\\n                    }\\n                    \\n                    // for others\\n                    \\n                    else\\n                    {\\n                        dp[i][j] = 1 + min({dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]});\\n                    }\\n                    \\n                    // update max side\\n                    \\n                    max_side = max(max_side, dp[i][j]);\\n                }\\n            }\\n        }\\n        \\n        // calculate max. area\\n        \\n        int max_area = max_side * max_side;\\n        \\n        return max_area;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // declare a dp\\n    \\n    int dp[305][305];\\n    \\n    int dfs(vector<vector<char>>& matrix, int i, int j, int n, int m)\\n    {\\n        // base case\\n        \\n        if(i < 0 || i >= n || j < 0 || j >= m || matrix[i][j] == \\'0\\')\\n            return 0;\\n        \\n        // if already calculated\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        // call for right cell\\n        \\n        int right = dfs(matrix, i, j + 1, n, m);\\n        \\n        // call for down cell\\n        \\n        int down = dfs(matrix, i + 1, j, n, m);\\n        \\n        // call for digonal cell\\n        \\n        int diagonal = dfs(matrix, i + 1, j + 1, n, m);\\n        \\n        // return the possible side of square\\n        \\n        return dp[i][j] = 1 + min({right, down, diagonal});\\n    }\\n    \\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        \\n        int n = matrix.size();\\n        \\n        int m = matrix[0].size();\\n        \\n        // initialize the dp with -1\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        // find the max_area possible\\n        \\n        int max_area = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(matrix[i][j] == \\'1\\')\\n                {\\n                    int curr_side = dfs(matrix, i, j, n, m);\\n                    \\n                    int curr_area = curr_side * curr_side;\\n                    \\n                    max_area = max(max_area, curr_area);\\n                }\\n            }\\n        }\\n        \\n        return max_area;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        \\n        int n = matrix.size();\\n        \\n        int m = matrix[0].size();\\n        \\n        // declare a dp and initialize with 0\\n        \\n        vector<vector<int>> dp(n, vector<int> (m, 0));\\n        \\n        int max_side = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(matrix[i][j] == \\'1\\')\\n                {\\n                    // for 0th row and 0th col\\n                    \\n                    if(i == 0 || j == 0) \\n                    {\\n                        dp[i][j] = 1;\\n                    }\\n                    \\n                    // for others\\n                    \\n                    else\\n                    {\\n                        dp[i][j] = 1 + min({dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]});\\n                    }\\n                    \\n                    // update max side\\n                    \\n                    max_side = max(max_side, dp[i][j]);\\n                }\\n            }\\n        }\\n        \\n        // calculate max. area\\n        \\n        int max_area = max_side * max_side;\\n        \\n        return max_area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1632542,
                "title": "c-simple-and-easy-dynamic-programming-solution",
                "content": "If `dp[i][j]` is 1, it keeps the length of the largest square where `matrix[i][j]` is the bottom-left corner.\\nWhile we iterate, we update `res` to the maximum.\\n```\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int n = matrix.size(), m = matrix[0].size(), res = 0;\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, 0));\\n        \\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                if (matrix[i-1][j-1] == \\'1\\') {\\n                    dp[i][j] = min({dp[i-1][j], dp[i][j-1], dp[i-1][j-1]}) + 1;\\n                    res = max(res, dp[i][j]);\\n                } \\n            }\\n        }\\n        \\n        return res*res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int n = matrix.size(), m = matrix[0].size(), res = 0;\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, 0));\\n        \\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                if (matrix[i-1][j-1] == \\'1\\') {\\n                    dp[i][j] = min({dp[i-1][j], dp[i][j-1], dp[i-1][j-1]}) + 1;\\n                    res = max(res, dp[i][j]);\\n                } \\n            }\\n        }\\n        \\n        return res*res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1467253,
                "title": "python-top-down-dp-clean-concise",
                "content": "**Idea**\\n- Let `dp[r][c]` denote the side length of the maximum square whose bottom right corner is the at cell `(r, c)`.\\n\\n```python\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        dp = [[0] * n for _ in range(m)]\\n        ans = 0\\n        for r in range(m):\\n            for c in range(n):\\n                if matrix[r][c] == \"0\": continue\\n                if r == 0 or c == 0:\\n                    dp[r][c] = 1\\n                else:\\n                    dp[r][c] = min(dp[r-1][c], dp[r][c-1], dp[r-1][c-1]) + 1\\n                ans = max(ans, dp[r][c])\\n        return ans * ans\\n```\\nComplexity:\\n- Time: `O(M*N)`, where `M <= 300` is number of rows, `N <= 300` is number of columns in the matrix.\\n- Space: `O(M*N)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        dp = [[0] * n for _ in range(m)]\\n        ans = 0\\n        for r in range(m):\\n            for c in range(n):\\n                if matrix[r][c] == \"0\": continue\\n                if r == 0 or c == 0:\\n                    dp[r][c] = 1\\n                else:\\n                    dp[r][c] = min(dp[r-1][c], dp[r][c-1], dp[r-1][c-1]) + 1\\n                ans = max(ans, dp[r][c])\\n        return ans * ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 357071,
                "title": "java-top-down-and-bottom-up-dp",
                "content": "```\\nBottom Up Solution: \\n\\npublic int maximalSquare(char[][] matrix) {\\n    if (matrix.length == 0 || matrix[0].length == 0) return 0;\\n    int n = matrix.length;\\n    int m = matrix[0].length;\\n    int max = 0;\\n    int[][] dp = new int[n][m];\\n    for(int i = n - 1; i >= 0; i--) {\\n        for(int j = m - 1; j >= 0; j--) {\\n            if (matrix[i][j] == \\'0\\') continue;\\n\\n            int val1 = i + 1 <= n - 1 ? dp[i + 1][j] : 0;\\n            int val2 = j + 1 <= m - 1 ? dp[i][j + 1] : 0;\\n            int val3 = (i + 1 <= n - 1 && j + 1 <= m - 1) ? dp[i + 1][j + 1] : 0;\\n\\n            dp[i][j] = Math.min(val1, Math.min(val2, val3)) + 1;\\n            max = Math.max(max, dp[i][j]);\\n        }\\n    }\\n\\n    return max * max;\\n}\\n```\\n\\n```\\n\\nTop Down Solution\\n\\nclass Solution {\\n    public int maximalSquare(char[][] matrix) {\\n        if (matrix.length == 0 || matrix[0].length == 0) return 0;\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int max = 0;\\n        Integer[][] cache = new Integer[n][m];\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                max = Math.max(max, helper(matrix, i, j, cache));\\n            }\\n        }\\n\\n        return max * max;\\n    }\\n    \\n    private int helper(char[][] matrix, int i, int j, Integer[][] cache) {\\n        if (i == matrix.length || j == matrix[0].length) return 0;\\n        if (matrix[i][j] == \\'0\\') return 0;\\n        if (cache[i][j] != null) return cache[i][j];\\n\\n        int re1 = helper(matrix, i, j + 1, cache);\\n        int re2 = helper(matrix, i + 1, j, cache);\\n        int re3 = helper(matrix, i + 1, j + 1, cache);\\n\\n        cache[i][j] = Math.min(re1, Math.min(re2,re3)) + (matrix[i][j] - \\'0\\');\\n        return cache[i][j];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nBottom Up Solution: \\n\\npublic int maximalSquare(char[][] matrix) {\\n    if (matrix.length == 0 || matrix[0].length == 0) return 0;\\n    int n = matrix.length;\\n    int m = matrix[0].length;\\n    int max = 0;\\n    int[][] dp = new int[n][m];\\n    for(int i = n - 1; i >= 0; i--) {\\n        for(int j = m - 1; j >= 0; j--) {\\n            if (matrix[i][j] == \\'0\\') continue;\\n\\n            int val1 = i + 1 <= n - 1 ? dp[i + 1][j] : 0;\\n            int val2 = j + 1 <= m - 1 ? dp[i][j + 1] : 0;\\n            int val3 = (i + 1 <= n - 1 && j + 1 <= m - 1) ? dp[i + 1][j + 1] : 0;\\n\\n            dp[i][j] = Math.min(val1, Math.min(val2, val3)) + 1;\\n            max = Math.max(max, dp[i][j]);\\n        }\\n    }\\n\\n    return max * max;\\n}\\n```\n```\\n\\nTop Down Solution\\n\\nclass Solution {\\n    public int maximalSquare(char[][] matrix) {\\n        if (matrix.length == 0 || matrix[0].length == 0) return 0;\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int max = 0;\\n        Integer[][] cache = new Integer[n][m];\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                max = Math.max(max, helper(matrix, i, j, cache));\\n            }\\n        }\\n\\n        return max * max;\\n    }\\n    \\n    private int helper(char[][] matrix, int i, int j, Integer[][] cache) {\\n        if (i == matrix.length || j == matrix[0].length) return 0;\\n        if (matrix[i][j] == \\'0\\') return 0;\\n        if (cache[i][j] != null) return cache[i][j];\\n\\n        int re1 = helper(matrix, i, j + 1, cache);\\n        int re2 = helper(matrix, i + 1, j, cache);\\n        int re3 = helper(matrix, i + 1, j + 1, cache);\\n\\n        cache[i][j] = Math.min(re1, Math.min(re2,re3)) + (matrix[i][j] - \\'0\\');\\n        return cache[i][j];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2042540,
                "title": "simple-recursion-memoization-approach-easy-to-understand",
                "content": "INTUITIVE APPROACH SAME LIKE : [Number of Islands](https://leetcode.com/problems/number-of-islands/)\\n [Number of Islands Solution](https://leetcode.com/problems/number-of-islands/discuss/2042529/Simple-Recursion-DFS-Approach-.-FASTER-than-95.27)\\n```\\nclass Solution {\\npublic:\\n    int dp[301][301];\\n    int helperMethod(int i,int j,vector<vector<char>>& matrix)\\n    {\\n        if(i<0 || j<0 || i>= matrix.size()|| j>=matrix[0].size()|| matrix[i][j] == \\'0\\')\\n            return 0;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        return dp[i][j] = 1+min( helperMethod(i+1,j,matrix),\\n                            min(helperMethod(i+1,j+1,matrix),helperMethod(i,j+1,matrix))) ;\\n    }\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int ans = INT_MIN;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==\\'1\\')\\n                {\\n                    ans=max(ans,helperMethod(i,j,matrix));\\n                }\\n            }\\n        }\\n        return ans==INT_MIN?0:ans*ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[301][301];\\n    int helperMethod(int i,int j,vector<vector<char>>& matrix)\\n    {\\n        if(i<0 || j<0 || i>= matrix.size()|| j>=matrix[0].size()|| matrix[i][j] == \\'0\\')\\n            return 0;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        return dp[i][j] = 1+min( helperMethod(i+1,j,matrix),\\n                            min(helperMethod(i+1,j+1,matrix),helperMethod(i,j+1,matrix))) ;\\n    }\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int ans = INT_MIN;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==\\'1\\')\\n                {\\n                    ans=max(ans,helperMethod(i,j,matrix));\\n                }\\n            }\\n        }\\n        return ans==INT_MIN?0:ans*ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1331540,
                "title": "swift-maximal-square-test-cases",
                "content": "```swift\\nclass Solution {\\n    func maximalSquare(_ matrix: [[Character]]) -> Int {\\n        guard !matrix.isEmpty else { return 0 }\\n        var length = 0\\n        let row = matrix.count, col = matrix[0].count\\n        var dp = Array<[Int]>(repeating: [Int](repeating: 0, count: col+1), count: row+1)\\n        for x in 1...row {\\n            for y in 1...col where matrix[x-1][y-1] == \"1\" {\\n                dp[x][y] = min(dp[x-1][y], dp[x][y-1], dp[x-1][y-1]) + 1\\n                length = max(dp[x][y], length)\\n            }\\n        }\\n        return length * length\\n    }\\n}\\n```\\n\\n```swift\\nimport XCTest\\n\\n// Executed 3 tests, with 0 failures (0 unexpected) in 0.111 (0.113) seconds\\n\\nclass Tests: XCTestCase {\\n    let s = Solution()\\n    func test0() {\\n        let res = s.maximalSquare([[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]])\\n        XCTAssertEqual(res, 4)\\n    }\\n    func test1() {\\n        let res = s.maximalSquare([[\"0\",\"1\"],[\"1\",\"0\"]])\\n        XCTAssertEqual(res, 1)\\n    }\\n    func test2() {\\n        let res = s.maximalSquare([[\"0\"]])\\n        XCTAssertEqual(res, 0)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func maximalSquare(_ matrix: [[Character]]) -> Int {\\n        guard !matrix.isEmpty else { return 0 }\\n        var length = 0\\n        let row = matrix.count, col = matrix[0].count\\n        var dp = Array<[Int]>(repeating: [Int](repeating: 0, count: col+1), count: row+1)\\n        for x in 1...row {\\n            for y in 1...col where matrix[x-1][y-1] == \"1\" {\\n                dp[x][y] = min(dp[x-1][y], dp[x][y-1], dp[x-1][y-1]) + 1\\n                length = max(dp[x][y], length)\\n            }\\n        }\\n        return length * length\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 3 tests, with 0 failures (0 unexpected) in 0.111 (0.113) seconds\\n\\nclass Tests: XCTestCase {\\n    let s = Solution()\\n    func test0() {\\n        let res = s.maximalSquare([[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]])\\n        XCTAssertEqual(res, 4)\\n    }\\n    func test1() {\\n        let res = s.maximalSquare([[\"0\",\"1\"],[\"1\",\"0\"]])\\n        XCTAssertEqual(res, 1)\\n    }\\n    func test2() {\\n        let res = s.maximalSquare([[\"0\"]])\\n        XCTAssertEqual(res, 0)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 518951,
                "title": "python-o-m-n-sol-by-dp-with-demo",
                "content": "Python O( m * n ) sol. by dynamic programming\\n\\n---\\n\\n**Hint**:\\n\\nThink of the **dynamic programming** technique.\\n\\nWe can develope a 2D dynamic programming algorithm to find the **area of maximum square**.\\n\\nRecall that for square, area = (side length) ^ 2.\\nTherefore **maximum area** must be generated by **maximum side length**.\\n\\n---\\n\\n**Algorithm**:\\n\\nFirst, **compute** the **max side length of square** for **each matrix cell** by dynamic programming with optimal substructure (this will described later).\\n\\nMeanwhile, rememeber to maintain the **global max side length of square** for whole matrix\\n\\nSecond, compute the the ![image](https://assets.leetcode.com/users/brianchiang_tw/image_1582515590.png),then we get the **area of mximum square** of given input matrix.\\n\\n---\\n\\n**Note**:\\nThe **input** matrix is a 2D **string** array, remember to carry out **type casting** during computation\\n\\n---\\n\\n**Optimal substructure**: for maximum side length of square, in dynamic programming.\\n\\nLet DP[ *i* ][ *j* ] denote the max side length, and **[ *i* ][ *j* ]** as the **anchor point** (i.e., bottom-right point) of square\\n\\nFor any i, j with i > 0 and j > 0:\\nDP[ *i* ][ *j* ] = 1 + min( DP[ *i* ][ *j* - 1 ] , DP[ *i* - 1 ][ *j* - 1 ] , DP[ *i* ][ *j* - 1 ] ), if matrix[ *i* ][ *j* ] = 1\\n\\nDP[ *i* ][ *j* ] = matrix[ *i* ][ *j* ] = 0, Otherwise.\\n\\n---\\n\\n**Abstract model** for update with optimal substructure:\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1582454810.png)\\n\\n\\n---\\n\\n**Demo**:\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1582514813.png)\\n\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1582514823.png)\\n\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1582514828.png)\\n\\n\\n---\\n\\n**Implementation**:\\nOut-of-place update, with O( m * n ) space, O( m * n ) time\\n\\n```\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        \\n        if not matrix:\\n            return 0\\n        \\n        dp_table = [ [ int(x) for x in row] for row in matrix]\\n        \\n        h, w = len(matrix), len(matrix[0])\\n        \\n        max_edge_of_square = 0\\n        \\n        for y in range(h):\\n            for x in range(w):\\n                \\n                if y and x and int(matrix[y][x]):\\n                    dp_table[y][x] = 1 + min( dp_table[y][x-1], dp_table[y-1][x-1], dp_table[y-1][x] )\\n                \\n                max_edge_of_square = max(max_edge_of_square, dp_table[y][x])\\n        \\n\\n        return max_edge_of_square*max_edge_of_square\\n```\\n\\n---\\n\\n**Implementation**:\\nIn-place update, with O( 1 ) space, O( m * n ) time\\n\\n```\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        \\n        if not matrix:\\n            return 0\\n        \\n        h, w = len(matrix), len(matrix[0])\\n        \\n\\t\\t# in-place update\\n        dp_table = matrix\\n        \\n        max_edge_length = 0\\n        \\n        for x in range(w):\\n            matrix[0][x] = int( matrix[0][x] )\\n        \\n        for y in range(h):\\n            matrix[y][0] = int( matrix[y][0] )\\n        \\n        for y in range(h):\\n            for x in range(w):\\n                \\n                if y > 0 and x > 0:\\n                    if matrix[y][x] == \\'1\\':\\n\\n                        matrix[y][x] = 1 + min( matrix[y][x-1], matrix[y-1][x-1], matrix[y-1][x])\\n\\n                    else:\\n                        matrix[y][x] = 0\\n\\n                max_edge_length = max(max_edge_length, matrix[y][x])\\n            \\n        return max_edge_length*max_edge_length\\n                \\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n#1277 is a twin-like challenge of the one we solve now\\n[Leetcode #1277 Count Square Submatrices with All Ones](https://leetcode.com/problems/count-square-submatrices-with-all-ones/)\\n\\na good training to develop 2D dynamic programming skill\\n[Leetcode #304 Range Sum Query 2D - Immutable](https://leetcode.com/problems/range-sum-query-2d-immutable/)\\n\\nuse the concept of image low-pass filtering\\n[Leetcode #661 Image Smoother](https://leetcode.com/problems/image-smoother/)\\n\\n---\\n\\nReference:\\n\\n[1] [Wiki: Dynamic programming algorithm framework](https://en.wikipedia.org/wiki/Dynamic_programming#Examples:_Computer_algorithms)\\n\\n[2] [GfG: Introduction to dynamic programming](https://www.***.org/dynamic-programming/)\\n\\n[3] [Python official docs about list comprehension](https://docs.python.org/3.8/tutorial/datastructures.html?highlight=list%20comprehension#list-comprehensions)\\n\\n---\\n\\nThanks for your reading.\\n\\nWish you have a nice day.\\n\\nMeow~\\uD83D\\uDE3A",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        \\n        if not matrix:\\n            return 0\\n        \\n        dp_table = [ [ int(x) for x in row] for row in matrix]\\n        \\n        h, w = len(matrix), len(matrix[0])\\n        \\n        max_edge_of_square = 0\\n        \\n        for y in range(h):\\n            for x in range(w):\\n                \\n                if y and x and int(matrix[y][x]):\\n                    dp_table[y][x] = 1 + min( dp_table[y][x-1], dp_table[y-1][x-1], dp_table[y-1][x] )\\n                \\n                max_edge_of_square = max(max_edge_of_square, dp_table[y][x])\\n        \\n\\n        return max_edge_of_square*max_edge_of_square\\n```\n```\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        \\n        if not matrix:\\n            return 0\\n        \\n        h, w = len(matrix), len(matrix[0])\\n        \\n\\t\\t# in-place update\\n        dp_table = matrix\\n        \\n        max_edge_length = 0\\n        \\n        for x in range(w):\\n            matrix[0][x] = int( matrix[0][x] )\\n        \\n        for y in range(h):\\n            matrix[y][0] = int( matrix[y][0] )\\n        \\n        for y in range(h):\\n            for x in range(w):\\n                \\n                if y > 0 and x > 0:\\n                    if matrix[y][x] == \\'1\\':\\n\\n                        matrix[y][x] = 1 + min( matrix[y][x-1], matrix[y-1][x-1], matrix[y-1][x])\\n\\n                    else:\\n                        matrix[y][x] = 0\\n\\n                max_edge_length = max(max_edge_length, matrix[y][x])\\n            \\n        return max_edge_length*max_edge_length\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281001,
                "title": "easy-python-solution-using-dp-grid",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        dp=[[0]*(len(matrix[0])+1)]\\n        for i in matrix:\\n            l=[0]\\n            for j in i:l.append(int(j))\\n            dp.append(l)\\n        mx=0\\n        for i in range(len(dp)):\\n            for j in range(len(dp[0])):\\n                if dp[i][j]==1:\\n                    dp[i][j]=min(dp[i-1][j],dp[i-1][j-1],dp[i][j-1])+1\\n                mx=max(mx,dp[i][j])\\n        return mx*mx\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        dp=[[0]*(len(matrix[0])+1)]\\n        for i in matrix:\\n            l=[0]\\n            for j in i:l.append(int(j))\\n            dp.append(l)\\n        mx=0\\n        for i in range(len(dp)):\\n            for j in range(len(dp[0])):\\n                if dp[i][j]==1:\\n                    dp[i][j]=min(dp[i-1][j],dp[i-1][j-1],dp[i][j-1])+1\\n                mx=max(mx,dp[i][j])\\n        return mx*mx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826866,
                "title": "in-m-n-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:1\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:n*m\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        mx=0\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if(matrix[i][j]==\"0\"):\\n                    matrix[i][j]=0\\n                else:\\n                    if(i==0 or j==0):\\n                        matrix[i][j]=1\\n                    else:\\n                        matrix[i][j]=min(matrix[i][j-1],matrix[i-1][j],matrix[i-1][j-1])+1\\n                mx=max(mx,matrix[i][j])\\n            # print(matrix[i])\\n        # print(matrix)\\n        return mx**2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        mx=0\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if(matrix[i][j]==\"0\"):\\n                    matrix[i][j]=0\\n                else:\\n                    if(i==0 or j==0):\\n                        matrix[i][j]=1\\n                    else:\\n                        matrix[i][j]=min(matrix[i][j-1],matrix[i-1][j],matrix[i-1][j-1])+1\\n                mx=max(mx,matrix[i][j])\\n            # print(matrix[i])\\n        # print(matrix)\\n        return mx**2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1632351,
                "title": "python-short-dp-explained",
                "content": "Classical DP problem, where by `dp[i][j]` we define the biggest square whose bottom right corner is the cell with index `(i,j)` in the original matrix. Then we can use `dp(i, j)= min(dp(i-1, j), dp(i-1, j-1), dp(i, j-1)) + 1` to update cells, if we have `1` in `(i, j)` place in original matrix.\\n\\n#### Complexity\\nTime complexity is `O(mn)` and the same space. Space complexity can be reduced to `O(min(m, n))`, because we use only one row at a time.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def maximalSquare(self, M):\\n        m, n = len(M[0]), len(M)\\n        @lru_cache(None)\\n        def dp(i, j):\\n            if M[i][j] == \"0\": return 0\\n            if i < 0 or j < 0: return 0\\n            return min(dp(i-1, j), dp(i, j-1), dp(i-1, j-1)) + 1\\n        \\n        return max(dp(i, j) for i, j in product(range(n), range(m)))**2\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def maximalSquare(self, M):\\n        m, n = len(M[0]), len(M)\\n        @lru_cache(None)\\n        def dp(i, j):\\n            if M[i][j] == \"0\": return 0\\n            if i < 0 or j < 0: return 0\\n            return min(dp(i-1, j), dp(i, j-1), dp(i-1, j-1)) + 1\\n        \\n        return max(dp(i, j) for i, j in product(range(n), range(m)))**2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1062538,
                "title": "python-bottom-up-dp-short-explanation-diagram",
                "content": "Approach: O(m\\\\*n) runtime, O(1) extra space - 216ms(40.97%), 17.4MB (8.59%)\\nBottom-Up Dynamic programming - dp[i][j] depends on left,top,top-left values. \\nA bigger square of dimension K+1 is formed when the previous 3 values are all squares of dimension K\\nNote that we don\\'t return the last value at the end, but keep track of the maximum square throughout the iteration;\\nthis is sort of using Kadane\\'s algorithm.\\n![image](https://assets.leetcode.com/users/images/15d5a7cd-cdca-4429-9f49-7cb0ba340e42_1613161649.510422.png)\\n\\n\\n```py\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        #dp = [[0] * n for _ in range(m)]\\n        \\n        #dp[i][j] looks at topleft,top,left values\\n        #since there\\'s no rules about modifying input matrix, we can use our input matrix as our dp matrix to be memory efficient\\n        \\n        #initialize maxSquareSide to be 0 (or 1 if there\\'s a 1 in first row or col)\\n        maxSquareSide = 0 #our current max square side length\\n        for val in matrix[0]:\\n            #first row\\n            if val == \"1\":\\n                maxSquareSide = 1\\n                break\\n        if maxSquareSide == 0:\\n            for i in range(m):\\n                #first col\\n                if matrix[i][0] == \"1\":\\n                    maxSquareSide = 1\\n                    break\\n        \\n        for i in range(1,m):\\n            for j in range(1,n):\\n                if matrix[i][j] == \"1\":\\n                    matrix[i][j] = str(min(int(matrix[i-1][j-1]),int(matrix[i-1][j]),int(matrix[i][j-1])) + 1)\\n                if int(matrix[i][j]) > maxSquareSide:\\n                    maxSquareSide = int(matrix[i][j])\\n        #print(matrix)\\n        return maxSquareSide**2\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```py\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        #dp = [[0] * n for _ in range(m)]\\n        \\n        #dp[i][j] looks at topleft,top,left values\\n        #since there\\'s no rules about modifying input matrix, we can use our input matrix as our dp matrix to be memory efficient\\n        \\n        #initialize maxSquareSide to be 0 (or 1 if there\\'s a 1 in first row or col)\\n        maxSquareSide = 0 #our current max square side length\\n        for val in matrix[0]:\\n            #first row\\n            if val == \"1\":\\n                maxSquareSide = 1\\n                break\\n        if maxSquareSide == 0:\\n            for i in range(m):\\n                #first col\\n                if matrix[i][0] == \"1\":\\n                    maxSquareSide = 1\\n                    break\\n        \\n        for i in range(1,m):\\n            for j in range(1,n):\\n                if matrix[i][j] == \"1\":\\n                    matrix[i][j] = str(min(int(matrix[i-1][j-1]),int(matrix[i-1][j]),int(matrix[i][j-1])) + 1)\\n                if int(matrix[i][j]) > maxSquareSide:\\n                    maxSquareSide = int(matrix[i][j])\\n        #print(matrix)\\n        return maxSquareSide**2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 853928,
                "title": "memoization-java-solution-98",
                "content": "**Mamoization Method: **\\n```\\nclass Solution {\\n    public int maximalSquare(char[][] matrix) {\\n        \\n        if(matrix.length == 0) return 0;\\n        \\n        int[][] memo = new int[matrix.length][matrix[0].length];\\n        int max = 0;\\n        int currMax = 0;\\n        for(int i = 0; i<matrix.length; i++){\\n            for(int j = 0; j<matrix[0].length; j++){\\n                currMax = findsquare(matrix,i,j,memo);\\n                if(max < currMax)\\n                    max = currMax;\\n            }\\n        }\\n        return max*max;\\n    }\\n    \\n    private int findsquare(char[][] matrix, int i, int j, int[][] dp){\\n        \\n        if(i >= matrix.length || j >= matrix[0].length || matrix[i][j] == \\'0\\')\\n            return 0;\\n        if(dp[i][j] != 0) return dp[i][j];\\n        \\n        return dp[i][j]  =  1 + Math.min(findsquare(matrix, i+1, j+1,dp),\\n                                Math.min(findsquare(matrix, i+1,j,dp),\\n                                         findsquare(matrix, i, j+1, dp)));\\n    }\\n}\\n```\\n**Tabulation Method**: \\n\\n```\\nclass Solution {\\n    public int maximalSquare(char[][] matrix) {\\n        if(matrix.length == 0) return 0;\\n        \\n        int[][] dp = new int[matrix.length][matrix[0].length];\\n        int max = 0;\\n        for(int i =0; i< matrix.length; i++){\\n            for(int j = 0; j <matrix[i].length; j++){\\n                \\n                if(i == 0 || j == 0)dp[i][j] = matrix[i][j] == \\'0\\' ? 0: 1 ;\\n                \\n                else{\\n                    if(matrix[i][j] == \\'0\\') continue;\\n                    \\n                     dp[i][j] = 1 + Math.min(dp[i-1][j-1],Math.min(dp[i-1][j],dp[i][j-1]));\\n                }\\n                max = Math.max(max,dp[i][j]);\\n            }\\n        }\\n        return max*max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int maximalSquare(char[][] matrix) {\\n        \\n        if(matrix.length == 0) return 0;\\n        \\n        int[][] memo = new int[matrix.length][matrix[0].length];\\n        int max = 0;\\n        int currMax = 0;\\n        for(int i = 0; i<matrix.length; i++){\\n            for(int j = 0; j<matrix[0].length; j++){\\n                currMax = findsquare(matrix,i,j,memo);\\n                if(max < currMax)\\n                    max = currMax;\\n            }\\n        }\\n        return max*max;\\n    }\\n    \\n    private int findsquare(char[][] matrix, int i, int j, int[][] dp){\\n        \\n        if(i >= matrix.length || j >= matrix[0].length || matrix[i][j] == \\'0\\')\\n            return 0;\\n        if(dp[i][j] != 0) return dp[i][j];\\n        \\n        return dp[i][j]  =  1 + Math.min(findsquare(matrix, i+1, j+1,dp),\\n                                Math.min(findsquare(matrix, i+1,j,dp),\\n                                         findsquare(matrix, i, j+1, dp)));\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maximalSquare(char[][] matrix) {\\n        if(matrix.length == 0) return 0;\\n        \\n        int[][] dp = new int[matrix.length][matrix[0].length];\\n        int max = 0;\\n        for(int i =0; i< matrix.length; i++){\\n            for(int j = 0; j <matrix[i].length; j++){\\n                \\n                if(i == 0 || j == 0)dp[i][j] = matrix[i][j] == \\'0\\' ? 0: 1 ;\\n                \\n                else{\\n                    if(matrix[i][j] == \\'0\\') continue;\\n                    \\n                     dp[i][j] = 1 + Math.min(dp[i-1][j-1],Math.min(dp[i-1][j],dp[i][j-1]));\\n                }\\n                max = Math.max(max,dp[i][j]);\\n            }\\n        }\\n        return max*max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 753187,
                "title": "c-simple-solution",
                "content": "```\\nint maximalSquare(vector<vector<char>>& matrix) {\\n        int n=matrix.size();\\n        if(!n) return 0;\\n        int m=matrix[0].size(),sz=0;\\n        vector<vector<int> > dp(n, vector<int>(m, 0));\\n        for(int i=0;i<n;++i) {\\n            for(int j=0;j<m;++j) {\\n                if(i==0 || j==0) dp[i][j]=matrix[i][j]-\\'0\\';                     //for first Row & Col\\n                else if(matrix[i][j]==\\'1\\') dp[i][j] = min({dp[i-1][j-1], dp[i-1][j], dp[i][j-1]}) + 1;\\n                sz = max(sz, dp[i][j]);\\n            }\\n        }\\n        return sz*sz;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint maximalSquare(vector<vector<char>>& matrix) {\\n        int n=matrix.size();\\n        if(!n) return 0;\\n        int m=matrix[0].size(),sz=0;\\n        vector<vector<int> > dp(n, vector<int>(m, 0));\\n        for(int i=0;i<n;++i) {\\n            for(int j=0;j<m;++j) {\\n                if(i==0 || j==0) dp[i][j]=matrix[i][j]-\\'0\\';                     //for first Row & Col\\n                else if(matrix[i][j]==\\'1\\') dp[i][j] = min({dp[i-1][j-1], dp[i-1][j], dp[i][j-1]}) + 1;\\n                sz = max(sz, dp[i][j]);\\n            }\\n        }\\n        return sz*sz;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 599760,
                "title": "javascript-very-fast-dp-solution-w-comments-explanation",
                "content": "**solution:**\\n```\\nfunction maximalSquare(matrix) {\\n    // max square we\\'ve seen\\n    let max = 0;\\n\\t\\n    // create empty dp array matching matrix size\\n    const dp = [\\n        ...Array(matrix.length),\\n    ].map((e) => Array(matrix[0].length));\\n\\t\\n    // iterate i by j thru matrix\\n    for (let i = 0; i < matrix.length; i++) {\\n        for (let j = 0; j < matrix[0].length; j++) {\\n            // check if this is first row, or col\\n            if (i === 0 || j === 0) {\\n                // check if it\\'s a 1 to update max square to 1\\n                if (matrix[i][j] === \\'1\\') {\\n                    dp[i][j] = 1;\\n                    max = Math.max(max, 1);\\n                }\\n                else {\\n                    // just write a 0 to dp\\n                    dp[i][j] = 0;\\n                }\\n            } else {\\n                // check if 1\\n                if (matrix[i][j] === \\'1\\') {\\n                    // number at this dp cell, is min of left, top, top left + 1\\n                    // this ensures, will only be a square if all of those are 1s\\n                    dp[i][j] =\\n                        Math.min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]) + 1;\\n                    // update max if necessary\\n                    max = Math.max(max, dp[i][j]);\\n                }\\n                else {\\n                    // just write a 0 to dp\\n                    dp[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n\\t\\n    // return max squared (cuz its a square :))\\n    return max ** 2;\\n}\\n```\\n\\n**explanation:**\\n\\n1. we originally create a DP matrix, same dimensions as input matrix.\\n2. then, we fill any number in first row, or first column, with the original number.\\n3. each cell, we take the min of the top left, left, and top, + 1.\\n4. then, each time we see a 1, we update the max\\n5. at the end, we return a square of that number.\\n\\nThis is pretty straight forward, but I will explain what\\'s happening by setting DP to be min of topleft, left, and top + 1.\\n\\nSay we are given this:\\n```\\n1 1 1\\n1 1 1\\n1 1 1\\n```\\n\\nfirst row stays same according to algo, then we\\'re at (1,0). this stays same because it\\'s in first column. \\nWhen we get to (1,1), we take min of top left, left, and top + 1, which is 2, so DP now becomes\\n\\n```\\n1 1 1\\n1 2 1\\n1 1 1\\n```\\n\\nAnd we set new max to be 2. \\n\\nAfter updating more values, DP becomes:\\n\\n```\\n1 1 1\\n1 2 2\\n1 2 1\\n```\\n\\nThen, when we get to last cell, (2,2), we take min again and it becomes:\\n```\\n1 1 1\\n1 2 2\\n1 2 3\\n```\\n\\nand new max is 3.\\n\\nResult becomes 3^2 which is 9, which is answer for this example.\\n\\nenjoy.\\n",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunction maximalSquare(matrix) {\\n    // max square we\\'ve seen\\n    let max = 0;\\n\\t\\n    // create empty dp array matching matrix size\\n    const dp = [\\n        ...Array(matrix.length),\\n    ].map((e) => Array(matrix[0].length));\\n\\t\\n    // iterate i by j thru matrix\\n    for (let i = 0; i < matrix.length; i++) {\\n        for (let j = 0; j < matrix[0].length; j++) {\\n            // check if this is first row, or col\\n            if (i === 0 || j === 0) {\\n                // check if it\\'s a 1 to update max square to 1\\n                if (matrix[i][j] === \\'1\\') {\\n                    dp[i][j] = 1;\\n                    max = Math.max(max, 1);\\n                }\\n                else {\\n                    // just write a 0 to dp\\n                    dp[i][j] = 0;\\n                }\\n            } else {\\n                // check if 1\\n                if (matrix[i][j] === \\'1\\') {\\n                    // number at this dp cell, is min of left, top, top left + 1\\n                    // this ensures, will only be a square if all of those are 1s\\n                    dp[i][j] =\\n                        Math.min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]) + 1;\\n                    // update max if necessary\\n                    max = Math.max(max, dp[i][j]);\\n                }\\n                else {\\n                    // just write a 0 to dp\\n                    dp[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n\\t\\n    // return max squared (cuz its a square :))\\n    return max ** 2;\\n}\\n```\n```\\n1 1 1\\n1 1 1\\n1 1 1\\n```\n```\\n1 1 1\\n1 2 1\\n1 1 1\\n```\n```\\n1 1 1\\n1 2 2\\n1 2 1\\n```\n```\\n1 1 1\\n1 2 2\\n1 2 3\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 61863,
                "title": "simple-clean-dp-solution-8ms-best-submission-in-c",
                "content": "    class Solution {\\n    public:\\n        int maximalSquare(vector<vector<char>>& matrix) \\n        {\\n            int rowSize = matrix.size();\\n            if(!rowSize) return 0;\\n            int colSize = matrix[0].size();\\n            if(!colSize) return 0;\\n            int square[rowSize+1][colSize+1];\\n            memset(square, 0, sizeof(int)*(rowSize+1)*(colSize+1));\\n            int maxWidth = 0;\\n            for(int r = 1; r <= rowSize; ++r)\\n            {\\n                for(int c = 1; c <= colSize; ++c)\\n                {\\n                    if(matrix[r-1][c-1] == '1')\\n                        square[r][c] = min(min(square[r-1][c], square[r][c-1]), square[r-1][c-1]) + 1;\\n                    maxWidth = max(maxWidth, square[r][c]);\\n                }\\n            }\\n            return maxWidth*maxWidth;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int maximalSquare(vector<vector<char>>& matrix) \\n        {\\n            int rowSize = matrix.size();\\n            if(!rowSize) return 0;\\n            int colSize = matrix[0].size();\\n            if(!colSize) return 0;\\n            int square[rowSize+1][colSize+1];\\n            memset(square, 0, sizeof(int)*(rowSize+1)*(colSize+1));\\n            int maxWidth = 0;\\n            for(int r = 1; r <= rowSize; ++r)\\n            {\\n                for(int c = 1; c <= colSize; ++c)\\n                {\\n                    if(matrix[r-1][c-1] == '1')\\n                        square[r][c] = min(min(square[r-1][c], square[r][c-1]), square[r-1][c-1]) + 1;\\n                    maxWidth = max(maxWidth, square[r][c]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 61875,
                "title": "simple-and-easy-understood-java-dp-solution-o-m-n-and-99-59",
                "content": "public class Solution {\\n\\n    public int maximalSquare(char[][] matrix) {\\n        int m = matrix.length;\\n        if(m <= 0)return 0;\\n        int n = matrix[0].length;\\n        int[][] dp = new int[m][n];\\n        for(int i = 0; i < m; ++i)\\n            dp[i][0] = matrix[i][0] - '0';\\n        for(int j = 0; j < n; ++j)\\n            dp[0][j] = matrix[0][j] - '0';\\n        for(int i = 1; i < m; ++i)\\n            for(int j = 1; j < n; ++j){\\n                if(matrix[i][j] == '0'){\\n                    dp[i][j] = 0;\\n                }else{\\n                    int L1 = dp[i][j - 1];\\n                    int L2 = dp[i - 1][j];\\n                    if(L1 != L2)\\n                        dp[i][j] = Math.min(L1, L2) + 1;\\n                    else\\n                        dp[i][j] = (matrix[i-L1][j-L1] == '1') ? L1 + 1 : L1;            \\n                }\\n            }\\n        int max = 0;\\n        for(int[] row : dp)\\n            for(int col : row)\\n                max = Math.max(max, col);\\n        return max * max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int maximalSquare(char[][] matrix) {\\n        int m = matrix.length;\\n        if(m <= 0)return 0;\\n        int n = matrix[0].length;\\n        int[][] dp = new int[m][n];\\n        for(int i = 0; i < m; ++i)\\n            dp[i][0] = matrix[i][0] - '0';\\n        for(int j = 0; j < n; ++j)\\n            dp[0][j] = matrix[0][j] - '0';\\n        for(int i = 1; i < m; ++i)\\n            for(int j = 1; j < n; ++j){\\n                if(matrix[i][j] == '0'){\\n                    dp[i][j] = 0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 61897,
                "title": "java-dp-simple-solution",
                "content": "    public class Solution {\\n        public int maximalSquare(char[][] matrix) {\\n            if (matrix == null || matrix.length == 0) return 0;\\n            \\n            int row = matrix.length;\\n            int col = matrix[0].length;\\n            int max = 0;\\n            \\n            // matrix to  keep track the size of a square which its bottom right corner is i,j\\n            int S[][] = new int[row][col];\\n            for (int i = 0; i < row; i++){\\n                for (int j = 0; j < col; j++){\\n                    if (i == 0 || j == 0) S[i][j] = matrix[i][j] - '0';\\n                    else if (matrix[i][j] == '0') S[i][j] = 0;\\n                    else {\\n                        S[i][j] = Math.min(S[i][j-1], Math.min(S[i-1][j], S[i-1][j-1])) + 1;\\n                    }\\n                    \\n                    //replace the largest square if necessary\\n                    if (max < S[i][j]) max = S[i][j];\\n                }\\n            }\\n            return max*max;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n        public int maximalSquare(char[][] matrix) {\\n            if (matrix == null || matrix.length == 0) return 0;\\n            \\n            int row = matrix.length;\\n            int col = matrix[0].length;\\n            int max = 0;\\n            \\n            // matrix to  keep track the size of a square which its bottom right corner is i,j\\n            int S[][] = new int[row][col];\\n            for (int i = 0; i < row; i++){\\n                for (int j = 0; j < col; j++){\\n                    if (i == 0 || j == 0) S[i][j] = matrix[i][j] - '0';\\n                    else if (matrix[i][j] == '0') S[i][j] = 0;\\n                    else {\\n                        S[i][j] = Math.min(S[i][j-1], Math.min(S[i-1][j], S[i-1][j-1])) + 1;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 61914,
                "title": "simple-and-efficient-implementation-using-dp-in-c",
                "content": "Where *n* is the number of rows and *m* is the number of column,This solution runs in O(*nm*) complexity and O(*nm*) space. If the space really matters to you, you can reduce the space complexity to O(*n*) by reusing the last raw per each iteration but the code could be slightly more complex.\\n\\n\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        if(matrix.empty() || matrix[0].empty()) return 0;\\n        int maxSize = 0;        \\n        vector<vector<int>> m(matrix.size(), vector<int>(matrix[0].size(), 0));\\n        for(int r = 0 ; r < m.size() ; ++r) {\\n            for(int c = 0 ; c < m[0].size() ; ++c) {\\n                m[r][c] = matrix[r][c]-'0';\\n                if(r > 0 && c > 0 && m[r][c] == 1) {\\n                    m[r][c] += min(m[r-1][c], min(m[r][c-1], m[r-1][c-1]));\\n                }\\n                maxSize = max(maxSize, m[r][c]);\\n            }\\n        }\\n        return maxSize*maxSize;\\n    }",
                "solutionTags": [],
                "code": "Where *n* is the number of rows and *m* is the number of column,This solution runs in O(*nm*) complexity and O(*nm*) space. If the space really matters to you, you can reduce the space complexity to O(*n*) by reusing the last raw per each iteration but the code could be slightly more complex.\\n\\n\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        if(matrix.empty() || matrix[0].empty()) return 0;\\n        int maxSize = 0;        \\n        vector<vector<int>> m(matrix.size(), vector<int>(matrix[0].size(), 0));\\n        for(int r = 0 ; r < m.size() ; ++r) {\\n            for(int c = 0 ; c < m[0].size() ; ++c) {\\n                m[r][c] = matrix[r][c]-'0';\\n                if(r > 0 && c > 0 && m[r][c] == 1) {\\n                    m[r][c] += min(m[r-1][c], min(m[r][c-1], m[r-1][c-1]));\\n                }\\n                maxSize = max(maxSize, m[r][c]);\\n            }\\n        }\\n        return maxSize*maxSize;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3456569,
                "title": "221-maximal-square",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[301][301];\\n    int area(int row, int col, int m, int n, vector<vector<char>>& matrix ){\\n        \\n        if(row >= m || col >=n || matrix[row][col] == \\'0\\')\\n            return 0;\\n        \\n        if(dp[row][col] != -1)\\n            return dp[row][col];\\n        \\n        int right = 1 + area(row,col+1,m,n,matrix);\\n        int below = 1 + area(row+1,col,m,n,matrix);\\n        int diagonal = 1 + area(row+1,col+1,m,n,matrix);\\n        \\n        return dp[row][col] = min(right,min(below,diagonal));\\n    }\\n    \\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int ans = 0;\\n        memset(dp,-1,sizeof dp);\\n        \\n        for(int i = 0; i<m; i++){\\n            for(int j = 0; j<n ;j ++){\\n                if(matrix[i][j] == \\'1\\'){\\n                    ans = max(ans, area(i,j,m,n,matrix));;\\n                }\\n            }\\n        }\\n        return ans*ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[301][301];\\n    int area(int row, int col, int m, int n, vector<vector<char>>& matrix ){\\n        \\n        if(row >= m || col >=n || matrix[row][col] == \\'0\\')\\n            return 0;\\n        \\n        if(dp[row][col] != -1)\\n            return dp[row][col];\\n        \\n        int right = 1 + area(row,col+1,m,n,matrix);\\n        int below = 1 + area(row+1,col,m,n,matrix);\\n        int diagonal = 1 + area(row+1,col+1,m,n,matrix);\\n        \\n        return dp[row][col] = min(right,min(below,diagonal));\\n    }\\n    \\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int ans = 0;\\n        memset(dp,-1,sizeof dp);\\n        \\n        for(int i = 0; i<m; i++){\\n            for(int j = 0; j<n ;j ++){\\n                if(matrix[i][j] == \\'1\\'){\\n                    ans = max(ans, area(i,j,m,n,matrix));;\\n                }\\n            }\\n        }\\n        return ans*ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451520,
                "title": "java-recursive-memoization-tabulation-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    int max = 0;\\n    public int maximalSquare(char[][] matrix) {\\n        // helper(matrix, 0, 0);\\n\\n        // int[][] dp = new int[matrix.length + 1][matrix[0].length + 1];\\n        // for(int[] a : dp) Arrays.fill(a, -1);\\n        // helperMem(matrix, 0, 0, dp);\\n\\n        helperTab(matrix);\\n\\n        return max * max;\\n    }\\n\\n     public int helper(char[][] matrix, int i, int j){\\n         if(i >= matrix.length || j >= matrix[0].length) return 0;\\n         int right = helper(matrix, i, j + 1);\\n         int diagonal = helper(matrix, i + 1, j + 1);\\n         int bottom = helper(matrix, i + 1, j);\\n         int ans = 0;\\n         if(matrix[i][j] == \\'1\\'){\\n             ans = 1 + Math.min(right, Math.min(diagonal, bottom));\\n             max = Math.max(max, ans);\\n         }\\n         else return 0;\\n         return ans;\\n     }\\n\\n     public int helperMem(char[][] matrix, int i, int j, int[][] dp){\\n         if(i >= matrix.length || j >= matrix[0].length) return 0;\\n         if(dp[i][j] != -1) return dp[i][j];\\n         int right = helperMem(matrix, i, j + 1, dp);\\n         int diagonal = helperMem(matrix, i + 1, j + 1, dp);\\n         int bottom = helperMem(matrix, i + 1, j, dp);\\n         int ans = 0;\\n         if(matrix[i][j] == \\'1\\'){\\n             ans = 1 + Math.min(right, Math.min(diagonal, bottom));\\n             max = Math.max(max, ans);\\n         }\\n         else return dp[i][j] = 0;\\n         return dp[i][j] = ans;\\n     }\\n\\n    public int helperTab(char[][] matrix){\\n        int[][] dp = new int[matrix.length + 1][matrix[0].length + 1];\\n        for(int row[] : dp) Arrays.fill(row, 0);\\n        for(int row = matrix.length - 1; row >= 0; row--){\\n            for(int col = matrix[0].length - 1; col >= 0; col--){\\n                int right = dp[row][col + 1];\\n                int diagonal = dp[row + 1][col + 1];\\n                int bottom = dp[row + 1][col];\\n                if(matrix[row][col] == \\'1\\'){\\n                    dp[row][col] = 1 + Math.min(right, Math.min(diagonal, bottom));\\n                    max = Math.max(max, dp[row][col]);\\n                }\\n                else dp[row][col] = 0;\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int max = 0;\\n    public int maximalSquare(char[][] matrix) {\\n        // helper(matrix, 0, 0);\\n\\n        // int[][] dp = new int[matrix.length + 1][matrix[0].length + 1];\\n        // for(int[] a : dp) Arrays.fill(a, -1);\\n        // helperMem(matrix, 0, 0, dp);\\n\\n        helperTab(matrix);\\n\\n        return max * max;\\n    }\\n\\n     public int helper(char[][] matrix, int i, int j){\\n         if(i >= matrix.length || j >= matrix[0].length) return 0;\\n         int right = helper(matrix, i, j + 1);\\n         int diagonal = helper(matrix, i + 1, j + 1);\\n         int bottom = helper(matrix, i + 1, j);\\n         int ans = 0;\\n         if(matrix[i][j] == \\'1\\'){\\n             ans = 1 + Math.min(right, Math.min(diagonal, bottom));\\n             max = Math.max(max, ans);\\n         }\\n         else return 0;\\n         return ans;\\n     }\\n\\n     public int helperMem(char[][] matrix, int i, int j, int[][] dp){\\n         if(i >= matrix.length || j >= matrix[0].length) return 0;\\n         if(dp[i][j] != -1) return dp[i][j];\\n         int right = helperMem(matrix, i, j + 1, dp);\\n         int diagonal = helperMem(matrix, i + 1, j + 1, dp);\\n         int bottom = helperMem(matrix, i + 1, j, dp);\\n         int ans = 0;\\n         if(matrix[i][j] == \\'1\\'){\\n             ans = 1 + Math.min(right, Math.min(diagonal, bottom));\\n             max = Math.max(max, ans);\\n         }\\n         else return dp[i][j] = 0;\\n         return dp[i][j] = ans;\\n     }\\n\\n    public int helperTab(char[][] matrix){\\n        int[][] dp = new int[matrix.length + 1][matrix[0].length + 1];\\n        for(int row[] : dp) Arrays.fill(row, 0);\\n        for(int row = matrix.length - 1; row >= 0; row--){\\n            for(int col = matrix[0].length - 1; col >= 0; col--){\\n                int right = dp[row][col + 1];\\n                int diagonal = dp[row + 1][col + 1];\\n                int bottom = dp[row + 1][col];\\n                if(matrix[row][col] == \\'1\\'){\\n                    dp[row][col] = 1 + Math.min(right, Math.min(diagonal, bottom));\\n                    max = Math.max(max, dp[row][col]);\\n                }\\n                else dp[row][col] = 0;\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 870659,
                "title": "python-dynamic-programming-100-6",
                "content": "In this problem, we are trying to solve the subproblem \\n```\\nA[i][j] = The largest square containing only 1\\'s that includes indicies {1...i} and {1...j}\\n```\\nLet\\'s begin by thinking of small subproblems and trying to piece them together so that they solve bigger subproblems.  If we consider just a single box, a `1x1` matrix with value 1, we know the largest square you can form is of size 1.\\nNow let\\'s look at a `2x2` matrix:\\n```\\n1 1\\n1 1\\n```\\nThe largest square you can form is of size 2.  How did we get that?  Well if we look at the bottom right corner, all of its direct neighbors must be 1 before we can say this is a square of size 2.  If any of the other three were 0, then the maximal square size of this matrix would be 1.  This mimics the recursion relation of \\n```\\nA[i][j] = 1 + min(A[i - 1][j], A[1][j - 1], A[i - 1][j - 1])\\n```\\nThus, we have:\\n```\\nclass Solution(object):\\n    def maximalSquare(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        if not matrix:\\n            return 0\\n        \\n        m, n = len(matrix), len(matrix[0])\\n        res = 0\\n        \\n        A = [[0] * n for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j] == \"1\":\\n                    A[i][j] = 1 + min(A[i - 1][j], A[i][j - 1], A[i - 1][j - 1])\\n                    res = max(res, A[i][j])\\n        return res ** 2\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nA[i][j] = The largest square containing only 1\\'s that includes indicies {1...i} and {1...j}\\n```\n```\\n1 1\\n1 1\\n```\n```\\nA[i][j] = 1 + min(A[i - 1][j], A[1][j - 1], A[i - 1][j - 1])\\n```\n```\\nclass Solution(object):\\n    def maximalSquare(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        if not matrix:\\n            return 0\\n        \\n        m, n = len(matrix), len(matrix[0])\\n        res = 0\\n        \\n        A = [[0] * n for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j] == \"1\":\\n                    A[i][j] = 1 + min(A[i - 1][j], A[i][j - 1], A[i - 1][j - 1])\\n                    res = max(res, A[i][j])\\n        return res ** 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 599811,
                "title": "python-dp-simple",
                "content": "- check elements in [i -1, j -1], [i, j - 1] and [j - 1, i] positions\\n- to eliminate first-row-problem plus-sized matrix is created and from [0, 0] element we actually look at [-1,-1] == [n + 1, m + 1] \\n- guys that add an empty array test in input should BURN IN HELL, fok\\'em\\n\\n```\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        if not matrix or not matrix[0]:\\n            return 0\\n        n, m = len(matrix), len(matrix[0])\\n        mat2 = [[0 for _ in range(m + 1)] for __ in range(n + 1)]\\n        for i in range(n):\\n            for j in range(m):\\n                mat2[i][j] = min(mat2[i - 1][j - 1], mat2[i - 1][j], mat2[i][j - 1]) + 1 if matrix[i][j] == \\'1\\' else 0\\n        return max([max(row) for row in mat2]) ** 2\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        if not matrix or not matrix[0]:\\n            return 0\\n        n, m = len(matrix), len(matrix[0])\\n        mat2 = [[0 for _ in range(m + 1)] for __ in range(n + 1)]\\n        for i in range(n):\\n            for j in range(m):\\n                mat2[i][j] = min(mat2[i - 1][j - 1], mat2[i - 1][j], mat2[i][j - 1]) + 1 if matrix[i][j] == \\'1\\' else 0\\n        return max([max(row) for row in mat2]) ** 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 599784,
                "title": "python-rolling-dp",
                "content": "2D DP is more easy to get start with.\\nLet `dp[i+1][j+1]` store the side length of the largest square with `(i, j)` as its right lower corner.\\nThen when `matrix[i][j] == \"1\"`, the recursion would be `dp[i+1][j+1] = min(dp[i+1][j], dp[i][j+1], dp[i][j]) + 1` . \\nOtherwise we reset `dp[i+1][j+1]` to `0`.\\nAnd we keep updating the longest side we found so far `max_len = max(max_len, dp[i+1][j+1])`.\\n\\nAnd since we only use `dp[i+1][j]`, `dp[i][j+1]` and `dp[i][j]` to get `dp[i+1][j+1]`, we can use rolling skill to optimize space to O(n). \\nIn `(i+1, j+1)`\\'s round, we use `dp[j]` to get `dp[i+1][j]` as `dp[j]` has been updated at `(i+1, j)`\\'s round. We use `dp[j+1]` to get `dp[i][j+1]` as `dp[j+1]` hasn\\'t been updated so it keeps old value in `(i, j+1)`\\'s round. We update `dp[j+1]` with calculated `dp[i+1][j+1]` value.\\nThe tricky part is how to get `dp[i][j]` value. We need to use a variable `cache` to store that.\\nYou can take reference [here](https://leetcode.com/problems/longest-common-subsequence/discuss/598294/python-c-dp-rolling-1d-array-solution).\\nHere is rolling solution. We just need a `dp[n]`.\\n```\\ndef maximalSquare(matrix):\\n    if not matrix:\\n        return 0\\n    m, n, max_len, cache = len(matrix), len(matrix[0]), 0, 0\\n    dp = [0] * (n+1)\\n    for i in range(m):\\n        for j in range(n):\\n            if matrix[i][j] == \"1\":\\n                dp[j+1], cache = min(dp[j], dp[j+1], cache) + 1, dp[j+1]\\n                max_len = max(max_len, dp[j+1])\\n            else:\\n                dp[j+1], cache = 0, dp[j+1]\\n    return max_len * max_len\\n```\\n\\nHere post 2D dp solution for a reference.\\n```\\ndef maximalSquare(matrix):\\n    if not matrix:\\n        return 0\\n    m, n, max_len = len(matrix), len(matrix[0]), 0\\n    dp = [[0] * (n+1) for _ in range(m+1)]\\n    for i in range(m):\\n        for j in range(n):\\n            if matrix[i][j] == \"1\":\\n                dp[i+1][j+1] = min(dp[i+1][j], dp[i][j+1], dp[i][j]) + 1\\n                max_len = max(max_len, dp[i+1][j+1])\\n            else:\\n                dp[i+1][j+1] = 0\\n    return max_len * max_len\\n```",
                "solutionTags": [],
                "code": "```\\ndef maximalSquare(matrix):\\n    if not matrix:\\n        return 0\\n    m, n, max_len, cache = len(matrix), len(matrix[0]), 0, 0\\n    dp = [0] * (n+1)\\n    for i in range(m):\\n        for j in range(n):\\n            if matrix[i][j] == \"1\":\\n                dp[j+1], cache = min(dp[j], dp[j+1], cache) + 1, dp[j+1]\\n                max_len = max(max_len, dp[j+1])\\n            else:\\n                dp[j+1], cache = 0, dp[j+1]\\n    return max_len * max_len\\n```\n```\\ndef maximalSquare(matrix):\\n    if not matrix:\\n        return 0\\n    m, n, max_len = len(matrix), len(matrix[0]), 0\\n    dp = [[0] * (n+1) for _ in range(m+1)]\\n    for i in range(m):\\n        for j in range(n):\\n            if matrix[i][j] == \"1\":\\n                dp[i+1][j+1] = min(dp[i+1][j], dp[i][j+1], dp[i][j]) + 1\\n                max_len = max(max_len, dp[i+1][j+1])\\n            else:\\n                dp[i+1][j+1] = 0\\n    return max_len * max_len\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 464431,
                "title": "python-recursion-memoization-tabulation",
                "content": "# RECURSION\\n```Python\\ndef maximalSquareR(matrix,i,j):\\n    if i >= len(matrix) or j >= len(matrix[0]): return 0\\n    if matrix[i][j] == \\'0\\': return 0\\n    return min(maximalSquareR(matrix,i+1,j),maximalSquareR(matrix,i+1,j+1),maximalSquareR(matrix,i,j+1)) + 1\\nmaxs = -float(\"inf\")\\nfor i in range(len(matrix)):\\n    for j in range(len(matrix[0])):\\n        if matrix[i][j] == 1:\\n            maxs = max(maxs,maximalSquareR(matrix,i,j))\\nreturn maxs*maxs\\n```\\n# MEMOIZATION (TOP DOWN)\\n```Python\\ndef maximalSquareMemo(matrix,i,j,cache):\\n    if i >= len(matrix) or j >= len(matrix[0]): return 0\\n    if matrix[i][j] == \\'0\\': cache[i][j] = 0\\n    if cache[i][j] != -1:\\n        return cache[i][j]\\n    else:\\n        cache[i][j] = min(maximalSquareMemo(matrix,i+1,j,cache),maximalSquareMemo(matrix,i+1,j+1,cache),maximalSquareMemo(matrix,i,j+1,cache)) + 1\\n    return cache[i][j]\\nmaxs = -float(\"inf\")\\ncache = [[-1 for i in range(len(matrix[0]))] for j in range(len(matrix))]\\nfor i in range(len(matrix)):\\n    for j in range(len(matrix[0])):\\n        maxs = max(maxs,maximalSquareMemo(matrix,i,j,cache))\\nreturn maxs*maxs\\n```\\n# TABULATION (BOTTOM UP)\\n```Python\\n    def maximalSquare(matrix):\\n        if not matrix:\\n            return 0\\n        maxs = 0\\n        dp = [[0 for i in range(len(matrix[0])+1)] for j in range(len(matrix)+1)]\\n        for i in range(1,len(matrix)+1):\\n            for j in range(1,len(matrix[0])+1):\\n                if i == 0 or j ==0: continue;\\n                elif matrix[i-1][j-1] == \\'1\\':\\n                    dp[i][j] = min(int(dp[i-1][j-1]),int(dp[i-1][j]),int(dp[i][j-1]))+1\\n                    maxs = max(maxs,dp[i][j])\\n        return maxs*maxs\\n```",
                "solutionTags": [],
                "code": "```Python\\ndef maximalSquareR(matrix,i,j):\\n    if i >= len(matrix) or j >= len(matrix[0]): return 0\\n    if matrix[i][j] == \\'0\\': return 0\\n    return min(maximalSquareR(matrix,i+1,j),maximalSquareR(matrix,i+1,j+1),maximalSquareR(matrix,i,j+1)) + 1\\nmaxs = -float(\"inf\")\\nfor i in range(len(matrix)):\\n    for j in range(len(matrix[0])):\\n        if matrix[i][j] == 1:\\n            maxs = max(maxs,maximalSquareR(matrix,i,j))\\nreturn maxs*maxs\\n```\n```Python\\ndef maximalSquareMemo(matrix,i,j,cache):\\n    if i >= len(matrix) or j >= len(matrix[0]): return 0\\n    if matrix[i][j] == \\'0\\': cache[i][j] = 0\\n    if cache[i][j] != -1:\\n        return cache[i][j]\\n    else:\\n        cache[i][j] = min(maximalSquareMemo(matrix,i+1,j,cache),maximalSquareMemo(matrix,i+1,j+1,cache),maximalSquareMemo(matrix,i,j+1,cache)) + 1\\n    return cache[i][j]\\nmaxs = -float(\"inf\")\\ncache = [[-1 for i in range(len(matrix[0]))] for j in range(len(matrix))]\\nfor i in range(len(matrix)):\\n    for j in range(len(matrix[0])):\\n        maxs = max(maxs,maximalSquareMemo(matrix,i,j,cache))\\nreturn maxs*maxs\\n```\n```Python\\n    def maximalSquare(matrix):\\n        if not matrix:\\n            return 0\\n        maxs = 0\\n        dp = [[0 for i in range(len(matrix[0])+1)] for j in range(len(matrix)+1)]\\n        for i in range(1,len(matrix)+1):\\n            for j in range(1,len(matrix[0])+1):\\n                if i == 0 or j ==0: continue;\\n                elif matrix[i-1][j-1] == \\'1\\':\\n                    dp[i][j] = min(int(dp[i-1][j-1]),int(dp[i-1][j]),int(dp[i][j-1]))+1\\n                    maxs = max(maxs,dp[i][j])\\n        return maxs*maxs\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 325137,
                "title": "easy-to-understand-python-dp-solution-with-explaination",
                "content": "The key to dynamic programming is to under a big square is made up of smaller squares.\\n\\nSquare is by defintion all four sides with the same length.  \\n\\nLet dp[i][j] be the length of the lower right corner of the square.   \\ndp[i-1][j-1], dp[i-1][j], dp[i][j-1] must also be squares\\n\\nIt is easy to build up the dp table by traversing from left to right, up to bottom.  \\n\\n```\\nmap            dp\\n1,1,1,1      1,1,1,1\\n1,1,1,0      1,2,2,0\\n1,1,1,0      1,2,3,0\\n```\\n\\n```\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        rows = len(matrix)\\n        if rows == 0: return 0\\n        cols = len(matrix[0])\\n        dp = []\\n        for i in range(rows):\\n            dp.append([0] * cols)\\n        \\n        maxSize = 0\\n        for r in range(rows):\\n            for c in range(cols):\\n                if matrix[r][c] == \\'0\\': continue\\n                if r == 0 or c == 0:\\n                    dp[r][c] = int(matrix[r][c])\\n                else:\\n                    dp[r][c] = min(dp[r-1][c-1], dp[r-1][c], dp[r][c-1]) + 1\\n                maxSize = max(maxSize, dp[r][c])\\n        \\n        return maxSize * maxSize\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nmap            dp\\n1,1,1,1      1,1,1,1\\n1,1,1,0      1,2,2,0\\n1,1,1,0      1,2,3,0\\n```\n```\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        rows = len(matrix)\\n        if rows == 0: return 0\\n        cols = len(matrix[0])\\n        dp = []\\n        for i in range(rows):\\n            dp.append([0] * cols)\\n        \\n        maxSize = 0\\n        for r in range(rows):\\n            for c in range(cols):\\n                if matrix[r][c] == \\'0\\': continue\\n                if r == 0 or c == 0:\\n                    dp[r][c] = int(matrix[r][c])\\n                else:\\n                    dp[r][c] = min(dp[r-1][c-1], dp[r-1][c], dp[r][c-1]) + 1\\n                maxSize = max(maxSize, dp[r][c])\\n        \\n        return maxSize * maxSize\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 61885,
                "title": "clean-c-dp-solution",
                "content": "We can derive the formula of side length of the square: dp[i][j] = matrix[i][j] == '0' ? 0 : min{dp[i-1][j], dp[i][j-1], dp[i-1][j-1]}+1.\\n\\n    class Solution {\\n    public:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int m = matrix.size();\\n        if(m==0) return 0;\\n        int n = matrix[0].size();\\n        \\n        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\\n        \\n        int ret = 0;\\n        for(int i = 1; i <= m; i ++){\\n            for(int j = 1; j <= n; j ++){\\n                if(matrix[i-1][j-1] == '0'){\\n                    dp[i][j] = 0;\\n                }else{\\n                    dp[i][j] = 1 + min(dp[i-1][j], min(dp[i][j-1], dp[i-1][j-1]));\\n                }\\n                ret = max(ret, dp[i][j]);\\n            }\\n        }\\n        return ret*ret;\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int m = matrix.size();\\n        if(m==0) return 0;\\n        int n = matrix[0].size();\\n        \\n        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\\n        \\n        int ret = 0;\\n        for(int i = 1; i <= m; i ++){\\n            for(int j = 1; j <= n; j ++){\\n                if(matrix[i-1][j-1] == '0'){\\n                    dp[i][j] = 0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3748753,
                "title": "easy-c-solution-using-memoization",
                "content": "\\n# Approach\\nDefine a helper function solve that takes the matrix, current indices (i and j), the reference to maxi, and the dp matrix as parameters.\\n\\nInside the solve function, check if the indices i and j are out of bounds of the matrix. If they are, return 0.\\n\\nCheck if the current cell in the matrix is already visited (marked by dp[i][j] != -1). If it is, return the value stored in dp[i][j].\\n\\nRecursively call the solve function for the right cell, diagonal cell, and bottom cell to explore all possible squares starting from the current position. Store the results in right, diagonal, and bottom variables.\\n\\nIf the current cell contains a \\'1\\', calculate the size of the square that can be formed starting from this cell. This can be done by adding 1 to the minimum of the values from the right, diagonal, and bottom cells.\\n\\nUpdate maxi by taking the maximum of the current square size and the existing maxi.\\n\\nStore the current square size in dp[i][j] for memoization.\\n\\nReturn the current square size.\\n\\nIn the maximalSquare function, initialize the dp matrix with -1 values.\\n\\nInitialize maxi with 0 before calling the solve function with the starting indices (0, 0) and the matrix.\\n\\nReturn the maximum square area by multiplying maxi by itself (i.e., maxi * maxi).\\n\\nThis approach uses dynamic programming and memoization to avoid redundant calculations and optimize the solution.\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n# Code\\n```\\n#include <algorithm>\\n#include <vector>\\nclass Solution {\\npublic:\\nint solve(vector<vector<char>>& matrix, int i , int j ,int& maxi,vector<vector<int>>&dp)\\n{\\n    // CHECK IF INDEX ARE OUT OF BOUND OR NOT \\n    if(i>=matrix.size() || j>=matrix[0].size())\\n    {\\n        return 0 ;\\n    }\\n\\n    if(dp[i][j]!=-1)\\n    {\\n        return dp[i][j];\\n    }\\n    int right=solve(matrix,i,j+1,maxi,dp);\\n    int diagonal=solve(matrix,i+1,j+1,maxi,dp);\\n    int bottom=solve(matrix,i+1,j,maxi,dp);\\n    if(matrix[i][j]==\\'1\\')\\n    {\\n        dp[i][j] = 1+min(right, min(diagonal , bottom));\\n        maxi=max(dp[i][j],maxi);\\n        return dp[i][j];\\n    }\\n    else\\n        return 0 ;\\n\\n}\\n    int maximalSquare(vector<vector<char>>& matrix)\\n    {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n\\n        int maxi = 0;\\n        int s=solve(matrix, 0,0 , maxi,dp);\\n          return maxi * maxi; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n#include <algorithm>\\n#include <vector>\\nclass Solution {\\npublic:\\nint solve(vector<vector<char>>& matrix, int i , int j ,int& maxi,vector<vector<int>>&dp)\\n{\\n    // CHECK IF INDEX ARE OUT OF BOUND OR NOT \\n    if(i>=matrix.size() || j>=matrix[0].size())\\n    {\\n        return 0 ;\\n    }\\n\\n    if(dp[i][j]!=-1)\\n    {\\n        return dp[i][j];\\n    }\\n    int right=solve(matrix,i,j+1,maxi,dp);\\n    int diagonal=solve(matrix,i+1,j+1,maxi,dp);\\n    int bottom=solve(matrix,i+1,j,maxi,dp);\\n    if(matrix[i][j]==\\'1\\')\\n    {\\n        dp[i][j] = 1+min(right, min(diagonal , bottom));\\n        maxi=max(dp[i][j],maxi);\\n        return dp[i][j];\\n    }\\n    else\\n        return 0 ;\\n\\n}\\n    int maximalSquare(vector<vector<char>>& matrix)\\n    {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n\\n        int maxi = 0;\\n        int s=solve(matrix, 0,0 , maxi,dp);\\n          return maxi * maxi; \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3642734,
                "title": "c-93ms-most-optimized-bottom-up-solution-dynamic-programming",
                "content": "# Intuition\\nDynamic Programming , Matrix Traversal , Tracking Square Size , Optimization\\n\\n# Explanation\\n\\n\\nThe approach used in the code is dynamic programming, specifically **Bottom-up tabulation.**\\n\\n   - Parameters: `vector<vector<char>>& v` - the input binary matrix, `int& maxi` - a reference variable to store the maximum square size\\n   - Return type: `int` - returns the size of the largest square\\n\\n   This function calculates the maximum square size using dynamic programming.\\n\\n   - Variables:\\n     - `n` and `m`: the dimensions of the matrix (`n` rows, `m` columns)\\n     - `dp`: a 2D vector representing the dynamic programming table, initialized with zeros\\n     - `right`, `diagonal`, and `down`: variables to store the values of the neighboring cells in the DP table\\n     - `ans`: variable to store the current cell\\'s value in the DP table\\n     - `maxi`: stores the maximum square size encountered so far\\n\\n   - Iteration:\\n     - The nested loops iterate over each cell in reverse order, starting from the bottom-right corner of the matrix.\\n     - For each cell, the neighboring cells to the right, diagonal, and down are accessed to calculate the minimum value.\\n     - If the current cell in the matrix is \\'1\\', the minimum of the neighboring cells is computed, incremented by 1, and stored in the `ans` variable.\\n     - The `maxi` variable is updated with the maximum value encountered so far.\\n     - The `dp` table is updated with the `ans` value.\\n     - If the current cell in the matrix is \\'0\\', the `dp` table is updated with 0.\\n\\n   - Time Complexity: The time complexity of this function is O(n * m), where n is the number of rows and m is the number of columns in the matrix. The nested loops iterate over each cell exactly once.\\n\\n   - Space Complexity: The space complexity is O(n * m) since we are using a 2D vector (`dp`) to store the dynamic programming table.\\n\\n2. Function `maximalSquare`:\\n   - Parameter: `vector<vector<char>>& matrix` - the input binary matrix\\n   - Return type: `int` - returns the size of the largest square\\n\\n   This function serves as a wrapper function to call the `solveTab` function and calculate the maximum square size.\\n\\n   - Variables:\\n     - `n` and `m`: the dimensions of the matrix (`n` rows, `m` columns)\\n     - `maxi`: stores the maximum square size encountered\\n\\n   - Calculation:\\n     - The dimensions of the matrix are obtained using `matrix.size()` and `matrix[0].size()`.\\n     - The `maxi` variable is initialized to 0.\\n     - The `solveTab` function is called with the matrix and `maxi` as parameters to calculate the maximum square size.\\n     - The function returns `maxi * maxi`, which represents the area of the largest square.\\n\\n# Complexity\\n- Time complexity: **O(n*m)**\\n\\n- Space complexity: **O(n*m)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint solveTab(vector<vector<char>>&v,int &maxi)\\n{\\n    int n(v.size()),m(v[0].size());\\n    vector<vector<int>>dp(n+1,vector<int>(m+1,0));\\n    for(int i=n-1;i>=0;i--)\\n    {\\n        for(int j=m-1;j>=0;j--)\\n        {\\n            int right=dp[i][j+1];\\n            int diagonal=dp[i+1][j+1];\\n            int down=dp[i+1][j];\\n            if(v[i][j] == \\'1\\'){\\n                int ans=1+min({right,down,diagonal});\\n                maxi=max(maxi,ans);\\n                dp[i][j]=ans;                                                                           \\n            }\\n            else{\\n                dp[i][j]=0;\\n            }\\n        }\\n\\n    }\\n    return dp[0][0];\\n}\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int n(matrix.size()),m(matrix[0].size());\\n        int maxi=0;\\n        solveTab(matrix,maxi);\\n        return maxi*maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint solveTab(vector<vector<char>>&v,int &maxi)\\n{\\n    int n(v.size()),m(v[0].size());\\n    vector<vector<int>>dp(n+1,vector<int>(m+1,0));\\n    for(int i=n-1;i>=0;i--)\\n    {\\n        for(int j=m-1;j>=0;j--)\\n        {\\n            int right=dp[i][j+1];\\n            int diagonal=dp[i+1][j+1];\\n            int down=dp[i+1][j];\\n            if(v[i][j] == \\'1\\'){\\n                int ans=1+min({right,down,diagonal});\\n                maxi=max(maxi,ans);\\n                dp[i][j]=ans;                                                                           \\n            }\\n            else{\\n                dp[i][j]=0;\\n            }\\n        }\\n\\n    }\\n    return dp[0][0];\\n}\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int n(matrix.size()),m(matrix[0].size());\\n        int maxi=0;\\n        solveTab(matrix,maxi);\\n        return maxi*maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2953863,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int sz=0, pre;\\n        vector<int> dp(n);\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                    int temp=dp[j];\\n                if(i==0 || j==0 || matrix[i][j]==\\'0\\')\\n                    dp[j]=matrix[i][j]-\\'0\\';\\n                else\\n                {\\n                    dp[j]=min({dp[j], dp[j-1], pre})+1;\\n                }\\n                sz=max(sz, dp[j]);\\n                    pre=temp;\\n            }\\n        }\\n        return sz*sz;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int sz=0, pre;\\n        vector<int> dp(n);\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                    int temp=dp[j];\\n                if(i==0 || j==0 || matrix[i][j]==\\'0\\')\\n                    dp[j]=matrix[i][j]-\\'0\\';\\n                else\\n                {\\n                    dp[j]=min({dp[j], dp[j-1], pre})+1;\\n                }\\n                sz=max(sz, dp[j]);\\n                    pre=temp;\\n            }\\n        }\\n        return sz*sz;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2953861,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int sz=0, pre;\\n        vector<int> dp(n);\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                    int temp=dp[j];\\n                if(i==0 || j==0 || matrix[i][j]==\\'0\\')\\n                    dp[j]=matrix[i][j]-\\'0\\';\\n                else\\n                {\\n                    dp[j]=min({dp[j], dp[j-1], pre})+1;\\n                }\\n                sz=max(sz, dp[j]);\\n                    pre=temp;\\n            }\\n        }\\n        return sz*sz;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int sz=0, pre;\\n        vector<int> dp(n);\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                    int temp=dp[j];\\n                if(i==0 || j==0 || matrix[i][j]==\\'0\\')\\n                    dp[j]=matrix[i][j]-\\'0\\';\\n                else\\n                {\\n                    dp[j]=min({dp[j], dp[j-1], pre})+1;\\n                }\\n                sz=max(sz, dp[j]);\\n                    pre=temp;\\n            }\\n        }\\n        return sz*sz;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2462695,
                "title": "everything-you-need-dp-c",
                "content": "```\\nclass Solution {\\npublic:\\n    //\\tJUST REMEMBER THAT TO MAKE A SQUARE FROM A POINT YOU WANT A RIGHT,DIAGNOL AND A BOTTOM POINT. \\n\\nint maxi=0;\\n// //RECURSIVE SOLN.(TLE)\\nint solve(vector<vector<char>>& matrix, int i, int j, int n, int m)\\n{\\n    if(i>=n||j>=m)\\n        return 0;\\n    \\n    int right=solve(matrix,i,j+1,n,m);\\n    int diag=solve(matrix,i+1,j+1,n,m);\\n    int bottom=solve(matrix,i+1,j,n,m);\\n    \\n    if(matrix[i][j]==\\'1\\')\\n    {\\n        maxi=max(maxi, 1+min(right,min(diag,bottom)));  //storing max is a major step we can\\'t just return the below\\n        return 1+min(right,min(diag,bottom));\\n    }\\n    else \\n    {\\n        return 0;\\n    }\\n    \\n}\\n// //MEMOIZATION METHOD\\nint solveTab(vector<vector<char>>& matrix, int i, int j, int n, int m, vector<vector<int>> &dp)\\n{\\n    if(i>=n||j>=m)\\n        return 0;\\n    if(dp[i][j]!=-1) return dp[i][j];\\n    \\n    int right=solveMem(matrix,i,j+1,n,m,dp);\\n    int diag=solveMem(matrix,i+1,j+1,n,m,dp);\\n    int bottom=solveMem(matrix,i+1,j,n,m,dp);\\n\\t\\n    if(matrix[i][j]==\\'1\\')\\n    {\\n        dp[i][j]=1+min(right,min(diag,bottom));\\n        maxi=max(maxi,dp[i][j]);\\n        return dp[i][j];\\n    }\\n    else \\n    {\\n        return 0;\\n    }\\n}\\n\\n// //TABULATION METHOD \\nvoid solveTab(vector<vector<char>>& matrix, int i, int j, int n, int m)\\n{\\n    vector<vector<int>>dp(n+1,vector<int>(m+1,0));\\n    \\n    for(int i=n-1;i>=0;i--)\\n    {\\n        for(int j=m-1;j>=0;j--)\\n        {\\n            int right=dp[i][j+1];\\n            int diag=dp[i+1][j+1];\\n            int bottom=dp[i+1][j];\\n            if(matrix[i][j]==\\'1\\')\\n            {\\n                dp[i][j]=1+min(right,min(diag,bottom));\\n                maxi=max(maxi,dp[i][j]);\\n            }\\n            //As for all the 0 cases we\\'ve already filled 0, we don\\'t have to write extra else condiiton this makes the code much faster\\n        }\\n    }\\n}\\n//SPACE OPTIMIZATION\\nvoid solveSO(vector<vector<char>>& matrix, int n, int m)\\n{\\n    \\n    vector<int>prev(m+1,0); \\n    vector<int>cur(m+1,0);\\n    for(int i=n-1;i>=0;i--)\\n    {\\n        fill(cur.begin(), cur.end(), 0);  //u could also have declared the cur array again or instead wrote a else condition assigning 0 value to cur[j] but this is the fastest method i could get :)\\n        for(int j=m-1;j>=0;j--)\\n        {\\n            if(matrix[i][j]==\\'1\\')\\n            {\\n                cur[j]=1+min(cur[j+1],min(prev[j+1],prev[j]));\\n                maxi=max(maxi,cur[j]);\\n            }\\n            \\n        }\\n        prev=cur;\\n    }\\n}\\n\\nint maximalSquare(vector<vector<char>>& matrix) {\\n    int n=matrix.size(); int m=matrix[0].size();\\n    vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n    // solve(matrix,0,0,n,m);\\n    // solveMem(matrix,0,0,n,m,dp);\\n    // solveTab(matrix,0,0,n,m);\\n   solveSO(matrix,n,m);\\n     return maxi*maxi;\\n}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //\\tJUST REMEMBER THAT TO MAKE A SQUARE FROM A POINT YOU WANT A RIGHT,DIAGNOL AND A BOTTOM POINT. \\n\\nint maxi=0;\\n// //RECURSIVE SOLN.(TLE)\\nint solve(vector<vector<char>>& matrix, int i, int j, int n, int m)\\n{\\n    if(i>=n||j>=m)\\n        return 0;\\n    \\n    int right=solve(matrix,i,j+1,n,m);\\n    int diag=solve(matrix,i+1,j+1,n,m);\\n    int bottom=solve(matrix,i+1,j,n,m);\\n    \\n    if(matrix[i][j]==\\'1\\')\\n    {\\n        maxi=max(maxi, 1+min(right,min(diag,bottom)));  //storing max is a major step we can\\'t just return the below\\n        return 1+min(right,min(diag,bottom));\\n    }\\n    else \\n    {\\n        return 0;\\n    }\\n    \\n}\\n// //MEMOIZATION METHOD\\nint solveTab(vector<vector<char>>& matrix, int i, int j, int n, int m, vector<vector<int>> &dp)\\n{\\n    if(i>=n||j>=m)\\n        return 0;\\n    if(dp[i][j]!=-1) return dp[i][j];\\n    \\n    int right=solveMem(matrix,i,j+1,n,m,dp);\\n    int diag=solveMem(matrix,i+1,j+1,n,m,dp);\\n    int bottom=solveMem(matrix,i+1,j,n,m,dp);\\n\\t\\n    if(matrix[i][j]==\\'1\\')\\n    {\\n        dp[i][j]=1+min(right,min(diag,bottom));\\n        maxi=max(maxi,dp[i][j]);\\n        return dp[i][j];\\n    }\\n    else \\n    {\\n        return 0;\\n    }\\n}\\n\\n// //TABULATION METHOD \\nvoid solveTab(vector<vector<char>>& matrix, int i, int j, int n, int m)\\n{\\n    vector<vector<int>>dp(n+1,vector<int>(m+1,0));\\n    \\n    for(int i=n-1;i>=0;i--)\\n    {\\n        for(int j=m-1;j>=0;j--)\\n        {\\n            int right=dp[i][j+1];\\n            int diag=dp[i+1][j+1];\\n            int bottom=dp[i+1][j];\\n            if(matrix[i][j]==\\'1\\')\\n            {\\n                dp[i][j]=1+min(right,min(diag,bottom));\\n                maxi=max(maxi,dp[i][j]);\\n            }\\n            //As for all the 0 cases we\\'ve already filled 0, we don\\'t have to write extra else condiiton this makes the code much faster\\n        }\\n    }\\n}\\n//SPACE OPTIMIZATION\\nvoid solveSO(vector<vector<char>>& matrix, int n, int m)\\n{\\n    \\n    vector<int>prev(m+1,0); \\n    vector<int>cur(m+1,0);\\n    for(int i=n-1;i>=0;i--)\\n    {\\n        fill(cur.begin(), cur.end(), 0);  //u could also have declared the cur array again or instead wrote a else condition assigning 0 value to cur[j] but this is the fastest method i could get :)\\n        for(int j=m-1;j>=0;j--)\\n        {\\n            if(matrix[i][j]==\\'1\\')\\n            {\\n                cur[j]=1+min(cur[j+1],min(prev[j+1],prev[j]));\\n                maxi=max(maxi,cur[j]);\\n            }\\n            \\n        }\\n        prev=cur;\\n    }\\n}\\n\\nint maximalSquare(vector<vector<char>>& matrix) {\\n    int n=matrix.size(); int m=matrix[0].size();\\n    vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n    // solve(matrix,0,0,n,m);\\n    // solveMem(matrix,0,0,n,m,dp);\\n    // solveTab(matrix,0,0,n,m);\\n   solveSO(matrix,n,m);\\n     return maxi*maxi;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2220906,
                "title": "java-clean-simple-recursive-dp",
                "content": "```\\nclass Solution {\\n    public int maximalSquare(char[][] matrix) {\\n        int[][] map = new int[matrix.length][matrix[0].length];\\n        int result = 0;\\n\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                result = Math.max(result, helper(i, j, matrix, map));\\n            }\\n        }\\n        return result * result;\\n    }\\n\\n    public int helper(int r, int c, char[][] arr, int[][] map) {\\n        if (r == arr.length || c == arr[0].length || arr[r][c] == \\'0\\')\\n            return 0;\\n\\n        if (map[r][c] != 0)\\n            return map[r][c];\\n\\n        int current = Math.min(helper(r + 1, c, arr, map),\\n                Math.min(helper(r, c + 1, arr, map), helper(r + 1, c + 1, arr, map)));\\n\\n        map[r][c] = current + 1;\\n        return map[r][c];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int maximalSquare(char[][] matrix) {\\n        int[][] map = new int[matrix.length][matrix[0].length];\\n        int result = 0;\\n\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                result = Math.max(result, helper(i, j, matrix, map));\\n            }\\n        }\\n        return result * result;\\n    }\\n\\n    public int helper(int r, int c, char[][] arr, int[][] map) {\\n        if (r == arr.length || c == arr[0].length || arr[r][c] == \\'0\\')\\n            return 0;\\n\\n        if (map[r][c] != 0)\\n            return map[r][c];\\n\\n        int current = Math.min(helper(r + 1, c, arr, map),\\n                Math.min(helper(r, c + 1, arr, map), helper(r + 1, c + 1, arr, map)));\\n\\n        map[r][c] = current + 1;\\n        return map[r][c];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1632325,
                "title": "o-nm-time-o-m-space-solution",
                "content": "**Idea**\\n* **Dynamic Programming**\\n* `dp[i][j] = 1 + min({dp[i][j-1],dp[i-1][j],dp[i-1][j-1]})` when `matrix[i][j]` contains \\'1\\'\\n* We can optimise the above n * m dp table to 2 * m dp table since answering for current cell (r,c) depends totally on current and previous row.\\n\\n```\\nclass Solution {\\npublic:\\n    // Time Complexity:- O(NM)\\n    // Space Complexity:- O(M)\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int side = 0;\\n        vector<vector<int>> dp(2,vector<int>(matrix[0].size()));\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[i].size();j++){\\n                dp[i%2][j] = matrix[i][j]-\\'0\\';\\n                if(i and j and dp[i%2][j])\\n                    dp[i%2][j] = 1 + min({dp[i%2][j-1],dp[(i-1)%2][j],dp[(i-1)%2][j-1]});\\n                side = max(side,dp[i%2][j]);\\n            }\\n        }\\n        return side*side;\\n    }\\n};\\n```\\n**Don\\'t Forget to Upvote!**",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Time Complexity:- O(NM)\\n    // Space Complexity:- O(M)\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int side = 0;\\n        vector<vector<int>> dp(2,vector<int>(matrix[0].size()));\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[i].size();j++){\\n                dp[i%2][j] = matrix[i][j]-\\'0\\';\\n                if(i and j and dp[i%2][j])\\n                    dp[i%2][j] = 1 + min({dp[i%2][j-1],dp[(i-1)%2][j],dp[(i-1)%2][j-1]});\\n                side = max(side,dp[i%2][j]);\\n            }\\n        }\\n        return side*side;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1569523,
                "title": "java-aditya-verma-similar-to-maximal-rectangle-minor-modification-dfs-memo-bottom-up-dp",
                "content": "**1. Aditya Verma Approach, similar to Maximal Rectangle Problem with minor modification**\\n```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n\\t\\t// your code here\\n\\t\\t// nearest smaller to left\\n\\t\\tint n = heights.length;\\n\\t\\tint max = Integer.MIN_VALUE;\\n\\t\\tStack<Integer> left = new Stack<>();\\n\\t\\tint[] l = new int[n];\\n\\n\\t\\tStack<Integer> right = new Stack<>();\\n\\t\\tint[] r = new int[n];\\n\\t\\t// NSL\\n\\t\\t// we need to find the index of the next smaller element on the left side\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\twhile (!left.isEmpty() && heights[left.peek()] >= heights[i]) {\\n\\t\\t\\t\\tleft.pop();\\n\\t\\t\\t}\\n\\t\\t\\tif (left.isEmpty()) {\\n\\t\\t\\t\\tl[i] = -1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tl[i] = left.peek();\\n\\t\\t\\t}\\n\\t\\t\\tleft.push(i);\\n\\t\\t}\\n\\n\\t\\t// NSR\\n\\t\\t// we need to find the index of the next smaller element to the right side\\n\\t\\t// handle edge case , when there are no smaller elements to the right\\n\\t\\t// assume the next smaller elements index to be lenght of the inout array in\\n\\t\\t// that case\\n\\t\\t// we do this to facilitate the max calculation that has been done in the end\\n\\t\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\t\\twhile (!right.isEmpty() && heights[right.peek()] >= heights[i]) {\\n\\t\\t\\t\\tright.pop();\\n\\t\\t\\t}\\n\\t\\t\\tif (right.isEmpty()) {\\n\\t\\t\\t\\tr[i] = n;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tr[i] = right.peek();\\n\\t\\t\\t}\\n\\t\\t\\tright.push(i);\\n\\t\\t}\\n\\n        // modification here, we need a square, so taking the min of length and height of\\n        // each block and calculating area, take max of all, that will be our ans\\n\\t\\tfor (int i = 0; i < n; i++) {\\n            int length=r[i] - l[i] - 1;\\n            int height=heights[i];\\n            int side=Math.min(length,height);\\n            max = Math.max(max, (side*side));\\n\\t\\t}\\n\\t\\treturn max;\\n\\t}\\n    public int maximalSquare(char[][] matrix) {\\n        int m = matrix.length;\\n        if(m==0){\\n            return 0;\\n        }\\n\\t\\tint n = matrix[0].length;\\n\\t\\tint[] heights = new int[n];\\n\\t\\tint max = Integer.MIN_VALUE;\\n\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tif (i == 0) {\\n\\t\\t\\t\\t\\theights[j] = matrix[i][j] - \\'0\\';\\n\\t\\t\\t\\t} else if (matrix[i][j] - \\'0\\' == 0) {\\n\\t\\t\\t\\t\\theights[j] = 0;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\theights[j] = heights[j] + (matrix[i][j] - \\'0\\');\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tmax = Math.max(max, largestRectangleArea(heights));\\n\\t\\t}\\n\\t\\treturn max;\\n    }\\n}\\n```\\n\\n**2. DFS+Memo(Top Down)**\\n```\\nclass Solution {\\n     public int maximalSquare(char[][] a) {\\n\\t\\tif(a.length == 0) return 0;\\n        int m = a.length, n = a[0].length;\\n        int ans = Integer.MIN_VALUE;\\n        Integer[][] dp = new Integer[m + 1][n + 1];\\n        for(int i = 0; i < m ; i++) {\\n            for(int j = 0; j < n;j++) {\\n                if(a[i][j] == \\'1\\') {\\n                    ans = Math.max(ans, dfs(a, i, j, m, n, dp));\\n                }\\n            }\\n        }\\n        return ans*ans;        \\n    }\\n    private int dfs(char[][] a, int i, int j, int m, int n, Integer[][] dp) {\\n        if( i  < 0 || i >=m || j < 0 || j >=n ||a[i][j] == \\'0\\') return 0;\\n        if(dp[i][j] != null) return dp[i][j];\\n        int down = dfs(a, i + 1, j, m, n, dp);\\n        int right = dfs(a, i, j + 1, m, n, dp);\\n        int diagonal = dfs(a, i + 1, j + 1, m, n, dp);\\n        return dp[i][j] = 1 + Math.min(Math.min(down, right), diagonal);\\n        \\n    }\\n}\\n```\\n\\n**3. Bottom Up DP**\\n```\\nclass Solution {\\n\\tpublic int maximalSquare(char[][] matrix) {\\n\\t\\tint rows = matrix.length;\\n\\t\\tif (rows == 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tint column = matrix[0].length;\\n\\t\\tint[][] dp = new int[rows + 1][column + 1];\\n\\n\\t\\tint largest = 0;\\n\\t\\tfor (int i = 1; i <= rows; i++) {\\n\\t\\t\\tfor (int j = 1; j <= column; j++) {\\n\\n\\t\\t\\t\\tif (matrix[i - 1][j - 1] == \\'1\\') {\\n\\t\\t\\t\\t\\t// value = current val + left diagonal + left row + upper col\\n\\t\\t\\t\\t\\tdp[i][j] = 1 + Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1]));\\n\\n\\t\\t\\t\\t\\tif (largest < dp[i][j])\\n\\t\\t\\t\\t\\t\\tlargest = dp[i][j];\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn largest * largest;\\n\\t}\\n\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int largestRectangleArea(int[] heights) {\\n\\t\\t// your code here\\n\\t\\t// nearest smaller to left\\n\\t\\tint n = heights.length;\\n\\t\\tint max = Integer.MIN_VALUE;\\n\\t\\tStack<Integer> left = new Stack<>();\\n\\t\\tint[] l = new int[n];\\n\\n\\t\\tStack<Integer> right = new Stack<>();\\n\\t\\tint[] r = new int[n];\\n\\t\\t// NSL\\n\\t\\t// we need to find the index of the next smaller element on the left side\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\twhile (!left.isEmpty() && heights[left.peek()] >= heights[i]) {\\n\\t\\t\\t\\tleft.pop();\\n\\t\\t\\t}\\n\\t\\t\\tif (left.isEmpty()) {\\n\\t\\t\\t\\tl[i] = -1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tl[i] = left.peek();\\n\\t\\t\\t}\\n\\t\\t\\tleft.push(i);\\n\\t\\t}\\n\\n\\t\\t// NSR\\n\\t\\t// we need to find the index of the next smaller element to the right side\\n\\t\\t// handle edge case , when there are no smaller elements to the right\\n\\t\\t// assume the next smaller elements index to be lenght of the inout array in\\n\\t\\t// that case\\n\\t\\t// we do this to facilitate the max calculation that has been done in the end\\n\\t\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\t\\twhile (!right.isEmpty() && heights[right.peek()] >= heights[i]) {\\n\\t\\t\\t\\tright.pop();\\n\\t\\t\\t}\\n\\t\\t\\tif (right.isEmpty()) {\\n\\t\\t\\t\\tr[i] = n;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tr[i] = right.peek();\\n\\t\\t\\t}\\n\\t\\t\\tright.push(i);\\n\\t\\t}\\n\\n        // modification here, we need a square, so taking the min of length and height of\\n        // each block and calculating area, take max of all, that will be our ans\\n\\t\\tfor (int i = 0; i < n; i++) {\\n            int length=r[i] - l[i] - 1;\\n            int height=heights[i];\\n            int side=Math.min(length,height);\\n            max = Math.max(max, (side*side));\\n\\t\\t}\\n\\t\\treturn max;\\n\\t}\\n    public int maximalSquare(char[][] matrix) {\\n        int m = matrix.length;\\n        if(m==0){\\n            return 0;\\n        }\\n\\t\\tint n = matrix[0].length;\\n\\t\\tint[] heights = new int[n];\\n\\t\\tint max = Integer.MIN_VALUE;\\n\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tif (i == 0) {\\n\\t\\t\\t\\t\\theights[j] = matrix[i][j] - \\'0\\';\\n\\t\\t\\t\\t} else if (matrix[i][j] - \\'0\\' == 0) {\\n\\t\\t\\t\\t\\theights[j] = 0;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\theights[j] = heights[j] + (matrix[i][j] - \\'0\\');\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tmax = Math.max(max, largestRectangleArea(heights));\\n\\t\\t}\\n\\t\\treturn max;\\n    }\\n}\\n```\n```\\nclass Solution {\\n     public int maximalSquare(char[][] a) {\\n\\t\\tif(a.length == 0) return 0;\\n        int m = a.length, n = a[0].length;\\n        int ans = Integer.MIN_VALUE;\\n        Integer[][] dp = new Integer[m + 1][n + 1];\\n        for(int i = 0; i < m ; i++) {\\n            for(int j = 0; j < n;j++) {\\n                if(a[i][j] == \\'1\\') {\\n                    ans = Math.max(ans, dfs(a, i, j, m, n, dp));\\n                }\\n            }\\n        }\\n        return ans*ans;        \\n    }\\n    private int dfs(char[][] a, int i, int j, int m, int n, Integer[][] dp) {\\n        if( i  < 0 || i >=m || j < 0 || j >=n ||a[i][j] == \\'0\\') return 0;\\n        if(dp[i][j] != null) return dp[i][j];\\n        int down = dfs(a, i + 1, j, m, n, dp);\\n        int right = dfs(a, i, j + 1, m, n, dp);\\n        int diagonal = dfs(a, i + 1, j + 1, m, n, dp);\\n        return dp[i][j] = 1 + Math.min(Math.min(down, right), diagonal);\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\n\\tpublic int maximalSquare(char[][] matrix) {\\n\\t\\tint rows = matrix.length;\\n\\t\\tif (rows == 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tint column = matrix[0].length;\\n\\t\\tint[][] dp = new int[rows + 1][column + 1];\\n\\n\\t\\tint largest = 0;\\n\\t\\tfor (int i = 1; i <= rows; i++) {\\n\\t\\t\\tfor (int j = 1; j <= column; j++) {\\n\\n\\t\\t\\t\\tif (matrix[i - 1][j - 1] == \\'1\\') {\\n\\t\\t\\t\\t\\t// value = current val + left diagonal + left row + upper col\\n\\t\\t\\t\\t\\tdp[i][j] = 1 + Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1]));\\n\\n\\t\\t\\t\\t\\tif (largest < dp[i][j])\\n\\t\\t\\t\\t\\t\\tlargest = dp[i][j];\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn largest * largest;\\n\\t}\\n\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1544693,
                "title": "binary-search-2d-prefix-sum",
                "content": "**Prerequisite** : Binary_search, 2d prefix_array\\n\\nI can\\'t find any post with a binary search solution. So here it is.\\nNot the fastest, but could be solved in this way too.\\n\\nminimum side length = 0...i.e the lower_bound\\nmaximum possible side length = min(rows, cols)..i.e the upper_bound\\n\\nCheck for a square of side x.\\nIf there doesn\\'t exist any such square, we cannot find any square of bigger side length, so upper_bound = x - 1\\nelse, lower_bound = x + 1\\n\\n\\n```\\nbool isSquareWithSide(int side, vector<vector<int>> &pre_matrix) {\\n\\tint rows = pre_matrix.size(), cols = pre_matrix[0].size();\\n        \\n\\tfor(int i = side; i < rows; ++i) {\\n\\t\\tfor(int j = side; j < cols; ++j) {\\n\\t\\t\\tint cur_area = pre_matrix[i][j] - pre_matrix[i - side][j]\\n                            - pre_matrix[i][j - side] + pre_matrix[i - side][j - side];\\n                \\n\\t\\t\\tif(cur_area == side * side)\\n\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn false;\\n }\\n \\nint maximalSquare(vector<vector<char>>& matrix) {\\n\\tint rows = matrix.size();\\n\\tint cols = matrix[0].size();\\n        \\n\\tvector<vector<int>> pref_matrix(rows + 1, vector<int>(cols + 1, 0));\\n        \\n\\tfor(int i = 1; i <= rows; ++i) {\\n\\t\\tfor(int j = 1; j <= cols; ++j) {\\n\\t\\t\\tint tmp = pref_matrix[i][j - 1] + pref_matrix[i - 1][j] - pref_matrix[i - 1][j - 1];\\n\\n\\t\\t\\tpref_matrix[i][j] = tmp + (matrix[i - 1][j - 1] == \\'1\\');\\n\\t\\t}\\n\\t}\\n        \\n\\tint low = 0, high = min(rows, cols);\\n\\tint max_side = 0;\\n\\n\\twhile(low <= high) {\\n\\t\\tint mid = low + (high - low) / 2;\\n\\n\\t\\tif(isSquareWithSide(mid, pref_matrix))\\n\\t\\t\\tlow = mid + 1, max_side = mid;\\n\\t\\telse\\n\\t\\t\\thigh = mid - 1;\\n\\t}\\n        \\n\\treturn max_side * max_side;\\n}\\n```\\n\\n**O(n * m * log(min(n,m)) time**\\n**O(n * m) extra space**\\n\\nAny possible improvement in code is welcome :)\\n \\n",
                "solutionTags": [],
                "code": "```\\nbool isSquareWithSide(int side, vector<vector<int>> &pre_matrix) {\\n\\tint rows = pre_matrix.size(), cols = pre_matrix[0].size();\\n        \\n\\tfor(int i = side; i < rows; ++i) {\\n\\t\\tfor(int j = side; j < cols; ++j) {\\n\\t\\t\\tint cur_area = pre_matrix[i][j] - pre_matrix[i - side][j]\\n                            - pre_matrix[i][j - side] + pre_matrix[i - side][j - side];\\n                \\n\\t\\t\\tif(cur_area == side * side)\\n\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn false;\\n }\\n \\nint maximalSquare(vector<vector<char>>& matrix) {\\n\\tint rows = matrix.size();\\n\\tint cols = matrix[0].size();\\n        \\n\\tvector<vector<int>> pref_matrix(rows + 1, vector<int>(cols + 1, 0));\\n        \\n\\tfor(int i = 1; i <= rows; ++i) {\\n\\t\\tfor(int j = 1; j <= cols; ++j) {\\n\\t\\t\\tint tmp = pref_matrix[i][j - 1] + pref_matrix[i - 1][j] - pref_matrix[i - 1][j - 1];\\n\\n\\t\\t\\tpref_matrix[i][j] = tmp + (matrix[i - 1][j - 1] == \\'1\\');\\n\\t\\t}\\n\\t}\\n        \\n\\tint low = 0, high = min(rows, cols);\\n\\tint max_side = 0;\\n\\n\\twhile(low <= high) {\\n\\t\\tint mid = low + (high - low) / 2;\\n\\n\\t\\tif(isSquareWithSide(mid, pref_matrix))\\n\\t\\t\\tlow = mid + 1, max_side = mid;\\n\\t\\telse\\n\\t\\t\\thigh = mid - 1;\\n\\t}\\n        \\n\\treturn max_side * max_side;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1348633,
                "title": "c-simple-and-easy-dynamic-programming-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int n = matrix.size(), m = matrix[0].size(), res = 0;\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, 0));\\n        \\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                if (matrix[i-1][j-1] == \\'1\\') {\\n                    dp[i][j] = min({dp[i-1][j], dp[i][j-1], dp[i-1][j-1]}) + 1;\\n                    res = max(res, dp[i][j]);\\n                } \\n            }\\n        }\\n        \\n        return res*res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int n = matrix.size(), m = matrix[0].size(), res = 0;\\n        vector<vector<int>> dp(n+1, vector<int>(m+1, 0));\\n        \\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                if (matrix[i-1][j-1] == \\'1\\') {\\n                    dp[i][j] = min({dp[i-1][j], dp[i][j-1], dp[i-1][j-1]}) + 1;\\n                    res = max(res, dp[i][j]);\\n                } \\n            }\\n        }\\n        \\n        return res*res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1192745,
                "title": "java-recursive-memoization",
                "content": "```\\nclass Solution {\\n    Integer [][]dp;\\n    public int maximalSquare(char[][] matrix) {\\n        int res=0;\\n        dp=new Integer[matrix.length][matrix[0].length];\\n        for(int i=0;i<matrix.length;i++)\\n        {\\n            for(int j=0;j<matrix[i].length;j++)\\n            {\\n                if(matrix[i][j]==\\'1\\')\\n                {\\n                    res=Math.max(res,DFS(matrix,i,j));\\n                }\\n            }\\n        }\\n        \\n        \\n        return res*res;\\n    }\\n    public int DFS(char [][]matrix,int i,int j)\\n    {\\n        if(i<0||j<0||i>=matrix.length||j>=matrix[0].length||matrix[i][j]==\\'0\\')\\n        {\\n            return 0;\\n        }\\n        if(dp[i][j]!=null)\\n        {\\n            return dp[i][j];\\n        }\\n        dp[i][j]=1+Math.min(Math.min(DFS(matrix,i+1,j),DFS(matrix,i,j+1)),DFS(matrix,i+1,j+1));\\n        return dp[i][j];\\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    Integer [][]dp;\\n    public int maximalSquare(char[][] matrix) {\\n        int res=0;\\n        dp=new Integer[matrix.length][matrix[0].length];\\n        for(int i=0;i<matrix.length;i++)\\n        {\\n            for(int j=0;j<matrix[i].length;j++)\\n            {\\n                if(matrix[i][j]==\\'1\\')\\n                {\\n                    res=Math.max(res,DFS(matrix,i,j));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 955685,
                "title": "java-recursive-tle-memoization-2d-bottom-up-1d-bottom-up",
                "content": "```\\n- For each of the cell \\'r,c\\' with the value of 1\\n\\t- We can treat this cell as the top left corner of a rectangle\\n\\t- We will first need to recursively check the length of the maximal square located to the \\'right, bottom, bottom right\\'\\n\\t\\t- Then we can generate a new rectangle with length \\'min(right, bottom, bottom right) + 1\\'\\n- We will find the length of the largest square\\n\\t- Then square the length to find the area\\n```\\n```\\npublic class MaximalSquareRecursiveApproach {\\n    public int maximalSquare(char[][] matrix) {\\n        int maxLength = 0;\\n\\n        for (int r = 0; r < matrix.length; r++) {\\n            for (int c = 0; c < matrix[r].length; c++) {\\n                maxLength = Math.max(maxLength, getMaxLength(r, c, matrix));\\n            }\\n        }\\n\\n        return maxLength * maxLength;\\n    }\\n\\n    private int getMaxLength(int r, int c, char[][] matrix) {\\n        if (r < 0 || r >= matrix.length || c < 0 || c >= matrix[r].length || matrix[r][c] == \\'0\\') return 0;\\n\\n        return Math.min(\\n            getMaxLength(r + 1, c + 1, matrix),\\n            Math.min(getMaxLength(r, c + 1, matrix), getMaxLength(r + 1, c, matrix))\\n        ) + 1;\\n    }\\n}\\n```\\n```\\npublic class MaximalSquareMemoizationApproach {\\n    public int maximalSquare(char[][] matrix) {\\n        if (matrix.length == 0) return 0;\\n\\n        int m = matrix.length, n = matrix[0].length, maxLength = 0;\\n        int[][] memo = new int[m][n];\\n\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                maxLength = Math.max(maxLength, getMaxLength(r, c, matrix, memo));\\n            }\\n        }\\n\\n        return maxLength * maxLength;\\n    }\\n\\n    private int getMaxLength(int r, int c, char[][] matrix, int[][] memo) {\\n        if (r < 0 || r >= matrix.length || c < 0 || c >= matrix[r].length || matrix[r][c] == \\'0\\') return 0;\\n        if (memo[r][c] != 0) return memo[r][c];\\n\\n        return memo[r][c] = Math.min(\\n            getMaxLength(r + 1, c + 1, matrix, memo),\\n            Math.min(getMaxLength(r, c + 1, matrix, memo), getMaxLength(r + 1, c, matrix, memo))\\n        ) + 1;\\n    }\\n}\\n```\\n```\\npublic class MaximalSquareBottomUp2DApproach {\\n    public int maximalSquare(char[][] matrix) {\\n        if (matrix.length == 0) return 0;\\n\\n        int m = matrix.length, n = matrix[0].length, maxLength = 0;\\n        int[][] length = new int[m + 1][n + 1];\\n\\n        for (int r = m - 1; r >= 0; r--) {\\n            for (int c = n - 1; c >= 0; c--) {\\n                if (matrix[r][c] == \\'0\\') continue;\\n\\n                length[r][c] = Math.min(\\n                    length[r + 1][c + 1], Math.min(length[r + 1][c], length[r][c + 1])\\n                ) + 1;\\n\\n                maxLength = Math.max(maxLength, length[r][c]);\\n            }\\n        }\\n\\n        return maxLength * maxLength;\\n    }\\n}\\n```\\n```\\npublic class MaximalSquareBottomUp1DApproach {\\n    public int maximalSquare(char[][] matrix) {\\n        if (matrix.length == 0) return 0;\\n\\n        int m = matrix.length, n = matrix[0].length, maxLength = 0;\\n        int[] length = new int[n + 1];\\n\\n        for (int r = m - 1; r >= 0; r--) {\\n            int prev = 0;\\n\\n            for (int c = n - 1; c >= 0; c--) {\\n                if (matrix[r][c] == \\'0\\') {\\n                    prev = length[c];\\n                    length[c] = 0;\\n                    continue;\\n                }\\n\\n                int cur = length[c];\\n                length[c] = Math.min(prev, Math.min(length[c], length[c + 1])) + 1;\\n                prev = cur;\\n                maxLength = Math.max(maxLength, length[c]);\\n            }\\n        }\\n\\n        return maxLength * maxLength;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n- For each of the cell \\'r,c\\' with the value of 1\\n\\t- We can treat this cell as the top left corner of a rectangle\\n\\t- We will first need to recursively check the length of the maximal square located to the \\'right, bottom, bottom right\\'\\n\\t\\t- Then we can generate a new rectangle with length \\'min(right, bottom, bottom right) + 1\\'\\n- We will find the length of the largest square\\n\\t- Then square the length to find the area\\n```\n```\\npublic class MaximalSquareRecursiveApproach {\\n    public int maximalSquare(char[][] matrix) {\\n        int maxLength = 0;\\n\\n        for (int r = 0; r < matrix.length; r++) {\\n            for (int c = 0; c < matrix[r].length; c++) {\\n                maxLength = Math.max(maxLength, getMaxLength(r, c, matrix));\\n            }\\n        }\\n\\n        return maxLength * maxLength;\\n    }\\n\\n    private int getMaxLength(int r, int c, char[][] matrix) {\\n        if (r < 0 || r >= matrix.length || c < 0 || c >= matrix[r].length || matrix[r][c] == \\'0\\') return 0;\\n\\n        return Math.min(\\n            getMaxLength(r + 1, c + 1, matrix),\\n            Math.min(getMaxLength(r, c + 1, matrix), getMaxLength(r + 1, c, matrix))\\n        ) + 1;\\n    }\\n}\\n```\n```\\npublic class MaximalSquareMemoizationApproach {\\n    public int maximalSquare(char[][] matrix) {\\n        if (matrix.length == 0) return 0;\\n\\n        int m = matrix.length, n = matrix[0].length, maxLength = 0;\\n        int[][] memo = new int[m][n];\\n\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                maxLength = Math.max(maxLength, getMaxLength(r, c, matrix, memo));\\n            }\\n        }\\n\\n        return maxLength * maxLength;\\n    }\\n\\n    private int getMaxLength(int r, int c, char[][] matrix, int[][] memo) {\\n        if (r < 0 || r >= matrix.length || c < 0 || c >= matrix[r].length || matrix[r][c] == \\'0\\') return 0;\\n        if (memo[r][c] != 0) return memo[r][c];\\n\\n        return memo[r][c] = Math.min(\\n            getMaxLength(r + 1, c + 1, matrix, memo),\\n            Math.min(getMaxLength(r, c + 1, matrix, memo), getMaxLength(r + 1, c, matrix, memo))\\n        ) + 1;\\n    }\\n}\\n```\n```\\npublic class MaximalSquareBottomUp2DApproach {\\n    public int maximalSquare(char[][] matrix) {\\n        if (matrix.length == 0) return 0;\\n\\n        int m = matrix.length, n = matrix[0].length, maxLength = 0;\\n        int[][] length = new int[m + 1][n + 1];\\n\\n        for (int r = m - 1; r >= 0; r--) {\\n            for (int c = n - 1; c >= 0; c--) {\\n                if (matrix[r][c] == \\'0\\') continue;\\n\\n                length[r][c] = Math.min(\\n                    length[r + 1][c + 1], Math.min(length[r + 1][c], length[r][c + 1])\\n                ) + 1;\\n\\n                maxLength = Math.max(maxLength, length[r][c]);\\n            }\\n        }\\n\\n        return maxLength * maxLength;\\n    }\\n}\\n```\n```\\npublic class MaximalSquareBottomUp1DApproach {\\n    public int maximalSquare(char[][] matrix) {\\n        if (matrix.length == 0) return 0;\\n\\n        int m = matrix.length, n = matrix[0].length, maxLength = 0;\\n        int[] length = new int[n + 1];\\n\\n        for (int r = m - 1; r >= 0; r--) {\\n            int prev = 0;\\n\\n            for (int c = n - 1; c >= 0; c--) {\\n                if (matrix[r][c] == \\'0\\') {\\n                    prev = length[c];\\n                    length[c] = 0;\\n                    continue;\\n                }\\n\\n                int cur = length[c];\\n                length[c] = Math.min(prev, Math.min(length[c], length[c + 1])) + 1;\\n                prev = cur;\\n                maxLength = Math.max(maxLength, length[c]);\\n            }\\n        }\\n\\n        return maxLength * maxLength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 508525,
                "title": "extending-largest-rectangle-in-histogram",
                "content": "We can use one of the approaches used for solving <a href=\"https://leetcode.com/problems/largest-rectangle-in-histogram/\"> Largest Rectangle in Histogram</a>. Instead of finding the area of rectangle, use the min of length and breadth to find the square size. That\\'s all !!\\n\\n    public int maximalSquare(char[][] matrix) {\\n        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) return 0;\\n        int n = matrix.length, m = matrix[0].length, ans = 0;\\n        int[] h = new int[n];\\n        for(int j = 0; j < m; j++) {\\n            for(int i = 0; i < n; i++) {\\n                if(matrix[i][j] == \\'1\\') {\\n                    h[i]++;\\n                } else h[i] = 0;\\n            }\\n            ans = Math.max(ans, largestSquareArea(h));\\n        }\\n        return ans;    \\n    }\\n    \\n    public int largestSquareArea(int[] h) {\\n        if(h == null || h.length == 0) return 0;\\n        int ans = 0;\\n        Deque<Integer> stack = new LinkedList<Integer>();\\n        for(int i = 0; i <= h.length; i++) {\\n            int num = i == h.length ? 0 : h[i];\\n            if(stack.isEmpty() || h[stack.peekLast()] <= num) stack.addLast(i);\\n            else {\\n                int top = stack.pollLast();\\n                int len = h[top];\\n                int breadth = (stack.isEmpty() ? i : i - stack.peekLast() - 1);\\n                int side = Math.min(len, breadth);\\n                ans = Math.max(ans, side * side);\\n                i--;\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "We can use one of the approaches used for solving <a href=\"https://leetcode.com/problems/largest-rectangle-in-histogram/\"> Largest Rectangle in Histogram</a>. Instead of finding the area of rectangle, use the min of length and breadth to find the square size. That\\'s all !!\\n\\n    public int maximalSquare(char[][] matrix) {\\n        if(matrix == null || matrix.length == 0 || matrix[0].length == 0) return 0;\\n        int n = matrix.length, m = matrix[0].length, ans = 0;\\n        int[] h = new int[n];\\n        for(int j = 0; j < m; j++) {\\n            for(int i = 0; i < n; i++) {\\n                if(matrix[i][j] == \\'1\\') {\\n                    h[i]++;\\n                } else h[i] = 0;\\n            }\\n            ans = Math.max(ans, largestSquareArea(h));\\n        }\\n        return ans;    \\n    }\\n    \\n    public int largestSquareArea(int[] h) {\\n        if(h == null || h.length == 0) return 0;\\n        int ans = 0;\\n        Deque<Integer> stack = new LinkedList<Integer>();\\n        for(int i = 0; i <= h.length; i++) {\\n            int num = i == h.length ? 0 : h[i];\\n            if(stack.isEmpty() || h[stack.peekLast()] <= num) stack.addLast(i);\\n            else {\\n                int top = stack.pollLast();\\n                int len = h[top];\\n                int breadth = (stack.isEmpty() ? i : i - stack.peekLast() - 1);\\n                int side = Math.min(len, breadth);\\n                ans = Math.max(ans, side * side);\\n                i--;\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 491616,
                "title": "o-n-m-solution-based-on-the-finding-maximum-rectangle-problem",
                "content": "This solution is based on [Maximal Rectangle](https://leetcode.com/problems/maximal-rectangle/) The solution is not the best for this  problem, though. However, this solution is the proof-of-concept that we can move from the problem \"finding the maximum rectangle\" into the \"finding the maximum square\".\\n\\n**Main idea:** The whole point of finding the maxium rectangle algorithm is: we try to find the pair (W,  H) that can be formed the rectangle that we cannot stretch anymore on either side. Other word, there is no another pair(W1, H) that W1 > W and (W1,H) also a rectangle. Similarity for (W, H1). Because of that, **the maximum square must be inside one of the rectangle we have founed**\\n\\nSo from the formula:\\n```\\n max = Math.max(max, h[top] * (right-left+1));\\n```\\n\\nWe can get the minimum of both sides before calculating the area.\\n```\\n int side = Math.min(h[top], right-left+1);\\n max = Math.max(max, side*side);\\n```\\n\\t\\t\\t\\t\\nTime complexity: O(N*M)\\nSpace complexity: O(M)\\n\\n```\\nclass Solution {\\n    public int maximalSquare(char[][] matrix) {\\n        int n = matrix.length;\\n        if (n == 0) return 0;\\n        int m = matrix[0].length;\\n        \\n        int[] h  =  new int[m];\\n        int max = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int  j = 0; j < m; j++) {\\n                if (matrix[i][j] == \\'0\\') h[j] = 0;\\n                else h[j] = h[j]+1;\\n            }\\n            max = Math.max(max, maxArea(h));\\n        }\\n        return max;\\n    }\\n    \\n    // find the  maximum area of this histogram\\n    private int maxArea(int[] h)  {\\n        Stack<Integer> stack = new Stack<Integer>();\\n        int n = h.length;\\n        int max = 0;\\n        for (int i = 0; i < n; i++) {\\n            while (!stack.isEmpty() && h[stack.peek()] > h[i]) {\\n                int top = stack.pop();\\n                int right = i-1;\\n                int left = stack.isEmpty() ? 0 : stack.peek()+1;\\n                int range = right-left+1;\\n                int side = Math.min(h[top], right-left+1);\\n                max = Math.max(max, side*side);\\n            }\\n            stack.push(i);\\n        }\\n        \\n        if (!stack.isEmpty()) {\\n            int pivot = stack.peek();\\n            while (!stack.isEmpty()) {\\n                int top = stack.pop();\\n                int right = pivot;\\n                int left = stack.isEmpty() ? 0 : stack.peek()+1;\\n                int range = right-left+1;\\n                int side = Math.min(h[top], right-left+1);\\n                max =  Math.max(max, side*side);\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n max = Math.max(max, h[top] * (right-left+1));\\n```\n```\\n int side = Math.min(h[top], right-left+1);\\n max = Math.max(max, side*side);\\n```\n```\\nclass Solution {\\n    public int maximalSquare(char[][] matrix) {\\n        int n = matrix.length;\\n        if (n == 0) return 0;\\n        int m = matrix[0].length;\\n        \\n        int[] h  =  new int[m];\\n        int max = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int  j = 0; j < m; j++) {\\n                if (matrix[i][j] == \\'0\\') h[j] = 0;\\n                else h[j] = h[j]+1;\\n            }\\n            max = Math.max(max, maxArea(h));\\n        }\\n        return max;\\n    }\\n    \\n    // find the  maximum area of this histogram\\n    private int maxArea(int[] h)  {\\n        Stack<Integer> stack = new Stack<Integer>();\\n        int n = h.length;\\n        int max = 0;\\n        for (int i = 0; i < n; i++) {\\n            while (!stack.isEmpty() && h[stack.peek()] > h[i]) {\\n                int top = stack.pop();\\n                int right = i-1;\\n                int left = stack.isEmpty() ? 0 : stack.peek()+1;\\n                int range = right-left+1;\\n                int side = Math.min(h[top], right-left+1);\\n                max = Math.max(max, side*side);\\n            }\\n            stack.push(i);\\n        }\\n        \\n        if (!stack.isEmpty()) {\\n            int pivot = stack.peek();\\n            while (!stack.isEmpty()) {\\n                int top = stack.pop();\\n                int right = pivot;\\n                int left = stack.isEmpty() ? 0 : stack.peek()+1;\\n                int range = right-left+1;\\n                int side = Math.min(h[top], right-left+1);\\n                max =  Math.max(max, side*side);\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61884,
                "title": "python-solution-dp-116-ms",
                "content": "    def maximalSquare(self, matrix):\\n        if not matrix or not matrix[0]: return 0\\n        M, N, sideLen = len(matrix), len(matrix[0]), [[1 if ch == '1' else 0 for ch in row] for row in matrix]\\n        for i in range(1, M):\\n            for j in range(1, N):\\n                if matrix[i][j] == '1':\\n                    sideLen[i][j] = 1 + min(sideLen[i - 1][j], sideLen[i][j - 1], sideLen[i - 1][j - 1])\\n        return max(max(row) for row in sideLen) ** 2",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "    def maximalSquare(self, matrix):\\n        if not matrix or not matrix[0]: return 0\\n        M, N, sideLen = len(matrix), len(matrix[0]), [[1 if ch == '1' else 0 for ch in row] for row in matrix]\\n        for i in range(1, M):\\n            for j in range(1, N):\\n                if matrix[i][j] == '1':\\n                    sideLen[i][j] = 1 + min(sideLen[i - 1][j], sideLen[i][j - 1], sideLen[i - 1][j - 1])\\n        return max(max(row) for row in sideLen) ** 2",
                "codeTag": "Python3"
            },
            {
                "id": 61929,
                "title": "my-accepted-java-solution-time-o-mn-space-o-min-m-n",
                "content": "We assume here that columns are less than rows, otherwise we can put the row loop inside of column loop to archive the O(min(m,n)), tmp is to be used for remember the left-up conner value.\\n\\nNote: we have to set the tmp1 to 0 before inside loop, otherwise the left-up value might not be zero for calculating the first point of each row, because the tmp1 has the carry-over value from previous row.\\n \\n       public int maximalSquare(char[][] matrix) {\\n        if(matrix == null || matrix.length ==0|| matrix[0].length == 0) return  0;\\n        \\n        int[] dp = new int[matrix[0].length +1];\\n        int max = 0;\\n        int tmp1 = 0;\\n        int tmp2 = 0;\\n        \\n        for(int i=0; i< matrix.length; i++)\\n        {\\n            tmp1 = 0;\\n            for(int j=0; j< matrix[0].length; j++)\\n            {\\n                tmp2 = dp[j+1];\\n                                    \\n                if(matrix[i][j] == '1')\\n                {\\n                    dp[j+1] = Math.min(tmp1, Math.min(dp[j], dp[j+1])) + 1;\\n                    max = Math.max(max, dp[j+1]);\\n                }\\n                else\\n                {\\n                    dp[j+1] = 0;\\n                }\\n                \\n                tmp1 = tmp2;\\n            }\\n        }\\n        \\n        return max*max;\\n    }",
                "solutionTags": [],
                "code": "We assume here that columns are less than rows, otherwise we can put the row loop inside of column loop to archive the O(min(m,n)), tmp is to be used for remember the left-up conner value.\\n\\nNote: we have to set the tmp1 to 0 before inside loop, otherwise the left-up value might not be zero for calculating the first point of each row, because the tmp1 has the carry-over value from previous row.\\n \\n       public int maximalSquare(char[][] matrix) {\\n        if(matrix == null || matrix.length ==0|| matrix[0].length == 0) return  0;\\n        \\n        int[] dp = new int[matrix[0].length +1];\\n        int max = 0;\\n        int tmp1 = 0;\\n        int tmp2 = 0;\\n        \\n        for(int i=0; i< matrix.length; i++)\\n        {\\n            tmp1 = 0;\\n            for(int j=0; j< matrix[0].length; j++)\\n            {\\n                tmp2 = dp[j+1];\\n                                    \\n                if(matrix[i][j] == '1')\\n                {\\n                    dp[j+1] = Math.min(tmp1, Math.min(dp[j], dp[j+1])) + 1;\\n                    max = Math.max(max, dp[j+1]);\\n                }\\n                else\\n                {\\n                    dp[j+1] = 0;\\n                }\\n                \\n                tmp1 = tmp2;\\n            }\\n        }\\n        \\n        return max*max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 61920,
                "title": "my-java-solution-o-mn",
                "content": "Basic idea is to iterate over all columns and rows of a matrix (starting with i=j=1).  If value in a cell>0 and cells to the north, west, and north-west are >0, pick smallest value of those 3 cells, take it's square root, add 1, and assign square of new value to current cell. For example given matrix\\n\\n    1   1   1   1   1   1\\n    1   1   1   0   1   1\\n    1   1   1   1   1   1\\n    1   1   1   1   1   1\\n    1   1   1   1   1   1\\n    1   1   1   1   0   1\\n    \\n    We get:\\n    \\n    1   1   1   1   1   1\\n    1   4   4   0   1   4\\n    1   4   9   1   1   4\\n    1   4   9   4   4   4\\n    1   4   9   9   9   9\\n    1   4   9  16   0   1\\n\\nOur answer is the largest value in new matrix: 16\\n\\n    public class Solution {\\n        static int[] squares = new int[1001];\\n        static{\\n            for (int i=0;i<=1000;i++){\\n                squares[i] = i*i;\\n            }\\n        } \\n            \\n        public int maximalSquare(char[][] matrix) {\\n            if (matrix == null || matrix.length == 0){\\n                return 0;\\n            }\\n            int result = 0;\\n            \\n            int[][] intMatrix = new int[matrix.length][matrix[0].length];\\n        \\tfor (int i=0;i<matrix.length;i++){\\n        \\t\\tfor (int j=0;j<matrix[0].length;j++){\\n        \\t\\t    int val = matrix[i][j]-'0';\\n        \\t\\t    if (val == 1){\\n        \\t\\t        result = 1;\\n        \\t\\t    }\\n        \\t\\t\\tintMatrix[i][j] = val;\\n        \\t\\t}\\n        \\t}\\n            \\n            for (int i = 1; i<intMatrix.length;i++){\\n                for (int j=1; j<intMatrix[0].length;j++){\\n                    if (intMatrix[i][j]!=0){\\n                        int val1 = intMatrix[i][j-1];\\n                        int val2 = intMatrix[i-1][j];\\n                        int val3 = intMatrix[i-1][j-1];\\n                        int min1 = Math.min(val1, val2);\\n                        int min = Math.min(min1, val3);\\n                        if (min!=0){\\n                            int index = (int)Math.sqrt(min);\\n                            intMatrix[i][j] = (int)squares[index+1];\\n                            if (intMatrix[i][j]>result){\\n                                result = intMatrix[i][j];\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            return result;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        static int[] squares = new int[1001];\\n        static{\\n            for (int i=0;i<=1000;i++){\\n                squares[i] = i*i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 61893,
                "title": "integral-image-solution-156ms-i-know-i-know-it-s-slow-just-want-to-throw-it-out-here",
                "content": "Just want to throw a solution using integral image. Clearly it's not as fast as DP solution, but it's fun\\n\\n    class Solution {\\n    public:\\n        int maximalSquare(vector<vector<char>>& matrix) {\\n            int rows = matrix.size();\\n            if (rows == 0) return 0;\\n            int cols = matrix[0].size();\\n            if (cols == 0) return 0;\\n            int val;\\n            vector<vector<int> > image(rows+1, vector<int>(cols+1, 0)); // Integral image\\n            for (int r = 1; r <= rows; r++){\\n                for (int c = 1; c <= cols; c++){\\n                    val = (matrix[r-1][c-1] == '0' ? 0 : 1);\\n                    image[r][c] = val + image[r][c-1] + image[r-1][c] - image[r-1][c-1];\\n                }\\n            }\\n            if (image[rows][cols] == 0) return 0;\\n            int maxSize = 1;\\n            for (int r = 0; r <= rows; r++){\\n                for (int c = 0; c <= cols; c++){\\n                    for (int s = min(rows-r, cols-c); s >= maxSize; s--){\\n                        if (image[r+s][c+s] + image[r][c] - image[r][c+s] - image[r+s][c] == s * s) {\\n                            maxSize = s;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n            return maxSize * maxSize;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maximalSquare(vector<vector<char>>& matrix) {\\n            int rows = matrix.size();\\n            if (rows == 0) return 0;\\n            int cols = matrix[0].size();\\n            if (cols == 0) return 0;\\n            int val;\\n            vector<vector<int> > image(rows+1, vector<int>(cols+1, 0)); // Integral image\\n            for (int r = 1; r <= rows; r++){\\n                for (int c = 1; c <= cols; c++){\\n                    val = (matrix[r-1][c-1] == '0' ? 0 : 1);\\n                    image[r][c] = val + image[r][c-1] + image[r-1][c] - image[r-1][c-1];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3927708,
                "title": "easy-to-understand-c-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo have square of n as max, we should have n-1 forming squares, and to have square of n-1, we should have n-2 forming squares ... similarly to have 2 forming square we should have 1 as the forming suare first.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf the matrix[i][j]==1 then, we can check the min of the neighbour forming squares i.e\\ndp[i][j]=min(dp[i][j-1],min(dp[i-1][j-1],dp[i-1][j]))+1;\\n//the +1 id for considering the square itself.\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,0));\\n        int ans=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(i==0 or j==0)\\n                {\\n                    if(matrix[i][j]==\\'1\\')dp[i][j]=1;\\n                }\\n                else \\n                {\\n                    if(matrix[i][j]==\\'1\\')\\n                    {\\n                        dp[i][j]=min(dp[i-1][j],min(dp[i][j-1],dp[i-1][j-1]))+1;\\n                        \\n                    }\\n                }\\n                ans=max(ans,dp[i][j]);\\n            }\\n        }\\n        return ans*ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,0));\\n        int ans=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(i==0 or j==0)\\n                {\\n                    if(matrix[i][j]==\\'1\\')dp[i][j]=1;\\n                }\\n                else \\n                {\\n                    if(matrix[i][j]==\\'1\\')\\n                    {\\n                        dp[i][j]=min(dp[i-1][j],min(dp[i][j-1],dp[i-1][j-1]))+1;\\n                        \\n                    }\\n                }\\n                ans=max(ans,dp[i][j]);\\n            }\\n        }\\n        return ans*ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3292795,
                "title": "c-solution-easy-tabulation-beats-100-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<char>>& matrix,int ind,int col,int &ans,vector<vector<int>>&dp)\\n    {\\n        if(ind >= matrix.size() || col >= matrix[0].size())\\n        {\\n            return 0;\\n        }\\n\\n         if(dp[ind][col] != -1)\\n            return dp[ind][col];\\n\\n        int right = solve(matrix,ind,col+1,ans,dp);\\n        int down = solve(matrix,ind+1,col,ans,dp);\\n        int diagonal = solve(matrix,ind+1,col+1,ans,dp);\\n\\n\\n       \\n\\n        if(matrix[ind][col] == \\'1\\')\\n        {\\n            dp[ind][col] =  1 + min(right,min(down,diagonal));\\n            \\n            ans = max(dp[ind][col],ans);\\n            return dp[ind][col];\\n        }\\n        else\\n            return  dp[ind][col] = 0;\\n    }\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int ans = 0;\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,0));\\n        \\n        for(int i = n-1;i>=0;i--)\\n        {\\n            for(int j = m-1;j>=0;j--)\\n            {\\n                int right = dp[i][j+1];\\n                int down = dp[i+1][j];\\n                int diagonal = dp[i+1][j+1];\\n                    \\n\\n                if(matrix[i][j] == \\'1\\')\\n                {\\n                    dp[i][j] =  1 + min(right,min(down,diagonal));\\n\\n                    ans = max(dp[i][j],ans);\\n                }\\n                else\\n                    dp[i][j] = 0;\\n            }\\n        }\\n        return ans*ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<char>>& matrix,int ind,int col,int &ans,vector<vector<int>>&dp)\\n    {\\n        if(ind >= matrix.size() || col >= matrix[0].size())\\n        {\\n            return 0;\\n        }\\n\\n         if(dp[ind][col] != -1)\\n            return dp[ind][col];\\n\\n        int right = solve(matrix,ind,col+1,ans,dp);\\n        int down = solve(matrix,ind+1,col,ans,dp);\\n        int diagonal = solve(matrix,ind+1,col+1,ans,dp);\\n\\n\\n       \\n\\n        if(matrix[ind][col] == \\'1\\')\\n        {\\n            dp[ind][col] =  1 + min(right,min(down,diagonal));\\n            \\n            ans = max(dp[ind][col],ans);\\n            return dp[ind][col];\\n        }\\n        else\\n            return  dp[ind][col] = 0;\\n    }\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int ans = 0;\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,0));\\n        \\n        for(int i = n-1;i>=0;i--)\\n        {\\n            for(int j = m-1;j>=0;j--)\\n            {\\n                int right = dp[i][j+1];\\n                int down = dp[i+1][j];\\n                int diagonal = dp[i+1][j+1];\\n                    \\n\\n                if(matrix[i][j] == \\'1\\')\\n                {\\n                    dp[i][j] =  1 + min(right,min(down,diagonal));\\n\\n                    ans = max(dp[i][j],ans);\\n                }\\n                else\\n                    dp[i][j] = 0;\\n            }\\n        }\\n        return ans*ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225158,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,0));\\n        int maxi=0;\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                if (matrix[i-1][j-1] == \\'1\\'){\\n                    dp[i][j] = min(min(dp[i][j - 1], dp[i - 1][j]), dp[i - 1][j - 1]) + 1;\\n                    maxi = max(maxi, dp[i][j]);\\n                }\\n            }\\n        }\\n        return maxi*maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,0));\\n        int maxi=0;\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                if (matrix[i-1][j-1] == \\'1\\'){\\n                    dp[i][j] = min(min(dp[i][j - 1], dp[i - 1][j]), dp[i - 1][j - 1]) + 1;\\n                    maxi = max(maxi, dp[i][j]);\\n                }\\n            }\\n        }\\n        return maxi*maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962648,
                "title": "related-to-count-square-submatrices-with-all-ones-tabulation-2d-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis question can be solved by dp table of Count Square Submatrices with All Ones\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nin the dp table of Count Square Submatrices with All Ones at every index it represents the square possible at it thus we can again call a for loop and caluclate max area throughout as square area=size*size\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n3*O(mn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n2*O(mn)\\n# Code\\n```\\nclass Solution {\\n    public int maximalSquare(char[][] matrix) {\\n        int[][] arr=new int[matrix.length][matrix[0].length];\\nfor(int i=0;i<matrix.length;i++){\\n    for(int j=0;j<matrix[0].length;j++){\\n        if(matrix[i][j]==\\'1\\'){\\n            arr[i][j]=1;\\n        }\\n        else{\\n            arr[i][j]=0;\\n        }\\n    }\\n}\\n         int n=arr.length;\\n        int m=arr[0].length;\\n        int[][] dp=new int[n][m];\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            dp[i][0]=arr[i][0];\\n           \\n        }\\n        for(int j=0;j<m;j++){\\n            dp[0][j]=arr[0][j];\\n            \\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                if(arr[i][j]==0) dp[i][j]=0;\\n                else{\\n                    dp[i][j]=1+Math.min(Math.min(dp[i][j-1],dp[i-1][j-1]),dp[i-1][j]);\\n                }\\n              \\n            }\\n        }\\n        int area=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\narea=Math.max(dp[i][j]*dp[i][j],area);\\n            }\\n        }\\n        return area;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maximalSquare(char[][] matrix) {\\n        int[][] arr=new int[matrix.length][matrix[0].length];\\nfor(int i=0;i<matrix.length;i++){\\n    for(int j=0;j<matrix[0].length;j++){\\n        if(matrix[i][j]==\\'1\\'){\\n            arr[i][j]=1;\\n        }\\n        else{\\n            arr[i][j]=0;\\n        }\\n    }\\n}\\n         int n=arr.length;\\n        int m=arr[0].length;\\n        int[][] dp=new int[n][m];\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            dp[i][0]=arr[i][0];\\n           \\n        }\\n        for(int j=0;j<m;j++){\\n            dp[0][j]=arr[0][j];\\n            \\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                if(arr[i][j]==0) dp[i][j]=0;\\n                else{\\n                    dp[i][j]=1+Math.min(Math.min(dp[i][j-1],dp[i-1][j-1]),dp[i-1][j]);\\n                }\\n              \\n            }\\n        }\\n        int area=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\narea=Math.max(dp[i][j]*dp[i][j],area);\\n            }\\n        }\\n        return area;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885074,
                "title": "inplace-dp-must-check",
                "content": "# Complexity\\n- Time complexity: O(mn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) - No extra space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        \\n        m = len(matrix)\\n        n = len(matrix[0])        \\n        mx = 0\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j] == \\'1\\' : \\n                    if i != 0 and j != 0:\\n                        matrix[i][j] = min(int(matrix[i-1][j-1]), int(matrix[i][j-1]), int(matrix[i-1][j])) + 1\\n                    mx = max(mx, int(matrix[i][j]))\\n        \\n        return int(mx)**2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        \\n        m = len(matrix)\\n        n = len(matrix[0])        \\n        mx = 0\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j] == \\'1\\' : \\n                    if i != 0 and j != 0:\\n                        matrix[i][j] = min(int(matrix[i-1][j-1]), int(matrix[i][j-1]), int(matrix[i-1][j])) + 1\\n                    mx = max(mx, int(matrix[i][j]))\\n        \\n        return int(mx)**2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2802277,
                "title": "c-easy-fast-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int area = INT_MIN;\\n    pair<int,int> setval(vector<vector<pair<int,int>>>& dp, int i, int j, int v)\\n    {\\n        if (i==0 or j==0 or v==0)\\n        {\\n            area = max(area, v);\\n            return {v,v};\\n        }\\n        int x = min(dp[i-1][j].second, dp[i][j-1].second);\\n        int k = sqrt(dp[i-1][j-1].first);\\n        if(k<=x)\\n        {\\n            x++;\\n            k++;\\n            area = max(k*k, area);\\n            return {k*k, x};\\n        }\\n        x++;\\n        area = max(x*x, area);\\n        return {x*x, x};\\n    }\\n\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int n = matrix.size(), m = matrix[0].size();\\n        vector<vector<pair<int,int>>> dp(n,vector<pair<int,int>>(m, {0,0}));\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                dp[i][j] = setval(dp, i, j, matrix[i][j]-\\'0\\');\\n            }\\n        }\\n        return area;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int area = INT_MIN;\\n    pair<int,int> setval(vector<vector<pair<int,int>>>& dp, int i, int j, int v)\\n    {\\n        if (i==0 or j==0 or v==0)\\n        {\\n            area = max(area, v);\\n            return {v,v};\\n        }\\n        int x = min(dp[i-1][j].second, dp[i][j-1].second);\\n        int k = sqrt(dp[i-1][j-1].first);\\n        if(k<=x)\\n        {\\n            x++;\\n            k++;\\n            area = max(k*k, area);\\n            return {k*k, x};\\n        }\\n        x++;\\n        area = max(x*x, area);\\n        return {x*x, x};\\n    }\\n\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int n = matrix.size(), m = matrix[0].size();\\n        vector<vector<pair<int,int>>> dp(n,vector<pair<int,int>>(m, {0,0}));\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                dp[i][j] = setval(dp, i, j, matrix[i][j]-\\'0\\');\\n            }\\n        }\\n        return area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2636984,
                "title": "recursion-memoization-tabulation-c-easy-solution",
                "content": "```\\n//method 1 Recursion\\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int recursive(int i,int j, vector<vector<char>> &matrix){\\n        if(i>=matrix.size() || j>=matrix[0].size()) return 0;\\n        int right = recursive(i,j+1,matrix);\\n        int diagonal = recursive(i+1,j+1,matrix);\\n        int down = recursive(i+1,j,matrix);\\n        if(matrix[i][j]==\\'1\\'){\\n            int x = 1+min(right,min(diagonal,down));\\n            maxi = max(maxi,x);\\n            return x;\\n        } \\n        return 0;\\n    }\\n    \\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        recursive(0,0,matrix);\\n        return maxi*maxi;\\n    }\\n};\\n\\n//method 2 Memoization\\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int recursive(int i,int j, vector<vector<char>> &matrix, vector<vector<int>> &dp){\\n        if(i>=matrix.size() || j>=matrix[0].size()) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int right = recursive(i,j+1,matrix,dp);\\n        int diagonal = recursive(i+1,j+1,matrix,dp);\\n        int down = recursive(i+1,j,matrix,dp);\\n        if(matrix[i][j]==\\'1\\'){\\n            int x = 1+min(right,min(diagonal,down));\\n            maxi = max(maxi,x);\\n            return dp[i][j]=x;\\n        } \\n        return dp[i][j]=0;\\n    }\\n    \\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int n = matrix.size(), m = matrix[0].size();\\n        vector<vector<int>> dp(n,vector<int>(m,-1));\\n        recursive(0,0,matrix,dp);\\n        return maxi*maxi;\\n    }\\n};\\n\\n//method 3 Tabulation\\nclass Solution {\\npublic: \\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int n = matrix.size(), m = matrix[0].size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,0));\\n        int maxi = 0;\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=0;j--){\\n                if(matrix[i][j]==\\'1\\'){\\n                    dp[i][j] = 1 + min(dp[i][j+1],min(dp[i+1][j+1],dp[i+1][j]));\\n                    maxi = max(maxi,dp[i][j]);\\n                } else {\\n                    dp[i][j] = 0;\\n                }\\n            }\\n        }\\n        return maxi*maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n//method 1 Recursion\\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int recursive(int i,int j, vector<vector<char>> &matrix){\\n        if(i>=matrix.size() || j>=matrix[0].size()) return 0;\\n        int right = recursive(i,j+1,matrix);\\n        int diagonal = recursive(i+1,j+1,matrix);\\n        int down = recursive(i+1,j,matrix);\\n        if(matrix[i][j]==\\'1\\'){\\n            int x = 1+min(right,min(diagonal,down));\\n            maxi = max(maxi,x);\\n            return x;\\n        } \\n        return 0;\\n    }\\n    \\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        recursive(0,0,matrix);\\n        return maxi*maxi;\\n    }\\n};\\n\\n//method 2 Memoization\\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int recursive(int i,int j, vector<vector<char>> &matrix, vector<vector<int>> &dp){\\n        if(i>=matrix.size() || j>=matrix[0].size()) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int right = recursive(i,j+1,matrix,dp);\\n        int diagonal = recursive(i+1,j+1,matrix,dp);\\n        int down = recursive(i+1,j,matrix,dp);\\n        if(matrix[i][j]==\\'1\\'){\\n            int x = 1+min(right,min(diagonal,down));\\n            maxi = max(maxi,x);\\n            return dp[i][j]=x;\\n        } \\n        return dp[i][j]=0;\\n    }\\n    \\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int n = matrix.size(), m = matrix[0].size();\\n        vector<vector<int>> dp(n,vector<int>(m,-1));\\n        recursive(0,0,matrix,dp);\\n        return maxi*maxi;\\n    }\\n};\\n\\n//method 3 Tabulation\\nclass Solution {\\npublic: \\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int n = matrix.size(), m = matrix[0].size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,0));\\n        int maxi = 0;\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=0;j--){\\n                if(matrix[i][j]==\\'1\\'){\\n                    dp[i][j] = 1 + min(dp[i][j+1],min(dp[i+1][j+1],dp[i+1][j]));\\n                    maxi = max(maxi,dp[i][j]);\\n                } else {\\n                    dp[i][j] = 0;\\n                }\\n            }\\n        }\\n        return maxi*maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2328061,
                "title": "dp-explained-figure",
                "content": "```\\n// For having size 3 square at a pt, the above point, point to the diagonal left,point to the right should be the bottom right point of a square of size 2\\n/*\\n1 1 1   is only possible when  0 0  0       (1 1) 1         0 (1 1) \\n1 1 1                         (1 1) 1 and   (1 1) 1   and   0 (1 1)\\n1 1 1                         (1 1) 1        0 0  1         0  0 1  simuntaneously\\n*/\\n\\n\\n\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        if (matrix.empty()) {\\n            return 0;\\n        }\\n        int m = matrix.size(), n = matrix[0].size(), sz = 0;\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (!i || !j || matrix[i][j] == \\'0\\') {\\n                    dp[i][j] = matrix[i][j] - \\'0\\';\\n                } else {\\n                    dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1;\\n                }\\n                sz = max(dp[i][j], sz);\\n            }\\n        }\\n        return sz * sz;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// For having size 3 square at a pt, the above point, point to the diagonal left,point to the right should be the bottom right point of a square of size 2\\n/*\\n1 1 1   is only possible when  0 0  0       (1 1) 1         0 (1 1) \\n1 1 1                         (1 1) 1 and   (1 1) 1   and   0 (1 1)\\n1 1 1                         (1 1) 1        0 0  1         0  0 1  simuntaneously\\n*/\\n\\n\\n\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        if (matrix.empty()) {\\n            return 0;\\n        }\\n        int m = matrix.size(), n = matrix[0].size(), sz = 0;\\n        vector<vector<int>> dp(m, vector<int>(n, 0));\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (!i || !j || matrix[i][j] == \\'0\\') {\\n                    dp[i][j] = matrix[i][j] - \\'0\\';\\n                } else {\\n                    dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1;\\n                }\\n                sz = max(dp[i][j], sz);\\n            }\\n        }\\n        return sz * sz;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994329,
                "title": "easy-java-dp-solution",
                "content": "```\\nclass Solution {\\n    public int maximalSquare(char[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int dp[][] = new int[m][n];\\n        \\n        int maxlen = 0;\\n        \\n        for(int i = m-1 ; i>=0 ; i--){\\n            for(int j = n-1 ; j>=0 ; j--){\\n                \\n                if(i == m-1 || j == n-1){\\n                    dp[i][j] = matrix[i][j] - \\'0\\';\\n                }else{\\n                    if(matrix[i][j] == \\'1\\'){\\n                        dp[i][j] = Math.min(dp[i][j+1], Math.min(dp[i+1][j], dp[i+1][j+1])) + 1;\\n                    }\\n                }\\n                \\n                maxlen = Math.max(maxlen, dp[i][j]);\\n            }\\n        }\\n        \\n        int area = maxlen*maxlen;\\n        \\n        return area;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maximalSquare(char[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int dp[][] = new int[m][n];\\n        \\n        int maxlen = 0;\\n        \\n        for(int i = m-1 ; i>=0 ; i--){\\n            for(int j = n-1 ; j>=0 ; j--){\\n                \\n                if(i == m-1 || j == n-1){\\n                    dp[i][j] = matrix[i][j] - \\'0\\';\\n                }else{\\n                    if(matrix[i][j] == \\'1\\'){\\n                        dp[i][j] = Math.min(dp[i][j+1], Math.min(dp[i+1][j], dp[i+1][j+1])) + 1;\\n                    }\\n                }\\n                \\n                maxlen = Math.max(maxlen, dp[i][j]);\\n            }\\n        }\\n        \\n        int area = maxlen*maxlen;\\n        \\n        return area;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1988171,
                "title": "c-dp-easy-code",
                "content": "\\tpublic:\\n\\t\\tint maximalSquare(vector<vector<char>>& matrix) {\\n        \\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        int maxLen = 0;\\n        vector<vector<int>>dp(n, vector<int>(m, 0));\\n        \\n        for(int i=0;i<m;i++)\\n            if(matrix[n-1][i]==\\'1\\'){\\n                dp[n-1][i] = 1;\\n                maxLen = 1;\\n            }\\n        \\n        for(int i=0;i<n;i++)\\n            if(matrix[i][m-1]==\\'1\\'){\\n                maxLen = 1;\\n                dp[i][m-1] = 1;\\n            }\\n        \\n        for(int i=n-2;i>=0;i--)\\n            for(int j=m-2;j>=0;j--)\\n                if(matrix[i][j] == \\'1\\'){\\n                    dp[i][j] = 1 + min({dp[i+1][j], dp[i+1][j+1], dp[i][j+1]});\\n                    maxLen = max(maxLen, dp[i][j]);\\n                }\\n                        \\n        return (maxLen*maxLen);\\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "\\tpublic:\\n\\t\\tint maximalSquare(vector<vector<char>>& matrix) {\\n        \\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        int maxLen = 0;\\n        vector<vector<int>>dp(n, vector<int>(m, 0));\\n        \\n        for(int i=0;i<m;i++)\\n            if(matrix[n-1][i]==\\'1\\'){\\n                dp[n-1][i] = 1;\\n                maxLen = 1;\\n            }\\n        \\n        for(int i=0;i<n;i++)\\n            if(matrix[i][m-1]==\\'1\\'){\\n                maxLen = 1;\\n                dp[i][m-1] = 1;\\n            }\\n        \\n        for(int i=n-2;i>=0;i--)\\n            for(int j=m-2;j>=0;j--)\\n                if(matrix[i][j] == \\'1\\'){\\n                    dp[i][j] = 1 + min({dp[i+1][j], dp[i+1][j+1], dp[i][j+1]});\\n                    maxLen = max(maxLen, dp[i][j]);\\n                }\\n                        \\n        return (maxLen*maxLen);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1926775,
                "title": "python-dp-solution-with-o-1-space",
                "content": "```\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        currMax = 0\\n        \\n        for i in range(m-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                matrix[i][j] = int(matrix[i][j])\\n                right = matrix[i][j+1] if j < n-1 else 0\\n                bottom = matrix[i+1][j] if i < m-1 else 0\\n                bottomRight = matrix[i+1][j+1] if j < n-1 and i < m-1 else 0\\n                \\n                if matrix[i][j] != 0:\\n                    matrix[i][j] = min(right, bottom, bottomRight) + 1\\n                \\n                currMax = max(currMax, matrix[i][j])\\n\\n        return currMax**2\\n```\\n\\n**Idea**: scan from bottom right to upper left, updating the matrix entries to the size of area with current element being the top-left one in the square. Also, keep track of the maximum area along the way. \\n1. if the current element in the matrix is 0, then it stays 0\\n2. else: take the minimum of the right, bottom, and bottom-right area sizes and plus one, update this value to the current place in the matrix.\\n\\n**Examples**:\\n*input*:\\n| 1 | 1 | 1 |\\n| 1 | 1 | 1 |  \\n| 1 | 1 | 1 |\\n--> (matrix[2][2] stays 1, meaning 1^2=1 is the area of the bottom-right little square)\\n| 1 | 1 | 1 |\\n| 1 | 1 | 1 |  \\n| 1 | 1 | 1 |\\n--> (matrix[2][1] stays 1)\\n| 1 | 1 | 1 |\\n| 1 | 1 | 1 |  \\n| 1 | 1 | 1 |\\n--> (matrix[2][0] stays 1)\\n| 1 | 1 | 1 |\\n| 1 | 1 | 1 | \\n| 1 | 1 | 1 |\\n --> (matrix[1][2] stays 1)\\n| 1 | 1 | 1 |\\n| 1 | 1 | 1 |  \\n| 1 | 1 | 1 |\\n --> (matrix[1][1] updates to min(1,1,1)+1=2, meaning 2^2=4 is the area of the bottom-right 4-blocks square)\\n| 1 | 1 | 1 |\\n| 1 | 2 | 1 | \\n| 1 | 1 | 1 |\\n--> (matrix[1][0] updates to min(1,1,1)+1=2, meaning 2^2=4 is the area of the bottom-left 4-blocks square) \\n| 1 | 1 | 1 |\\n| 2 | 2 | 1 |  \\n| 1 | 1 | 1 |\\n--> (matrix[0][2] stays 1) \\n| 1 | 1 | 1 |\\n| 2 | 2 | 1 |  \\n| 1 | 1 | 1 |\\n--> (matrix[0][1] updates to min(2,1,1)+1=2, meaning 2^2=4 is the area of the upper-right 4-blocks square) \\n| 1 | 2 | 1 |\\n| 2 | 2 | 1 |  \\n| 1 | 1 | 1 |\\n--> (matrix[0][0] updates to min(2,2,2)+1=3, meaning 3^2=9 is the area of the entire 9-blocks square) \\n| 3 | 2 | 1 |\\n| 2 | 2 | 1 |  \\n| 1 | 1 | 1 |\\n**return 3^2 = 9**\\n\\n**Another Example**:\\n*input*:\\n| 1 | 1 | 0 |\\n| 1 | 1 | 1 |  \\n| 1 | 1 | 1 |\\n--> (matrix[2][2] stays 1, meaning 1^2=1 is the area of the bottom-right little square)\\n| 1 | 1 | 0 |\\n| 1 | 1 | 1 |  \\n| 1 | 1 | 1 |\\n--> (matrix[2][1] stays 1)\\n| 1 | 1 | 0 |\\n| 1 | 1 | 1 |  \\n| 1 | 1 | 1 |\\n--> (matrix[2][0] stays 1)\\n| 1 | 1 | 0 |\\n| 1 | 1 | 1 | \\n| 1 | 1 | 1 |\\n --> (matrix[1][2] stays 1)\\n| 1 | 1 | 0 |\\n| 1 | 1 | 1 |  \\n| 1 | 1 | 1 |\\n --> (matrix[1][1] updates to min(1,1,1)+1=2, meaning 2^2=4 is the area of the bottom-right 4-blocks square)\\n| 1 | 1 | 0 |\\n| 1 | 2 | 1 | \\n| 1 | 1 | 1 |\\n--> (matrix[1][0] updates to min(1,1,1)+1=2, meaning 2^2=4 is the area of the bottom-left 4-blocks square) \\n| 1 | 1 | 0 |\\n| 2 | 2 | 1 |  \\n| 1 | 1 | 1 |\\n--> (matrix[0][2] stays 0) \\n| 1 | 1 | 0 |\\n| 2 | 2 | 1 |  \\n| 1 | 1 | 1 |\\n--> (matrix[0][1] updates to min(2,0,1)+1=1, meaning 1^2=1 is the area of the upper-right 4-blocks square) \\n| 1 | 1 | 0 |\\n| 2 | 2 | 1 |  \\n| 1 | 1 | 1 |\\n--> (matrix[0][0] updates to min(2,1,2)+1=2, meaning 2^2=4 is the area of the entire 9-blocks square) \\n| 2 | 1 | 1 |\\n| 2 | 2 | 1 |  \\n| 1 | 1 | 1 |\\n**return 2^2 = 4**",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        currMax = 0\\n        \\n        for i in range(m-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                matrix[i][j] = int(matrix[i][j])\\n                right = matrix[i][j+1] if j < n-1 else 0\\n                bottom = matrix[i+1][j] if i < m-1 else 0\\n                bottomRight = matrix[i+1][j+1] if j < n-1 and i < m-1 else 0\\n                \\n                if matrix[i][j] != 0:\\n                    matrix[i][j] = min(right, bottom, bottomRight) + 1\\n                \\n                currMax = max(currMax, matrix[i][j])\\n\\n        return currMax**2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1805533,
                "title": "java-dp-solution",
                "content": "```\\nclass Solution {\\n    public int maximalSquare(char[][] matrix) {\\n        if(matrix.length == 0) return 0;\\n        int max = 0;\\n        int rows = matrix.length;\\n        int col = matrix[0].length;\\n        int [][]dp = new int[rows][col];\\n        \\n        for(int i = 0; i < rows; i ++) {\\n            dp[i][0] = matrix[i][0] == \\'0\\' ? 0 : 1;\\n            max = Math.max(max, dp[i][0]);\\n        }\\n        for(int i = 0; i < col; i++) {\\n            dp[0][i] = matrix[0][i] == \\'0\\' ? 0 : 1;\\n            max= Math.max(max, dp[0][i]);\\n        }\\n        for(int i = 1; i < rows; i++){\\n            for(int j = 1; j< col; j++) {\\n                if(matrix[i][j] == \\'1\\') {\\n                    dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i - 1][j - 1]), dp[i][j - 1]) + 1;\\n                    max = Math.max(max, dp[i][j]);\\n                }\\n            }\\n        }\\n        return max*max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maximalSquare(char[][] matrix) {\\n        if(matrix.length == 0) return 0;\\n        int max = 0;\\n        int rows = matrix.length;\\n        int col = matrix[0].length;\\n        int [][]dp = new int[rows][col];\\n        \\n        for(int i = 0; i < rows; i ++) {\\n            dp[i][0] = matrix[i][0] == \\'0\\' ? 0 : 1;\\n            max = Math.max(max, dp[i][0]);\\n        }\\n        for(int i = 0; i < col; i++) {\\n            dp[0][i] = matrix[0][i] == \\'0\\' ? 0 : 1;\\n            max= Math.max(max, dp[0][i]);\\n        }\\n        for(int i = 1; i < rows; i++){\\n            for(int j = 1; j< col; j++) {\\n                if(matrix[i][j] == \\'1\\') {\\n                    dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i - 1][j - 1]), dp[i][j - 1]) + 1;\\n                    max = Math.max(max, dp[i][j]);\\n                }\\n            }\\n        }\\n        return max*max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672563,
                "title": "top-down-bottom-up-approaches-java",
                "content": "Top-down (recursive) approach with memoization:\\n\\n```\\nclass Solution {    \\n    private int[][] memo;\\n    private char[][] matrix;\\n    private int m, n, sqrlen;\\n    \\n    public int maximalSquare(char[][] matrix) {\\n        this.m = matrix.length;\\n        this.n = matrix[0].length;\\n        this.matrix = matrix;\\n        this.memo = new int[m][n];\\n        \\n        dp(m - 1, n - 1);\\n\\t\\t\\n        return sqrlen * sqrlen;\\n    }\\n    \\n    private int dp(int i, int j) {\\n        if (i < 0 || j < 0)\\n            return 0;\\n        \\n        if (memo[i][j] != 0)\\n            return memo[i][j];\\n        \\n        if (matrix[i][j] == \\'1\\')\\n            memo[i][j] = Math.min(Math.min(dp(i - 1, j), dp(i, j - 1)), dp(i - 1, j - 1)) + 1;\\n        else {\\n            dp(i - 1, j);\\n            dp(i, j - 1);\\n        }\\n        \\n        sqrlen = Math.max(sqrlen, memo[i][j]);\\n        \\n        return memo[i][j];\\n    }\\n}\\n```\\n\\nBottom-up (iterative) approach:\\n\\n```\\nclass Solution {\\n    public int maximalSquare(char[][] matrix) {\\n        int m = matrix.length, n = matrix[0].length;\\n        int[][] dp = new int[m + 1][n + 1];\\n        int sqrlen = 0;\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (matrix[i - 1][j - 1] == \\'1\\') {\\n                    dp[i][j] = Math.min(Math.min(dp[i][j - 1], dp[i - 1][j]), dp[i - 1][j - 1]) + 1;\\n                    sqrlen = Math.max(sqrlen, dp[i][j]);\\n                }\\n            }\\n        }\\n        return sqrlen * sqrlen;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {    \\n    private int[][] memo;\\n    private char[][] matrix;\\n    private int m, n, sqrlen;\\n    \\n    public int maximalSquare(char[][] matrix) {\\n        this.m = matrix.length;\\n        this.n = matrix[0].length;\\n        this.matrix = matrix;\\n        this.memo = new int[m][n];\\n        \\n        dp(m - 1, n - 1);\\n\\t\\t\\n        return sqrlen * sqrlen;\\n    }\\n    \\n    private int dp(int i, int j) {\\n        if (i < 0 || j < 0)\\n            return 0;\\n        \\n        if (memo[i][j] != 0)\\n            return memo[i][j];\\n        \\n        if (matrix[i][j] == \\'1\\')\\n            memo[i][j] = Math.min(Math.min(dp(i - 1, j), dp(i, j - 1)), dp(i - 1, j - 1)) + 1;\\n        else {\\n            dp(i - 1, j);\\n            dp(i, j - 1);\\n        }\\n        \\n        sqrlen = Math.max(sqrlen, memo[i][j]);\\n        \\n        return memo[i][j];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maximalSquare(char[][] matrix) {\\n        int m = matrix.length, n = matrix[0].length;\\n        int[][] dp = new int[m + 1][n + 1];\\n        int sqrlen = 0;\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (matrix[i - 1][j - 1] == \\'1\\') {\\n                    dp[i][j] = Math.min(Math.min(dp[i][j - 1], dp[i - 1][j]), dp[i - 1][j - 1]) + 1;\\n                    sqrlen = Math.max(sqrlen, dp[i][j]);\\n                }\\n            }\\n        }\\n        return sqrlen * sqrlen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1632321,
                "title": "easy-c-solution-recursive-memoization-tabulation",
                "content": "\\n# Recursive+Memoization\\n```\\nint t[301][301];\\n    int maximalSquare(vector<vector<char>>& matrix) \\n    {\\n        memset(t,-1,sizeof(t));\\n        int ans=0;\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            for(int j=0;j<matrix[0].size();j++)\\n            {\\n                if(matrix[i][j]==\\'1\\')\\n                    ans=max(ans,solve(matrix,i,j));\\n                \\n            }\\n        }\\n        return ans*ans;\\n    }\\n    \\n    int solve(vector<vector<char>>&matrix,int i,int j)\\n    {\\n        if(i<0 || i>=matrix.size() || j<0 || j>=matrix[0].size() || matrix[i][j]==\\'0\\')\\n            return 0;\\n        if(t[i][j]!=-1)\\n            return t[i][j];\\n        return t[i][j] = 1+min(solve(matrix,i-1,j-1),min(solve(matrix,i-1,j),solve(matrix,i,j-1)));\\n    }\\n```\\n\\n\\n\\n# Tabulation\\n       ``\\n\\t   int n=matrix.size();\\n        int m=matrix[0].size();\\n        int t[n][m];\\n        int ans=0;\\n        //Filling 1st row as it is\\n        for(int i=0;i<m;i++)\\n        {\\n            t[0][i]=matrix[0][i]-\\'0\\';\\n            ans=max(ans,t[0][i]);\\n        }\\n        \\n        //Filling 1st column as it is\\n        for(int j=0;j<n;j++)\\n        {\\n            t[j][0]=matrix[j][0]-\\'0\\';\\n            ans=max(ans,t[j][0]);\\n        }\\n    \\n        //filling rest of the cells\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=1;j<m;j++)\\n            {\\n                if(matrix[i][j]==\\'0\\')\\n                    t[i][j]=0;\\n                else\\n                    t[i][j]=1+min(t[i-1][j-1],min(t[i-1][j],t[i][j-1]));\\n                    ans=max(ans,t[i][j]);\\n            }\\n        }\\n        return ans*ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nint t[301][301];\\n    int maximalSquare(vector<vector<char>>& matrix) \\n    {\\n        memset(t,-1,sizeof(t));\\n        int ans=0;\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            for(int j=0;j<matrix[0].size();j++)\\n            {\\n                if(matrix[i][j]==\\'1\\')\\n                    ans=max(ans,solve(matrix,i,j));\\n                \\n            }\\n        }\\n        return ans*ans;\\n    }\\n    \\n    int solve(vector<vector<char>>&matrix,int i,int j)\\n    {\\n        if(i<0 || i>=matrix.size() || j<0 || j>=matrix[0].size() || matrix[i][j]==\\'0\\')\\n            return 0;\\n        if(t[i][j]!=-1)\\n            return t[i][j];\\n        return t[i][j] = 1+min(solve(matrix,i-1,j-1),min(solve(matrix,i-1,j),solve(matrix,i,j-1)));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1506452,
                "title": "c-dp-time-o-n-m-space-o-1-easy-to-understand",
                "content": "```\\nint maximalSquare(vector<vector<char>>& arr) {\\n        int max_sq = 0;\\n        int n = arr.size(), m = arr[0].size();\\n    \\n        for(int i=0;i<n;i++)\\n            if(arr[i][0]==\\'1\\') max_sq=1;\\n        \\n        for(int i=0;i<m;i++)\\n            if(arr[0][i]==\\'1\\') max_sq=1;\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=1; j<m; j++){\\n                \\n                if(arr[i][j]==\\'0\\') continue;\\n                \\n                int tmp = min(min(arr[i-1][j-1]-\\'0\\' ,arr[i-1][j]-\\'0\\'), arr[i][j-1]-\\'0\\')+1;\\n                arr[i][j] = tmp+\\'0\\';\\n        \\n                max_sq = max(max_sq,tmp);\\n            }\\n        }\\n        return max_sq*max_sq;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint maximalSquare(vector<vector<char>>& arr) {\\n        int max_sq = 0;\\n        int n = arr.size(), m = arr[0].size();\\n    \\n        for(int i=0;i<n;i++)\\n            if(arr[i][0]==\\'1\\') max_sq=1;\\n        \\n        for(int i=0;i<m;i++)\\n            if(arr[0][i]==\\'1\\') max_sq=1;\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=1; j<m; j++){\\n                \\n                if(arr[i][j]==\\'0\\') continue;\\n                \\n                int tmp = min(min(arr[i-1][j-1]-\\'0\\' ,arr[i-1][j]-\\'0\\'), arr[i][j-1]-\\'0\\')+1;\\n                arr[i][j] = tmp+\\'0\\';\\n        \\n                max_sq = max(max_sq,tmp);\\n            }\\n        }\\n        return max_sq*max_sq;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1463726,
                "title": "c-recursive-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n       \\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        int sum=0;\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++)\\n            {\\n                if(matrix[i][j]==\\'1\\')\\n                {\\n                    int curr=solve(matrix,n,m,i,j,dp);\\n                    sum=max(sum,curr);\\n                }\\n            }\\n        }\\n        return sum*sum;\\n    }\\n    int solve(vector<vector<char>> &v,int n,int m,int i,int j,vector<vector<int>>&dp){\\n\\n        if(i>=n || j>= m || v[i][j]==\\'0\\')return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        return dp[i][j]=1+min(solve(v,n,m,i+1,j,dp),min(solve(v,n,m,i+1,j+1,dp),solve(v,n,m,i,j+1,dp)));\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n       \\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        int sum=0;\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++)\\n            {\\n                if(matrix[i][j]==\\'1\\')\\n                {\\n                    int curr=solve(matrix,n,m,i,j,dp);\\n                    sum=max(sum,curr);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1143439,
                "title": "java-stack-beats-100-o-row-col",
                "content": "\\n    // O(row*col)\\n\\tpublic int maximalSquare(char[][] M) {\\n\\n\\t\\tint row = M.length, col = M[0].length, max_area = 0;\\n\\t\\tint[] temp = new int[col];\\n\\n\\t\\tfor (int i = 0; i < row; i++) {\\n\\t\\t\\tfor (int j = 0; j < col; j++)\\n\\t\\t\\t\\ttemp[j] = (M[i][j] == \\'0\\') ? 0 : temp[j] + 1;\\n\\t\\t\\tint area = largestSquareArea(temp);\\n\\t\\t\\tif (area > max_area)\\n\\t\\t\\t\\tmax_area = area;\\n\\t\\t}\\n\\n\\t\\treturn max_area;\\n\\t}\\n\\n\\t// O(col)\\n\\tpublic int largestSquareArea(int[] heights) {\\n\\t\\tint max = 0, len = heights.length;\\n\\n\\t\\tint[] stack = new int[len];\\n\\n\\t\\tint i = 0, idx = -1;\\n\\n\\t\\twhile (i < len) {\\n\\n\\t\\t\\tif (idx == -1 || heights[stack[idx]] <= heights[i]) {\\n\\t\\t\\t\\tidx++;\\n\\t\\t\\t\\tstack[idx] = i;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tint pb = heights[stack[idx]];\\n                idx--;\\n\\n\\t\\t\\t\\tint r = i;\\n\\t\\t\\t\\tint l = -1;\\n\\n\\t\\t\\t\\tif (idx != -1)\\n\\t\\t\\t\\t\\tl = stack[idx];\\n\\n\\t\\t\\t\\tint min = Math.min(r - l - 1, pb);\\n\\t\\t\\t\\tint area = min * min;\\n\\n\\t\\t\\t\\tif (area > max)\\n\\t\\t\\t\\t\\tmax = area;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\twhile (idx != -1) {\\n\\n\\t\\t\\tint pb = heights[stack[idx]];\\n            idx--;\\n\\n\\t\\t\\tint r = len;\\n\\t\\t\\tint l = -1;\\n\\n\\t\\t\\tif (idx != -1)\\n\\t\\t\\t\\tl = stack[idx];\\n\\n\\t\\t\\tint min = Math.min(r - l - 1, pb);\\n\\t\\t\\tint area = min * min;\\n\\n\\t\\t\\tif (area > max)\\n\\t\\t\\t\\tmax = area;\\n\\t\\t}\\n\\n\\t\\treturn max;\\n\\t}",
                "solutionTags": [],
                "code": "\\n    // O(row*col)\\n\\tpublic int maximalSquare(char[][] M) {\\n\\n\\t\\tint row = M.length, col = M[0].length, max_area = 0;\\n\\t\\tint[] temp = new int[col];\\n\\n\\t\\tfor (int i = 0; i < row; i++) {\\n\\t\\t\\tfor (int j = 0; j < col; j++)\\n\\t\\t\\t\\ttemp[j] = (M[i][j] == \\'0\\') ? 0 : temp[j] + 1;\\n\\t\\t\\tint area = largestSquareArea(temp);\\n\\t\\t\\tif (area > max_area)\\n\\t\\t\\t\\tmax_area = area;\\n\\t\\t}\\n\\n\\t\\treturn max_area;\\n\\t}\\n\\n\\t// O(col)\\n\\tpublic int largestSquareArea(int[] heights) {\\n\\t\\tint max = 0, len = heights.length;\\n\\n\\t\\tint[] stack = new int[len];\\n\\n\\t\\tint i = 0, idx = -1;\\n\\n\\t\\twhile (i < len) {\\n\\n\\t\\t\\tif (idx == -1 || heights[stack[idx]] <= heights[i]) {\\n\\t\\t\\t\\tidx++;\\n\\t\\t\\t\\tstack[idx] = i;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tint pb = heights[stack[idx]];\\n                idx--;\\n\\n\\t\\t\\t\\tint r = i;\\n\\t\\t\\t\\tint l = -1;\\n\\n\\t\\t\\t\\tif (idx != -1)\\n\\t\\t\\t\\t\\tl = stack[idx];\\n\\n\\t\\t\\t\\tint min = Math.min(r - l - 1, pb);\\n\\t\\t\\t\\tint area = min * min;\\n\\n\\t\\t\\t\\tif (area > max)\\n\\t\\t\\t\\t\\tmax = area;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\twhile (idx != -1) {\\n\\n\\t\\t\\tint pb = heights[stack[idx]];\\n            idx--;\\n\\n\\t\\t\\tint r = len;\\n\\t\\t\\tint l = -1;\\n\\n\\t\\t\\tif (idx != -1)\\n\\t\\t\\t\\tl = stack[idx];\\n\\n\\t\\t\\tint min = Math.min(r - l - 1, pb);\\n\\t\\t\\tint area = min * min;\\n\\n\\t\\t\\tif (area > max)\\n\\t\\t\\t\\tmax = area;\\n\\t\\t}\\n\\n\\t\\treturn max;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1117284,
                "title": "javascript-99-7",
                "content": "![image](https://assets.leetcode.com/users/images/8d8c0e37-1808-42cb-af2d-28592dfd36dc_1616169069.3948543.png)\\n\\n```\\nvar maximalSquare = function(matrix) {\\n    let maxSize = 0;\\n    for (let i = 0; i < matrix.length; i++) {\\n        for (let j = 0; j < matrix[0].length; j++) {\\n\\t\\t\\t//Convert value from string to number.\\n            matrix[i][j] = matrix[i][j] - 0\\n\\t\\t\\tif (!maxSize && matrix[i][j]) maxSize = 1;\\n\\t\\t\\t//If above, to the side and diagonal all squares, take minimum value + 1.\\n\\t\\t\\t//This represents longest side of square at that point.\\n            if (i - 1 >= 0 && j - 1 >= 0 && matrix[i][j] === 1) {\\n                matrix[i][j] = Math.min(matrix[i - 1][j], matrix[i][j-1], matrix[i-1][j-1]) + 1;\\n\\t\\t\\t\\tmaxSize = Math.max(maxSize, matrix[i][j])\\n            }\\n        }\\n    }\\n\\t//Square value since maxSize represents max side length.\\n    return (maxSize) ** 2;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar maximalSquare = function(matrix) {\\n    let maxSize = 0;\\n    for (let i = 0; i < matrix.length; i++) {\\n        for (let j = 0; j < matrix[0].length; j++) {\\n\\t\\t\\t//Convert value from string to number.\\n            matrix[i][j] = matrix[i][j] - 0\\n\\t\\t\\tif (!maxSize && matrix[i][j]) maxSize = 1;\\n\\t\\t\\t//If above, to the side and diagonal all squares, take minimum value + 1.\\n\\t\\t\\t//This represents longest side of square at that point.\\n            if (i - 1 >= 0 && j - 1 >= 0 && matrix[i][j] === 1) {\\n                matrix[i][j] = Math.min(matrix[i - 1][j], matrix[i][j-1], matrix[i-1][j-1]) + 1;\\n\\t\\t\\t\\tmaxSize = Math.max(maxSize, matrix[i][j])\\n            }\\n        }\\n    }\\n\\t//Square value since maxSize represents max side length.\\n    return (maxSize) ** 2;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1115543,
                "title": "c-recursive-and-iterative-dp-solutions",
                "content": "**Recursive solution : Runtime 28ms**\\n```\\nclass Solution {\\npublic:\\n    int dp[301][301];\\n    int dfs(vector<vector<char>> &mat, int i, int j) {\\n\\t\\n        if(i>=mat.size() || j>=mat[0].size() || mat[i][j]==\\'0\\') return 0;\\n\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        return dp[i][j] = min({\\n            dfs(mat,i+1,j)+1,\\n            dfs(mat,i,j+1)+1,\\n            dfs(mat,i+1,j+1)+1\\n        });\\n    }\\n    \\n    int maximalSquare(vector<vector<char>>& mat) {\\n        memset(dp,-1,sizeof dp);\\n        int ans=0;\\n        for(int i=0;i<mat.size();i++) {\\n            for(int j=0;j<mat[0].size();j++) {\\n                if(mat[i][j]==\\'1\\')\\n                ans=max(ans,dfs(mat,i,j));\\n            }\\n        }\\n        return ans*ans;\\n    }\\n};\\n```\\n**Recursive solution converted to iterative : Runtime 20ms**\\n```\\nint maximalSquare(vector<vector<char>>& mat) {\\n\\tint dp[mat.size()+1][mat[0].size()+1];\\n\\tmemset(dp,0,sizeof dp);\\n\\n\\tint ans=0;\\n\\tfor(int i=1;i<=mat.size();i++) {\\n\\t\\tfor(int j=1;j<=mat[0].size();j++) {\\n\\t\\t\\tif(mat[i-1][j-1] == \\'0\\') continue;\\n\\n\\t\\t\\tdp[i][j]=min({dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+1});\\n\\t\\t\\tans=max(ans,dp[i][j]);\\n\\t\\t}\\n\\t}\\n\\treturn ans*ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[301][301];\\n    int dfs(vector<vector<char>> &mat, int i, int j) {\\n\\t\\n        if(i>=mat.size() || j>=mat[0].size() || mat[i][j]==\\'0\\') return 0;\\n\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        return dp[i][j] = min({\\n            dfs(mat,i+1,j)+1,\\n            dfs(mat,i,j+1)+1,\\n            dfs(mat,i+1,j+1)+1\\n        });\\n    }\\n    \\n    int maximalSquare(vector<vector<char>>& mat) {\\n        memset(dp,-1,sizeof dp);\\n        int ans=0;\\n        for(int i=0;i<mat.size();i++) {\\n            for(int j=0;j<mat[0].size();j++) {\\n                if(mat[i][j]==\\'1\\')\\n                ans=max(ans,dfs(mat,i,j));\\n            }\\n        }\\n        return ans*ans;\\n    }\\n};\\n```\n```\\nint maximalSquare(vector<vector<char>>& mat) {\\n\\tint dp[mat.size()+1][mat[0].size()+1];\\n\\tmemset(dp,0,sizeof dp);\\n\\n\\tint ans=0;\\n\\tfor(int i=1;i<=mat.size();i++) {\\n\\t\\tfor(int j=1;j<=mat[0].size();j++) {\\n\\t\\t\\tif(mat[i-1][j-1] == \\'0\\') continue;\\n\\n\\t\\t\\tdp[i][j]=min({dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+1});\\n\\t\\t\\tans=max(ans,dp[i][j]);\\n\\t\\t}\\n\\t}\\n\\treturn ans*ans;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1097801,
                "title": "clean-python-solution-with-other-similar-problems",
                "content": "```python\\nclass Solution(object):\\n    def maximalSquare(self, grid):\\n        if not grid or not grid[0]: return \\n        M, N = len(grid), len(grid[0])\\n        \\n        dp = [[0 for _ in xrange(N+1)] for _ in xrange(M+1)]\\n        ans = 0\\n        for i in xrange(M):\\n            for j in xrange(N):\\n                if grid[i][j]==\\'1\\':\\n                    dp[i+1][j+1] = min(dp[i][j], dp[i][j+1], dp[i+1][j])+1\\n                    ans = max(ans, dp[i+1][j+1])\\n        return ans**2\\n\\n\"\"\"\\nSimilar Problems: 85, 221, 304, 1277\\nFor more other topics similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def maximalSquare(self, grid):\\n        if not grid or not grid[0]: return \\n        M, N = len(grid), len(grid[0])\\n        \\n        dp = [[0 for _ in xrange(N+1)] for _ in xrange(M+1)]\\n        ans = 0\\n        for i in xrange(M):\\n            for j in xrange(N):\\n                if grid[i][j]==\\'1\\':\\n                    dp[i+1][j+1] = min(dp[i][j], dp[i][j+1], dp[i+1][j])+1\\n                    ans = max(ans, dp[i+1][j+1])\\n        return ans**2\\n\\n\"\"\"\\nSimilar Problems: 85, 221, 304, 1277\\nFor more other topics similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 944753,
                "title": "python-dp-probably-without-using-extra-space",
                "content": "```\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        if len(matrix) < 1:\\n            return 0\\n        rows,cols,max_size = len(matrix),len(matrix[0]),0\\n        for row in range(rows):\\n            for col in range(cols):\\n                matrix[row][col] = int(matrix[row][col])\\n                if matrix[row][col] >= 1:\\n                    if row-1 >= 0 and col-1 >= 0:\\n                        matrix[row][col] = min(matrix[row-1][col],matrix[row][col-1],matrix[row-1][col-1])+1\\n                    max_size = max(max_size,matrix[row][col])\\n        return max_size*max_size\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        if len(matrix) < 1:\\n            return 0\\n        rows,cols,max_size = len(matrix),len(matrix[0]),0\\n        for row in range(rows):\\n            for col in range(cols):\\n                matrix[row][col] = int(matrix[row][col])\\n                if matrix[row][col] >= 1:\\n                    if row-1 >= 0 and col-1 >= 0:\\n                        matrix[row][col] = min(matrix[row-1][col],matrix[row][col-1],matrix[row-1][col-1])+1\\n                    max_size = max(max_size,matrix[row][col])\\n        return max_size*max_size\\n```",
                "codeTag": "Java"
            },
            {
                "id": 600378,
                "title": "c-dp-solution",
                "content": "![image](https://assets.leetcode.com/users/images/f25b6b4d-39be-49c6-a351-1c95b5e70fe3_1638254045.0639465.png)\\n\\n\\n```\\npublic class Solution\\n{\\n    public int MaximalSquare(char[][] matrix)\\n    {\\n        if (matrix == null || matrix.Length == 0)\\n            return 0;\\n\\n        int m = matrix.Length, n = matrix[0].Length;\\n\\t\\t\\n        //dp[i,j]: max length of a square with right-bottom at [i,j]\\n        int[,] dp = new int[m, n];\\n        int max = 0;\\n\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (matrix[i][j] == \\'0\\')\\n                    continue;\\n\\n                if (i == 0 || j == 0)\\n                    dp[i, j] = 1;\\n                else\\n                    dp[i, j] = Math.Min(dp[i - 1, j - 1], Math.Min(dp[i - 1, j], dp[i, j - 1])) + 1;\\n\\n                max = Math.Max(max, dp[i, j]);\\n            }\\n        }\\n\\n        return max * max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public int MaximalSquare(char[][] matrix)\\n    {\\n        if (matrix == null || matrix.Length == 0)\\n            return 0;\\n\\n        int m = matrix.Length, n = matrix[0].Length;\\n\\t\\t\\n        //dp[i,j]: max length of a square with right-bottom at [i,j]\\n        int[,] dp = new int[m, n];\\n        int max = 0;\\n\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (matrix[i][j] == \\'0\\')\\n                    continue;\\n\\n                if (i == 0 || j == 0)\\n                    dp[i, j] = 1;\\n                else\\n                    dp[i, j] = Math.Min(dp[i - 1, j - 1], Math.Min(dp[i - 1, j], dp[i, j - 1])) + 1;\\n\\n                max = Math.Max(max, dp[i, j]);\\n            }\\n        }\\n\\n        return max * max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 600365,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The **ART** of dynamic programming](https://leetcode.com/discuss/general-discussion/712010/the-art-of-dynamic-programming-an-intuitive-approach-from-apprentice-to-master/)\\n\\n1. **A**ll possibilities are considered via brute-force top-down depth-first-search\\n2. **R**emember each subproblems\\' optimal solution via a DP memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n\\nOnly consider cells with value `\\'1\\'` as candidate participants in a maximal square.\\n\\n**Top-Down recurrence relation:** The optimal solution for each cell is 1 + the minimum of the adjacent cells down, right, down-and-right\\n\\n**Bottom-Up recurrence relation:** The optimal solution for each cell is 1 + the minimum of the adjacent cells above, left, above-and-left\\n\\n---\\n\\n**Kotlin Solutions:**\\n1. **A**ll possibilities are considered via brute-force top-down depth-first-search\\n```\\nclass Solution {\\n    fun maximalSquare(A: Array<CharArray>): Int {\\n        var best = 0\\n        var (M, N) = listOf(A.size, A[0].size)\\n        fun go(i: Int, j: Int): Int {\\n            if (A[i][j] == \\'0\\' || i == M - 1 || j == N - 1)\\n                return if (A[i][j] == \\'1\\') 1 else 0\\n            var D = go(i + 1, j)\\n            var R = go(i, j + 1)\\n            var X = go(i + 1, j + 1)\\n            return 1 + listOf(D, R, X).min()!!\\n        }\\n        for (i in 0 until M)\\n            for (j in 0 until N)\\n                best = Math.max(best, go(i, j))\\n        return best * best\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblems\\' optimal solution via a DP memo\\n```\\nclass Solution {\\n    fun maximalSquare(A: Array<CharArray>): Int {\\n        var best = 0\\n        var m = mutableMapOf<String, Int>()\\n        var (M, N) = listOf(A.size, A[0].size)\\n        fun go(i: Int, j: Int): Int {\\n            if (A[i][j] == \\'0\\' || i == M - 1 || j == N - 1)\\n                return if (A[i][j] == \\'1\\') 1 else 0\\n            var k = \"$i,$j\"\\n            if (!m.contains(k)) {\\n                var D = go(i + 1, j)\\n                var R = go(i, j + 1)\\n                var X = go(i + 1, j + 1)\\n                m[k] = 1 + listOf(D, R, X).min()!!\\n            }\\n            return m[k]!!\\n        }\\n        for (i in 0 until M)\\n            for (j in 0 until N)\\n                best = Math.max(best, go(i, j))\\n        return best * best\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\n    fun maximalSquare(A: Array<CharArray>): Int {\\n        var best = 0\\n        var (M, N) = listOf(A.size, A[0].size)\\n        var dp = Array(M) { IntArray(N) { 0 } }\\n        for (i in 0 until M) if (A[i][0] == \\'1\\') { dp[i][0] = 1; best = 1 }\\n        for (j in 0 until N) if (A[0][j] == \\'1\\') { dp[0][j] = 1; best = 1 }\\n        for (i in 1 until M) {\\n            for (j in 1 until N) {\\n                if (A[i][j] == \\'0\\')\\n                    continue\\n                var U = dp[i - 1][j]\\n                var L = dp[i][j - 1]\\n                var X = dp[i - 1][j - 1]\\n                dp[i][j] = 1 + listOf(U, L, X).min()!!\\n                best = Math.max(best, dp[i][j])\\n            }\\n        }\\n        return best * best\\n    }\\n}\\n```\\n\\n4. Memory optimization from O(N<sup>2</sup>) to O(N) by replacing entire `dp` matrix with previous `pre` and current `cur` rows\\n```\\nclass Solution {\\n    fun maximalSquare(A: Array<CharArray>): Int {\\n        var best = 0\\n        var (M, N) = listOf(A.size, A[0].size)\\n        var pre = IntArray(N) { 0 }\\n        for (j in 0 until N)\\n            if (A[0][j] == \\'1\\') { pre[j] = 1; best = Math.max(best, 1) }\\n        for (i in 1 until M) {\\n            var cur = IntArray(N) { 0 }\\n            if (A[i][0] == \\'1\\') { cur[0] = 1; best = Math.max(best, 1) }\\n            for (j in 1 until N) {\\n                if (A[i][j] == \\'0\\')\\n                    continue\\n                var U = pre[j]\\n                var L = cur[j - 1]\\n                var X = pre[j - 1]\\n                cur[j] = 1 + listOf(U, L, X).min()!!\\n                best = Math.max(best, cur[j])\\n            }\\n            pre = cur.also{ cur = pre }\\n        }\\n        return best * best\\n    }\\n}\\n```\\n\\n\\n---\\n\\n**Javascript Solutions:**\\n1. **A**ll possibilities are considered via brute-force top-down depth-first-search\\n```\\nlet maximalSquare = (A, best = 0) => {\\n    let [M, N] = [A.length, A[0].length];\\n    let go = (i, j) => {\\n        if (A[i][j] == \\'0\\' || i == M - 1 || j == N - 1)\\n            return Number(A[i][j] == \\'1\\');\\n        let D = go(i + 1, j),\\n            R = go(i, j + 1),\\n            X = go(i + 1, j + 1);\\n        return 1 + Math.min(D, R, X);\\n    };\\n    for (let i = 0; i < M; ++i)\\n        for (let j = 0; j < N; ++j)\\n            best = Math.max(best, go(i, j));\\n    return best * best;\\n};\\n```\\n\\n2. **R**emember each subproblems\\' optimal solution via a DP memo\\n```\\nlet maximalSquare = (A, m = new Map(), best = 0) => {\\n    let [M, N] = [A.length, A[0].length];\\n    let go = (i, j) => {\\n        if (A[i][j] == \\'0\\' || i == M - 1 || j == N - 1)\\n            return Number(A[i][j] == \\'1\\');\\n        let k = `${i},${j}`;\\n        if (!m.has(k)) {\\n            let D = go(i + 1, j),\\n                R = go(i, j + 1),\\n                X = go(i + 1, j + 1);\\n            m.set(k, 1 + Math.min(D, R, X));\\n        }\\n        return m.get(k);\\n    };\\n    for (let i = 0; i < M; ++i)\\n        for (let j = 0; j < N; ++j)\\n            best = Math.max(best, go(i, j));\\n    return best * best;\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nlet maximalSquare = (A, best = 0) => {\\n    let [M, N] = [A.length, A[0].length];\\n    let dp = [...Array(M)].map(_ => Array(N).fill(0));\\n    for (let i = 0; i < M; ++i) dp[i][0] = Number(A[i][0] == \\'1\\'), best = Math.max(best, dp[i][0]);\\n    for (let j = 0; j < N; ++j) dp[0][j] = Number(A[0][j] == \\'1\\'), best = Math.max(best, dp[0][j]);\\n    for (let i = 1; i < M; ++i) {\\n        for (let j = 1; j < N; ++j) {\\n            if (A[i][j] == \\'0\\')\\n                continue;\\n            let U = dp[i - 1][j],\\n                L = dp[i][j - 1],\\n                X = dp[i - 1][j - 1];\\n            dp[i][j] = 1 + Math.min(U, L, X);\\n            best = Math.max(best, dp[i][j]);\\n        }\\n    }\\n    return best * best;\\n};\\n```\\n\\n4. Memory optimization from O(N<sup>2</sup>) to O(N) by replacing entire `dp` matrix with previous `pre` and current `cur` rows\\n```\\nlet maximalSquare = (A, best = 0) => {\\n    let [M, N] = [A.length, A[0].length];\\n    let pre = Array(N).fill(0);\\n    for (let j = 0; j < N; ++j)\\n        pre[j] = Number(A[0][j] == \\'1\\'), best = Math.max(best, pre[j]);\\n    for (let i = 1; i < M; ++i) {\\n        let cur = Array(N).fill(0);\\n        cur[0] = Number(A[i][0] == \\'1\\'), best = Math.max(best, cur[0]);\\n        for (let j = 1; j < N; ++j) {\\n            if (A[i][j] == \\'0\\')\\n                continue;\\n            let U = pre[j],\\n                L = cur[j - 1],\\n                X = pre[j - 1];\\n            cur[j] = 1 + Math.min(U, L, X);\\n            best = Math.max(best, cur[j]);\\n        }\\n        [pre, cur] = [cur, pre];\\n    }\\n    return best * best;\\n};\\n```\\n\\n\\n---\\n\\n**Python3 Solutions:**\\n1. **A**ll possibilities are considered via brute-force top-down depth-first-search\\n```\\nclass Solution:\\n    def maximalSquare(self, A: List[List[str]]) -> int:\\n        M, N = len(A), len(A[0])\\n        def go(i, j):\\n            if A[i][j] == \\'0\\' or i == M - 1 or j == N - 1:\\n                return int(A[i][j] == \\'1\\')\\n            D = go(i + 1, j)\\n            R = go(i, j + 1)\\n            X = go(i + 1, j + 1)\\n            return 1 + min(D, R, X)\\n        best = max(go(i, j) for j in range(N) for i in range(M))\\n        return best * best\\n```\\n\\n2. **R**emember each subproblems\\' optimal solution via a DP memo\\n```\\nclass Solution:\\n    def maximalSquare(self, A: List[List[str]]) -> int:\\n        M, N = len(A), len(A[0])\\n        @cache\\n        def go(i, j):\\n            if A[i][j] == \\'0\\' or i == M - 1 or j == N - 1:\\n                return int(A[i][j] == \\'1\\')\\n            D = go(i + 1, j)\\n            R = go(i, j + 1)\\n            X = go(i + 1, j + 1)\\n            return 1 + min(D, R, X)\\n        best = max(go(i, j) for j in range(N) for i in range(M))\\n        return best * best\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution:\\n    def maximalSquare(self, A: List[List[str]], best = 0) -> int:\\n        M, N = len(A), len(A[0])\\n        dp = [[0] * N for _ in range(M)]\\n        for i in range(M): dp[i][0] = int(A[i][0] == \\'1\\'); best = max(best, dp[i][0])\\n        for j in range(N): dp[0][j] = int(A[0][j] == \\'1\\'); best = max(best, dp[0][j])\\n        for i in range(1, M):\\n            for j in range(1, N):\\n                if A[i][j] == \\'0\\':\\n                    continue\\n                U = dp[i - 1][j]\\n                L = dp[i][j - 1]\\n                X = dp[i - 1][j - 1]\\n                dp[i][j] = 1 + min(U, L, X)\\n                best = max(best, dp[i][j])\\n        return best * best\\n```\\n\\n4. Memory optimization from O(N<sup>2</sup>) to O(N) by replacing entire `dp` matrix with previous `pre` and current `cur` rows\\n```\\nclass Solution:\\n    def maximalSquare(self, A: List[List[str]], best = 0) -> int:\\n        M, N = len(A), len(A[0])\\n        pre = [0] * N\\n        for j in range(N):\\n            pre[j] = int(A[0][j] == \\'1\\'); best = max(best, pre[j])\\n        for i in range(1, M):\\n            cur = [0] * N\\n            cur[0] = int(A[i][0] == \\'1\\'); best = max(best, cur[0])\\n            for j in range(1, N):\\n                if A[i][j] == \\'0\\':\\n                    continue\\n                U = pre[j]\\n                L = cur[j - 1]\\n                X = pre[j - 1]\\n                cur[j] = 1 + min(U, L, X)\\n                best = max(best, cur[j])\\n            pre, cur = cur, pre\\n        return best * best\\n```\\n\\n\\n---\\n\\n**C++ Solutions:**\\n1. **A**ll possibilities are considered via brute-force top-down depth-first-search\\n```\\nclass Solution {\\npublic:\\n    using VC = vector<char>;\\n    using VVC = vector<VC>;\\n    using fun = function<int(int, int)>;\\n    int maximalSquare(VVC& A, int best = 0) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        fun go = [&](auto i, auto j) {\\n            if (A[i][j] == \\'0\\' || i == M - 1 || j == N - 1)\\n                return A[i][j] - \\'0\\';\\n            auto D = go(i + 1, j),\\n                 R = go(i, j + 1),\\n                 X = go(i + 1, j + 1);\\n            return 1 + min({ D, R, X });\\n        };\\n        for (auto i{ 0 }; i < M; ++i)\\n            for (auto j{ 0 }; j < N; ++j)\\n                best = max(best, go(i, j));\\n        return best * best;\\n    }\\n};\\n```\\n\\n2. **R**emember each subproblems\\' optimal solution via a DP memo\\n```\\nclass Solution {\\npublic:\\n    using VC = vector<char>;\\n    using VVC = vector<VC>;\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int maximalSquare(VVC& A, int best = 0, Map m = {}) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        auto key = [](auto i, auto j) {\\n            stringstream ss; ss << i << \",\" << j;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto j) {\\n            if (A[i][j] == \\'0\\' || i == M - 1 || j == N - 1)\\n                return A[i][j] - \\'0\\';\\n            auto k = key(i, j);\\n            if (m.find(k) == m.end()) {\\n                auto D = go(i + 1, j),\\n                     R = go(i, j + 1),\\n                     X = go(i + 1, j + 1);\\n                return 1 + min({ D, R, X });\\n            }\\n            return m[k];\\n        };\\n        for (auto i{ 0 }; i < M; ++i)\\n            for (auto j{ 0 }; j < N; ++j)\\n                best = max(best, go(i, j));\\n        return best * best;\\n    }\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\npublic:\\n    using VC = vector<char>;\\n    using VVC = vector<VC>;\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int maximalSquare(VVC& A, int best = 0) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        VVI dp(M, VI(N));\\n        for (auto i{ 0 }; i < M; ++i)\\n            for (auto j{ 0 }; j < N; ++j)\\n                dp[i][j] = A[i][j] == \\'1\\', best = max(best, dp[i][j]);\\n        for (auto i{ 1 }; i < M; ++i) {\\n            for (auto j{ 1 }; j < N; ++j) {\\n                if (!dp[i][j])\\n                    continue;\\n                auto U = dp[i - 1][j],\\n                     L = dp[i][j - 1],\\n                     X = dp[i - 1][j - 1];\\n                dp[i][j] = 1 + min({ U, L, X });\\n                best = max(best, dp[i][j]);\\n            }\\n        }\\n        return best * best;\\n    }\\n};\\n```\\n\\n4. Memory optimization from O(N<sup>2</sup>) to O(N) by replacing entire `dp` matrix with previous `pre` and current `cur` rows\\n```\\nclass Solution {\\npublic:\\n    using VC = vector<char>;\\n    using VVC = vector<VC>;\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int maximalSquare(VVC& A, int best = 0) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        VI pre(N);\\n        for (auto j{ 0 }; j < N; ++j)\\n            pre[j] = A[0][j] == \\'1\\', best = max(best, pre[j]);\\n        for (auto i{ 1 }; i < M; ++i) {\\n            VI cur(N);\\n            cur[0] = A[i][0] == \\'1\\', best = max(best, cur[0]);\\n            for (auto j{ 1 }; j < N; ++j) {\\n                if (A[i][j] == \\'0\\')\\n                    continue;\\n                auto U = pre[j],\\n                     L = cur[j - 1],\\n                     X = pre[j - 1];\\n                cur[j] = 1 + min({ U, L, X });\\n                best = max(best, cur[j]);\\n            }\\n            swap(pre, cur);\\n        }\\n        return best * best;\\n    }\\n};\\n```\\n\\n---\\n\\n**Rust Solution:** bottom-up DP\\n\\n```\\nuse std::cmp::max;\\nuse std::cmp::min;\\nimpl Solution {\\n    pub fn maximal_square(A: Vec<Vec<char>>) -> i32 {\\n        let mut best = 0;\\n        let (M, N) = (A.len(), A[0].len());\\n        let mut dp = vec![vec![0; N + 1]; M + 1];\\n        for i in (0..M).rev() {\\n            for j in (0..N).rev() {\\n                if A[i][j] == \\'0\\' {\\n                    continue;\\n                }\\n                dp[i][j] = 1 + min(dp[i + 1][j], min(dp[i][j + 1], dp[i + 1][j + 1]));\\n                let cand = dp[i][j];\\n                best = max(best, cand);\\n            }\\n        }\\n        return best * best;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun maximalSquare(A: Array<CharArray>): Int {\\n        var best = 0\\n        var (M, N) = listOf(A.size, A[0].size)\\n        fun go(i: Int, j: Int): Int {\\n            if (A[i][j] == \\'0\\' || i == M - 1 || j == N - 1)\\n                return if (A[i][j] == \\'1\\') 1 else 0\\n            var D = go(i + 1, j)\\n            var R = go(i, j + 1)\\n            var X = go(i + 1, j + 1)\\n            return 1 + listOf(D, R, X).min()!!\\n        }\\n        for (i in 0 until M)\\n            for (j in 0 until N)\\n                best = Math.max(best, go(i, j))\\n        return best * best\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun maximalSquare(A: Array<CharArray>): Int {\\n        var best = 0\\n        var m = mutableMapOf<String, Int>()\\n        var (M, N) = listOf(A.size, A[0].size)\\n        fun go(i: Int, j: Int): Int {\\n            if (A[i][j] == \\'0\\' || i == M - 1 || j == N - 1)\\n                return if (A[i][j] == \\'1\\') 1 else 0\\n            var k = \"$i,$j\"\\n            if (!m.contains(k)) {\\n                var D = go(i + 1, j)\\n                var R = go(i, j + 1)\\n                var X = go(i + 1, j + 1)\\n                m[k] = 1 + listOf(D, R, X).min()!!\\n            }\\n            return m[k]!!\\n        }\\n        for (i in 0 until M)\\n            for (j in 0 until N)\\n                best = Math.max(best, go(i, j))\\n        return best * best\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun maximalSquare(A: Array<CharArray>): Int {\\n        var best = 0\\n        var (M, N) = listOf(A.size, A[0].size)\\n        var dp = Array(M) { IntArray(N) { 0 } }\\n        for (i in 0 until M) if (A[i][0] == \\'1\\') { dp[i][0] = 1; best = 1 }\\n        for (j in 0 until N) if (A[0][j] == \\'1\\') { dp[0][j] = 1; best = 1 }\\n        for (i in 1 until M) {\\n            for (j in 1 until N) {\\n                if (A[i][j] == \\'0\\')\\n                    continue\\n                var U = dp[i - 1][j]\\n                var L = dp[i][j - 1]\\n                var X = dp[i - 1][j - 1]\\n                dp[i][j] = 1 + listOf(U, L, X).min()!!\\n                best = Math.max(best, dp[i][j])\\n            }\\n        }\\n        return best * best\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun maximalSquare(A: Array<CharArray>): Int {\\n        var best = 0\\n        var (M, N) = listOf(A.size, A[0].size)\\n        var pre = IntArray(N) { 0 }\\n        for (j in 0 until N)\\n            if (A[0][j] == \\'1\\') { pre[j] = 1; best = Math.max(best, 1) }\\n        for (i in 1 until M) {\\n            var cur = IntArray(N) { 0 }\\n            if (A[i][0] == \\'1\\') { cur[0] = 1; best = Math.max(best, 1) }\\n            for (j in 1 until N) {\\n                if (A[i][j] == \\'0\\')\\n                    continue\\n                var U = pre[j]\\n                var L = cur[j - 1]\\n                var X = pre[j - 1]\\n                cur[j] = 1 + listOf(U, L, X).min()!!\\n                best = Math.max(best, cur[j])\\n            }\\n            pre = cur.also{ cur = pre }\\n        }\\n        return best * best\\n    }\\n}\\n```\n```\\nlet maximalSquare = (A, best = 0) => {\\n    let [M, N] = [A.length, A[0].length];\\n    let go = (i, j) => {\\n        if (A[i][j] == \\'0\\' || i == M - 1 || j == N - 1)\\n            return Number(A[i][j] == \\'1\\');\\n        let D = go(i + 1, j),\\n            R = go(i, j + 1),\\n            X = go(i + 1, j + 1);\\n        return 1 + Math.min(D, R, X);\\n    };\\n    for (let i = 0; i < M; ++i)\\n        for (let j = 0; j < N; ++j)\\n            best = Math.max(best, go(i, j));\\n    return best * best;\\n};\\n```\n```\\nlet maximalSquare = (A, m = new Map(), best = 0) => {\\n    let [M, N] = [A.length, A[0].length];\\n    let go = (i, j) => {\\n        if (A[i][j] == \\'0\\' || i == M - 1 || j == N - 1)\\n            return Number(A[i][j] == \\'1\\');\\n        let k = `${i},${j}`;\\n        if (!m.has(k)) {\\n            let D = go(i + 1, j),\\n                R = go(i, j + 1),\\n                X = go(i + 1, j + 1);\\n            m.set(k, 1 + Math.min(D, R, X));\\n        }\\n        return m.get(k);\\n    };\\n    for (let i = 0; i < M; ++i)\\n        for (let j = 0; j < N; ++j)\\n            best = Math.max(best, go(i, j));\\n    return best * best;\\n};\\n```\n```\\nlet maximalSquare = (A, best = 0) => {\\n    let [M, N] = [A.length, A[0].length];\\n    let dp = [...Array(M)].map(_ => Array(N).fill(0));\\n    for (let i = 0; i < M; ++i) dp[i][0] = Number(A[i][0] == \\'1\\'), best = Math.max(best, dp[i][0]);\\n    for (let j = 0; j < N; ++j) dp[0][j] = Number(A[0][j] == \\'1\\'), best = Math.max(best, dp[0][j]);\\n    for (let i = 1; i < M; ++i) {\\n        for (let j = 1; j < N; ++j) {\\n            if (A[i][j] == \\'0\\')\\n                continue;\\n            let U = dp[i - 1][j],\\n                L = dp[i][j - 1],\\n                X = dp[i - 1][j - 1];\\n            dp[i][j] = 1 + Math.min(U, L, X);\\n            best = Math.max(best, dp[i][j]);\\n        }\\n    }\\n    return best * best;\\n};\\n```\n```\\nlet maximalSquare = (A, best = 0) => {\\n    let [M, N] = [A.length, A[0].length];\\n    let pre = Array(N).fill(0);\\n    for (let j = 0; j < N; ++j)\\n        pre[j] = Number(A[0][j] == \\'1\\'), best = Math.max(best, pre[j]);\\n    for (let i = 1; i < M; ++i) {\\n        let cur = Array(N).fill(0);\\n        cur[0] = Number(A[i][0] == \\'1\\'), best = Math.max(best, cur[0]);\\n        for (let j = 1; j < N; ++j) {\\n            if (A[i][j] == \\'0\\')\\n                continue;\\n            let U = pre[j],\\n                L = cur[j - 1],\\n                X = pre[j - 1];\\n            cur[j] = 1 + Math.min(U, L, X);\\n            best = Math.max(best, cur[j]);\\n        }\\n        [pre, cur] = [cur, pre];\\n    }\\n    return best * best;\\n};\\n```\n```\\nclass Solution:\\n    def maximalSquare(self, A: List[List[str]]) -> int:\\n        M, N = len(A), len(A[0])\\n        def go(i, j):\\n            if A[i][j] == \\'0\\' or i == M - 1 or j == N - 1:\\n                return int(A[i][j] == \\'1\\')\\n            D = go(i + 1, j)\\n            R = go(i, j + 1)\\n            X = go(i + 1, j + 1)\\n            return 1 + min(D, R, X)\\n        best = max(go(i, j) for j in range(N) for i in range(M))\\n        return best * best\\n```\n```\\nclass Solution:\\n    def maximalSquare(self, A: List[List[str]]) -> int:\\n        M, N = len(A), len(A[0])\\n        @cache\\n        def go(i, j):\\n            if A[i][j] == \\'0\\' or i == M - 1 or j == N - 1:\\n                return int(A[i][j] == \\'1\\')\\n            D = go(i + 1, j)\\n            R = go(i, j + 1)\\n            X = go(i + 1, j + 1)\\n            return 1 + min(D, R, X)\\n        best = max(go(i, j) for j in range(N) for i in range(M))\\n        return best * best\\n```\n```\\nclass Solution:\\n    def maximalSquare(self, A: List[List[str]], best = 0) -> int:\\n        M, N = len(A), len(A[0])\\n        dp = [[0] * N for _ in range(M)]\\n        for i in range(M): dp[i][0] = int(A[i][0] == \\'1\\'); best = max(best, dp[i][0])\\n        for j in range(N): dp[0][j] = int(A[0][j] == \\'1\\'); best = max(best, dp[0][j])\\n        for i in range(1, M):\\n            for j in range(1, N):\\n                if A[i][j] == \\'0\\':\\n                    continue\\n                U = dp[i - 1][j]\\n                L = dp[i][j - 1]\\n                X = dp[i - 1][j - 1]\\n                dp[i][j] = 1 + min(U, L, X)\\n                best = max(best, dp[i][j])\\n        return best * best\\n```\n```\\nclass Solution:\\n    def maximalSquare(self, A: List[List[str]], best = 0) -> int:\\n        M, N = len(A), len(A[0])\\n        pre = [0] * N\\n        for j in range(N):\\n            pre[j] = int(A[0][j] == \\'1\\'); best = max(best, pre[j])\\n        for i in range(1, M):\\n            cur = [0] * N\\n            cur[0] = int(A[i][0] == \\'1\\'); best = max(best, cur[0])\\n            for j in range(1, N):\\n                if A[i][j] == \\'0\\':\\n                    continue\\n                U = pre[j]\\n                L = cur[j - 1]\\n                X = pre[j - 1]\\n                cur[j] = 1 + min(U, L, X)\\n                best = max(best, cur[j])\\n            pre, cur = cur, pre\\n        return best * best\\n```\n```\\nclass Solution {\\npublic:\\n    using VC = vector<char>;\\n    using VVC = vector<VC>;\\n    using fun = function<int(int, int)>;\\n    int maximalSquare(VVC& A, int best = 0) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        fun go = [&](auto i, auto j) {\\n            if (A[i][j] == \\'0\\' || i == M - 1 || j == N - 1)\\n                return A[i][j] - \\'0\\';\\n            auto D = go(i + 1, j),\\n                 R = go(i, j + 1),\\n                 X = go(i + 1, j + 1);\\n            return 1 + min({ D, R, X });\\n        };\\n        for (auto i{ 0 }; i < M; ++i)\\n            for (auto j{ 0 }; j < N; ++j)\\n                best = max(best, go(i, j));\\n        return best * best;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VC = vector<char>;\\n    using VVC = vector<VC>;\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int maximalSquare(VVC& A, int best = 0, Map m = {}) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        auto key = [](auto i, auto j) {\\n            stringstream ss; ss << i << \",\" << j;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto j) {\\n            if (A[i][j] == \\'0\\' || i == M - 1 || j == N - 1)\\n                return A[i][j] - \\'0\\';\\n            auto k = key(i, j);\\n            if (m.find(k) == m.end()) {\\n                auto D = go(i + 1, j),\\n                     R = go(i, j + 1),\\n                     X = go(i + 1, j + 1);\\n                return 1 + min({ D, R, X });\\n            }\\n            return m[k];\\n        };\\n        for (auto i{ 0 }; i < M; ++i)\\n            for (auto j{ 0 }; j < N; ++j)\\n                best = max(best, go(i, j));\\n        return best * best;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VC = vector<char>;\\n    using VVC = vector<VC>;\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int maximalSquare(VVC& A, int best = 0) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        VVI dp(M, VI(N));\\n        for (auto i{ 0 }; i < M; ++i)\\n            for (auto j{ 0 }; j < N; ++j)\\n                dp[i][j] = A[i][j] == \\'1\\', best = max(best, dp[i][j]);\\n        for (auto i{ 1 }; i < M; ++i) {\\n            for (auto j{ 1 }; j < N; ++j) {\\n                if (!dp[i][j])\\n                    continue;\\n                auto U = dp[i - 1][j],\\n                     L = dp[i][j - 1],\\n                     X = dp[i - 1][j - 1];\\n                dp[i][j] = 1 + min({ U, L, X });\\n                best = max(best, dp[i][j]);\\n            }\\n        }\\n        return best * best;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VC = vector<char>;\\n    using VVC = vector<VC>;\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int maximalSquare(VVC& A, int best = 0) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        VI pre(N);\\n        for (auto j{ 0 }; j < N; ++j)\\n            pre[j] = A[0][j] == \\'1\\', best = max(best, pre[j]);\\n        for (auto i{ 1 }; i < M; ++i) {\\n            VI cur(N);\\n            cur[0] = A[i][0] == \\'1\\', best = max(best, cur[0]);\\n            for (auto j{ 1 }; j < N; ++j) {\\n                if (A[i][j] == \\'0\\')\\n                    continue;\\n                auto U = pre[j],\\n                     L = cur[j - 1],\\n                     X = pre[j - 1];\\n                cur[j] = 1 + min({ U, L, X });\\n                best = max(best, cur[j]);\\n            }\\n            swap(pre, cur);\\n        }\\n        return best * best;\\n    }\\n};\\n```\n```\\nuse std::cmp::max;\\nuse std::cmp::min;\\nimpl Solution {\\n    pub fn maximal_square(A: Vec<Vec<char>>) -> i32 {\\n        let mut best = 0;\\n        let (M, N) = (A.len(), A[0].len());\\n        let mut dp = vec![vec![0; N + 1]; M + 1];\\n        for i in (0..M).rev() {\\n            for j in (0..N).rev() {\\n                if A[i][j] == \\'0\\' {\\n                    continue;\\n                }\\n                dp[i][j] = 1 + min(dp[i + 1][j], min(dp[i][j + 1], dp[i + 1][j + 1]));\\n                let cand = dp[i][j];\\n                best = max(best, cand);\\n            }\\n        }\\n        return best * best;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 600212,
                "title": "rust-dp-solution",
                "content": "```\\nimpl Solution {\\n    pub fn maximal_square(matrix: Vec<Vec<char>>) -> i32 {\\n        if matrix.is_empty() {\\n            return 0;\\n        }\\n\\n        let (n, m) = (matrix.len(), matrix[0].len());\\n        let mut dp: Vec<Vec<i32>> = vec![vec![0; m + 1]; n + 1];\\n\\n        for y in 1..=n {\\n            for x in 1..=m {\\n                if matrix[y - 1][x - 1] == \\'1\\' {\\n                    dp[y][x] = dp[y - 1][x].min(dp[y][x - 1]).min(dp[y - 1][x - 1]) + 1;\\n                }\\n            }\\n        }\\n\\n        dp.into_iter()\\n            .map(|row| row.into_iter().max().unwrap())\\n            .max()\\n            .unwrap()\\n            .pow(2)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn maximal_square(matrix: Vec<Vec<char>>) -> i32 {\\n        if matrix.is_empty() {\\n            return 0;\\n        }\\n\\n        let (n, m) = (matrix.len(), matrix[0].len());\\n        let mut dp: Vec<Vec<i32>> = vec![vec![0; m + 1]; n + 1];\\n\\n        for y in 1..=n {\\n            for x in 1..=m {\\n                if matrix[y - 1][x - 1] == \\'1\\' {\\n                    dp[y][x] = dp[y - 1][x].min(dp[y][x - 1]).min(dp[y - 1][x - 1]) + 1;\\n                }\\n            }\\n        }\\n\\n        dp.into_iter()\\n            .map(|row| row.into_iter().max().unwrap())\\n            .max()\\n            .unwrap()\\n            .pow(2)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 455340,
                "title": "go-golang-0ms-two-solutions",
                "content": ">Runtime: 0 ms, faster than 100.00% of Go online submissions for Maximal Square.\\nMemory Usage: 4.3 MB, less than 50.00% of Go online submissions for Maximal Square.\\n\\n```go\\nfunc maximalSquare(matrix [][]byte) int {\\n    if len(matrix) == 0 { return 0 }\\n    m, n := len(matrix), len(matrix[0])\\n    dp := make([][]int, m + 1)\\n    ans := 0\\n    for i := range dp {\\n        dp[i] = make([]int, n + 1)\\n    }\\n    for i := 1; i <= m; i++ {\\n        for j := 1; j <= n; j++ {\\n            if matrix[i - 1][j - 1] == \\'1\\' {\\n                dp[i][j] = 1 + min(min(dp[i - 1][j - 1], dp[i - 1][j]), dp[i][j - 1])\\n            }\\n            ans = max(ans, dp[i][j])\\n        }\\n    }\\n    return ans * ans\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b { return a }\\n    return b\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```\\n\\n>Runtime: 0 ms, faster than 100.00% of Go online submissions for Maximal Square.\\nMemory Usage: 3.4 MB, less than 100.00% of Go online submissions for Maximal Square.\\n\\n```go\\nfunc maximalSquare(matrix [][]byte) int {\\n    if len(matrix) == 0 { return 0 }\\n    row := len(matrix)\\n    col := len(matrix[0])\\n    cur := make([]int, col)\\n    pre := 0 // previous row and col, last topleft\\n    size := 0\\n    for i := 0; i < row; i++ {\\n        for j := 0; j < col; j++ {\\n            tmp := cur[j]\\n            if i == 0 || j == 0 || matrix[i][j] == \\'0\\' {\\n                cur[j] = int(matrix[i][j] - \\'0\\')\\n            } else {\\n                cur[j] = min(pre, min(cur[j], cur[j-1])) + 1\\n            }\\n            if size < cur[j] {\\n                size = cur[j]\\n            }\\n            pre = tmp\\n        }\\n    }\\n    return size * size\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc maximalSquare(matrix [][]byte) int {\\n    if len(matrix) == 0 { return 0 }\\n    m, n := len(matrix), len(matrix[0])\\n    dp := make([][]int, m + 1)\\n    ans := 0\\n    for i := range dp {\\n        dp[i] = make([]int, n + 1)\\n    }\\n    for i := 1; i <= m; i++ {\\n        for j := 1; j <= n; j++ {\\n            if matrix[i - 1][j - 1] == \\'1\\' {\\n                dp[i][j] = 1 + min(min(dp[i - 1][j - 1], dp[i - 1][j]), dp[i][j - 1])\\n            }\\n            ans = max(ans, dp[i][j])\\n        }\\n    }\\n    return ans * ans\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b { return a }\\n    return b\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```\n```go\\nfunc maximalSquare(matrix [][]byte) int {\\n    if len(matrix) == 0 { return 0 }\\n    row := len(matrix)\\n    col := len(matrix[0])\\n    cur := make([]int, col)\\n    pre := 0 // previous row and col, last topleft\\n    size := 0\\n    for i := 0; i < row; i++ {\\n        for j := 0; j < col; j++ {\\n            tmp := cur[j]\\n            if i == 0 || j == 0 || matrix[i][j] == \\'0\\' {\\n                cur[j] = int(matrix[i][j] - \\'0\\')\\n            } else {\\n                cur[j] = min(pre, min(cur[j], cur[j-1])) + 1\\n            }\\n            if size < cur[j] {\\n                size = cur[j]\\n            }\\n            pre = tmp\\n        }\\n    }\\n    return size * size\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 440432,
                "title": "using-recursion-java-95",
                "content": "```\\nclass Solution {\\n    int dp[][] = null;\\n    public int maximalSquare(char[][] matrix) {\\n\\t\\tif (matrix.length == 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tdp = new int[matrix.length][matrix[0].length];\\n\\t\\tfor (int i = 0; i < dp.length; i++) {\\n\\t\\t\\tArrays.fill(dp[i], -1);\\n\\t\\t}\\n\\t\\tint h = matrix.length;\\n\\t\\tint l = matrix[0].length;\\n\\t\\tint max = 0;\\n\\n\\t\\tint curMax = 0;\\n\\t\\tfor (int i = 0; i < h; i++) {\\n\\t\\t\\tfor (int j = 0; j < l; j++) {\\n\\t\\t\\t\\tcurMax = findSquare(matrix, i, j);\\n\\t\\t\\t\\tif (max < curMax) {\\n\\t\\t\\t\\t\\tmax = curMax;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn max * max;\\n\\t}\\n\\n\\tprivate int findSquare(char[][] matrix, int i, int j) {\\n\\t\\tif (i >= matrix.length || j >= matrix[0].length) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tif (matrix[i][j] == \\'0\\') {\\n\\t\\t\\treturn dp[i][j] = 0;\\n\\t\\t}\\n\\t\\tif (dp[i][j] != -1) {\\n\\t\\t\\treturn dp[i][j];\\n\\t\\t}\\n\\t\\tint sum = 1 + Math.min(findSquare(matrix, i + 1, j + 1), Math.min(findSquare(matrix, i + 1, j), findSquare(matrix, i, j + 1)));\\n\\t\\treturn dp[i][j] = sum;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int dp[][] = null;\\n    public int maximalSquare(char[][] matrix) {\\n\\t\\tif (matrix.length == 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tdp = new int[matrix.length][matrix[0].length];\\n\\t\\tfor (int i = 0; i < dp.length; i++) {\\n\\t\\t\\tArrays.fill(dp[i], -1);\\n\\t\\t}\\n\\t\\tint h = matrix.length;\\n\\t\\tint l = matrix[0].length;\\n\\t\\tint max = 0;\\n\\n\\t\\tint curMax = 0;\\n\\t\\tfor (int i = 0; i < h; i++) {\\n\\t\\t\\tfor (int j = 0; j < l; j++) {\\n\\t\\t\\t\\tcurMax = findSquare(matrix, i, j);\\n\\t\\t\\t\\tif (max < curMax) {\\n\\t\\t\\t\\t\\tmax = curMax;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn max * max;\\n\\t}\\n\\n\\tprivate int findSquare(char[][] matrix, int i, int j) {\\n\\t\\tif (i >= matrix.length || j >= matrix[0].length) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tif (matrix[i][j] == \\'0\\') {\\n\\t\\t\\treturn dp[i][j] = 0;\\n\\t\\t}\\n\\t\\tif (dp[i][j] != -1) {\\n\\t\\t\\treturn dp[i][j];\\n\\t\\t}\\n\\t\\tint sum = 1 + Math.min(findSquare(matrix, i + 1, j + 1), Math.min(findSquare(matrix, i + 1, j), findSquare(matrix, i, j + 1)));\\n\\t\\treturn dp[i][j] = sum;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 384118,
                "title": "java-brute-force",
                "content": "```\\nclass Solution \\n{\\n    public int maximalSquare(char[][] matrix) \\n    {\\n        \\n        int m = matrix.length;\\n        if (m == 0) return 0;\\n        int n = matrix[0].length;\\n        if (n == 0) return 0;\\n        \\n        // brute force\\n        int max_k = -1;\\n        for (int i = 0; i < m; ++i)\\n        {\\n            for (int j = 0; j < n; ++j)\\n            {\\n                for (int k = 0; i + k < m && j + k < n; ++k)\\n                {\\n                    if (only_ones(matrix, i, j, k))\\n                    {\\n                        max_k = Math.max(k, max_k);\\n                    }\\n                    else\\n                    {\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        ++max_k;\\n        return max_k * max_k;\\n    }\\n    \\n    boolean only_ones(char[][] G, int start_i, int start_j, int k)\\n    {\\n        for (int i = start_i; i <= start_i + k; ++i)\\n        {\\n            for (int j = start_j; j <= start_j + k; ++j)\\n            {\\n                if (G[i][j] != \\'1\\') return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public int maximalSquare(char[][] matrix) \\n    {\\n        \\n        int m = matrix.length;\\n        if (m == 0) return 0;\\n        int n = matrix[0].length;\\n        if (n == 0) return 0;\\n        \\n        // brute force\\n        int max_k = -1;\\n        for (int i = 0; i < m; ++i)\\n        {\\n            for (int j = 0; j < n; ++j)\\n            {\\n                for (int k = 0; i + k < m && j + k < n; ++k)\\n                {\\n                    if (only_ones(matrix, i, j, k))\\n                    {\\n                        max_k = Math.max(k, max_k);\\n                    }\\n                    else\\n                    {\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        ++max_k;\\n        return max_k * max_k;\\n    }\\n    \\n    boolean only_ones(char[][] G, int start_i, int start_j, int k)\\n    {\\n        for (int i = start_i; i <= start_i + k; ++i)\\n        {\\n            for (int j = start_j; j <= start_j + k; ++j)\\n            {\\n                if (G[i][j] != \\'1\\') return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 372527,
                "title": "java-brute-force-solution",
                "content": "```java\\nclass Solution {\\n    public int maximalSquare(char[][] matrix) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\\n            return 0;\\n        }\\n        \\n        // Brute force\\n        int ans = 0;\\n        \\n        int nr = matrix.length;\\n        int nc = matrix[0].length;\\n        \\n        for (int len = 1; len <= Math.min(nr, nc); len++) {\\n            for (int i = 0; i + len <= nr; i++) {\\n                for (int j = 0; j + len <= nc; j++) {\\n                    // Top-left point is (i, j), with len, check every square\\n                    if (isSquare(i, j, len, matrix)) {\\n                        ans = Math.max(ans, len * len);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private boolean isSquare(int i, int j, int len, char[][] matrix) {\\n        for (int m = i; m < i + len; m++) {\\n            for (int n = j; n < j + len; n++) {\\n                if (matrix[m][n] == \\'0\\') {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int maximalSquare(char[][] matrix) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\\n            return 0;\\n        }\\n        \\n        // Brute force\\n        int ans = 0;\\n        \\n        int nr = matrix.length;\\n        int nc = matrix[0].length;\\n        \\n        for (int len = 1; len <= Math.min(nr, nc); len++) {\\n            for (int i = 0; i + len <= nr; i++) {\\n                for (int j = 0; j + len <= nc; j++) {\\n                    // Top-left point is (i, j), with len, check every square\\n                    if (isSquare(i, j, len, matrix)) {\\n                        ans = Math.max(ans, len * len);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private boolean isSquare(int i, int j, int len, char[][] matrix) {\\n        for (int m = i; m < i + len; m++) {\\n            for (int n = j; n < j + len; n++) {\\n                if (matrix[m][n] == \\'0\\') {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 166986,
                "title": "python-solution",
                "content": "Dynamic Programming O(mn) time, O(mn) space:\\ntableL[i][j] (tableU[i][j]) denotes the number of consecutive 1\\'s to the left (up) of matrix[i][j] (inclusive). tableD[i][j] denotes the largest length of the square whose bottom-right corner is matrix[i][j].\\n```\\nclass Solution(object):\\n    def maximalSquare(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        if not matrix:\\n            return 0\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        maximum = 0\\n        tableL = [[0]*n for _ in range(m)]\\n        tableU = [[0]*n for _ in range(m)]\\n        tableD = [[0]*n for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j] == \"0\":\\n                    tableL[i][j] = 0\\n                    tableU[i][j] = 0\\n                    tableD[i][j] = 0\\n                else:\\n                    if i == 0 and j == 0:\\n                        tableL[i][j] = 1\\n                        tableU[i][j] = 1\\n                        tableD[i][j] = 1\\n                    elif i == 0:\\n                        tableL[i][j] = tableL[i][j-1]+1\\n                        tableU[i][j] = 1\\n                        tableD[i][j] = 1\\n                    elif j == 0:\\n                        tableL[i][j] = 1\\n                        tableU[i][j] = tableU[i-1][j]+1\\n                        tableD[i][j] = 1\\n                    else:\\n                        tableL[i][j] = tableL[i][j-1]+1\\n                        tableU[i][j] = tableU[i-1][j]+1\\n                        tableD[i][j] = min(tableL[i][j],tableU[i][j],tableD[i-1][j-1]+1)\\n                candidate = tableD[i][j]\\n                if candidate > maximum:\\n                    maximum = candidate\\n        return maximum * maximum\\n```\\nTurns out that tableL and tableU are not needed after I studied the official solution. Below is an improved solution with O(mn) time O(mn) space:\\n```\\nclass Solution(object):\\n    def maximalSquare(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        if not matrix:\\n            return 0\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        maximum = 0\\n        table = [[0]*n for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j] == \"0\":\\n                    table[i][j] = 0\\n                else:\\n                    if i == 0 or j == 0:\\n                        table[i][j] = 1\\n                    else:\\n                        table[i][j] = min(table[i-1][j],table[i][j-1],table[i-1][j-1])+1\\n                if table[i][j] > maximum:\\n                    maximum = table[i][j]\\n        return maximum * maximum\\n```\\nAn even better solution with O(mn) time and O(n) space:\\n```\\nclass Solution(object):\\n    def maximalSquare(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        if not matrix:\\n            return 0\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        rec = [0]*n\\n        maximum = 0\\n        prev = 0\\n        for i in range(m):\\n            for j in range(n):\\n                temp = rec[j]\\n                if matrix[i][j] == \"1\":\\n                    if j > 0:\\n                        rec[j] = min(rec[j-1],rec[j],prev)+1\\n                    else:\\n                        rec[j] = 1\\n                else:\\n                    rec[j] = 0\\n                prev = temp\\n                maximum = max(maximum,rec[j])\\n        return maximum*maximum\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maximalSquare(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        if not matrix:\\n            return 0\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        maximum = 0\\n        tableL = [[0]*n for _ in range(m)]\\n        tableU = [[0]*n for _ in range(m)]\\n        tableD = [[0]*n for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j] == \"0\":\\n                    tableL[i][j] = 0\\n                    tableU[i][j] = 0\\n                    tableD[i][j] = 0\\n                else:\\n                    if i == 0 and j == 0:\\n                        tableL[i][j] = 1\\n                        tableU[i][j] = 1\\n                        tableD[i][j] = 1\\n                    elif i == 0:\\n                        tableL[i][j] = tableL[i][j-1]+1\\n                        tableU[i][j] = 1\\n                        tableD[i][j] = 1\\n                    elif j == 0:\\n                        tableL[i][j] = 1\\n                        tableU[i][j] = tableU[i-1][j]+1\\n                        tableD[i][j] = 1\\n                    else:\\n                        tableL[i][j] = tableL[i][j-1]+1\\n                        tableU[i][j] = tableU[i-1][j]+1\\n                        tableD[i][j] = min(tableL[i][j],tableU[i][j],tableD[i-1][j-1]+1)\\n                candidate = tableD[i][j]\\n                if candidate > maximum:\\n                    maximum = candidate\\n        return maximum * maximum\\n```\n```\\nclass Solution(object):\\n    def maximalSquare(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        if not matrix:\\n            return 0\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        maximum = 0\\n        table = [[0]*n for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j] == \"0\":\\n                    table[i][j] = 0\\n                else:\\n                    if i == 0 or j == 0:\\n                        table[i][j] = 1\\n                    else:\\n                        table[i][j] = min(table[i-1][j],table[i][j-1],table[i-1][j-1])+1\\n                if table[i][j] > maximum:\\n                    maximum = table[i][j]\\n        return maximum * maximum\\n```\n```\\nclass Solution(object):\\n    def maximalSquare(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        if not matrix:\\n            return 0\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        rec = [0]*n\\n        maximum = 0\\n        prev = 0\\n        for i in range(m):\\n            for j in range(n):\\n                temp = rec[j]\\n                if matrix[i][j] == \"1\":\\n                    if j > 0:\\n                        rec[j] = min(rec[j-1],rec[j],prev)+1\\n                    else:\\n                        rec[j] = 1\\n                else:\\n                    rec[j] = 0\\n                prev = temp\\n                maximum = max(maximum,rec[j])\\n        return maximum*maximum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61851,
                "title": "missing-test-case",
                "content": "[\"00000\",\"10000\",\"00000\",\"00000\"]\\n\\nOnly '1' existed in column 0\\n\\nThe code below will AC but missing the test case above\\n```\\nclass Solution(object):\\n    def maximalSquare(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        if not matrix: return 0\\n        dp = [[0 for j in xrange(len(matrix[0]))] for i in xrange(len(matrix))]\\n        max_value = 0\\n        for j in xrange(len(matrix[0])):\\n            dp[0][j] = int(matrix[0][j])\\n            max_value = max(dp[0][j], max_value)\\n        for i in xrange(1, len(matrix)):\\n            dp[i][0] = int(matrix[i][0])\\n            for j in xrange(1, len(matrix[0])):\\n                if matrix[i][j] == '1':\\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\\n                    max_value = max(dp[i][j], max_value)\\n                \\n        return max_value * max_value\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maximalSquare(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        if not matrix: return 0\\n        dp = [[0 for j in xrange(len(matrix[0]))] for i in xrange(len(matrix))]\\n        max_value = 0\\n        for j in xrange(len(matrix[0])):\\n            dp[0][j] = int(matrix[0][j])\\n            max_value = max(dp[0][j], max_value)\\n        for i in xrange(1, len(matrix)):\\n            dp[i][0] = int(matrix[i][0])\\n            for j in xrange(1, len(matrix[0])):\\n                if matrix[i][j] == '1':\\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\\n                    max_value = max(dp[i][j], max_value)\\n                \\n        return max_value * max_value\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61878,
                "title": "my-ac-java-solution-with-o-1-space-made-some-changes-to-original-matrix",
                "content": "    public int maximalSquare(char[][] matrix) {\\n        if(matrix == null || matrix.length == 0 || matrix[0].length == 0){\\n            return 0;\\n        }\\n        int result = matrix[0][0] - '0';\\n        for(int row = 0; row < matrix.length; row++){\\n            for(int col = 0; col < matrix[0].length; col++){\\n                if(row == 0 || col == 0){\\n                    if(matrix[row][col] == '1' && result == 0){\\n                        result = 1;\\n                    }\\n                } else if(matrix[row][col] == '1'){\\n                    int cur = Math.min(Math.min(matrix[row - 1][col - 1], matrix[row][col - 1]), matrix[row - 1][col]) -'0' + 1;\\n                    matrix[row][col] = (char)(cur + '0');\\n                    if(cur > result){\\n                        result = cur;\\n                    }\\n                }\\n            }\\n        }\\n        return result*result;\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "    public int maximalSquare(char[][] matrix) {\\n        if(matrix == null || matrix.length == 0 || matrix[0].length == 0){\\n            return 0;\\n        }\\n        int result = matrix[0][0] - '0';\\n        for(int row = 0; row < matrix.length; row++){\\n            for(int col = 0; col < matrix[0].length; col++){\\n                if(row == 0 || col == 0){\\n                    if(matrix[row][col] == '1' && result == 0){\\n                        result = 1;\\n                    }\\n                } else if(matrix[row][col] == '1'){\\n                    int cur = Math.min(Math.min(matrix[row - 1][col - 1], matrix[row][col - 1]), matrix[row - 1][col]) -'0' + 1;\\n                    matrix[row][col] = (char)(cur + '0');\\n                    if(cur > result){\\n                        result = cur;\\n                    }\\n                }\\n            }\\n        }\\n        return result*result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3524892,
                "title": "4-solutions-explained-recursion-dp-space-optimisation",
                "content": "we are finding maximum square \\'1\\' among the matrix .\\nso start from 1st elemet and check for all sides .\\nchoose the minimum side for becoming a square then after finding all square take maximum\\ne.g--\\nwhy minimum\\n1 1 1\\n1 1 1 1\\n0 1 1 1 \\n0 1 1 1 \\nleft -- 2 one \\ndown --  one \\ndiagonal--3 one\\nso choose minimum for becoming square .i.e 2 size sqaure\\n\\n//recursion\\n````\\nclass Solution{\\npublic:\\n    int solve(vector<vector<int>>& mat,int i,int j,int &maxi){\\n        if(i >= mat.size() || j >= mat[0].size()){\\n            return 0;\\n        }\\n   //Find \\'1\\' all side \\n        int right=solve(mat,i,j+1,maxi);\\n        int diagonal=solve(mat,i+1,j+1,maxi);\\n        int down=solve(mat,i+1,j,maxi);\\n  //if current element is 1 then\\n        if(mat[i][j] == \\'1\\'){\\n   //minimum of all side bcoz we have to create sqaure so we are taking upto zero in any of side\\n            int ans=1+min(right,min(diagonal,down));\\n    //Then out all all squares our ans is maximum\\n            maxi=max(ans,maxi);\\n            return ans;\\n        }\\n    // if 1st element itself is not \\'1\\'\\n        else return 0;\\n    }\\n    int maxSquare(int n, int m, vector<vector<int>> mat){\\n        // code here\\n        int maxi=0;\\n        solve(mat,0,0,maxi);\\n        return maxi*maxi;\\n    }\\n};\\n```\\n//tabulation\\n```\\nlass Solution{\\npublic:\\n    int solve(vector<vector<int>>& mat,int &maxi){\\n        int row=mat.size();\\n        int col=mat[0].size();\\n        vector<vector<int>>dp(row+1,vector<int>(col+1,0));\\n        \\n        for(int i=row-1; i >= 0;i--){\\n            for(int j=col-1;j >= 0;j--){\\n                int right=dp[i][j+1];\\n                int diagonal=dp[i+1][j+1];\\n                int down=dp[i+1][j];\\n                \\n                if(mat[i][j] == \\'1\\'){\\n                    dp[i][j]=1+min(right,min(diagonal,down));\\n                    maxi=max(dp[i][j],maxi);\\n                }\\n                else dp[i][j]=0;\\n            }\\n        }\\n        \\n        return dp[0][0];\\n    }\\n    int maxSquare(int n, int m, vector<vector<int>> mat){\\n        // code here\\n        int maxi=0;\\n        solve(mat,maxi);\\n        return maxi*maxi;\\n    }\\n};\\n```\\n//Memozation\\n```\\nclass Solution{\\npublic:\\n    int solve(vector<vector<int>>& mat,int i,int j,int &maxi,vector<vector<int>>&dp){\\n        if(i >= mat.size() || j >= mat[0].size()){\\n            return 0;\\n        }\\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        int right=solve(mat,i,j+1,maxi,dp);\\n        int diagonal=solve(mat,i+1,j+1,maxi,dp);\\n        int down=solve(mat,i+1,j,maxi,dp);\\n\\n        if(mat[i][j] == \\'1\\'){\\n            dp[i][j]=1+min(right,min(diagonal,down));\\n            maxi=max(dp[i][j],maxi);\\n            \\n            return dp[i][j];\\n        }\\n        else return dp[i][j]=0;\\n    }\\n    int maxSquare(int n, int m, vector<vector<int>> mat){\\n        // code here\\n        int maxi=0;\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        solve(mat,0,0,maxi,dp);\\n        return maxi*maxi;\\n    }\\n};\\n```\\n\\n//space optimisation\\ntake two vector cur and next .\\nand just change the cur with dp[i]\\nand next with dp[i+1)\\nin tabulation code \\nrest all same\\n```\\nint solve(vector<vector<char>>& matrix, int &maxi){\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n\\n        vector<int>curr(m + 1, 0);\\n        vector<int>next(m + 1 , 0);\\n\\n        for(int i= n - 1;i >= 0;i--){\\n            for(int j = m - 1; j >= 0; j--){\\n                int diagonal = next[j + 1];\\n                int right = curr[j + 1];\\n                int down = next[j];\\n\\n                if(matrix[i][j] == \\'1\\'){\\n                    curr[j] = 1 + min(right, min(diagonal, down));\\n                    maxi = max(maxi, curr[j]);\\n                    \\n                }\\n                else{\\n                    curr[j] = 0;\\n                }\\n            }\\n            next = curr;\\n        }  \\n        return curr[0];  \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "````\\nclass Solution{\\npublic:\\n    int solve(vector<vector<int>>& mat,int i,int j,int &maxi){\\n        if(i >= mat.size() || j >= mat[0].size()){\\n            return 0;\\n        }\\n   //Find \\'1\\' all side \\n        int right=solve(mat,i,j+1,maxi);\\n        int diagonal=solve(mat,i+1,j+1,maxi);\\n        int down=solve(mat,i+1,j,maxi);\\n  //if current element is 1 then\\n        if(mat[i][j] == \\'1\\'){\\n   //minimum of all side bcoz we have to create sqaure so we are taking upto zero in any of side\\n            int ans=1+min(right,min(diagonal,down));\\n    //Then out all all squares our ans is maximum\\n            maxi=max(ans,maxi);\\n            return ans;\\n        }\\n    // if 1st element itself is not \\'1\\'\\n        else return 0;\\n    }\\n    int maxSquare(int n, int m, vector<vector<int>> mat){\\n        // code here\\n        int maxi=0;\\n        solve(mat,0,0,maxi);\\n        return maxi*maxi;\\n    }\\n};\\n```\n```\\nlass Solution{\\npublic:\\n    int solve(vector<vector<int>>& mat,int &maxi){\\n        int row=mat.size();\\n        int col=mat[0].size();\\n        vector<vector<int>>dp(row+1,vector<int>(col+1,0));\\n        \\n        for(int i=row-1; i >= 0;i--){\\n            for(int j=col-1;j >= 0;j--){\\n                int right=dp[i][j+1];\\n                int diagonal=dp[i+1][j+1];\\n                int down=dp[i+1][j];\\n                \\n                if(mat[i][j] == \\'1\\'){\\n                    dp[i][j]=1+min(right,min(diagonal,down));\\n                    maxi=max(dp[i][j],maxi);\\n                }\\n                else dp[i][j]=0;\\n            }\\n        }\\n        \\n        return dp[0][0];\\n    }\\n    int maxSquare(int n, int m, vector<vector<int>> mat){\\n        // code here\\n        int maxi=0;\\n        solve(mat,maxi);\\n        return maxi*maxi;\\n    }\\n};\\n```\n```\\nclass Solution{\\npublic:\\n    int solve(vector<vector<int>>& mat,int i,int j,int &maxi,vector<vector<int>>&dp){\\n        if(i >= mat.size() || j >= mat[0].size()){\\n            return 0;\\n        }\\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        int right=solve(mat,i,j+1,maxi,dp);\\n        int diagonal=solve(mat,i+1,j+1,maxi,dp);\\n        int down=solve(mat,i+1,j,maxi,dp);\\n\\n        if(mat[i][j] == \\'1\\'){\\n            dp[i][j]=1+min(right,min(diagonal,down));\\n            maxi=max(dp[i][j],maxi);\\n            \\n            return dp[i][j];\\n        }\\n        else return dp[i][j]=0;\\n    }\\n    int maxSquare(int n, int m, vector<vector<int>> mat){\\n        // code here\\n        int maxi=0;\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        solve(mat,0,0,maxi,dp);\\n        return maxi*maxi;\\n    }\\n};\\n```\n```\\nint solve(vector<vector<char>>& matrix, int &maxi){\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n\\n        vector<int>curr(m + 1, 0);\\n        vector<int>next(m + 1 , 0);\\n\\n        for(int i= n - 1;i >= 0;i--){\\n            for(int j = m - 1; j >= 0; j--){\\n                int diagonal = next[j + 1];\\n                int right = curr[j + 1];\\n                int down = next[j];\\n\\n                if(matrix[i][j] == \\'1\\'){\\n                    curr[j] = 1 + min(right, min(diagonal, down));\\n                    maxi = max(maxi, curr[j]);\\n                    \\n                }\\n                else{\\n                    curr[j] = 0;\\n                }\\n            }\\n            next = curr;\\n        }  \\n        return curr[0];  \\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475701,
                "title": "java-solution-for-maximal-square-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given solution aims to find the size of the largest square in a given binary matrix where the matrix contains only 0\\'s and 1\\'s.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in the given solution is dynamic programming. The solution uses a two-dimensional array t of the same size as the input matrix, where t[i][j] represents the size of the largest square ending at position (i,j) in the input matrix. The first row and first column of the t matrix are initialized with the corresponding values of the input matrix. For each cell in the input matrix, if the cell value is 1, the value of t[i][j] is calculated as the minimum of t[i-1][j], t[i-1][j-1], and t[i][j-1], and then adding 1 to it. If the cell value is 0, then the corresponding value in the t matrix is 0. Finally, the largest value in the t matrix is returned multiplied by itself to get the area of the largest square\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m*n), where m and n are the number of rows and columns in the input matrix. This is because the solution uses three nested loops, each iterating over the input matrix, to fill the t matrix.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m*n), where m and n are the number of rows and columns in the input matrix. This is because the solution uses a two-dimensional array t of the same size as the input matrix to store intermediate results.\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximalSquare(char[][] matrix) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0)\\n            return 0;\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int[][] t = new int[m][n];\\n        //top row\\n        for (int i = 0; i < m; i++) \\n        {\\n            t[i][0] = Character.getNumericValue(matrix[i][0]);\\n        }\\n        //left column\\n        for (int j = 0; j < n; j++) \\n        {\\n            t[0][j] = Character.getNumericValue(matrix[0][j]);\\n        }\\n        //cells inside\\n        for (int i = 1; i < m; i++) \\n        {\\n            for (int j = 1; j < n; j++) \\n            {\\n                if (matrix[i][j] == \\'1\\') \\n                {\\n                    int min = Math.min(t[i - 1][j], t[i - 1][j - 1]);\\n                    min = Math.min(min,t[i][j - 1]);\\n                    t[i][j] = min + 1;\\n                } \\n                else \\n                {\\n                    t[i][j] = 0;\\n                }\\n            }\\n        }\\n        int max = 0;\\n        //get maximal length\\n        for (int i = 0; i < m; i++) \\n        {\\n            for (int j = 0; j < n; j++) \\n            {\\n                if (t[i][j] > max) \\n                {\\n                    max = t[i][j];\\n                }\\n            }\\n        }\\n        return max * max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximalSquare(char[][] matrix) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0)\\n            return 0;\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int[][] t = new int[m][n];\\n        //top row\\n        for (int i = 0; i < m; i++) \\n        {\\n            t[i][0] = Character.getNumericValue(matrix[i][0]);\\n        }\\n        //left column\\n        for (int j = 0; j < n; j++) \\n        {\\n            t[0][j] = Character.getNumericValue(matrix[0][j]);\\n        }\\n        //cells inside\\n        for (int i = 1; i < m; i++) \\n        {\\n            for (int j = 1; j < n; j++) \\n            {\\n                if (matrix[i][j] == \\'1\\') \\n                {\\n                    int min = Math.min(t[i - 1][j], t[i - 1][j - 1]);\\n                    min = Math.min(min,t[i][j - 1]);\\n                    t[i][j] = min + 1;\\n                } \\n                else \\n                {\\n                    t[i][j] = 0;\\n                }\\n            }\\n        }\\n        int max = 0;\\n        //get maximal length\\n        for (int i = 0; i < m; i++) \\n        {\\n            for (int j = 0; j < n; j++) \\n            {\\n                if (t[i][j] > max) \\n                {\\n                    max = t[i][j];\\n                }\\n            }\\n        }\\n        return max * max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3172929,
                "title": "two-approaches-binary-search-prefix-sum-and-dynamic-programming",
                "content": "```\\nclass Solution {\\npublic:\\n    // check function for binary search\\n    // bool check(int mid,vector<vector<int>>&matrix1)\\n    // {\\n    //     int n=matrix1.size(),m=matrix1[0].size();\\n    //     int ans=mid*mid;\\n    //     if(mid==0)return true;\\n    //     for(int i=mid-1;i<n;i++)\\n    //     {\\n    //         for(int j=mid-1;j<m;j++)\\n    //         {\\n    //             int cal=0;\\n    //             if(i==mid-1 or j==mid-1)\\n    //             {\\n    //                 cal+=matrix1[i][j]+((i-mid>=0 and j-mid>=0)?matrix1[i-mid][j-mid]:0)-((i-mid>=0)?matrix1[i-mid][j]:0)-((j-mid>=0)?matrix1[i][j-mid]:0);\\n    //             }\\n    //             else\\n    //             {\\n    //                 cal+=matrix1[i][j]+matrix1[i-mid][j-mid]-matrix1[i-mid][j]-matrix1[i][j-mid];     \\n    //             }\\n    //             if(cal==ans)\\n    //             {\\n    //                 return true;\\n    //             }\\n    //         }\\n    //     }return false;\\n    // }\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        // binary search approach with calculating prefix sums \\n        // vector<vector<int>>matrix1(n,vector<int>(m));\\n        // for(int i=0;i<n;i++)\\n        // {\\n        //     for(int j=0;j<m;j++)\\n        //     {\\n        //         matrix1[i][j]=matrix[i][j]-\\'0\\';\\n        //         if(i==0 or j==0)\\n        //         {\\n        //             matrix1[i][j]+=i>0?matrix1[i-1][j]:0;\\n        //             matrix1[i][j]+=j>0?matrix1[i][j-1]:0;\\n        //         }\\n        //         else\\n        //         {\\n        //             matrix1[i][j]+=matrix1[i-1][j]+matrix1[i][j-1]-matrix1[i-1][j-1];\\n        //         }\\n        //     }\\n        // }\\n        // int s=0,e=min(m,n);\\n        // int ans=0;\\n        // while(s<=e)\\n        // {\\n        //     int mid=(s+e)/2;\\n        //     if(check(mid,matrix1))\\n        //     {\\n        //         ans=mid*mid;\\n        //         s=mid+1;\\n        //     }\\n        //     else\\n        //     {\\n        //         e=mid-1;\\n        //     } \\n        // }\\n        // return ans;\\n        \\n        \\n        // dynamic programming approach\\n        vector<vector<int>>dp(n,vector<int>(m,0));\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(!j or !i or matrix[i][j]==\\'0\\')\\n                {\\n                    dp[i][j]=matrix[i][j]-\\'0\\';\\n                }\\n                else\\n                    dp[i][j]=min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1]))+1;\\n                ans=max(ans,dp[i][j]);\\n            }\\n        }return ans*ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // check function for binary search\\n    // bool check(int mid,vector<vector<int>>&matrix1)\\n    // {\\n    //     int n=matrix1.size(),m=matrix1[0].size();\\n    //     int ans=mid*mid;\\n    //     if(mid==0)return true;\\n    //     for(int i=mid-1;i<n;i++)\\n    //     {\\n    //         for(int j=mid-1;j<m;j++)\\n    //         {\\n    //             int cal=0;\\n    //             if(i==mid-1 or j==mid-1)\\n    //             {\\n    //                 cal+=matrix1[i][j]+((i-mid>=0 and j-mid>=0)?matrix1[i-mid][j-mid]:0)-((i-mid>=0)?matrix1[i-mid][j]:0)-((j-mid>=0)?matrix1[i][j-mid]:0);\\n    //             }\\n    //             else\\n    //             {\\n    //                 cal+=matrix1[i][j]+matrix1[i-mid][j-mid]-matrix1[i-mid][j]-matrix1[i][j-mid];     \\n    //             }\\n    //             if(cal==ans)\\n    //             {\\n    //                 return true;\\n    //             }\\n    //         }\\n    //     }return false;\\n    // }\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        // binary search approach with calculating prefix sums \\n        // vector<vector<int>>matrix1(n,vector<int>(m));\\n        // for(int i=0;i<n;i++)\\n        // {\\n        //     for(int j=0;j<m;j++)\\n        //     {\\n        //         matrix1[i][j]=matrix[i][j]-\\'0\\';\\n        //         if(i==0 or j==0)\\n        //         {\\n        //             matrix1[i][j]+=i>0?matrix1[i-1][j]:0;\\n        //             matrix1[i][j]+=j>0?matrix1[i][j-1]:0;\\n        //         }\\n        //         else\\n        //         {\\n        //             matrix1[i][j]+=matrix1[i-1][j]+matrix1[i][j-1]-matrix1[i-1][j-1];\\n        //         }\\n        //     }\\n        // }\\n        // int s=0,e=min(m,n);\\n        // int ans=0;\\n        // while(s<=e)\\n        // {\\n        //     int mid=(s+e)/2;\\n        //     if(check(mid,matrix1))\\n        //     {\\n        //         ans=mid*mid;\\n        //         s=mid+1;\\n        //     }\\n        //     else\\n        //     {\\n        //         e=mid-1;\\n        //     } \\n        // }\\n        // return ans;\\n        \\n        \\n        // dynamic programming approach\\n        vector<vector<int>>dp(n,vector<int>(m,0));\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(!j or !i or matrix[i][j]==\\'0\\')\\n                {\\n                    dp[i][j]=matrix[i][j]-\\'0\\';\\n                }\\n                else\\n                    dp[i][j]=min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1]))+1;\\n                ans=max(ans,dp[i][j]);\\n            }\\n        }return ans*ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3166551,
                "title": "java-solution-3-ms-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maximalSquare(char[][] matrix) {\\n        if(matrix.length==0 || matrix[0].length==0)\\n            return 0;\\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n        int[][] dp=new int [n+1][m+1];\\n        for(int i=0;i<=n;i++)\\n            for(int j=0;j<=m;j++)\\n                dp[i][j]=0;\\n        int maxsize=0;\\n        for(int i=1;i<=n;i++)\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(matrix[i-1][j-1]==\\'1\\')\\n                {\\n                    dp[i][j]=Math.min( dp[i-1][j], Math.min ( dp[i-1][j-1], dp[i][j-1] )) + 1 ;\\n                        maxsize=Math.max(maxsize,dp[i][j]);\\n                }\\n            }\\n        return maxsize*maxsize;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int maximalSquare(char[][] matrix) {\\n        if(matrix.length==0 || matrix[0].length==0)\\n            return 0;\\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n        int[][] dp=new int [n+1][m+1];\\n        for(int i=0;i<=n;i++)\\n            for(int j=0;j<=m;j++)\\n                dp[i][j]=0;\\n        int maxsize=0;\\n        for(int i=1;i<=n;i++)\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(matrix[i-1][j-1]==\\'1\\')\\n                {\\n                    dp[i][j]=Math.min( dp[i-1][j], Math.min ( dp[i-1][j-1], dp[i][j-1] )) + 1 ;\\n                        maxsize=Math.max(maxsize,dp[i][j]);\\n                }\\n            }\\n        return maxsize*maxsize;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3123177,
                "title": "c-dynamic-programming",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,0));\\n        int maxi=0;\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                if (matrix[i-1][j-1] == \\'1\\'){\\n                    dp[i][j] = min(min(dp[i][j - 1], dp[i - 1][j]), dp[i - 1][j - 1]) + 1;\\n                    maxi = max(maxi, dp[i][j]);\\n                }\\n            }\\n        }\\n        return maxi*maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,0));\\n        int maxi=0;\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                if (matrix[i-1][j-1] == \\'1\\'){\\n                    dp[i][j] = min(min(dp[i][j - 1], dp[i - 1][j]), dp[i - 1][j - 1]) + 1;\\n                    maxi = max(maxi, dp[i][j]);\\n                }\\n            }\\n        }\\n        return maxi*maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017544,
                "title": "2-solutions-dp-and-dfs-simple-organized-code",
                "content": "# Complexity\\n- Time complexity: O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(M*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# DP solution\\n```\\nclass Solution {\\n    private int rows, cols;\\n\\n    public int maximalSquare(char[][] matrix) {\\n        int res =0;\\n        rows = matrix.length;\\n        cols = matrix[0].length;\\n\\n        for(int i=1;i<=rows;i++)\\n            for(int j=1;j<=cols;j++){\\n                if(matrix[i-1][j-1] == \\'1\\'){\\n                    int upAndDownMin = Math.min(dp[i-1][j], dp[i][j-1]);\\n                    dp[i][j] = 1 + Math.min(upAndDownMin, dp[i-1][j-1]); \\n                    res = Math.max(res, dp[i][j]);\\n                }\\n                else \\n                    dp[i][j] = 0;\\n            }\\n        return res*res;\\n    }\\n}\\n```\\n  --------------------------------------------\\n# Complexity\\n- Time complexity: O(N^2*M^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# DFS solution\\n```\\nclass Solution {\\n    private int rows, cols;\\n\\n    public int maximalSquare(char[][] matrix) {\\n        int res =0;\\n        rows = matrix.length;\\n        cols = matrix[0].length;\\n\\n        for(int i=0;i<rows;i++)\\n            for(int j=0;j<cols;j++){\\n                if(matrix[i][j] == \\'1\\'){\\n                    int mx = maximalSquareHelper(i, j, matrix);\\n                    res = Math.max(res,mx);\\n                }\\n            }\\n        return res*res;\\n    }\\n    private int maximalSquareHelper(int x, int y, char[][] matrix){\\n        int diagonal = 1;     \\n        int tempx = x+1, tempy = y+1;\\n        while(tempx < rows && tempy< cols && matrix[tempx][tempy] == \\'1\\'){ // diagonal\\n            if(!isValid(x,y,tempx, tempy, matrix))  break;        \\n            diagonal++;\\n            tempx++; tempy++;\\n        }\\n        \\n        return diagonal;\\n    }\\n\\n    private boolean isValid(int x, int y, int x2, int y2, char[][] matrix){\\n        for(int i=x; i<=x2; i++)\\n            if(matrix[i][y2] != \\'1\\') return false;    \\n        \\n         for(int i=y; i<=y2; i++)\\n            if(matrix[x2][i] != \\'1\\') return false; \\n        \\n        return true;\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    private int rows, cols;\\n\\n    public int maximalSquare(char[][] matrix) {\\n        int res =0;\\n        rows = matrix.length;\\n        cols = matrix[0].length;\\n\\n        for(int i=1;i<=rows;i++)\\n            for(int j=1;j<=cols;j++){\\n                if(matrix[i-1][j-1] == \\'1\\'){\\n                    int upAndDownMin = Math.min(dp[i-1][j], dp[i][j-1]);\\n                    dp[i][j] = 1 + Math.min(upAndDownMin, dp[i-1][j-1]); \\n                    res = Math.max(res, dp[i][j]);\\n                }\\n                else \\n                    dp[i][j] = 0;\\n            }\\n        return res*res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private int rows, cols;\\n\\n    public int maximalSquare(char[][] matrix) {\\n        int res =0;\\n        rows = matrix.length;\\n        cols = matrix[0].length;\\n\\n        for(int i=0;i<rows;i++)\\n            for(int j=0;j<cols;j++){\\n                if(matrix[i][j] == \\'1\\'){\\n                    int mx = maximalSquareHelper(i, j, matrix);\\n                    res = Math.max(res,mx);\\n                }\\n            }\\n        return res*res;\\n    }\\n    private int maximalSquareHelper(int x, int y, char[][] matrix){\\n        int diagonal = 1;     \\n        int tempx = x+1, tempy = y+1;\\n        while(tempx < rows && tempy< cols && matrix[tempx][tempy] == \\'1\\'){ // diagonal\\n            if(!isValid(x,y,tempx, tempy, matrix))  break;        \\n            diagonal++;\\n            tempx++; tempy++;\\n        }\\n        \\n        return diagonal;\\n    }\\n\\n    private boolean isValid(int x, int y, int x2, int y2, char[][] matrix){\\n        for(int i=x; i<=x2; i++)\\n            if(matrix[i][y2] != \\'1\\') return false;    \\n        \\n         for(int i=y; i<=y2; i++)\\n            if(matrix[x2][i] != \\'1\\') return false; \\n        \\n        return true;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2804714,
                "title": "dynamic-programming-solution-python",
                "content": "Hi, we convert this problem into finding the length of the largest square.\\n\\nWe start by creating a top-down solution.\\n```\\n        def solve(i, j):\\n            if i < 0 or j < 0:\\n                return 0\\n            if matrix[i][j] == \"0\":\\n                memo[(i, j)] = 0\\n            else:\\n                memo[(i, j)] =  1 + min(solve(i - 1, j), solve(i, j - 1), solve(i - 1, j - 1))\\n            return memo[(i, j)]\\n        \\n    \\n        memo = {}\\n        ans = 0\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                ans = max(ans, solve(i, j))\\n                \\n        return ans ** 2\\n```\\nThis solution, however, does not pass (TLE).\\n\\nWe convert to an equivalent bottom up solution.\\n\\n```\\ndp = [[0] * len(matrix[0]) for _ in range(len(matrix))]\\n        \\n        for i in range(len(matrix)):\\n            dp[i][0] = 1 if matrix[i][0] == \"1\" else 0\\n        \\n        for j in range(len(matrix[0])):\\n            dp[0][j] = 1 if matrix[0][j] == \"1\" else 0\\n            \\n        for i in range(1, len(dp)):\\n            for j in range(1, len(dp[0])):\\n                if matrix[i][j] == \"1\":\\n                    dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\\n                else:\\n                    dp[i][j] = 0\\n        \\n        ans = 0\\n        for i in range(len(dp)):\\n            for j in range(len(dp[0])):\\n                ans = max(ans, dp[i][j])\\n        return ans ** 2\\n```\\n\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n        def solve(i, j):\\n            if i < 0 or j < 0:\\n                return 0\\n            if matrix[i][j] == \"0\":\\n                memo[(i, j)] = 0\\n            else:\\n                memo[(i, j)] =  1 + min(solve(i - 1, j), solve(i, j - 1), solve(i - 1, j - 1))\\n            return memo[(i, j)]\\n        \\n    \\n        memo = {}\\n        ans = 0\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                ans = max(ans, solve(i, j))\\n                \\n        return ans ** 2\\n```\n```\\ndp = [[0] * len(matrix[0]) for _ in range(len(matrix))]\\n        \\n        for i in range(len(matrix)):\\n            dp[i][0] = 1 if matrix[i][0] == \"1\" else 0\\n        \\n        for j in range(len(matrix[0])):\\n            dp[0][j] = 1 if matrix[0][j] == \"1\" else 0\\n            \\n        for i in range(1, len(dp)):\\n            for j in range(1, len(dp[0])):\\n                if matrix[i][j] == \"1\":\\n                    dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\\n                else:\\n                    dp[i][j] = 0\\n        \\n        ans = 0\\n        for i in range(len(dp)):\\n            for j in range(len(dp[0])):\\n                ans = max(ans, dp[i][j])\\n        return ans ** 2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2492377,
                "title": "python-dp",
                "content": "```\\nclass Solution(object):\\n    def maximalSquare(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        m,n = len(matrix), len(matrix[0])\\n        #dp = [[0]*(n+1)]*(m+1)  # not working\\n        dp = [[0]*(n+1) for _ in range(m+1)] # working\\n        if matrix is None or len(matrix) < 1:\\n            return 0\\n        l = 0    \\n        for i in range(1,m+1):\\n            for j in range(1,n+1):\\n                if matrix[i-1][j-1] == \"1\":\\n                    dp[i][j] = min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1]) + 1\\n                    l = max(l,dp[i][j])\\n        return l*l\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maximalSquare(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        m,n = len(matrix), len(matrix[0])\\n        #dp = [[0]*(n+1)]*(m+1)  # not working\\n        dp = [[0]*(n+1) for _ in range(m+1)] # working\\n        if matrix is None or len(matrix) < 1:\\n            return 0\\n        l = 0    \\n        for i in range(1,m+1):\\n            for j in range(1,n+1):\\n                if matrix[i-1][j-1] == \"1\":\\n                    dp[i][j] = min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1]) + 1\\n                    l = max(l,dp[i][j])\\n        return l*l\\n",
                "codeTag": "Java"
            },
            {
                "id": 2403479,
                "title": "c-two-approaches-recursion-memoization-tabulation-method",
                "content": "```\\nclass Solution {\\n    \\n    \\nint SolveByMemoization(vector<vector<char>> &matrix, int m, int n, int i, int j, int &maxi, vector<vector<int>> &dp)\\n{\\n    if (i == m || j == n)\\n        return 0;\\n\\n    if (dp[i][j] != -1)\\n        return dp[i][j];\\n\\n    int diagonal = SolveByMemoization(matrix, m, n, i + 1, j + 1, maxi, dp);\\n    int right = SolveByMemoization(matrix, m, n, i, j + 1, maxi, dp);\\n    int down = SolveByMemoization(matrix, m, n, i + 1, j, maxi, dp);\\n\\n    if (matrix[i][j] == \\'1\\')\\n    {\\n\\n        int ans = 1 + min(diagonal, min(right, down));\\n\\n        maxi = max(maxi, ans);\\n        return dp[i][j] = ans;\\n    }\\n\\n    return dp[i][j] = 0;\\n}\\n    \\nvoid SolveByTabulation(vector<vector<char>> &matrix, int m, int n, int &maxi)\\n{\\n    vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\\n\\n   \\n    for (int i = m - 1; i >= 0; i--)\\n    {\\n        for (int j = n - 1; j >= 0; j--)\\n        {\\n            if (matrix[i][j] == \\'0\\')\\n                dp[i][j] = 0;\\n            else\\n            {\\n                dp[i][j] = 1 + min(dp[i + 1][j + 1], min(dp[i + 1][j], dp[i][j + 1]));\\n                maxi = max(dp[i][j], maxi);\\n            }\\n        }\\n    }\\n\\n}\\n\\n    \\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        \\n        int maxi = 0;\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        \\n        // Memoization\\n          \\n        // vector<vector<int>> dp(m, vector<int>(n, -1));\\n        // int temp = SolveByMemoization(matrix, m, n, 0, 0, maxi, dp);\\n        \\n        //Tabulation\\n          SolveByTabulation(matrix, m, n, maxi);\\n        \\n        return maxi*maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    \\n    \\nint SolveByMemoization(vector<vector<char>> &matrix, int m, int n, int i, int j, int &maxi, vector<vector<int>> &dp)\\n{\\n    if (i == m || j == n)\\n        return 0;\\n\\n    if (dp[i][j] != -1)\\n        return dp[i][j];\\n\\n    int diagonal = SolveByMemoization(matrix, m, n, i + 1, j + 1, maxi, dp);\\n    int right = SolveByMemoization(matrix, m, n, i, j + 1, maxi, dp);\\n    int down = SolveByMemoization(matrix, m, n, i + 1, j, maxi, dp);\\n\\n    if (matrix[i][j] == \\'1\\')\\n    {\\n\\n        int ans = 1 + min(diagonal, min(right, down));\\n\\n        maxi = max(maxi, ans);\\n        return dp[i][j] = ans;\\n    }\\n\\n    return dp[i][j] = 0;\\n}\\n    \\nvoid SolveByTabulation(vector<vector<char>> &matrix, int m, int n, int &maxi)\\n{\\n    vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\\n\\n   \\n    for (int i = m - 1; i >= 0; i--)\\n    {\\n        for (int j = n - 1; j >= 0; j--)\\n        {\\n            if (matrix[i][j] == \\'0\\')\\n                dp[i][j] = 0;\\n            else\\n            {\\n                dp[i][j] = 1 + min(dp[i + 1][j + 1], min(dp[i + 1][j], dp[i][j + 1]));\\n                maxi = max(dp[i][j], maxi);\\n            }\\n        }\\n    }\\n\\n}\\n\\n    \\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        \\n        int maxi = 0;\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        \\n        // Memoization\\n          \\n        // vector<vector<int>> dp(m, vector<int>(n, -1));\\n        // int temp = SolveByMemoization(matrix, m, n, 0, 0, maxi, dp);\\n        \\n        //Tabulation\\n          SolveByTabulation(matrix, m, n, maxi);\\n        \\n        return maxi*maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2338221,
                "title": "c-dp-memoization-easy-readable-bottom-up",
                "content": "```\\nclass Solution {\\npublic:\\n    int sol(vector<vector<char>>& matrix, int i, int j, int &ans, vector<vector<int>> &dp){\\n        if(i>=matrix.size() || j>= matrix[0].size()){\\n            return 0;\\n        }\\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        \\n        int right=      sol(matrix, i, j+1, ans, dp);\\n        int digonal=    sol(matrix, i+1, j+1, ans, dp);\\n        int down=       sol(matrix, i+1, j, ans, dp);\\n        if(matrix[i][j]==\\'1\\'){\\n            dp[i][j]= 1+ min(right, min(digonal, down));\\n            ans= max(ans, dp[i][j]);\\n            return dp[i][j];\\n        }else{\\n            return dp[i][j] = 0;\\n        }\\n    }\\n    \\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        vector<vector<int>> dp(matrix.size()+1, vector<int>(matrix[0].size()+1, -1));\\n        int ans=0;\\n       sol(matrix, 0, 0, ans, dp);\\n        return ans*ans;\\n    }\\n};\\n```\\nElements in the double ciecle are memoized in DP array.\\n![image](https://assets.leetcode.com/users/images/76d4b893-f4e7-4bd5-8dfb-734dd5b64692_1658865965.0762148.png)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int sol(vector<vector<char>>& matrix, int i, int j, int &ans, vector<vector<int>> &dp){\\n        if(i>=matrix.size() || j>= matrix[0].size()){\\n            return 0;\\n        }\\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        \\n        int right=      sol(matrix, i, j+1, ans, dp);\\n        int digonal=    sol(matrix, i+1, j+1, ans, dp);\\n        int down=       sol(matrix, i+1, j, ans, dp);\\n        if(matrix[i][j]==\\'1\\'){\\n            dp[i][j]= 1+ min(right, min(digonal, down));\\n            ans= max(ans, dp[i][j]);\\n            return dp[i][j];\\n        }else{\\n            return dp[i][j] = 0;\\n        }\\n    }\\n    \\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        vector<vector<int>> dp(matrix.size()+1, vector<int>(matrix[0].size()+1, -1));\\n        int ans=0;\\n       sol(matrix, 0, 0, ans, dp);\\n        return ans*ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2204279,
                "title": "c-2-methods-dp-stack",
                "content": "METHOD_1\\nDP watch this video by [pepcoding](https://www.youtube.com/watch?v=UagRoA3C5VQ) to understand the intution behind this method\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        \\n        int m=matrix[0].size(); \\n        int n=matrix.size();\\n        vector<vector<int>> M(n,vector<int>(m,0));\\n        \\n        // converting  character to type int\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(matrix[i][j]==\\'0\\')  M[i][j]=0;\\n                \\n                else M[i][j]=1;\\n                    \\n            }\\n        }\\n        \\n        vector<vector<int>> dp(n,vector<int>(m));\\n        int ans=0;\\n        \\n        for(int i=n-1;i>=0;i--){\\n            \\n            for(int j=m-1;j>=0;j--){\\n                \\n                // last row \\n                if(i==n-1){\\n                    dp[i][j]=M[i][j];\\n                }\\n                \\n                // last column\\n                else if(j==m-1){\\n                    dp[i][j]=M[i][j];\\n                }\\n                \\n                // otherwise\\n                else{\\n                    if(M[i][j]==0)\\n                        dp[i][j]=0;\\n                    \\n                    else{\\n                        // calculate the minimum of the elements to the right , diagonally , and to the bottom\\n                        // becuase we want the square , so length and breadth should be same  \\n                        int x=min(dp[i+1][j], dp[i][j+1]);\\n                        int y=min(x, dp[i+1][j+1]);\\n                        dp[i][j]=1+y;\\n                        \\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans=max(ans,dp[i][j]);\\n            }\\n        }\\n        return ans*ans;\\n    }\\n};\\n```\\n\\nMETHOD_2\\nthis method is just same as  [ largest area in histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/), we take out next smaller and previous smaller elemnt for every m[i][j] , while itertating over row , and height will be added from the previous rows value , but if m[i][j]==0 , then height will be 0\\n\\n```\\nclass Solution {\\npublic:\\n     vector<int> nextSmallerElement(vector<int> &arr, int n) {\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n\\n        for(int i=n-1; i>=0 ; i--) {\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr)\\n            {\\n                s.pop();\\n            }\\n            //ans is stack ka top\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n    \\n    vector<int> prevSmallerElement( vector<int> &arr, int n) {\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n\\n        for(int i=0; i<n; i++) {\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr)\\n            {\\n                s.pop();\\n            }\\n            //ans is stack ka top\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans; \\n    }    \\n    \\n  \\n  \\n  int largestSquareArea(vector<int> &heights, int n) {\\n        //int n= heights.size();\\n        \\n        vector<int> next(n);\\n        next = nextSmallerElement(heights, n);\\n            \\n        vector<int> prev(n);\\n        prev = prevSmallerElement(heights, n);\\n        \\n        int area = INT_MIN;\\n        for(int i=0; i<n; i++) {\\n            int l = heights[i];\\n            \\n            if(next[i] == -1) {\\n                next[i] = n;\\n            }\\n             int b = next[i] - prev[i] - 1;\\n            int p;\\n           p= min(l,b);\\n            int newArea = p*p;\\n            area = max(area, newArea);\\n        }\\n        return area;\\n    }\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n      int m=matrix[0].size(); \\n      int n=matrix.size();\\n      vector<vector<int>> M(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(matrix[i][j]==\\'0\\')  M[i][j]=0;\\n                \\n                else M[i][j]=1;\\n                    \\n            }\\n        }\\n        \\n        int area = largestSquareArea(M[0], m);\\n        for(int i = 1; i<n; i++) {\\n            for(int j = 0; j<m; j++) {\\n                \\n                //row udpate: by adding previous row\\'s value\\n                if(M[i][j] != 0)\\n                    M[i][j] = M[i][j] + M[i-1][j];\\n                \\n                // if   M[i][j] ==0 then height will be 0;\\n              \\n            }\\n            \\n            //entire row is updated now\\n            area = max(area, largestSquareArea(M[i],m));\\n            \\n        }\\n        return area;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        \\n        int m=matrix[0].size(); \\n        int n=matrix.size();\\n        vector<vector<int>> M(n,vector<int>(m,0));\\n        \\n        // converting  character to type int\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(matrix[i][j]==\\'0\\')  M[i][j]=0;\\n                \\n                else M[i][j]=1;\\n                    \\n            }\\n        }\\n        \\n        vector<vector<int>> dp(n,vector<int>(m));\\n        int ans=0;\\n        \\n        for(int i=n-1;i>=0;i--){\\n            \\n            for(int j=m-1;j>=0;j--){\\n                \\n                // last row \\n                if(i==n-1){\\n                    dp[i][j]=M[i][j];\\n                }\\n                \\n                // last column\\n                else if(j==m-1){\\n                    dp[i][j]=M[i][j];\\n                }\\n                \\n                // otherwise\\n                else{\\n                    if(M[i][j]==0)\\n                        dp[i][j]=0;\\n                    \\n                    else{\\n                        // calculate the minimum of the elements to the right , diagonally , and to the bottom\\n                        // becuase we want the square , so length and breadth should be same  \\n                        int x=min(dp[i+1][j], dp[i][j+1]);\\n                        int y=min(x, dp[i+1][j+1]);\\n                        dp[i][j]=1+y;\\n                        \\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                ans=max(ans,dp[i][j]);\\n            }\\n        }\\n        return ans*ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n     vector<int> nextSmallerElement(vector<int> &arr, int n) {\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n\\n        for(int i=n-1; i>=0 ; i--) {\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr)\\n            {\\n                s.pop();\\n            }\\n            //ans is stack ka top\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n    \\n    vector<int> prevSmallerElement( vector<int> &arr, int n) {\\n        stack<int> s;\\n        s.push(-1);\\n        vector<int> ans(n);\\n\\n        for(int i=0; i<n; i++) {\\n            int curr = arr[i];\\n            while(s.top() != -1 && arr[s.top()] >= curr)\\n            {\\n                s.pop();\\n            }\\n            //ans is stack ka top\\n            ans[i] = s.top();\\n            s.push(i);\\n        }\\n        return ans; \\n    }    \\n    \\n  \\n  \\n  int largestSquareArea(vector<int> &heights, int n) {\\n        //int n= heights.size();\\n        \\n        vector<int> next(n);\\n        next = nextSmallerElement(heights, n);\\n            \\n        vector<int> prev(n);\\n        prev = prevSmallerElement(heights, n);\\n        \\n        int area = INT_MIN;\\n        for(int i=0; i<n; i++) {\\n            int l = heights[i];\\n            \\n            if(next[i] == -1) {\\n                next[i] = n;\\n            }\\n             int b = next[i] - prev[i] - 1;\\n            int p;\\n           p= min(l,b);\\n            int newArea = p*p;\\n            area = max(area, newArea);\\n        }\\n        return area;\\n    }\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n      int m=matrix[0].size(); \\n      int n=matrix.size();\\n      vector<vector<int>> M(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(matrix[i][j]==\\'0\\')  M[i][j]=0;\\n                \\n                else M[i][j]=1;\\n                    \\n            }\\n        }\\n        \\n        int area = largestSquareArea(M[0], m);\\n        for(int i = 1; i<n; i++) {\\n            for(int j = 0; j<m; j++) {\\n                \\n                //row udpate: by adding previous row\\'s value\\n                if(M[i][j] != 0)\\n                    M[i][j] = M[i][j] + M[i-1][j];\\n                \\n                // if   M[i][j] ==0 then height will be 0;\\n              \\n            }\\n            \\n            //entire row is updated now\\n            area = max(area, largestSquareArea(M[i],m));\\n            \\n        }\\n        return area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2113596,
                "title": "easy-and-fast-c-solution",
                "content": "//O(n^2) space\\n\\nclass Solution \\n{\\npublic:\\n\\n    int maximalSquare(vector<vector<char>>& matrix) \\n    {\\n        int n = matrix.size(), m = matrix[0].size();\\n        vector<vector<int > > dp(n, vector<int> (m, 0));\\n        int ans = 0;\\n        \\n        for(int i = n-1; i >= 0; i--)\\n        {\\n            for(int j = m-1; j >= 0; j--)\\n            {\\n                if(i == n-1  or j == m-1)\\n                {\\n                    if(matrix[i][j] != \\'0\\'){\\n                        dp[i][j] = 1;\\n                    }\\n                    ans = max(ans, dp[i][j]);\\n                }\\n                else if(matrix[i][j] != \\'0\\')\\n                {\\n                    dp[i][j] = min(dp[i][j+1], min(dp[i+1][j], dp[i+1][j+1])) + 1;\\n                    ans = max(ans, dp[i][j]);\\n                }\\n            }\\n        }\\n        return ans*ans;\\n    }\\n};\\n\\n\\n// in O(2n) space\\n\\n\\nclass Solution {\\npublic:\\n\\n    int maximalSquare(vector<vector<char>> &matrix)\\n    {\\n        int n = matrix.size(), m = matrix[0].size();\\n        vector<vector<int>> dp(2, vector<int>(m, 0));\\n        int ans = 0;\\n\\n        for (int i = n - 1; i >= 0; i--) \\n        {\\n            for (int j = m - 1; j >= 0; j--) \\n            {\\n                if (i == n - 1 or j == m - 1) \\n                {\\n                    if (matrix[i][j] != \\'0\\')\\n                        dp[i % 2][j] = 1;\\n                    else \\n                        dp[i % 2][j] = 0; \\n\\n                    ans = max(ans, dp[i % 2][j]);\\n                }\\n                else if (matrix[i][j] != \\'0\\')\\n                {\\n                    dp[i % 2][j] = min(dp[i % 2][j + 1], min(dp[(i + 1) % 2][j], dp[(i + 1) % 2][j + 1])) + 1;\\n                    ans = max(ans, dp[i % 2][j]);\\n                }\\n                else if (matrix[i][j] == \\'0\\') \\n                    dp[i % 2][j] = 0;\\n            }\\n        }\\n        return ans * ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution \\n{\\npublic:\\n\\n    int maximalSquare(vector<vector<char>>& matrix) \\n    {\\n        int n = matrix.size(), m = matrix[0].size();\\n        vector<vector<int > > dp(n, vector<int> (m, 0));\\n        int ans = 0;\\n        \\n        for(int i = n-1; i >= 0; i--)\\n        {\\n            for(int j = m-1; j >= 0; j--)\\n            {\\n                if(i == n-1  or j == m-1)\\n                {\\n                    if(matrix[i][j] != \\'0\\'){\\n                        dp[i][j] = 1;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2046140,
                "title": "top-down-dfs-solution-python",
                "content": "```\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        cache = {} # store *length* of longest ones square with top left corner at idx (i, j)\\n        \\n        def dfs(i, j):\\n            if i >= len(matrix) or j >= len(matrix[0]) or i < 0 or j < 0: # out of bounds\\n                return 0\\n            if (i, j) in cache:\\n                return cache[(i, j)]\\n            \\n            right = dfs(i + 1, j)\\n            down = dfs(i, j + 1)\\n            diag = dfs(i + 1, j + 1)\\n            cache[(i, j)] = 1 + min(right, down, diag) if matrix[i][j] == \"1\" else 0\\n            return cache[(i, j)]\\n        \\n        dfs(0, 0) # top left corner\\n        maxArea = 0\\n        for key in cache:\\n            area = cache[key]**2\\n            maxArea = max(area, maxArea)\\n        return maxArea\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        cache = {} # store *length* of longest ones square with top left corner at idx (i, j)\\n        \\n        def dfs(i, j):\\n            if i >= len(matrix) or j >= len(matrix[0]) or i < 0 or j < 0: # out of bounds\\n                return 0\\n            if (i, j) in cache:\\n                return cache[(i, j)]\\n            \\n            right = dfs(i + 1, j)\\n            down = dfs(i, j + 1)\\n            diag = dfs(i + 1, j + 1)\\n            cache[(i, j)] = 1 + min(right, down, diag) if matrix[i][j] == \"1\" else 0\\n            return cache[(i, j)]\\n        \\n        dfs(0, 0) # top left corner\\n        maxArea = 0\\n        for key in cache:\\n            area = cache[key]**2\\n            maxArea = max(area, maxArea)\\n        return maxArea\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1966131,
                "title": "69-horney-solution-in-python3-dynamic-programing",
                "content": "![image](https://assets.leetcode.com/users/images/de6e27c5-2ebd-4627-9428-d64f3e56684f_1650443870.289733.png)\\n-----------ugly explaination-----------------\\n\\n1x1==[1] --> smallest subproblem\\n\\n\\n2x2=[1,1\\n\\t 1,1]\\n\\n3X3=[1,1,1\\n\\t 1,1,1\\n\\t 1,1,1]\\n\\t \\n\\n1   1\\n1   [2]--> critical 2x2\\n\\n\\n1   1   1 \\n1  [2]  [2]\\n1  [2]  [3]--> critical 3x3\\n\\n```\\n\\nclass Solution:\\n    def maximalSquare(self, mat: List[List[str]]) -> int:\\n        def sanitize():\\n            flag=0\\n            for i in range(len(mat)):\\n                for j in range(len(mat[0])):\\n                    mat[i][j]=int(mat[i][j])\\n                    if mat[i][j]:\\n                        flag=1\\n            return flag\\n                        \\n        if mat==[\"0\"]:return 0\\n        max_area=sanitize()\\n        for i in range(1,len(mat)):\\n            for j in range(1,len(mat[0])):\\n                if(mat[i][j]):\\n                    mat[i][j]=min(\\n                        mat[i-1][j],\\n                        mat[i][j-1],\\n                        mat[i-1][j-1]\\n                    )+1\\n                    max_area=max(max_area,mat[i][j])\\n        return max_area**2\\n                    \\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\nclass Solution:\\n    def maximalSquare(self, mat: List[List[str]]) -> int:\\n        def sanitize():\\n            flag=0\\n            for i in range(len(mat)):\\n                for j in range(len(mat[0])):\\n                    mat[i][j]=int(mat[i][j])\\n                    if mat[i][j]:\\n                        flag=1\\n            return flag\\n                        \\n        if mat==[\"0\"]:return 0\\n        max_area=sanitize()\\n        for i in range(1,len(mat)):\\n            for j in range(1,len(mat[0])):\\n                if(mat[i][j]):\\n                    mat[i][j]=min(\\n                        mat[i-1][j],\\n                        mat[i][j-1],\\n                        mat[i-1][j-1]\\n                    )+1\\n                    max_area=max(max_area,mat[i][j])\\n        return max_area**2\\n                    \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845846,
                "title": "c-easy-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    /*\\n    we need to check in these 3 direction to make our pre exisitng matrix largest \\n      \\\\    |\\n       \\\\   |\\n        \\\\  |\\n         \\\\ |\\n    ______\\\\|\\n    \\n    if there is a possibility that\\n    matrix[i-1][j-1] = 1\\n    matrix[i-1][j] = 1\\n    matrix[i][j-1] = 1 &\\n    matrix[i][j] = 1 then we can include that 1 and make our matrix larger , we loop over the matrix and keep the record of largest matrix we have encountered\\n    */\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int rows = matrix.size();\\n        if(rows == 0) return 0;\\n        int cols = matrix[0].size();\\n        vector<vector<int>> dp(rows+1,vector<int>(cols+1,0));\\n        int largest = 0;\\n        for(int i=1;i<=rows;i++)\\n        {\\n            for(int j=1;j<=cols;j++)\\n            {\\n                if(matrix[i-1][j-1] == \\'1\\'){\\n                dp[i][j] = 1+min(dp[i-1][j],min(dp[i][j-1],dp[i-1][j-1]));\\n                if(largest < dp[i][j])\\n                {\\n                   largest = dp[i][j];\\n                }\\n              }\\n            }\\n        }\\n        return largest*largest;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n    we need to check in these 3 direction to make our pre exisitng matrix largest \\n      \\\\    |\\n       \\\\   |\\n        \\\\  |\\n         \\\\ |\\n    ______\\\\|\\n    \\n    if there is a possibility that\\n    matrix[i-1][j-1] = 1\\n    matrix[i-1][j] = 1\\n    matrix[i][j-1] = 1 &\\n    matrix[i][j] = 1 then we can include that 1 and make our matrix larger , we loop over the matrix and keep the record of largest matrix we have encountered\\n    */\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int rows = matrix.size();\\n        if(rows == 0) return 0;\\n        int cols = matrix[0].size();\\n        vector<vector<int>> dp(rows+1,vector<int>(cols+1,0));\\n        int largest = 0;\\n        for(int i=1;i<=rows;i++)\\n        {\\n            for(int j=1;j<=cols;j++)\\n            {\\n                if(matrix[i-1][j-1] == \\'1\\'){\\n                dp[i][j] = 1+min(dp[i-1][j],min(dp[i][j-1],dp[i-1][j-1]));\\n                if(largest < dp[i][j])\\n                {\\n                   largest = dp[i][j];\\n                }\\n              }\\n            }\\n        }\\n        return largest*largest;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1841313,
                "title": "c-very-easy-dp-solution",
                "content": "If you get helful ,Upvote :)\\n```\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n     \\n        int m= matrix.size(),n=matrix[0].size();\\n        int dp[m+1][n+1];\\n        memset(dp,0,sizeof(dp));\\n        \\n        int mx=0;\\n        \\n        for(int i=1 ; i<=m ;i++){\\n            for(int j=1; j<=n; j++){\\n                if(matrix[i-1][j-1]==\\'1\\'){\\n                    dp[i][j] = 1+ min({dp[i-1][j],dp[i][j-1],dp[i-1][j-1]});\\n                    mx=max(mx,dp[i][j]);\\n                }\\n            }\\n        }\\n        \\n        \\n        return mx*mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n     \\n        int m= matrix.size(),n=matrix[0].size();\\n        int dp[m+1][n+1];\\n        memset(dp,0,sizeof(dp));\\n        \\n        int mx=0;\\n        \\n        for(int i=1 ; i<=m ;i++){\\n            for(int j=1; j<=n; j++){\\n                if(matrix[i-1][j-1]==\\'1\\'){\\n                    dp[i][j] = 1+ min({dp[i-1][j],dp[i][j-1],dp[i-1][j-1]});\\n                    mx=max(mx,dp[i][j]);\\n                }\\n            }\\n        }\\n        \\n        \\n        return mx*mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1834255,
                "title": "maximal-square-recursion-and-iteration-explained-code",
                "content": "# **<---Upvote if you like the solution**\\n\\nif you know better way to do this problem plz comment it down\\n\\n**SOLUTION 1 - ITERATION**\\n*In this solution I have not use extra space I have just use a variable largest to find the largest value and modified the given matrix by inserting maximum size squre possible at that position.*\\n\\'\\'\\'\\n\\n\\n\\tclass Solution:\\n\\n\\t\\tdef maximalSquare(self, matrix: List[List[str]]) -> int:\\n\\t\\t\\tlargest = int(matrix[0][0])\\n\\t#this loop is used when our array is having dimension(1,n) or (m,1) in this \\n\\t#case we just need to find \"1\" is present in it or not is present we return 1 else 0\\n\\t\\t\\tif len(matrix) == 1 or len(matrix[0]) == 1:\\n\\t\\t\\t\\tfor i in matrix:\\n\\t\\t\\t\\t\\tfor j in i:\\n\\t\\t\\t\\t\\t\\tif j == \"1\":    return 1\\n\\t\\t\\t\\t\\t\\t\\n\\t# if our array is like [[0,1][1,0]] then our ans lies in first row or first col to \\n\\t#chek this condition I have used largest for only first col and first row\\n\\t\\t\\tfor r in range(1,len(matrix)):\\n\\t\\t\\t\\tlargest = max(largest,int(matrix[r][0]))  \\n\\t\\t\\t\\tfor c in range(1,len(matrix[0])):\\n\\t\\t\\t\\t\\tlargest = max(largest,int(matrix[0][c]))\\n\\t\\t\\t\\t\\tif matrix[r][c] != \"0\":\\n\\t\\t\\t\\t\\t\\tside,upper,digo = int(matrix[r-1][c]),int(matrix[r][c-1]),int(matrix[r-1][c-1])\\n\\t\\t\\t\\t\\t\\tnewVal = 1 + min(side,upper,digo)\\n\\t\\t\\t\\t\\t\\tlargest = max(largest,newVal)\\n\\t\\t\\t\\t\\t\\tmatrix[r][c] = str(newVal)\\n\\n\\t\\t\\treturn largest **2\\n\\'\\'\\'\\n\\n**Solution 2 :  Recursion (top down)**\\n*if you not understand the solution I recommend you to watch neetcode youtube channel I learned this solution from there.*\\n\\n\\tclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n\\t#         recursion top down approach use cache for storing all possible squre for that specific (r,c) \\n\\n        ROW,COL = len(matrix),len(matrix[0])\\n        cache = {}        \\n        def helper(r,c):\\n            if r>=ROW or c>=COL:    return 0\\n            \\n            if (r,c) not in cache:\\n                bottom = helper(r+1,c)\\n                side = helper(r,c+1)\\n                digo = helper(r+1,c+1)\\n                \\n                cache[(r,c)] = 0\\n                if matrix[r][c] == \"1\":\\n                    cache[(r,c)] = 1 + min(side,bottom,digo) \\n                    \\n            return cache[(r,c)]\\n    \\n        helper(0,0)\\n        length = max(cache.values())\\n        return length**2",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Iterator"
                ],
                "code": "class Solution:\\n\\n\\t\\tdef maximalSquare(self, matrix: List[List[str]]) -> int:\\n\\t\\t\\tlargest = int(matrix[0][0])\\n\\t#this loop is used when our array is having dimension(1,n) or (m,1) in this \\n\\t#case we just need to find \"1\" is present in it or not is present we return 1 else 0\\n\\t\\t\\tif len(matrix) == 1 or len(matrix[0]) == 1:\\n\\t\\t\\t\\tfor i in matrix:\\n\\t\\t\\t\\t\\tfor j in i:\\n\\t\\t\\t\\t\\t\\tif j == \"1\":    return 1\\n\\t\\t\\t\\t\\t\\t\\n\\t# if our array is like [[0,1][1,0]] then our ans lies in first row or first col to \\n\\t#chek this condition I have used largest for only first col and first row\\n\\t\\t\\tfor r in range(1,len(matrix)):\\n\\t\\t\\t\\tlargest = max(largest,int(matrix[r][0]))  \\n\\t\\t\\t\\tfor c in range(1,len(matrix[0])):\\n\\t\\t\\t\\t\\tlargest = max(largest,int(matrix[0][c]))\\n\\t\\t\\t\\t\\tif matrix[r][c] != \"0\":\\n\\t\\t\\t\\t\\t\\tside,upper,digo = int(matrix[r-1][c]),int(matrix[r][c-1]),int(matrix[r-1][c-1])\\n\\t\\t\\t\\t\\t\\tnewVal = 1 + min(side,upper,digo)\\n\\t\\t\\t\\t\\t\\tlargest = max(largest,newVal)\\n\\t\\t\\t\\t\\t\\tmatrix[r][c] = str(newVal)\\n\\n\\t\\t\\treturn largest **2\\n\\'\\'\\'\\n\\n**Solution 2 :  Recursion (top down)**\\n*if you not understand the solution I recommend you to watch neetcode youtube channel I learned this solution from there.*\\n\\n\\tclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n\\t#         recursion top down approach use cache for storing all possible squre for that specific (r,c) \\n\\n        ROW,COL = len(matrix),len(matrix[0])\\n        cache = {}",
                "codeTag": "Java"
            },
            {
                "id": 1821227,
                "title": "c-recursion-memorization-space-optimisation",
                "content": "My intutuion was inspiried from [ Number of Islands](https://leetcode.com/problems/number-of-islands/) questions intuituion\\nso \\n**Recursion**:\\n```\\nint helper(int curr_r,int curr_c,vector<vector<char>>& matrix){\\n        if(curr_r<0 || curr_c<0 || curr_r>= matrix.size()|| curr_c>=matrix[0].size()|| \\n            matrix[curr_r][curr_c] == \\'0\\'){\\n            return 0;\\n            }\\n       \\n        return 1+min( helper(curr_r+1,curr_c,matrix),\\n                     min(helper(curr_r+1,curr_c+1,matrix),\\n                         helper(curr_r,curr_c+1,matrix))) ;\\n    }\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        \\n        \\n        int r = matrix.size() ;\\n        int c = matrix[0].size() ;\\n        int ans = INT_MIN ;\\n        for(int i = 0;i<r;i++){\\n            for(int j = 0;j<c;j++){\\n                if(matrix[i][j] == \\'1\\'){\\n                    ans = max(ans,helper(i,j,matrix)) ;\\n                }\\n            }\\n        }\\n        return ans == INT_MIN? 0:ans*ans ;\\n        \\n\\t\\t/*\\n\\t\\tTime : O(3^(r*c))\\n\\t\\tSpace : O(r+c)\\n\\t\\t*/\\n        \\n    }\\n```\\ncan we memorize the recursion?\\nyes we can because we can clearly see overlapping subproblems\\n**changing variable**: (curr_r,curr_c)\\nso 2D-vector is requried\\n\\n**MEMORIZATION:**\\n```\\nint helper(int curr_r,int curr_c,vector<vector<char>>& matrix,vector<vector<int>>& dp){\\n        if(curr_r<0 || curr_c<0 || curr_r>= matrix.size()|| curr_c>=matrix[0].size()|| \\n            matrix[curr_r][curr_c] == \\'0\\'){\\n            return 0;\\n            }\\n        if(dp[curr_r][curr_c]!=-1) return dp[curr_r][curr_c] ;\\n        return dp[curr_r][curr_c] = 1+min( helper(curr_r+1,curr_c,matrix,dp),\\n                     min(helper(curr_r+1,curr_c+1,matrix,dp),\\n                         helper(curr_r,curr_c+1,matrix,dp))) ;\\n    }\\n\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int r = matrix.size() ;\\n        int c = matrix[0].size() ;\\n\\t\\t//2d vector\\n        vector<vector<int>> dp(r,vector<int>(c,-1)) ;\\n\\t\\t\\n        int ans = INT_MIN ;\\n\\t\\t\\n        for(int i = 0;i<r;i++){\\n            for(int j = 0;j<c;j++){\\n                if(matrix[i][j] == \\'1\\'){\\n                    ans = max(ans,helper(i,j,matrix,dp)) ;\\n                }\\n            }\\n        }\\n        return ans == INT_MIN? 0:ans*ans ;\\n\\t\\t\\n\\t\\t/*\\n\\t\\tTime : O(r*c)\\n\\t\\tSPace : O(r*c) + O(r+c)\\n\\t\\t*/\\n        \\n    }\\n```\\nNow let us see **Bottom up**:\\n```\\nint btup(vector<vector<char>>& matrix){\\n        int r = matrix.size() ;\\n        int c = matrix[0].size() ;\\n        vector<vector<int>> dp(r,vector<int>(c)) ;\\n        int ans = INT_MIN ;\\n        for(int i = 0;i<c;i++){\\n            dp[r-1][i] = matrix[r-1][i]-\\'0\\';\\n            ans = max(ans,dp[r-1][i]) ;\\n        }\\n        \\n        for(int i = 0;i<r;i++){\\n            dp[i][c-1] = matrix[i][c-1]-\\'0\\' ;\\n            ans = max(ans,dp[i][c-1]) ;\\n        }\\n        \\n        for(int i = r-2;i>=0;i--){\\n            for(int j = c-2;j>=0;j--){\\n               if(matrix[i][j] == \\'1\\'){\\n                    dp[i][j] = 1+ min(dp[i][j+1],min(dp[i+1][j+1],dp[i+1][j])) ;\\n               }\\n                ans = max(ans,dp[i][j]) ;\\n            }\\n        }\\n        return ans == INT_MIN? 0:ans*ans ;\\n\\t\\t\\n\\t\\t/*\\n\\t\\tTime : O(r*c)\\n\\t\\tSpace : O(r*c) //no extra recursive stack space\\n\\t\\t*/\\n        \\n    }\\n```\\n\\ncan we space optimise the Tabulation approach?\\nyes we can because i depends on i, i+1 but not i+2,i-1..\\nso we can just use two rows and optimise the solution\\n**space optimised:**\\n```\\nint spot(vector<vector<char>>& matrix){\\n        int r = matrix.size() ;\\n        int c = matrix[0].size() ;\\n        int ans = INT_MIN ;\\n        \\n\\t\\t//check if our matrix has only one row \\n\\t\\t//if one we can just check wether we have one or not and return it\\n        if(r == 1){\\n            for(int i = 0;i<c;i++){\\n                ans = max(ans,matrix[0][i]-\\'0\\') ;\\n            }\\n            return ans ;\\n        }\\n        \\n        //2*c matrix = 2 1d arrays\\n        vector<vector<int>> dp(2,vector<int>(c)) ;\\n        \\n        \\n        for(int i = 0;i<c;i++){\\n            dp[(r-1)%2][i] = matrix[r-1][i]-\\'0\\';\\n            ans = max(ans,dp[(r-1)%2][i]) ;\\n        }\\n        \\n        dp[(r-2)%2][c-1] = matrix[(r-2)][c-1]-\\'0\\' ;//just adding (r-2)(c-1) element\\n        ans = max(ans,dp[(r-2)%2][c-1]) ;\\n        \\n        \\n        for(int i = r-2;i>=0;i--){\\n            for(int j = c-2;j>=0;j--){\\n\\t\\t\\t\\n               if(matrix[i][j] == \\'1\\'){\\n                    dp[i%2][j] = 1+ min(dp[i%2][j+1],min(dp[(i+1)%2][j+1],dp[(i+1)%2][j])) ;\\n               }\\n                else{\\n\\t\\t\\t\\t//if it is zero you have to make it zero \\n\\t\\t\\t\\t//because previously we have 0 in all places but now we are using same space so\\n\\t\\t\\t\\t//we have to make zero\\n                    dp[i%2][j] = 0;\\n                }\\n                ans = max(ans,dp[i%2][j]) ;\\n            }\\n        }\\n        \\n        for(int i = 0;i<2;i++){\\n            for(int j = 0;j<c;j++){\\n                cout<<dp[i][j]<<\" \";\\n            }\\n            cout<<endl ;\\n        }\\n        return ans == INT_MIN? 0:ans*ans ;\\n        /*\\n\\t\\tTime : O(r*c)\\n\\t\\tspace : O(2*c)\\n\\t\\t*/\\n    }\\n\\t\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint helper(int curr_r,int curr_c,vector<vector<char>>& matrix){\\n        if(curr_r<0 || curr_c<0 || curr_r>= matrix.size()|| curr_c>=matrix[0].size()|| \\n            matrix[curr_r][curr_c] == \\'0\\'){\\n            return 0;\\n            }\\n       \\n        return 1+min( helper(curr_r+1,curr_c,matrix),\\n                     min(helper(curr_r+1,curr_c+1,matrix),\\n                         helper(curr_r,curr_c+1,matrix))) ;\\n    }\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        \\n        \\n        int r = matrix.size() ;\\n        int c = matrix[0].size() ;\\n        int ans = INT_MIN ;\\n        for(int i = 0;i<r;i++){\\n            for(int j = 0;j<c;j++){\\n                if(matrix[i][j] == \\'1\\'){\\n                    ans = max(ans,helper(i,j,matrix)) ;\\n                }\\n            }\\n        }\\n        return ans == INT_MIN? 0:ans*ans ;\\n        \\n\\t\\t/*\\n\\t\\tTime : O(3^(r*c))\\n\\t\\tSpace : O(r+c)\\n\\t\\t*/\\n        \\n    }\\n```\n```\\nint helper(int curr_r,int curr_c,vector<vector<char>>& matrix,vector<vector<int>>& dp){\\n        if(curr_r<0 || curr_c<0 || curr_r>= matrix.size()|| curr_c>=matrix[0].size()|| \\n            matrix[curr_r][curr_c] == \\'0\\'){\\n            return 0;\\n            }\\n        if(dp[curr_r][curr_c]!=-1) return dp[curr_r][curr_c] ;\\n        return dp[curr_r][curr_c] = 1+min( helper(curr_r+1,curr_c,matrix,dp),\\n                     min(helper(curr_r+1,curr_c+1,matrix,dp),\\n                         helper(curr_r,curr_c+1,matrix,dp))) ;\\n    }\\n\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int r = matrix.size() ;\\n        int c = matrix[0].size() ;\\n\\t\\t//2d vector\\n        vector<vector<int>> dp(r,vector<int>(c,-1)) ;\\n\\t\\t\\n        int ans = INT_MIN ;\\n\\t\\t\\n        for(int i = 0;i<r;i++){\\n            for(int j = 0;j<c;j++){\\n                if(matrix[i][j] == \\'1\\'){\\n                    ans = max(ans,helper(i,j,matrix,dp)) ;\\n                }\\n            }\\n        }\\n        return ans == INT_MIN? 0:ans*ans ;\\n\\t\\t\\n\\t\\t/*\\n\\t\\tTime : O(r*c)\\n\\t\\tSPace : O(r*c) + O(r+c)\\n\\t\\t*/\\n        \\n    }\\n```\n```\\nint btup(vector<vector<char>>& matrix){\\n        int r = matrix.size() ;\\n        int c = matrix[0].size() ;\\n        vector<vector<int>> dp(r,vector<int>(c)) ;\\n        int ans = INT_MIN ;\\n        for(int i = 0;i<c;i++){\\n            dp[r-1][i] = matrix[r-1][i]-\\'0\\';\\n            ans = max(ans,dp[r-1][i]) ;\\n        }\\n        \\n        for(int i = 0;i<r;i++){\\n            dp[i][c-1] = matrix[i][c-1]-\\'0\\' ;\\n            ans = max(ans,dp[i][c-1]) ;\\n        }\\n        \\n        for(int i = r-2;i>=0;i--){\\n            for(int j = c-2;j>=0;j--){\\n               if(matrix[i][j] == \\'1\\'){\\n                    dp[i][j] = 1+ min(dp[i][j+1],min(dp[i+1][j+1],dp[i+1][j])) ;\\n               }\\n                ans = max(ans,dp[i][j]) ;\\n            }\\n        }\\n        return ans == INT_MIN? 0:ans*ans ;\\n\\t\\t\\n\\t\\t/*\\n\\t\\tTime : O(r*c)\\n\\t\\tSpace : O(r*c) //no extra recursive stack space\\n\\t\\t*/\\n        \\n    }\\n```\n```\\nint spot(vector<vector<char>>& matrix){\\n        int r = matrix.size() ;\\n        int c = matrix[0].size() ;\\n        int ans = INT_MIN ;\\n        \\n\\t\\t//check if our matrix has only one row \\n\\t\\t//if one we can just check wether we have one or not and return it\\n        if(r == 1){\\n            for(int i = 0;i<c;i++){\\n                ans = max(ans,matrix[0][i]-\\'0\\') ;\\n            }\\n            return ans ;\\n        }\\n        \\n        //2*c matrix = 2 1d arrays\\n        vector<vector<int>> dp(2,vector<int>(c)) ;\\n        \\n        \\n        for(int i = 0;i<c;i++){\\n            dp[(r-1)%2][i] = matrix[r-1][i]-\\'0\\';\\n            ans = max(ans,dp[(r-1)%2][i]) ;\\n        }\\n        \\n        dp[(r-2)%2][c-1] = matrix[(r-2)][c-1]-\\'0\\' ;//just adding (r-2)(c-1) element\\n        ans = max(ans,dp[(r-2)%2][c-1]) ;\\n        \\n        \\n        for(int i = r-2;i>=0;i--){\\n            for(int j = c-2;j>=0;j--){\\n\\t\\t\\t\\n               if(matrix[i][j] == \\'1\\'){\\n                    dp[i%2][j] = 1+ min(dp[i%2][j+1],min(dp[(i+1)%2][j+1],dp[(i+1)%2][j])) ;\\n               }\\n                else{\\n\\t\\t\\t\\t//if it is zero you have to make it zero \\n\\t\\t\\t\\t//because previously we have 0 in all places but now we are using same space so\\n\\t\\t\\t\\t//we have to make zero\\n                    dp[i%2][j] = 0;\\n                }\\n                ans = max(ans,dp[i%2][j]) ;\\n            }\\n        }\\n        \\n        for(int i = 0;i<2;i++){\\n            for(int j = 0;j<c;j++){\\n                cout<<dp[i][j]<<\" \";\\n            }\\n            cout<<endl ;\\n        }\\n        return ans == INT_MIN? 0:ans*ans ;\\n        /*\\n\\t\\tTime : O(r*c)\\n\\t\\tspace : O(2*c)\\n\\t\\t*/\\n    }\\n\\t\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1742680,
                "title": "python-easiest-top-down-bottom-up-dp-soln",
                "content": "**Top-down**\\n```\\nclass Solution:\\n    def dp(self, A, i, j, dp):\\n        if dp[i][j] != 0:\\n            return dp[i][j]\\n\\n        if i < 0 or j < 0 or A[i][j] == \\'0\\':\\n            ans = 0\\n        else:\\n            ans = 1 + min(self.dp(A, i - 1, j, dp), self.dp(A, i - 1, j - 1, dp), self.dp(A, i, j - 1, dp))\\n\\n        dp[i][j] = ans\\n        return ans\\n\\n    def maximalSquare(self, mat):\\n        m = len(mat)\\n        n = len(mat[0])\\n        dp = [[0 for _ in range(n)] for _ in range(m)]\\n\\n        ans = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if mat[i][j] == \\'1\\':\\n                    ans = max(ans, self.dp(mat, i, j, dp))\\n\\n        return ans ** 2\\n```\\n**Bottom-up**\\n```\\nclass Solution:\\n    def maximalSquare(self, mat):\\n        m = len(mat)\\n        n = len(mat[0])\\n        dp = [[0 for _ in range(n)] for _ in range(m)]\\n        \\n        ans = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if i == 0 or j == 0:\\n                    dp[i][j] = int(mat[i][j])\\n                    ans = max(ans, dp[i][j])\\n                else:\\n                    if mat[i][j] == \\'1\\':\\n                        dp[i][j] = 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])\\n                        ans = max(ans, dp[i][j])\\n        \\n        return ans ** 2\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def dp(self, A, i, j, dp):\\n        if dp[i][j] != 0:\\n            return dp[i][j]\\n\\n        if i < 0 or j < 0 or A[i][j] == \\'0\\':\\n            ans = 0\\n        else:\\n            ans = 1 + min(self.dp(A, i - 1, j, dp), self.dp(A, i - 1, j - 1, dp), self.dp(A, i, j - 1, dp))\\n\\n        dp[i][j] = ans\\n        return ans\\n\\n    def maximalSquare(self, mat):\\n        m = len(mat)\\n        n = len(mat[0])\\n        dp = [[0 for _ in range(n)] for _ in range(m)]\\n\\n        ans = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if mat[i][j] == \\'1\\':\\n                    ans = max(ans, self.dp(mat, i, j, dp))\\n\\n        return ans ** 2\\n```\n```\\nclass Solution:\\n    def maximalSquare(self, mat):\\n        m = len(mat)\\n        n = len(mat[0])\\n        dp = [[0 for _ in range(n)] for _ in range(m)]\\n        \\n        ans = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if i == 0 or j == 0:\\n                    dp[i][j] = int(mat[i][j])\\n                    ans = max(ans, dp[i][j])\\n                else:\\n                    if mat[i][j] == \\'1\\':\\n                        dp[i][j] = 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])\\n                        ans = max(ans, dp[i][j])\\n        \\n        return ans ** 2\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1634318,
                "title": "java-simple-explanation-dp-space-optimized-solution",
                "content": "**Problem**. Given an m x n binary matrix filled with 0\\'s and 1\\'s, find the largest square containing only 1\\'s and return its area. \\nThis problem can be elegantly solved with a **dp strategy**.\\n\\n```\\nclass Solution {\\n    public int maximalSquare(char[][] matrix) {\\n        int[][] dp = new int[matrix.length][matrix[0].length];\\n        int ans = 0;\\n        for(int i = 0; i < matrix.length; i++){\\n            for(int j = 0; j < matrix[0].length; j ++){\\n                if(matrix[i][j] == \\'1\\'){\\n                   //initialization\\n\\t\\t\\t\\t   if(i == 0|| j == 0)\\n                        dp[i][j] = 1;\\n                     else \\n                        dp[i][j] = Math.min(Math.min(dp[i - 1][j - 1], dp[i - 1][j]), dp[i][j - 1]) + 1;\\n                    \\n                    ans = Math.max(ans, dp[i][j] * dp[i][j]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n**TC: O(mn)\\nTS: O(mn)**\\n\\nNow we implement a space optimized solution. We apply the same logic.\\nInstead of using a dp **m**x**n** matrix, we use only an array, that represent each column, and a int value, right_up, that is the fourth value needed to populate the dp array (one is matrix[i][i], then dp[i], dp[i-1] and right_up, that is the old dp[i-1], of the previus column).\\n\\n\\n![image](https://assets.leetcode.com/users/images/d9209d70-b067-49ea-88a1-92eb622cf218_1639843295.2600548.jpeg)\\nI hope I was helpful, if yes then upvote. Thanks.\\n**Given m rows and n columns**\\n**TC: O(mn)\\nTS: O(m+1)= O(m)**\\n\\n```\\nclass Solution {\\n    public int maximalSquare(char[][] matrix) {\\n\\n         /*\\n                        dp[i-1][j-1]  ||  dp[i-1] [j]\\n                   ----------------------------------\\n                        dp[i][j-1]     ||   dp[i][j]\\n                    */\\n        \\n        int[] dp = new int[matrix.length]; //rows\\n        int ans = 0;\\n        \\n        int up_right = 0;\\n        \\n        for(int j = 0; j < matrix[0].length; j++)\\n            for(int i = 0; i < matrix.length; i++)\\n                \\n            {\\n                    if(i == 0 || j == 0  || matrix[i][j] -\\'0\\' == 0)\\n                    {\\n                        if(matrix[i][j]-\\'0\\' == 1 && ans==0)\\n                           ans = 1;\\n                        \\n                        if(j >= 1)\\n                            up_right = dp[i];\\n                            \\n                            dp[i] = matrix[i][j] - \\'0\\';\\n                       \\n                    }\\n                \\n                     else \\n                     \\n                         if(matrix[i][j]-\\'0\\'== 1)\\n                         {\\n                             int store= dp[i];\\n                             dp[i] = Math.min(Math.min(dp[i], dp[i - 1]), up_right) + 1;\\n                             up_right = store;\\n                             ans = Math.max(ans, dp[i]);\\n                             \\n                         }\\n                     \\n                }\\n            \\n        \\n        return ans*ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maximalSquare(char[][] matrix) {\\n        int[][] dp = new int[matrix.length][matrix[0].length];\\n        int ans = 0;\\n        for(int i = 0; i < matrix.length; i++){\\n            for(int j = 0; j < matrix[0].length; j ++){\\n                if(matrix[i][j] == \\'1\\'){\\n                   //initialization\\n\\t\\t\\t\\t   if(i == 0|| j == 0)\\n                        dp[i][j] = 1;\\n                     else \\n                        dp[i][j] = Math.min(Math.min(dp[i - 1][j - 1], dp[i - 1][j]), dp[i][j - 1]) + 1;\\n                    \\n                    ans = Math.max(ans, dp[i][j] * dp[i][j]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maximalSquare(char[][] matrix) {\\n\\n         /*\\n                        dp[i-1][j-1]  ||  dp[i-1] [j]\\n                   ----------------------------------\\n                        dp[i][j-1]     ||   dp[i][j]\\n                    */\\n        \\n        int[] dp = new int[matrix.length]; //rows\\n        int ans = 0;\\n        \\n        int up_right = 0;\\n        \\n        for(int j = 0; j < matrix[0].length; j++)\\n            for(int i = 0; i < matrix.length; i++)\\n                \\n            {\\n                    if(i == 0 || j == 0  || matrix[i][j] -\\'0\\' == 0)\\n                    {\\n                        if(matrix[i][j]-\\'0\\' == 1 && ans==0)\\n                           ans = 1;\\n                        \\n                        if(j >= 1)\\n                            up_right = dp[i];\\n                            \\n                            dp[i] = matrix[i][j] - \\'0\\';\\n                       \\n                    }\\n                \\n                     else \\n                     \\n                         if(matrix[i][j]-\\'0\\'== 1)\\n                         {\\n                             int store= dp[i];\\n                             dp[i] = Math.min(Math.min(dp[i], dp[i - 1]), up_right) + 1;\\n                             up_right = store;\\n                             ans = Math.max(ans, dp[i]);\\n                             \\n                         }\\n                     \\n                }\\n            \\n        \\n        return ans*ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1633215,
                "title": "c-dp-solutions-explained-100-time-90-space",
                "content": "Pretty similar to [maximal rectangle](https://leetcode.com/problems/maximal-rectangle/) ([solution here](https://leetcode.com/problems/maximal-rectangle/discuss/1605049/)), with a few twists!\\n\\nWe might be tempted to iterate through each cell and check how large is the square we can have once we hit a `\\'1\\'`, but that will have us iterate over the same rows and cols over again; we can be a bit smarter about it and store somewhere else (if the limit for each size was `< 255`, we might just have overwritten `matrix`, actually) how many `\\'1\\'` are from there to the right, for example: thanks to that, we can then  much more easily proceed to identify the largest square we might find, parsing only in the direction perpendicular to the one we buffered (in our case, then, going down).\\n\\nTo do this, we will need a few support variables:\\n* `h` and `w` will store the height and width of the provided input, respectively;\\n* `dp` is a 2D array of `h` rows and `w` cols that will store our previously mentioned computation to see how many `\\'1\\'` are on the right of each matching cell.\\n\\nWe will loop through each row `y` and each column `x` and, using also `cx` set to `-1` at the beginning of each row, we will:\\n* if `matrix[y][x] == \\'0\\'`, then we will set `dp[y][x]` to be `0` (as a number, notice: not a character);\\n* alternatively:\\n\\t* if `cx < x` (as it would be the case initially, for example), we will advance `cx` from `x` until we keep finding `\\'1\\'`s in `matrix[y][cx]` and we are not out of bonds;\\n\\t* in any case, we will set `dp[y][x]` to be `cx - x` - notice that will mean that we will iterate forward to find the full extension of the following `\\'1\\'` series right after only once.\\n\\nFor example the input:\\n\\n```cpp\\n1\\t0\\t1\\t0\\t0\\t1\\t1\\t1\\t\\n1\\t0\\t1\\t1\\t1\\t1\\t1\\t1\\t\\n1\\t1\\t1\\t1\\t1\\t1\\t0\\t1\\t\\n1\\t0\\t0\\t1\\t0\\t1\\t1\\t1\\n```\\n\\nWill give us this `dp`:\\n\\n```cpp\\n1\\t0\\t1\\t0\\t0\\t3\\t2\\t1\\t\\n1\\t0\\t6\\t5\\t4\\t3\\t2\\t1\\t\\n6\\t5\\t4\\t3\\t2\\t1\\t0\\t1\\t\\n1\\t0\\t0\\t1\\t0\\t3\\t2\\t1\\t\\n```\\nOnce done, time to run the real parsing of `matrix` to find our maximum squares, so we will similarly loop through each row `y` and each column `x` and, using also `cy`, `maxX` and `diff`to help us with our computation; in each inner iteration,  as soon as we find a value of `dp[y][x]` which is not `0`, we will:\\n* set `cy` to be equal to `y` and decrease `y` by `1` (to help us later perform subtractions without having to add `1` all the time);\\n* set `maxX` to be `dp[cy][x]`, the current maximum of `\\'1\\'` the matching cell in `matrix` might have had on its right;\\n* update `res` to be the maximum between its current value and `1`;\\n* iterate increasing `cy` while it does not go out of bonds (`< h`) and `dp[cy][x]` is not `0` and:\\n\\t* update `maxX` to be the minimum between its current value and what we have now in `dp[cy][x]`, so the maximum number of consecutive `\\'1\\'` we would have on row from the same column `x` on the current row `cy`;\\n\\t* compute `diffY` as the difference between `cy` and `y`;\\n\\t* check if `diffY > maxX`, in which case we have no more reason to go down and can just `break`;\\n\\t* if we are still in the `while` loop, then  we will update `res` as the maximum between its current value and the square of the minimum between `maxX` and `diffY`;\\n* increase `y` back to its original value (for now, we no longer need to compute a subtraction to get the full range of cells we are parsing).\\n\\nOnce done, we can finally `return` `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        // support variables\\n        int h = matrix.size(), w = matrix[0].size(), dp[h][w], res = 0;\\n        // populating dp\\n        for (int y = 0; y < h; y++) {\\n            for (int x = 0, cx = -1; x < w; x++) {\\n                if (matrix[y][x] == \\'0\\') dp[y][x] = 0;\\n                else {\\n                    if (cx < x) {\\n                        cx = x;\\n                        while (cx < w && matrix[y][cx] == \\'1\\') cx++;\\n                    }\\n                    dp[y][x] = (cx - x);\\n                }\\n            }\\n        }\\n\\t\\t// parsing to find the largest square\\n        for (int y = 0, cy, maxX, diffY; y < h; y++) {\\n            for (int x = 0; x < w; x++) {\\n                // looking for nodes here\\n                if (dp[y][x]) {\\n                    cy = y--;\\n                    maxX = dp[cy][x];\\n                    res = max(res, 1);\\n\\t\\t\\t\\t\\t// going down as long as we have non 0 cells and are in the bounds of matrix\\n                    while (++cy < h && dp[cy][x]) {\\n                        maxX = min(maxX, dp[cy][x]);\\n                        diffY = cy - y;\\n                        if (diffY > maxX) break;\\n                        res = max(res, (int)pow(min(maxX, diffY), 2));\\n                    }\\n                    y++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nCan we optimise further? Well, yes! If we store also the side of the largest square found so far, we can skip checking on cells that would never offer us anything bigger than that; storing just the size, we can also compute the area just in the last line and all in all this optimisation gave me much faster hunts:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        // support variables\\n        int h = matrix.size(), w = matrix[0].size(), dp[h][w], res = 0, maxSide = 0;\\n        // populating dp\\n        for (int y = 0; y < h; y++) {\\n            for (int x = 0, cx = -1; x < w; x++) {\\n                if (matrix[y][x] == \\'0\\') dp[y][x] = 0;\\n                else {\\n                    if (cx < x) {\\n                        cx = x;\\n                        while (cx < w && matrix[y][cx] == \\'1\\') cx++;\\n                    }\\n                    dp[y][x] = (cx - x);\\n                }\\n            }\\n        }\\n\\t\\t// parsing to find the largest square\\n        for (int y = 0, maxX, diffY, currSide; y < h; y++) {\\n            for (int x = 0, cy; x < w; x++) {\\n                // looking for nodes here\\n                if (dp[y][x] > maxSide) {\\n                    cy = y--;\\n                    maxX = dp[cy][x];\\n                    maxSide = max(maxSide, 1);\\n                    res = max(res, 1);\\n\\t\\t\\t\\t\\t// going down as long as we have non 0 cells and are in the bounds of matrix\\n                    while (++cy < h && dp[cy][x]) {\\n                        maxX = min(maxX, dp[cy][x]);\\n                        diffY = cy - y;\\n                        currSide = min(maxX, diffY);\\n                        // cutting short when it makes no sense to continue\\n                        if (diffY > maxX || maxX < maxSide) break;\\n                        maxSide = max(maxSide, currSide);\\n                    }\\n                    y++;\\n                }\\n            }\\n        }\\n        return maxSide * maxSide;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```cpp\\n1\\t0\\t1\\t0\\t0\\t1\\t1\\t1\\t\\n1\\t0\\t1\\t1\\t1\\t1\\t1\\t1\\t\\n1\\t1\\t1\\t1\\t1\\t1\\t0\\t1\\t\\n1\\t0\\t0\\t1\\t0\\t1\\t1\\t1\\n```\n```cpp\\n1\\t0\\t1\\t0\\t0\\t3\\t2\\t1\\t\\n1\\t0\\t6\\t5\\t4\\t3\\t2\\t1\\t\\n6\\t5\\t4\\t3\\t2\\t1\\t0\\t1\\t\\n1\\t0\\t0\\t1\\t0\\t3\\t2\\t1\\t\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        // support variables\\n        int h = matrix.size(), w = matrix[0].size(), dp[h][w], res = 0;\\n        // populating dp\\n        for (int y = 0; y < h; y++) {\\n            for (int x = 0, cx = -1; x < w; x++) {\\n                if (matrix[y][x] == \\'0\\') dp[y][x] = 0;\\n                else {\\n                    if (cx < x) {\\n                        cx = x;\\n                        while (cx < w && matrix[y][cx] == \\'1\\') cx++;\\n                    }\\n                    dp[y][x] = (cx - x);\\n                }\\n            }\\n        }\\n\\t\\t// parsing to find the largest square\\n        for (int y = 0, cy, maxX, diffY; y < h; y++) {\\n            for (int x = 0; x < w; x++) {\\n                // looking for nodes here\\n                if (dp[y][x]) {\\n                    cy = y--;\\n                    maxX = dp[cy][x];\\n                    res = max(res, 1);\\n\\t\\t\\t\\t\\t// going down as long as we have non 0 cells and are in the bounds of matrix\\n                    while (++cy < h && dp[cy][x]) {\\n                        maxX = min(maxX, dp[cy][x]);\\n                        diffY = cy - y;\\n                        if (diffY > maxX) break;\\n                        res = max(res, (int)pow(min(maxX, diffY), 2));\\n                    }\\n                    y++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        // support variables\\n        int h = matrix.size(), w = matrix[0].size(), dp[h][w], res = 0, maxSide = 0;\\n        // populating dp\\n        for (int y = 0; y < h; y++) {\\n            for (int x = 0, cx = -1; x < w; x++) {\\n                if (matrix[y][x] == \\'0\\') dp[y][x] = 0;\\n                else {\\n                    if (cx < x) {\\n                        cx = x;\\n                        while (cx < w && matrix[y][cx] == \\'1\\') cx++;\\n                    }\\n                    dp[y][x] = (cx - x);\\n                }\\n            }\\n        }\\n\\t\\t// parsing to find the largest square\\n        for (int y = 0, maxX, diffY, currSide; y < h; y++) {\\n            for (int x = 0, cy; x < w; x++) {\\n                // looking for nodes here\\n                if (dp[y][x] > maxSide) {\\n                    cy = y--;\\n                    maxX = dp[cy][x];\\n                    maxSide = max(maxSide, 1);\\n                    res = max(res, 1);\\n\\t\\t\\t\\t\\t// going down as long as we have non 0 cells and are in the bounds of matrix\\n                    while (++cy < h && dp[cy][x]) {\\n                        maxX = min(maxX, dp[cy][x]);\\n                        diffY = cy - y;\\n                        currSide = min(maxX, diffY);\\n                        // cutting short when it makes no sense to continue\\n                        if (diffY > maxX || maxX < maxSide) break;\\n                        maxSide = max(maxSide, currSide);\\n                    }\\n                    y++;\\n                }\\n            }\\n        }\\n        return maxSide * maxSide;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1632842,
                "title": "c-dynamic-programming-bottom-up-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n       \\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,0));\\n        int ans = 0;\\n        for(int i=m-1;i>=0;i--){\\n            for(int j=n-1;j>=0;j--){\\n                if(i == m-1 || j == n-1){\\n                    dp[i][j] = matrix[i][j] - \\'0\\';\\n                }else{\\n                    if(matrix[i][j] == \\'1\\'){\\n                        int right = dp[i][j+1];\\n                        int bottom = dp[i+1][j];\\n                        int diagonal = dp[i+1][j+1];\\n                        dp[i][j] = min(min(right,bottom),diagonal)+1;\\n                    }\\n                }\\n                ans = max(ans,dp[i][j]);\\n            }\\n        }\\n        return ans*ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n       \\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        vector<vector<int>>dp(m,vector<int>(n,0));\\n        int ans = 0;\\n        for(int i=m-1;i>=0;i--){\\n            for(int j=n-1;j>=0;j--){\\n                if(i == m-1 || j == n-1){\\n                    dp[i][j] = matrix[i][j] - \\'0\\';\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1632292,
                "title": "python3-dp-solution-easy-clean-code-with-detailed-comments-and-algo-draft",
                "content": "__DP solution in O(M * N)__\\n- The challenging part is really how you design your DP table;\\n\\n- I came up this solution beacuase I realize the 3 * 3 square can be \\ncontructed by three 2 * 2 square plus the lower right conor 1;\\n\\n![image](https://assets.leetcode.com/users/images/35881d87-f35d-49cd-a891-463facb150ad_1639719177.8418624.png)\\n\\n```\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        # get matrix bound \\n        ROW, COL = len(matrix), len(matrix[0])\\n        # build dp table for our 0,1 matrix\\n        dp = [[ 0 for _ in range(COL)] for _ in range(ROW)]\\n        max_edge = 0\\n        # helper method for extracting dp table cell value with edge insurance\\n        def get_cell(x, y):\\n            if x < 0 or y < 0:\\n                return 0\\n            else:\\n                return dp[x][y]\\n        \\n        # dp[i,j]: maximum edge of a square using i, j as lower right conor.\\n        # dp[i,j] = min(dp[i-1,j], dp[i,j-1], dp[i-1,j-1]) + 1\\n        # use our state transform equation to update the DP table\\n        for r in range(ROW):\\n            for c in range(COL):\\n                # if current cell value is 0, we simply skip it, since it can not construct a 1 square\\n                if matrix[r][c] == \\'1\\': # caution it is a string \\'1\\'\\n                    # only update the dp table when the value of the current cell is 1\\n                    dp[r][c] = min(get_cell(r-1,c), get_cell(r,c-1), get_cell(r-1,c-1)) + 1\\n                    # update the max_edge while iterating\\n                    \\n                    max_edge = max(max_edge, dp[r][c])\\n        print(dp)\\n        # square the edge for the area \\n        return max_edge ** 2       \\n        \\n                \\n                \\n                \\n    \\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        # get matrix bound \\n        ROW, COL = len(matrix), len(matrix[0])\\n        # build dp table for our 0,1 matrix\\n        dp = [[ 0 for _ in range(COL)] for _ in range(ROW)]\\n        max_edge = 0\\n        # helper method for extracting dp table cell value with edge insurance\\n        def get_cell(x, y):\\n            if x < 0 or y < 0:\\n                return 0\\n            else:\\n                return dp[x][y]\\n        \\n        # dp[i,j]: maximum edge of a square using i, j as lower right conor.\\n        # dp[i,j] = min(dp[i-1,j], dp[i,j-1], dp[i-1,j-1]) + 1\\n        # use our state transform equation to update the DP table\\n        for r in range(ROW):\\n            for c in range(COL):\\n                # if current cell value is 0, we simply skip it, since it can not construct a 1 square\\n                if matrix[r][c] == \\'1\\': # caution it is a string \\'1\\'\\n                    # only update the dp table when the value of the current cell is 1\\n                    dp[r][c] = min(get_cell(r-1,c), get_cell(r,c-1), get_cell(r-1,c-1)) + 1\\n                    # update the max_edge while iterating\\n                    \\n                    max_edge = max(max_edge, dp[r][c])\\n        print(dp)\\n        # square the edge for the area \\n        return max_edge ** 2       \\n        \\n                \\n                \\n                \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1632249,
                "title": "2d-range-sum-binary-search-time-o-r-c-log-min-r-c",
                "content": "Obviously, my solution is not an optimal solution. However, I hope this helps to give someone the idea or new toolbox for this type of this problem.\\n\\nIn this post, I use 2D-Range sum & binary search.\\n\\nIf you check the existence of the square with the size of k x k from k = 1 to k = min(R, C), it\\'s gonna take O(R * C * min(R, C)), and you\\'ll get TLE. So, the idea here is that you look for the maximum k by using binary search. k can be 1 to min(R, C), so it\\'ll take O(R*C*log(min(R, C))) and it\\'s faster.\\n\\nIn order to judge if there is a square of size k whose upper left corder\\'s coordinate is (i, j), we use 2-D range sum.\\nsum_matrix[i][j] denotes the number of \\'1\\'s from (0, 0) to (i, j). Here, you can write the formula, \\n`(The number of \\'1\\'s in the square of size k whose upper left corner is (i, j)) = sum_matrix[i + k - 1][j + k - 1] + sum_matrix[i - 1][j - 1] - sum_matrix[i - 1][j + k - 1] - sum_matrix[i + k - 1][j - 1]`\\n\\nIn the diagram below, this corresponds to (yellow area) = a + b - c - d\\n\\nBy using this formula, you can check if there is a square or not in O(1) time.\\n\\n ![image](https://assets.leetcode.com/users/images/bd0b6eac-1e42-43c9-8b42-ca7ec558c4ad_1639717161.1701272.jpeg)\\n\\n\\n```\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        def exist(k):\\n            for i in range(R):\\n                if i + k - 1 >= R:\\n                    break\\n                for j in range(C):\\n                    if j + k - 1 >= C:\\n                        break\\n                    a = sum_matrix[i + k - 1][j + k - 1]\\n                    b = sum_matrix[i - 1][j - 1] if i > 0 and j > 0 else 0\\n                    c = sum_matrix[i - 1][j + k - 1] if i > 0 else 0\\n                    d = sum_matrix[i + k - 1][j - 1] if j > 0 else 0\\n                    if a + b - c - d == k ** 2:\\n                        return True\\n            return False\\n            \\n        R, C = len(matrix), len(matrix[0])\\n        #create sum_matrix\\n        sum_matrix = [[0 for _ in range(C)] for _ in range(R)]\\n        sum_matrix[0][0] = (matrix[0][0] == \\'1\\')\\n        for j in range(1, C):\\n            sum_matrix[0][j] = sum_matrix[0][j - 1] + (matrix[0][j] == \\'1\\')\\n        for i in range(1, R):\\n            sum_matrix[i][0] = sum_matrix[i - 1][0] + (matrix[i][0] == \\'1\\')\\n        for i in range(1, R):\\n            for j in range(1, C):\\n                sum_matrix[i][j] = sum_matrix[i - 1][j] + sum_matrix[i][j - 1] - sum_matrix[i - 1][j - 1] + (matrix[i][j] == \\'1\\')\\n        \\n        #binary search\\n        l, r = 0, min(R, C)\\n        while l < r:\\n            mid = (l + r + 1) // 2\\n            if exist(mid):\\n                l = mid\\n            else:\\n                r = mid - 1\\n        return l ** 2\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        def exist(k):\\n            for i in range(R):\\n                if i + k - 1 >= R:\\n                    break\\n                for j in range(C):\\n                    if j + k - 1 >= C:\\n                        break\\n                    a = sum_matrix[i + k - 1][j + k - 1]\\n                    b = sum_matrix[i - 1][j - 1] if i > 0 and j > 0 else 0\\n                    c = sum_matrix[i - 1][j + k - 1] if i > 0 else 0\\n                    d = sum_matrix[i + k - 1][j - 1] if j > 0 else 0\\n                    if a + b - c - d == k ** 2:\\n                        return True\\n            return False\\n            \\n        R, C = len(matrix), len(matrix[0])\\n        #create sum_matrix\\n        sum_matrix = [[0 for _ in range(C)] for _ in range(R)]\\n        sum_matrix[0][0] = (matrix[0][0] == \\'1\\')\\n        for j in range(1, C):\\n            sum_matrix[0][j] = sum_matrix[0][j - 1] + (matrix[0][j] == \\'1\\')\\n        for i in range(1, R):\\n            sum_matrix[i][0] = sum_matrix[i - 1][0] + (matrix[i][0] == \\'1\\')\\n        for i in range(1, R):\\n            for j in range(1, C):\\n                sum_matrix[i][j] = sum_matrix[i - 1][j] + sum_matrix[i][j - 1] - sum_matrix[i - 1][j - 1] + (matrix[i][j] == \\'1\\')\\n        \\n        #binary search\\n        l, r = 0, min(R, C)\\n        while l < r:\\n            mid = (l + r + 1) // 2\\n            if exist(mid):\\n                l = mid\\n            else:\\n                r = mid - 1\\n        return l ** 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1632085,
                "title": "dfs-python",
                "content": "If we encounter a 1, run the matrix through a series of checks to check if we can expand our square. To check if we can expand to a bigger square, we first need to make sure the spot to the diagonally to the right also equals 1. If this check passes, we need to make sure every spot from that diagonal square up and to the left level spaces equals 1 as well. If this passes all checks, run the same test starting with the diagonal square. If it fails, return the level it is currently on. We take this value and square it to get the area, and track the max are we\\'ve seen so far.\\n```\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        max_square = 0\\n        \\n        def check_square(i, j, level):\\n            if i+1 < len(matrix) and j+1 < len(matrix[i]) and matrix[i+1][j+1] == \\'1\\':\\n                for idx in range(level):\\n                    if matrix[i+1][j-idx] == \\'1\\' and matrix[i-idx][j+1] == \\'1\\':\\n                        continue\\n                    else:\\n                        return level\\n            else:\\n                return level\\n            \\n            return check_square(i+1, j+1, level+1)\\n        \\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[i])):\\n                if matrix[i][j] == \\'1\\':\\n                    max_square = max(max_square, (check_square(i, j, 1))**2)\\n        \\n        return max_square\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        max_square = 0\\n        \\n        def check_square(i, j, level):\\n            if i+1 < len(matrix) and j+1 < len(matrix[i]) and matrix[i+1][j+1] == \\'1\\':\\n                for idx in range(level):\\n                    if matrix[i+1][j-idx] == \\'1\\' and matrix[i-idx][j+1] == \\'1\\':\\n                        continue\\n                    else:\\n                        return level\\n            else:\\n                return level\\n            \\n            return check_square(i+1, j+1, level+1)\\n        \\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[i])):\\n                if matrix[i][j] == \\'1\\':\\n                    max_square = max(max_square, (check_square(i, j, 1))**2)\\n        \\n        return max_square\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1631158,
                "title": "c-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[301][301];\\n    int ans = 0;\\n    int solve(vector<vector<char>> &matrix, int i, int j, int m, int n)\\n    {\\n        if(i<0 || i>=m || j<0 || j>=n || matrix[i][j] == \\'0\\')\\n            return 0;\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        int down = solve(matrix, i+1, j, m, n);\\n        int right = solve(matrix, i, j+1, m, n);\\n        int diagonal = solve(matrix, i+1, j+1, m, n);\\n        return dp[i][j] = 1 + min(min(down, right), diagonal);\\n        \\n    }\\n    int maximalSquare(vector<vector<char>> &matrix) \\n    {\\n        memset(dp, -1, sizeof(dp));\\n        for(int i=0; i<matrix.size(); i++)\\n            for(int j=0; j<matrix[0].size(); j++)\\n                if(matrix[i][j] == \\'1\\')\\n                    ans = max(ans, solve(matrix, i, j, matrix.size(), matrix[0].size()));\\n        return ans*ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[301][301];\\n    int ans = 0;\\n    int solve(vector<vector<char>> &matrix, int i, int j, int m, int n)\\n    {\\n        if(i<0 || i>=m || j<0 || j>=n || matrix[i][j] == \\'0\\')\\n            return 0;\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        int down = solve(matrix, i+1, j, m, n);\\n        int right = solve(matrix, i, j+1, m, n);\\n        int diagonal = solve(matrix, i+1, j+1, m, n);\\n        return dp[i][j] = 1 + min(min(down, right), diagonal);\\n        \\n    }\\n    int maximalSquare(vector<vector<char>> &matrix) \\n    {\\n        memset(dp, -1, sizeof(dp));\\n        for(int i=0; i<matrix.size(); i++)\\n            for(int j=0; j<matrix[0].size(); j++)\\n                if(matrix[i][j] == \\'1\\')\\n                    ans = max(ans, solve(matrix, i, j, matrix.size(), matrix[0].size()));\\n        return ans*ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1596943,
                "title": "maximum-area-in-histogram",
                "content": "```\\n//THIS CAN EASILY BE DONE BY \"maximum area of histogram\" method that we did in \"maxiumal rectangle question\"\\n    // The below code is the exact copy of: https://leetcode.com/problems/maximal-rectangle/\\n    \\n    //\\uD83D\\uDEA8NOTE\\uD83D\\uDEA8-->  The only difference is that, in histogram we will take the minimum of height and length as the side of square\\n    \\n    int maxAreaHist(vector<int>heights){\\n        \\n        int n = heights.size();\\n        \\n        vector<int> nse(n,n); NSE(nse,heights);\\n        \\n        vector<int> pse(n,-1); PSE(pse, heights);\\n        \\n        int maxi = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            int length = nse[i] - pse[i] - 1;\\n            int height = heights[i];\\n            \\n            int sideOfSquare = min(length, height);//\\uD83D\\uDEA8\\uD83D\\uDEA8\\uD83D\\uDEA8\\uD83D\\uDEA8 THE ONLY DIFFERENCE! OTHERWISE EXACLY SAME \\uD83D\\uDEA8\\uD83D\\uDEA8\\uD83D\\uDEA8\\uD83D\\uDEA8\\n            \\n            maxi = max(maxi,sideOfSquare*sideOfSquare );\\n        }\\n            \\n        \\n        return maxi;\\n    }\\n    \\n    \\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        \\n        int maxiSquareArea = 0;\\n        \\n        int R = matrix.size(); if(R==0) return 0;\\n        int C = matrix[0].size();\\n        \\n        vector<int> heights (C, 0);\\n        \\n        for(int i = 0; i<R;i++){\\n            for(int j=0;j<C;j++){\\n                if(matrix[i][j]==\\'1\\')   heights[j]+=1;\\n                else heights[j] = 0;\\n            }\\n            \\n            maxiSquareArea = max(maxiSquareArea,maxAreaHist(heights) );\\n        }\\n        \\n        return maxiSquareArea;\\n        \\n    }\\n    \\n    \\nvoid NSE(vector<int>& nse, vector<int>& nums){\\n        int n = nums.size();\\n        \\n        deque<int> mini;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            while(mini.size() && nums[i] < nums[mini.back()])\\n            {\\n                nse[mini.back()] = i;\\n                mini.pop_back();\\n            }\\n            \\n            mini.push_back(i);\\n        }\\n        \\n        return; \\n    }\\n        \\nvoid PSE(vector<int>& pse, vector<int>& nums){\\n        int n = nums.size();\\n        \\n        deque<int> mini;\\n        \\n        for(int i=n-1;i>-1;i--){\\n            \\n            while(mini.size() && nums[i] < nums[mini.back()])\\n            {\\n                pse[mini.back()] = i;\\n                mini.pop_back();\\n            }\\n            \\n            mini.push_back(i);\\n        }\\n        \\n        return; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//THIS CAN EASILY BE DONE BY \"maximum area of histogram\" method that we did in \"maxiumal rectangle question\"\\n    // The below code is the exact copy of: https://leetcode.com/problems/maximal-rectangle/\\n    \\n    //\\uD83D\\uDEA8NOTE\\uD83D\\uDEA8-->  The only difference is that, in histogram we will take the minimum of height and length as the side of square\\n    \\n    int maxAreaHist(vector<int>heights){\\n        \\n        int n = heights.size();\\n        \\n        vector<int> nse(n,n); NSE(nse,heights);\\n        \\n        vector<int> pse(n,-1); PSE(pse, heights);\\n        \\n        int maxi = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            int length = nse[i] - pse[i] - 1;\\n            int height = heights[i];\\n            \\n            int sideOfSquare = min(length, height);//\\uD83D\\uDEA8\\uD83D\\uDEA8\\uD83D\\uDEA8\\uD83D\\uDEA8 THE ONLY DIFFERENCE! OTHERWISE EXACLY SAME \\uD83D\\uDEA8\\uD83D\\uDEA8\\uD83D\\uDEA8\\uD83D\\uDEA8\\n            \\n            maxi = max(maxi,sideOfSquare*sideOfSquare );\\n        }\\n            \\n        \\n        return maxi;\\n    }\\n    \\n    \\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        \\n        int maxiSquareArea = 0;\\n        \\n        int R = matrix.size(); if(R==0) return 0;\\n        int C = matrix[0].size();\\n        \\n        vector<int> heights (C, 0);\\n        \\n        for(int i = 0; i<R;i++){\\n            for(int j=0;j<C;j++){\\n                if(matrix[i][j]==\\'1\\')   heights[j]+=1;\\n                else heights[j] = 0;\\n            }\\n            \\n            maxiSquareArea = max(maxiSquareArea,maxAreaHist(heights) );\\n        }\\n        \\n        return maxiSquareArea;\\n        \\n    }\\n    \\n    \\nvoid NSE(vector<int>& nse, vector<int>& nums){\\n        int n = nums.size();\\n        \\n        deque<int> mini;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            while(mini.size() && nums[i] < nums[mini.back()])\\n            {\\n                nse[mini.back()] = i;\\n                mini.pop_back();\\n            }\\n            \\n            mini.push_back(i);\\n        }\\n        \\n        return; \\n    }\\n        \\nvoid PSE(vector<int>& pse, vector<int>& nums){\\n        int n = nums.size();\\n        \\n        deque<int> mini;\\n        \\n        for(int i=n-1;i>-1;i--){\\n            \\n            while(mini.size() && nums[i] < nums[mini.back()])\\n            {\\n                pse[mini.back()] = i;\\n                mini.pop_back();\\n            }\\n            \\n            mini.push_back(i);\\n        }\\n        \\n        return; \\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1588099,
                "title": "python-solution-dp-bottom-up-suitable-comments",
                "content": "```\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n\\t   \\'\\'\\' \\n\\t\\t   Time : O(n*m) \\n\\t\\t   Idea : Every cell of matrix represent the square possible of length cell-val with that cell as bottom-right cell in that square\\n\\t   \\'\\'\\'\\n\\t   # use matrix as dp to save space\\n        ROWS, COLS = len(matrix), len(matrix[0])\\n        for i in range(ROWS):\\n            for j in range(COLS):\\n                if not(i and j):  # for first row & col\\n                    matrix[i][j] = int(matrix[i][j])\\n                    continue\\n                if matrix[i][j] == \\'0\\': # constraints as per problem\\n                    matrix[i][j] = 0\\n                    continue\\n\\t\\t\\t\\t\\t\\n                # explore cell (i, j) as bottom-right cell for possible square\\n                diagTopLeft = matrix[i-1][j-1]\\n                top = matrix[i-1][j]\\n                left = matrix[i][j-1]\\n\\t\\t\\t\\t# update matrix aka dp here\\n                matrix[i][j] = 1 + min(diagTopLeft, top, left)  # 1 minimum ie self itself of length 1\\n\\n        return max(itertools.chain(*matrix))**2\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n\\t   \\'\\'\\' \\n\\t\\t   Time : O(n*m) \\n\\t\\t   Idea : Every cell of matrix represent the square possible of length cell-val with that cell as bottom-right cell in that square\\n\\t   \\'\\'\\'\\n\\t   # use matrix as dp to save space\\n        ROWS, COLS = len(matrix), len(matrix[0])\\n        for i in range(ROWS):\\n            for j in range(COLS):\\n                if not(i and j):  # for first row & col\\n                    matrix[i][j] = int(matrix[i][j])\\n                    continue\\n                if matrix[i][j] == \\'0\\': # constraints as per problem\\n                    matrix[i][j] = 0\\n                    continue\\n\\t\\t\\t\\t\\t\\n                # explore cell (i, j) as bottom-right cell for possible square\\n                diagTopLeft = matrix[i-1][j-1]\\n                top = matrix[i-1][j]\\n                left = matrix[i][j-1]\\n\\t\\t\\t\\t# update matrix aka dp here\\n                matrix[i][j] = 1 + min(diagTopLeft, top, left)  # 1 minimum ie self itself of length 1\\n\\n        return max(itertools.chain(*matrix))**2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1413319,
                "title": "c-dp-solution-with-explanation-diagrams",
                "content": "Logic : \\n1. We traverse the array normally and keep track of the largest side length of the square we can form at `dp[i][j]`\\n![image](https://assets.leetcode.com/users/images/e6b1c939-4bcf-4991-873b-8530f4feeac9_1629375252.2617404.png)\\n\\nIf any of the `1s` would have been 0 then the square of 2*2 would not have been possible . And this is checked via the `min of all the 3 blocks +1` \\n\\nSimilary for 3*3 it would have been something like this \\n![image](https://assets.leetcode.com/users/images/2a3dc777-21c1-46f0-a4c5-2228beff5fe8_1629375565.619509.png)\\n\\n\\n```\\nint maximalSquare(vector<vector<char>>& matrix) {\\n        int m= matrix.size() , n=matrix[0].size();\\n       vector<vector<int>>dp(m,vector<int>(n,0));\\n        int res=0;\\n        for(int i=0 ; i<m ;i++){\\n            \\n            for(int j=0 ;j<n ;j++){\\n                \\n                if(matrix[i][j]==\\'1\\'){\\n                    \\n                    if(i==0 || j==0)  // If Bounday elements then max is 1\\n                    dp[i][j]=1;\\n                else\\n                    dp[i][j]=1+ min({dp[i-1][j] , dp[i][j-1] , dp[i-1][j-1]});   // This conditon is to check whether all the rest are valid or not \\n                }\\n                \\n                res=max(res,dp[i][j]);\\n            }\\n        }\\n        \\n        return pow(res,2);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint maximalSquare(vector<vector<char>>& matrix) {\\n        int m= matrix.size() , n=matrix[0].size();\\n       vector<vector<int>>dp(m,vector<int>(n,0));\\n        int res=0;\\n        for(int i=0 ; i<m ;i++){\\n            \\n            for(int j=0 ;j<n ;j++){\\n                \\n                if(matrix[i][j]==\\'1\\'){\\n                    \\n                    if(i==0 || j==0)  // If Bounday elements then max is 1\\n                    dp[i][j]=1;\\n                else\\n                    dp[i][j]=1+ min({dp[i-1][j] , dp[i][j-1] , dp[i-1][j-1]});   // This conditon is to check whether all the rest are valid or not \\n                }\\n                \\n                res=max(res,dp[i][j]);\\n            }\\n        }\\n        \\n        return pow(res,2);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1357283,
                "title": "java-dp-solution-o-n-m-time-complexity-faster-than-100",
                "content": "**Do vote up if you like it :)**\\n```\\nclass Solution {\\n    public int maximalSquare(char[][] matrix) {\\n        int max = 0;\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int[][] dp = new int[n][m];\\n        \\n        for(int i = n - 1; i >= 0; i--) {\\n            for(int j = m - 1; j >= 0; j--) {\\n                if(i == n - 1 || j == m - 1) {\\n                    if(matrix[i][j] == \\'1\\') { \\n                        dp[i][j] = 1;\\n                        max = Math.max(max, dp[i][j]);\\n                    }\\n                    continue;\\n                }\\n                \\n                else if(matrix[i][j] == \\'0\\') {\\n                    continue;\\n                }\\n                \\n                dp[i][j] = Math.min(dp[i + 1][j + 1], Math.min(dp[i + 1][j], dp[i][j + 1])) + 1;\\n                max = Math.max(max, dp[i][j]);\\n            }\\n        }\\n        return max * max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximalSquare(char[][] matrix) {\\n        int max = 0;\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int[][] dp = new int[n][m];\\n        \\n        for(int i = n - 1; i >= 0; i--) {\\n            for(int j = m - 1; j >= 0; j--) {\\n                if(i == n - 1 || j == m - 1) {\\n                    if(matrix[i][j] == \\'1\\') { \\n                        dp[i][j] = 1;\\n                        max = Math.max(max, dp[i][j]);\\n                    }\\n                    continue;\\n                }\\n                \\n                else if(matrix[i][j] == \\'0\\') {\\n                    continue;\\n                }\\n                \\n                dp[i][j] = Math.min(dp[i + 1][j + 1], Math.min(dp[i + 1][j], dp[i][j + 1])) + 1;\\n                max = Math.max(max, dp[i][j]);\\n            }\\n        }\\n        return max * max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1337862,
                "title": "c-dp",
                "content": "```\\nint maximalSquare(vector<vector<char>>& matrix) \\n    {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int res = 0;\\n        vector<vector<int>> t(m + 1, vector<int>(n + 1, 0));\\n     \\n        for(int i = 1; i <= m; i++)\\n        {\\n            for(int j = 1; j <= n; j++)\\n            {\\n                if(matrix[i - 1][j - 1] == \\'1\\')\\n                {\\n                    t[i][j] = min(min(t[i - 1][j - 1], t[i - 1][j]),  t[i][j - 1]) + 1;\\n                    res = max(res, t[i][j]);\\n                }\\n            }\\n        }\\n        return res * res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint maximalSquare(vector<vector<char>>& matrix) \\n    {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int res = 0;\\n        vector<vector<int>> t(m + 1, vector<int>(n + 1, 0));\\n     \\n        for(int i = 1; i <= m; i++)\\n        {\\n            for(int j = 1; j <= n; j++)\\n            {\\n                if(matrix[i - 1][j - 1] == \\'1\\')\\n                {\\n                    t[i][j] = min(min(t[i - 1][j - 1], t[i - 1][j]),  t[i][j - 1]) + 1;\\n                    res = max(res, t[i][j]);\\n                }\\n            }\\n        }\\n        return res * res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1291406,
                "title": "python-dp-solution-faster-than-93-lower-memory-than-73",
                "content": "```\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        \\n        dp = [[int(matrix[i][j]) for j in range(len(matrix[0]))] for i in range(len(matrix))]\\n        \\n        for i in range(1, len(dp)):\\n            for j in range(1, len(dp[0])):\\n                \\n                if matrix[i][j] == \"1\":\\n                    dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\\n                \\n        \\n        return max(max(dp, key=lambda x: max(x)))**2\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        \\n        dp = [[int(matrix[i][j]) for j in range(len(matrix[0]))] for i in range(len(matrix))]\\n        \\n        for i in range(1, len(dp)):\\n            for j in range(1, len(dp[0])):\\n                \\n                if matrix[i][j] == \"1\":\\n                    dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\\n                \\n        \\n        return max(max(dp, key=lambda x: max(x)))**2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1136050,
                "title": "simple-dp-solution-using-2d-matrix-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& m) {\\n        int R = m.size();\\n        int C = m[0].size();\\n        int dp[R][C];\\n        for(int i = 0;i<R;i++){\\n            for(int j = 0;j<C;j++)  dp[i][j] = 0;\\n        }\\n        bool ok = false;\\n        for(int i = 0;i<R;i++){\\n            if(m[i][0] == \\'1\\')  ok = true;\\n            dp[i][0] = (m[i][0] == \\'1\\' ? 1 : 0);\\n        }\\n        for(int j = 0;j<C;j++){\\n            if(m[0][j] == \\'1\\')  ok = true;\\n            dp[0][j] = (m[0][j] == \\'1\\' ? 1 : 0);\\n        }\\n        int res = ok;\\n        for(int i = 1;i<R;i++){\\n            for(int j = 1;j<C;j++){\\n                if(m[i][j] == \\'0\\')  dp[i][j] = 0;\\n                else{\\n                    dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;\\n                    res = max(res, dp[i][j]);\\n                }\\n            }\\n        }\\n        return res*res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& m) {\\n        int R = m.size();\\n        int C = m[0].size();\\n        int dp[R][C];\\n        for(int i = 0;i<R;i++){\\n            for(int j = 0;j<C;j++)  dp[i][j] = 0;\\n        }\\n        bool ok = false;\\n        for(int i = 0;i<R;i++){\\n            if(m[i][0] == \\'1\\')  ok = true;\\n            dp[i][0] = (m[i][0] == \\'1\\' ? 1 : 0);\\n        }\\n        for(int j = 0;j<C;j++){\\n            if(m[0][j] == \\'1\\')  ok = true;\\n            dp[0][j] = (m[0][j] == \\'1\\' ? 1 : 0);\\n        }\\n        int res = ok;\\n        for(int i = 1;i<R;i++){\\n            for(int j = 1;j<C;j++){\\n                if(m[i][j] == \\'0\\')  dp[i][j] = 0;\\n                else{\\n                    dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;\\n                    res = max(res, dp[i][j]);\\n                }\\n            }\\n        }\\n        return res*res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119525,
                "title": "c-brute-force-tle-70-73",
                "content": "This solution is too slow, but the thought process is easy to understand.\\nFeel free to comment a way to make it faster and accepted.\\n```\\npublic class Solution {\\n    public int MaximalSquare(char[][] matrix) {\\n        int maxArea = int.MinValue;\\n\\n        List<(int i, int j)> points = new List<(int, int)>();\\n\\n        // Get every point\\n        for (int i = 0; i < matrix.Length; i++) {\\n            for (int j = 0; j < matrix[0].Length; j++) {                \\n                points.Add((i, j));\\n            }\\n        }\\n        \\n        // Every pair of points\\n        for (int i = 0; i < points.Count; i++) {\\n            for (int j = 0; j < points.Count; j++) {\\n                // If it\\'s not an m x m square, don\\'t check the area\\n                if (points[j].i - points[i].i != points[j].j - points[i].j) continue;\\n                \\n                maxArea = Math.Max(maxArea, CountArea(points[i], points[j], matrix));\\n            }\\n        }\\n        return maxArea;\\n    }\\n    \\n\\t// Return the area between 2 points in the matrix\\n    private int CountArea((int i, int j) begin, (int i, int j) end, char[][] matrix) {\\n        int count = 0;\\n        \\n        int x1 = begin.i;\\n        int y1 = begin.j;\\n        int x2 = end.i;\\n        int y2 = end.j;\\n\\n        for (int i = x1; i <= x2; i++) {\\n            for (int j = y1; j <= y2; j++) {\\n                // Invalid square\\n                if (matrix[i][j] != \\'1\\') return 0;\\n                count++;\\n            }\\n        }\\n       \\n        return count;\\n    }  \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MaximalSquare(char[][] matrix) {\\n        int maxArea = int.MinValue;\\n\\n        List<(int i, int j)> points = new List<(int, int)>();\\n\\n        // Get every point\\n        for (int i = 0; i < matrix.Length; i++) {\\n            for (int j = 0; j < matrix[0].Length; j++) {                \\n                points.Add((i, j));\\n            }\\n        }\\n        \\n        // Every pair of points\\n        for (int i = 0; i < points.Count; i++) {\\n            for (int j = 0; j < points.Count; j++) {\\n                // If it\\'s not an m x m square, don\\'t check the area\\n                if (points[j].i - points[i].i != points[j].j - points[i].j) continue;\\n                \\n                maxArea = Math.Max(maxArea, CountArea(points[i], points[j], matrix));\\n            }\\n        }\\n        return maxArea;\\n    }\\n    \\n\\t// Return the area between 2 points in the matrix\\n    private int CountArea((int i, int j) begin, (int i, int j) end, char[][] matrix) {\\n        int count = 0;\\n        \\n        int x1 = begin.i;\\n        int y1 = begin.j;\\n        int x2 = end.i;\\n        int y2 = end.j;\\n\\n        for (int i = x1; i <= x2; i++) {\\n            for (int j = y1; j <= y2; j++) {\\n                // Invalid square\\n                if (matrix[i][j] != \\'1\\') return 0;\\n                count++;\\n            }\\n        }\\n       \\n        return count;\\n    }  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 981093,
                "title": "python-dp-with-easy-implementation",
                "content": "```\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        dp = [[0] * (len(matrix[0]) + 1) for i in range(len(matrix) + 1)]\\n        max_edge = 0\\n        for i in range(1, len(matrix) + 1):\\n            for j in range(1, len(matrix[0]) + 1):\\n                if matrix[i-1][j-1] == \\'1\\':\\n                    dp[i][j] = min([dp[i-1][j], dp[i][j-1], dp[i-1][j-1]]) + 1\\n                    max_edge = max(max_edge, dp[i][j])\\n        \\n        return max_edge * max_edge\\n```",
                "solutionTags": [],
                "code": "```\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        dp = [[0] * (len(matrix[0]) + 1) for i in range(len(matrix) + 1)]\\n        max_edge = 0\\n        for i in range(1, len(matrix) + 1):\\n            for j in range(1, len(matrix[0]) + 1):\\n                if matrix[i-1][j-1] == \\'1\\':\\n                    dp[i][j] = min([dp[i-1][j], dp[i][j-1], dp[i-1][j-1]]) + 1\\n                    max_edge = max(max_edge, dp[i][j])\\n        \\n        return max_edge * max_edge\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 928864,
                "title": "python3-dp-simple-solution",
                "content": "Please +1 if you find it helpful.\\n```\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        if len(matrix)==0 or len(matrix[0])==0:\\n            return 0\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        maxLen = 0\\n\\n        # initialize the dp\\n        dp=[[0]*(len(matrix[0])+1) for i in range(len(matrix)+1)]\\n\\n        # start putting in the values\\n        for i in range(1,m+1):\\n            for j in range(1,n+1):\\n                if (matrix[i-1][j-1]) == \\'1\\':\\n                    dp[i][j]=min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1\\n                    maxLen = max(maxLen, dp[i][j])\\n\\n        return maxLen*maxLen\\n\\t\\t\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        if len(matrix)==0 or len(matrix[0])==0:\\n            return 0\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        maxLen = 0\\n\\n        # initialize the dp\\n        dp=[[0]*(len(matrix[0])+1) for i in range(len(matrix)+1)]\\n\\n        # start putting in the values\\n        for i in range(1,m+1):\\n            for j in range(1,n+1):\\n                if (matrix[i-1][j-1]) == \\'1\\':\\n                    dp[i][j]=min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1\\n                    maxLen = max(maxLen, dp[i][j])\\n\\n        return maxLen*maxLen\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 906134,
                "title": "100-faster-dp-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& a) {\\n        int m=a.size();\\n        if(m==0)\\n            return 0;\\n        int n=a[0].size();\\n        int ans=0;\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n            {\\n                if(a[i][j] !=\\'0\\' && i>0 && j>0)\\n                {\\n                    a[i][j]=1+min(a[i-1][j],min(a[i-1][j-1],a[i][j-1]));\\n                    ans=max(ans,(int)a[i][j]-48);\\n                }\\n                else\\n                {\\n                    if(a[i][j] !=\\'0\\')\\n                      ans=max(ans,(int)a[i][j]-48);  \\n                }\\n            }\\n        return ans*ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& a) {\\n        int m=a.size();\\n        if(m==0)\\n            return 0;\\n        int n=a[0].size();\\n        int ans=0;\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n            {\\n                if(a[i][j] !=\\'0\\' && i>0 && j>0)\\n                {\\n                    a[i][j]=1+min(a[i-1][j],min(a[i-1][j-1],a[i][j-1]));\\n                    ans=max(ans,(int)a[i][j]-48);\\n                }\\n                else\\n                {\\n                    if(a[i][j] !=\\'0\\')\\n                      ans=max(ans,(int)a[i][j]-48);  \\n                }\\n            }\\n        return ans*ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 830282,
                "title": "c-beats",
                "content": "Here is O(1) memory solution in cpp. The fact is we don\\'t need dp vector at all.\\uD83D\\uDE43We can use char matrix which is provided in the function. If you have any query please comment below.\\uD83D\\uDC47If you find it helpful then please upvote this \\uD83D\\uDC4D\\n```\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        if(m==0)\\n            return 0;\\n        int n=matrix[0].size();\\n        int ans=0;\\n        for(int i=0;i<m;i++)\\n        {\\n           for(int j=0;j<n;j++)\\n           {\\n               if(matrix[i][j]==\\'1\\')\\n               {\\n                  if(i!=0&&j!=0)\\n                    matrix[i][j]=1+min({matrix[i-1][j]-\\'0\\',matrix[i-1][j-1]-\\'0\\',matrix[i][j-1]-\\'0\\'})+\\'0\\';\\n                  ans=max(ans,matrix[i][j]-\\'0\\');\\n               }\\n\\n           }\\n        }\\n        return ans*ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        int m=matrix.size();\\n        if(m==0)\\n            return 0;\\n        int n=matrix[0].size();\\n        int ans=0;\\n        for(int i=0;i<m;i++)\\n        {\\n           for(int j=0;j<n;j++)\\n           {\\n               if(matrix[i][j]==\\'1\\')\\n               {\\n                  if(i!=0&&j!=0)\\n                    matrix[i][j]=1+min({matrix[i-1][j]-\\'0\\',matrix[i-1][j-1]-\\'0\\',matrix[i][j-1]-\\'0\\'})+\\'0\\';\\n                  ans=max(ans,matrix[i][j]-\\'0\\');\\n               }\\n\\n           }\\n        }\\n        return ans*ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 748165,
                "title": "simple-python-dp",
                "content": "```python\\nclass Solution(object):\\n    def maximalSquare(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        try:\\n            m, n = len(matrix), len(matrix[0])\\n        except IndexError:\\n            return 0\\n\\t\\t\\n\\t\\t# duplicate matrix but convert str to int\\n        dp = [list(map(int, row)) for row in matrix]\\n        res = 0\\n        for i in range(0, m):\\n            for j in range(0, n):\\n                if i and j:\\n                    dp[i][j] = dp[i][j] * (min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1)\\n                res = max(res, dp[i][j])\\n        return res * res\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution(object):\\n    def maximalSquare(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        try:\\n            m, n = len(matrix), len(matrix[0])\\n        except IndexError:\\n            return 0\\n\\t\\t\\n\\t\\t# duplicate matrix but convert str to int\\n        dp = [list(map(int, row)) for row in matrix]\\n        res = 0\\n        for i in range(0, m):\\n            for j in range(0, n):\\n                if i and j:\\n                    dp[i][j] = dp[i][j] * (min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1)\\n                res = max(res, dp[i][j])\\n        return res * res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 738298,
                "title": "javascript-clean-dp-table",
                "content": "```javascript\\nvar maximalSquare = function(matrix) {\\n    if(!matrix.length) return 0;\\n    const R_NUM = matrix.length, C_NUM = matrix[0].length;\\n    const dp = Array.from({length: R_NUM+1}, () => Array(C_NUM+1).fill(0));\\n    let maxLen = 0;\\n    \\n    for(let r = 1; r <= R_NUM; r++) {\\n        for(let c = 1; c <= C_NUM; c++) {\\n            if(!+matrix[r-1][c-1]) continue;\\n            dp[r][c] = Math.min(dp[r-1][c], dp[r][c-1], dp[r-1][c-1]) + 1;\\n            maxLen = Math.max(maxLen, dp[r][c]);\\n        }\\n    }\\n    return maxLen**2;    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```javascript\\nvar maximalSquare = function(matrix) {\\n    if(!matrix.length) return 0;\\n    const R_NUM = matrix.length, C_NUM = matrix[0].length;\\n    const dp = Array.from({length: R_NUM+1}, () => Array(C_NUM+1).fill(0));\\n    let maxLen = 0;\\n    \\n    for(let r = 1; r <= R_NUM; r++) {\\n        for(let c = 1; c <= C_NUM; c++) {\\n            if(!+matrix[r-1][c-1]) continue;\\n            dp[r][c] = Math.min(dp[r-1][c], dp[r][c-1], dp[r-1][c-1]) + 1;\\n            maxLen = Math.max(maxLen, dp[r][c]);\\n        }\\n    }\\n    return maxLen**2;    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 660045,
                "title": "java-bfs-solution-with-explanation",
                "content": "This is neither fast nor space efficient and is probably not what an interviewer is looking for, but I was curious if this could be done with BFS as I didn\\'t see anyone else post one, so I\\'m sharing it here: \\n```\\nclass Solution {\\n    public int maximalSquare(char[][] m) {\\n        if (m.length == 0 || m == null) return 0;\\n        int rows = m.length; int cols = m[0].length; \\n        int res = 0;\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (m[i][j] == \\'1\\') {\\n                    int sizeOfPotentialSquare = BFS(m, i, j); \\n                    res = Math.max(res, sizeOfPotentialSquare);\\n                }\\n            } \\n        }\\n        return res;\\n    }\\n    \\n    public int BFS(char[][] grid, int i, int j) {\\n        Queue<int[]> q = new LinkedList<>();\\n        int[][] dir = new int[][]{{1, 0}, {1, 1}, {0, 1}};\\n        q.add(new int[]{i, j}); \\n        int cycle = 1;\\n        int maxSquareSize = 1;\\n        \\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int k = 0; k < size; k++) {\\n                int[] curr = q.poll(); int x = curr[0]; int y = curr[1]; \\n                for (int[] d: dir) {\\n                    int newX = x + d[0]; int newY = y + d[1];\\n\\t\\t\\t\\t\\t// If we will go out of bounds or detect a potential 0 that will be in our new bottom right layer\\n\\t\\t\\t\\t\\t// the next iteration cannot possibly be a square, so we return our current square size \\n                    if (newX < 0 || newX >= grid.length || newY < 0 || newY >= grid[0].length || grid[newX][newY] == \\'0\\') {\\n                        return maxSquareSize;\\n                    }\\n                    else {\\n                        q.add(new int[]{newX, newY});\\n                    }\\n                }\\n            }\\n\\t\\t\\t/* \\n\\t\\t\\tIf we reach these lines, everything in the queue will build the next bottom right layer of our square\\n\\t\\t\\tA Square can only be of size 1, 4, 9, 16, ... etc. \\n\\t\\t\\tSo we increment the cycle by 1 and then square it to get the max square size \\n\\t\\t\\t*/\\n            cycle++; \\n            maxSquareSize = cycle * cycle; // \\n        }\\n        return maxSquareSize;\\n    }\\n}\\n```\\n\\nI was stuck on how I could check if what I found was a square or not, until I realized that if we only add a grid\\'s bottom, right, and bottom-right diagonal as the next search direction in our queue, the search \\'pattern\\' forms a perfect square. Any potential grids that have a 0 will mean the next iteration will not form a perfect square, so we break early.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximalSquare(char[][] m) {\\n        if (m.length == 0 || m == null) return 0;\\n        int rows = m.length; int cols = m[0].length; \\n        int res = 0;\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (m[i][j] == \\'1\\') {\\n                    int sizeOfPotentialSquare = BFS(m, i, j); \\n                    res = Math.max(res, sizeOfPotentialSquare);\\n                }\\n            } \\n        }\\n        return res;\\n    }\\n    \\n    public int BFS(char[][] grid, int i, int j) {\\n        Queue<int[]> q = new LinkedList<>();\\n        int[][] dir = new int[][]{{1, 0}, {1, 1}, {0, 1}};\\n        q.add(new int[]{i, j}); \\n        int cycle = 1;\\n        int maxSquareSize = 1;\\n        \\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int k = 0; k < size; k++) {\\n                int[] curr = q.poll(); int x = curr[0]; int y = curr[1]; \\n                for (int[] d: dir) {\\n                    int newX = x + d[0]; int newY = y + d[1];\\n\\t\\t\\t\\t\\t// If we will go out of bounds or detect a potential 0 that will be in our new bottom right layer\\n\\t\\t\\t\\t\\t// the next iteration cannot possibly be a square, so we return our current square size \\n                    if (newX < 0 || newX >= grid.length || newY < 0 || newY >= grid[0].length || grid[newX][newY] == \\'0\\') {\\n                        return maxSquareSize;\\n                    }\\n                    else {\\n                        q.add(new int[]{newX, newY});\\n                    }\\n                }\\n            }\\n\\t\\t\\t/* \\n\\t\\t\\tIf we reach these lines, everything in the queue will build the next bottom right layer of our square\\n\\t\\t\\tA Square can only be of size 1, 4, 9, 16, ... etc. \\n\\t\\t\\tSo we increment the cycle by 1 and then square it to get the max square size \\n\\t\\t\\t*/\\n            cycle++; \\n            maxSquareSize = cycle * cycle; // \\n        }\\n        return maxSquareSize;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 659065,
                "title": "java-dp-solution-with-detailed-explanation-time-complexity",
                "content": "Please refer video from detailed explaination - \\n[https://www.youtube.com/channel/UCUQjKo3h1fe-uzr_n6Bx7PQ]\\n\\nTime complexity - O( n * m )\\nSpace complexity -O( n * m ) as we are using DP array.\\n\\n```\\nclass Solution {\\n    public int maximalSquare(char[][] matrix) {\\n        if(matrix.length == 0)\\n            return 0;\\n        int max = 0;\\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n        int[][] dp = new int[rows][cols];\\n        for(int i=0; i<rows; i++){\\n            dp[i][0] = matrix[i][0]==\\'0\\'?0:1;\\n            max = Math.max(max, dp[i][0]);\\n        }\\n        for(int i=0; i<cols; i++){\\n            dp[0][i] = matrix[0][i]==\\'0\\'?0:1;\\n            max = Math.max(max, dp[0][i]);\\n        }\\n        \\n        for(int i=1; i<rows; i++){\\n            for(int j=1; j<cols; j++){\\n                if(matrix[i][j] == \\'1\\'){\\n                    dp[i][j] = Math.min(Math.min(dp[i-1][j], dp[i-1][j-1]), dp[i][j-1]) + 1;                       max = Math.max(max, dp[i][j]);\\n                }\\n            }\\n        }\\n        \\n        return max*max;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximalSquare(char[][] matrix) {\\n        if(matrix.length == 0)\\n            return 0;\\n        int max = 0;\\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n        int[][] dp = new int[rows][cols];\\n        for(int i=0; i<rows; i++){\\n            dp[i][0] = matrix[i][0]==\\'0\\'?0:1;\\n            max = Math.max(max, dp[i][0]);\\n        }\\n        for(int i=0; i<cols; i++){\\n            dp[0][i] = matrix[0][i]==\\'0\\'?0:1;\\n            max = Math.max(max, dp[0][i]);\\n        }\\n        \\n        for(int i=1; i<rows; i++){\\n            for(int j=1; j<cols; j++){\\n                if(matrix[i][j] == \\'1\\'){\\n                    dp[i][j] = Math.min(Math.min(dp[i-1][j], dp[i-1][j-1]), dp[i][j-1]) + 1;                       max = Math.max(max, dp[i][j]);\\n                }\\n            }\\n        }\\n        \\n        return max*max;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 623616,
                "title": "java-dp",
                "content": "```\\npublic int maximalSquare(char[][] mx) {\\n    int m = mx.length, n = mx[0].length, res = 0;\\n    int[][] dp = new int[m + 1][n + 1];\\n    for (int i = 1; i <= m; i++) {\\n        for (int j = 1; j <= n; j++) {\\n            if (mx[i - 1][j - 1] !=\\'1\\') continue;\\n            dp[i][j] = Math.min(dp[i - 1][j], Math.min(dp[i][j - 1], dp[i - 1][j - 1])) + 1;\\n            res = Math.max(res, dp[i][j]);\\n        }\\n    }\\n    return res * res;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int maximalSquare(char[][] mx) {\\n    int m = mx.length, n = mx[0].length, res = 0;\\n    int[][] dp = new int[m + 1][n + 1];\\n    for (int i = 1; i <= m; i++) {\\n        for (int j = 1; j <= n; j++) {\\n            if (mx[i - 1][j - 1] !=\\'1\\') continue;\\n            dp[i][j] = Math.min(dp[i - 1][j], Math.min(dp[i][j - 1], dp[i - 1][j - 1])) + 1;\\n            res = Math.max(res, dp[i][j]);\\n        }\\n    }\\n    return res * res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 619061,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        \\n        if (matrix.empty()) return 0;\\n        \\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        \\n        \\n        vector<vector<int>>v(m, vector<int>(n, 0));\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                v[i][j] = matrix[i][j]-\\'0\\';\\n            }\\n        }\\n        \\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                if (v[i][j])\\n                    v[i][j] += min(min(v[i-1][j], v[i-1][j-1]), v[i][j-1]);\\n            }\\n        }\\n        \\n        int mxval = INT_MIN;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                mxval = max(v[i][j], mxval);\\n            }\\n        }\\n        \\n        return mxval*mxval;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximalSquare(vector<vector<char>>& matrix) {\\n        \\n        if (matrix.empty()) return 0;\\n        \\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        \\n        \\n        vector<vector<int>>v(m, vector<int>(n, 0));\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                v[i][j] = matrix[i][j]-\\'0\\';\\n            }\\n        }\\n        \\n        for (int i = 1; i < m; i++) {\\n            for (int j = 1; j < n; j++) {\\n                if (v[i][j])\\n                    v[i][j] += min(min(v[i-1][j], v[i-1][j-1]), v[i][j-1]);\\n            }\\n        }\\n        \\n        int mxval = INT_MIN;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                mxval = max(v[i][j], mxval);\\n            }\\n        }\\n        \\n        return mxval*mxval;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 600774,
                "title": "javascript-solution",
                "content": "```\\nvar maximalSquare = function(matrix) {\\n    const dp = [];\\n    const m = matrix.length;\\n    if (m === 0) return 0;\\n    const n = matrix[0].length;\\n    \\n    let max = 0;\\n    \\n    for (let i = 0; i <= m; i++) {\\n        dp[i] = [];\\n    }\\n    \\n    for (let j = 0; j <= n; j++) {\\n        dp[0][j] = 0;\\n    }\\n    \\n    for (let i = 1; i <= m; i++) {\\n        dp[i][0] = 0;\\n    }\\n    \\n    \\n    for (let i = 1; i <= m; i++) {\\n        for (let j = 1; j <= n; j++) {\\n            // if the current matrix cell equals 1\\n            if (matrix[i - 1][j - 1] === \\'1\\') {\\n                const min = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]);\\n                dp[i][j] = min + 1;\\n                max = Math.max(max, dp[i][j]);\\n            } else {\\n                dp[i][j] = 0;\\n            }\\n            \\n        }\\n    }\\n    \\n    return max * max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximalSquare = function(matrix) {\\n    const dp = [];\\n    const m = matrix.length;\\n    if (m === 0) return 0;\\n    const n = matrix[0].length;\\n    \\n    let max = 0;\\n    \\n    for (let i = 0; i <= m; i++) {\\n        dp[i] = [];\\n    }\\n    \\n    for (let j = 0; j <= n; j++) {\\n        dp[0][j] = 0;\\n    }\\n    \\n    for (let i = 1; i <= m; i++) {\\n        dp[i][0] = 0;\\n    }\\n    \\n    \\n    for (let i = 1; i <= m; i++) {\\n        for (let j = 1; j <= n; j++) {\\n            // if the current matrix cell equals 1\\n            if (matrix[i - 1][j - 1] === \\'1\\') {\\n                const min = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]);\\n                dp[i][j] = min + 1;\\n                max = Math.max(max, dp[i][j]);\\n            } else {\\n                dp[i][j] = 0;\\n            }\\n            \\n        }\\n    }\\n    \\n    return max * max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 600691,
                "title": "non-dp-java-use-a-kernel-for-convolution-image-processing-logic",
                "content": "1. Use a square Identity matrix of size x by x to APPLY it over the main matrix from left to right and go from top to bottom. \\n2. Whenevr the product of the matrix elements with EACH main matrix subset it is ON TOP OF, is not 1, break. \\n3. If the product of each element of the main matrix and the kernel filter is 1, set max as max of previous max and x by x. \\n4. Return max\\n\\nRead this [Image Processing](https://en.wikipedia.org/wiki/Kernel_(image_processing))\\n```\\nclass Solution {\\n    int max = 0;\\n    public int maximalSquare(char[][] matrix) {\\n        if(matrix.length == 0) return 0;\\n        //Start with the largest kernelSize and as soon as it is obtained, dont look for smaller kernelSizes\\n        for(int i = Math.min(matrix.length, matrix[0].length); i >= 1; i--) {\\n            check(matrix, i);\\n            if(max > 0) return max;\\n        }\\n        return max;\\n    }\\n    \\n    private void check(char[][] matrix, int kernelSize) {\\n        int up = 0;\\n        int left = 0;\\n        int down = up + kernelSize - 1;\\n        int right = left + kernelSize - 1;\\n        //Apply Kernel from left to right and top to bottom\\n        while(down <= matrix.length - 1 && right <= matrix[0].length - 1) {\\n            int val = 1;\\n            for(int i = up; i <= down; i++) {\\n                for(int j = left; j <= right; j++) {\\n                    val *= matrix[i][j] - \\'0\\';\\n                    if(val == 0) break;\\n                }\\n            }\\n            if(val == 1) {\\n                max = Math.max(kernelSize * kernelSize, max);\\n                return;\\n            }\\n            if(right >= matrix[0].length - 1) {\\n                up++;\\n                down++;\\n                left = 0;\\n                right = left + kernelSize - 1;\\n            } else {\\n                left++;\\n                right++;\\n            }\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int max = 0;\\n    public int maximalSquare(char[][] matrix) {\\n        if(matrix.length == 0) return 0;\\n        //Start with the largest kernelSize and as soon as it is obtained, dont look for smaller kernelSizes\\n        for(int i = Math.min(matrix.length, matrix[0].length); i >= 1; i--) {\\n            check(matrix, i);\\n            if(max > 0) return max;\\n        }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1685559,
                "content": [
                    {
                        "username": "koff82",
                        "content": "Dear Leetcode team: could you change the inputs to be integers? I see no reason to use chars, and it would be more elegant in the code not to have to deal with chars. This tripped me up a few times at the beginning of writing down the solution. "
                    },
                    {
                        "username": "me-oniichan",
                        "content": "[@lastmanstandingzone](/lastmanstandingzone) just use `bool` at this point"
                    },
                    {
                        "username": "lastmanstandingzone",
                        "content": "char required less storage as compared to integer"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximal-square/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force [Accepted]\n\n  \n**Approach 2:** (Dynamic Programming) [Accepted]\n\n  \n**Approach 3:** (Better Dynamic Programming) [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nzwice",
                        "content": "Recall that dp[i, j] is the longest square side possible upto (i, j) where matrix[i, j] = \\'1\\'. Here I will prove why dp[i, j] = 1 + min(dp[i-1, j] + dp[i, j-1] + dp[i-1, j-1])\\n\\nAssume that dp[i, j], dp[i-1, j], dp[i, j-1], dp[i-1, j-1] equal to f, x, y, z respectively.\\n\\nFirst: f > x + 1 is impossible, because if it were, by drawing on the matrix, you will see that dp[i-1, j] > x, which is not our desires. So: f <= x + 1. \\nSimilarly, we have f <= y + 1, and f <= z + 1\\nSo far, what we got is f <= min(x+1, y+1, z+1)\\nNow let P = min(x+1, y+1, z+1), we have 3 cases:\\n* P = x+1, which means y >= x and z >= x. By some drawing, you will see that f = x+1\\n* P = y+1, which means x >= y and z >= y. By some drawing, f = y+1 also.\\n* P = z+1 (similarly).\\nWith above 3 cases, we have f = P = min(x+1, y+1, z+1) = 1 + min(x,y,z).\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhakiptk",
                        "content": "thanks a lot for this"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It took me half an hour to figure out where am I going wrong, lately I realized that the matrix is given as char and not int. "
                    },
                    {
                        "username": "d00mer",
                        "content": "By now, you\\'ve probably read the top voted solution. Here is an illustration to see why we need to get the minimum of the three values:\\n\\n![image](https://assets.leetcode.com/users/meatbag/image_1566784421.png)\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "* <a href=\"https://www.techiedelight.com/find-maximum-sum-submatrix-in-given-matrix/\">Find maximum sum K x K sub-matrix in a given M x N matrix</a>\\n* <a href=\"https://www.techiedelight.com/find-maximum-sum-submatrix-present-given-matrix/\">Find maximum sum submatrix present in a given matrix</a>"
                    },
                    {
                        "username": "vikassaini",
                        "content": "when i submitted my code in maximum square then it say required from here.Why this is happening ?"
                    },
                    {
                        "username": "batsy01",
                        "content": "for half a day, me dumbass trying to find maximum rectangle area instead of square"
                    },
                    {
                        "username": "yogita_upadhyay",
                        "content": "The catch here is that for a cell (i, j) to be botttom corner for a sqaure of length n lets say 3, cells [i-1, j], [i-1, j-1], [i, j-1], all three shoule be bottom right of a square of length n-1 e.g. of length 2.\\n\\n![image](https://assets.leetcode.com/users/images/e6f90fb2-0d2a-4ed3-92b3-5de2b64ab3a7_1647908252.6751.png)\\n"
                    },
                    {
                        "username": "tianmao",
                        "content": "![image](https://assets.leetcode.com/users/tianmao/image_1558571755.png)\\n"
                    }
                ]
            },
            {
                "id": 1565416,
                "content": [
                    {
                        "username": "koff82",
                        "content": "Dear Leetcode team: could you change the inputs to be integers? I see no reason to use chars, and it would be more elegant in the code not to have to deal with chars. This tripped me up a few times at the beginning of writing down the solution. "
                    },
                    {
                        "username": "me-oniichan",
                        "content": "[@lastmanstandingzone](/lastmanstandingzone) just use `bool` at this point"
                    },
                    {
                        "username": "lastmanstandingzone",
                        "content": "char required less storage as compared to integer"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximal-square/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force [Accepted]\n\n  \n**Approach 2:** (Dynamic Programming) [Accepted]\n\n  \n**Approach 3:** (Better Dynamic Programming) [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nzwice",
                        "content": "Recall that dp[i, j] is the longest square side possible upto (i, j) where matrix[i, j] = \\'1\\'. Here I will prove why dp[i, j] = 1 + min(dp[i-1, j] + dp[i, j-1] + dp[i-1, j-1])\\n\\nAssume that dp[i, j], dp[i-1, j], dp[i, j-1], dp[i-1, j-1] equal to f, x, y, z respectively.\\n\\nFirst: f > x + 1 is impossible, because if it were, by drawing on the matrix, you will see that dp[i-1, j] > x, which is not our desires. So: f <= x + 1. \\nSimilarly, we have f <= y + 1, and f <= z + 1\\nSo far, what we got is f <= min(x+1, y+1, z+1)\\nNow let P = min(x+1, y+1, z+1), we have 3 cases:\\n* P = x+1, which means y >= x and z >= x. By some drawing, you will see that f = x+1\\n* P = y+1, which means x >= y and z >= y. By some drawing, f = y+1 also.\\n* P = z+1 (similarly).\\nWith above 3 cases, we have f = P = min(x+1, y+1, z+1) = 1 + min(x,y,z).\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhakiptk",
                        "content": "thanks a lot for this"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It took me half an hour to figure out where am I going wrong, lately I realized that the matrix is given as char and not int. "
                    },
                    {
                        "username": "d00mer",
                        "content": "By now, you\\'ve probably read the top voted solution. Here is an illustration to see why we need to get the minimum of the three values:\\n\\n![image](https://assets.leetcode.com/users/meatbag/image_1566784421.png)\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "* <a href=\"https://www.techiedelight.com/find-maximum-sum-submatrix-in-given-matrix/\">Find maximum sum K x K sub-matrix in a given M x N matrix</a>\\n* <a href=\"https://www.techiedelight.com/find-maximum-sum-submatrix-present-given-matrix/\">Find maximum sum submatrix present in a given matrix</a>"
                    },
                    {
                        "username": "vikassaini",
                        "content": "when i submitted my code in maximum square then it say required from here.Why this is happening ?"
                    },
                    {
                        "username": "batsy01",
                        "content": "for half a day, me dumbass trying to find maximum rectangle area instead of square"
                    },
                    {
                        "username": "yogita_upadhyay",
                        "content": "The catch here is that for a cell (i, j) to be botttom corner for a sqaure of length n lets say 3, cells [i-1, j], [i-1, j-1], [i, j-1], all three shoule be bottom right of a square of length n-1 e.g. of length 2.\\n\\n![image](https://assets.leetcode.com/users/images/e6f90fb2-0d2a-4ed3-92b3-5de2b64ab3a7_1647908252.6751.png)\\n"
                    },
                    {
                        "username": "tianmao",
                        "content": "![image](https://assets.leetcode.com/users/tianmao/image_1558571755.png)\\n"
                    }
                ]
            },
            {
                "id": 1567477,
                "content": [
                    {
                        "username": "koff82",
                        "content": "Dear Leetcode team: could you change the inputs to be integers? I see no reason to use chars, and it would be more elegant in the code not to have to deal with chars. This tripped me up a few times at the beginning of writing down the solution. "
                    },
                    {
                        "username": "me-oniichan",
                        "content": "[@lastmanstandingzone](/lastmanstandingzone) just use `bool` at this point"
                    },
                    {
                        "username": "lastmanstandingzone",
                        "content": "char required less storage as compared to integer"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximal-square/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force [Accepted]\n\n  \n**Approach 2:** (Dynamic Programming) [Accepted]\n\n  \n**Approach 3:** (Better Dynamic Programming) [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nzwice",
                        "content": "Recall that dp[i, j] is the longest square side possible upto (i, j) where matrix[i, j] = \\'1\\'. Here I will prove why dp[i, j] = 1 + min(dp[i-1, j] + dp[i, j-1] + dp[i-1, j-1])\\n\\nAssume that dp[i, j], dp[i-1, j], dp[i, j-1], dp[i-1, j-1] equal to f, x, y, z respectively.\\n\\nFirst: f > x + 1 is impossible, because if it were, by drawing on the matrix, you will see that dp[i-1, j] > x, which is not our desires. So: f <= x + 1. \\nSimilarly, we have f <= y + 1, and f <= z + 1\\nSo far, what we got is f <= min(x+1, y+1, z+1)\\nNow let P = min(x+1, y+1, z+1), we have 3 cases:\\n* P = x+1, which means y >= x and z >= x. By some drawing, you will see that f = x+1\\n* P = y+1, which means x >= y and z >= y. By some drawing, f = y+1 also.\\n* P = z+1 (similarly).\\nWith above 3 cases, we have f = P = min(x+1, y+1, z+1) = 1 + min(x,y,z).\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhakiptk",
                        "content": "thanks a lot for this"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It took me half an hour to figure out where am I going wrong, lately I realized that the matrix is given as char and not int. "
                    },
                    {
                        "username": "d00mer",
                        "content": "By now, you\\'ve probably read the top voted solution. Here is an illustration to see why we need to get the minimum of the three values:\\n\\n![image](https://assets.leetcode.com/users/meatbag/image_1566784421.png)\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "* <a href=\"https://www.techiedelight.com/find-maximum-sum-submatrix-in-given-matrix/\">Find maximum sum K x K sub-matrix in a given M x N matrix</a>\\n* <a href=\"https://www.techiedelight.com/find-maximum-sum-submatrix-present-given-matrix/\">Find maximum sum submatrix present in a given matrix</a>"
                    },
                    {
                        "username": "vikassaini",
                        "content": "when i submitted my code in maximum square then it say required from here.Why this is happening ?"
                    },
                    {
                        "username": "batsy01",
                        "content": "for half a day, me dumbass trying to find maximum rectangle area instead of square"
                    },
                    {
                        "username": "yogita_upadhyay",
                        "content": "The catch here is that for a cell (i, j) to be botttom corner for a sqaure of length n lets say 3, cells [i-1, j], [i-1, j-1], [i, j-1], all three shoule be bottom right of a square of length n-1 e.g. of length 2.\\n\\n![image](https://assets.leetcode.com/users/images/e6f90fb2-0d2a-4ed3-92b3-5de2b64ab3a7_1647908252.6751.png)\\n"
                    },
                    {
                        "username": "tianmao",
                        "content": "![image](https://assets.leetcode.com/users/tianmao/image_1558571755.png)\\n"
                    }
                ]
            },
            {
                "id": 1919268,
                "content": [
                    {
                        "username": "koff82",
                        "content": "Dear Leetcode team: could you change the inputs to be integers? I see no reason to use chars, and it would be more elegant in the code not to have to deal with chars. This tripped me up a few times at the beginning of writing down the solution. "
                    },
                    {
                        "username": "me-oniichan",
                        "content": "[@lastmanstandingzone](/lastmanstandingzone) just use `bool` at this point"
                    },
                    {
                        "username": "lastmanstandingzone",
                        "content": "char required less storage as compared to integer"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximal-square/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force [Accepted]\n\n  \n**Approach 2:** (Dynamic Programming) [Accepted]\n\n  \n**Approach 3:** (Better Dynamic Programming) [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nzwice",
                        "content": "Recall that dp[i, j] is the longest square side possible upto (i, j) where matrix[i, j] = \\'1\\'. Here I will prove why dp[i, j] = 1 + min(dp[i-1, j] + dp[i, j-1] + dp[i-1, j-1])\\n\\nAssume that dp[i, j], dp[i-1, j], dp[i, j-1], dp[i-1, j-1] equal to f, x, y, z respectively.\\n\\nFirst: f > x + 1 is impossible, because if it were, by drawing on the matrix, you will see that dp[i-1, j] > x, which is not our desires. So: f <= x + 1. \\nSimilarly, we have f <= y + 1, and f <= z + 1\\nSo far, what we got is f <= min(x+1, y+1, z+1)\\nNow let P = min(x+1, y+1, z+1), we have 3 cases:\\n* P = x+1, which means y >= x and z >= x. By some drawing, you will see that f = x+1\\n* P = y+1, which means x >= y and z >= y. By some drawing, f = y+1 also.\\n* P = z+1 (similarly).\\nWith above 3 cases, we have f = P = min(x+1, y+1, z+1) = 1 + min(x,y,z).\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhakiptk",
                        "content": "thanks a lot for this"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It took me half an hour to figure out where am I going wrong, lately I realized that the matrix is given as char and not int. "
                    },
                    {
                        "username": "d00mer",
                        "content": "By now, you\\'ve probably read the top voted solution. Here is an illustration to see why we need to get the minimum of the three values:\\n\\n![image](https://assets.leetcode.com/users/meatbag/image_1566784421.png)\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "* <a href=\"https://www.techiedelight.com/find-maximum-sum-submatrix-in-given-matrix/\">Find maximum sum K x K sub-matrix in a given M x N matrix</a>\\n* <a href=\"https://www.techiedelight.com/find-maximum-sum-submatrix-present-given-matrix/\">Find maximum sum submatrix present in a given matrix</a>"
                    },
                    {
                        "username": "vikassaini",
                        "content": "when i submitted my code in maximum square then it say required from here.Why this is happening ?"
                    },
                    {
                        "username": "batsy01",
                        "content": "for half a day, me dumbass trying to find maximum rectangle area instead of square"
                    },
                    {
                        "username": "yogita_upadhyay",
                        "content": "The catch here is that for a cell (i, j) to be botttom corner for a sqaure of length n lets say 3, cells [i-1, j], [i-1, j-1], [i, j-1], all three shoule be bottom right of a square of length n-1 e.g. of length 2.\\n\\n![image](https://assets.leetcode.com/users/images/e6f90fb2-0d2a-4ed3-92b3-5de2b64ab3a7_1647908252.6751.png)\\n"
                    },
                    {
                        "username": "tianmao",
                        "content": "![image](https://assets.leetcode.com/users/tianmao/image_1558571755.png)\\n"
                    }
                ]
            },
            {
                "id": 1569609,
                "content": [
                    {
                        "username": "koff82",
                        "content": "Dear Leetcode team: could you change the inputs to be integers? I see no reason to use chars, and it would be more elegant in the code not to have to deal with chars. This tripped me up a few times at the beginning of writing down the solution. "
                    },
                    {
                        "username": "me-oniichan",
                        "content": "[@lastmanstandingzone](/lastmanstandingzone) just use `bool` at this point"
                    },
                    {
                        "username": "lastmanstandingzone",
                        "content": "char required less storage as compared to integer"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximal-square/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force [Accepted]\n\n  \n**Approach 2:** (Dynamic Programming) [Accepted]\n\n  \n**Approach 3:** (Better Dynamic Programming) [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nzwice",
                        "content": "Recall that dp[i, j] is the longest square side possible upto (i, j) where matrix[i, j] = \\'1\\'. Here I will prove why dp[i, j] = 1 + min(dp[i-1, j] + dp[i, j-1] + dp[i-1, j-1])\\n\\nAssume that dp[i, j], dp[i-1, j], dp[i, j-1], dp[i-1, j-1] equal to f, x, y, z respectively.\\n\\nFirst: f > x + 1 is impossible, because if it were, by drawing on the matrix, you will see that dp[i-1, j] > x, which is not our desires. So: f <= x + 1. \\nSimilarly, we have f <= y + 1, and f <= z + 1\\nSo far, what we got is f <= min(x+1, y+1, z+1)\\nNow let P = min(x+1, y+1, z+1), we have 3 cases:\\n* P = x+1, which means y >= x and z >= x. By some drawing, you will see that f = x+1\\n* P = y+1, which means x >= y and z >= y. By some drawing, f = y+1 also.\\n* P = z+1 (similarly).\\nWith above 3 cases, we have f = P = min(x+1, y+1, z+1) = 1 + min(x,y,z).\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhakiptk",
                        "content": "thanks a lot for this"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It took me half an hour to figure out where am I going wrong, lately I realized that the matrix is given as char and not int. "
                    },
                    {
                        "username": "d00mer",
                        "content": "By now, you\\'ve probably read the top voted solution. Here is an illustration to see why we need to get the minimum of the three values:\\n\\n![image](https://assets.leetcode.com/users/meatbag/image_1566784421.png)\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "* <a href=\"https://www.techiedelight.com/find-maximum-sum-submatrix-in-given-matrix/\">Find maximum sum K x K sub-matrix in a given M x N matrix</a>\\n* <a href=\"https://www.techiedelight.com/find-maximum-sum-submatrix-present-given-matrix/\">Find maximum sum submatrix present in a given matrix</a>"
                    },
                    {
                        "username": "vikassaini",
                        "content": "when i submitted my code in maximum square then it say required from here.Why this is happening ?"
                    },
                    {
                        "username": "batsy01",
                        "content": "for half a day, me dumbass trying to find maximum rectangle area instead of square"
                    },
                    {
                        "username": "yogita_upadhyay",
                        "content": "The catch here is that for a cell (i, j) to be botttom corner for a sqaure of length n lets say 3, cells [i-1, j], [i-1, j-1], [i, j-1], all three shoule be bottom right of a square of length n-1 e.g. of length 2.\\n\\n![image](https://assets.leetcode.com/users/images/e6f90fb2-0d2a-4ed3-92b3-5de2b64ab3a7_1647908252.6751.png)\\n"
                    },
                    {
                        "username": "tianmao",
                        "content": "![image](https://assets.leetcode.com/users/tianmao/image_1558571755.png)\\n"
                    }
                ]
            },
            {
                "id": 1570005,
                "content": [
                    {
                        "username": "koff82",
                        "content": "Dear Leetcode team: could you change the inputs to be integers? I see no reason to use chars, and it would be more elegant in the code not to have to deal with chars. This tripped me up a few times at the beginning of writing down the solution. "
                    },
                    {
                        "username": "me-oniichan",
                        "content": "[@lastmanstandingzone](/lastmanstandingzone) just use `bool` at this point"
                    },
                    {
                        "username": "lastmanstandingzone",
                        "content": "char required less storage as compared to integer"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximal-square/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force [Accepted]\n\n  \n**Approach 2:** (Dynamic Programming) [Accepted]\n\n  \n**Approach 3:** (Better Dynamic Programming) [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nzwice",
                        "content": "Recall that dp[i, j] is the longest square side possible upto (i, j) where matrix[i, j] = \\'1\\'. Here I will prove why dp[i, j] = 1 + min(dp[i-1, j] + dp[i, j-1] + dp[i-1, j-1])\\n\\nAssume that dp[i, j], dp[i-1, j], dp[i, j-1], dp[i-1, j-1] equal to f, x, y, z respectively.\\n\\nFirst: f > x + 1 is impossible, because if it were, by drawing on the matrix, you will see that dp[i-1, j] > x, which is not our desires. So: f <= x + 1. \\nSimilarly, we have f <= y + 1, and f <= z + 1\\nSo far, what we got is f <= min(x+1, y+1, z+1)\\nNow let P = min(x+1, y+1, z+1), we have 3 cases:\\n* P = x+1, which means y >= x and z >= x. By some drawing, you will see that f = x+1\\n* P = y+1, which means x >= y and z >= y. By some drawing, f = y+1 also.\\n* P = z+1 (similarly).\\nWith above 3 cases, we have f = P = min(x+1, y+1, z+1) = 1 + min(x,y,z).\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhakiptk",
                        "content": "thanks a lot for this"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It took me half an hour to figure out where am I going wrong, lately I realized that the matrix is given as char and not int. "
                    },
                    {
                        "username": "d00mer",
                        "content": "By now, you\\'ve probably read the top voted solution. Here is an illustration to see why we need to get the minimum of the three values:\\n\\n![image](https://assets.leetcode.com/users/meatbag/image_1566784421.png)\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "* <a href=\"https://www.techiedelight.com/find-maximum-sum-submatrix-in-given-matrix/\">Find maximum sum K x K sub-matrix in a given M x N matrix</a>\\n* <a href=\"https://www.techiedelight.com/find-maximum-sum-submatrix-present-given-matrix/\">Find maximum sum submatrix present in a given matrix</a>"
                    },
                    {
                        "username": "vikassaini",
                        "content": "when i submitted my code in maximum square then it say required from here.Why this is happening ?"
                    },
                    {
                        "username": "batsy01",
                        "content": "for half a day, me dumbass trying to find maximum rectangle area instead of square"
                    },
                    {
                        "username": "yogita_upadhyay",
                        "content": "The catch here is that for a cell (i, j) to be botttom corner for a sqaure of length n lets say 3, cells [i-1, j], [i-1, j-1], [i, j-1], all three shoule be bottom right of a square of length n-1 e.g. of length 2.\\n\\n![image](https://assets.leetcode.com/users/images/e6f90fb2-0d2a-4ed3-92b3-5de2b64ab3a7_1647908252.6751.png)\\n"
                    },
                    {
                        "username": "tianmao",
                        "content": "![image](https://assets.leetcode.com/users/tianmao/image_1558571755.png)\\n"
                    }
                ]
            },
            {
                "id": 1566488,
                "content": [
                    {
                        "username": "koff82",
                        "content": "Dear Leetcode team: could you change the inputs to be integers? I see no reason to use chars, and it would be more elegant in the code not to have to deal with chars. This tripped me up a few times at the beginning of writing down the solution. "
                    },
                    {
                        "username": "me-oniichan",
                        "content": "[@lastmanstandingzone](/lastmanstandingzone) just use `bool` at this point"
                    },
                    {
                        "username": "lastmanstandingzone",
                        "content": "char required less storage as compared to integer"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximal-square/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force [Accepted]\n\n  \n**Approach 2:** (Dynamic Programming) [Accepted]\n\n  \n**Approach 3:** (Better Dynamic Programming) [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nzwice",
                        "content": "Recall that dp[i, j] is the longest square side possible upto (i, j) where matrix[i, j] = \\'1\\'. Here I will prove why dp[i, j] = 1 + min(dp[i-1, j] + dp[i, j-1] + dp[i-1, j-1])\\n\\nAssume that dp[i, j], dp[i-1, j], dp[i, j-1], dp[i-1, j-1] equal to f, x, y, z respectively.\\n\\nFirst: f > x + 1 is impossible, because if it were, by drawing on the matrix, you will see that dp[i-1, j] > x, which is not our desires. So: f <= x + 1. \\nSimilarly, we have f <= y + 1, and f <= z + 1\\nSo far, what we got is f <= min(x+1, y+1, z+1)\\nNow let P = min(x+1, y+1, z+1), we have 3 cases:\\n* P = x+1, which means y >= x and z >= x. By some drawing, you will see that f = x+1\\n* P = y+1, which means x >= y and z >= y. By some drawing, f = y+1 also.\\n* P = z+1 (similarly).\\nWith above 3 cases, we have f = P = min(x+1, y+1, z+1) = 1 + min(x,y,z).\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhakiptk",
                        "content": "thanks a lot for this"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It took me half an hour to figure out where am I going wrong, lately I realized that the matrix is given as char and not int. "
                    },
                    {
                        "username": "d00mer",
                        "content": "By now, you\\'ve probably read the top voted solution. Here is an illustration to see why we need to get the minimum of the three values:\\n\\n![image](https://assets.leetcode.com/users/meatbag/image_1566784421.png)\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "* <a href=\"https://www.techiedelight.com/find-maximum-sum-submatrix-in-given-matrix/\">Find maximum sum K x K sub-matrix in a given M x N matrix</a>\\n* <a href=\"https://www.techiedelight.com/find-maximum-sum-submatrix-present-given-matrix/\">Find maximum sum submatrix present in a given matrix</a>"
                    },
                    {
                        "username": "vikassaini",
                        "content": "when i submitted my code in maximum square then it say required from here.Why this is happening ?"
                    },
                    {
                        "username": "batsy01",
                        "content": "for half a day, me dumbass trying to find maximum rectangle area instead of square"
                    },
                    {
                        "username": "yogita_upadhyay",
                        "content": "The catch here is that for a cell (i, j) to be botttom corner for a sqaure of length n lets say 3, cells [i-1, j], [i-1, j-1], [i, j-1], all three shoule be bottom right of a square of length n-1 e.g. of length 2.\\n\\n![image](https://assets.leetcode.com/users/images/e6f90fb2-0d2a-4ed3-92b3-5de2b64ab3a7_1647908252.6751.png)\\n"
                    },
                    {
                        "username": "tianmao",
                        "content": "![image](https://assets.leetcode.com/users/tianmao/image_1558571755.png)\\n"
                    }
                ]
            },
            {
                "id": 2016921,
                "content": [
                    {
                        "username": "koff82",
                        "content": "Dear Leetcode team: could you change the inputs to be integers? I see no reason to use chars, and it would be more elegant in the code not to have to deal with chars. This tripped me up a few times at the beginning of writing down the solution. "
                    },
                    {
                        "username": "me-oniichan",
                        "content": "[@lastmanstandingzone](/lastmanstandingzone) just use `bool` at this point"
                    },
                    {
                        "username": "lastmanstandingzone",
                        "content": "char required less storage as compared to integer"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximal-square/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force [Accepted]\n\n  \n**Approach 2:** (Dynamic Programming) [Accepted]\n\n  \n**Approach 3:** (Better Dynamic Programming) [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nzwice",
                        "content": "Recall that dp[i, j] is the longest square side possible upto (i, j) where matrix[i, j] = \\'1\\'. Here I will prove why dp[i, j] = 1 + min(dp[i-1, j] + dp[i, j-1] + dp[i-1, j-1])\\n\\nAssume that dp[i, j], dp[i-1, j], dp[i, j-1], dp[i-1, j-1] equal to f, x, y, z respectively.\\n\\nFirst: f > x + 1 is impossible, because if it were, by drawing on the matrix, you will see that dp[i-1, j] > x, which is not our desires. So: f <= x + 1. \\nSimilarly, we have f <= y + 1, and f <= z + 1\\nSo far, what we got is f <= min(x+1, y+1, z+1)\\nNow let P = min(x+1, y+1, z+1), we have 3 cases:\\n* P = x+1, which means y >= x and z >= x. By some drawing, you will see that f = x+1\\n* P = y+1, which means x >= y and z >= y. By some drawing, f = y+1 also.\\n* P = z+1 (similarly).\\nWith above 3 cases, we have f = P = min(x+1, y+1, z+1) = 1 + min(x,y,z).\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhakiptk",
                        "content": "thanks a lot for this"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It took me half an hour to figure out where am I going wrong, lately I realized that the matrix is given as char and not int. "
                    },
                    {
                        "username": "d00mer",
                        "content": "By now, you\\'ve probably read the top voted solution. Here is an illustration to see why we need to get the minimum of the three values:\\n\\n![image](https://assets.leetcode.com/users/meatbag/image_1566784421.png)\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "* <a href=\"https://www.techiedelight.com/find-maximum-sum-submatrix-in-given-matrix/\">Find maximum sum K x K sub-matrix in a given M x N matrix</a>\\n* <a href=\"https://www.techiedelight.com/find-maximum-sum-submatrix-present-given-matrix/\">Find maximum sum submatrix present in a given matrix</a>"
                    },
                    {
                        "username": "vikassaini",
                        "content": "when i submitted my code in maximum square then it say required from here.Why this is happening ?"
                    },
                    {
                        "username": "batsy01",
                        "content": "for half a day, me dumbass trying to find maximum rectangle area instead of square"
                    },
                    {
                        "username": "yogita_upadhyay",
                        "content": "The catch here is that for a cell (i, j) to be botttom corner for a sqaure of length n lets say 3, cells [i-1, j], [i-1, j-1], [i, j-1], all three shoule be bottom right of a square of length n-1 e.g. of length 2.\\n\\n![image](https://assets.leetcode.com/users/images/e6f90fb2-0d2a-4ed3-92b3-5de2b64ab3a7_1647908252.6751.png)\\n"
                    },
                    {
                        "username": "tianmao",
                        "content": "![image](https://assets.leetcode.com/users/tianmao/image_1558571755.png)\\n"
                    }
                ]
            },
            {
                "id": 1576530,
                "content": [
                    {
                        "username": "koff82",
                        "content": "Dear Leetcode team: could you change the inputs to be integers? I see no reason to use chars, and it would be more elegant in the code not to have to deal with chars. This tripped me up a few times at the beginning of writing down the solution. "
                    },
                    {
                        "username": "me-oniichan",
                        "content": "[@lastmanstandingzone](/lastmanstandingzone) just use `bool` at this point"
                    },
                    {
                        "username": "lastmanstandingzone",
                        "content": "char required less storage as compared to integer"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximal-square/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force [Accepted]\n\n  \n**Approach 2:** (Dynamic Programming) [Accepted]\n\n  \n**Approach 3:** (Better Dynamic Programming) [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nzwice",
                        "content": "Recall that dp[i, j] is the longest square side possible upto (i, j) where matrix[i, j] = \\'1\\'. Here I will prove why dp[i, j] = 1 + min(dp[i-1, j] + dp[i, j-1] + dp[i-1, j-1])\\n\\nAssume that dp[i, j], dp[i-1, j], dp[i, j-1], dp[i-1, j-1] equal to f, x, y, z respectively.\\n\\nFirst: f > x + 1 is impossible, because if it were, by drawing on the matrix, you will see that dp[i-1, j] > x, which is not our desires. So: f <= x + 1. \\nSimilarly, we have f <= y + 1, and f <= z + 1\\nSo far, what we got is f <= min(x+1, y+1, z+1)\\nNow let P = min(x+1, y+1, z+1), we have 3 cases:\\n* P = x+1, which means y >= x and z >= x. By some drawing, you will see that f = x+1\\n* P = y+1, which means x >= y and z >= y. By some drawing, f = y+1 also.\\n* P = z+1 (similarly).\\nWith above 3 cases, we have f = P = min(x+1, y+1, z+1) = 1 + min(x,y,z).\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhakiptk",
                        "content": "thanks a lot for this"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It took me half an hour to figure out where am I going wrong, lately I realized that the matrix is given as char and not int. "
                    },
                    {
                        "username": "d00mer",
                        "content": "By now, you\\'ve probably read the top voted solution. Here is an illustration to see why we need to get the minimum of the three values:\\n\\n![image](https://assets.leetcode.com/users/meatbag/image_1566784421.png)\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "* <a href=\"https://www.techiedelight.com/find-maximum-sum-submatrix-in-given-matrix/\">Find maximum sum K x K sub-matrix in a given M x N matrix</a>\\n* <a href=\"https://www.techiedelight.com/find-maximum-sum-submatrix-present-given-matrix/\">Find maximum sum submatrix present in a given matrix</a>"
                    },
                    {
                        "username": "vikassaini",
                        "content": "when i submitted my code in maximum square then it say required from here.Why this is happening ?"
                    },
                    {
                        "username": "batsy01",
                        "content": "for half a day, me dumbass trying to find maximum rectangle area instead of square"
                    },
                    {
                        "username": "yogita_upadhyay",
                        "content": "The catch here is that for a cell (i, j) to be botttom corner for a sqaure of length n lets say 3, cells [i-1, j], [i-1, j-1], [i, j-1], all three shoule be bottom right of a square of length n-1 e.g. of length 2.\\n\\n![image](https://assets.leetcode.com/users/images/e6f90fb2-0d2a-4ed3-92b3-5de2b64ab3a7_1647908252.6751.png)\\n"
                    },
                    {
                        "username": "tianmao",
                        "content": "![image](https://assets.leetcode.com/users/tianmao/image_1558571755.png)\\n"
                    }
                ]
            },
            {
                "id": 1572694,
                "content": [
                    {
                        "username": "koff82",
                        "content": "Dear Leetcode team: could you change the inputs to be integers? I see no reason to use chars, and it would be more elegant in the code not to have to deal with chars. This tripped me up a few times at the beginning of writing down the solution. "
                    },
                    {
                        "username": "me-oniichan",
                        "content": "[@lastmanstandingzone](/lastmanstandingzone) just use `bool` at this point"
                    },
                    {
                        "username": "lastmanstandingzone",
                        "content": "char required less storage as compared to integer"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximal-square/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force [Accepted]\n\n  \n**Approach 2:** (Dynamic Programming) [Accepted]\n\n  \n**Approach 3:** (Better Dynamic Programming) [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nzwice",
                        "content": "Recall that dp[i, j] is the longest square side possible upto (i, j) where matrix[i, j] = \\'1\\'. Here I will prove why dp[i, j] = 1 + min(dp[i-1, j] + dp[i, j-1] + dp[i-1, j-1])\\n\\nAssume that dp[i, j], dp[i-1, j], dp[i, j-1], dp[i-1, j-1] equal to f, x, y, z respectively.\\n\\nFirst: f > x + 1 is impossible, because if it were, by drawing on the matrix, you will see that dp[i-1, j] > x, which is not our desires. So: f <= x + 1. \\nSimilarly, we have f <= y + 1, and f <= z + 1\\nSo far, what we got is f <= min(x+1, y+1, z+1)\\nNow let P = min(x+1, y+1, z+1), we have 3 cases:\\n* P = x+1, which means y >= x and z >= x. By some drawing, you will see that f = x+1\\n* P = y+1, which means x >= y and z >= y. By some drawing, f = y+1 also.\\n* P = z+1 (similarly).\\nWith above 3 cases, we have f = P = min(x+1, y+1, z+1) = 1 + min(x,y,z).\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhakiptk",
                        "content": "thanks a lot for this"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It took me half an hour to figure out where am I going wrong, lately I realized that the matrix is given as char and not int. "
                    },
                    {
                        "username": "d00mer",
                        "content": "By now, you\\'ve probably read the top voted solution. Here is an illustration to see why we need to get the minimum of the three values:\\n\\n![image](https://assets.leetcode.com/users/meatbag/image_1566784421.png)\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "* <a href=\"https://www.techiedelight.com/find-maximum-sum-submatrix-in-given-matrix/\">Find maximum sum K x K sub-matrix in a given M x N matrix</a>\\n* <a href=\"https://www.techiedelight.com/find-maximum-sum-submatrix-present-given-matrix/\">Find maximum sum submatrix present in a given matrix</a>"
                    },
                    {
                        "username": "vikassaini",
                        "content": "when i submitted my code in maximum square then it say required from here.Why this is happening ?"
                    },
                    {
                        "username": "batsy01",
                        "content": "for half a day, me dumbass trying to find maximum rectangle area instead of square"
                    },
                    {
                        "username": "yogita_upadhyay",
                        "content": "The catch here is that for a cell (i, j) to be botttom corner for a sqaure of length n lets say 3, cells [i-1, j], [i-1, j-1], [i, j-1], all three shoule be bottom right of a square of length n-1 e.g. of length 2.\\n\\n![image](https://assets.leetcode.com/users/images/e6f90fb2-0d2a-4ed3-92b3-5de2b64ab3a7_1647908252.6751.png)\\n"
                    },
                    {
                        "username": "tianmao",
                        "content": "![image](https://assets.leetcode.com/users/tianmao/image_1558571755.png)\\n"
                    }
                ]
            },
            {
                "id": 1685559,
                "content": [
                    {
                        "username": "koff82",
                        "content": "Dear Leetcode team: could you change the inputs to be integers? I see no reason to use chars, and it would be more elegant in the code not to have to deal with chars. This tripped me up a few times at the beginning of writing down the solution. "
                    },
                    {
                        "username": "me-oniichan",
                        "content": "[@lastmanstandingzone](/lastmanstandingzone) just use `bool` at this point"
                    },
                    {
                        "username": "lastmanstandingzone",
                        "content": "char required less storage as compared to integer"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximal-square/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force [Accepted]\n\n  \n**Approach 2:** (Dynamic Programming) [Accepted]\n\n  \n**Approach 3:** (Better Dynamic Programming) [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nzwice",
                        "content": "Recall that dp[i, j] is the longest square side possible upto (i, j) where matrix[i, j] = \\'1\\'. Here I will prove why dp[i, j] = 1 + min(dp[i-1, j] + dp[i, j-1] + dp[i-1, j-1])\\n\\nAssume that dp[i, j], dp[i-1, j], dp[i, j-1], dp[i-1, j-1] equal to f, x, y, z respectively.\\n\\nFirst: f > x + 1 is impossible, because if it were, by drawing on the matrix, you will see that dp[i-1, j] > x, which is not our desires. So: f <= x + 1. \\nSimilarly, we have f <= y + 1, and f <= z + 1\\nSo far, what we got is f <= min(x+1, y+1, z+1)\\nNow let P = min(x+1, y+1, z+1), we have 3 cases:\\n* P = x+1, which means y >= x and z >= x. By some drawing, you will see that f = x+1\\n* P = y+1, which means x >= y and z >= y. By some drawing, f = y+1 also.\\n* P = z+1 (similarly).\\nWith above 3 cases, we have f = P = min(x+1, y+1, z+1) = 1 + min(x,y,z).\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhakiptk",
                        "content": "thanks a lot for this"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It took me half an hour to figure out where am I going wrong, lately I realized that the matrix is given as char and not int. "
                    },
                    {
                        "username": "d00mer",
                        "content": "By now, you\\'ve probably read the top voted solution. Here is an illustration to see why we need to get the minimum of the three values:\\n\\n![image](https://assets.leetcode.com/users/meatbag/image_1566784421.png)\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "* <a href=\"https://www.techiedelight.com/find-maximum-sum-submatrix-in-given-matrix/\">Find maximum sum K x K sub-matrix in a given M x N matrix</a>\\n* <a href=\"https://www.techiedelight.com/find-maximum-sum-submatrix-present-given-matrix/\">Find maximum sum submatrix present in a given matrix</a>"
                    },
                    {
                        "username": "vikassaini",
                        "content": "when i submitted my code in maximum square then it say required from here.Why this is happening ?"
                    },
                    {
                        "username": "batsy01",
                        "content": "for half a day, me dumbass trying to find maximum rectangle area instead of square"
                    },
                    {
                        "username": "yogita_upadhyay",
                        "content": "The catch here is that for a cell (i, j) to be botttom corner for a sqaure of length n lets say 3, cells [i-1, j], [i-1, j-1], [i, j-1], all three shoule be bottom right of a square of length n-1 e.g. of length 2.\\n\\n![image](https://assets.leetcode.com/users/images/e6f90fb2-0d2a-4ed3-92b3-5de2b64ab3a7_1647908252.6751.png)\\n"
                    },
                    {
                        "username": "tianmao",
                        "content": "![image](https://assets.leetcode.com/users/tianmao/image_1558571755.png)\\n"
                    }
                ]
            },
            {
                "id": 1565416,
                "content": [
                    {
                        "username": "koff82",
                        "content": "Dear Leetcode team: could you change the inputs to be integers? I see no reason to use chars, and it would be more elegant in the code not to have to deal with chars. This tripped me up a few times at the beginning of writing down the solution. "
                    },
                    {
                        "username": "me-oniichan",
                        "content": "[@lastmanstandingzone](/lastmanstandingzone) just use `bool` at this point"
                    },
                    {
                        "username": "lastmanstandingzone",
                        "content": "char required less storage as compared to integer"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximal-square/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force [Accepted]\n\n  \n**Approach 2:** (Dynamic Programming) [Accepted]\n\n  \n**Approach 3:** (Better Dynamic Programming) [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nzwice",
                        "content": "Recall that dp[i, j] is the longest square side possible upto (i, j) where matrix[i, j] = \\'1\\'. Here I will prove why dp[i, j] = 1 + min(dp[i-1, j] + dp[i, j-1] + dp[i-1, j-1])\\n\\nAssume that dp[i, j], dp[i-1, j], dp[i, j-1], dp[i-1, j-1] equal to f, x, y, z respectively.\\n\\nFirst: f > x + 1 is impossible, because if it were, by drawing on the matrix, you will see that dp[i-1, j] > x, which is not our desires. So: f <= x + 1. \\nSimilarly, we have f <= y + 1, and f <= z + 1\\nSo far, what we got is f <= min(x+1, y+1, z+1)\\nNow let P = min(x+1, y+1, z+1), we have 3 cases:\\n* P = x+1, which means y >= x and z >= x. By some drawing, you will see that f = x+1\\n* P = y+1, which means x >= y and z >= y. By some drawing, f = y+1 also.\\n* P = z+1 (similarly).\\nWith above 3 cases, we have f = P = min(x+1, y+1, z+1) = 1 + min(x,y,z).\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhakiptk",
                        "content": "thanks a lot for this"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It took me half an hour to figure out where am I going wrong, lately I realized that the matrix is given as char and not int. "
                    },
                    {
                        "username": "d00mer",
                        "content": "By now, you\\'ve probably read the top voted solution. Here is an illustration to see why we need to get the minimum of the three values:\\n\\n![image](https://assets.leetcode.com/users/meatbag/image_1566784421.png)\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "* <a href=\"https://www.techiedelight.com/find-maximum-sum-submatrix-in-given-matrix/\">Find maximum sum K x K sub-matrix in a given M x N matrix</a>\\n* <a href=\"https://www.techiedelight.com/find-maximum-sum-submatrix-present-given-matrix/\">Find maximum sum submatrix present in a given matrix</a>"
                    },
                    {
                        "username": "vikassaini",
                        "content": "when i submitted my code in maximum square then it say required from here.Why this is happening ?"
                    },
                    {
                        "username": "batsy01",
                        "content": "for half a day, me dumbass trying to find maximum rectangle area instead of square"
                    },
                    {
                        "username": "yogita_upadhyay",
                        "content": "The catch here is that for a cell (i, j) to be botttom corner for a sqaure of length n lets say 3, cells [i-1, j], [i-1, j-1], [i, j-1], all three shoule be bottom right of a square of length n-1 e.g. of length 2.\\n\\n![image](https://assets.leetcode.com/users/images/e6f90fb2-0d2a-4ed3-92b3-5de2b64ab3a7_1647908252.6751.png)\\n"
                    },
                    {
                        "username": "tianmao",
                        "content": "![image](https://assets.leetcode.com/users/tianmao/image_1558571755.png)\\n"
                    }
                ]
            },
            {
                "id": 1567477,
                "content": [
                    {
                        "username": "koff82",
                        "content": "Dear Leetcode team: could you change the inputs to be integers? I see no reason to use chars, and it would be more elegant in the code not to have to deal with chars. This tripped me up a few times at the beginning of writing down the solution. "
                    },
                    {
                        "username": "me-oniichan",
                        "content": "[@lastmanstandingzone](/lastmanstandingzone) just use `bool` at this point"
                    },
                    {
                        "username": "lastmanstandingzone",
                        "content": "char required less storage as compared to integer"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximal-square/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force [Accepted]\n\n  \n**Approach 2:** (Dynamic Programming) [Accepted]\n\n  \n**Approach 3:** (Better Dynamic Programming) [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nzwice",
                        "content": "Recall that dp[i, j] is the longest square side possible upto (i, j) where matrix[i, j] = \\'1\\'. Here I will prove why dp[i, j] = 1 + min(dp[i-1, j] + dp[i, j-1] + dp[i-1, j-1])\\n\\nAssume that dp[i, j], dp[i-1, j], dp[i, j-1], dp[i-1, j-1] equal to f, x, y, z respectively.\\n\\nFirst: f > x + 1 is impossible, because if it were, by drawing on the matrix, you will see that dp[i-1, j] > x, which is not our desires. So: f <= x + 1. \\nSimilarly, we have f <= y + 1, and f <= z + 1\\nSo far, what we got is f <= min(x+1, y+1, z+1)\\nNow let P = min(x+1, y+1, z+1), we have 3 cases:\\n* P = x+1, which means y >= x and z >= x. By some drawing, you will see that f = x+1\\n* P = y+1, which means x >= y and z >= y. By some drawing, f = y+1 also.\\n* P = z+1 (similarly).\\nWith above 3 cases, we have f = P = min(x+1, y+1, z+1) = 1 + min(x,y,z).\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhakiptk",
                        "content": "thanks a lot for this"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It took me half an hour to figure out where am I going wrong, lately I realized that the matrix is given as char and not int. "
                    },
                    {
                        "username": "d00mer",
                        "content": "By now, you\\'ve probably read the top voted solution. Here is an illustration to see why we need to get the minimum of the three values:\\n\\n![image](https://assets.leetcode.com/users/meatbag/image_1566784421.png)\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "* <a href=\"https://www.techiedelight.com/find-maximum-sum-submatrix-in-given-matrix/\">Find maximum sum K x K sub-matrix in a given M x N matrix</a>\\n* <a href=\"https://www.techiedelight.com/find-maximum-sum-submatrix-present-given-matrix/\">Find maximum sum submatrix present in a given matrix</a>"
                    },
                    {
                        "username": "vikassaini",
                        "content": "when i submitted my code in maximum square then it say required from here.Why this is happening ?"
                    },
                    {
                        "username": "batsy01",
                        "content": "for half a day, me dumbass trying to find maximum rectangle area instead of square"
                    },
                    {
                        "username": "yogita_upadhyay",
                        "content": "The catch here is that for a cell (i, j) to be botttom corner for a sqaure of length n lets say 3, cells [i-1, j], [i-1, j-1], [i, j-1], all three shoule be bottom right of a square of length n-1 e.g. of length 2.\\n\\n![image](https://assets.leetcode.com/users/images/e6f90fb2-0d2a-4ed3-92b3-5de2b64ab3a7_1647908252.6751.png)\\n"
                    },
                    {
                        "username": "tianmao",
                        "content": "![image](https://assets.leetcode.com/users/tianmao/image_1558571755.png)\\n"
                    }
                ]
            },
            {
                "id": 1919268,
                "content": [
                    {
                        "username": "koff82",
                        "content": "Dear Leetcode team: could you change the inputs to be integers? I see no reason to use chars, and it would be more elegant in the code not to have to deal with chars. This tripped me up a few times at the beginning of writing down the solution. "
                    },
                    {
                        "username": "me-oniichan",
                        "content": "[@lastmanstandingzone](/lastmanstandingzone) just use `bool` at this point"
                    },
                    {
                        "username": "lastmanstandingzone",
                        "content": "char required less storage as compared to integer"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximal-square/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force [Accepted]\n\n  \n**Approach 2:** (Dynamic Programming) [Accepted]\n\n  \n**Approach 3:** (Better Dynamic Programming) [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nzwice",
                        "content": "Recall that dp[i, j] is the longest square side possible upto (i, j) where matrix[i, j] = \\'1\\'. Here I will prove why dp[i, j] = 1 + min(dp[i-1, j] + dp[i, j-1] + dp[i-1, j-1])\\n\\nAssume that dp[i, j], dp[i-1, j], dp[i, j-1], dp[i-1, j-1] equal to f, x, y, z respectively.\\n\\nFirst: f > x + 1 is impossible, because if it were, by drawing on the matrix, you will see that dp[i-1, j] > x, which is not our desires. So: f <= x + 1. \\nSimilarly, we have f <= y + 1, and f <= z + 1\\nSo far, what we got is f <= min(x+1, y+1, z+1)\\nNow let P = min(x+1, y+1, z+1), we have 3 cases:\\n* P = x+1, which means y >= x and z >= x. By some drawing, you will see that f = x+1\\n* P = y+1, which means x >= y and z >= y. By some drawing, f = y+1 also.\\n* P = z+1 (similarly).\\nWith above 3 cases, we have f = P = min(x+1, y+1, z+1) = 1 + min(x,y,z).\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhakiptk",
                        "content": "thanks a lot for this"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It took me half an hour to figure out where am I going wrong, lately I realized that the matrix is given as char and not int. "
                    },
                    {
                        "username": "d00mer",
                        "content": "By now, you\\'ve probably read the top voted solution. Here is an illustration to see why we need to get the minimum of the three values:\\n\\n![image](https://assets.leetcode.com/users/meatbag/image_1566784421.png)\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "* <a href=\"https://www.techiedelight.com/find-maximum-sum-submatrix-in-given-matrix/\">Find maximum sum K x K sub-matrix in a given M x N matrix</a>\\n* <a href=\"https://www.techiedelight.com/find-maximum-sum-submatrix-present-given-matrix/\">Find maximum sum submatrix present in a given matrix</a>"
                    },
                    {
                        "username": "vikassaini",
                        "content": "when i submitted my code in maximum square then it say required from here.Why this is happening ?"
                    },
                    {
                        "username": "batsy01",
                        "content": "for half a day, me dumbass trying to find maximum rectangle area instead of square"
                    },
                    {
                        "username": "yogita_upadhyay",
                        "content": "The catch here is that for a cell (i, j) to be botttom corner for a sqaure of length n lets say 3, cells [i-1, j], [i-1, j-1], [i, j-1], all three shoule be bottom right of a square of length n-1 e.g. of length 2.\\n\\n![image](https://assets.leetcode.com/users/images/e6f90fb2-0d2a-4ed3-92b3-5de2b64ab3a7_1647908252.6751.png)\\n"
                    },
                    {
                        "username": "tianmao",
                        "content": "![image](https://assets.leetcode.com/users/tianmao/image_1558571755.png)\\n"
                    }
                ]
            },
            {
                "id": 1569609,
                "content": [
                    {
                        "username": "koff82",
                        "content": "Dear Leetcode team: could you change the inputs to be integers? I see no reason to use chars, and it would be more elegant in the code not to have to deal with chars. This tripped me up a few times at the beginning of writing down the solution. "
                    },
                    {
                        "username": "me-oniichan",
                        "content": "[@lastmanstandingzone](/lastmanstandingzone) just use `bool` at this point"
                    },
                    {
                        "username": "lastmanstandingzone",
                        "content": "char required less storage as compared to integer"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximal-square/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force [Accepted]\n\n  \n**Approach 2:** (Dynamic Programming) [Accepted]\n\n  \n**Approach 3:** (Better Dynamic Programming) [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nzwice",
                        "content": "Recall that dp[i, j] is the longest square side possible upto (i, j) where matrix[i, j] = \\'1\\'. Here I will prove why dp[i, j] = 1 + min(dp[i-1, j] + dp[i, j-1] + dp[i-1, j-1])\\n\\nAssume that dp[i, j], dp[i-1, j], dp[i, j-1], dp[i-1, j-1] equal to f, x, y, z respectively.\\n\\nFirst: f > x + 1 is impossible, because if it were, by drawing on the matrix, you will see that dp[i-1, j] > x, which is not our desires. So: f <= x + 1. \\nSimilarly, we have f <= y + 1, and f <= z + 1\\nSo far, what we got is f <= min(x+1, y+1, z+1)\\nNow let P = min(x+1, y+1, z+1), we have 3 cases:\\n* P = x+1, which means y >= x and z >= x. By some drawing, you will see that f = x+1\\n* P = y+1, which means x >= y and z >= y. By some drawing, f = y+1 also.\\n* P = z+1 (similarly).\\nWith above 3 cases, we have f = P = min(x+1, y+1, z+1) = 1 + min(x,y,z).\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhakiptk",
                        "content": "thanks a lot for this"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It took me half an hour to figure out where am I going wrong, lately I realized that the matrix is given as char and not int. "
                    },
                    {
                        "username": "d00mer",
                        "content": "By now, you\\'ve probably read the top voted solution. Here is an illustration to see why we need to get the minimum of the three values:\\n\\n![image](https://assets.leetcode.com/users/meatbag/image_1566784421.png)\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "* <a href=\"https://www.techiedelight.com/find-maximum-sum-submatrix-in-given-matrix/\">Find maximum sum K x K sub-matrix in a given M x N matrix</a>\\n* <a href=\"https://www.techiedelight.com/find-maximum-sum-submatrix-present-given-matrix/\">Find maximum sum submatrix present in a given matrix</a>"
                    },
                    {
                        "username": "vikassaini",
                        "content": "when i submitted my code in maximum square then it say required from here.Why this is happening ?"
                    },
                    {
                        "username": "batsy01",
                        "content": "for half a day, me dumbass trying to find maximum rectangle area instead of square"
                    },
                    {
                        "username": "yogita_upadhyay",
                        "content": "The catch here is that for a cell (i, j) to be botttom corner for a sqaure of length n lets say 3, cells [i-1, j], [i-1, j-1], [i, j-1], all three shoule be bottom right of a square of length n-1 e.g. of length 2.\\n\\n![image](https://assets.leetcode.com/users/images/e6f90fb2-0d2a-4ed3-92b3-5de2b64ab3a7_1647908252.6751.png)\\n"
                    },
                    {
                        "username": "tianmao",
                        "content": "![image](https://assets.leetcode.com/users/tianmao/image_1558571755.png)\\n"
                    }
                ]
            },
            {
                "id": 1570005,
                "content": [
                    {
                        "username": "koff82",
                        "content": "Dear Leetcode team: could you change the inputs to be integers? I see no reason to use chars, and it would be more elegant in the code not to have to deal with chars. This tripped me up a few times at the beginning of writing down the solution. "
                    },
                    {
                        "username": "me-oniichan",
                        "content": "[@lastmanstandingzone](/lastmanstandingzone) just use `bool` at this point"
                    },
                    {
                        "username": "lastmanstandingzone",
                        "content": "char required less storage as compared to integer"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximal-square/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force [Accepted]\n\n  \n**Approach 2:** (Dynamic Programming) [Accepted]\n\n  \n**Approach 3:** (Better Dynamic Programming) [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nzwice",
                        "content": "Recall that dp[i, j] is the longest square side possible upto (i, j) where matrix[i, j] = \\'1\\'. Here I will prove why dp[i, j] = 1 + min(dp[i-1, j] + dp[i, j-1] + dp[i-1, j-1])\\n\\nAssume that dp[i, j], dp[i-1, j], dp[i, j-1], dp[i-1, j-1] equal to f, x, y, z respectively.\\n\\nFirst: f > x + 1 is impossible, because if it were, by drawing on the matrix, you will see that dp[i-1, j] > x, which is not our desires. So: f <= x + 1. \\nSimilarly, we have f <= y + 1, and f <= z + 1\\nSo far, what we got is f <= min(x+1, y+1, z+1)\\nNow let P = min(x+1, y+1, z+1), we have 3 cases:\\n* P = x+1, which means y >= x and z >= x. By some drawing, you will see that f = x+1\\n* P = y+1, which means x >= y and z >= y. By some drawing, f = y+1 also.\\n* P = z+1 (similarly).\\nWith above 3 cases, we have f = P = min(x+1, y+1, z+1) = 1 + min(x,y,z).\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhakiptk",
                        "content": "thanks a lot for this"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It took me half an hour to figure out where am I going wrong, lately I realized that the matrix is given as char and not int. "
                    },
                    {
                        "username": "d00mer",
                        "content": "By now, you\\'ve probably read the top voted solution. Here is an illustration to see why we need to get the minimum of the three values:\\n\\n![image](https://assets.leetcode.com/users/meatbag/image_1566784421.png)\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "* <a href=\"https://www.techiedelight.com/find-maximum-sum-submatrix-in-given-matrix/\">Find maximum sum K x K sub-matrix in a given M x N matrix</a>\\n* <a href=\"https://www.techiedelight.com/find-maximum-sum-submatrix-present-given-matrix/\">Find maximum sum submatrix present in a given matrix</a>"
                    },
                    {
                        "username": "vikassaini",
                        "content": "when i submitted my code in maximum square then it say required from here.Why this is happening ?"
                    },
                    {
                        "username": "batsy01",
                        "content": "for half a day, me dumbass trying to find maximum rectangle area instead of square"
                    },
                    {
                        "username": "yogita_upadhyay",
                        "content": "The catch here is that for a cell (i, j) to be botttom corner for a sqaure of length n lets say 3, cells [i-1, j], [i-1, j-1], [i, j-1], all three shoule be bottom right of a square of length n-1 e.g. of length 2.\\n\\n![image](https://assets.leetcode.com/users/images/e6f90fb2-0d2a-4ed3-92b3-5de2b64ab3a7_1647908252.6751.png)\\n"
                    },
                    {
                        "username": "tianmao",
                        "content": "![image](https://assets.leetcode.com/users/tianmao/image_1558571755.png)\\n"
                    }
                ]
            },
            {
                "id": 1566488,
                "content": [
                    {
                        "username": "koff82",
                        "content": "Dear Leetcode team: could you change the inputs to be integers? I see no reason to use chars, and it would be more elegant in the code not to have to deal with chars. This tripped me up a few times at the beginning of writing down the solution. "
                    },
                    {
                        "username": "me-oniichan",
                        "content": "[@lastmanstandingzone](/lastmanstandingzone) just use `bool` at this point"
                    },
                    {
                        "username": "lastmanstandingzone",
                        "content": "char required less storage as compared to integer"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximal-square/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force [Accepted]\n\n  \n**Approach 2:** (Dynamic Programming) [Accepted]\n\n  \n**Approach 3:** (Better Dynamic Programming) [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nzwice",
                        "content": "Recall that dp[i, j] is the longest square side possible upto (i, j) where matrix[i, j] = \\'1\\'. Here I will prove why dp[i, j] = 1 + min(dp[i-1, j] + dp[i, j-1] + dp[i-1, j-1])\\n\\nAssume that dp[i, j], dp[i-1, j], dp[i, j-1], dp[i-1, j-1] equal to f, x, y, z respectively.\\n\\nFirst: f > x + 1 is impossible, because if it were, by drawing on the matrix, you will see that dp[i-1, j] > x, which is not our desires. So: f <= x + 1. \\nSimilarly, we have f <= y + 1, and f <= z + 1\\nSo far, what we got is f <= min(x+1, y+1, z+1)\\nNow let P = min(x+1, y+1, z+1), we have 3 cases:\\n* P = x+1, which means y >= x and z >= x. By some drawing, you will see that f = x+1\\n* P = y+1, which means x >= y and z >= y. By some drawing, f = y+1 also.\\n* P = z+1 (similarly).\\nWith above 3 cases, we have f = P = min(x+1, y+1, z+1) = 1 + min(x,y,z).\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhakiptk",
                        "content": "thanks a lot for this"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It took me half an hour to figure out where am I going wrong, lately I realized that the matrix is given as char and not int. "
                    },
                    {
                        "username": "d00mer",
                        "content": "By now, you\\'ve probably read the top voted solution. Here is an illustration to see why we need to get the minimum of the three values:\\n\\n![image](https://assets.leetcode.com/users/meatbag/image_1566784421.png)\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "* <a href=\"https://www.techiedelight.com/find-maximum-sum-submatrix-in-given-matrix/\">Find maximum sum K x K sub-matrix in a given M x N matrix</a>\\n* <a href=\"https://www.techiedelight.com/find-maximum-sum-submatrix-present-given-matrix/\">Find maximum sum submatrix present in a given matrix</a>"
                    },
                    {
                        "username": "vikassaini",
                        "content": "when i submitted my code in maximum square then it say required from here.Why this is happening ?"
                    },
                    {
                        "username": "batsy01",
                        "content": "for half a day, me dumbass trying to find maximum rectangle area instead of square"
                    },
                    {
                        "username": "yogita_upadhyay",
                        "content": "The catch here is that for a cell (i, j) to be botttom corner for a sqaure of length n lets say 3, cells [i-1, j], [i-1, j-1], [i, j-1], all three shoule be bottom right of a square of length n-1 e.g. of length 2.\\n\\n![image](https://assets.leetcode.com/users/images/e6f90fb2-0d2a-4ed3-92b3-5de2b64ab3a7_1647908252.6751.png)\\n"
                    },
                    {
                        "username": "tianmao",
                        "content": "![image](https://assets.leetcode.com/users/tianmao/image_1558571755.png)\\n"
                    }
                ]
            },
            {
                "id": 2016921,
                "content": [
                    {
                        "username": "koff82",
                        "content": "Dear Leetcode team: could you change the inputs to be integers? I see no reason to use chars, and it would be more elegant in the code not to have to deal with chars. This tripped me up a few times at the beginning of writing down the solution. "
                    },
                    {
                        "username": "me-oniichan",
                        "content": "[@lastmanstandingzone](/lastmanstandingzone) just use `bool` at this point"
                    },
                    {
                        "username": "lastmanstandingzone",
                        "content": "char required less storage as compared to integer"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximal-square/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force [Accepted]\n\n  \n**Approach 2:** (Dynamic Programming) [Accepted]\n\n  \n**Approach 3:** (Better Dynamic Programming) [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nzwice",
                        "content": "Recall that dp[i, j] is the longest square side possible upto (i, j) where matrix[i, j] = \\'1\\'. Here I will prove why dp[i, j] = 1 + min(dp[i-1, j] + dp[i, j-1] + dp[i-1, j-1])\\n\\nAssume that dp[i, j], dp[i-1, j], dp[i, j-1], dp[i-1, j-1] equal to f, x, y, z respectively.\\n\\nFirst: f > x + 1 is impossible, because if it were, by drawing on the matrix, you will see that dp[i-1, j] > x, which is not our desires. So: f <= x + 1. \\nSimilarly, we have f <= y + 1, and f <= z + 1\\nSo far, what we got is f <= min(x+1, y+1, z+1)\\nNow let P = min(x+1, y+1, z+1), we have 3 cases:\\n* P = x+1, which means y >= x and z >= x. By some drawing, you will see that f = x+1\\n* P = y+1, which means x >= y and z >= y. By some drawing, f = y+1 also.\\n* P = z+1 (similarly).\\nWith above 3 cases, we have f = P = min(x+1, y+1, z+1) = 1 + min(x,y,z).\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhakiptk",
                        "content": "thanks a lot for this"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It took me half an hour to figure out where am I going wrong, lately I realized that the matrix is given as char and not int. "
                    },
                    {
                        "username": "d00mer",
                        "content": "By now, you\\'ve probably read the top voted solution. Here is an illustration to see why we need to get the minimum of the three values:\\n\\n![image](https://assets.leetcode.com/users/meatbag/image_1566784421.png)\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "* <a href=\"https://www.techiedelight.com/find-maximum-sum-submatrix-in-given-matrix/\">Find maximum sum K x K sub-matrix in a given M x N matrix</a>\\n* <a href=\"https://www.techiedelight.com/find-maximum-sum-submatrix-present-given-matrix/\">Find maximum sum submatrix present in a given matrix</a>"
                    },
                    {
                        "username": "vikassaini",
                        "content": "when i submitted my code in maximum square then it say required from here.Why this is happening ?"
                    },
                    {
                        "username": "batsy01",
                        "content": "for half a day, me dumbass trying to find maximum rectangle area instead of square"
                    },
                    {
                        "username": "yogita_upadhyay",
                        "content": "The catch here is that for a cell (i, j) to be botttom corner for a sqaure of length n lets say 3, cells [i-1, j], [i-1, j-1], [i, j-1], all three shoule be bottom right of a square of length n-1 e.g. of length 2.\\n\\n![image](https://assets.leetcode.com/users/images/e6f90fb2-0d2a-4ed3-92b3-5de2b64ab3a7_1647908252.6751.png)\\n"
                    },
                    {
                        "username": "tianmao",
                        "content": "![image](https://assets.leetcode.com/users/tianmao/image_1558571755.png)\\n"
                    }
                ]
            },
            {
                "id": 1576530,
                "content": [
                    {
                        "username": "koff82",
                        "content": "Dear Leetcode team: could you change the inputs to be integers? I see no reason to use chars, and it would be more elegant in the code not to have to deal with chars. This tripped me up a few times at the beginning of writing down the solution. "
                    },
                    {
                        "username": "me-oniichan",
                        "content": "[@lastmanstandingzone](/lastmanstandingzone) just use `bool` at this point"
                    },
                    {
                        "username": "lastmanstandingzone",
                        "content": "char required less storage as compared to integer"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximal-square/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force [Accepted]\n\n  \n**Approach 2:** (Dynamic Programming) [Accepted]\n\n  \n**Approach 3:** (Better Dynamic Programming) [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nzwice",
                        "content": "Recall that dp[i, j] is the longest square side possible upto (i, j) where matrix[i, j] = \\'1\\'. Here I will prove why dp[i, j] = 1 + min(dp[i-1, j] + dp[i, j-1] + dp[i-1, j-1])\\n\\nAssume that dp[i, j], dp[i-1, j], dp[i, j-1], dp[i-1, j-1] equal to f, x, y, z respectively.\\n\\nFirst: f > x + 1 is impossible, because if it were, by drawing on the matrix, you will see that dp[i-1, j] > x, which is not our desires. So: f <= x + 1. \\nSimilarly, we have f <= y + 1, and f <= z + 1\\nSo far, what we got is f <= min(x+1, y+1, z+1)\\nNow let P = min(x+1, y+1, z+1), we have 3 cases:\\n* P = x+1, which means y >= x and z >= x. By some drawing, you will see that f = x+1\\n* P = y+1, which means x >= y and z >= y. By some drawing, f = y+1 also.\\n* P = z+1 (similarly).\\nWith above 3 cases, we have f = P = min(x+1, y+1, z+1) = 1 + min(x,y,z).\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhakiptk",
                        "content": "thanks a lot for this"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It took me half an hour to figure out where am I going wrong, lately I realized that the matrix is given as char and not int. "
                    },
                    {
                        "username": "d00mer",
                        "content": "By now, you\\'ve probably read the top voted solution. Here is an illustration to see why we need to get the minimum of the three values:\\n\\n![image](https://assets.leetcode.com/users/meatbag/image_1566784421.png)\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "* <a href=\"https://www.techiedelight.com/find-maximum-sum-submatrix-in-given-matrix/\">Find maximum sum K x K sub-matrix in a given M x N matrix</a>\\n* <a href=\"https://www.techiedelight.com/find-maximum-sum-submatrix-present-given-matrix/\">Find maximum sum submatrix present in a given matrix</a>"
                    },
                    {
                        "username": "vikassaini",
                        "content": "when i submitted my code in maximum square then it say required from here.Why this is happening ?"
                    },
                    {
                        "username": "batsy01",
                        "content": "for half a day, me dumbass trying to find maximum rectangle area instead of square"
                    },
                    {
                        "username": "yogita_upadhyay",
                        "content": "The catch here is that for a cell (i, j) to be botttom corner for a sqaure of length n lets say 3, cells [i-1, j], [i-1, j-1], [i, j-1], all three shoule be bottom right of a square of length n-1 e.g. of length 2.\\n\\n![image](https://assets.leetcode.com/users/images/e6f90fb2-0d2a-4ed3-92b3-5de2b64ab3a7_1647908252.6751.png)\\n"
                    },
                    {
                        "username": "tianmao",
                        "content": "![image](https://assets.leetcode.com/users/tianmao/image_1558571755.png)\\n"
                    }
                ]
            },
            {
                "id": 1572694,
                "content": [
                    {
                        "username": "koff82",
                        "content": "Dear Leetcode team: could you change the inputs to be integers? I see no reason to use chars, and it would be more elegant in the code not to have to deal with chars. This tripped me up a few times at the beginning of writing down the solution. "
                    },
                    {
                        "username": "me-oniichan",
                        "content": "[@lastmanstandingzone](/lastmanstandingzone) just use `bool` at this point"
                    },
                    {
                        "username": "lastmanstandingzone",
                        "content": "char required less storage as compared to integer"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximal-square/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force [Accepted]\n\n  \n**Approach 2:** (Dynamic Programming) [Accepted]\n\n  \n**Approach 3:** (Better Dynamic Programming) [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "nzwice",
                        "content": "Recall that dp[i, j] is the longest square side possible upto (i, j) where matrix[i, j] = \\'1\\'. Here I will prove why dp[i, j] = 1 + min(dp[i-1, j] + dp[i, j-1] + dp[i-1, j-1])\\n\\nAssume that dp[i, j], dp[i-1, j], dp[i, j-1], dp[i-1, j-1] equal to f, x, y, z respectively.\\n\\nFirst: f > x + 1 is impossible, because if it were, by drawing on the matrix, you will see that dp[i-1, j] > x, which is not our desires. So: f <= x + 1. \\nSimilarly, we have f <= y + 1, and f <= z + 1\\nSo far, what we got is f <= min(x+1, y+1, z+1)\\nNow let P = min(x+1, y+1, z+1), we have 3 cases:\\n* P = x+1, which means y >= x and z >= x. By some drawing, you will see that f = x+1\\n* P = y+1, which means x >= y and z >= y. By some drawing, f = y+1 also.\\n* P = z+1 (similarly).\\nWith above 3 cases, we have f = P = min(x+1, y+1, z+1) = 1 + min(x,y,z).\\n\\n\\n\\n"
                    },
                    {
                        "username": "dhakiptk",
                        "content": "thanks a lot for this"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "It took me half an hour to figure out where am I going wrong, lately I realized that the matrix is given as char and not int. "
                    },
                    {
                        "username": "d00mer",
                        "content": "By now, you\\'ve probably read the top voted solution. Here is an illustration to see why we need to get the minimum of the three values:\\n\\n![image](https://assets.leetcode.com/users/meatbag/image_1566784421.png)\\n"
                    },
                    {
                        "username": "max_223",
                        "content": "* <a href=\"https://www.techiedelight.com/find-maximum-sum-submatrix-in-given-matrix/\">Find maximum sum K x K sub-matrix in a given M x N matrix</a>\\n* <a href=\"https://www.techiedelight.com/find-maximum-sum-submatrix-present-given-matrix/\">Find maximum sum submatrix present in a given matrix</a>"
                    },
                    {
                        "username": "vikassaini",
                        "content": "when i submitted my code in maximum square then it say required from here.Why this is happening ?"
                    },
                    {
                        "username": "batsy01",
                        "content": "for half a day, me dumbass trying to find maximum rectangle area instead of square"
                    },
                    {
                        "username": "yogita_upadhyay",
                        "content": "The catch here is that for a cell (i, j) to be botttom corner for a sqaure of length n lets say 3, cells [i-1, j], [i-1, j-1], [i, j-1], all three shoule be bottom right of a square of length n-1 e.g. of length 2.\\n\\n![image](https://assets.leetcode.com/users/images/e6f90fb2-0d2a-4ed3-92b3-5de2b64ab3a7_1647908252.6751.png)\\n"
                    },
                    {
                        "username": "tianmao",
                        "content": "![image](https://assets.leetcode.com/users/tianmao/image_1558571755.png)\\n"
                    }
                ]
            },
            {
                "id": 1571451,
                "content": [
                    {
                        "username": "ganeshdudwadkar",
                        "content": "I dont understand why they need input as char and somehow upon submission its giving error for input [\"01\"]. How come thats a char input? Basically I wanted to set max to matrix[0][0] but its not working as they have messed up the input form.\\n\\n    int max = Character.getNumericValue(matrix[0][0])"
                    },
                    {
                        "username": "jianhualiu2",
                        "content": "Input:\\n[\"11\"]\\nOutput:\\n2\\nExpected:\\n1\\n\\nWhy expect 1?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "c\\'mon bro, FR ?"
                    },
                    {
                        "username": "godshiva",
                        "content": "Because a square must have the same length as width\\nSince the height is only 1, the width of the largest square can only be 1 as well"
                    },
                    {
                        "username": "pandora111",
                        "content": "This description says \"Given a 2D binary matrix filled with 0\\'s and 1\\'s\" but a test case was a 1x1 matrix with a single value.  A matrix containing a single character is an illegalment because it is NOT filled with 0\\'s and 1\\'s!!!  And it\\'s very annoy to account for these stupid illegalment edge cases that contradicts with the description of the problem!\\n\\n\\n"
                    },
                    {
                        "username": "taxaditya13121989",
                        "content": "This problem is similar to Count Submatrices with ones, I just found the maximum value in DP array and squared it to get the maximum answer, if you look closely then you will find out why I squared it.\\n"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I watch a video on this problem (we had this as a challenge in 42 Piscine) which explained how to work this out iteratively.\\n\\nYou just start at the (x = 1, y = 1) and iterate through the matrx adding (if not 0) the minimum value of each points left, upper left, and upper neighbours.\\n\\nVery easy to code and works beautifully."
                    },
                    {
                        "username": "tuningfolk",
                        "content": "What a beautiful problem"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "There are two, ie O(N3) and O(N2) solution. If anyone wants a challenge figure both of them out."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "//O ( M*N )\\n\\n//This is best Approch and very simple to understandable\\n\\nclass Solution {\\npublic:\\n    \\n    int maximalSquare(vector<vector<char>>&matrix){\\n  \\n  if(matrix.size() ==0)return 0;\\n  int row = matrix.size();int cols = matrix[0].size();\\n\\n  int max_indp =0;\\n\\n  int **dp = new int*[row];\\n\\n   for(int i=0;i<row;i++) dp[i] = new int[cols];\\n\\n   for(int j=0;j<cols;j++){\\n       dp[row-1][j] = matrix[row-1][j] -\\'0\\';\\n       max_indp  = max(max_indp,dp[row-1][j]);\\n   }\\n   for(int j=0;j<row;j++){\\n       dp[j][cols-1] = matrix[j][cols-1] -\\'0\\';\\n       max_indp  = max(max_indp,dp[j][cols-1]);\\n   }\\n\\n   for(int i=row-2;i>=0;i--){\\n       for(int j=cols-2;j>=0;j--){\\n\\n           int step1 = dp[i][j+1];\\n           int step2 = dp[i+1][j];\\n           int step3 = dp[i+1][j+1];\\n\\n           int ans = min(step1,min(step2,step3));\\n\\n           if(matrix[i][j] ==\\'0\\') dp[i][j]=0;\\n           else{\\n               ans++;\\n               max_indp = max(max_indp,ans);\\n               dp[i][j]=ans;\\n           }\\n       }\\n   }\\n  return max_indp*max_indp;\\n}\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "//This is best Rules and very easy to understand.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ulab888",
                        "content": "```\nclass Solution {\n    char[][] matrix;\n    int m;\n    int n;\n    int max;\n    public int maximalSquare(char[][] matrix) {\n        this.matrix=matrix;\n        m=matrix.length;\n        n=matrix[0].length;\n        Integer[][] dp=new Integer[m][n];\n        // topDown(m-1,n-1, dp);\n        bottomUp();\n        return max;\n    }\n    \n    int topDown(int row,int col, Integer[][] dp){\n        //return 0 if array out of bounds\n        if(row<0 || row>=m|| col<0 || col>=n)\n            return 0;\n        if(dp[row][col]!=null)\n            return dp[row][col];\n        /*fill the max area at the bottom right corner of a sqaure.\n        It depdendes on top, diagoanal and left cells. Recursive they depend on their prev cells\n        start with 1x1, 2x2, 3x3....*/\n        int top=topDown(row-1,col,dp);\n        int dia=topDown(row-1,col-1,dp);\n        int left=topDown(row,col-1,dp);\n        if(matrix[row][col]!='0'){\n            int min=(int)Math.min(top,Math.min(dia,left));\n            /*formula: find min of top,left and dia; lets say Min(16,9,4)=4, if current cell value is 1\n             it means it will form 3x3 area. so square(sqrt(4)+1)\n            */\n            int result=(int)Math.pow(Math.sqrt(min)+(matrix[row][col]-'0'),2);\n            max=(int)Math.max(result,max);\n            dp[row][col]=result;\n            return result;\n        }\n        dp[row][col]=0;\n        return 0;\n    }\n    \n    void bottomUp(){\n        int[][] dp=new int[m][n];\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(i==0 || j==0){\n                    dp[i][j]=matrix[i][j]-'0';\n                } else if(matrix[i][j]!='0'){\n                    int min=(int)Math.min(dp[i-1][j],Math.min(dp[i-1][j-1],dp[i][j-1]));\n                    dp[i][j]=(int)Math.pow(Math.sqrt(min)+(matrix[i][j]-'0'),2);\n                }\n                max=Math.max(max,dp[i][j]);\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1571452,
                "content": [
                    {
                        "username": "ganeshdudwadkar",
                        "content": "I dont understand why they need input as char and somehow upon submission its giving error for input [\"01\"]. How come thats a char input? Basically I wanted to set max to matrix[0][0] but its not working as they have messed up the input form.\\n\\n    int max = Character.getNumericValue(matrix[0][0])"
                    },
                    {
                        "username": "jianhualiu2",
                        "content": "Input:\\n[\"11\"]\\nOutput:\\n2\\nExpected:\\n1\\n\\nWhy expect 1?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "c\\'mon bro, FR ?"
                    },
                    {
                        "username": "godshiva",
                        "content": "Because a square must have the same length as width\\nSince the height is only 1, the width of the largest square can only be 1 as well"
                    },
                    {
                        "username": "pandora111",
                        "content": "This description says \"Given a 2D binary matrix filled with 0\\'s and 1\\'s\" but a test case was a 1x1 matrix with a single value.  A matrix containing a single character is an illegalment because it is NOT filled with 0\\'s and 1\\'s!!!  And it\\'s very annoy to account for these stupid illegalment edge cases that contradicts with the description of the problem!\\n\\n\\n"
                    },
                    {
                        "username": "taxaditya13121989",
                        "content": "This problem is similar to Count Submatrices with ones, I just found the maximum value in DP array and squared it to get the maximum answer, if you look closely then you will find out why I squared it.\\n"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I watch a video on this problem (we had this as a challenge in 42 Piscine) which explained how to work this out iteratively.\\n\\nYou just start at the (x = 1, y = 1) and iterate through the matrx adding (if not 0) the minimum value of each points left, upper left, and upper neighbours.\\n\\nVery easy to code and works beautifully."
                    },
                    {
                        "username": "tuningfolk",
                        "content": "What a beautiful problem"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "There are two, ie O(N3) and O(N2) solution. If anyone wants a challenge figure both of them out."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "//O ( M*N )\\n\\n//This is best Approch and very simple to understandable\\n\\nclass Solution {\\npublic:\\n    \\n    int maximalSquare(vector<vector<char>>&matrix){\\n  \\n  if(matrix.size() ==0)return 0;\\n  int row = matrix.size();int cols = matrix[0].size();\\n\\n  int max_indp =0;\\n\\n  int **dp = new int*[row];\\n\\n   for(int i=0;i<row;i++) dp[i] = new int[cols];\\n\\n   for(int j=0;j<cols;j++){\\n       dp[row-1][j] = matrix[row-1][j] -\\'0\\';\\n       max_indp  = max(max_indp,dp[row-1][j]);\\n   }\\n   for(int j=0;j<row;j++){\\n       dp[j][cols-1] = matrix[j][cols-1] -\\'0\\';\\n       max_indp  = max(max_indp,dp[j][cols-1]);\\n   }\\n\\n   for(int i=row-2;i>=0;i--){\\n       for(int j=cols-2;j>=0;j--){\\n\\n           int step1 = dp[i][j+1];\\n           int step2 = dp[i+1][j];\\n           int step3 = dp[i+1][j+1];\\n\\n           int ans = min(step1,min(step2,step3));\\n\\n           if(matrix[i][j] ==\\'0\\') dp[i][j]=0;\\n           else{\\n               ans++;\\n               max_indp = max(max_indp,ans);\\n               dp[i][j]=ans;\\n           }\\n       }\\n   }\\n  return max_indp*max_indp;\\n}\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "//This is best Rules and very easy to understand.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ulab888",
                        "content": "```\nclass Solution {\n    char[][] matrix;\n    int m;\n    int n;\n    int max;\n    public int maximalSquare(char[][] matrix) {\n        this.matrix=matrix;\n        m=matrix.length;\n        n=matrix[0].length;\n        Integer[][] dp=new Integer[m][n];\n        // topDown(m-1,n-1, dp);\n        bottomUp();\n        return max;\n    }\n    \n    int topDown(int row,int col, Integer[][] dp){\n        //return 0 if array out of bounds\n        if(row<0 || row>=m|| col<0 || col>=n)\n            return 0;\n        if(dp[row][col]!=null)\n            return dp[row][col];\n        /*fill the max area at the bottom right corner of a sqaure.\n        It depdendes on top, diagoanal and left cells. Recursive they depend on their prev cells\n        start with 1x1, 2x2, 3x3....*/\n        int top=topDown(row-1,col,dp);\n        int dia=topDown(row-1,col-1,dp);\n        int left=topDown(row,col-1,dp);\n        if(matrix[row][col]!='0'){\n            int min=(int)Math.min(top,Math.min(dia,left));\n            /*formula: find min of top,left and dia; lets say Min(16,9,4)=4, if current cell value is 1\n             it means it will form 3x3 area. so square(sqrt(4)+1)\n            */\n            int result=(int)Math.pow(Math.sqrt(min)+(matrix[row][col]-'0'),2);\n            max=(int)Math.max(result,max);\n            dp[row][col]=result;\n            return result;\n        }\n        dp[row][col]=0;\n        return 0;\n    }\n    \n    void bottomUp(){\n        int[][] dp=new int[m][n];\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(i==0 || j==0){\n                    dp[i][j]=matrix[i][j]-'0';\n                } else if(matrix[i][j]!='0'){\n                    int min=(int)Math.min(dp[i-1][j],Math.min(dp[i-1][j-1],dp[i][j-1]));\n                    dp[i][j]=(int)Math.pow(Math.sqrt(min)+(matrix[i][j]-'0'),2);\n                }\n                max=Math.max(max,dp[i][j]);\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1573420,
                "content": [
                    {
                        "username": "ganeshdudwadkar",
                        "content": "I dont understand why they need input as char and somehow upon submission its giving error for input [\"01\"]. How come thats a char input? Basically I wanted to set max to matrix[0][0] but its not working as they have messed up the input form.\\n\\n    int max = Character.getNumericValue(matrix[0][0])"
                    },
                    {
                        "username": "jianhualiu2",
                        "content": "Input:\\n[\"11\"]\\nOutput:\\n2\\nExpected:\\n1\\n\\nWhy expect 1?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "c\\'mon bro, FR ?"
                    },
                    {
                        "username": "godshiva",
                        "content": "Because a square must have the same length as width\\nSince the height is only 1, the width of the largest square can only be 1 as well"
                    },
                    {
                        "username": "pandora111",
                        "content": "This description says \"Given a 2D binary matrix filled with 0\\'s and 1\\'s\" but a test case was a 1x1 matrix with a single value.  A matrix containing a single character is an illegalment because it is NOT filled with 0\\'s and 1\\'s!!!  And it\\'s very annoy to account for these stupid illegalment edge cases that contradicts with the description of the problem!\\n\\n\\n"
                    },
                    {
                        "username": "taxaditya13121989",
                        "content": "This problem is similar to Count Submatrices with ones, I just found the maximum value in DP array and squared it to get the maximum answer, if you look closely then you will find out why I squared it.\\n"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I watch a video on this problem (we had this as a challenge in 42 Piscine) which explained how to work this out iteratively.\\n\\nYou just start at the (x = 1, y = 1) and iterate through the matrx adding (if not 0) the minimum value of each points left, upper left, and upper neighbours.\\n\\nVery easy to code and works beautifully."
                    },
                    {
                        "username": "tuningfolk",
                        "content": "What a beautiful problem"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "There are two, ie O(N3) and O(N2) solution. If anyone wants a challenge figure both of them out."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "//O ( M*N )\\n\\n//This is best Approch and very simple to understandable\\n\\nclass Solution {\\npublic:\\n    \\n    int maximalSquare(vector<vector<char>>&matrix){\\n  \\n  if(matrix.size() ==0)return 0;\\n  int row = matrix.size();int cols = matrix[0].size();\\n\\n  int max_indp =0;\\n\\n  int **dp = new int*[row];\\n\\n   for(int i=0;i<row;i++) dp[i] = new int[cols];\\n\\n   for(int j=0;j<cols;j++){\\n       dp[row-1][j] = matrix[row-1][j] -\\'0\\';\\n       max_indp  = max(max_indp,dp[row-1][j]);\\n   }\\n   for(int j=0;j<row;j++){\\n       dp[j][cols-1] = matrix[j][cols-1] -\\'0\\';\\n       max_indp  = max(max_indp,dp[j][cols-1]);\\n   }\\n\\n   for(int i=row-2;i>=0;i--){\\n       for(int j=cols-2;j>=0;j--){\\n\\n           int step1 = dp[i][j+1];\\n           int step2 = dp[i+1][j];\\n           int step3 = dp[i+1][j+1];\\n\\n           int ans = min(step1,min(step2,step3));\\n\\n           if(matrix[i][j] ==\\'0\\') dp[i][j]=0;\\n           else{\\n               ans++;\\n               max_indp = max(max_indp,ans);\\n               dp[i][j]=ans;\\n           }\\n       }\\n   }\\n  return max_indp*max_indp;\\n}\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "//This is best Rules and very easy to understand.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ulab888",
                        "content": "```\nclass Solution {\n    char[][] matrix;\n    int m;\n    int n;\n    int max;\n    public int maximalSquare(char[][] matrix) {\n        this.matrix=matrix;\n        m=matrix.length;\n        n=matrix[0].length;\n        Integer[][] dp=new Integer[m][n];\n        // topDown(m-1,n-1, dp);\n        bottomUp();\n        return max;\n    }\n    \n    int topDown(int row,int col, Integer[][] dp){\n        //return 0 if array out of bounds\n        if(row<0 || row>=m|| col<0 || col>=n)\n            return 0;\n        if(dp[row][col]!=null)\n            return dp[row][col];\n        /*fill the max area at the bottom right corner of a sqaure.\n        It depdendes on top, diagoanal and left cells. Recursive they depend on their prev cells\n        start with 1x1, 2x2, 3x3....*/\n        int top=topDown(row-1,col,dp);\n        int dia=topDown(row-1,col-1,dp);\n        int left=topDown(row,col-1,dp);\n        if(matrix[row][col]!='0'){\n            int min=(int)Math.min(top,Math.min(dia,left));\n            /*formula: find min of top,left and dia; lets say Min(16,9,4)=4, if current cell value is 1\n             it means it will form 3x3 area. so square(sqrt(4)+1)\n            */\n            int result=(int)Math.pow(Math.sqrt(min)+(matrix[row][col]-'0'),2);\n            max=(int)Math.max(result,max);\n            dp[row][col]=result;\n            return result;\n        }\n        dp[row][col]=0;\n        return 0;\n    }\n    \n    void bottomUp(){\n        int[][] dp=new int[m][n];\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(i==0 || j==0){\n                    dp[i][j]=matrix[i][j]-'0';\n                } else if(matrix[i][j]!='0'){\n                    int min=(int)Math.min(dp[i-1][j],Math.min(dp[i-1][j-1],dp[i][j-1]));\n                    dp[i][j]=(int)Math.pow(Math.sqrt(min)+(matrix[i][j]-'0'),2);\n                }\n                max=Math.max(max,dp[i][j]);\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2014211,
                "content": [
                    {
                        "username": "ganeshdudwadkar",
                        "content": "I dont understand why they need input as char and somehow upon submission its giving error for input [\"01\"]. How come thats a char input? Basically I wanted to set max to matrix[0][0] but its not working as they have messed up the input form.\\n\\n    int max = Character.getNumericValue(matrix[0][0])"
                    },
                    {
                        "username": "jianhualiu2",
                        "content": "Input:\\n[\"11\"]\\nOutput:\\n2\\nExpected:\\n1\\n\\nWhy expect 1?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "c\\'mon bro, FR ?"
                    },
                    {
                        "username": "godshiva",
                        "content": "Because a square must have the same length as width\\nSince the height is only 1, the width of the largest square can only be 1 as well"
                    },
                    {
                        "username": "pandora111",
                        "content": "This description says \"Given a 2D binary matrix filled with 0\\'s and 1\\'s\" but a test case was a 1x1 matrix with a single value.  A matrix containing a single character is an illegalment because it is NOT filled with 0\\'s and 1\\'s!!!  And it\\'s very annoy to account for these stupid illegalment edge cases that contradicts with the description of the problem!\\n\\n\\n"
                    },
                    {
                        "username": "taxaditya13121989",
                        "content": "This problem is similar to Count Submatrices with ones, I just found the maximum value in DP array and squared it to get the maximum answer, if you look closely then you will find out why I squared it.\\n"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I watch a video on this problem (we had this as a challenge in 42 Piscine) which explained how to work this out iteratively.\\n\\nYou just start at the (x = 1, y = 1) and iterate through the matrx adding (if not 0) the minimum value of each points left, upper left, and upper neighbours.\\n\\nVery easy to code and works beautifully."
                    },
                    {
                        "username": "tuningfolk",
                        "content": "What a beautiful problem"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "There are two, ie O(N3) and O(N2) solution. If anyone wants a challenge figure both of them out."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "//O ( M*N )\\n\\n//This is best Approch and very simple to understandable\\n\\nclass Solution {\\npublic:\\n    \\n    int maximalSquare(vector<vector<char>>&matrix){\\n  \\n  if(matrix.size() ==0)return 0;\\n  int row = matrix.size();int cols = matrix[0].size();\\n\\n  int max_indp =0;\\n\\n  int **dp = new int*[row];\\n\\n   for(int i=0;i<row;i++) dp[i] = new int[cols];\\n\\n   for(int j=0;j<cols;j++){\\n       dp[row-1][j] = matrix[row-1][j] -\\'0\\';\\n       max_indp  = max(max_indp,dp[row-1][j]);\\n   }\\n   for(int j=0;j<row;j++){\\n       dp[j][cols-1] = matrix[j][cols-1] -\\'0\\';\\n       max_indp  = max(max_indp,dp[j][cols-1]);\\n   }\\n\\n   for(int i=row-2;i>=0;i--){\\n       for(int j=cols-2;j>=0;j--){\\n\\n           int step1 = dp[i][j+1];\\n           int step2 = dp[i+1][j];\\n           int step3 = dp[i+1][j+1];\\n\\n           int ans = min(step1,min(step2,step3));\\n\\n           if(matrix[i][j] ==\\'0\\') dp[i][j]=0;\\n           else{\\n               ans++;\\n               max_indp = max(max_indp,ans);\\n               dp[i][j]=ans;\\n           }\\n       }\\n   }\\n  return max_indp*max_indp;\\n}\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "//This is best Rules and very easy to understand.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ulab888",
                        "content": "```\nclass Solution {\n    char[][] matrix;\n    int m;\n    int n;\n    int max;\n    public int maximalSquare(char[][] matrix) {\n        this.matrix=matrix;\n        m=matrix.length;\n        n=matrix[0].length;\n        Integer[][] dp=new Integer[m][n];\n        // topDown(m-1,n-1, dp);\n        bottomUp();\n        return max;\n    }\n    \n    int topDown(int row,int col, Integer[][] dp){\n        //return 0 if array out of bounds\n        if(row<0 || row>=m|| col<0 || col>=n)\n            return 0;\n        if(dp[row][col]!=null)\n            return dp[row][col];\n        /*fill the max area at the bottom right corner of a sqaure.\n        It depdendes on top, diagoanal and left cells. Recursive they depend on their prev cells\n        start with 1x1, 2x2, 3x3....*/\n        int top=topDown(row-1,col,dp);\n        int dia=topDown(row-1,col-1,dp);\n        int left=topDown(row,col-1,dp);\n        if(matrix[row][col]!='0'){\n            int min=(int)Math.min(top,Math.min(dia,left));\n            /*formula: find min of top,left and dia; lets say Min(16,9,4)=4, if current cell value is 1\n             it means it will form 3x3 area. so square(sqrt(4)+1)\n            */\n            int result=(int)Math.pow(Math.sqrt(min)+(matrix[row][col]-'0'),2);\n            max=(int)Math.max(result,max);\n            dp[row][col]=result;\n            return result;\n        }\n        dp[row][col]=0;\n        return 0;\n    }\n    \n    void bottomUp(){\n        int[][] dp=new int[m][n];\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(i==0 || j==0){\n                    dp[i][j]=matrix[i][j]-'0';\n                } else if(matrix[i][j]!='0'){\n                    int min=(int)Math.min(dp[i-1][j],Math.min(dp[i-1][j-1],dp[i][j-1]));\n                    dp[i][j]=(int)Math.pow(Math.sqrt(min)+(matrix[i][j]-'0'),2);\n                }\n                max=Math.max(max,dp[i][j]);\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2006686,
                "content": [
                    {
                        "username": "ganeshdudwadkar",
                        "content": "I dont understand why they need input as char and somehow upon submission its giving error for input [\"01\"]. How come thats a char input? Basically I wanted to set max to matrix[0][0] but its not working as they have messed up the input form.\\n\\n    int max = Character.getNumericValue(matrix[0][0])"
                    },
                    {
                        "username": "jianhualiu2",
                        "content": "Input:\\n[\"11\"]\\nOutput:\\n2\\nExpected:\\n1\\n\\nWhy expect 1?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "c\\'mon bro, FR ?"
                    },
                    {
                        "username": "godshiva",
                        "content": "Because a square must have the same length as width\\nSince the height is only 1, the width of the largest square can only be 1 as well"
                    },
                    {
                        "username": "pandora111",
                        "content": "This description says \"Given a 2D binary matrix filled with 0\\'s and 1\\'s\" but a test case was a 1x1 matrix with a single value.  A matrix containing a single character is an illegalment because it is NOT filled with 0\\'s and 1\\'s!!!  And it\\'s very annoy to account for these stupid illegalment edge cases that contradicts with the description of the problem!\\n\\n\\n"
                    },
                    {
                        "username": "taxaditya13121989",
                        "content": "This problem is similar to Count Submatrices with ones, I just found the maximum value in DP array and squared it to get the maximum answer, if you look closely then you will find out why I squared it.\\n"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I watch a video on this problem (we had this as a challenge in 42 Piscine) which explained how to work this out iteratively.\\n\\nYou just start at the (x = 1, y = 1) and iterate through the matrx adding (if not 0) the minimum value of each points left, upper left, and upper neighbours.\\n\\nVery easy to code and works beautifully."
                    },
                    {
                        "username": "tuningfolk",
                        "content": "What a beautiful problem"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "There are two, ie O(N3) and O(N2) solution. If anyone wants a challenge figure both of them out."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "//O ( M*N )\\n\\n//This is best Approch and very simple to understandable\\n\\nclass Solution {\\npublic:\\n    \\n    int maximalSquare(vector<vector<char>>&matrix){\\n  \\n  if(matrix.size() ==0)return 0;\\n  int row = matrix.size();int cols = matrix[0].size();\\n\\n  int max_indp =0;\\n\\n  int **dp = new int*[row];\\n\\n   for(int i=0;i<row;i++) dp[i] = new int[cols];\\n\\n   for(int j=0;j<cols;j++){\\n       dp[row-1][j] = matrix[row-1][j] -\\'0\\';\\n       max_indp  = max(max_indp,dp[row-1][j]);\\n   }\\n   for(int j=0;j<row;j++){\\n       dp[j][cols-1] = matrix[j][cols-1] -\\'0\\';\\n       max_indp  = max(max_indp,dp[j][cols-1]);\\n   }\\n\\n   for(int i=row-2;i>=0;i--){\\n       for(int j=cols-2;j>=0;j--){\\n\\n           int step1 = dp[i][j+1];\\n           int step2 = dp[i+1][j];\\n           int step3 = dp[i+1][j+1];\\n\\n           int ans = min(step1,min(step2,step3));\\n\\n           if(matrix[i][j] ==\\'0\\') dp[i][j]=0;\\n           else{\\n               ans++;\\n               max_indp = max(max_indp,ans);\\n               dp[i][j]=ans;\\n           }\\n       }\\n   }\\n  return max_indp*max_indp;\\n}\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "//This is best Rules and very easy to understand.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ulab888",
                        "content": "```\nclass Solution {\n    char[][] matrix;\n    int m;\n    int n;\n    int max;\n    public int maximalSquare(char[][] matrix) {\n        this.matrix=matrix;\n        m=matrix.length;\n        n=matrix[0].length;\n        Integer[][] dp=new Integer[m][n];\n        // topDown(m-1,n-1, dp);\n        bottomUp();\n        return max;\n    }\n    \n    int topDown(int row,int col, Integer[][] dp){\n        //return 0 if array out of bounds\n        if(row<0 || row>=m|| col<0 || col>=n)\n            return 0;\n        if(dp[row][col]!=null)\n            return dp[row][col];\n        /*fill the max area at the bottom right corner of a sqaure.\n        It depdendes on top, diagoanal and left cells. Recursive they depend on their prev cells\n        start with 1x1, 2x2, 3x3....*/\n        int top=topDown(row-1,col,dp);\n        int dia=topDown(row-1,col-1,dp);\n        int left=topDown(row,col-1,dp);\n        if(matrix[row][col]!='0'){\n            int min=(int)Math.min(top,Math.min(dia,left));\n            /*formula: find min of top,left and dia; lets say Min(16,9,4)=4, if current cell value is 1\n             it means it will form 3x3 area. so square(sqrt(4)+1)\n            */\n            int result=(int)Math.pow(Math.sqrt(min)+(matrix[row][col]-'0'),2);\n            max=(int)Math.max(result,max);\n            dp[row][col]=result;\n            return result;\n        }\n        dp[row][col]=0;\n        return 0;\n    }\n    \n    void bottomUp(){\n        int[][] dp=new int[m][n];\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(i==0 || j==0){\n                    dp[i][j]=matrix[i][j]-'0';\n                } else if(matrix[i][j]!='0'){\n                    int min=(int)Math.min(dp[i-1][j],Math.min(dp[i-1][j-1],dp[i][j-1]));\n                    dp[i][j]=(int)Math.pow(Math.sqrt(min)+(matrix[i][j]-'0'),2);\n                }\n                max=Math.max(max,dp[i][j]);\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1967815,
                "content": [
                    {
                        "username": "ganeshdudwadkar",
                        "content": "I dont understand why they need input as char and somehow upon submission its giving error for input [\"01\"]. How come thats a char input? Basically I wanted to set max to matrix[0][0] but its not working as they have messed up the input form.\\n\\n    int max = Character.getNumericValue(matrix[0][0])"
                    },
                    {
                        "username": "jianhualiu2",
                        "content": "Input:\\n[\"11\"]\\nOutput:\\n2\\nExpected:\\n1\\n\\nWhy expect 1?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "c\\'mon bro, FR ?"
                    },
                    {
                        "username": "godshiva",
                        "content": "Because a square must have the same length as width\\nSince the height is only 1, the width of the largest square can only be 1 as well"
                    },
                    {
                        "username": "pandora111",
                        "content": "This description says \"Given a 2D binary matrix filled with 0\\'s and 1\\'s\" but a test case was a 1x1 matrix with a single value.  A matrix containing a single character is an illegalment because it is NOT filled with 0\\'s and 1\\'s!!!  And it\\'s very annoy to account for these stupid illegalment edge cases that contradicts with the description of the problem!\\n\\n\\n"
                    },
                    {
                        "username": "taxaditya13121989",
                        "content": "This problem is similar to Count Submatrices with ones, I just found the maximum value in DP array and squared it to get the maximum answer, if you look closely then you will find out why I squared it.\\n"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I watch a video on this problem (we had this as a challenge in 42 Piscine) which explained how to work this out iteratively.\\n\\nYou just start at the (x = 1, y = 1) and iterate through the matrx adding (if not 0) the minimum value of each points left, upper left, and upper neighbours.\\n\\nVery easy to code and works beautifully."
                    },
                    {
                        "username": "tuningfolk",
                        "content": "What a beautiful problem"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "There are two, ie O(N3) and O(N2) solution. If anyone wants a challenge figure both of them out."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "//O ( M*N )\\n\\n//This is best Approch and very simple to understandable\\n\\nclass Solution {\\npublic:\\n    \\n    int maximalSquare(vector<vector<char>>&matrix){\\n  \\n  if(matrix.size() ==0)return 0;\\n  int row = matrix.size();int cols = matrix[0].size();\\n\\n  int max_indp =0;\\n\\n  int **dp = new int*[row];\\n\\n   for(int i=0;i<row;i++) dp[i] = new int[cols];\\n\\n   for(int j=0;j<cols;j++){\\n       dp[row-1][j] = matrix[row-1][j] -\\'0\\';\\n       max_indp  = max(max_indp,dp[row-1][j]);\\n   }\\n   for(int j=0;j<row;j++){\\n       dp[j][cols-1] = matrix[j][cols-1] -\\'0\\';\\n       max_indp  = max(max_indp,dp[j][cols-1]);\\n   }\\n\\n   for(int i=row-2;i>=0;i--){\\n       for(int j=cols-2;j>=0;j--){\\n\\n           int step1 = dp[i][j+1];\\n           int step2 = dp[i+1][j];\\n           int step3 = dp[i+1][j+1];\\n\\n           int ans = min(step1,min(step2,step3));\\n\\n           if(matrix[i][j] ==\\'0\\') dp[i][j]=0;\\n           else{\\n               ans++;\\n               max_indp = max(max_indp,ans);\\n               dp[i][j]=ans;\\n           }\\n       }\\n   }\\n  return max_indp*max_indp;\\n}\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "//This is best Rules and very easy to understand.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ulab888",
                        "content": "```\nclass Solution {\n    char[][] matrix;\n    int m;\n    int n;\n    int max;\n    public int maximalSquare(char[][] matrix) {\n        this.matrix=matrix;\n        m=matrix.length;\n        n=matrix[0].length;\n        Integer[][] dp=new Integer[m][n];\n        // topDown(m-1,n-1, dp);\n        bottomUp();\n        return max;\n    }\n    \n    int topDown(int row,int col, Integer[][] dp){\n        //return 0 if array out of bounds\n        if(row<0 || row>=m|| col<0 || col>=n)\n            return 0;\n        if(dp[row][col]!=null)\n            return dp[row][col];\n        /*fill the max area at the bottom right corner of a sqaure.\n        It depdendes on top, diagoanal and left cells. Recursive they depend on their prev cells\n        start with 1x1, 2x2, 3x3....*/\n        int top=topDown(row-1,col,dp);\n        int dia=topDown(row-1,col-1,dp);\n        int left=topDown(row,col-1,dp);\n        if(matrix[row][col]!='0'){\n            int min=(int)Math.min(top,Math.min(dia,left));\n            /*formula: find min of top,left and dia; lets say Min(16,9,4)=4, if current cell value is 1\n             it means it will form 3x3 area. so square(sqrt(4)+1)\n            */\n            int result=(int)Math.pow(Math.sqrt(min)+(matrix[row][col]-'0'),2);\n            max=(int)Math.max(result,max);\n            dp[row][col]=result;\n            return result;\n        }\n        dp[row][col]=0;\n        return 0;\n    }\n    \n    void bottomUp(){\n        int[][] dp=new int[m][n];\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(i==0 || j==0){\n                    dp[i][j]=matrix[i][j]-'0';\n                } else if(matrix[i][j]!='0'){\n                    int min=(int)Math.min(dp[i-1][j],Math.min(dp[i-1][j-1],dp[i][j-1]));\n                    dp[i][j]=(int)Math.pow(Math.sqrt(min)+(matrix[i][j]-'0'),2);\n                }\n                max=Math.max(max,dp[i][j]);\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1898773,
                "content": [
                    {
                        "username": "ganeshdudwadkar",
                        "content": "I dont understand why they need input as char and somehow upon submission its giving error for input [\"01\"]. How come thats a char input? Basically I wanted to set max to matrix[0][0] but its not working as they have messed up the input form.\\n\\n    int max = Character.getNumericValue(matrix[0][0])"
                    },
                    {
                        "username": "jianhualiu2",
                        "content": "Input:\\n[\"11\"]\\nOutput:\\n2\\nExpected:\\n1\\n\\nWhy expect 1?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "c\\'mon bro, FR ?"
                    },
                    {
                        "username": "godshiva",
                        "content": "Because a square must have the same length as width\\nSince the height is only 1, the width of the largest square can only be 1 as well"
                    },
                    {
                        "username": "pandora111",
                        "content": "This description says \"Given a 2D binary matrix filled with 0\\'s and 1\\'s\" but a test case was a 1x1 matrix with a single value.  A matrix containing a single character is an illegalment because it is NOT filled with 0\\'s and 1\\'s!!!  And it\\'s very annoy to account for these stupid illegalment edge cases that contradicts with the description of the problem!\\n\\n\\n"
                    },
                    {
                        "username": "taxaditya13121989",
                        "content": "This problem is similar to Count Submatrices with ones, I just found the maximum value in DP array and squared it to get the maximum answer, if you look closely then you will find out why I squared it.\\n"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I watch a video on this problem (we had this as a challenge in 42 Piscine) which explained how to work this out iteratively.\\n\\nYou just start at the (x = 1, y = 1) and iterate through the matrx adding (if not 0) the minimum value of each points left, upper left, and upper neighbours.\\n\\nVery easy to code and works beautifully."
                    },
                    {
                        "username": "tuningfolk",
                        "content": "What a beautiful problem"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "There are two, ie O(N3) and O(N2) solution. If anyone wants a challenge figure both of them out."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "//O ( M*N )\\n\\n//This is best Approch and very simple to understandable\\n\\nclass Solution {\\npublic:\\n    \\n    int maximalSquare(vector<vector<char>>&matrix){\\n  \\n  if(matrix.size() ==0)return 0;\\n  int row = matrix.size();int cols = matrix[0].size();\\n\\n  int max_indp =0;\\n\\n  int **dp = new int*[row];\\n\\n   for(int i=0;i<row;i++) dp[i] = new int[cols];\\n\\n   for(int j=0;j<cols;j++){\\n       dp[row-1][j] = matrix[row-1][j] -\\'0\\';\\n       max_indp  = max(max_indp,dp[row-1][j]);\\n   }\\n   for(int j=0;j<row;j++){\\n       dp[j][cols-1] = matrix[j][cols-1] -\\'0\\';\\n       max_indp  = max(max_indp,dp[j][cols-1]);\\n   }\\n\\n   for(int i=row-2;i>=0;i--){\\n       for(int j=cols-2;j>=0;j--){\\n\\n           int step1 = dp[i][j+1];\\n           int step2 = dp[i+1][j];\\n           int step3 = dp[i+1][j+1];\\n\\n           int ans = min(step1,min(step2,step3));\\n\\n           if(matrix[i][j] ==\\'0\\') dp[i][j]=0;\\n           else{\\n               ans++;\\n               max_indp = max(max_indp,ans);\\n               dp[i][j]=ans;\\n           }\\n       }\\n   }\\n  return max_indp*max_indp;\\n}\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "//This is best Rules and very easy to understand.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ulab888",
                        "content": "```\nclass Solution {\n    char[][] matrix;\n    int m;\n    int n;\n    int max;\n    public int maximalSquare(char[][] matrix) {\n        this.matrix=matrix;\n        m=matrix.length;\n        n=matrix[0].length;\n        Integer[][] dp=new Integer[m][n];\n        // topDown(m-1,n-1, dp);\n        bottomUp();\n        return max;\n    }\n    \n    int topDown(int row,int col, Integer[][] dp){\n        //return 0 if array out of bounds\n        if(row<0 || row>=m|| col<0 || col>=n)\n            return 0;\n        if(dp[row][col]!=null)\n            return dp[row][col];\n        /*fill the max area at the bottom right corner of a sqaure.\n        It depdendes on top, diagoanal and left cells. Recursive they depend on their prev cells\n        start with 1x1, 2x2, 3x3....*/\n        int top=topDown(row-1,col,dp);\n        int dia=topDown(row-1,col-1,dp);\n        int left=topDown(row,col-1,dp);\n        if(matrix[row][col]!='0'){\n            int min=(int)Math.min(top,Math.min(dia,left));\n            /*formula: find min of top,left and dia; lets say Min(16,9,4)=4, if current cell value is 1\n             it means it will form 3x3 area. so square(sqrt(4)+1)\n            */\n            int result=(int)Math.pow(Math.sqrt(min)+(matrix[row][col]-'0'),2);\n            max=(int)Math.max(result,max);\n            dp[row][col]=result;\n            return result;\n        }\n        dp[row][col]=0;\n        return 0;\n    }\n    \n    void bottomUp(){\n        int[][] dp=new int[m][n];\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(i==0 || j==0){\n                    dp[i][j]=matrix[i][j]-'0';\n                } else if(matrix[i][j]!='0'){\n                    int min=(int)Math.min(dp[i-1][j],Math.min(dp[i-1][j-1],dp[i][j-1]));\n                    dp[i][j]=(int)Math.pow(Math.sqrt(min)+(matrix[i][j]-'0'),2);\n                }\n                max=Math.max(max,dp[i][j]);\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1810678,
                "content": [
                    {
                        "username": "ganeshdudwadkar",
                        "content": "I dont understand why they need input as char and somehow upon submission its giving error for input [\"01\"]. How come thats a char input? Basically I wanted to set max to matrix[0][0] but its not working as they have messed up the input form.\\n\\n    int max = Character.getNumericValue(matrix[0][0])"
                    },
                    {
                        "username": "jianhualiu2",
                        "content": "Input:\\n[\"11\"]\\nOutput:\\n2\\nExpected:\\n1\\n\\nWhy expect 1?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "c\\'mon bro, FR ?"
                    },
                    {
                        "username": "godshiva",
                        "content": "Because a square must have the same length as width\\nSince the height is only 1, the width of the largest square can only be 1 as well"
                    },
                    {
                        "username": "pandora111",
                        "content": "This description says \"Given a 2D binary matrix filled with 0\\'s and 1\\'s\" but a test case was a 1x1 matrix with a single value.  A matrix containing a single character is an illegalment because it is NOT filled with 0\\'s and 1\\'s!!!  And it\\'s very annoy to account for these stupid illegalment edge cases that contradicts with the description of the problem!\\n\\n\\n"
                    },
                    {
                        "username": "taxaditya13121989",
                        "content": "This problem is similar to Count Submatrices with ones, I just found the maximum value in DP array and squared it to get the maximum answer, if you look closely then you will find out why I squared it.\\n"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I watch a video on this problem (we had this as a challenge in 42 Piscine) which explained how to work this out iteratively.\\n\\nYou just start at the (x = 1, y = 1) and iterate through the matrx adding (if not 0) the minimum value of each points left, upper left, and upper neighbours.\\n\\nVery easy to code and works beautifully."
                    },
                    {
                        "username": "tuningfolk",
                        "content": "What a beautiful problem"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "There are two, ie O(N3) and O(N2) solution. If anyone wants a challenge figure both of them out."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "//O ( M*N )\\n\\n//This is best Approch and very simple to understandable\\n\\nclass Solution {\\npublic:\\n    \\n    int maximalSquare(vector<vector<char>>&matrix){\\n  \\n  if(matrix.size() ==0)return 0;\\n  int row = matrix.size();int cols = matrix[0].size();\\n\\n  int max_indp =0;\\n\\n  int **dp = new int*[row];\\n\\n   for(int i=0;i<row;i++) dp[i] = new int[cols];\\n\\n   for(int j=0;j<cols;j++){\\n       dp[row-1][j] = matrix[row-1][j] -\\'0\\';\\n       max_indp  = max(max_indp,dp[row-1][j]);\\n   }\\n   for(int j=0;j<row;j++){\\n       dp[j][cols-1] = matrix[j][cols-1] -\\'0\\';\\n       max_indp  = max(max_indp,dp[j][cols-1]);\\n   }\\n\\n   for(int i=row-2;i>=0;i--){\\n       for(int j=cols-2;j>=0;j--){\\n\\n           int step1 = dp[i][j+1];\\n           int step2 = dp[i+1][j];\\n           int step3 = dp[i+1][j+1];\\n\\n           int ans = min(step1,min(step2,step3));\\n\\n           if(matrix[i][j] ==\\'0\\') dp[i][j]=0;\\n           else{\\n               ans++;\\n               max_indp = max(max_indp,ans);\\n               dp[i][j]=ans;\\n           }\\n       }\\n   }\\n  return max_indp*max_indp;\\n}\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "//This is best Rules and very easy to understand.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ulab888",
                        "content": "```\nclass Solution {\n    char[][] matrix;\n    int m;\n    int n;\n    int max;\n    public int maximalSquare(char[][] matrix) {\n        this.matrix=matrix;\n        m=matrix.length;\n        n=matrix[0].length;\n        Integer[][] dp=new Integer[m][n];\n        // topDown(m-1,n-1, dp);\n        bottomUp();\n        return max;\n    }\n    \n    int topDown(int row,int col, Integer[][] dp){\n        //return 0 if array out of bounds\n        if(row<0 || row>=m|| col<0 || col>=n)\n            return 0;\n        if(dp[row][col]!=null)\n            return dp[row][col];\n        /*fill the max area at the bottom right corner of a sqaure.\n        It depdendes on top, diagoanal and left cells. Recursive they depend on their prev cells\n        start with 1x1, 2x2, 3x3....*/\n        int top=topDown(row-1,col,dp);\n        int dia=topDown(row-1,col-1,dp);\n        int left=topDown(row,col-1,dp);\n        if(matrix[row][col]!='0'){\n            int min=(int)Math.min(top,Math.min(dia,left));\n            /*formula: find min of top,left and dia; lets say Min(16,9,4)=4, if current cell value is 1\n             it means it will form 3x3 area. so square(sqrt(4)+1)\n            */\n            int result=(int)Math.pow(Math.sqrt(min)+(matrix[row][col]-'0'),2);\n            max=(int)Math.max(result,max);\n            dp[row][col]=result;\n            return result;\n        }\n        dp[row][col]=0;\n        return 0;\n    }\n    \n    void bottomUp(){\n        int[][] dp=new int[m][n];\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(i==0 || j==0){\n                    dp[i][j]=matrix[i][j]-'0';\n                } else if(matrix[i][j]!='0'){\n                    int min=(int)Math.min(dp[i-1][j],Math.min(dp[i-1][j-1],dp[i][j-1]));\n                    dp[i][j]=(int)Math.pow(Math.sqrt(min)+(matrix[i][j]-'0'),2);\n                }\n                max=Math.max(max,dp[i][j]);\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1757540,
                "content": [
                    {
                        "username": "ganeshdudwadkar",
                        "content": "I dont understand why they need input as char and somehow upon submission its giving error for input [\"01\"]. How come thats a char input? Basically I wanted to set max to matrix[0][0] but its not working as they have messed up the input form.\\n\\n    int max = Character.getNumericValue(matrix[0][0])"
                    },
                    {
                        "username": "jianhualiu2",
                        "content": "Input:\\n[\"11\"]\\nOutput:\\n2\\nExpected:\\n1\\n\\nWhy expect 1?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "c\\'mon bro, FR ?"
                    },
                    {
                        "username": "godshiva",
                        "content": "Because a square must have the same length as width\\nSince the height is only 1, the width of the largest square can only be 1 as well"
                    },
                    {
                        "username": "pandora111",
                        "content": "This description says \"Given a 2D binary matrix filled with 0\\'s and 1\\'s\" but a test case was a 1x1 matrix with a single value.  A matrix containing a single character is an illegalment because it is NOT filled with 0\\'s and 1\\'s!!!  And it\\'s very annoy to account for these stupid illegalment edge cases that contradicts with the description of the problem!\\n\\n\\n"
                    },
                    {
                        "username": "taxaditya13121989",
                        "content": "This problem is similar to Count Submatrices with ones, I just found the maximum value in DP array and squared it to get the maximum answer, if you look closely then you will find out why I squared it.\\n"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I watch a video on this problem (we had this as a challenge in 42 Piscine) which explained how to work this out iteratively.\\n\\nYou just start at the (x = 1, y = 1) and iterate through the matrx adding (if not 0) the minimum value of each points left, upper left, and upper neighbours.\\n\\nVery easy to code and works beautifully."
                    },
                    {
                        "username": "tuningfolk",
                        "content": "What a beautiful problem"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "There are two, ie O(N3) and O(N2) solution. If anyone wants a challenge figure both of them out."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "//O ( M*N )\\n\\n//This is best Approch and very simple to understandable\\n\\nclass Solution {\\npublic:\\n    \\n    int maximalSquare(vector<vector<char>>&matrix){\\n  \\n  if(matrix.size() ==0)return 0;\\n  int row = matrix.size();int cols = matrix[0].size();\\n\\n  int max_indp =0;\\n\\n  int **dp = new int*[row];\\n\\n   for(int i=0;i<row;i++) dp[i] = new int[cols];\\n\\n   for(int j=0;j<cols;j++){\\n       dp[row-1][j] = matrix[row-1][j] -\\'0\\';\\n       max_indp  = max(max_indp,dp[row-1][j]);\\n   }\\n   for(int j=0;j<row;j++){\\n       dp[j][cols-1] = matrix[j][cols-1] -\\'0\\';\\n       max_indp  = max(max_indp,dp[j][cols-1]);\\n   }\\n\\n   for(int i=row-2;i>=0;i--){\\n       for(int j=cols-2;j>=0;j--){\\n\\n           int step1 = dp[i][j+1];\\n           int step2 = dp[i+1][j];\\n           int step3 = dp[i+1][j+1];\\n\\n           int ans = min(step1,min(step2,step3));\\n\\n           if(matrix[i][j] ==\\'0\\') dp[i][j]=0;\\n           else{\\n               ans++;\\n               max_indp = max(max_indp,ans);\\n               dp[i][j]=ans;\\n           }\\n       }\\n   }\\n  return max_indp*max_indp;\\n}\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "//This is best Rules and very easy to understand.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ulab888",
                        "content": "```\nclass Solution {\n    char[][] matrix;\n    int m;\n    int n;\n    int max;\n    public int maximalSquare(char[][] matrix) {\n        this.matrix=matrix;\n        m=matrix.length;\n        n=matrix[0].length;\n        Integer[][] dp=new Integer[m][n];\n        // topDown(m-1,n-1, dp);\n        bottomUp();\n        return max;\n    }\n    \n    int topDown(int row,int col, Integer[][] dp){\n        //return 0 if array out of bounds\n        if(row<0 || row>=m|| col<0 || col>=n)\n            return 0;\n        if(dp[row][col]!=null)\n            return dp[row][col];\n        /*fill the max area at the bottom right corner of a sqaure.\n        It depdendes on top, diagoanal and left cells. Recursive they depend on their prev cells\n        start with 1x1, 2x2, 3x3....*/\n        int top=topDown(row-1,col,dp);\n        int dia=topDown(row-1,col-1,dp);\n        int left=topDown(row,col-1,dp);\n        if(matrix[row][col]!='0'){\n            int min=(int)Math.min(top,Math.min(dia,left));\n            /*formula: find min of top,left and dia; lets say Min(16,9,4)=4, if current cell value is 1\n             it means it will form 3x3 area. so square(sqrt(4)+1)\n            */\n            int result=(int)Math.pow(Math.sqrt(min)+(matrix[row][col]-'0'),2);\n            max=(int)Math.max(result,max);\n            dp[row][col]=result;\n            return result;\n        }\n        dp[row][col]=0;\n        return 0;\n    }\n    \n    void bottomUp(){\n        int[][] dp=new int[m][n];\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(i==0 || j==0){\n                    dp[i][j]=matrix[i][j]-'0';\n                } else if(matrix[i][j]!='0'){\n                    int min=(int)Math.min(dp[i-1][j],Math.min(dp[i-1][j-1],dp[i][j-1]));\n                    dp[i][j]=(int)Math.pow(Math.sqrt(min)+(matrix[i][j]-'0'),2);\n                }\n                max=Math.max(max,dp[i][j]);\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1708185,
                "content": [
                    {
                        "username": "ganeshdudwadkar",
                        "content": "I dont understand why they need input as char and somehow upon submission its giving error for input [\"01\"]. How come thats a char input? Basically I wanted to set max to matrix[0][0] but its not working as they have messed up the input form.\\n\\n    int max = Character.getNumericValue(matrix[0][0])"
                    },
                    {
                        "username": "jianhualiu2",
                        "content": "Input:\\n[\"11\"]\\nOutput:\\n2\\nExpected:\\n1\\n\\nWhy expect 1?"
                    },
                    {
                        "username": "SeineAle",
                        "content": "c\\'mon bro, FR ?"
                    },
                    {
                        "username": "godshiva",
                        "content": "Because a square must have the same length as width\\nSince the height is only 1, the width of the largest square can only be 1 as well"
                    },
                    {
                        "username": "pandora111",
                        "content": "This description says \"Given a 2D binary matrix filled with 0\\'s and 1\\'s\" but a test case was a 1x1 matrix with a single value.  A matrix containing a single character is an illegalment because it is NOT filled with 0\\'s and 1\\'s!!!  And it\\'s very annoy to account for these stupid illegalment edge cases that contradicts with the description of the problem!\\n\\n\\n"
                    },
                    {
                        "username": "taxaditya13121989",
                        "content": "This problem is similar to Count Submatrices with ones, I just found the maximum value in DP array and squared it to get the maximum answer, if you look closely then you will find out why I squared it.\\n"
                    },
                    {
                        "username": "sam_cee",
                        "content": "I watch a video on this problem (we had this as a challenge in 42 Piscine) which explained how to work this out iteratively.\\n\\nYou just start at the (x = 1, y = 1) and iterate through the matrx adding (if not 0) the minimum value of each points left, upper left, and upper neighbours.\\n\\nVery easy to code and works beautifully."
                    },
                    {
                        "username": "tuningfolk",
                        "content": "What a beautiful problem"
                    },
                    {
                        "username": "grean_peas2020",
                        "content": "There are two, ie O(N3) and O(N2) solution. If anyone wants a challenge figure both of them out."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "//O ( M*N )\\n\\n//This is best Approch and very simple to understandable\\n\\nclass Solution {\\npublic:\\n    \\n    int maximalSquare(vector<vector<char>>&matrix){\\n  \\n  if(matrix.size() ==0)return 0;\\n  int row = matrix.size();int cols = matrix[0].size();\\n\\n  int max_indp =0;\\n\\n  int **dp = new int*[row];\\n\\n   for(int i=0;i<row;i++) dp[i] = new int[cols];\\n\\n   for(int j=0;j<cols;j++){\\n       dp[row-1][j] = matrix[row-1][j] -\\'0\\';\\n       max_indp  = max(max_indp,dp[row-1][j]);\\n   }\\n   for(int j=0;j<row;j++){\\n       dp[j][cols-1] = matrix[j][cols-1] -\\'0\\';\\n       max_indp  = max(max_indp,dp[j][cols-1]);\\n   }\\n\\n   for(int i=row-2;i>=0;i--){\\n       for(int j=cols-2;j>=0;j--){\\n\\n           int step1 = dp[i][j+1];\\n           int step2 = dp[i+1][j];\\n           int step3 = dp[i+1][j+1];\\n\\n           int ans = min(step1,min(step2,step3));\\n\\n           if(matrix[i][j] ==\\'0\\') dp[i][j]=0;\\n           else{\\n               ans++;\\n               max_indp = max(max_indp,ans);\\n               dp[i][j]=ans;\\n           }\\n       }\\n   }\\n  return max_indp*max_indp;\\n}\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "//This is best Rules and very easy to understand.\n\n💡 Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "ulab888",
                        "content": "```\nclass Solution {\n    char[][] matrix;\n    int m;\n    int n;\n    int max;\n    public int maximalSquare(char[][] matrix) {\n        this.matrix=matrix;\n        m=matrix.length;\n        n=matrix[0].length;\n        Integer[][] dp=new Integer[m][n];\n        // topDown(m-1,n-1, dp);\n        bottomUp();\n        return max;\n    }\n    \n    int topDown(int row,int col, Integer[][] dp){\n        //return 0 if array out of bounds\n        if(row<0 || row>=m|| col<0 || col>=n)\n            return 0;\n        if(dp[row][col]!=null)\n            return dp[row][col];\n        /*fill the max area at the bottom right corner of a sqaure.\n        It depdendes on top, diagoanal and left cells. Recursive they depend on their prev cells\n        start with 1x1, 2x2, 3x3....*/\n        int top=topDown(row-1,col,dp);\n        int dia=topDown(row-1,col-1,dp);\n        int left=topDown(row,col-1,dp);\n        if(matrix[row][col]!='0'){\n            int min=(int)Math.min(top,Math.min(dia,left));\n            /*formula: find min of top,left and dia; lets say Min(16,9,4)=4, if current cell value is 1\n             it means it will form 3x3 area. so square(sqrt(4)+1)\n            */\n            int result=(int)Math.pow(Math.sqrt(min)+(matrix[row][col]-'0'),2);\n            max=(int)Math.max(result,max);\n            dp[row][col]=result;\n            return result;\n        }\n        dp[row][col]=0;\n        return 0;\n    }\n    \n    void bottomUp(){\n        int[][] dp=new int[m][n];\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(i==0 || j==0){\n                    dp[i][j]=matrix[i][j]-'0';\n                } else if(matrix[i][j]!='0'){\n                    int min=(int)Math.min(dp[i-1][j],Math.min(dp[i-1][j-1],dp[i][j-1]));\n                    dp[i][j]=(int)Math.pow(Math.sqrt(min)+(matrix[i][j]-'0'),2);\n                }\n                max=Math.max(max,dp[i][j]);\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            }
        ]
    },
    {
        "title": "Number of Distinct Islands II",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1565376,
                "content": [
                    {
                        "username": "iaming",
                        "content": "after rotation or reflection\\nis different from \\nafter rotation or/and reflection\\n!!!"
                    }
                ]
            }
        ]
    }
]