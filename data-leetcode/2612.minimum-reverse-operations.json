[
    {
        "title": "Minimum Reverse Operations",
        "question_content": "You are given an integer n and an integer p in the range [0, n - 1]. Representing a 0-indexed array arr&nbsp;of length n where all positions are set to 0's, except position p which is set to 1.\nYou are also given an integer array banned containing some positions from the array. For the ith position in banned, arr[banned[i]] = 0, and banned[i] != p.\nYou can perform multiple operations on arr. In an operation, you can choose a subarray with size k and reverse the subarray. However, the 1 in arr should never go to any of the positions in banned. In other words, after each operation arr[banned[i]] remains 0.\nReturn an array ans where for each i from [0, n - 1], ans[i] is the minimum number of reverse operations needed to bring the 1 to position i in arr, or -1 if it is impossible.\n\n\tA subarray is a contiguous non-empty sequence of elements within an array.\n\tThe values of ans[i] are independent for all i's.\n\tThe reverse of an array is an array containing the values in reverse order.\n\n&nbsp;\nExample 1:\n\nInput: n = 4, p = 0, banned = [1,2], k = 4\nOutput: [0,-1,-1,1]\nExplanation: In this case k = 4 so there is only one possible reverse operation we can perform, which is reversing the whole array. Initially, 1 is placed at position 0 so the amount of operations we need for position 0 is 0. We can never place a 1 on the banned positions, so the answer for positions 1 and 2 is -1. Finally, with one reverse operation we can bring the 1 to index 3, so the answer for position 3 is 1. \n\nExample 2:\n\nInput: n = 5, p = 0, banned = [2,4], k = 3\nOutput: [0,-1,-1,-1,-1]\nExplanation: In this case the 1 is initially at position 0, so the answer for that position is 0. We can perform reverse operations of size 3. The 1 is currently located at position 0, so we need to reverse the subarray [0, 2] for it to leave that position, but reversing that subarray makes position 2 have a 1, which shouldn't happen. So, we can't move the 1 from position 0, making the result for all the other positions -1. \n\nExample 3:\n\nInput: n = 4, p = 2, banned = [0,1,3], k = 1\nOutput: [-1,-1,0,-1]\nExplanation: In this case we can only perform reverse operations of size 1.&nbsp;So the 1 never changes its position.\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 105\n\t0 <= p <= n - 1\n\t0 <= banned.length <= n - 1\n\t0 <= banned[i] <= n - 1\n\t1 <= k <= n&nbsp;\n\tbanned[i] != p\n\tall values in banned&nbsp;are unique&nbsp;",
        "solutions": [
            {
                "id": 3368273,
                "title": "c-o-nlogn-solution-with-comments-bfs-floodfill-bst-optimization",
                "content": "```\\nclass Solution {\\npublic:\\n    // Returns a range that pivot can be possibly at after reversing a subarray with length k.\\n    inline pair<int, int> getRange(int n, int pivot, int k) {\\n\\t\\t// Left most subarray containing pivot\\n        int l1 = max(0, pivot - k + 1);\\n        int r1 = l1 + k - 1;\\n\\t\\t\\n\\t\\t// Right most subarray containing pivot\\n        int r2 = min(n - 1, pivot + k - 1);\\n        int l2 = r2 - k + 1;\\n\\t\\t\\n\\t\\tint left = r1 - (pivot - l1);\\n        int right = l2 + (r2 - pivot);\\n        return {left, right};\\n    }\\n    \\n    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {\\n        unordered_set<int> bans(banned.begin(), banned.end());\\n        vector<int> ans(n, -1);\\n        // BST to store all nodes not visited yet.\\n        set<int> s[2];\\n\\n        ans[p] = 0;\\n        // Put all available postions in BST, split by parity\\n        for (int i = 0; i < n; i ++)\\n            if (i != p && bans.find(i) == bans.end())\\n                s[i & 1].insert(i);\\n        \\n        // Queue for BFS floodfill.\\n        queue<int> q;\\n        q.push(p);\\n        while (!q.empty()) {\\n            int pivot = q.front();\\n            q.pop();\\n            auto range = getRange(n, pivot, k);\\n\\n            // for current pivot, check if it will visit even positions or odd positions. \\n            int o = (k % 2 == 0) ? (1 - pivot & 1) : (pivot & 1);\\n            //int o = (k & 1) ^ (pivot & 1) ^ 1;\\n\\n            // Find all reachable indexes range on the tree.\\n            auto bg = s[o].lower_bound(range.first);\\n            auto ed = s[o].upper_bound(range.second);\\n\\n            // Visit reachable indexes and update answer.\\n            for (auto it = bg; it != ed; it ++) {\\n                ans[*it] = ans[pivot] + 1;\\n                q.push(*it);\\n            }\\n\\n            // Remove visited indexes from tree.\\n            s[o].erase(bg, ed);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // Returns a range that pivot can be possibly at after reversing a subarray with length k.\\n    inline pair<int, int> getRange(int n, int pivot, int k) {\\n\\t\\t// Left most subarray containing pivot\\n        int l1 = max(0, pivot - k + 1);\\n        int r1 = l1 + k - 1;\\n\\t\\t\\n\\t\\t// Right most subarray containing pivot\\n        int r2 = min(n - 1, pivot + k - 1);\\n        int l2 = r2 - k + 1;\\n\\t\\t\\n\\t\\tint left = r1 - (pivot - l1);\\n        int right = l2 + (r2 - pivot);\\n        return {left, right};\\n    }\\n    \\n    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {\\n        unordered_set<int> bans(banned.begin(), banned.end());\\n        vector<int> ans(n, -1);\\n        // BST to store all nodes not visited yet.\\n        set<int> s[2];\\n\\n        ans[p] = 0;\\n        // Put all available postions in BST, split by parity\\n        for (int i = 0; i < n; i ++)\\n            if (i != p && bans.find(i) == bans.end())\\n                s[i & 1].insert(i);\\n        \\n        // Queue for BFS floodfill.\\n        queue<int> q;\\n        q.push(p);\\n        while (!q.empty()) {\\n            int pivot = q.front();\\n            q.pop();\\n            auto range = getRange(n, pivot, k);\\n\\n            // for current pivot, check if it will visit even positions or odd positions. \\n            int o = (k % 2 == 0) ? (1 - pivot & 1) : (pivot & 1);\\n            //int o = (k & 1) ^ (pivot & 1) ^ 1;\\n\\n            // Find all reachable indexes range on the tree.\\n            auto bg = s[o].lower_bound(range.first);\\n            auto ed = s[o].upper_bound(range.second);\\n\\n            // Visit reachable indexes and update answer.\\n            for (auto it = bg; it != ed; it ++) {\\n                ans[*it] = ans[pivot] + 1;\\n                q.push(*it);\\n            }\\n\\n            // Remove visited indexes from tree.\\n            s[o].erase(bg, ed);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368819,
                "title": "python3-bfs-sortedlist-keep-track-of-remaining-nodes",
                "content": "Evidently, we should start our investigation with the question: if there is a `1` at position `node`, what neighboring nodes `nei` could it reach in one move?\\n\\nLet `i_left = max(0, node - K + 1)`, `i_right = min(node + K - 1, n - 1) - (K - 1)` be the starting positions of the subarray to be reversed.  Then, after reversing subarray `[i, i+K-1]` (for `i` in `[i_left, i_right]`), `node` goes to `nei = i + (i+K-1) - node`.  In the end, `nei` is chosen from some interval `[lo, lo+2, ..., hi]`.\\n\\nArmed with this information, let\\'s do a standard BFS.  However, this is too slow as we are considering the same neighbors a lot.\\n\\nTo remedy this, let\\'s keep track of which nodes haven\\'t been reached by our BFS yet.  We split these by parity into `remaining[0]` and `remaining[1]`.  When we have some interval `[lo, lo+2, ..., hi]` of potential neigbhors, we can query the intersection (of this interval with unvisited nodes) quickly as we only consider each unvisited neighbor once.\\n\\n**Complexity**: Time $$O(N^2)$$, Space: $$O(N)$$.  (`SortedList` dominates the complexity, and for general purposes it can be thought of as contributing $$\\\\approx O(N \\\\log N)$$, but the implementation is actually $$O(N^{\\\\frac{4}{3}})$$, assuming the load constant is chosen as $$m = N^{\\\\frac{1}{3}}$$.)\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def minReverseOperations(self, n, p, banned_vals, K):\\n        remaining = [SortedList(), SortedList()]\\n        banned = set(banned_vals)\\n        for u in range(n):\\n            if u != p and u not in banned:\\n                remaining[u & 1].add(u)\\n\\n        queue = [p]\\n        dist = [-1] * n\\n        dist[p] = 0\\n        for node in queue:\\n            lo = max(node - K + 1, 0)\\n            lo = 2 * lo + K - 1 - node\\n            hi = min(node + K - 1, n - 1) - (K - 1)\\n            hi = 2 * hi + K - 1 - node\\n\\n            for nei in list(remaining[lo % 2].irange(lo, hi)):\\n                queue.append(nei)\\n                dist[nei] = dist[node] + 1\\n                remaining[lo % 2].remove(nei)\\n        \\n        return dist\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def minReverseOperations(self, n, p, banned_vals, K):\\n        remaining = [SortedList(), SortedList()]\\n        banned = set(banned_vals)\\n        for u in range(n):\\n            if u != p and u not in banned:\\n                remaining[u & 1].add(u)\\n\\n        queue = [p]\\n        dist = [-1] * n\\n        dist[p] = 0\\n        for node in queue:\\n            lo = max(node - K + 1, 0)\\n            lo = 2 * lo + K - 1 - node\\n            hi = min(node + K - 1, n - 1) - (K - 1)\\n            hi = 2 * hi + K - 1 - node\\n\\n            for nei in list(remaining[lo % 2].irange(lo, hi)):\\n                queue.append(nei)\\n                dist[nei] = dist[node] + 1\\n                remaining[lo % 2].remove(nei)\\n        \\n        return dist\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369888,
                "title": "c-100-understandable-very-detailed",
                "content": "# Approach 1\\nAt first glance the problem doesn\\'t look very hard. (But it is :))\\nWhat we need to do:\\n1. Mark banned positions\\n2. Start the queue from specified position\\n3. Add to the queue following positions from the current according to the rule from the condition (skip visited positions)\\n4. Go through all of the queue till the end\\n\\nSome remarks before we start:\\n\\nAt the begginng we will mark unvisited position as -1. So if position is not visited at the end it will have correct value. The initial position $$p$$ we mark as visited at $$0$$. When we add any position to the queue we get value from current position and increase it by 1.\\nSo at the end our $$visited$$ array will be the result.\\n\\nAnd about how we get following positions from the current. \\nLet\\'s for example $$k = 6$$ What we can do here:\\n$$ 0 0 0 0 0 1 0 0 0 0 0 $$\\n$$|0 0 0 0 0 1|0 0 0 0 0 $$ => $$|1 0 0 0 0 0|0 0 0 0 0 $$\\n$$ 0|0 0 0 0 1 0|0 0 0 0 $$ => $$ 0|0 1 0 0 0 0|0 0 0 0 $$\\n$$ 0 0|0 0 0 1 0 0|0 0 0 $$ => $$ 0 0|0 0 1 0 0 0|0 0 0 $$\\n$$ 0 0 0|0 0 1 0 0 0|0 0 $$ => $$ 0 0 0|0 0 0 1 0 0|0 0 $$\\n$$ 0 0 0 0|0 1 0 0 0 0|0 $$ => $$ 0 0 0 0|0 0 0 0 1 0|0 $$\\n$$ 0 0 0 0 0|1 0 0 0 0 0|$$ => $$ 0 0 0 0 0|0 0 0 0 0 1|$$\\n\\nSo the starting position is $$position - k + 1$$. And next we get every even position (even if we count from the starting position, not from 0) up to $$position + k - 1$$\\nAlso we should check edge cases when $$position - k + 1 < 0$$ or $$position + k - 1 >= n$$\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) \\n    {\\n        std::vector<int> visited(n, -1);\\n        std::vector<int> ban(n , 0);\\n        for (const int& b: banned)\\n        {\\n            ban[b] = -1;\\n            visited[b] = -1;\\n        }\\n\\n        std::queue<int> q;\\n        q.push(p);\\n        visited[p] = 0;\\n        while (!q.empty())    \\n        {\\n            int curr = q.front();\\n            q.pop();\\n\\n            int begin = curr - k + 1;\\n            int end   = curr + k - 1;\\n\\n            for (int i = begin, start = begin; i <= end; i += 2, ++start)\\n            {\\n                if (start < 0 || start + k - 1 >= n || -1 == ban[i])\\n                    continue;\\n\\n                if (-1 == visited[i])\\n                {\\n                    q.push(i);\\n                    visited[i] = visited[curr] + 1;\\n                }\\n            }\\n        }\\n\\n        return visited;\\n    }\\n};\\n```\\n\\nThis solution is okay, but we get TLE here.\\n\\n# Approach 2\\nImprove check for edge cases first\\n\\n```\\nclass Solution \\n{\\npublic:\\n    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) \\n    {\\n        std::vector<int> visited(n, -1);\\n        std::vector<int> ban(n , 0);\\n        for (const int& b: banned)\\n        {\\n            ban[b] = -1;\\n            visited[b] = -1;\\n        }    \\n\\n        std::queue<int> q;\\n        q.push(p);\\n        visited[p] = 0;\\n        while (!q.empty())    \\n        {\\n            int curr = q.front();\\n            q.pop();\\n\\n            int begin = std::abs(curr - k + 1);\\n            int end   = n - 1 - std::abs(n - curr - k);\\n\\n            for (int i = begin; i <= end; i += 2)\\n            {\\n                if (-1 == ban[i])\\n                    continue;\\n\\n                if (-1 == visited[i])\\n                {\\n                    q.push(i);\\n                    visited[i] = visited[curr] + 1;\\n                }\\n            }\\n        }\\n\\n        return visited;\\n    }\\n};\\n```\\nObviously we haven\\'t improved anything much, so again we will get TLE here\\nSo, what is  the problem?\\nWe add each position at most once to the queue and we must check each position. So the problem in the way we find following positions from the current one. The larger the window size $$k$$ we have, the greater its intersection for neighboring points. So we have to control positions that we have already checked.\\n\\n# Approach 3\\n\\nHere we store all non-banned positions in two arrays for even and odd positions. When ever the position is used we erase it from array.\\n```\\nclass Solution \\n{\\npublic:\\n    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) \\n    {\\n        std::vector<int> visited(n, -1);\\n        std::vector<int> ban(n , 0);\\n        for (const int& b: banned)\\n        {\\n            ban[b] = -1;\\n            visited[b] = -1;\\n        }\\n        \\n        std::vector<int> odd;\\n        std::vector<int> even;\\n        for (int i = 0; i < n; ++i) \\n        {            \\n            if (!ban[i] && i != p) \\n            {\\n                if (i & 1)\\n                    odd.push_back(i);\\n                else\\n                    even.push_back(i);\\n\\n            }\\n        }\\n\\n        std::queue<int> q;\\n        q.push(p);\\n        visited[p] = 0;\\n        while (!q.empty())    \\n        {\\n            int curr = q.front();\\n            q.pop();\\n\\n            int begin = std::abs(curr - k + 1);\\n            int end   = n - 1 - std::abs(n - curr - k);\\n            \\n            std::vector<int>& list = begin & 1 ? odd : even;\\n            for (int pos = list.size() - 1; pos >= 0; --pos)\\n            {\\n                if (list[pos] > end)\\n                    continue;\\n                if (list[pos] < begin)\\n                    break;\\n                \\n                q.push(list[pos]);\\n                visited[list[pos]] = visited[curr] + 1;\\n                list.erase(list.begin() + pos);\\n            }            \\n        }\\n\\n        return visited;\\n    }\\n};\\n```\\nUnfortunately we will get TLE again. The main reason, because erase operation on a vector is not so fast. \\n\\n# Approach 4\\n\\nTo improve the performance of removing an element, replace the vector with a linked list. Let\\'s write a simple implementation.\\n\\n# Code\\n```\\nclass Solution \\n{\\nprivate:\\n    \\n    struct ListEntry\\n    {\\n        int val;\\n        ListEntry* next;\\n        ListEntry* prev;\\n        \\n        ListEntry(const int& v)\\n        {\\n            val  = v;\\n            next = nullptr;\\n            prev = nullptr;\\n        }\\n    };\\n    class LinkedList\\n    {\\n    public:\\n        LinkedList()\\n        {\\n            head = nullptr;\\n            tail = nullptr;\\n        }\\n        ~LinkedList()\\n        {\\n            while (head)\\n            {\\n                ListEntry* temp = head->next;\\n                delete head;\\n                head = temp;\\n            }\\n            \\n            head = nullptr;\\n            tail = nullptr;\\n        }\\n        void push(const int& v)\\n        {\\n            if (!tail)\\n            {\\n                head = new ListEntry(v);\\n                tail = head;                \\n            }\\n            else\\n            {\\n                ListEntry* p = new ListEntry(v);\\n                p->prev = tail;\\n                tail->next = p;\\n                tail = p;\\n            }\\n        }\\n        ListEntry* find(const int& v)\\n        {\\n            ListEntry* cur = head;\\n            while (cur && cur->val < v)\\n            {\\n                cur = cur->next;                    \\n            }\\n            return cur;\\n        }\\n        void erase(ListEntry* p)\\n        {\\n            if (head == tail && p == head)\\n            {\\n                head = nullptr;\\n                tail = nullptr;\\n            }\\n            else if (head == p)\\n            {\\n                head = head->next;\\n                head->prev = nullptr;\\n            }\\n            else if (tail == p)\\n            {\\n                tail = tail->prev;\\n                tail->next = nullptr;\\n            }\\n            else\\n            {\\n                ListEntry* prev = p->prev;\\n                p->prev->next = p->next;\\n                p->next->prev = p->prev;\\n            }\\n            delete p;\\n        }\\n        \\n    private:\\n        ListEntry* head;        \\n        ListEntry* tail;\\n    };\\n    \\npublic:\\n    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) \\n    {\\n        std::vector<int> visited(n, -1);\\n        std::vector<int> ban(n , 0);\\n        for (const int& b: banned)\\n        {\\n            ban[b] = -1;\\n            visited[b] = -1;\\n        }\\n        \\n        LinkedList odd;\\n        LinkedList even;\\n        for (int i = 0; i < n; ++i) \\n        {            \\n            if (!ban[i] && i != p) \\n            {\\n                if (i & 1)\\n                    odd.push(i);\\n                else\\n                    even.push(i);\\n            }\\n        }\\n        \\n\\n        std::queue<int> q;\\n        q.push(p);\\n        visited[p] = 0;\\n        while (!q.empty())    \\n        {\\n            int curr = q.front();\\n            q.pop();\\n\\n            int begin = std::abs(curr - k + 1);\\n            int end   = n - 1 - std::abs(n - curr - k);\\n\\n            LinkedList& list = begin & 1 ? odd : even;\\n            ListEntry* entry = list.find(begin), *nextEntry;\\n            while (entry && entry->val <= end)\\n            {\\n                q.push(entry->val);\\n                visited[entry->val] = visited[curr] + 1;\\n                nextEntry = entry->next;\\n                list.erase(entry);\\n                entry = nextEntry;\\n            }            \\n        }\\n\\n        return visited;\\n    }\\n};\\n```\\n\\nHooray, we did it. All tests passed. Cheers :)\\n\\n# Update. Approach 5: \\n\\nWe passed all tests, but as mentioned in the comments, we can still get TLE in some edge situations.\\nFor example here:\\n```\\nminReverseOperations(100000, 50000, {}, 2);\\n```\\nThis is because in the previous approach, our $$LinkedList::find$$ method started searching from the beginning of the list and had to go through the entire list to the desired element, which gives us the linear complexity $$O(n)$$.\\nSo let\\'s try to replace linked list with a Binary Search Tree to achieve time complexity for all operations equal to $$O(log n)$$\\nSince we have a sorted list at the beginning, it will be easy to build a balanced BST.\\nTo leave our main algorithm untouched, we add $$find$$ and $$erase$$ methods to the $$Tree$$ class.\\n\\n```\\nclass Solution \\n{\\nprivate:\\n    \\n    struct TreeNode\\n    {\\n        int val;\\n\\n        TreeNode* left;\\n        TreeNode* right;\\n        TreeNode* parent;\\n\\n        TreeNode(const int& v)\\n        {\\n            val    = v;\\n            left   = nullptr;\\n            right  = nullptr;\\n            parent = nullptr;\\n        }\\n    };\\n\\n    class Tree\\n    {\\n    public:\\n\\n        Tree(const std::vector<int>& v)\\n        {\\n            root = initFrom(v, 0, v.size() - 1);\\n        }\\n        TreeNode* find(const int& val)\\n        {\\n            return find(root, val);\\n        }\\n        TreeNode* next(TreeNode* node)\\n        {\\n            if (node->right)\\n            {\\n                node = node->right;\\n                while (node->left)\\n                    node = node->left;\\n\\n                return node;\\n            }\\n        \\n            TreeNode* parent = node->parent;\\n            while (parent && node == parent->right) \\n            {\\n                node = parent;\\n                parent = parent->parent;\\n            }\\n            return parent;\\n        }\\n        TreeNode* erase(TreeNode* node)\\n        {\\n            if (!node)\\n                return nullptr;\\n\\n            TreeNode* parent = node->parent;\\n            if (!node->left && !node->right)\\n            {\\n                TreeNode* nextNode = next(node);\\n                if (!parent)\\n                {\\n                    root = nullptr;\\n                }\\n                else\\n                {\\n                    if (parent->left == node)\\n                        parent->left = nullptr;\\n                    else\\n                        parent->right = nullptr;\\n                }\\n                \\n                return nextNode;\\n            }\\n            else if (!node->left) \\n            {\\n                TreeNode* nextNode = next(node);\\n\\n                if (!parent)\\n                {\\n                    root = node->right;\\n                    node->right->parent = nullptr;\\n                }\\n                else if (parent->left == node)\\n                {\\n                    parent->left = node->right;\\n                    node->right->parent = parent;\\n                }\\n                else\\n                {\\n                    parent->right = node->right;\\n                    node->right->parent = parent;\\n                }\\n\\n                delete node;\\n                return nextNode;\\n            }\\n            else if (!node->right) \\n            {\\n                TreeNode* nextNode = next(node);\\n                if (!parent)\\n                {\\n                    root = node->left;\\n                    node->left->parent = nullptr;\\n                }\\n                else if (parent->left == node)\\n                {\\n                    parent->left = node->left;\\n                    node->left->parent = parent;\\n                }\\n                else\\n                {\\n                    parent->right = node->left;\\n                    node->left->parent = parent;\\n                }\\n\\n                delete node;\\n                return nextNode;\\n            }\\n            else\\n            {\\n                TreeNode* temp = node->right;\\n                while (temp->left)\\n                    temp = temp->left;\\n\\n                node->val = temp->val;\\n\\n                erase(temp);\\n                return node;\\n            }\\n        }\\n\\n    private:      \\n        TreeNode* initFrom(const std::vector<int>& vec, int start, int end)\\n        {       \\n            if (start > end)\\n                return nullptr;\\n        \\n            int mid = (start + end) / 2;\\n            TreeNode* node = new TreeNode(vec[mid]);\\n            node->left  = initFrom(vec, start, mid - 1);\\n            node->right = initFrom(vec, mid + 1, end);\\n\\n            if (node->left)\\n                node->left->parent = node;\\n            if (node->right)\\n                node->right->parent = node;\\n\\n            return node;\\n        }\\n        TreeNode* find(TreeNode* node, const int& val)\\n        {\\n            TreeNode* stored = nullptr;\\n            while (node)\\n            {\\n                if (node->val >= val)\\n                {\\n                    stored = node;\\n                    node = node->left;\\n                }\\n                else\\n                {\\n                    node = node->right;\\n                }\\n            }\\n            return stored;\\n        }\\n    private:\\n\\n        TreeNode* root;\\n    };\\npublic:    \\n    std::vector<int> minReverseOperations(int n, int p, std::vector<int>& banned, int k) \\n    {\\n        std::vector<int> visited(n, -1);\\n        std::vector<int> ban(n , 0);\\n        for (const int& b: banned)\\n        {\\n            ban[b] = -1;\\n            visited[b] = -1;\\n        }\\n        \\n        std::vector<int> vOdd, vEven;\\n        for (int i = 0; i < n; ++i) \\n        {            \\n            if (!ban[i] && i != p) \\n            {\\n                if (i & 1)\\n                    vOdd.push_back(i);\\n                else\\n                    vEven.push_back(i);\\n            }\\n        }          \\n\\n        Tree odd(vOdd);\\n        Tree even(vEven);    \\n        \\n        std::queue<int> q;\\n        q.push(p);\\n        visited[p] = 0;\\n        while (!q.empty())    \\n        {\\n            int curr = q.front();\\n            q.pop();\\n\\n            int begin = std::abs(curr - k + 1);\\n            int end   = n - 1 - std::abs(n - curr - k);\\n\\n            Tree& tree = begin & 1 ? odd: even;\\n            TreeNode* entry = tree.find(begin);\\n            while (entry && entry->val <= end)\\n            {\\n                q.push(entry->val);\\n                visited[entry->val] = visited[curr] + 1;\\n                entry = tree.erase(entry);\\n            }\\n        }\\n        return visited;\\n    };\\n};\\n```\\n\\nWe did it again :)\\nTest passing time has been improved and we didn\\'t get TLE for edge case mentioned in the title of this approach.\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) \\n    {\\n        std::vector<int> visited(n, -1);\\n        std::vector<int> ban(n , 0);\\n        for (const int& b: banned)\\n        {\\n            ban[b] = -1;\\n            visited[b] = -1;\\n        }\\n\\n        std::queue<int> q;\\n        q.push(p);\\n        visited[p] = 0;\\n        while (!q.empty())    \\n        {\\n            int curr = q.front();\\n            q.pop();\\n\\n            int begin = curr - k + 1;\\n            int end   = curr + k - 1;\\n\\n            for (int i = begin, start = begin; i <= end; i += 2, ++start)\\n            {\\n                if (start < 0 || start + k - 1 >= n || -1 == ban[i])\\n                    continue;\\n\\n                if (-1 == visited[i])\\n                {\\n                    q.push(i);\\n                    visited[i] = visited[curr] + 1;\\n                }\\n            }\\n        }\\n\\n        return visited;\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\npublic:\\n    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) \\n    {\\n        std::vector<int> visited(n, -1);\\n        std::vector<int> ban(n , 0);\\n        for (const int& b: banned)\\n        {\\n            ban[b] = -1;\\n            visited[b] = -1;\\n        }    \\n\\n        std::queue<int> q;\\n        q.push(p);\\n        visited[p] = 0;\\n        while (!q.empty())    \\n        {\\n            int curr = q.front();\\n            q.pop();\\n\\n            int begin = std::abs(curr - k + 1);\\n            int end   = n - 1 - std::abs(n - curr - k);\\n\\n            for (int i = begin; i <= end; i += 2)\\n            {\\n                if (-1 == ban[i])\\n                    continue;\\n\\n                if (-1 == visited[i])\\n                {\\n                    q.push(i);\\n                    visited[i] = visited[curr] + 1;\\n                }\\n            }\\n        }\\n\\n        return visited;\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\npublic:\\n    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) \\n    {\\n        std::vector<int> visited(n, -1);\\n        std::vector<int> ban(n , 0);\\n        for (const int& b: banned)\\n        {\\n            ban[b] = -1;\\n            visited[b] = -1;\\n        }\\n        \\n        std::vector<int> odd;\\n        std::vector<int> even;\\n        for (int i = 0; i < n; ++i) \\n        {            \\n            if (!ban[i] && i != p) \\n            {\\n                if (i & 1)\\n                    odd.push_back(i);\\n                else\\n                    even.push_back(i);\\n\\n            }\\n        }\\n\\n        std::queue<int> q;\\n        q.push(p);\\n        visited[p] = 0;\\n        while (!q.empty())    \\n        {\\n            int curr = q.front();\\n            q.pop();\\n\\n            int begin = std::abs(curr - k + 1);\\n            int end   = n - 1 - std::abs(n - curr - k);\\n            \\n            std::vector<int>& list = begin & 1 ? odd : even;\\n            for (int pos = list.size() - 1; pos >= 0; --pos)\\n            {\\n                if (list[pos] > end)\\n                    continue;\\n                if (list[pos] < begin)\\n                    break;\\n                \\n                q.push(list[pos]);\\n                visited[list[pos]] = visited[curr] + 1;\\n                list.erase(list.begin() + pos);\\n            }            \\n        }\\n\\n        return visited;\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\nprivate:\\n    \\n    struct ListEntry\\n    {\\n        int val;\\n        ListEntry* next;\\n        ListEntry* prev;\\n        \\n        ListEntry(const int& v)\\n        {\\n            val  = v;\\n            next = nullptr;\\n            prev = nullptr;\\n        }\\n    };\\n    class LinkedList\\n    {\\n    public:\\n        LinkedList()\\n        {\\n            head = nullptr;\\n            tail = nullptr;\\n        }\\n        ~LinkedList()\\n        {\\n            while (head)\\n            {\\n                ListEntry* temp = head->next;\\n                delete head;\\n                head = temp;\\n            }\\n            \\n            head = nullptr;\\n            tail = nullptr;\\n        }\\n        void push(const int& v)\\n        {\\n            if (!tail)\\n            {\\n                head = new ListEntry(v);\\n                tail = head;                \\n            }\\n            else\\n            {\\n                ListEntry* p = new ListEntry(v);\\n                p->prev = tail;\\n                tail->next = p;\\n                tail = p;\\n            }\\n        }\\n        ListEntry* find(const int& v)\\n        {\\n            ListEntry* cur = head;\\n            while (cur && cur->val < v)\\n            {\\n                cur = cur->next;                    \\n            }\\n            return cur;\\n        }\\n        void erase(ListEntry* p)\\n        {\\n            if (head == tail && p == head)\\n            {\\n                head = nullptr;\\n                tail = nullptr;\\n            }\\n            else if (head == p)\\n            {\\n                head = head->next;\\n                head->prev = nullptr;\\n            }\\n            else if (tail == p)\\n            {\\n                tail = tail->prev;\\n                tail->next = nullptr;\\n            }\\n            else\\n            {\\n                ListEntry* prev = p->prev;\\n                p->prev->next = p->next;\\n                p->next->prev = p->prev;\\n            }\\n            delete p;\\n        }\\n        \\n    private:\\n        ListEntry* head;        \\n        ListEntry* tail;\\n    };\\n    \\npublic:\\n    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) \\n    {\\n        std::vector<int> visited(n, -1);\\n        std::vector<int> ban(n , 0);\\n        for (const int& b: banned)\\n        {\\n            ban[b] = -1;\\n            visited[b] = -1;\\n        }\\n        \\n        LinkedList odd;\\n        LinkedList even;\\n        for (int i = 0; i < n; ++i) \\n        {            \\n            if (!ban[i] && i != p) \\n            {\\n                if (i & 1)\\n                    odd.push(i);\\n                else\\n                    even.push(i);\\n            }\\n        }\\n        \\n\\n        std::queue<int> q;\\n        q.push(p);\\n        visited[p] = 0;\\n        while (!q.empty())    \\n        {\\n            int curr = q.front();\\n            q.pop();\\n\\n            int begin = std::abs(curr - k + 1);\\n            int end   = n - 1 - std::abs(n - curr - k);\\n\\n            LinkedList& list = begin & 1 ? odd : even;\\n            ListEntry* entry = list.find(begin), *nextEntry;\\n            while (entry && entry->val <= end)\\n            {\\n                q.push(entry->val);\\n                visited[entry->val] = visited[curr] + 1;\\n                nextEntry = entry->next;\\n                list.erase(entry);\\n                entry = nextEntry;\\n            }            \\n        }\\n\\n        return visited;\\n    }\\n};\\n```\n```\\nminReverseOperations(100000, 50000, {}, 2);\\n```\n```\\nclass Solution \\n{\\nprivate:\\n    \\n    struct TreeNode\\n    {\\n        int val;\\n\\n        TreeNode* left;\\n        TreeNode* right;\\n        TreeNode* parent;\\n\\n        TreeNode(const int& v)\\n        {\\n            val    = v;\\n            left   = nullptr;\\n            right  = nullptr;\\n            parent = nullptr;\\n        }\\n    };\\n\\n    class Tree\\n    {\\n    public:\\n\\n        Tree(const std::vector<int>& v)\\n        {\\n            root = initFrom(v, 0, v.size() - 1);\\n        }\\n        TreeNode* find(const int& val)\\n        {\\n            return find(root, val);\\n        }\\n        TreeNode* next(TreeNode* node)\\n        {\\n            if (node->right)\\n            {\\n                node = node->right;\\n                while (node->left)\\n                    node = node->left;\\n\\n                return node;\\n            }\\n        \\n            TreeNode* parent = node->parent;\\n            while (parent && node == parent->right) \\n            {\\n                node = parent;\\n                parent = parent->parent;\\n            }\\n            return parent;\\n        }\\n        TreeNode* erase(TreeNode* node)\\n        {\\n            if (!node)\\n                return nullptr;\\n\\n            TreeNode* parent = node->parent;\\n            if (!node->left && !node->right)\\n            {\\n                TreeNode* nextNode = next(node);\\n                if (!parent)\\n                {\\n                    root = nullptr;\\n                }\\n                else\\n                {\\n                    if (parent->left == node)\\n                        parent->left = nullptr;\\n                    else\\n                        parent->right = nullptr;\\n                }\\n                \\n                return nextNode;\\n            }\\n            else if (!node->left) \\n            {\\n                TreeNode* nextNode = next(node);\\n\\n                if (!parent)\\n                {\\n                    root = node->right;\\n                    node->right->parent = nullptr;\\n                }\\n                else if (parent->left == node)\\n                {\\n                    parent->left = node->right;\\n                    node->right->parent = parent;\\n                }\\n                else\\n                {\\n                    parent->right = node->right;\\n                    node->right->parent = parent;\\n                }\\n\\n                delete node;\\n                return nextNode;\\n            }\\n            else if (!node->right) \\n            {\\n                TreeNode* nextNode = next(node);\\n                if (!parent)\\n                {\\n                    root = node->left;\\n                    node->left->parent = nullptr;\\n                }\\n                else if (parent->left == node)\\n                {\\n                    parent->left = node->left;\\n                    node->left->parent = parent;\\n                }\\n                else\\n                {\\n                    parent->right = node->left;\\n                    node->left->parent = parent;\\n                }\\n\\n                delete node;\\n                return nextNode;\\n            }\\n            else\\n            {\\n                TreeNode* temp = node->right;\\n                while (temp->left)\\n                    temp = temp->left;\\n\\n                node->val = temp->val;\\n\\n                erase(temp);\\n                return node;\\n            }\\n        }\\n\\n    private:      \\n        TreeNode* initFrom(const std::vector<int>& vec, int start, int end)\\n        {       \\n            if (start > end)\\n                return nullptr;\\n        \\n            int mid = (start + end) / 2;\\n            TreeNode* node = new TreeNode(vec[mid]);\\n            node->left  = initFrom(vec, start, mid - 1);\\n            node->right = initFrom(vec, mid + 1, end);\\n\\n            if (node->left)\\n                node->left->parent = node;\\n            if (node->right)\\n                node->right->parent = node;\\n\\n            return node;\\n        }\\n        TreeNode* find(TreeNode* node, const int& val)\\n        {\\n            TreeNode* stored = nullptr;\\n            while (node)\\n            {\\n                if (node->val >= val)\\n                {\\n                    stored = node;\\n                    node = node->left;\\n                }\\n                else\\n                {\\n                    node = node->right;\\n                }\\n            }\\n            return stored;\\n        }\\n    private:\\n\\n        TreeNode* root;\\n    };\\npublic:    \\n    std::vector<int> minReverseOperations(int n, int p, std::vector<int>& banned, int k) \\n    {\\n        std::vector<int> visited(n, -1);\\n        std::vector<int> ban(n , 0);\\n        for (const int& b: banned)\\n        {\\n            ban[b] = -1;\\n            visited[b] = -1;\\n        }\\n        \\n        std::vector<int> vOdd, vEven;\\n        for (int i = 0; i < n; ++i) \\n        {            \\n            if (!ban[i] && i != p) \\n            {\\n                if (i & 1)\\n                    vOdd.push_back(i);\\n                else\\n                    vEven.push_back(i);\\n            }\\n        }          \\n\\n        Tree odd(vOdd);\\n        Tree even(vEven);    \\n        \\n        std::queue<int> q;\\n        q.push(p);\\n        visited[p] = 0;\\n        while (!q.empty())    \\n        {\\n            int curr = q.front();\\n            q.pop();\\n\\n            int begin = std::abs(curr - k + 1);\\n            int end   = n - 1 - std::abs(n - curr - k);\\n\\n            Tree& tree = begin & 1 ? odd: even;\\n            TreeNode* entry = tree.find(begin);\\n            while (entry && entry->val <= end)\\n            {\\n                q.push(entry->val);\\n                visited[entry->val] = visited[curr] + 1;\\n                entry = tree.erase(entry);\\n            }\\n        }\\n        return visited;\\n    };\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368312,
                "title": "java-solution-with-detailed-explanation",
                "content": "# Background\\n\\nSuppose the value 1 in the array is at index x. Let\\u2019s think of the places we could move it to if we could reverse any subarray of size k containing x. If we have an array of size 10 and x is 6 and k is 4, we could move x to positions   3,5,7 and 9. If k is 3, we could move x to 4, 6(current position), 8. Notice that the parity (mod 2) of index we could move to are same. So if we can find the minimum and maximum index that could be visited, we can assume that all index of same parity in between can be visited with a single reversal.\\n\\n# Intuition\\n\\u2028To solve this problem, we can perform a bfs starting at p. We also use two TreeSet (odd and even parity index) to keep track of the index which are not banned and haven\\u2019t been visited. While performing the bfs, we find the parity of index we can move to if we  reversing a subarray k containing the index x. Next we find the minimum and maximum index we can move to with a single reversal. In most cases, the minimum index is x - k + 1 and the maximum is x + k - 1. However there are special cases where x is closer to the extreme of the array. If x is closer to the left of the array more formally x < k, then the minimum (k - 1) - x. A Similar logic also apply to the maximum when x closer to the right end. Once we have the parity, max and min index we could move to from the current index under consideration. We can add all values of index in the treeset with the right parity to the queue and remove the values from the set since they are already visited. This process would be repeated until the queue is empty as in the standard bfs.\\n\\nTime Complexity : O(n log n) as treeset operations take O(log n)\\nSpace Complexity: O(n) used by the sets\\n\\nPlease upvote if you like the solution :)\\n\\n# Code\\n\\n```\\nclass Solution {\\n    public int[] minReverseOperations(int n, int p, int[] banned, int k) {\\n        TreeSet<Integer> even = new TreeSet<>();\\n        TreeSet<Integer> odd = new TreeSet<>();\\n        \\n        TreeSet<Integer> set;\\n        \\n        boolean [] skip = new boolean [n];\\n        \\n        for (int num : banned) {\\n            skip[num] = true;\\n        }\\n        \\n        int start = p;\\n        \\n        // Add values to the set that are not banned\\n        for (int i = 0; i < n; ++i) {\\n            if (skip[i] || i == p)\\n                continue;\\n            \\n            if (i % 2 == 1)\\n                odd.add(i);\\n            else\\n                even.add(i);\\n        }\\n        \\n        int [] result = new int [n];\\n        Arrays.fill(result, -1);\\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(p);\\n        \\n        int size;\\n        int current;\\n        int moves = 0;\\n        \\n        int min, max;\\n        \\n        Integer key;\\n        \\n        int mCurrent;\\n        \\n        while (!queue.isEmpty()) {\\n            size = queue.size();\\n            \\n            \\n            while (size-- > 0) {\\n                current = queue.remove();\\n                \\n                result[current] = moves;\\n                \\n                \\n                // calculate min index\\n                if (current < k - 1) {\\n                    min = (k - 1) - current;\\n                }else {\\n                    min = current - k + 1;\\n                }\\n                \\n                // calculate max index\\n                mCurrent = (n - 1) - current;\\n                if (mCurrent < k - 1) {\\n                    max = (k - 1) - mCurrent;\\n                }else {\\n                    max = mCurrent - k + 1;\\n                }\\n                max = (n - 1) - max;\\n                \\n                \\n                // chose the correct parity set\\n                set = min % 2 == 0 ? even : odd;\\n                \\n                key = set.ceiling(min);\\n                \\n                // add all values in range to the queue and remove from set\\n                while (key != null && key <= max) {\\n                    queue.add(key);\\n                    set.remove(key);\\n                    key = set.ceiling(min);\\n                }\\n            }\\n            \\n            ++moves;\\n        }\\n        \\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] minReverseOperations(int n, int p, int[] banned, int k) {\\n        TreeSet<Integer> even = new TreeSet<>();\\n        TreeSet<Integer> odd = new TreeSet<>();\\n        \\n        TreeSet<Integer> set;\\n        \\n        boolean [] skip = new boolean [n];\\n        \\n        for (int num : banned) {\\n            skip[num] = true;\\n        }\\n        \\n        int start = p;\\n        \\n        // Add values to the set that are not banned\\n        for (int i = 0; i < n; ++i) {\\n            if (skip[i] || i == p)\\n                continue;\\n            \\n            if (i % 2 == 1)\\n                odd.add(i);\\n            else\\n                even.add(i);\\n        }\\n        \\n        int [] result = new int [n];\\n        Arrays.fill(result, -1);\\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(p);\\n        \\n        int size;\\n        int current;\\n        int moves = 0;\\n        \\n        int min, max;\\n        \\n        Integer key;\\n        \\n        int mCurrent;\\n        \\n        while (!queue.isEmpty()) {\\n            size = queue.size();\\n            \\n            \\n            while (size-- > 0) {\\n                current = queue.remove();\\n                \\n                result[current] = moves;\\n                \\n                \\n                // calculate min index\\n                if (current < k - 1) {\\n                    min = (k - 1) - current;\\n                }else {\\n                    min = current - k + 1;\\n                }\\n                \\n                // calculate max index\\n                mCurrent = (n - 1) - current;\\n                if (mCurrent < k - 1) {\\n                    max = (k - 1) - mCurrent;\\n                }else {\\n                    max = mCurrent - k + 1;\\n                }\\n                max = (n - 1) - max;\\n                \\n                \\n                // chose the correct parity set\\n                set = min % 2 == 0 ? even : odd;\\n                \\n                key = set.ceiling(min);\\n                \\n                // add all values in range to the queue and remove from set\\n                while (key != null && key <= max) {\\n                    queue.add(key);\\n                    set.remove(key);\\n                    key = set.ceiling(min);\\n                }\\n            }\\n            \\n            ++moves;\\n        }\\n        \\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368533,
                "title": "python3-solution",
                "content": "# Intuition\\nThis problem was hard to understand, and it has an $$O(K * N)$$ issue that needs to be addressed.\\n\\n# Approach\\nThe basic algorithm is a breadth-first search of positions, where depth is a reversal operation.\\n*   Avoid set lookups by marking `banned` positions with a `-2` reduces the constant coefficient speed-up. This is not enough to avoid a TLE, however.\\n*   Every visited position has $$O(k)$$ potential target positions. On visiting a new position, the multiplicative cost can be avoided by updating `nextNode2s`, which originally points forward 2, to point beyond all target positions considered for that position.\\n\\n# Complexity\\n- Time complexity: $$O(n + k)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minReverseOperations(self, n: int, p: int, banned: List[int], k: int) -> List[int]:\\n        out = [-1] * n\\n        # To speed up iterations, mark banned positions differently; remember to\\n        # convert them to -1 at the end.\\n        for node in banned:\\n            out[node] = -2\\n        # Perform reversals in level-based breadth-first order.\\n        nodes = [p]\\n        depth = 0\\n        out[p] = depth\\n        step = k - 1\\n        \\n        # TLEs occur when n is large, k is large, and not to many are banned,\\n        # so that very O(N) points have O(N) possible post-reverse positions.\\n        # These O(N) post-reverse positions are 2 apart, but each only needs\\n        # to be visited once. We will nextNode2s dynamically to save work.\\n        nextNode2s = [i + 2 for i in range(n)]  # might be out of range\\n\\n        while nodes:\\n            depth += 1\\n            newNodes = []\\n            for node1 in nodes:\\n                # The post-reverse positions are every other node between\\n                # loNode2 and hiNode2, inclusive.\\n                loReverseStart = max(node1 - step, 0)\\n                hiReverseStart = min(node1, n - k) # Inclusive\\n                loNode2 = 2 * loReverseStart + k - 1 - node1\\n                hiNode2 = 2 * hiReverseStart + k - 1 - node1  # Inclusive\\n                # We will exclude the entire range from future iterations\\n                # by setting nextNode2s[node2] to hiNode2 + 2 for every\\n                # visited node2.\\n                postHiNode2 = hiNode2 + 2\\n                node2 = loNode2\\n                while node2 <= hiNode2:\\n                    nextNode2 = nextNode2s[node2]\\n                    nextNode2s[node2] = postHiNode2\\n                    if node2 >= 0 and node2 < n and out[node2] == -1:\\n                        newNodes.append(node2)\\n                        out[node2] = depth\\n                    node2 = nextNode2\\n            nodes = newNodes\\n            \\n        # Mark all banned positions as -1 (see above).\\n        for i in range(n):\\n            if out[i] == -2:\\n                out[i] = -1\\n        return out\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minReverseOperations(self, n: int, p: int, banned: List[int], k: int) -> List[int]:\\n        out = [-1] * n\\n        # To speed up iterations, mark banned positions differently; remember to\\n        # convert them to -1 at the end.\\n        for node in banned:\\n            out[node] = -2\\n        # Perform reversals in level-based breadth-first order.\\n        nodes = [p]\\n        depth = 0\\n        out[p] = depth\\n        step = k - 1\\n        \\n        # TLEs occur when n is large, k is large, and not to many are banned,\\n        # so that very O(N) points have O(N) possible post-reverse positions.\\n        # These O(N) post-reverse positions are 2 apart, but each only needs\\n        # to be visited once. We will nextNode2s dynamically to save work.\\n        nextNode2s = [i + 2 for i in range(n)]  # might be out of range\\n\\n        while nodes:\\n            depth += 1\\n            newNodes = []\\n            for node1 in nodes:\\n                # The post-reverse positions are every other node between\\n                # loNode2 and hiNode2, inclusive.\\n                loReverseStart = max(node1 - step, 0)\\n                hiReverseStart = min(node1, n - k) # Inclusive\\n                loNode2 = 2 * loReverseStart + k - 1 - node1\\n                hiNode2 = 2 * hiReverseStart + k - 1 - node1  # Inclusive\\n                # We will exclude the entire range from future iterations\\n                # by setting nextNode2s[node2] to hiNode2 + 2 for every\\n                # visited node2.\\n                postHiNode2 = hiNode2 + 2\\n                node2 = loNode2\\n                while node2 <= hiNode2:\\n                    nextNode2 = nextNode2s[node2]\\n                    nextNode2s[node2] = postHiNode2\\n                    if node2 >= 0 and node2 < n and out[node2] == -1:\\n                        newNodes.append(node2)\\n                        out[node2] = depth\\n                    node2 = nextNode2\\n            nodes = newNodes\\n            \\n        # Mark all banned positions as -1 (see above).\\n        for i in range(n):\\n            if out[i] == -2:\\n                out[i] = -1\\n        return out\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372755,
                "title": "c-some-thoughts-of-this-special-bfs",
                "content": "# Problem Statement\\nLet\\'s first try to understand this problem:\\n1. There is an array ```A``` of size ```n```, which has only one ```1``` and all other elements are ```0```s. Initially this ```1``` is located at index ```p```\\n2. An operation is allowed: finding a subarray of ```A``` whose size is ```k```, and reverse this subarray, **this means we can move the only ```1``` around in this way**. This operation can be performed numerously\\n3. When performing the operation above, the only ```1``` of ```A``` can\\'t be moved to banned positions, denoted as an array ```banned```\\n4. This problem requires an output of an array ```ans``` whose size is also ```n```, and ```ans[i]``` means the minimum number of operations to move the only ```1``` to index ```i``` from initial index ```p```\\n\\n# Preparation\\n\\nSay the only ```1``` is located at index ```p```, what positions can it be moved to if we perform the operation for once?\\n\\nIt depends on ```p,n,k```. Intuitively, we can pick subarray ```[p-k+1 ... p]```, and reverse it to make the only ```1``` move to index ```p-k+1```, the leftmost index it can be moved to. However, if ```p-k+1<0```, the subarray is out of the range and it shouldn\\'t be picked, so we need to put some constraints considering the array size ```n```.\\n\\nAssume the subarray we pick in operation is ```[l ... r]```, where ```r = l+k-1```. On the one hand, this subarray must contain the only ```1```, so ```l >= p-k+1, r <= p+k-1```; On the other hand, this subarray can\\'t reside out of the range, so ```l >= 0, r < n```. These are all the constraints we need: ```max(0,p-k+1) <= l <= min(n-1,p+k-1)-(k-1)```.\\n\\nUnder the assumptions above, we move the only ```1``` to index ```p\\'```. We know that ```p``` and ```p\\'``` should be symmetric in the subarray ```[l...r]```, that is ```p-l=r-p\\'```, which means ```p\\'=2l+(k-1)-p```\\n\\nIt reveals that from an index ```p```, **we can move the only ```1``` to a series of indexes with the same parity, and these indexes are continuous odd or even numbers**\\n\\nHere is the function to get all these indexes given the only ```1```\\'s initial position ```x```, subarray size ```k``` and array size ```n```:\\n\\n```\\npair<int, int> getRange(int x, int n, int k)\\n{\\n    int l = max(x - k + 1, 0), r = min(x, n - k);\\n    int L = 2 * l + k - 1 - x, R = 2 * r + k - 1 - x;\\n    return {L, R};\\n}\\n```\\n\\n# Intuition\\n\\nPreparation done, now we know how to move the only ```1``` from one index to next ones. It follows naturally that this problem can be modeled as ```finding the minimum path length in a graph```, and **BFS** (Breadth First Search) can be employed immediately:\\n\\n(TLE version of BFS)\\n```\\nvector<int> minReverseOperations(int n, int p, vector<int>& banned, int k)\\n{\\n    unordered_set<int> B(banned.begin(), banned.end());\\n    vector<int> ans(n, -1);\\n    queue<int> q;\\n    q.push(p);\\n    ans[p] = 0;\\n    while(!q.empty())\\n    {\\n        int x = q.front(); q.pop();\\n        pair<int, int> R = getRange(x, n, k);\\n        for(int y = R.first; y <= R.second; y += 2)\\n        {\\n            if(ans[y] != -1 || B.count(y)) continue;\\n            ans[y] = ans[x] + 1;\\n            q.push(y);\\n        }\\n    }\\n    return ans;\\n}\\n```\\nHere ```ans``` serves both as the result and the usual ```visited``` array in BFS to denote whether this index has been visited. The array ```banned``` is transformed in to an **unordered_set** to quickly check if we move the ```1``` to banned positions. Everything seems to be ok, except this solution causes **TLE (Time Limit Exceed)**!\\n\\n# Approach\\n\\nLet\\'s revisit the solution above: we are solving a problem of ```finding the minimum path length in a graph```. By using BFS, the time complexity is ```O(N+E)```, where ```N``` and ```E``` denotes the number of nodes and edges of this graph. Here we have ```n``` nodes, but the number of edges can be as large as ```O(n^2)```!  Considering ```n``` can be as large as ```1e5```, a solution of ```O(n^2)``` time can probably cause TLE.\\n\\nThe key idea to reduce the number of edges is to make use of an important observation mentioned above: **we can move the only ```1``` to a series of indexes with the same parity, and these indexes are continuous odd or even numbers**.\\n\\nThis observation shows that the edges of a node follows a strict rule, not as random as some casual graphs. Each time we wish to visit the neighbors of a node, we are certain that **the indexes of these neighbors resides in a range with the same parity**, so we can rule out useless edges just like the array  ```visited``` to rule out visited nodes.\\n\\nHence we maintain two **sets** by parity, one for odd numbers and another for even numbers. By using **set** we can access a certain range quickly (O(logn) time). After visiting a node, we erase it from the two sets, which means we also erase all the edges leading to this node. This is how we reduce the number of edges at the same time with traversing the graph.\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    pair<int, int> getRange(int x, int n, int k)\\n    {\\n        int l = max(x - k + 1, 0), r = min(x, n - k);\\n        int L = 2 * l + k - 1 - x, R = 2 * r + k - 1 - x;\\n        return {L, R};\\n    }\\n    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k)\\n    {\\n        set<int> E[2];\\n        for(int i = 0; i < n; i++) E[i & 1].insert(i);\\n        int B = (int)banned.size();\\n        for(int i = 0; i < B; i++) E[banned[i] & 1].erase(banned[i]);\\n        vector<int> ans(n, -1);\\n        queue<int> q;\\n        q.push(p);\\n        ans[p] = 0;\\n        E[p & 1].erase(p);\\n        while(!q.empty())\\n        {\\n            int x = q.front(); q.pop();\\n            pair<int, int> R = getRange(x, n, k);\\n            set<int>& cur = E[R.first & 1];\\n            auto it = cur.lower_bound(R.first);\\n            while(it != cur.end() && *it <= R.second)\\n            {\\n                ans[*it] = ans[x] + 1;\\n                q.push(*it);\\n                it = cur.erase(it);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity:\\nO(nlog(n))\\n\\n- Space complexity:\\nO(n)\\n\\n# Some Thoughts\\n\\nWhy can we reduce the number of edges in this problem, but generaly we can\\'t in classic BFS problems?\\n\\nIn classic BFS problem, we usually create adjacency list **explicitly**,  therefore all the edges exist in the memory. This problem however, the adjacency list exists **implicitly**\\uFF0Cand actually we make use of a function ```getRange``` to produce adjacency list on the fly, which gives us chance to reduce the number of edges involved since they don\\'t exist beforehand.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```A```\n```n```\n```1```\n```0```\n```1```\n```p```\n```A```\n```k```\n```1```\n```1```\n```A```\n```banned```\n```ans```\n```n```\n```ans[i]```\n```1```\n```i```\n```p```\n```1```\n```p```\n```p,n,k```\n```[p-k+1 ... p]```\n```1```\n```p-k+1```\n```p-k+1<0```\n```n```\n```[l ... r]```\n```r = l+k-1```\n```1```\n```l >= p-k+1, r <= p+k-1```\n```l >= 0, r < n```\n```max(0,p-k+1) <= l <= min(n-1,p+k-1)-(k-1)```\n```1```\n```p\\'```\n```p```\n```p\\'```\n```[l...r]```\n```p-l=r-p\\'```\n```p\\'=2l+(k-1)-p```\n```p```\n```1```\n```1```\n```x```\n```k```\n```n```\n```\\npair<int, int> getRange(int x, int n, int k)\\n{\\n    int l = max(x - k + 1, 0), r = min(x, n - k);\\n    int L = 2 * l + k - 1 - x, R = 2 * r + k - 1 - x;\\n    return {L, R};\\n}\\n```\n```1```\n```finding the minimum path length in a graph```\n```\\nvector<int> minReverseOperations(int n, int p, vector<int>& banned, int k)\\n{\\n    unordered_set<int> B(banned.begin(), banned.end());\\n    vector<int> ans(n, -1);\\n    queue<int> q;\\n    q.push(p);\\n    ans[p] = 0;\\n    while(!q.empty())\\n    {\\n        int x = q.front(); q.pop();\\n        pair<int, int> R = getRange(x, n, k);\\n        for(int y = R.first; y <= R.second; y += 2)\\n        {\\n            if(ans[y] != -1 || B.count(y)) continue;\\n            ans[y] = ans[x] + 1;\\n            q.push(y);\\n        }\\n    }\\n    return ans;\\n}\\n```\n```ans```\n```visited```\n```banned```\n```1```\n```finding the minimum path length in a graph```\n```O(N+E)```\n```N```\n```E```\n```n```\n```O(n^2)```\n```n```\n```1e5```\n```O(n^2)```\n```1```\n```visited```\n```\\n\\nclass Solution {\\npublic:\\n    pair<int, int> getRange(int x, int n, int k)\\n    {\\n        int l = max(x - k + 1, 0), r = min(x, n - k);\\n        int L = 2 * l + k - 1 - x, R = 2 * r + k - 1 - x;\\n        return {L, R};\\n    }\\n    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k)\\n    {\\n        set<int> E[2];\\n        for(int i = 0; i < n; i++) E[i & 1].insert(i);\\n        int B = (int)banned.size();\\n        for(int i = 0; i < B; i++) E[banned[i] & 1].erase(banned[i]);\\n        vector<int> ans(n, -1);\\n        queue<int> q;\\n        q.push(p);\\n        ans[p] = 0;\\n        E[p & 1].erase(p);\\n        while(!q.empty())\\n        {\\n            int x = q.front(); q.pop();\\n            pair<int, int> R = getRange(x, n, k);\\n            set<int>& cur = E[R.first & 1];\\n            auto it = cur.lower_bound(R.first);\\n            while(it != cur.end() && *it <= R.second)\\n            {\\n                ans[*it] = ans[x] + 1;\\n                q.push(*it);\\n                it = cur.erase(it);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```getRange```",
                "codeTag": "Java"
            },
            {
                "id": 4069466,
                "title": "c-java-python-javascript",
                "content": "Read Whole article : https://www.nileshblog.tech/minimum-reverse-operations/\\n\\nExplanation Eg.\\nTime Complexity:\\n\\nDynamic Programming dp O()\\nPython :\\nJava:\\nc++:\\nJavaScript:\\n\\nRead Whole article :https://www.nileshblog.tech/minimum-reverse-operations/",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "Read Whole article : https://www.nileshblog.tech/minimum-reverse-operations/\\n\\nExplanation Eg.\\nTime Complexity:\\n\\nDynamic Programming dp O()\\nPython :\\nJava:\\nc++:\\nJavaScript:\\n\\nRead Whole article :https://www.nileshblog.tech/minimum-reverse-operations/",
                "codeTag": "Unknown"
            },
            {
                "id": 3372746,
                "title": "from-tle-to-100-time-and-space-the-key-is-insert-intervals",
                "content": "Here is the first iteration, straightforward BFS, but TLE\\n```\\n    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {\\n        vector<int> res(n,-1);\\n        for (int b : banned) res[b]=INT_MAX;\\n        queue<int> q;\\n        q.push(p);\\n        int d=0;\\n        res[p]=d;\\n        while (not q.empty()) {\\n            ++d;\\n            for (int i=0, m=int(q.size()); i<m; ++i) {\\n                int x=q.front(); q.pop();\\n                // y1+2*z>=0, z>=(1-y1)/2\\n                // y1+z>=0, z>=-y1\\n                int y1=x-k+1;\\n                if (y1<0) y1+=max(((1-y1)/2),-y1)*2;\\n                // y2-2*z<n, z>=(y2-n)/2+1\\n                // y2-z<n, z>=(y2-n)+1\\n                int y2=x+k-1;\\n                if (y2>=n) y2-=max((y2-n)/2,y2-n)*2+2;\\n                for (int y=y1; y<=y2; y+=2) {\\n                    if (res[y]==-1) {\\n                        res[y]=d;\\n                        q.push(y);\\n                    }\\n                }\\n            }\\n        }\\n        for (int i=0; i<n; ++i)\\n            if (res[i]==INT_MAX) res[i]=-1;\\n        return res;\\n    }\\n```\\nThe problem is that for each x, an index range of [y1,y2] increment of 2 is checked. The range size is O(K)=O(N). Therefore the overal algorithm is O(N^2)\\nThe insight is that all those range [y1,y2] have a lot of overlaps, especially for large K. On the other hand, each y could be propagated from K different x and the same computation repeated K times. As an example without considering the bound and banned, K=4\\n![image](https://assets.leetcode.com/users/images/6a655030-b751-436a-869f-a8b976db3fff_1680790943.0055997.png)\\n\\nIndex ranges should be combined first before BFS propagation. \\nThe key is https://leetcode.com/problems/insert-interval/\\nHere is the implementation, \\n```\\n    void insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        auto p1=lower_bound(intervals.begin(),intervals.end(),newInterval[0],[](const auto& x, int v){ return x[1]<v; });\\n        auto p2=upper_bound(intervals.begin(),intervals.end(),newInterval[1],[](int v, const auto& x){ return v<x[0]; });\\n        vector<int>& x=newInterval;\\n        if (p1!=p2) {\\n            x[0]=min((*p1)[0],x[0]);\\n            x[1]=max((*prev(p2))[1],x[1]);\\n        }\\n        intervals.erase(p1,p2);\\n        intervals.insert(p1,x);\\n    }\\n```\\n\\nThen the solution is modified as, 229 ms and 100.2 MB, both metrics are 100%\\n```\\n    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {\\n        vector<int> res(n,-1);\\n        for (int b : banned) res[b]=INT_MAX;\\n        queue<int> q;\\n        q.push(p);\\n        int d=0;\\n        res[p]=d;\\n        while (not q.empty()) {\\n            ++d;\\n            vector<vector<int>> intervals;\\n            for (int i=0, m=int(q.size()); i<m; ++i) {\\n                int x=q.front(); q.pop();\\n                // y1+2*z>=0, z>=(1-y1)/2\\n                // y1+z>=0, z>=-y1\\n                int y1=x-k+1;\\n                if (y1<0) y1+=max(((1-y1)/2),-y1)*2;\\n                // y2-2*z<n, z>=(y2-n)/2+1\\n                // y2-z<n, z>=(y2-n)+1\\n                int y2=x+k-1;\\n                if (y2>=n) y2-=max((y2-n)/2,y2-n)*2+2;\\n                vector<int> r{y1,y2+2};\\n                insert(intervals,r);\\n            }\\n            for (auto& r : intervals) {\\n                for (int y=r[0]; y<r[1]; y+=2) {\\n                    if (res[y]==-1) {\\n                        res[y]=d;\\n                        q.push(y);\\n                    }\\n                }\\n            }\\n        }\\n        for (int i=0; i<n; ++i)\\n            if (res[i]==INT_MAX) res[i]=-1;\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\n    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {\\n        vector<int> res(n,-1);\\n        for (int b : banned) res[b]=INT_MAX;\\n        queue<int> q;\\n        q.push(p);\\n        int d=0;\\n        res[p]=d;\\n        while (not q.empty()) {\\n            ++d;\\n            for (int i=0, m=int(q.size()); i<m; ++i) {\\n                int x=q.front(); q.pop();\\n                // y1+2*z>=0, z>=(1-y1)/2\\n                // y1+z>=0, z>=-y1\\n                int y1=x-k+1;\\n                if (y1<0) y1+=max(((1-y1)/2),-y1)*2;\\n                // y2-2*z<n, z>=(y2-n)/2+1\\n                // y2-z<n, z>=(y2-n)+1\\n                int y2=x+k-1;\\n                if (y2>=n) y2-=max((y2-n)/2,y2-n)*2+2;\\n                for (int y=y1; y<=y2; y+=2) {\\n                    if (res[y]==-1) {\\n                        res[y]=d;\\n                        q.push(y);\\n                    }\\n                }\\n            }\\n        }\\n        for (int i=0; i<n; ++i)\\n            if (res[i]==INT_MAX) res[i]=-1;\\n        return res;\\n    }\\n```\n```\\n    void insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\\n        auto p1=lower_bound(intervals.begin(),intervals.end(),newInterval[0],[](const auto& x, int v){ return x[1]<v; });\\n        auto p2=upper_bound(intervals.begin(),intervals.end(),newInterval[1],[](int v, const auto& x){ return v<x[0]; });\\n        vector<int>& x=newInterval;\\n        if (p1!=p2) {\\n            x[0]=min((*p1)[0],x[0]);\\n            x[1]=max((*prev(p2))[1],x[1]);\\n        }\\n        intervals.erase(p1,p2);\\n        intervals.insert(p1,x);\\n    }\\n```\n```\\n    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {\\n        vector<int> res(n,-1);\\n        for (int b : banned) res[b]=INT_MAX;\\n        queue<int> q;\\n        q.push(p);\\n        int d=0;\\n        res[p]=d;\\n        while (not q.empty()) {\\n            ++d;\\n            vector<vector<int>> intervals;\\n            for (int i=0, m=int(q.size()); i<m; ++i) {\\n                int x=q.front(); q.pop();\\n                // y1+2*z>=0, z>=(1-y1)/2\\n                // y1+z>=0, z>=-y1\\n                int y1=x-k+1;\\n                if (y1<0) y1+=max(((1-y1)/2),-y1)*2;\\n                // y2-2*z<n, z>=(y2-n)/2+1\\n                // y2-z<n, z>=(y2-n)+1\\n                int y2=x+k-1;\\n                if (y2>=n) y2-=max((y2-n)/2,y2-n)*2+2;\\n                vector<int> r{y1,y2+2};\\n                insert(intervals,r);\\n            }\\n            for (auto& r : intervals) {\\n                for (int y=r[0]; y<r[1]; y+=2) {\\n                    if (res[y]==-1) {\\n                        res[y]=d;\\n                        q.push(y);\\n                    }\\n                }\\n            }\\n        }\\n        for (int i=0; i<n; ++i)\\n            if (res[i]==INT_MAX) res[i]=-1;\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3374809,
                "title": "graph-explanation-of-how-to-calculate-the-index-after-reverse-the-subarray",
                "content": "A----------X------------|--------------Y-----------B\\n\\n\\nSuppose the start index of subarray is A, current index of 1 is X and we know the subarry size is K, what is Y?\\n\\nEasily we could got two formulas:\\n```\\nB - A + 1 = K\\nX - A = B - Y\\n```\\nThus we could get\\n```\\nY = A + B - X\\n```\\n\\nAnd we could plug in \\n```\\nB = K - 1 + A\\n```\\n\\nFinally \\n```\\nY = A + (K - 1 + A) - X = 2*A + K - 1 - X\\n```",
                "solutionTags": [
                    "Graph"
                ],
                "code": "```\\nB - A + 1 = K\\nX - A = B - Y\\n```\n```\\nY = A + B - X\\n```\n```\\nB = K - 1 + A\\n```\n```\\nY = A + (K - 1 + A) - X = 2*A + K - 1 - X\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3370879,
                "title": "c-using-bfs-and-set-o-nlogn-100-100-for-the-moment",
                "content": "# Intuition\\n<!-- After every operation, there is always only one \\'1\\' in the ```arr```, hence we only need to remember this number and current number of operations. -->\\nFor each index ```i```, we need to find after how many operations ```arr[i]``` could be ```1```. Hence, we can do BFS by saving statuses```(idx, ops)``` where ```arr[idx] == 1``` is achievable after ```ops``` operations.\\n\\nIf ```arr[i] == 1```, how can we find all ```j``` such that ```arr[j] == 1``` is achievable after 1 operation? \\n\\nTo answer this question, first, suppose the size of subarray that we choose to reverse is ```k```. If this subarray is ```[a, a + k - 1]```, after 1 operations, the index ```a``` will be moved to index ```a + k - 1```, ```a + 1``` will be moved to ```a + k - 2``` etc. \\nThis shows that for all the indices within this subarray: __current index + index after operation = constant__. \\nSo, if we know that the reversed subarray is ```[a, a + k - 1]```, index ```i``` will be moved to ```2*a + k - 1  - i``` after operation.\\n\\nSecond, we need to know all the possible ```a``` ( starting index of the subarray ) for a given ```i``` where ```arr[i] == 1```. Note that ```i``` needs to be within ```[a, a + k - 1]```, otherwise the operation makes no difference on ```arr```. So, we can find that for the leftmost possible subarray, ```a == max(0, i - k + 1)```, and for the rightmost,```a == min(n - k, i)```. As for now, we have enough information to answer the question: \\n```\\nfor (int a = max(0, i - k + 1) ; a <= min(n - k, i) ; ++a) {\\n    int j = 2 * a + k - 1 - i;\\n    // ...\\n}\\n```\\nand ```j``` is the possible index for ```arr[j]``` to be 1 after 1 operation. Note that the parity of ```j``` remains the same during the whole operations\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We need  a ```queue<pair<int,int> > statuses``` to save the statuses ```(idx, ops)```, the initial status is ```(p, 0)```\\n\\n2. While doing BFS, the earlier we save a status, the ```ops``` must be smaller or same. Because we are looking for the smallest number of operations, there is no need to save a status where ```idx``` is already used before\\n\\n    To achieve this, we need to memorize all the indices that have been used. The intuition is to use a ```vector<bool> used``` to record it. However, there is a faster way.\\n\\n    As we can see, for a given current index ```i```, all the ```j``` that is the possible index after one operation __remains the same parity__. For instance, this loop\\n    ```\\n    for (int a = max(0, i - k + 1) ; a <= min(n - k, i) ; ++a) {\\n        int j = 2 * a + k - 1 - i;\\n        // ...\\n    }\\n    ```\\n\\n    is the same as this loop\\n    ```\\n    for (int j =  2 * max(0, i - k + 1) + k - 1 - i ; \\n        j <= 2 * min(n - k, i) + k - 1 - i ; j += 2) {\\n        // ...\\n    }\\n    ```\\n    Hence, we can use two sets, save the __unvisited and unbanned__ indices for odds and evens respectively. And for every current index ```i```, we determine the parity of possible indices after 1 operation, then every index in the set that is within the range will be put in ```statuses``` for further iterations.\\n\\n    \\n\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {\\n        // create a boolean array to check if index i is banned in linear time\\n        vector<bool> isBanned(n, false);\\n         for (auto &i : banned)\\n            isBanned[i] = true;\\n\\n        // create return array, which will be the return value\\n        vector<int> ret(n, -1);\\n        // because arr[p] is 1 without any operation, ret[p] is assigned 0        \\n        ret[p] = 0;\\n\\n        if (k == 1) // in this case, arr remains invariant after every operation\\n            return ret;\\n\\n\\n        // create two sets, for odd and even indices respectively\\n        set<int> odd, even;\\n        for (int i = 0 ; i < n ; ++i) {\\n            if (!isBanned[i]) {\\n                if (i % 2) {\\n                    odd.insert(i);\\n                }\\n                else {\\n                    even.insert(i);\\n                }\\n            }\\n        }\\n        \\n        queue<pair<int,int> > statuses; // (idx, ops)\\n\\n        // initial status\\n        statuses.push(make_pair(p, 0));\\n        if (p % 2)\\n            odd.erase(odd.find(p));\\n        else\\n            even.erase(even.find(p));\\n\\n        while (!statuses.empty()) {\\n            auto tmp = statuses.front();\\n            statuses.pop();\\n            \\n            int i = tmp.first, ops = tmp.second;\\n            \\n            // the smallest and biggest possible index after 1 operation\\n            int smallest = 2 * max(0, i - k + 1) + k - 1 - i, biggest = 2 * min(n - k, i) + k - 1 - i;\\n\\n            // determine the parity of possible indices after 1 operation\\n            if (smallest % 2) { // find in odd\\n\\n                for (auto it = odd.lower_bound(smallest) ; it != odd.end() && *it <= biggest ;) {\\n                    statuses.push(make_pair(*it, ops + 1));\\n                    ret[*it] = ops + 1;\\n                    odd.erase(it++);\\n                }\\n\\n            }\\n            else { // find in even\\n\\n                for (auto it = even.lower_bound(smallest) ; it != even.end() && *it <= biggest ;) {\\n                    statuses.push(make_pair(*it, ops + 1));\\n                    ret[*it] = ops + 1;\\n                    even.erase(it++);\\n                }\\n            }\\n            \\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```arr```\n```i```\n```arr[i]```\n```1```\n```(idx, ops)```\n```arr[idx] == 1```\n```ops```\n```arr[i] == 1```\n```j```\n```arr[j] == 1```\n```k```\n```[a, a + k - 1]```\n```a```\n```a + k - 1```\n```a + 1```\n```a + k - 2```\n```[a, a + k - 1]```\n```i```\n```2*a + k - 1  - i```\n```a```\n```i```\n```arr[i] == 1```\n```i```\n```[a, a + k - 1]```\n```arr```\n```a == max(0, i - k + 1)```\n```a == min(n - k, i)```\n```\\nfor (int a = max(0, i - k + 1) ; a <= min(n - k, i) ; ++a) {\\n    int j = 2 * a + k - 1 - i;\\n    // ...\\n}\\n```\n```j```\n```arr[j]```\n```j```\n```queue<pair<int,int> > statuses```\n```(idx, ops)```\n```(p, 0)```\n```ops```\n```idx```\n```vector<bool> used```\n```i```\n```j```\n```\\n    for (int a = max(0, i - k + 1) ; a <= min(n - k, i) ; ++a) {\\n        int j = 2 * a + k - 1 - i;\\n        // ...\\n    }\\n    ```\n```\\n    for (int j =  2 * max(0, i - k + 1) + k - 1 - i ; \\n        j <= 2 * min(n - k, i) + k - 1 - i ; j += 2) {\\n        // ...\\n    }\\n    ```\n```i```\n```statuses```\n```\\nclass Solution {\\npublic:\\n    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {\\n        // create a boolean array to check if index i is banned in linear time\\n        vector<bool> isBanned(n, false);\\n         for (auto &i : banned)\\n            isBanned[i] = true;\\n\\n        // create return array, which will be the return value\\n        vector<int> ret(n, -1);\\n        // because arr[p] is 1 without any operation, ret[p] is assigned 0        \\n        ret[p] = 0;\\n\\n        if (k == 1) // in this case, arr remains invariant after every operation\\n            return ret;\\n\\n\\n        // create two sets, for odd and even indices respectively\\n        set<int> odd, even;\\n        for (int i = 0 ; i < n ; ++i) {\\n            if (!isBanned[i]) {\\n                if (i % 2) {\\n                    odd.insert(i);\\n                }\\n                else {\\n                    even.insert(i);\\n                }\\n            }\\n        }\\n        \\n        queue<pair<int,int> > statuses; // (idx, ops)\\n\\n        // initial status\\n        statuses.push(make_pair(p, 0));\\n        if (p % 2)\\n            odd.erase(odd.find(p));\\n        else\\n            even.erase(even.find(p));\\n\\n        while (!statuses.empty()) {\\n            auto tmp = statuses.front();\\n            statuses.pop();\\n            \\n            int i = tmp.first, ops = tmp.second;\\n            \\n            // the smallest and biggest possible index after 1 operation\\n            int smallest = 2 * max(0, i - k + 1) + k - 1 - i, biggest = 2 * min(n - k, i) + k - 1 - i;\\n\\n            // determine the parity of possible indices after 1 operation\\n            if (smallest % 2) { // find in odd\\n\\n                for (auto it = odd.lower_bound(smallest) ; it != odd.end() && *it <= biggest ;) {\\n                    statuses.push(make_pair(*it, ops + 1));\\n                    ret[*it] = ops + 1;\\n                    odd.erase(it++);\\n                }\\n\\n            }\\n            else { // find in even\\n\\n                for (auto it = even.lower_bound(smallest) ; it != even.end() && *it <= biggest ;) {\\n                    statuses.push(make_pair(*it, ops + 1));\\n                    ret[*it] = ops + 1;\\n                    even.erase(it++);\\n                }\\n            }\\n            \\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372058,
                "title": "bfs-even-odd-segment-tree",
                "content": "# Intuition / approach\\n\\nThere are several hard subproblems within this problem, but the main one is to figure out how the 1s can be efficiently updated after a subarray is reversed.\\n\\nAfter discovering that a reverse affects a range of numbers only at either even or odd positions, I went for a segment tree approach where there is one tree for odd and one for even numbers.\\n\\nThe segment tree is responsible for keeping track of whether a range of odd or even numbers consists of only banned or reached numbers. The result is also split into odd/even.\\n\\nThen, using BFS, elements are visited in order, updating ranges of odd/even numbers based on the subarray length and the element index.\\n\\nThis implementation is full of foot-guns. If you can find a simpler approach, then I recommend using it. I\\'m just sharing it for reference or if some lazy person wants to copy-paste the solution.\\n\\n# Complexity\\n\\n- Time complexity: `O(n*log(n))`\\n- Space complexity: `O(n)`\\n\\n# Code\\n```\\nfunc minReverseOperations(n int, p int, banned []int, k int) []int {\\n\\t// This problem is quite hard.\\n\\t//\\n\\t// First, it is worth noting that we want to work with odd and even\\n\\t// positions in the array separately. This is because an odd k can only\\n\\t// reverse 1 into positions at an even distance from the current position.\\n\\t// Similarly, with an even k, the 1 can only be moved into an odd distance\\n\\t// from the current position.\\n\\t//\\n\\t// By splitting the array into odd and even positions, the reachable\\n\\t// positions can be described as a range rather than single positions,\\n\\t// making it possible to do a range update with a segment tree.\\n\\t//\\n\\tm := 1\\n\\tneven := n/2 + n&1\\n\\tfor m < neven {\\n\\t\\tm *= 2\\n\\t}\\n\\tvar segtree [2][]bool\\n\\tsegtree[0] = make([]bool, m*2)\\n\\tsegtree[1] = make([]bool, m*2)\\n\\n\\tvar res [2][]int\\n\\tres[0] = make([]int, neven)\\n\\tres[1] = make([]int, n/2)\\n\\tfor i := range res {\\n\\t\\tfor j := range res[i] {\\n\\t\\t\\tres[i][j] = -2\\n\\t\\t}\\n\\t}\\n\\n\\t// mark marks the provided index with the provided value\\n\\tmark := func(segtree []bool, res []int, i, val int) {\\n\\t\\tsegtree[m+i] = true\\n\\t\\tfor k := (m + i) / 2; k >= 1; k /= 2 {\\n\\t\\t\\tsegtree[k] = segtree[k*2] && segtree[k*2+1]\\n\\t\\t\\tif !segtree[k] {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif i < len(res) {\\n\\t\\t\\tres[i] = val\\n\\t\\t}\\n\\t}\\n\\n\\tfor _, i := range banned {\\n\\t\\tmark(segtree[i&1], res[i&1], i/2, -1)\\n\\t}\\n\\n\\t// Mark out-of-bounds elements as seen\\n\\tfor i := neven; i < m; i++ {\\n\\t\\tmark(segtree[0], res[0], i, -1)\\n\\t}\\n\\tfor i := n / 2; i < m; i++ {\\n\\t\\tmark(segtree[1], res[1], i, -1)\\n\\t}\\n\\n\\ttype pos struct {\\n\\t\\ti   int\\n\\t\\todd int\\n\\t}\\n\\n\\t// Update marks the range\\n\\t// [lo,hi] is the current range in the segment tree\\n\\t// [qlo,qhi] is the range being updated by the caller\\n\\t// j is 0 if using even segtree, otherwise 1\\n\\tvar update func(segtree []bool, res []int, next *[]pos, i, lo, hi, qlo, qhi, val, odd int)\\n\\tupdate = func(segtree []bool, res []int, next *[]pos, i, lo, hi, qlo, qhi, val, odd int) {\\n\\t\\tif qhi < lo || qlo > hi {\\n\\t\\t\\t// Skip\\n\\t\\t\\treturn\\n\\t\\t}\\n\\n\\t\\tif lo >= qlo && hi <= qhi {\\n\\t\\t\\t// This range of the segment tree should be marked as \"done\"\\n\\t\\t\\tif segtree[i] {\\n\\t\\t\\t\\t// If it is already done, return\\n\\t\\t\\t\\treturn\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Mark all nodes as done, adding unseen nodes to next iteration\\n\\t\\t\\tfor j := lo; j <= hi; j++ {\\n\\t\\t\\t\\tif res[j] != -2 {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tres[j] = val\\n\\n\\t\\t\\t\\tmark(segtree, res, j, val)\\n\\t\\t\\t\\t*next = append(*next, pos{j, odd})\\n\\t\\t\\t}\\n\\t\\t\\treturn\\n\\t\\t}\\n\\n\\t\\t// Split query into left/right\\n\\t\\tmid := lo + (hi-lo)/2\\n\\t\\tupdate(segtree, res, next, i*2, lo, mid, qlo, qhi, val, odd)\\n\\t\\tupdate(segtree, res, next, i*2+1, mid+1, hi, qlo, qhi, val, odd)\\n\\t}\\n\\n\\tcurr := []pos{}\\n\\tnext := []pos{}\\n\\n\\t// Start by marking p as done\\n\\t// This will populate next with the first node.\\n\\tupdate(segtree[p&1], res[p&1], &curr, 1, 0, m-1, p/2, p/2, 0, p&1)\\n\\n\\tfor steps := 1; len(curr) > 0; steps++ {\\n\\t\\tnext = next[:0]\\n\\t\\tfor _, x := range curr {\\n\\t\\t\\tii := x.i*2 + x.odd\\n\\t\\t\\tl, r := reachableRange(n, ii, k)\\n\\t\\t\\tupdate(segtree[l&1], res[l&1], &next, 1, 0, m-1, l/2, r/2, steps, l&1)\\n\\t\\t}\\n\\t\\tcurr, next = next, curr\\n\\t}\\n\\n\\tret := make([]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tret[i] = res[i&1][i/2]\\n\\t}\\n\\tfor i := range ret {\\n\\t\\tif ret[i] == -2 {\\n\\t\\t\\tret[i] = -1\\n\\t\\t}\\n\\t}\\n\\treturn ret\\n}\\n\\nfunc reachableRange(n, i, k int) (int, int) {\\n\\tleftMost := i - k + 1\\n\\trightMost := i + k - 1\\n\\tif leftMost < 0 {\\n\\t\\td := -leftMost\\n\\t\\tleftMost += d * 2\\n\\t}\\n\\tif rightMost >= n {\\n\\t\\td := rightMost - n + 1\\n\\t\\trightMost -= d * 2\\n\\t}\\n\\treturn leftMost, rightMost\\n}\\n\\nfunc min(a, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minReverseOperations(n int, p int, banned []int, k int) []int {\\n\\t// This problem is quite hard.\\n\\t//\\n\\t// First, it is worth noting that we want to work with odd and even\\n\\t// positions in the array separately. This is because an odd k can only\\n\\t// reverse 1 into positions at an even distance from the current position.\\n\\t// Similarly, with an even k, the 1 can only be moved into an odd distance\\n\\t// from the current position.\\n\\t//\\n\\t// By splitting the array into odd and even positions, the reachable\\n\\t// positions can be described as a range rather than single positions,\\n\\t// making it possible to do a range update with a segment tree.\\n\\t//\\n\\tm := 1\\n\\tneven := n/2 + n&1\\n\\tfor m < neven {\\n\\t\\tm *= 2\\n\\t}\\n\\tvar segtree [2][]bool\\n\\tsegtree[0] = make([]bool, m*2)\\n\\tsegtree[1] = make([]bool, m*2)\\n\\n\\tvar res [2][]int\\n\\tres[0] = make([]int, neven)\\n\\tres[1] = make([]int, n/2)\\n\\tfor i := range res {\\n\\t\\tfor j := range res[i] {\\n\\t\\t\\tres[i][j] = -2\\n\\t\\t}\\n\\t}\\n\\n\\t// mark marks the provided index with the provided value\\n\\tmark := func(segtree []bool, res []int, i, val int) {\\n\\t\\tsegtree[m+i] = true\\n\\t\\tfor k := (m + i) / 2; k >= 1; k /= 2 {\\n\\t\\t\\tsegtree[k] = segtree[k*2] && segtree[k*2+1]\\n\\t\\t\\tif !segtree[k] {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif i < len(res) {\\n\\t\\t\\tres[i] = val\\n\\t\\t}\\n\\t}\\n\\n\\tfor _, i := range banned {\\n\\t\\tmark(segtree[i&1], res[i&1], i/2, -1)\\n\\t}\\n\\n\\t// Mark out-of-bounds elements as seen\\n\\tfor i := neven; i < m; i++ {\\n\\t\\tmark(segtree[0], res[0], i, -1)\\n\\t}\\n\\tfor i := n / 2; i < m; i++ {\\n\\t\\tmark(segtree[1], res[1], i, -1)\\n\\t}\\n\\n\\ttype pos struct {\\n\\t\\ti   int\\n\\t\\todd int\\n\\t}\\n\\n\\t// Update marks the range\\n\\t// [lo,hi] is the current range in the segment tree\\n\\t// [qlo,qhi] is the range being updated by the caller\\n\\t// j is 0 if using even segtree, otherwise 1\\n\\tvar update func(segtree []bool, res []int, next *[]pos, i, lo, hi, qlo, qhi, val, odd int)\\n\\tupdate = func(segtree []bool, res []int, next *[]pos, i, lo, hi, qlo, qhi, val, odd int) {\\n\\t\\tif qhi < lo || qlo > hi {\\n\\t\\t\\t// Skip\\n\\t\\t\\treturn\\n\\t\\t}\\n\\n\\t\\tif lo >= qlo && hi <= qhi {\\n\\t\\t\\t// This range of the segment tree should be marked as \"done\"\\n\\t\\t\\tif segtree[i] {\\n\\t\\t\\t\\t// If it is already done, return\\n\\t\\t\\t\\treturn\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Mark all nodes as done, adding unseen nodes to next iteration\\n\\t\\t\\tfor j := lo; j <= hi; j++ {\\n\\t\\t\\t\\tif res[j] != -2 {\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tres[j] = val\\n\\n\\t\\t\\t\\tmark(segtree, res, j, val)\\n\\t\\t\\t\\t*next = append(*next, pos{j, odd})\\n\\t\\t\\t}\\n\\t\\t\\treturn\\n\\t\\t}\\n\\n\\t\\t// Split query into left/right\\n\\t\\tmid := lo + (hi-lo)/2\\n\\t\\tupdate(segtree, res, next, i*2, lo, mid, qlo, qhi, val, odd)\\n\\t\\tupdate(segtree, res, next, i*2+1, mid+1, hi, qlo, qhi, val, odd)\\n\\t}\\n\\n\\tcurr := []pos{}\\n\\tnext := []pos{}\\n\\n\\t// Start by marking p as done\\n\\t// This will populate next with the first node.\\n\\tupdate(segtree[p&1], res[p&1], &curr, 1, 0, m-1, p/2, p/2, 0, p&1)\\n\\n\\tfor steps := 1; len(curr) > 0; steps++ {\\n\\t\\tnext = next[:0]\\n\\t\\tfor _, x := range curr {\\n\\t\\t\\tii := x.i*2 + x.odd\\n\\t\\t\\tl, r := reachableRange(n, ii, k)\\n\\t\\t\\tupdate(segtree[l&1], res[l&1], &next, 1, 0, m-1, l/2, r/2, steps, l&1)\\n\\t\\t}\\n\\t\\tcurr, next = next, curr\\n\\t}\\n\\n\\tret := make([]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tret[i] = res[i&1][i/2]\\n\\t}\\n\\tfor i := range ret {\\n\\t\\tif ret[i] == -2 {\\n\\t\\t\\tret[i] = -1\\n\\t\\t}\\n\\t}\\n\\treturn ret\\n}\\n\\nfunc reachableRange(n, i, k int) (int, int) {\\n\\tleftMost := i - k + 1\\n\\trightMost := i + k - 1\\n\\tif leftMost < 0 {\\n\\t\\td := -leftMost\\n\\t\\tleftMost += d * 2\\n\\t}\\n\\tif rightMost >= n {\\n\\t\\td := rightMost - n + 1\\n\\t\\trightMost -= d * 2\\n\\t}\\n\\treturn leftMost, rightMost\\n}\\n\\nfunc min(a, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3370524,
                "title": "python-bfs-binary-search-o-n-log-n",
                "content": "1. Suppose we stand at `i1`, the widest range we can reach by one reverse is `i1-k+1`, `i1-k+3`, ..., `i1+k-3`, `i1+k-1`. The indices in the sequence are all even or all odd. \\nBut we should be cautious when `i1 < k` or `i1 > n-k`. The starting index of the leftmost subarray containing `i1` is `max(0, i1-k+1)`, while the one of the rightmost subarray containing `i1` is `min(i1, n-k)`.\\nFor a subarray containing `i1` with size `k`, say `[start:start+k]`, after reverse, `1` moved from `i1` to `i2 = 2*start-k-1-i1`.\\nAssume the leftmost and rightmost indices we can reach are `le` and `ri`, respectively.\\n2. During BFS, we would save indices not touched yet in `remain`. Because the possible indices in one step are all even/odd, we save even/odd indices seperately.\\n3. To avoid TLE, use binary search to find the `intersection` of remaining indices(`remain[0]/remain[1]`) and `[le, ri]`.\\n4. For each index `i2` in `intersection`, update `ans[i2]` and remove `i2` from `remain[0]/remain[1]`.\\n```\\nfrom collections import deque\\nfrom bisect import bisect_left, bisect_right\\n \\nclass Solution:\\n    def minReverseOperations(self, n: int, p: int, banned: List[int], k: int) -> List[int]:\\n        ans = [-1]*n\\n        ans[p] = 0\\n        banned = set(banned)\\n        remain_e = [i for i in range(n) if i not in banned and i != p and i&1 == 0]\\n        remain_o = [i for i in range(n) if i not in banned and i != p and i&1 == 1]\\n        remain = [remain_e, remain_o]\\n        \\n        cur = deque([p])\\n        step = 1\\n        while cur:\\n            for _ in range(len(cur)):\\n                i1 = cur.popleft()\\n                lm, rm = max(0, i1-k+1), min(i1, n-k)\\n                le = lm+lm+k-1-i1\\n                ri = rm+rm+k-1-i1\\n                i_l, i_r = bisect_left(remain[le&1], le), bisect_right(remain[le&1], ri)\\n                intersection = remain[le&1][i_l:i_r]\\n                for i2 in intersection:\\n                    ans[i2] = step\\n                    cur.append(i2)\\n                    remain[le&1].pop(i_l)\\n            step += 1\\n        return ans",
                "solutionTags": [
                    "Python3"
                ],
                "code": "1. Suppose we stand at `i1`, the widest range we can reach by one reverse is `i1-k+1`, `i1-k+3`, ..., `i1+k-3`, `i1+k-1`. The indices in the sequence are all even or all odd. \\nBut we should be cautious when `i1 < k` or `i1 > n-k`. The starting index of the leftmost subarray containing `i1` is `max(0, i1-k+1)`, while the one of the rightmost subarray containing `i1` is `min(i1, n-k)`.\\nFor a subarray containing `i1` with size `k`, say `[start:start+k]`, after reverse, `1` moved from `i1` to `i2 = 2*start-k-1-i1`.\\nAssume the leftmost and rightmost indices we can reach are `le` and `ri`, respectively.\\n2. During BFS, we would save indices not touched yet in `remain`. Because the possible indices in one step are all even/odd, we save even/odd indices seperately.\\n3. To avoid TLE, use binary search to find the `intersection` of remaining indices(`remain[0]/remain[1]`) and `[le, ri]`.\\n4. For each index `i2` in `intersection`, update `ans[i2]` and remove `i2` from `remain[0]/remain[1]`.\\n```\\nfrom collections import deque\\nfrom bisect import bisect_left, bisect_right\\n \\nclass Solution:\\n    def minReverseOperations(self, n: int, p: int, banned: List[int], k: int) -> List[int]:\\n        ans = [-1]*n\\n        ans[p] = 0\\n        banned = set(banned)\\n        remain_e = [i for i in range(n) if i not in banned and i != p and i&1 == 0]\\n        remain_o = [i for i in range(n) if i not in banned and i != p and i&1 == 1]\\n        remain = [remain_e, remain_o]\\n        \\n        cur = deque([p])\\n        step = 1\\n        while cur:\\n            for _ in range(len(cur)):\\n                i1 = cur.popleft()\\n                lm, rm = max(0, i1-k+1), min(i1, n-k)\\n                le = lm+lm+k-1-i1\\n                ri = rm+rm+k-1-i1\\n                i_l, i_r = bisect_left(remain[le&1], le), bisect_right(remain[le&1], ri)\\n                intersection = remain[le&1][i_l:i_r]\\n                for i2 in intersection:\\n                    ans[i2] = step\\n                    cur.append(i2)\\n                    remain[le&1].pop(i_l)\\n            step += 1\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 3368571,
                "title": "java-bfs-check-if-a-position-can-reach",
                "content": "1. Use BFS to find the shortest distance\\n2. For each point, calculate the range it can reach\\n3. Use TreeSet to find the point that can reach for the range [L : R]\\n\\nNote : Do some experiement to find out how to calculate the range, it need to deal with both odd index and even index seperatly\\n\\n```\\nclass Solution {\\n    int INF = 1000000000;\\n    public int[] minReverseOperations(int n, int s, int[] banned, int k) {\\n        int d[] = new int[n];\\n        Arrays.fill(d, INF);\\n        boolean is[] = new boolean[n];\\n        for(int i : banned) is[i] = true;\\n        \\n        TreeSet<Integer> odd = new TreeSet<>();\\n        TreeSet<Integer> even = new TreeSet<>();\\n        for(int i = 0; i < n; i++) {\\n            if(!is[i] && i != s) {\\n                if(i % 2 == 0) even.add(i);\\n                else odd.add(i);\\n            }\\n        }\\n\\t\\t\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(s);\\n        d[s] = 0;\\n        while(q.size() > 0) {\\n            int u = q.poll();\\n            int l = u;\\n            int r = u;\\n            \\n            int ll = Math.max(0, u - k + 1);\\n            int rr = ll + k - 1;\\n            if(rr < n) {\\n                int ith = u - ll;\\n                l = ll + (k - ith - 1);\\n            }\\n            \\n            int rrr = Math.min(n - 1, u + k - 1);\\n            int lll = rrr - k + 1;\\n            if(lll >= 0) {\\n                int ith = u - lll;\\n                r = lll + (k - ith - 1);\\n            }\\n            \\n            \\n            TreeSet<Integer> tree;\\n         \\n            if(u % 2 == 0) {\\n                if(k % 2 == 0) tree = odd;\\n                else tree = even;\\n            } else {\\n                if(k % 2 == 0) tree = even;\\n                else tree = odd;\\n            }\\n            \\n            while(true) {\\n                Integer hi = tree.ceiling(l);\\n                if(hi == null) break;\\n\\n                if(hi <= r) {\\n                    d[hi] = d[u]  + 1;\\n                    q.add(hi);\\n                    tree.remove(hi);\\n                } else {\\n                    break;\\n                }\\n            }\\n            \\n            while(true) {\\n                Integer lo = tree.floor(r);\\n                if(lo == null) break;\\n                if(lo >= l) {\\n                    d[lo] = d[u] + 1;\\n                    tree.remove(lo);\\n                    q.add(lo);\\n                } else {\\n                    break;\\n                }\\n            }\\n        }\\n       \\n        for(int i = 0; i < n; i++) {\\n            if(d[i] == INF) d[i] = -1;\\n        }\\n        return d;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int INF = 1000000000;\\n    public int[] minReverseOperations(int n, int s, int[] banned, int k) {\\n        int d[] = new int[n];\\n        Arrays.fill(d, INF);\\n        boolean is[] = new boolean[n];\\n        for(int i : banned) is[i] = true;\\n        \\n        TreeSet<Integer> odd = new TreeSet<>();\\n        TreeSet<Integer> even = new TreeSet<>();\\n        for(int i = 0; i < n; i++) {\\n            if(!is[i] && i != s) {\\n                if(i % 2 == 0) even.add(i);\\n                else odd.add(i);\\n            }\\n        }\\n\\t\\t\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(s);\\n        d[s] = 0;\\n        while(q.size() > 0) {\\n            int u = q.poll();\\n            int l = u;\\n            int r = u;\\n            \\n            int ll = Math.max(0, u - k + 1);\\n            int rr = ll + k - 1;\\n            if(rr < n) {\\n                int ith = u - ll;\\n                l = ll + (k - ith - 1);\\n            }\\n            \\n            int rrr = Math.min(n - 1, u + k - 1);\\n            int lll = rrr - k + 1;\\n            if(lll >= 0) {\\n                int ith = u - lll;\\n                r = lll + (k - ith - 1);\\n            }\\n            \\n            \\n            TreeSet<Integer> tree;\\n         \\n            if(u % 2 == 0) {\\n                if(k % 2 == 0) tree = odd;\\n                else tree = even;\\n            } else {\\n                if(k % 2 == 0) tree = even;\\n                else tree = odd;\\n            }\\n            \\n            while(true) {\\n                Integer hi = tree.ceiling(l);\\n                if(hi == null) break;\\n\\n                if(hi <= r) {\\n                    d[hi] = d[u]  + 1;\\n                    q.add(hi);\\n                    tree.remove(hi);\\n                } else {\\n                    break;\\n                }\\n            }\\n            \\n            while(true) {\\n                Integer lo = tree.floor(r);\\n                if(lo == null) break;\\n                if(lo >= l) {\\n                    d[lo] = d[u] + 1;\\n                    tree.remove(lo);\\n                    q.add(lo);\\n                } else {\\n                    break;\\n                }\\n            }\\n        }\\n       \\n        for(int i = 0; i < n; i++) {\\n            if(d[i] == INF) d[i] = -1;\\n        }\\n        return d;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368456,
                "title": "simple-bfs",
                "content": "# Intuition\\nNote: For each position, do some maths to calculate the source and the destination positions of each start postion. Also the positions should have the smae parity.\\n\\n# Approach\\nThe key point is to query/delete the positions instead of querying.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {\\n        vector<int> r(n, -1);\\n        r[p] = 0;\\n        if (k == 1 || n == 1) {\\n            return r;\\n        }\\n        unordered_set<int> all;\\n        for (int i = 0; i < n; ++i) {\\n            all.insert(i);\\n        }\\n        all.erase(p);\\n        for (int x : banned) {\\n            all.erase(x);\\n        }\\n        vector<set<int>> s(2);\\n        for (int x : all) {\\n            s[x & 1].insert(x);\\n        }\\n        queue<int> q;\\n        for (q.push(p); !q.empty(); ) {\\n            p = q.front();\\n            q.pop();\\n            // left side:  x \\n            // right side: (k - 1 - x)\\n            //  p + k - n <= x <= p\\n            // max(0, p + k - n) <= x <= min(p, k - 1)\\n            const int left = max(0, p + k - n), right = min(p, k - 1);\\n            if (left > right) {\\n                continue;\\n            }\\n            const int v1 = k + p - 1 - right - right;\\n            const int v2 = k + p - 1 - left - left;\\n            const int ind = v1 & 1;\\n            for (auto t = s[ind].lower_bound(v1); t != s[ind].end(); ) {\\n                if (*t > v2) {\\n                    break;\\n                }\\n                r[*t] = r[p] + 1;\\n                q.push(*t);\\n                s[ind].erase(t++);\\n            }\\n            \\n        }\\n        return r;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {\\n        vector<int> r(n, -1);\\n        r[p] = 0;\\n        if (k == 1 || n == 1) {\\n            return r;\\n        }\\n        unordered_set<int> all;\\n        for (int i = 0; i < n; ++i) {\\n            all.insert(i);\\n        }\\n        all.erase(p);\\n        for (int x : banned) {\\n            all.erase(x);\\n        }\\n        vector<set<int>> s(2);\\n        for (int x : all) {\\n            s[x & 1].insert(x);\\n        }\\n        queue<int> q;\\n        for (q.push(p); !q.empty(); ) {\\n            p = q.front();\\n            q.pop();\\n            // left side:  x \\n            // right side: (k - 1 - x)\\n            //  p + k - n <= x <= p\\n            // max(0, p + k - n) <= x <= min(p, k - 1)\\n            const int left = max(0, p + k - n), right = min(p, k - 1);\\n            if (left > right) {\\n                continue;\\n            }\\n            const int v1 = k + p - 1 - right - right;\\n            const int v2 = k + p - 1 - left - left;\\n            const int ind = v1 & 1;\\n            for (auto t = s[ind].lower_bound(v1); t != s[ind].end(); ) {\\n                if (*t > v2) {\\n                    break;\\n                }\\n                r[*t] = r[p] + 1;\\n                q.push(*t);\\n                s[ind].erase(t++);\\n            }\\n            \\n        }\\n        return r;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917568,
                "title": "c-splay-binary-search-bfs",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int[] MinReverseOperations(int n, int p, int[] banned, int k) {\\n        Dictionary<int, int> d = new();\\n        SortedSet<int>[] sets = new SortedSet<int>[2];\\n        for(int i = 0; i < 2; i++) sets[i] = new SortedSet<int>();\\n        for(int i = 0; i < banned.Length; i++) d[banned[i]] = 1;\\n        for(int i = 0; i < n; i++) {\\n            if(i != p && !d.ContainsKey(i))\\n                sets[i % 2].Add(i);\\n        }\\n        int[] f = new int[n];\\n        Array.Fill(f, -1);\\n\\n        List<int> q = new List<int>();\\n        q.Add(p);\\n        for(int step = 0; q.Count > 0; step++) {\\n            List<int> nq = new List<int>();\\n            foreach(int i in q) {\\n                f[i] = step;\\n                int l = Math.Max(i - k + 1, k - i - 1);\\n                int r = Math.Min(i + k - 1, n * 2 - k - i - 1);\\n                SortedSet<int> view = new(sets[l % 2].GetViewBetween(l, r));\\n                foreach(int it in view) nq.Add(it);\\n                sets[l % 2].ExceptWith(view);\\n            }\\n            q = nq;\\n        }\\n        return f;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] MinReverseOperations(int n, int p, int[] banned, int k) {\\n        Dictionary<int, int> d = new();\\n        SortedSet<int>[] sets = new SortedSet<int>[2];\\n        for(int i = 0; i < 2; i++) sets[i] = new SortedSet<int>();\\n        for(int i = 0; i < banned.Length; i++) d[banned[i]] = 1;\\n        for(int i = 0; i < n; i++) {\\n            if(i != p && !d.ContainsKey(i))\\n                sets[i % 2].Add(i);\\n        }\\n        int[] f = new int[n];\\n        Array.Fill(f, -1);\\n\\n        List<int> q = new List<int>();\\n        q.Add(p);\\n        for(int step = 0; q.Count > 0; step++) {\\n            List<int> nq = new List<int>();\\n            foreach(int i in q) {\\n                f[i] = step;\\n                int l = Math.Max(i - k + 1, k - i - 1);\\n                int r = Math.Min(i + k - 1, n * 2 - k - i - 1);\\n                SortedSet<int> view = new(sets[l % 2].GetViewBetween(l, r));\\n                foreach(int it in view) nq.Add(it);\\n                sets[l % 2].ExceptWith(view);\\n            }\\n            q = nq;\\n        }\\n        return f;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376923,
                "title": "python3-bfs-w-o-a-queue-beats-100-time-and-memory-index-math-explained",
                "content": "# Index math\\n\\nA length-$N$ list has $N-k+1$ length-$k$ slices, one starting at each $i \\\\in [0, N-k]$.\\n\\nSuppose the set/on/one bit is currenlty at position $p \\\\in [0, N)$. Reverseing one of these slices, `bits[i:i+k]`, has no effect. if $p < i$ or $p \\\\geq i+k$; we should only consider reversing slices `bits[i:i+k]` s.t. $i \\\\leq p < i+k$. This gives us limits on $i$, the starting position of the slice: $p-k < i \\\\leftrightarrow p-k+1 \\\\leq i$ and $i \\\\leq p$, so $i \\\\in [p-k+1, p]$. Furthermore, we should make sure $0 \\\\leq i \\\\leq N-k$, so `i_lo = max(0, p-k+1)` and `i_hi = min(N-k, p)`.\\n\\nReversing `bits[i:i+k]` where the set bit is at position $p \\\\in [i, i+k]$ simply moves the set bit to posiiton $i+k-1-(p-i) = 2i+k-1-p$. Rather than iterating through the appropritate $i$s and calculating $2i+k-1-p$ for each $i$, we can just iterate throught `range(p_lo, p_hi+1, 2)` where `p_lo = 2*i_lo + k - 1 - p` and `p_hi = 2*i_hi + k - 1 - p`.\\n\\nSo given the position of the set bit, $p$, we can calculate the possible next positions. We do a BFS to identify all the possible positions in operations order, each time recording how many operations were necessary to reach said position.\\n\\n# Complexity\\n- Time complexity: I think it\\'s $O(N \\\\lg N)$.\\n- Space complexity: $O(N)$\\n\\n# Code\\n\\nThis is an improvement on [awice\\'s SortedList.irange soltuion](https://leetcode.com/problems/minimum-reverse-operations/solutions/3368819/python3-bfs-sortedlist-keep-track-of-remaining-nodes/).\\n\\n```\\nIMPOSSIBLE = -1\\nEVEN, ODD = 0, 1\\nclass Solution:\\n    def minReverseOperations(self, N: int, p: int, banned: List[int], k: int) -> List[int]:\\n        if k == 1 or len(banned) == N-1:\\n            numOps = [IMPOSSIBLE] * N\\n            numOps[p] = 0\\n            return numOps\\n        \\n        numOps = [IMPOSSIBLE] * N\\n        numOps[p] = 0\\n        \\n        remaining = [[], []]\\n        banned = set(banned)\\n        for pos in range(0, N, 2):\\n            if pos != p and pos not in banned:\\n                remaining[EVEN].append(pos)\\n            pos += 1\\n            if pos != p and pos not in banned:\\n                remaining[ODD].append(pos)\\n        \\n        # BFS\\n        numOp = 1\\n        p0s = [p]\\n        while p0s:\\n            p1s = []\\n            for p0 in p0s:\\n                i_lo = max(0, p0+1-k)\\n                i_hi = min(N-k, p0)\\n                p1_lo = p1_hi = k-1-p0\\n                p1_lo += 2*i_lo\\n                p1_hi += 2*i_hi\\n                parity = p1_lo & 0b1\\n                rem = remaining[parity]\\n                lo = bisect_left(rem, p1_lo)\\n                hi = bisect_right(rem, p1_hi)\\n\\n                # Alt 1\\n                for j in reversed(range(lo, hi)):\\n                    p1 = rem.pop(j)\\n                    numOps[p1] = numOp\\n                    p1s.append(p1)\\n\\n                # # Alt 2\\n                # for _ in range(hi - lo):\\n                #     p1 = rem.pop(lo)\\n                #     numOps[p1] = numOp\\n                #     p1s.append(p1)\\n            \\n            p0s = p1s\\n            numOp += 1\\n        \\n        return numOps\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nIMPOSSIBLE = -1\\nEVEN, ODD = 0, 1\\nclass Solution:\\n    def minReverseOperations(self, N: int, p: int, banned: List[int], k: int) -> List[int]:\\n        if k == 1 or len(banned) == N-1:\\n            numOps = [IMPOSSIBLE] * N\\n            numOps[p] = 0\\n            return numOps\\n        \\n        numOps = [IMPOSSIBLE] * N\\n        numOps[p] = 0\\n        \\n        remaining = [[], []]\\n        banned = set(banned)\\n        for pos in range(0, N, 2):\\n            if pos != p and pos not in banned:\\n                remaining[EVEN].append(pos)\\n            pos += 1\\n            if pos != p and pos not in banned:\\n                remaining[ODD].append(pos)\\n        \\n        # BFS\\n        numOp = 1\\n        p0s = [p]\\n        while p0s:\\n            p1s = []\\n            for p0 in p0s:\\n                i_lo = max(0, p0+1-k)\\n                i_hi = min(N-k, p0)\\n                p1_lo = p1_hi = k-1-p0\\n                p1_lo += 2*i_lo\\n                p1_hi += 2*i_hi\\n                parity = p1_lo & 0b1\\n                rem = remaining[parity]\\n                lo = bisect_left(rem, p1_lo)\\n                hi = bisect_right(rem, p1_hi)\\n\\n                # Alt 1\\n                for j in reversed(range(lo, hi)):\\n                    p1 = rem.pop(j)\\n                    numOps[p1] = numOp\\n                    p1s.append(p1)\\n\\n                # # Alt 2\\n                # for _ in range(hi - lo):\\n                #     p1 = rem.pop(lo)\\n                #     numOps[p1] = numOp\\n                #     p1s.append(p1)\\n            \\n            p0s = p1s\\n            numOp += 1\\n        \\n        return numOps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368749,
                "title": "easy-understanding-c-deque",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {\\n        set<int> valid_pos[2];\\n        for(int i=0;i<n;i++) valid_pos[i&1].insert(i);\\n        for(int x : banned) {\\n            valid_pos[0].erase(x);\\n            valid_pos[1].erase(x);\\n        }\\n        deque<pair<int,int>> Q;\\n        Q.push_back({0,p});\\n        vector<int> ans(n, -1);\\n        while(!Q.empty()) {\\n            pair<int,int> q=Q.front();\\n            Q.pop_front();\\n            int pos=q.second;\\n            int num_moves=q.first;\\n            if (ans[pos]!=-1) continue;\\n            // left end is L\\n            // L >= max(0,pos-k+1)\\n            // L <= min(pos,n-k)            \\n            // if left end is L -> 2*L+k-1-pos\\n            int minL=max(0,pos-k+1);\\n            int maxL=min(pos,n-k);\\n                        //printf(\"pos=%d %d to %d\\\\n\",pos,minn,maxx);\\n\\n            int minn = 2*minL+k-1-pos;\\n            int maxx = 2*maxL+k-1-pos;\\n            ans[pos]=num_moves;\\n            valid_pos[pos&1].erase(pos);\\n            // pos-k to pos+k\\n            int parity=(minn&1);\\n            auto it = valid_pos[parity].lower_bound(minn);\\n            vector<int> to_remove;\\n            while(it != valid_pos[parity].end() && *it <= maxx) {\\n                Q.push_back({num_moves+1,*it});\\n                to_remove.push_back(*it);\\n                ++it;\\n            }\\n            for(int x : to_remove) valid_pos[parity].erase(x);\\n        }\\n        return ans;\\n    }\\n};\\n``",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {\\n        set<int> valid_pos[2];\\n        for(int i=0;i<n;i++) valid_pos[i&1].insert(i);\\n        for(int x : banned) {\\n            valid_pos[0].erase(x);\\n            valid_pos[1].erase(x);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3961834,
                "title": "sortedcontainers-with-details",
                "content": "# Intuition\\nUsing diffirent approach to find the best Solution.\\n\\n# Approach\\nCheck for the bottle necks, because my main issue was with the tome. \\n\\n# Complexity\\n- Time complexity:\\nLook for the best approach\\n\\n- Space complexity:\\nTry to write as less operations as possible\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n\\n    def minReverseOperations(self, total_nodes, start_point, restricted_nodes, jump):\\n        slots = [SortedList(), SortedList()]\\n        forbidden = set(restricted_nodes)\\n        for idx in range(total_nodes):\\n            if idx != start_point and idx not in forbidden:\\n                slots[idx & 1].add(idx)\\n\\n        exploration_list = [start_point]\\n        distances = [-1] * total_nodes\\n        distances[start_point] = 0\\n        \\n        for current_node in exploration_list:\\n            lower_bound = max(current_node - jump + 1, 0)\\n            lower_bound = 2 * lower_bound + jump - 1 - current_node\\n            upper_bound = min(current_node + jump - 1, total_nodes - 1) - (jump - 1)\\n            upper_bound = 2 * upper_bound + jump - 1 - current_node\\n\\n            for adjacent in list(slots[lower_bound % 2].irange(lower_bound, upper_bound)):\\n                exploration_list.append(adjacent)\\n                distances[adjacent] = distances[current_node] + 1\\n                slots[lower_bound % 2].remove(adjacent)\\n        \\n        return distances\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n\\n    def minReverseOperations(self, total_nodes, start_point, restricted_nodes, jump):\\n        slots = [SortedList(), SortedList()]\\n        forbidden = set(restricted_nodes)\\n        for idx in range(total_nodes):\\n            if idx != start_point and idx not in forbidden:\\n                slots[idx & 1].add(idx)\\n\\n        exploration_list = [start_point]\\n        distances = [-1] * total_nodes\\n        distances[start_point] = 0\\n        \\n        for current_node in exploration_list:\\n            lower_bound = max(current_node - jump + 1, 0)\\n            lower_bound = 2 * lower_bound + jump - 1 - current_node\\n            upper_bound = min(current_node + jump - 1, total_nodes - 1) - (jump - 1)\\n            upper_bound = 2 * upper_bound + jump - 1 - current_node\\n\\n            for adjacent in list(slots[lower_bound % 2].irange(lower_bound, upper_bound)):\\n                exploration_list.append(adjacent)\\n                distances[adjacent] = distances[current_node] + 1\\n                slots[lower_bound % 2].remove(adjacent)\\n        \\n        return distances\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864731,
                "title": "rust-c-bfs-ordered-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\n//Rust\\nuse std::collections::BTreeSet;\\nuse std::collections::HashSet;\\nuse std::collections::VecDeque;\\n\\nimpl Solution {\\n    pub fn min_reverse_operations(n: i32, p: i32, banned: Vec<i32>, k: i32) -> Vec<i32> {\\n        let banned = banned.into_iter().collect::<HashSet<_>>();\\n        let mut s = vec![BTreeSet::<i32>::new(); 2];\\n        for i in 0 .. n {\\n            if i != p && banned.contains(&i) == false { s[i as usize % 2].insert(i); }\\n        }\\n\\n        let mut ret = vec![-1; n as usize];\\n        let mut q = VecDeque::from([(p as usize, 0)]);\\n\\n        while let Some((i, cnt)) = q.pop_front() {\\n            ret[i] = cnt;\\n            let mut idx = p as usize % 2;\\n            if k % 2 == 0 && (i as i32 - p) % 2 == 0 { idx = 1 - idx; };\\n            let len = (k - 1) / 2; \\n            let (d1, d2) = (len.min(i as i32), len.min(n - 1 - i as i32));\\n            \\n            let temp = i as i32 + (k - 1) - 2 * d1;\\n            while let Some(j) = s[idx].range(temp ..).next() {\\n                let j = *j;\\n                if ((k - 1) - (j - i as i32)) / 2 + j >= n { break }\\n                if j >= i as i32 + k { break }\\n                ret[j as usize] = cnt + 1;\\n                q.push_back((j as usize, cnt + 1));\\n                s[idx].remove(&j);\\n            }\\n            \\n            let temp = i as i32 - (k - 1) + 2 * d2;\\n            while let Some(j) = s[idx].range(..= temp).next_back() {\\n                let j = *j;\\n                if ((k - 1) - (i as i32 - j)) / 2 > j { break }\\n                if (i as i32 >= j + k) { break }\\n                ret[j as usize] = cnt + 1;\\n                q.push_back((j as usize, cnt + 1));\\n                s[idx].remove(&j);\\n            }\\n        }\\n\\n        ret\\n    }\\n}\\n```\\n\\n~~~\\n//C++\\nclass Solution {\\npublic:\\n    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {\\n        vector<set<int>> s(2);\\n        unordered_set<int> ban(banned.begin(), banned.end());\\n        for (int i = 0; i < n; ++i) {\\n            if (i != p and ban.find(i) == ban.end()) s[i % 2].insert(i);\\n        }\\n\\n        vector<int> ret(n, -1);\\n        queue<pair<int, int>> q({{p, 0}}); \\n\\n        while (not q.empty()) {\\n            int i = q.front().first, cnt = q.front().second;\\n            q.pop();\\n            ret[i] = cnt;\\n\\n            int len = (k - 1) / 2, d1 = min(len, i), d2 = min(len, n - 1 - i);\\n            int idx = p % 2;            \\n            if (k % 2 == 0 and abs(i - p) % 2 == 0) idx = 1 - idx;\\n    \\n            while (true) {\\n                auto it = s[idx].lower_bound(i + (k - 1) - 2 * d1);\\n                if (it == s[idx].end()) break;\\n                if (((k - 1) - (*it - i)) / 2 + *it >= n) break;\\n                if (*it >= i + k) break;\\n                q.push({*it, cnt + 1});\\n                s[idx].erase(it);\\n            }\\n            \\n            while (true) {\\n                auto it = s[idx].upper_bound(i - (k - 1) + 2 * d2);\\n                if (it == s[idx].begin()) break;\\n                it = prev(it);\\n                if (((k - 1) - (i - *it)) / 2 > *it) break;\\n                if (i >= *it + k) break;\\n                q.push({*it, cnt + 1});\\n                s[idx].erase(it);\\n            }        \\n        }\\n\\n        return ret;\\n    }\\n};\\n~~~",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n//Rust\\nuse std::collections::BTreeSet;\\nuse std::collections::HashSet;\\nuse std::collections::VecDeque;\\n\\nimpl Solution {\\n    pub fn min_reverse_operations(n: i32, p: i32, banned: Vec<i32>, k: i32) -> Vec<i32> {\\n        let banned = banned.into_iter().collect::<HashSet<_>>();\\n        let mut s = vec![BTreeSet::<i32>::new(); 2];\\n        for i in 0 .. n {\\n            if i != p && banned.contains(&i) == false { s[i as usize % 2].insert(i); }\\n        }\\n\\n        let mut ret = vec![-1; n as usize];\\n        let mut q = VecDeque::from([(p as usize, 0)]);\\n\\n        while let Some((i, cnt)) = q.pop_front() {\\n            ret[i] = cnt;\\n            let mut idx = p as usize % 2;\\n            if k % 2 == 0 && (i as i32 - p) % 2 == 0 { idx = 1 - idx; };\\n            let len = (k - 1) / 2; \\n            let (d1, d2) = (len.min(i as i32), len.min(n - 1 - i as i32));\\n            \\n            let temp = i as i32 + (k - 1) - 2 * d1;\\n            while let Some(j) = s[idx].range(temp ..).next() {\\n                let j = *j;\\n                if ((k - 1) - (j - i as i32)) / 2 + j >= n { break }\\n                if j >= i as i32 + k { break }\\n                ret[j as usize] = cnt + 1;\\n                q.push_back((j as usize, cnt + 1));\\n                s[idx].remove(&j);\\n            }\\n            \\n            let temp = i as i32 - (k - 1) + 2 * d2;\\n            while let Some(j) = s[idx].range(..= temp).next_back() {\\n                let j = *j;\\n                if ((k - 1) - (i as i32 - j)) / 2 > j { break }\\n                if (i as i32 >= j + k) { break }\\n                ret[j as usize] = cnt + 1;\\n                q.push_back((j as usize, cnt + 1));\\n                s[idx].remove(&j);\\n            }\\n        }\\n\\n        ret\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3738281,
                "title": "minimum-reverse-operations-to-move-a-value-in-an-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is asking us to find the minimum number of reverse operations needed to move a value (represented as 1) to each position in an array, given certain positions are banned. The reverse operation can only be performed on a subarray of size k and the value should never go to any of the positions in banned.\\n\\nOur first thought is to use a breadth-first search (BFS) approach. We can start from the initial position of the value and try to move it to each position in the array using reverse operations. We need to keep track of the minimum number of reverse operations needed to move the value to each position.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe use a breadth-first search (BFS) approach to solve this problem. We start from the initial position of the value and try to move it to each position in the array using reverse operations. We keep track of the minimum number of reverse operations needed to move the value to each position in a list out.\\n\\nFor each visited position, there are potentially O(k) target positions that can be reached through reverse operations. To avoid the multiplicative cost of iterating over all these potential positions, we update the nextNode2s array. This array initially points forward by 2, but it is updated dynamically to point beyond all the target positions considered for each visited position. This optimization helps improve the efficiency of the algorithm and avoids unnecessary computations.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this approach is O(n), where n is the length of the array. This is because we visit each position in the array once.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this approach is also O(n). This is because we need to store the minimum number of reverse operations needed to move the value to each position in a list, and we also need to store the next node for each position in an array.\\n# Code\\n```\\nfrom collections import deque\\nclass Solution:\\n    def minReverseOperations(self, n, p, banned, k):\\n        out = [-1]*n\\n        for node in banned:\\n            out[node] = -2\\n        nodes = [p]\\n        depth = 0\\n        out[p] = depth\\n        step = k - 1\\n        nextNode2s = [i+2 for i in range(n)]\\n        while nodes:\\n            depth += 1\\n            newNodes = []\\n            for node1 in nodes:\\n                loReverseStart = max(node1 - step, 0)\\n                hiReverseStart = min(node1, n - k)\\n                loNode2 = 2 * loReverseStart + k - 1 - node1\\n                hiNode2 = 2 * hiReverseStart + k - 1 - node1\\n                postHiNode2 = hiNode2 + 2\\n                node2 = loNode2\\n                while node2 <= hiNode2:\\n                    nextNode2 = nextNode2s[node2]\\n                    nextNode2s[node2] = postHiNode2\\n                    if node2 >= 0 and node2 < n and out[node2] == -1:\\n                        newNodes.append(node2)\\n                        out[node2] = depth\\n                    node2 = nextNode2\\n            nodes = newNodes\\n        for i in range(n):\\n            if out[i] == -2:\\n                out[i] = -1\\n        return out\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def minReverseOperations(self, n, p, banned, k):\\n        out = [-1]*n\\n        for node in banned:\\n            out[node] = -2\\n        nodes = [p]\\n        depth = 0\\n        out[p] = depth\\n        step = k - 1\\n        nextNode2s = [i+2 for i in range(n)]\\n        while nodes:\\n            depth += 1\\n            newNodes = []\\n            for node1 in nodes:\\n                loReverseStart = max(node1 - step, 0)\\n                hiReverseStart = min(node1, n - k)\\n                loNode2 = 2 * loReverseStart + k - 1 - node1\\n                hiNode2 = 2 * hiReverseStart + k - 1 - node1\\n                postHiNode2 = hiNode2 + 2\\n                node2 = loNode2\\n                while node2 <= hiNode2:\\n                    nextNode2 = nextNode2s[node2]\\n                    nextNode2s[node2] = postHiNode2\\n                    if node2 >= 0 and node2 < n and out[node2] == -1:\\n                        newNodes.append(node2)\\n                        out[node2] = depth\\n                    node2 = nextNode2\\n            nodes = newNodes\\n        for i in range(n):\\n            if out[i] == -2:\\n                out[i] = -1\\n        return out\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731761,
                "title": "very-chalak-bro-in-java",
                "content": "# Intuition\\nGive me Thumbs upppppppppppppp\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] minReverseOperations(int n, int p, int[] banned, int k) {\\n        TreeSet<Integer> even = new TreeSet<>();\\n        TreeSet<Integer> odd = new TreeSet<>();\\n        \\n        TreeSet<Integer> set;\\n        \\n        boolean [] skip = new boolean [n];\\n        \\n        for (int num : banned) {\\n            skip[num] = true;\\n        }\\n        \\n        int start = p;\\n        \\n\\n        for (int i = 0; i < n; ++i) {\\n            if (skip[i] || i == p)\\n                continue;\\n            \\n            if (i % 2 == 1)\\n                odd.add(i);\\n            else\\n                even.add(i);\\n        }\\n        \\n        int [] result = new int [n];\\n        Arrays.fill(result, -1);\\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(p);\\n        \\n        int size;\\n        int current;\\n        int moves = 0;\\n        \\n        int min, max;\\n        \\n        Integer key;\\n        \\n        int mCurrent;\\n        \\n        while (!queue.isEmpty()) {\\n            size = queue.size();\\n            \\n            \\n            while (size-- > 0) {\\n                current = queue.remove();\\n                \\n                result[current] = moves;\\n                \\n                \\n\\n                if (current < k - 1) {\\n                    min = (k - 1) - current;\\n                }else {\\n                    min = current - k + 1;\\n                }\\n                \\n\\n                mCurrent = (n - 1) - current;\\n                if (mCurrent < k - 1) {\\n                    max = (k - 1) - mCurrent;\\n                }else {\\n                    max = mCurrent - k + 1;\\n                }\\n                max = (n - 1) - max;\\n                \\n                \\n                \\n                set = min % 2 == 0 ? even : odd;\\n                \\n                key = set.ceiling(min);\\n                \\n               \\n                while (key != null && key <= max) {\\n                    queue.add(key);\\n                    set.remove(key);\\n                    key = set.ceiling(min);\\n                }\\n            }\\n            \\n            ++moves;\\n        }\\n        \\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] minReverseOperations(int n, int p, int[] banned, int k) {\\n        TreeSet<Integer> even = new TreeSet<>();\\n        TreeSet<Integer> odd = new TreeSet<>();\\n        \\n        TreeSet<Integer> set;\\n        \\n        boolean [] skip = new boolean [n];\\n        \\n        for (int num : banned) {\\n            skip[num] = true;\\n        }\\n        \\n        int start = p;\\n        \\n\\n        for (int i = 0; i < n; ++i) {\\n            if (skip[i] || i == p)\\n                continue;\\n            \\n            if (i % 2 == 1)\\n                odd.add(i);\\n            else\\n                even.add(i);\\n        }\\n        \\n        int [] result = new int [n];\\n        Arrays.fill(result, -1);\\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(p);\\n        \\n        int size;\\n        int current;\\n        int moves = 0;\\n        \\n        int min, max;\\n        \\n        Integer key;\\n        \\n        int mCurrent;\\n        \\n        while (!queue.isEmpty()) {\\n            size = queue.size();\\n            \\n            \\n            while (size-- > 0) {\\n                current = queue.remove();\\n                \\n                result[current] = moves;\\n                \\n                \\n\\n                if (current < k - 1) {\\n                    min = (k - 1) - current;\\n                }else {\\n                    min = current - k + 1;\\n                }\\n                \\n\\n                mCurrent = (n - 1) - current;\\n                if (mCurrent < k - 1) {\\n                    max = (k - 1) - mCurrent;\\n                }else {\\n                    max = mCurrent - k + 1;\\n                }\\n                max = (n - 1) - max;\\n                \\n                \\n                \\n                set = min % 2 == 0 ? even : odd;\\n                \\n                key = set.ceiling(min);\\n                \\n               \\n                while (key != null && key <= max) {\\n                    queue.add(key);\\n                    set.remove(key);\\n                    key = set.ceiling(min);\\n                }\\n            }\\n            \\n            ++moves;\\n        }\\n        \\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711452,
                "title": "fast-solution-swift-bfs-o-n-k-o-n",
                "content": "# Approach\\nThe algorithm follows a breadth-first search (BFS) approach to determine the minimum number of reverse operations needed to bring the 1 to each position in the array.\\n\\nTo speed up the algorithm, we mark banned positions with -2 instead of using set lookups. This optimization reduces the constant coefficient and improves the speed of the algorithm, but it may still result in a time limit exceeded (TLE) error.\\n\\nFor each visited position, there are potentially O(k) target positions that can be reached through reverse operations. To avoid the multiplicative cost of iterating over all these potential positions, we update the nextNode2s array. This array initially points forward by 2, but we update it dynamically to point beyond all the target positions considered for each visited position. This optimization helps improve the efficiency of the algorithm and avoids unnecessary computations.\\n\\n# Complexity\\n- Time complexity: O(n+k)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    func minReverseOperations(_ n: Int, _ p: Int, _ banned: [Int], _ k: Int) -> [Int] {\\n        var out = Array(repeating: -1, count: n)\\n        \\n        for node in banned {\\n            out[node] = -2\\n        }\\n        \\n        var nodes = [p]\\n        var depth = 0\\n        out[p] = depth\\n        let step = k - 1\\n        var nextNode2s = Array(0...(n - 1)).map { $0 + 2 }\\n        \\n        while !nodes.isEmpty {\\n            depth += 1\\n            var newNodes = [Int]()\\n            \\n            for node1 in nodes {\\n                let loReverseStart = max(node1 - step, 0)\\n                let hiReverseStart = min(node1, n - k)\\n                let loNode2 = 2 * loReverseStart + k - 1 - node1\\n                let hiNode2 = 2 * hiReverseStart + k - 1 - node1\\n                \\n                let postHiNode2 = hiNode2 + 2\\n                var node2 = loNode2\\n                \\n                while node2 <= hiNode2 {\\n                    let nextNode2 = nextNode2s[node2]\\n                    nextNode2s[node2] = postHiNode2\\n                    \\n                    if node2 >= 0 && node2 < n && out[node2] == -1 {\\n                        newNodes.append(node2)\\n                        out[node2] = depth\\n                    }\\n                    \\n                    node2 = nextNode2\\n                }\\n            }\\n            \\n            nodes = newNodes\\n        }\\n        \\n        for i in 0..<n {\\n            if out[i] == -2 {\\n                out[i] = -1\\n            }\\n        }\\n        \\n        return out\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    func minReverseOperations(_ n: Int, _ p: Int, _ banned: [Int], _ k: Int) -> [Int] {\\n        var out = Array(repeating: -1, count: n)\\n        \\n        for node in banned {\\n            out[node] = -2\\n        }\\n        \\n        var nodes = [p]\\n        var depth = 0\\n        out[p] = depth\\n        let step = k - 1\\n        var nextNode2s = Array(0...(n - 1)).map { $0 + 2 }\\n        \\n        while !nodes.isEmpty {\\n            depth += 1\\n            var newNodes = [Int]()\\n            \\n            for node1 in nodes {\\n                let loReverseStart = max(node1 - step, 0)\\n                let hiReverseStart = min(node1, n - k)\\n                let loNode2 = 2 * loReverseStart + k - 1 - node1\\n                let hiNode2 = 2 * hiReverseStart + k - 1 - node1\\n                \\n                let postHiNode2 = hiNode2 + 2\\n                var node2 = loNode2\\n                \\n                while node2 <= hiNode2 {\\n                    let nextNode2 = nextNode2s[node2]\\n                    nextNode2s[node2] = postHiNode2\\n                    \\n                    if node2 >= 0 && node2 < n && out[node2] == -1 {\\n                        newNodes.append(node2)\\n                        out[node2] = depth\\n                    }\\n                    \\n                    node2 = nextNode2\\n                }\\n            }\\n            \\n            nodes = newNodes\\n        }\\n        \\n        for i in 0..<n {\\n            if out[i] == -2 {\\n                out[i] = -1\\n            }\\n        }\\n        \\n        return out\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692111,
                "title": "bfs-java-solution-7ms-100-working",
                "content": "# Intuition\\nUsing BFS to traverse a graph-like representation of the sequence and keeping track of the depth or level of each position to determine the minimum number of reverse operations. Taking into account banned positions to optimize the algorithm.\\n\\n\\n# Approach\\n\\nThe approach involves using BFS to find the minimum number of reverse operations required to transform a given sequence. We initialize an array to store the result and mark banned positions. Starting from a given position, we perform a BFS traversal, keeping track of the depth and updating the result array. Finally, we return the result array.\\n\\n# Complexity\\n- Time complexity: ***O(n+k)***\\n\\n- Space complexity: ***O(n)***\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] minReverseOperations(int n, int p, int[] banned, int k) {\\n        int[] out = new int[n];\\n        Arrays.fill(out, -1);\\n        \\n        for (int node : banned) {\\n            out[node] = -2;\\n        }\\n        \\n        List<Integer> nodes = new ArrayList<>();\\n        nodes.add(p);\\n        \\n        int depth = 0;\\n        out[p] = depth;\\n        int step = k - 1;\\n        \\n        int[] nextNode2s = new int[n + 1];\\n        for (int i = 0; i < n + 1; i++) {\\n            nextNode2s[i] = i + 2;\\n        }\\n        \\n        while (!nodes.isEmpty()) {\\n            depth++;\\n            List<Integer> newNodes = new ArrayList<>();\\n            \\n            for (int node1 : nodes) {\\n                int loReverseStart = Math.max(node1 - step, 0);\\n                int hiReverseStart = Math.min(node1, n - k);\\n                int loNode2 = 2 * loReverseStart + k - 1 - node1;\\n                int hiNode2 = 2 * hiReverseStart + k - 1 - node1;\\n                int postHiNode2 = hiNode2 + 2;\\n                int node2 = loNode2;\\n                while (node2 <= hiNode2) {\\n                    int nextNode2 = nextNode2s[node2];\\n                    nextNode2s[node2] = postHiNode2;\\n                    if (node2 >= 0 && node2 < n && out[node2] == -1) {\\n                        newNodes.add(node2);\\n                        out[node2] = depth;\\n                    }       \\n                    node2 = nextNode2;\\n                }\\n            }   \\n            nodes = newNodes;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (out[i] == -2) {\\n                out[i] = -1;\\n            }\\n        }\\n        return out;\\n    }\\n}\\n\\n```\\n![free Delivery.png](https://assets.leetcode.com/users/images/26d5eb70-4ee8-4703-bfb7-494d356693e0_1687939722.5027916.png)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Breadth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int[] minReverseOperations(int n, int p, int[] banned, int k) {\\n        int[] out = new int[n];\\n        Arrays.fill(out, -1);\\n        \\n        for (int node : banned) {\\n            out[node] = -2;\\n        }\\n        \\n        List<Integer> nodes = new ArrayList<>();\\n        nodes.add(p);\\n        \\n        int depth = 0;\\n        out[p] = depth;\\n        int step = k - 1;\\n        \\n        int[] nextNode2s = new int[n + 1];\\n        for (int i = 0; i < n + 1; i++) {\\n            nextNode2s[i] = i + 2;\\n        }\\n        \\n        while (!nodes.isEmpty()) {\\n            depth++;\\n            List<Integer> newNodes = new ArrayList<>();\\n            \\n            for (int node1 : nodes) {\\n                int loReverseStart = Math.max(node1 - step, 0);\\n                int hiReverseStart = Math.min(node1, n - k);\\n                int loNode2 = 2 * loReverseStart + k - 1 - node1;\\n                int hiNode2 = 2 * hiReverseStart + k - 1 - node1;\\n                int postHiNode2 = hiNode2 + 2;\\n                int node2 = loNode2;\\n                while (node2 <= hiNode2) {\\n                    int nextNode2 = nextNode2s[node2];\\n                    nextNode2s[node2] = postHiNode2;\\n                    if (node2 >= 0 && node2 < n && out[node2] == -1) {\\n                        newNodes.add(node2);\\n                        out[node2] = depth;\\n                    }       \\n                    node2 = nextNode2;\\n                }\\n            }   \\n            nodes = newNodes;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (out[i] == -2) {\\n                out[i] = -1;\\n            }\\n        }\\n        return out;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640977,
                "title": "goodd-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <iostream>\\n#include <vector>\\n#include <queue>\\n\\nclass Solution \\n{\\nprivate:\\n    struct TreeNode\\n    {\\n        int val;\\n        TreeNode* left;\\n        TreeNode* right;\\n        TreeNode* parent;\\n\\n        TreeNode(const int& v)\\n        {\\n            val = v;\\n            left = nullptr;\\n            right = nullptr;\\n            parent = nullptr;\\n        }\\n    };\\n\\n    class Tree\\n    {\\n    public:\\n        Tree(const std::vector<int>& v)\\n        {\\n            root = buildTreeFrom(v, 0, v.size() - 1);\\n        }\\n\\n        TreeNode* find(const int& val)\\n        {\\n            return findNode(root, val);\\n        }\\n\\n        TreeNode* next(TreeNode* node)\\n        {\\n            if (node->right)\\n            {\\n                node = node->right;\\n                while (node->left)\\n                    node = node->left;\\n\\n                return node;\\n            }\\n        \\n            TreeNode* parent = node->parent;\\n            while (parent && node == parent->right) \\n            {\\n                node = parent;\\n                parent = parent->parent;\\n            }\\n            return parent;\\n        }\\n\\n        TreeNode* erase(TreeNode* node)\\n        {\\n            if (!node)\\n                return nullptr;\\n\\n            TreeNode* parent = node->parent;\\n            if (!node->left && !node->right)\\n            {\\n                TreeNode* nextNode = next(node);\\n                if (!parent)\\n                {\\n                    root = nullptr;\\n                }\\n                else\\n                {\\n                    if (parent->left == node)\\n                        parent->left = nullptr;\\n                    else\\n                        parent->right = nullptr;\\n                }\\n                \\n                return nextNode;\\n            }\\n            else if (!node->left) \\n            {\\n                TreeNode* nextNode = next(node);\\n\\n                if (!parent)\\n                {\\n                    root = node->right;\\n                    node->right->parent = nullptr;\\n                }\\n                else if (parent->left == node)\\n                {\\n                    parent->left = node->right;\\n                    node->right->parent = parent;\\n                }\\n                else\\n                {\\n                    parent->right = node->right;\\n                    node->right->parent = parent;\\n                }\\n\\n                delete node;\\n                return nextNode;\\n            }\\n            else if (!node->right) \\n            {\\n                TreeNode* nextNode = next(node);\\n                if (!parent)\\n                {\\n                    root = node->left;\\n                    node->left->parent = nullptr;\\n                }\\n                else if (parent->left == node)\\n                {\\n                    parent->left = node->left;\\n                    node->left->parent = parent;\\n                }\\n                else\\n                {\\n                    parent->right = node->left;\\n                    node->left->parent = parent;\\n                }\\n\\n                delete node;\\n                return nextNode;\\n            }\\n            else\\n            {\\n                TreeNode* temp = node->right;\\n                while (temp->left)\\n                    temp = temp->left;\\n\\n                node->val = temp->val;\\n\\n                erase(temp);\\n                return node;\\n            }\\n        }\\n\\n    private:      \\n        TreeNode* buildTreeFrom(const std::vector<int>& vec, int start, int end)\\n        {       \\n            if (start > end)\\n                return nullptr;\\n        \\n            int mid = (start + end) / 2;\\n            TreeNode* node = new TreeNode(vec[mid]);\\n            node->left  = buildTreeFrom(vec, start, mid - 1);\\n            node->right = buildTreeFrom(vec, mid + 1, end);\\n\\n            if (node->left)\\n                node->left->parent = node;\\n            if (node->right)\\n                node->right->parent = node;\\n\\n            return node;\\n        }\\n\\n        TreeNode* findNode(TreeNode* node, const int& val)\\n        {\\n            TreeNode* stored = nullptr;\\n            while (node)\\n            {\\n                if (node->val >= val)\\n                {\\n                    stored = node;\\n                    node = node->left;\\n                }\\n                else\\n                {\\n                    node = node->right;\\n                }\\n            }\\n            return stored;\\n        }\\n\\n    private:\\n        TreeNode* root;\\n    };\\n\\npublic:    \\n    std::vector<int> minReverseOperations(int n, int p, std::vector<int>& banned, int k) \\n    {\\n        std::vector<int> visited(n, -1);\\n        std::vector<int> ban(n , 0);\\n        for (const int& b: banned)\\n        {\\n            ban[b] = -1;\\n            visited[b] = -1;\\n        }\\n        \\n        std::vector<int> vOdd, vEven;\\n        for (int i = 0; i < n; ++i) \\n        {            \\n            if (!ban[i] && i != p) \\n            {\\n                if (i & 1)\\n                    vOdd.push_back(i);\\n                else\\n                    vEven.push_back(i);\\n            }\\n        }          \\n\\n        Tree odd(vOdd);\\n        Tree even(vEven);    \\n        \\n        std::queue<int> q;\\n        q.push(p);\\n        visited[p] = 0;\\n        while (!q.empty())    \\n        {\\n            int curr = q.front();\\n            q.pop();\\n\\n            int begin = std::abs(curr - k + 1);\\n            int end   = n - 1 - std::abs(n - curr - k);\\n\\n            Tree& tree = begin & 1 ? odd : even;\\n            TreeNode* entry = tree.find(begin);\\n            while (entry && entry->val <= end)\\n            {\\n                q.push(entry->val);\\n                visited[entry->val] = visited[curr] + 1;\\n                entry = tree.erase(entry);\\n            }\\n        }\\n        return visited;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <iostream>\\n#include <vector>\\n#include <queue>\\n\\nclass Solution \\n{\\nprivate:\\n    struct TreeNode\\n    {\\n        int val;\\n        TreeNode* left;\\n        TreeNode* right;\\n        TreeNode* parent;\\n\\n        TreeNode(const int& v)\\n        {\\n            val = v;\\n            left = nullptr;\\n            right = nullptr;\\n            parent = nullptr;\\n        }\\n    };\\n\\n    class Tree\\n    {\\n    public:\\n        Tree(const std::vector<int>& v)\\n        {\\n            root = buildTreeFrom(v, 0, v.size() - 1);\\n        }\\n\\n        TreeNode* find(const int& val)\\n        {\\n            return findNode(root, val);\\n        }\\n\\n        TreeNode* next(TreeNode* node)\\n        {\\n            if (node->right)\\n            {\\n                node = node->right;\\n                while (node->left)\\n                    node = node->left;\\n\\n                return node;\\n            }\\n        \\n            TreeNode* parent = node->parent;\\n            while (parent && node == parent->right) \\n            {\\n                node = parent;\\n                parent = parent->parent;\\n            }\\n            return parent;\\n        }\\n\\n        TreeNode* erase(TreeNode* node)\\n        {\\n            if (!node)\\n                return nullptr;\\n\\n            TreeNode* parent = node->parent;\\n            if (!node->left && !node->right)\\n            {\\n                TreeNode* nextNode = next(node);\\n                if (!parent)\\n                {\\n                    root = nullptr;\\n                }\\n                else\\n                {\\n                    if (parent->left == node)\\n                        parent->left = nullptr;\\n                    else\\n                        parent->right = nullptr;\\n                }\\n                \\n                return nextNode;\\n            }\\n            else if (!node->left) \\n            {\\n                TreeNode* nextNode = next(node);\\n\\n                if (!parent)\\n                {\\n                    root = node->right;\\n                    node->right->parent = nullptr;\\n                }\\n                else if (parent->left == node)\\n                {\\n                    parent->left = node->right;\\n                    node->right->parent = parent;\\n                }\\n                else\\n                {\\n                    parent->right = node->right;\\n                    node->right->parent = parent;\\n                }\\n\\n                delete node;\\n                return nextNode;\\n            }\\n            else if (!node->right) \\n            {\\n                TreeNode* nextNode = next(node);\\n                if (!parent)\\n                {\\n                    root = node->left;\\n                    node->left->parent = nullptr;\\n                }\\n                else if (parent->left == node)\\n                {\\n                    parent->left = node->left;\\n                    node->left->parent = parent;\\n                }\\n                else\\n                {\\n                    parent->right = node->left;\\n                    node->left->parent = parent;\\n                }\\n\\n                delete node;\\n                return nextNode;\\n            }\\n            else\\n            {\\n                TreeNode* temp = node->right;\\n                while (temp->left)\\n                    temp = temp->left;\\n\\n                node->val = temp->val;\\n\\n                erase(temp);\\n                return node;\\n            }\\n        }\\n\\n    private:      \\n        TreeNode* buildTreeFrom(const std::vector<int>& vec, int start, int end)\\n        {       \\n            if (start > end)\\n                return nullptr;\\n        \\n            int mid = (start + end) / 2;\\n            TreeNode* node = new TreeNode(vec[mid]);\\n            node->left  = buildTreeFrom(vec, start, mid - 1);\\n            node->right = buildTreeFrom(vec, mid + 1, end);\\n\\n            if (node->left)\\n                node->left->parent = node;\\n            if (node->right)\\n                node->right->parent = node;\\n\\n            return node;\\n        }\\n\\n        TreeNode* findNode(TreeNode* node, const int& val)\\n        {\\n            TreeNode* stored = nullptr;\\n            while (node)\\n            {\\n                if (node->val >= val)\\n                {\\n                    stored = node;\\n                    node = node->left;\\n                }\\n                else\\n                {\\n                    node = node->right;\\n                }\\n            }\\n            return stored;\\n        }\\n\\n    private:\\n        TreeNode* root;\\n    };\\n\\npublic:    \\n    std::vector<int> minReverseOperations(int n, int p, std::vector<int>& banned, int k) \\n    {\\n        std::vector<int> visited(n, -1);\\n        std::vector<int> ban(n , 0);\\n        for (const int& b: banned)\\n        {\\n            ban[b] = -1;\\n            visited[b] = -1;\\n        }\\n        \\n        std::vector<int> vOdd, vEven;\\n        for (int i = 0; i < n; ++i) \\n        {            \\n            if (!ban[i] && i != p) \\n            {\\n                if (i & 1)\\n                    vOdd.push_back(i);\\n                else\\n                    vEven.push_back(i);\\n            }\\n        }          \\n\\n        Tree odd(vOdd);\\n        Tree even(vEven);    \\n        \\n        std::queue<int> q;\\n        q.push(p);\\n        visited[p] = 0;\\n        while (!q.empty())    \\n        {\\n            int curr = q.front();\\n            q.pop();\\n\\n            int begin = std::abs(curr - k + 1);\\n            int end   = n - 1 - std::abs(n - curr - k);\\n\\n            Tree& tree = begin & 1 ? odd : even;\\n            TreeNode* entry = tree.find(begin);\\n            while (entry && entry->val <= end)\\n            {\\n                q.push(entry->val);\\n                visited[entry->val] = visited[curr] + 1;\\n                entry = tree.erase(entry);\\n            }\\n        }\\n        return visited;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3639869,
                "title": "doubly-linked-list-python",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minReverseOperations(self, n: int, p: int, banned: List[int], k: int) -> List[int]:\\n        right = [(i+2) % (n+4) for i in range(n+4)]\\n        left = [(i-2) for i in range(n+4)]\\n        distance = [-1] * n\\n        q = collections.deque(maxlen=n)\\n\\n        def first(i):\\n            j = right[i]\\n            if left[j] == i:\\n                return i\\n            else:\\n                right[i] = first(j)\\n                return right[i]\\n\\n        def drop(i):\\n            left[right[i]], right[left[i]] = left[i], right[i]\\n\\n        def set_distance(i, d):\\n            distance[i] = d\\n            q.append(i)\\n            drop(i)\\n\\n        for i in banned:\\n            drop(i)\\n\\n        set_distance(p, 0)\\n        while q:\\n            i0 = q.popleft()\\n            s0 = abs(i0 - (k - 1))\\n            i = first(s0)\\n            if i < n:\\n                d = distance[i0] + 1\\n                s1 = min(i0+k-1, 2*n-k-1-i0)\\n                while i <= s1:\\n                    set_distance(i, d)\\n                    i = right[i]\\n\\n\\n        return distance\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minReverseOperations(self, n: int, p: int, banned: List[int], k: int) -> List[int]:\\n        right = [(i+2) % (n+4) for i in range(n+4)]\\n        left = [(i-2) for i in range(n+4)]\\n        distance = [-1] * n\\n        q = collections.deque(maxlen=n)\\n\\n        def first(i):\\n            j = right[i]\\n            if left[j] == i:\\n                return i\\n            else:\\n                right[i] = first(j)\\n                return right[i]\\n\\n        def drop(i):\\n            left[right[i]], right[left[i]] = left[i], right[i]\\n\\n        def set_distance(i, d):\\n            distance[i] = d\\n            q.append(i)\\n            drop(i)\\n\\n        for i in banned:\\n            drop(i)\\n\\n        set_distance(p, 0)\\n        while q:\\n            i0 = q.popleft()\\n            s0 = abs(i0 - (k - 1))\\n            i = first(s0)\\n            if i < n:\\n                d = distance[i0] + 1\\n                s1 = min(i0+k-1, 2*n-k-1-i0)\\n                while i <= s1:\\n                    set_distance(i, d)\\n                    i = right[i]\\n\\n\\n        return distance\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623145,
                "title": "breadth-first-search-with-treeset-minimum-reverse-operations-for-array-positioning",
                "content": "# Intuition\\nThe approach uses a breadth-first search to find the minimum number of reverse operations required to bring the 1 to each position in the array. It efficiently uses two TreeSet objects to track available positions based on their parity and avoids banned positions. By processing positions in levels, it ensures that the minimum number of moves is calculated correctly.\\n\\n# Approach\\n1. Create two TreeSet objects, `even` and `odd`, to store positions with even and odd indices respectively.\\n2. Create a boolean array, `skip`, to mark banned positions.\\n3. Mark the banned positions in the `skip` array.\\n4. Add values to the `even` and `odd` sets that are not banned, based on their parity.\\n5. Create a `result` array and initialize it with -1 to store the minimum number of operations required for each position.\\n6. Create a `Queue` called queue and add the initial position `p` to it.\\n7. While the queue is not empty, do the following:\\nProcess positions in the current level.\\n    * Calculate the minimum and maximum indices for the subarray based on the current position and the value of `k`.\\n    * Choose the appropriate TreeSet based on the parity of the minimum index.\\n    * Add all positions in the range to the queue and remove them from the set.\\n    * Increment the number of moves for the next level.\\n8. Return the `result` array.\\n\\n# Complexity\\n- Time complexity:\\nThe code processes each position in the array once, and for each position, it performs operations on the TreeSet in logarithmic time. Therefore, the overall time complexity is O(n log n), where n is the size of the array.\\n\\n- Space complexity:\\nThe code uses TreeSet objects to store the available positions, which require O(n) space. Additionally, it uses arrays and queues of size n for bookkeeping. Therefore, the overall space complexity is O(n).\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] minReverseOperations(int n, int p, int[] banned, int k) {\\n        TreeSet<Integer> even = new TreeSet<>();\\n        TreeSet<Integer> odd = new TreeSet<>();\\n        \\n        TreeSet<Integer> set;\\n        \\n        boolean [] skip = new boolean [n];\\n        \\n        for (int num : banned) {\\n            skip[num] = true;\\n        }\\n        \\n        int start = p;\\n        \\n        // Add values to the set that are not banned\\n        for (int i = 0; i < n; ++i) {\\n            if (skip[i] || i == p)\\n                continue;\\n            \\n            if (i % 2 == 1)\\n                odd.add(i);\\n            else\\n                even.add(i);\\n        }\\n        \\n        int [] result = new int [n];\\n        Arrays.fill(result, -1);\\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(p);\\n        \\n        int size;\\n        int current;\\n        int moves = 0;\\n        \\n        int min, max;\\n        \\n        Integer key;\\n        \\n        int mCurrent;\\n        \\n        while (!queue.isEmpty()) {\\n            size = queue.size();\\n            \\n            \\n            while (size-- > 0) {\\n                current = queue.remove();\\n                \\n                result[current] = moves;\\n                \\n                \\n                // calculate min index\\n                if (current < k - 1) {\\n                    min = (k - 1) - current;\\n                }else {\\n                    min = current - k + 1;\\n                }\\n                \\n                // calculate max index\\n                mCurrent = (n - 1) - current;\\n                if (mCurrent < k - 1) {\\n                    max = (k - 1) - mCurrent;\\n                }else {\\n                    max = mCurrent - k + 1;\\n                }\\n                max = (n - 1) - max;\\n                \\n                \\n                // chose the correct parity set\\n                set = min % 2 == 0 ? even : odd;\\n                \\n                key = set.ceiling(min);\\n                \\n                // add all values in range to the queue and remove from set\\n                while (key != null && key <= max) {\\n                    queue.add(key);\\n                    set.remove(key);\\n                    key = set.ceiling(min);\\n                }\\n            }\\n            \\n            ++moves;\\n        }\\n        \\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Breadth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int[] minReverseOperations(int n, int p, int[] banned, int k) {\\n        TreeSet<Integer> even = new TreeSet<>();\\n        TreeSet<Integer> odd = new TreeSet<>();\\n        \\n        TreeSet<Integer> set;\\n        \\n        boolean [] skip = new boolean [n];\\n        \\n        for (int num : banned) {\\n            skip[num] = true;\\n        }\\n        \\n        int start = p;\\n        \\n        // Add values to the set that are not banned\\n        for (int i = 0; i < n; ++i) {\\n            if (skip[i] || i == p)\\n                continue;\\n            \\n            if (i % 2 == 1)\\n                odd.add(i);\\n            else\\n                even.add(i);\\n        }\\n        \\n        int [] result = new int [n];\\n        Arrays.fill(result, -1);\\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(p);\\n        \\n        int size;\\n        int current;\\n        int moves = 0;\\n        \\n        int min, max;\\n        \\n        Integer key;\\n        \\n        int mCurrent;\\n        \\n        while (!queue.isEmpty()) {\\n            size = queue.size();\\n            \\n            \\n            while (size-- > 0) {\\n                current = queue.remove();\\n                \\n                result[current] = moves;\\n                \\n                \\n                // calculate min index\\n                if (current < k - 1) {\\n                    min = (k - 1) - current;\\n                }else {\\n                    min = current - k + 1;\\n                }\\n                \\n                // calculate max index\\n                mCurrent = (n - 1) - current;\\n                if (mCurrent < k - 1) {\\n                    max = (k - 1) - mCurrent;\\n                }else {\\n                    max = mCurrent - k + 1;\\n                }\\n                max = (n - 1) - max;\\n                \\n                \\n                // chose the correct parity set\\n                set = min % 2 == 0 ? even : odd;\\n                \\n                key = set.ceiling(min);\\n                \\n                // add all values in range to the queue and remove from set\\n                while (key != null && key <= max) {\\n                    queue.add(key);\\n                    set.remove(key);\\n                    key = set.ceiling(min);\\n                }\\n            }\\n            \\n            ++moves;\\n        }\\n        \\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615826,
                "title": "python-beats-100-time-with-14-lines-simple-bfs-idea",
                "content": "# Intuition\\n\\nSome observations about the problem:\\n\\n*   Each subarray reverse operation is just moving the position p of the single 1 in the array.\\n*   Therefore the current \"state\" after any number of reverses can be summarized by the current position `pos` of the 1, and the number of `moves` taken to get there.\\n*   The potential reversal operations at any state are limited by just two factors:\\n    *   The banned positions: the 1 isn\\'t allowed to be moved there by a subarray reversal\\n    *   The boundaries of the array: the subarray being reversed should contain the 1 (otherwise there\\'s no point), but it can\\'t extend beyond the overall array.\\n\\n\\n# Approach\\n\\nThe idea is to take a dynamic programming approach, sort of a breadth-first search from the starting point `pos=p` with `moves=0`.\\n\\nAt each step, we form an array `added` of the new positions that can be reached with one more reverse operation (i.e. `moves+1` steps).\\n\\nWhen the newly-reachable array `added` is empty, the search ends. We never add anything twice to this array.\\n\\nThe key observation for efficiency is that the **newly-reachable positions consist of all even or odd indexes within a sub-array**. That means that by just computing the left and right *boundaries* (called `lbound` and `rbound`) of what is newly-reachable, we have all the information we need. This saves a nested loop and makes the code much faster!\\n\\n# Complexity\\n- Time complexity: $$O(n^2/k)$$. The bottleneck is the list comprehension to compute the next `added` set, which iterates over (half of) the integers in the range `[lbound..rbound]`. This outer while loop is then repeated $$O(n/k)$$ times in order to potentially reach from one side of the array to the other.\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minReverseOperations(self, n: int, p: int, banned: List[int], k: int) -> List[int]:\\n        banda = [False] * n\\n        for i in banned: banda[i] = True\\n        ops = [-1] * n\\n        moves = 0\\n        added = [p]\\n        while added:\\n            lbound, rbound = n, -1\\n            for pos in added:\\n                ops[pos] = moves\\n                lbound = min(lbound, abs(pos - k + 1))\\n                rbound = max(rbound, n - 1 - abs(n - k - pos))\\n            added = [i for i in range(lbound, rbound+1, 2) if (ops[i] == -1 and not banda[i])]\\n            moves += 1\\n        return ops\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minReverseOperations(self, n: int, p: int, banned: List[int], k: int) -> List[int]:\\n        banda = [False] * n\\n        for i in banned: banda[i] = True\\n        ops = [-1] * n\\n        moves = 0\\n        added = [p]\\n        while added:\\n            lbound, rbound = n, -1\\n            for pos in added:\\n                ops[pos] = moves\\n                lbound = min(lbound, abs(pos - k + 1))\\n                rbound = max(rbound, n - 1 - abs(n - k - pos))\\n            added = [i for i in range(lbound, rbound+1, 2) if (ops[i] == -1 and not banda[i])]\\n            moves += 1\\n        return ops\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563175,
                "title": "python3-without-the-use-of-imports",
                "content": "# Intuition\\nI didn\\'t really like how every other solution I saw involved some third party packages. I wanted to write a piece of code that works with python3 out of the box, no other packages or libraries.\\n\\n# Approach\\nThe big piece I was missing was two fold:\\n\\n1. BFS alone is not fast enough. You need to track all elements that have not been queued yet. Since your step-width for every $$i$$ is $$2$$, it means it\\'s most efficient to keep track of two lists with even and odd elements respectiveley.\\n2. You shouldn\\'t iterate other positions. Instead, you should iterate `lower` which is the lower bound of your reversing operation. Every reverse will flip the elements between `lower` and upper. \\n\\nI believe that most answers here get to the first realization so I want to expand on the second one in my own words. It\\'s easy to see that the upper bound will be `lower + k - 1` for any lower and k. We now use the formular that translates a pre-flip position `i` into a post-flip `j` with `j = upper - (i - lower)` to be\\n`j = 2 * lower + k - 1 - i`.\\nThat was the last puzzle piece for me. With the observations above, we now need to go through all j\\'s that have not previously been observed and are in the boundaries (inclusive)\\n`[2 * lower_min + k - 1 - i, 2 * lower_max + k - 1 - i]`\\nwhere\\n`lower_min = max(0, i - k + 1)`\\nand\\n`lower_max = min(n - k, i)`\\n\\nTranslated back to plain english: Take all possible inversions, iterate over the lower index of that inversion, translate that iteration into an iteration over the new index j, and use the other observations to speed up that process by only looking at each j once.\\n\\n# Complexity\\n- Time complexity:\\nIt seems that all answers for this are $$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\ndef bisect_left(lst, num, lo=0, hi=None):\\n    if hi is None: hi = len(lst)\\n    while lo < hi:\\n        mid = (lo + hi) // 2\\n        if lst[mid] < num: lo = mid + 1\\n        else: hi = mid\\n    return lo\\n\\nclass Solution:\\n    def minReverseOperations(self, n: int, p: int, banned_: List[int], k: int) -> List[int]:\\n        banned = set(banned_)\\n        lists = [[], []]\\n        pos = [(0 if i == p else -1) for i in range(n)]\\n        for i in range(n):\\n            if i in banned or i == p:\\n                continue\\n            lists[i % 2].append(i)\\n        queue = [ p ]\\n\\n        for i in queue:\\n            l = lists[(k - 1 - i) % 2]\\n            lower_min = max(0, i - k + 1)\\n            lower_max = min(n - k, i)\\n            j_lower_min = 2 * lower_min + k - 1 - i\\n            j_lower_max = 2 * lower_max + k - 1 - i\\n            j = bisect_left(l, j_lower_min)\\n            while j < len(l) and l[j] <= j_lower_max:\\n                queue.append(l[j])\\n                pos[l[j]] = pos[i] + 1\\n                del l[j]\\n\\n        return pos\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef bisect_left(lst, num, lo=0, hi=None):\\n    if hi is None: hi = len(lst)\\n    while lo < hi:\\n        mid = (lo + hi) // 2\\n        if lst[mid] < num: lo = mid + 1\\n        else: hi = mid\\n    return lo\\n\\nclass Solution:\\n    def minReverseOperations(self, n: int, p: int, banned_: List[int], k: int) -> List[int]:\\n        banned = set(banned_)\\n        lists = [[], []]\\n        pos = [(0 if i == p else -1) for i in range(n)]\\n        for i in range(n):\\n            if i in banned or i == p:\\n                continue\\n            lists[i % 2].append(i)\\n        queue = [ p ]\\n\\n        for i in queue:\\n            l = lists[(k - 1 - i) % 2]\\n            lower_min = max(0, i - k + 1)\\n            lower_max = min(n - k, i)\\n            j_lower_min = 2 * lower_min + k - 1 - i\\n            j_lower_max = 2 * lower_max + k - 1 - i\\n            j = bisect_left(l, j_lower_min)\\n            while j < len(l) and l[j] <= j_lower_max:\\n                queue.append(l[j])\\n                pos[l[j]] = pos[i] + 1\\n                del l[j]\\n\\n        return pos\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3500875,
                "title": "python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom bisect import bisect_left, bisect_right\\n\\nIMPOSSIBLE = -1\\nEVEN, ODD = 0, 1\\n\\nclass Solution:\\n    def minReverseOperations(self, N, p, banned, k):\\n        if k == 1 or len(banned) == N-1:\\n            numOps = [IMPOSSIBLE] * N\\n            numOps[p] = 0\\n            return numOps\\n        \\n        numOps = [IMPOSSIBLE] * N\\n        numOps[p] = 0\\n        \\n        remaining = [[], []]\\n        banned = set(banned)\\n        for pos in range(0, N, 2):\\n            if pos != p and pos not in banned:\\n                remaining[EVEN].append(pos)\\n            pos += 1\\n            if pos != p and pos not in banned:\\n                remaining[ODD].append(pos)\\n        \\n        # BFS\\n        numOp = 1\\n        p0s = [p]\\n        while p0s:\\n            p1s = []\\n            for p0 in p0s:\\n                i_lo = max(0, p0+1-k)\\n                i_hi = min(N-k, p0)\\n                p1_lo = p1_hi = k-1-p0\\n                p1_lo += 2*i_lo\\n                p1_hi += 2*i_hi\\n                parity = p1_lo & 0b1\\n                rem = remaining[parity]\\n                lo = bisect_left(rem, p1_lo)\\n                hi = bisect_right(rem, p1_hi)\\n\\n                for j in reversed(range(lo, hi)):\\n                    p1 = rem.pop(j)\\n                    numOps[p1] = numOp\\n                    p1s.append(p1)\\n            \\n            p0s = p1s\\n            numOp += 1\\n        \\n        return numOps\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom bisect import bisect_left, bisect_right\\n\\nIMPOSSIBLE = -1\\nEVEN, ODD = 0, 1\\n\\nclass Solution:\\n    def minReverseOperations(self, N, p, banned, k):\\n        if k == 1 or len(banned) == N-1:\\n            numOps = [IMPOSSIBLE] * N\\n            numOps[p] = 0\\n            return numOps\\n        \\n        numOps = [IMPOSSIBLE] * N\\n        numOps[p] = 0\\n        \\n        remaining = [[], []]\\n        banned = set(banned)\\n        for pos in range(0, N, 2):\\n            if pos != p and pos not in banned:\\n                remaining[EVEN].append(pos)\\n            pos += 1\\n            if pos != p and pos not in banned:\\n                remaining[ODD].append(pos)\\n        \\n        # BFS\\n        numOp = 1\\n        p0s = [p]\\n        while p0s:\\n            p1s = []\\n            for p0 in p0s:\\n                i_lo = max(0, p0+1-k)\\n                i_hi = min(N-k, p0)\\n                p1_lo = p1_hi = k-1-p0\\n                p1_lo += 2*i_lo\\n                p1_hi += 2*i_hi\\n                parity = p1_lo & 0b1\\n                rem = remaining[parity]\\n                lo = bisect_left(rem, p1_lo)\\n                hi = bisect_right(rem, p1_hi)\\n\\n                for j in reversed(range(lo, hi)):\\n                    p1 = rem.pop(j)\\n                    numOps[p1] = numOp\\n                    p1s.append(p1)\\n            \\n            p0s = p1s\\n            numOp += 1\\n        \\n        return numOps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483186,
                "title": "very-easy-c",
                "content": "\\nclass Solution {\\npublic:\\n    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {\\n        vector<int> out(n, -1);\\n\\n        for (int node : banned) {\\n            out[node] = -2;\\n        }\\n\\n        vector<int> nodes{p};\\n        int depth = 0;\\n        out[p] = depth;\\n        int step = k - 1;\\n        \\n\\n        vector<int> nextNode2s(n, 0);\\n        for (int i = 0; i < n; ++i) {\\n            nextNode2s[i] = i + 2; \\n        }\\n\\n        while (!nodes.empty()) {\\n            depth += 1;\\n            vector<int> newNodes;\\n            for (int node1 : nodes) {\\n              \\n                int loReverseStart = max(node1 - step, 0);\\n                int hiReverseStart = min(node1, n - k); \\n                int loNode2 = 2 * loReverseStart + k - 1 - node1;\\n                int hiNode2 = 2 * hiReverseStart + k - 1 - node1;  \\n             \\n                int postHiNode2 = hiNode2 + 2;\\n                int node2 = loNode2;\\n                while (node2 <= hiNode2) {\\n                    int nextNode2 = nextNode2s[node2];\\n                    nextNode2s[node2] = postHiNode2;\\n                    if (node2 >= 0 && node2 < n && out[node2] == -1) {\\n                        newNodes.push_back(node2);\\n                        out[node2] = depth;\\n                    }\\n                    node2 = nextNode2;\\n                }\\n            }\\n            nodes = newNodes;\\n        }\\n        \\n       \\n        for (int i = 0; i < n; ++i) {\\n            if (out[i] == -2) {\\n                out[i] = -1;\\n            }\\n        }\\n        return out;\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {\\n        vector<int> out(n, -1);\\n\\n        for (int node : banned) {\\n            out[node] = -2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3473552,
                "title": "c-commented-solution-using-bfs-set-time-o-nlogn-space-o-n",
                "content": "# Code\\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {\\n        int len = banned.size(), res = -1, sz, cur, low, high;\\n        vector<int> ans(n, -1);\\n        set<int> even, odd;// Create two sets to store even and odd indices respectively Initially, all indices are present in the corresponding set\\n        for (int i = 0; i < n; i++) i % 2 == 0 ? even.insert(i) : odd.insert(i);\\n        for (int i = 0; i < len; i++)  banned[i] % 2 == 0 ? even.erase(banned[i]) : odd.erase(banned[i]); // Remove the banned indices from their corresponding sets\\n        queue<int> q; // Use a BFS approach to traverse the array and find the minimum number of reverse operations required to move the 1 to all other indices\\n        q.push(p);\\n        p % 2 == 0 ? even.erase(p) : odd.erase(p); // p is insert in the queue, so remove it form set\\n        while (!q.empty()) {\\n            res++;\\n            sz = q.size();\\n            while (sz--) {\\n                cur = q.front();\\n                q.pop();\\n                ans[cur] = res; // Update the answer for the current index\\n                low = cur < k ? 0 : cur - k + 1; // Determine the lowest index from which if we take subarray of length k then cur is part of that subarray\\n                high = n - 1 - cur < k ? n - 1 : cur + k - 1; // Determine the highest index if subarray of length k end to that index then cur is part of that subarray\\n                low += low + k - 1 - cur; // Determine the lowest index where cur element can go after reverse opreation\\n                high -= cur + k - 1 - high; // Determine the highest index where cur element can go after reverse opreation\\n                // Use the sets to find the next indices that can be visited within the allowed range\\n                if (low % 2 == 0) {\\n                    auto it = even.lower_bound(low);\\n                    while (it != even.end() && *it <= high) {\\n                        q.push(*it);\\n                        auto ij = it;\\n                        it++;\\n                        even.erase(ij);\\n                    }\\n                } else {\\n                    auto it = odd.lower_bound(low);\\n                    while (it != odd.end() && *it <= high) {\\n                        q.push(*it);\\n                        auto ij = it;\\n                        it++;\\n                        odd.erase(ij);\\n                    }\\n                }\\n            }\\n        }\\n        return ans; // Return the final answer\\n    }\\n};\\n\\n```\\n\\n# Complexity\\n**Time complexity:**\\n\\nRemoving the banned indices from the sets takes O(len) time.\\nThe BFS algorithm has a worst-case time complexity of O(n), where n is the number of elements in the array, as each index is visited at most once.\\nFinding the lower and upper bounds for each index takes O(log n) time in the worst case.\\nUpdating the sets and the queue takes O(log n) time for each index.\\nTherefore, the overall time complexity of the algorithm is O(n log n).\\n\\n**Space complexity:**\\n\\nThe space required to store the sets is O(n) as each index is stored at most once.\\nThe space required to store the queue is also O(n) as each index is stored at most once.\\nThe space required to store the answer vector is O(n).\\nTherefore, the overall space complexity of the algorithm is O(n).",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {\\n        int len = banned.size(), res = -1, sz, cur, low, high;\\n        vector<int> ans(n, -1);\\n        set<int> even, odd;// Create two sets to store even and odd indices respectively Initially, all indices are present in the corresponding set\\n        for (int i = 0; i < n; i++) i % 2 == 0 ? even.insert(i) : odd.insert(i);\\n        for (int i = 0; i < len; i++)  banned[i] % 2 == 0 ? even.erase(banned[i]) : odd.erase(banned[i]); // Remove the banned indices from their corresponding sets\\n        queue<int> q; // Use a BFS approach to traverse the array and find the minimum number of reverse operations required to move the 1 to all other indices\\n        q.push(p);\\n        p % 2 == 0 ? even.erase(p) : odd.erase(p); // p is insert in the queue, so remove it form set\\n        while (!q.empty()) {\\n            res++;\\n            sz = q.size();\\n            while (sz--) {\\n                cur = q.front();\\n                q.pop();\\n                ans[cur] = res; // Update the answer for the current index\\n                low = cur < k ? 0 : cur - k + 1; // Determine the lowest index from which if we take subarray of length k then cur is part of that subarray\\n                high = n - 1 - cur < k ? n - 1 : cur + k - 1; // Determine the highest index if subarray of length k end to that index then cur is part of that subarray\\n                low += low + k - 1 - cur; // Determine the lowest index where cur element can go after reverse opreation\\n                high -= cur + k - 1 - high; // Determine the highest index where cur element can go after reverse opreation\\n                // Use the sets to find the next indices that can be visited within the allowed range\\n                if (low % 2 == 0) {\\n                    auto it = even.lower_bound(low);\\n                    while (it != even.end() && *it <= high) {\\n                        q.push(*it);\\n                        auto ij = it;\\n                        it++;\\n                        even.erase(ij);\\n                    }\\n                } else {\\n                    auto it = odd.lower_bound(low);\\n                    while (it != odd.end() && *it <= high) {\\n                        q.push(*it);\\n                        auto ij = it;\\n                        it++;\\n                        odd.erase(ij);\\n                    }\\n                }\\n            }\\n        }\\n        return ans; // Return the final answer\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436527,
                "title": "c-solution-with-detailed-description",
                "content": "# Intuition\\nThe problem requires to find the minimum number of reverse operations needed to convert the given sequence of integers b to a sequence a of length n, such that a subsequence of length k starting from the index p in the sequence a is strictly increasing. A reverse operation consists of reversing a subsequence in a.\\n\\n# Approach\\nThe given problem can be solved using BFS. Initially, create a set s containing all the elements in the sequence b. Then, create a queue q and a map vis to keep track of visited elements. Initialize the map with the starting element p as visited. Create a vector d of length n initialized to -1 which will be used to store the minimum number of reverse operations needed for each index in the sequence a. Create two sets vs[0] and vs[1] and initialize them with indices of even and odd positions respectively in the sequence a. Remove the indices of elements in the sequence b from their corresponding sets.\\n\\nNow, while the queue q is not empty, perform the following operations:\\n\\nRemove the front element from the queue and set the minimum number of reverse operations needed for that index in d to the current distance dis.\\nCompute the indices mn and mx such that the subsequence of a starting from index mn and ending at index mx contains k elements including the element at index p.\\nFor each index j in the set vs[p % 2] (i.e. the set of indices with the same parity as p), such that j is between mn and mx and (mx + ((j-p)/2)) < n, do the following:\\nIf j is not visited, mark it as visited and push it to the queue. Also, add it to a vector v.\\nFor each element in the vector v, remove the index from the set vs[j%2].\\nIncrement the distance dis.\\nFinally, return the vector d which contains the minimum number of reverse operations needed for each index in the sequence a.\\n\\n# Complexity\\n\\n- Time complexity:\\nThe time complexity of the above solution is O(n log n) where n is the length of the sequence a. The for loop in the beginning has a time complexity of O(n log n) because it uses set data structure which takes log n time for insertion of each element. The while loop has a time complexity of O(n) because each index in the sequence a is visited only once. The inner for loop has a time complexity of O(log n) because the set data structure is used again. Therefore, the overall time complexity is O(n log n).\\n\\n- Space complexity:\\nThe space complexity of the above solution is O(n) where n is the length of the sequence a. The set and vector data structures used in the solution have a space complexity of O(n). The queue and map data structures used in the solution have a space complexity of O(w) where w is the maximum width of the tree during BFS. In the worst case, the maximum width of the tree is n/2 (when k is 2 and p is 0 or 1) which gives a space complexity of O(n). Therefore, the overall space complexity is O(n).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> minReverseOperations(int n, int p, vector<int>& b, int k) {\\n        // Initialize an array d to store the minimum number of reverse operations needed to sort the array.\\n        vector<int> d(n,-1);\\n        // Initialize a set s to store the values in the array b.\\n        set<int> s;\\n        for(int i : b) s.insert(i);\\n        // Initialize a queue q to perform BFS.\\n        queue<int> q;\\n        // Initialize a map vis to store the visited nodes.\\n        map<int,bool> vis;\\n        // Mark the starting node as visited.\\n        vis[p] = true;\\n        // Push the starting node into the queue.\\n        q.push(p);\\n        // Initialize a variable dis to store the current distance.\\n        int dis = 0;\\n        // Initialize a vector of sets vs to store the indices of odd and even numbers.\\n        vector<set<int>> vs(2);\\n        for(int i = 0; i < n; i++) {\\n            vs[i % 2].insert(i);\\n        }\\n        // Remove the elements from the set that appear in the array b.\\n        for(int j : b) {\\n            vs[j % 2].erase(j);\\n        }\\n        // Remove the starting node from the set.\\n        vs[p % 2].erase(p);\\n        // Perform BFS.\\n        while(!q.empty()) {\\n            int sz = q.size();\\n            while(sz--) {\\n                // Pop the front node from the queue.\\n                int a = q.front();\\n                q.pop();\\n                // Set the distance of the current node.\\n                d[a] = dis;\\n                // Calculate the range of the current node.\\n                int mn = max(0, a - k + 1);\\n                int y = a - mn;\\n                int j = mn + (k - 1 - y);\\n                int p = j;\\n                // Initialize a vector v to store the children of the current node.\\n                vector<int> v;\\n                int mx = mn + k - 1;\\n                // Traverse the set to find the children of the current node.\\n                for(auto k1 = vs[j % 2].lower_bound(j); k1 != vs[j % 2].end() && *k1 <= (a + k - 1) && (mx + ((*k1 - p) / 2) < n); k1++) {\\n                    // If the child node is not visited, mark it as visited and push it into the queue and the vector v.\\n                    if(vis[*k1] == false) {\\n                        vis[*k1] = true;\\n                        q.push(*k1);\\n                        v.push_back(*k1);\\n                    }\\n                }\\n                // Remove the children from the set.\\n                for(int i : v) {\\n                    vs[i % 2].erase(i);\\n                }\\n            }\\n            // Increment the distance.\\n            dis++;\\n        }\\n        // Return the array d.\\n        return d;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minReverseOperations(int n, int p, vector<int>& b, int k) {\\n        // Initialize an array d to store the minimum number of reverse operations needed to sort the array.\\n        vector<int> d(n,-1);\\n        // Initialize a set s to store the values in the array b.\\n        set<int> s;\\n        for(int i : b) s.insert(i);\\n        // Initialize a queue q to perform BFS.\\n        queue<int> q;\\n        // Initialize a map vis to store the visited nodes.\\n        map<int,bool> vis;\\n        // Mark the starting node as visited.\\n        vis[p] = true;\\n        // Push the starting node into the queue.\\n        q.push(p);\\n        // Initialize a variable dis to store the current distance.\\n        int dis = 0;\\n        // Initialize a vector of sets vs to store the indices of odd and even numbers.\\n        vector<set<int>> vs(2);\\n        for(int i = 0; i < n; i++) {\\n            vs[i % 2].insert(i);\\n        }\\n        // Remove the elements from the set that appear in the array b.\\n        for(int j : b) {\\n            vs[j % 2].erase(j);\\n        }\\n        // Remove the starting node from the set.\\n        vs[p % 2].erase(p);\\n        // Perform BFS.\\n        while(!q.empty()) {\\n            int sz = q.size();\\n            while(sz--) {\\n                // Pop the front node from the queue.\\n                int a = q.front();\\n                q.pop();\\n                // Set the distance of the current node.\\n                d[a] = dis;\\n                // Calculate the range of the current node.\\n                int mn = max(0, a - k + 1);\\n                int y = a - mn;\\n                int j = mn + (k - 1 - y);\\n                int p = j;\\n                // Initialize a vector v to store the children of the current node.\\n                vector<int> v;\\n                int mx = mn + k - 1;\\n                // Traverse the set to find the children of the current node.\\n                for(auto k1 = vs[j % 2].lower_bound(j); k1 != vs[j % 2].end() && *k1 <= (a + k - 1) && (mx + ((*k1 - p) / 2) < n); k1++) {\\n                    // If the child node is not visited, mark it as visited and push it into the queue and the vector v.\\n                    if(vis[*k1] == false) {\\n                        vis[*k1] = true;\\n                        q.push(*k1);\\n                        v.push_back(*k1);\\n                    }\\n                }\\n                // Remove the children from the set.\\n                for(int i : v) {\\n                    vs[i % 2].erase(i);\\n                }\\n            }\\n            // Increment the distance.\\n            dis++;\\n        }\\n        // Return the array d.\\n        return d;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434869,
                "title": "all-about-ds-optimisations",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {\\n        set<int> avail[2];\\n        for(int i = 0; i < n; i++){\\n            avail[i%2].insert(i);\\n        }\\n        for(int x: banned) avail[x%2].erase(x);\\n        vector<int> ans(n, -1);\\n        ans[p] = 0;\\n        queue<int> q;\\n        q.push(p);\\n        avail[p%2].erase(p);\\n        int x, d, s, e, i;\\n        set<int>:: iterator it, is, ie;\\n        while(!q.empty()){\\n            x = q.front();\\n            q.pop();\\n            d = ans[x] + 1;\\n            s = max(x - k + 1, k - x - 1);\\n            e = min(x + k - 1, 2*n - k - x);\\n            i = s%2;\\n            it = avail[i].lower_bound(s);\\n            is = it;\\n            ie = avail[i].end();\\n            while(it != avail[i].end()){\\n                if(*it > e) {\\n                    ie = it;\\n                    break;\\n                }\\n                q.push(*it);\\n                ans[*it] = d;\\n                it++;\\n            }\\n            avail[i].erase(is, ie);  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {\\n        set<int> avail[2];\\n        for(int i = 0; i < n; i++){\\n            avail[i%2].insert(i);\\n        }\\n        for(int x: banned) avail[x%2].erase(x);\\n        vector<int> ans(n, -1);\\n        ans[p] = 0;\\n        queue<int> q;\\n        q.push(p);\\n        avail[p%2].erase(p);\\n        int x, d, s, e, i;\\n        set<int>:: iterator it, is, ie;\\n        while(!q.empty()){\\n            x = q.front();\\n            q.pop();\\n            d = ans[x] + 1;\\n            s = max(x - k + 1, k - x - 1);\\n            e = min(x + k - 1, 2*n - k - x);\\n            i = s%2;\\n            it = avail[i].lower_bound(s);\\n            is = it;\\n            ie = avail[i].end();\\n            while(it != avail[i].end()){\\n                if(*it > e) {\\n                    ie = it;\\n                    break;\\n                }\\n                q.push(*it);\\n                ans[*it] = d;\\n                it++;\\n            }\\n            avail[i].erase(is, ie);  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427442,
                "title": "python-simple-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minReverseOperations(self, n, p, banned, k):\\n        from sortedcontainers import SortedList\\n\\n        remaining = [SortedList(),SortedList()]\\n        banned = set(banned)\\n\\n        for i in range(n):\\n            if i!=p and i not in banned:\\n                remaining[i&1].add(i)\\n\\n        stack = [p]\\n        dist = [-1]*n\\n        dist[p] = 0\\n\\n        while stack:\\n            node = stack.pop(0)\\n            lo = max(node-k+1,0)\\n            lo = 2*lo + k - 1 - node\\n            hi = min(node+k-1,n-1) - (k-1)\\n            hi = 2*hi + k - 1 - node\\n            for neighbor in list(remaining[lo%2].irange(lo,hi)):\\n                stack.append(neighbor)\\n                dist[neighbor] = dist[node] + 1\\n                remaining[lo%2].remove(neighbor)\\n\\n        return dist\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n        \\n        \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minReverseOperations(self, n, p, banned, k):\\n        from sortedcontainers import SortedList\\n\\n        remaining = [SortedList(),SortedList()]\\n        banned = set(banned)\\n\\n        for i in range(n):\\n            if i!=p and i not in banned:\\n                remaining[i&1].add(i)\\n\\n        stack = [p]\\n        dist = [-1]*n\\n        dist[p] = 0\\n\\n        while stack:\\n            node = stack.pop(0)\\n            lo = max(node-k+1,0)\\n            lo = 2*lo + k - 1 - node\\n            hi = min(node+k-1,n-1) - (k-1)\\n            hi = 2*hi + k - 1 - node\\n            for neighbor in list(remaining[lo%2].irange(lo,hi)):\\n                stack.append(neighbor)\\n                dist[neighbor] = dist[node] + 1\\n                remaining[lo%2].remove(neighbor)\\n\\n        return dist\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n        \\n        \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421277,
                "title": "bfs-and-treeset-based-solution-o-n-time-o-n-space-easy-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can use a breadth-first search (BFS) approach to solve this problem. Since we are allowed to perform multiple reverse operations of size k, we will use BFS to find the minimum number of operations needed to reach each index i, starting from the index p. We will maintain a TreeSet of available even and odd positions to facilitate searching for the next index to reverse to.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize the \\'arr\\' to hold the results for each index, initially filled with -2.\\n1. Set the positions specified in the \\'banned\\' array to -1 and the position p to 0.\\n1. Create a Queue \\'q\\' to perform BFS and add the starting position \\'p\\'.\\n1. Create TreeSets \\'odd\\' and \\'even\\' to store the available odd and even positions.\\n1. Perform BFS using the queue \\'q\\' to find the minimum number of reverse operations for each index.\\n1. After BFS is complete, set any index i with a value of -2 in the \\'arr\\' to -1, as it is impossible to reach that position.\\n# Complexity\\n- Time complexity: O(n) - where n is the length of the input array \\'nums\\'.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) - since we store the input elements in the TreeSet, Queue and the result array \\'arr\\'.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] minReverseOperations(int n, int p, int[] banned, int k) {\\n         // Step 1: Initialize the \\'arr\\' to hold the results for each index, initially filled with -2\\n    int[] arr = new int[n];\\n    for (int i = 0; i < n; i++) {\\n        arr[i] = -2;\\n    }\\n\\n    // Step 2: Set the positions specified in the \\'banned\\' array to -1 and the position p to 0\\n    for (int num : banned) {\\n        arr[num] = -1;\\n    }\\n    arr[p] = 0;\\n\\n    // Step 3: Create a Queue \\'q\\' to perform BFS and add the starting position \\'p\\'\\n    Queue<Integer> q = new LinkedList<>();\\n    q.add(p);\\n\\n    // Step 4: Create TreeSets \\'odd\\' and \\'even\\' to store the available odd and even positions\\n    TreeSet<Integer> odd = new TreeSet<>();\\n    TreeSet<Integer> even = new TreeSet<>();\\n    for (int i = 0; i < n; i++) {\\n        if (arr[i] == -2) {\\n            if (i % 2 == 0) {\\n                even.add(i);\\n            } else {\\n                odd.add(i);\\n            }\\n        }\\n    }\\n\\n    // Step 5: Perform BFS using the queue \\'q\\' to find the minimum number of reverse operations for each index\\n        \\n        while (!q.isEmpty()) {\\n            int origin = q.remove();\\n            int min = 0;\\n            if (origin < k - 1) {\\n                min = k - 1 -origin;\\n            } else {\\n                min = origin - k + 1;\\n            }\\n            \\n            int max = 0;\\n            int rightDistance = n - 1 - origin;\\n            if (rightDistance < k - 1) {\\n                max = k - 1 - rightDistance;\\n            } else {\\n                max = rightDistance - k + 1;\\n            }\\n            max = n - 1 - max;\\n        \\n            TreeSet<Integer> set = max % 2 == 0 ? even : odd;\\n            Integer next = set.ceiling(min);\\n            while (next != null && next <= max) {\\n                arr[next] = arr[origin] + 1;\\n                q.add(next);\\n                set.remove(next);\\n                next = set.ceiling(min);\\n            }\\n        }\\n// Step 6: After BFS is complete, set any index i with a value of -2 in the \\'arr\\' to -1\\n        for (int i = 0; i < n; i++) {\\n            if (arr[i] == -2) {\\n                arr[i] = -1;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] minReverseOperations(int n, int p, int[] banned, int k) {\\n         // Step 1: Initialize the \\'arr\\' to hold the results for each index, initially filled with -2\\n    int[] arr = new int[n];\\n    for (int i = 0; i < n; i++) {\\n        arr[i] = -2;\\n    }\\n\\n    // Step 2: Set the positions specified in the \\'banned\\' array to -1 and the position p to 0\\n    for (int num : banned) {\\n        arr[num] = -1;\\n    }\\n    arr[p] = 0;\\n\\n    // Step 3: Create a Queue \\'q\\' to perform BFS and add the starting position \\'p\\'\\n    Queue<Integer> q = new LinkedList<>();\\n    q.add(p);\\n\\n    // Step 4: Create TreeSets \\'odd\\' and \\'even\\' to store the available odd and even positions\\n    TreeSet<Integer> odd = new TreeSet<>();\\n    TreeSet<Integer> even = new TreeSet<>();\\n    for (int i = 0; i < n; i++) {\\n        if (arr[i] == -2) {\\n            if (i % 2 == 0) {\\n                even.add(i);\\n            } else {\\n                odd.add(i);\\n            }\\n        }\\n    }\\n\\n    // Step 5: Perform BFS using the queue \\'q\\' to find the minimum number of reverse operations for each index\\n        \\n        while (!q.isEmpty()) {\\n            int origin = q.remove();\\n            int min = 0;\\n            if (origin < k - 1) {\\n                min = k - 1 -origin;\\n            } else {\\n                min = origin - k + 1;\\n            }\\n            \\n            int max = 0;\\n            int rightDistance = n - 1 - origin;\\n            if (rightDistance < k - 1) {\\n                max = k - 1 - rightDistance;\\n            } else {\\n                max = rightDistance - k + 1;\\n            }\\n            max = n - 1 - max;\\n        \\n            TreeSet<Integer> set = max % 2 == 0 ? even : odd;\\n            Integer next = set.ceiling(min);\\n            while (next != null && next <= max) {\\n                arr[next] = arr[origin] + 1;\\n                q.add(next);\\n                set.remove(next);\\n                next = set.ceiling(min);\\n            }\\n        }\\n// Step 6: After BFS is complete, set any index i with a value of -2 in the \\'arr\\' to -1\\n        for (int i = 0; i < n; i++) {\\n            if (arr[i] == -2) {\\n                arr[i] = -1;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418847,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] minReverseOperations(int n, int p, int[] banned, int k) {\\n        TreeSet<Integer> even = new TreeSet<>();\\n        TreeSet<Integer> odd = new TreeSet<>();\\n        \\n        TreeSet<Integer> set;\\n        \\n        boolean [] skip = new boolean [n];\\n        \\n        for (int num : banned) {\\n            skip[num] = true;\\n        }\\n        \\n        int start = p;\\n        \\n        // Add values to the set that are not banned\\n        for (int i = 0; i < n; ++i) {\\n            if (skip[i] || i == p)\\n                continue;\\n            \\n            if (i % 2 == 1)\\n                odd.add(i);\\n            else\\n                even.add(i);\\n        }\\n        \\n        int [] result = new int [n];\\n        Arrays.fill(result, -1);\\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(p);\\n        \\n        int size;\\n        int current;\\n        int moves = 0;\\n        \\n        int min, max;\\n        \\n        Integer key;\\n        \\n        int mCurrent;\\n        \\n        while (!queue.isEmpty()) {\\n            size = queue.size();\\n            \\n            \\n            while (size-- > 0) {\\n                current = queue.remove();\\n                \\n                result[current] = moves;\\n                \\n                \\n                // calculate min index\\n                if (current < k - 1) {\\n                    min = (k - 1) - current;\\n                }else {\\n                    min = current - k + 1;\\n                }\\n                \\n                // calculate max index\\n                mCurrent = (n - 1) - current;\\n                if (mCurrent < k - 1) {\\n                    max = (k - 1) - mCurrent;\\n                }else {\\n                    max = mCurrent - k + 1;\\n                }\\n                max = (n - 1) - max;\\n                \\n                \\n                // chose the correct parity set\\n                set = min % 2 == 0 ? even : odd;\\n                \\n                key = set.ceiling(min);\\n                \\n                // add all values in range to the queue and remove from set\\n                while (key != null && key <= max) {\\n                    queue.add(key);\\n                    set.remove(key);\\n                    key = set.ceiling(min);\\n                }\\n            }\\n            \\n            ++moves;\\n        }\\n        \\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] minReverseOperations(int n, int p, int[] banned, int k) {\\n        TreeSet<Integer> even = new TreeSet<>();\\n        TreeSet<Integer> odd = new TreeSet<>();\\n        \\n        TreeSet<Integer> set;\\n        \\n        boolean [] skip = new boolean [n];\\n        \\n        for (int num : banned) {\\n            skip[num] = true;\\n        }\\n        \\n        int start = p;\\n        \\n        // Add values to the set that are not banned\\n        for (int i = 0; i < n; ++i) {\\n            if (skip[i] || i == p)\\n                continue;\\n            \\n            if (i % 2 == 1)\\n                odd.add(i);\\n            else\\n                even.add(i);\\n        }\\n        \\n        int [] result = new int [n];\\n        Arrays.fill(result, -1);\\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(p);\\n        \\n        int size;\\n        int current;\\n        int moves = 0;\\n        \\n        int min, max;\\n        \\n        Integer key;\\n        \\n        int mCurrent;\\n        \\n        while (!queue.isEmpty()) {\\n            size = queue.size();\\n            \\n            \\n            while (size-- > 0) {\\n                current = queue.remove();\\n                \\n                result[current] = moves;\\n                \\n                \\n                // calculate min index\\n                if (current < k - 1) {\\n                    min = (k - 1) - current;\\n                }else {\\n                    min = current - k + 1;\\n                }\\n                \\n                // calculate max index\\n                mCurrent = (n - 1) - current;\\n                if (mCurrent < k - 1) {\\n                    max = (k - 1) - mCurrent;\\n                }else {\\n                    max = mCurrent - k + 1;\\n                }\\n                max = (n - 1) - max;\\n                \\n                \\n                // chose the correct parity set\\n                set = min % 2 == 0 ? even : odd;\\n                \\n                key = set.ceiling(min);\\n                \\n                // add all values in range to the queue and remove from set\\n                while (key != null && key <= max) {\\n                    queue.add(key);\\n                    set.remove(key);\\n                    key = set.ceiling(min);\\n                }\\n            }\\n            \\n            ++moves;\\n        }\\n        \\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3390822,
                "title": "wc339-4",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    int[] ans;\\n\\n    public void calcOper(int n, int sp, int fp, int k) {\\n        int finish = fp + k;\\n        int curStep = ans[sp];\\n        if (finish > n) {\\n            for (int i = fp; i >= sp; i -= 2) {\\n                if (ans[i] == curStep) {\\n                    if (i <= n - k) {\\n                        if (i+k>finish) finish = i + k;\\n                        break;\\n                    } else {\\n                        finish = 2 * n - i - k;\\n                        if (finish==n) break;\\n                    }\\n                }\\n            }\\n        }\\n        int start = sp - k + 1;\\n        if (start < 0) {\\n            for (int i = sp; i <= fp; i += 2) {\\n                if (ans[i] == curStep) {\\n                    if (i >= k - 1) {\\n                        if (i - k + 1 < start) start = i - k + 1;\\n                        break;\\n                    } else {\\n                        start = k - 1 - i;\\n                        if (start == 0) break;\\n                    }\\n                }\\n            }\\n        }\\n        curStep++;\\n        int nextSp = -1;\\n        int nextFp = 0;\\n        for (int i = start; i < finish; i += 2) {\\n            if (ans[i] == -2) {\\n                ans[i] = curStep;\\n                if (nextSp == -1) {\\n                    nextFp = nextSp = i;\\n                } else nextFp = i;\\n            }\\n        }\\n        if (nextSp != -1) calcOper(n, nextSp, nextFp, k);\\n    }\\n\\n    public int[] minReverseOperations(int n, int p, int[] banned, int k) {\\n        ans = new int[n];\\n        for (int i = 0; i < n; i++) ans[i] = -2;\\n        for (int i : banned) ans[i] = -1;\\n        ans[p] = 0;\\n        if (k == 2) {\\n            for (int i = p + 1, j = 1; i < n; i++) {\\n                if (ans[i] == -1) break;\\n                else {\\n                    ans[i] = j++;\\n                }\\n            }\\n            for (int i = p - 1, j = 1; i >= 0; i--) {\\n                if (ans[i] == -1) break;\\n                else {\\n                    ans[i] = j++;\\n                }\\n            }\\n        } else if (k != 1) {\\n            calcOper(n, p, p, k);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (ans[i] == -2) ans[i]++;\\n        }\\n        return ans;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    int[] ans;\\n\\n    public void calcOper(int n, int sp, int fp, int k) {\\n        int finish = fp + k;\\n        int curStep = ans[sp];\\n        if (finish > n) {\\n            for (int i = fp; i >= sp; i -= 2) {\\n                if (ans[i] == curStep) {\\n                    if (i <= n - k) {\\n                        if (i+k>finish) finish = i + k;\\n                        break;\\n                    } else {\\n                        finish = 2 * n - i - k;\\n                        if (finish==n) break;\\n                    }\\n                }\\n            }\\n        }\\n        int start = sp - k + 1;\\n        if (start < 0) {\\n            for (int i = sp; i <= fp; i += 2) {\\n                if (ans[i] == curStep) {\\n                    if (i >= k - 1) {\\n                        if (i - k + 1 < start) start = i - k + 1;\\n                        break;\\n                    } else {\\n                        start = k - 1 - i;\\n                        if (start == 0) break;\\n                    }\\n                }\\n            }\\n        }\\n        curStep++;\\n        int nextSp = -1;\\n        int nextFp = 0;\\n        for (int i = start; i < finish; i += 2) {\\n            if (ans[i] == -2) {\\n                ans[i] = curStep;\\n                if (nextSp == -1) {\\n                    nextFp = nextSp = i;\\n                } else nextFp = i;\\n            }\\n        }\\n        if (nextSp != -1) calcOper(n, nextSp, nextFp, k);\\n    }\\n\\n    public int[] minReverseOperations(int n, int p, int[] banned, int k) {\\n        ans = new int[n];\\n        for (int i = 0; i < n; i++) ans[i] = -2;\\n        for (int i : banned) ans[i] = -1;\\n        ans[p] = 0;\\n        if (k == 2) {\\n            for (int i = p + 1, j = 1; i < n; i++) {\\n                if (ans[i] == -1) break;\\n                else {\\n                    ans[i] = j++;\\n                }\\n            }\\n            for (int i = p - 1, j = 1; i >= 0; i--) {\\n                if (ans[i] == -1) break;\\n                else {\\n                    ans[i] = j++;\\n                }\\n            }\\n        } else if (k != 1) {\\n            calcOper(n, p, p, k);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (ans[i] == -2) ans[i]++;\\n        }\\n        return ans;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389204,
                "title": "c-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nC : cheked position\\n0 : not cheked yet\\nX : current position\\n\\noveral status shape would be below.\\n\\n0 0 0 C C C C 0 0 0 X 0 0 0 C C C C 0 0 0 0 0 \\n\\nin this case, I can check for new positions from X like below.\\n\\n---> CCCC <--- X ---> CCCCC <---\\n\\n** four directions\\n** if meet checked postion then break\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:        \\n    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {        \\n        vector<int> ans(n, -1);        \\n        ans[p] = 0;\\n        if(k == 1) return ans;\\n\\n        vector<char>visit(n, 0);\\n        vector<char>ban(n, 0);        \\n        queue<int> Q;\\n\\n        for(int num : banned) ban[num] = 1;\\n        visit[p] = 1;\\n        Q.push(p);\\n        int cur;\\n        int s, e, loc;\\n        while(!Q.empty()) {            \\n            cur = Q.front();\\n            Q.pop();\\n\\n            // right, outside -> inside\\n            s = cur;\\n            e = cur + k - 1;\\n            if(e >= n) {\\n                s -= e - n + 1;\\n                e = n - 1;                \\n            }\\n          \\n            while(s >= 0 && cur - s < e - cur) {\\n                loc = e + s - cur;                \\n                if(ban[loc]) {\\n                    --s, --e;\\n                    continue;\\n                }                \\n                if(visit[loc]) break;                \\n                visit[loc] = 1;\\n                ans[loc] = ans[cur] + 1;\\n                Q.push(loc);\\n                --s, --e;\\n            }\\n\\n            // left, outside -> inside\\n            s = cur - k + 1;\\n            e = cur;\\n            if(s < 0) {\\n                e -= s;\\n                s = 0;\\n            }\\n\\n            while(e < n && cur - s > e - cur) {\\n                loc = e + s - cur;\\n                if(ban[loc]) {\\n                    ++s, ++e;\\n                    continue;\\n                }            \\n                if(visit[loc]) break;\\n                visit[loc] = 1;\\n                ans[loc] = ans[cur] + 1;\\n                Q.push(loc);\\n                ++s, ++e;\\n            }\\n\\n            // right, inside -> outside\\n            s = cur - (k - 1) / 2;\\n            e = cur + k / 2;\\n            if(k&1) {\\n                ++s, ++e;\\n            }\\n            \\n            if(e >= n) {\\n                s -= e - n + 1;\\n                e = n - 1;                \\n            }\\n            if(s < 0) {\\n                e -= s;\\n                s = 0;\\n            }\\n\\n           \\n            while(s <= cur && e < n && cur - s < e - cur) {\\n                loc = e + s - cur;                \\n                if(ban[loc]) {\\n                    ++s, ++e;\\n                    continue;\\n                }                \\n                if(visit[loc]) break;                \\n                visit[loc] = 1;\\n                ans[loc] = ans[cur] + 1;\\n                Q.push(loc);\\n                ++s, ++e;\\n            }\\n\\n            // left, inside -> outside\\n            s = cur - (k - 1) / 2 - 1;\\n            e = cur + k / 2 - 1;\\n            if(e >= n) {\\n                s -= e - n + 1;\\n                e = n - 1;                \\n            }\\n            if(s < 0) {\\n                e -= s;\\n                s = 0;\\n            }\\n\\n            while(e >= cur && s >= 0 && cur - s > e - cur) {\\n                loc = e + s - cur;\\n                if(ban[loc]) {\\n                    --s, --e;\\n                    continue;\\n                }            \\n                if(visit[loc]) break;\\n                visit[loc] = 1;\\n                ans[loc] = ans[cur] + 1;\\n                Q.push(loc);\\n                --s, --e;\\n            }\\n        }\\n\\n        return ans;\\n    }       \\n};\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:        \\n    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {        \\n        vector<int> ans(n, -1);        \\n        ans[p] = 0;\\n        if(k == 1) return ans;\\n\\n        vector<char>visit(n, 0);\\n        vector<char>ban(n, 0);        \\n        queue<int> Q;\\n\\n        for(int num : banned) ban[num] = 1;\\n        visit[p] = 1;\\n        Q.push(p);\\n        int cur;\\n        int s, e, loc;\\n        while(!Q.empty()) {            \\n            cur = Q.front();\\n            Q.pop();\\n\\n            // right, outside -> inside\\n            s = cur;\\n            e = cur + k - 1;\\n            if(e >= n) {\\n                s -= e - n + 1;\\n                e = n - 1;                \\n            }\\n          \\n            while(s >= 0 && cur - s < e - cur) {\\n                loc = e + s - cur;                \\n                if(ban[loc]) {\\n                    --s, --e;\\n                    continue;\\n                }                \\n                if(visit[loc]) break;                \\n                visit[loc] = 1;\\n                ans[loc] = ans[cur] + 1;\\n                Q.push(loc);\\n                --s, --e;\\n            }\\n\\n            // left, outside -> inside\\n            s = cur - k + 1;\\n            e = cur;\\n            if(s < 0) {\\n                e -= s;\\n                s = 0;\\n            }\\n\\n            while(e < n && cur - s > e - cur) {\\n                loc = e + s - cur;\\n                if(ban[loc]) {\\n                    ++s, ++e;\\n                    continue;\\n                }            \\n                if(visit[loc]) break;\\n                visit[loc] = 1;\\n                ans[loc] = ans[cur] + 1;\\n                Q.push(loc);\\n                ++s, ++e;\\n            }\\n\\n            // right, inside -> outside\\n            s = cur - (k - 1) / 2;\\n            e = cur + k / 2;\\n            if(k&1) {\\n                ++s, ++e;\\n            }\\n            \\n            if(e >= n) {\\n                s -= e - n + 1;\\n                e = n - 1;                \\n            }\\n            if(s < 0) {\\n                e -= s;\\n                s = 0;\\n            }\\n\\n           \\n            while(s <= cur && e < n && cur - s < e - cur) {\\n                loc = e + s - cur;                \\n                if(ban[loc]) {\\n                    ++s, ++e;\\n                    continue;\\n                }                \\n                if(visit[loc]) break;                \\n                visit[loc] = 1;\\n                ans[loc] = ans[cur] + 1;\\n                Q.push(loc);\\n                ++s, ++e;\\n            }\\n\\n            // left, inside -> outside\\n            s = cur - (k - 1) / 2 - 1;\\n            e = cur + k / 2 - 1;\\n            if(e >= n) {\\n                s -= e - n + 1;\\n                e = n - 1;                \\n            }\\n            if(s < 0) {\\n                e -= s;\\n                s = 0;\\n            }\\n\\n            while(e >= cur && s >= 0 && cur - s > e - cur) {\\n                loc = e + s - cur;\\n                if(ban[loc]) {\\n                    --s, --e;\\n                    continue;\\n                }            \\n                if(visit[loc]) break;\\n                visit[loc] = 1;\\n                ans[loc] = ans[cur] + 1;\\n                Q.push(loc);\\n                --s, --e;\\n            }\\n        }\\n\\n        return ans;\\n    }       \\n};\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387715,
                "title": "2612-minimum-reverse-operations",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {\\n    const unordered_set<int> bannedSet{begin(banned), end(banned)};\\n    vector<int> ans(n, -1);\\n    // unseen[i] := unseen nums that are % 2 == i\\n    vector<set<int>> unseen(2);\\n\\n    for (int num = 0; num < n; ++num)\\n      if (num != p && !bannedSet.count(num))\\n        unseen[num & 1].insert(num);\\n\\n    // Perform BFS from `p`.\\n    queue<int> q{{p}};\\n    ans[p] = 0;\\n\\n    while (!q.empty()) {\\n      const int u = q.front();\\n      q.pop();\\n      const int lo = max(u - k + 1, k - 1 - u);\\n      const int hi = min(u + k - 1, n - 1 - (u - (n - k)));\\n      // Choose the correct set of nums.\\n      set<int>& nums = unseen[lo & 1];\\n      for (auto it = nums.lower_bound(lo); it != end(nums) && *it <= hi;) {\\n        ans[*it] = ans[u] + 1;\\n        q.push(*it);\\n        it = nums.erase(it);\\n      }\\n    }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {\\n    const unordered_set<int> bannedSet{begin(banned), end(banned)};\\n    vector<int> ans(n, -1);\\n    // unseen[i] := unseen nums that are % 2 == i\\n    vector<set<int>> unseen(2);\\n\\n    for (int num = 0; num < n; ++num)\\n      if (num != p && !bannedSet.count(num))\\n        unseen[num & 1].insert(num);\\n\\n    // Perform BFS from `p`.\\n    queue<int> q{{p}};\\n    ans[p] = 0;\\n\\n    while (!q.empty()) {\\n      const int u = q.front();\\n      q.pop();\\n      const int lo = max(u - k + 1, k - 1 - u);\\n      const int hi = min(u + k - 1, n - 1 - (u - (n - k)));\\n      // Choose the correct set of nums.\\n      set<int>& nums = unseen[lo & 1];\\n      for (auto it = nums.lower_bound(lo); it != end(nums) && *it <= hi;) {\\n        ans[*it] = ans[u] + 1;\\n        q.push(*it);\\n        it = nums.erase(it);\\n      }\\n    }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387200,
                "title": "dsu-bfs-and-easy-maths-explained-in-my-best-way-beats-96",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPropagating in a BFS fashion to get minimum distance from source \\'P\\' to every other index of the array, and using DSU to skip visited node which is the greatest optimization in our code. Why BFS? Why DSU? go through my approach I have tried my best to explain every critical step of the code. I have also explained the mathematics of finding range [l,r] this code in easiest way.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI have commented out the approach in the every step of the code\\nGo through the comments line by line. Don\\'t worry if you dont\\'t understand any particular step read the whole code maybe the thing which you didn\\'t understand becomes understandable after reading the whole code.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\nint even[100100];\\nint odd[100100];\\n\\n//Creating DSU parent finding function for Odd and Even array\\n\\nint even_par(int i){\\n    if(i==even[i])\\n    return i;\\n    \\n    return even[i]=even_par(even[i]);\\n}\\nint odd_par(int i){\\n    if(i==odd[i])\\n    return i;\\n\\n    return odd[i]=odd_par(odd[i]);\\n}\\n\\n vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {\\n\\n        vector<int>ans(n,-1);\\n//storing parent of every index,in the beginning every element \\n//will be parent of it self.\\n\\n//How and Why DSU? is explained at line no 84.\\n        for(int i=0;i<n+2;i++)\\n        even[i]=i,odd[i]=i;\\n\\n        for(auto i:banned){\\n            if(i&1)\\n            odd[i]=i+2;\\n            else even[i]=i+2;\\n        }\\n\\n     /*If any index is visited then we will skip this index and\\n     jump to +2 distance because we can only visit every second\\n     element in the range. \\n     This can get more clear if you draw a sliding window of size K\\n     and check the reversal operations, you will observe\\n     that every alternating position int the range[left,right] \\n     will differ by exactly 2.\\n        */\\n\\n\\n        if(p&1)odd[p]=p+2; //This line will get clear from the comment of line no 78-79.\\n        else even[p]=p+2;\\n\\n/*Propagating through the array in BFS style\\n will make us achieve the minimum distance from index \\'P\\'\\n to every other index*/\\n\\n    int dis=0;//Every level will define the minimum distance from source \\'P\\' to other vertices.\\n\\n    ans[p]=0; //Source will be at distance 0\\n    queue<int>q;\\n    q.push(p);\\n        \\n    while(!q.empty()){\\n        \\n        dis++;\\n        int sz=q.size();\\n\\n       for(int j=0;j<sz;j++){\\n            int curr=q.front();\\n            q.pop();\\n                \\n                int left=curr-k+1; //Left boundary from current index\\n\\n                /* If left boundary gets out of range, (left<0)\\n                Then bring it back to range by taking difference \\n                with the leftmost range(0) of the array\\n               \\'0-(curr-k+1)\\' */\\n\\n                if(left<0)\\n                left=k-curr-1;\\n\\n              \\n                int right=curr+k-1;//Right boundary from current index\\n\\n                 /* If right boundary gets out of range, (right>=n)\\n                Then bring it back to range by taking difference \\n                with the rightmost range(n) of the array\\n                n-((curr+k-1)-n) */\\n\\n                if(right>=n)\\n                right=n+n-k-curr-1;\\n\\n                /*From the observation we get if our left or right boundary lies on\\n                even/odd place then every position from [left,right] will lie on same parity\\n                as every next position is at +2 distance. \\n                */\\n\\n           if(left&1){\\n\\n>            /*For every index i we have found it\\'s left and right\\n             boundary now we will jump +2 steps from [left,right]\\n             and add the unvisited nodes/indexes into the BFS queue,\\n             inserting the visited node again and again will be of\\n             no help so, it will be better to skip it.\\n             And also traversing every index from [left,right] to \\n             check if it\\'s visited or not-visited will cost us linear\\n             time.\\n             Overall it will become a costly operation, but\\n             to skip the visited node in best time we can do this:\\n\\n           ->We know that every index/node is parent of itself.\\n\\n           -> To make sure we don\\'t visit the visited index again\\n             we will change/point the parent of the visited index \\'i\\'\\n             to its next index/child which is at +2 distance,\\n             this will skip the visited index visiting again in \\n             the next iteration. \\n             We can use Disjoint Set Union(DSU) Parent finding\\n             method to do this in in optimized way.\\n\\n           ->Initially every node is parent of itself.\\n             When we will visit any parent will change its parent\\n             to its next element(+2).\\n             So when next time we reach a visited index \\'i\\'\\n             it will skip us to it\\'s next unvisited child/index.\\n\\n           ->Doing this same thing for even case.\\n               */\\n\\n                for(int i=odd_par(left);i<=right;i=odd_par(i)){\\n                   ans[i]=dis;\\n                    odd[i]=i+2;\\n                    q.push(i);\\n                 }\\n           }else{\\n              for(int i=even_par(left);i<=right;i=even_par(i)){\\n                    ans[i]=dis;\\n                    even[i]=i+2;\\n                    q.push(i);\\n                 }\\n            }\\n       }\\n    }\\n       return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Union Find",
                    "Graph",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\nint even[100100];\\nint odd[100100];\\n\\n//Creating DSU parent finding function for Odd and Even array\\n\\nint even_par(int i){\\n    if(i==even[i])\\n    return i;\\n    \\n    return even[i]=even_par(even[i]);\\n}\\nint odd_par(int i){\\n    if(i==odd[i])\\n    return i;\\n\\n    return odd[i]=odd_par(odd[i]);\\n}\\n\\n vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {\\n\\n        vector<int>ans(n,-1);\\n//storing parent of every index,in the beginning every element \\n//will be parent of it self.\\n\\n//How and Why DSU? is explained at line no 84.\\n        for(int i=0;i<n+2;i++)\\n        even[i]=i,odd[i]=i;\\n\\n        for(auto i:banned){\\n            if(i&1)\\n            odd[i]=i+2;\\n            else even[i]=i+2;\\n        }\\n\\n     /*If any index is visited then we will skip this index and\\n     jump to +2 distance because we can only visit every second\\n     element in the range. \\n     This can get more clear if you draw a sliding window of size K\\n     and check the reversal operations, you will observe\\n     that every alternating position int the range[left,right] \\n     will differ by exactly 2.\\n        */\\n\\n\\n        if(p&1)odd[p]=p+2; //This line will get clear from the comment of line no 78-79.\\n        else even[p]=p+2;\\n\\n/*Propagating through the array in BFS style\\n will make us achieve the minimum distance from index \\'P\\'\\n to every other index*/\\n\\n    int dis=0;//Every level will define the minimum distance from source \\'P\\' to other vertices.\\n\\n    ans[p]=0; //Source will be at distance 0\\n    queue<int>q;\\n    q.push(p);\\n        \\n    while(!q.empty()){\\n        \\n        dis++;\\n        int sz=q.size();\\n\\n       for(int j=0;j<sz;j++){\\n            int curr=q.front();\\n            q.pop();\\n                \\n                int left=curr-k+1; //Left boundary from current index\\n\\n                /* If left boundary gets out of range, (left<0)\\n                Then bring it back to range by taking difference \\n                with the leftmost range(0) of the array\\n               \\'0-(curr-k+1)\\' */\\n\\n                if(left<0)\\n                left=k-curr-1;\\n\\n              \\n                int right=curr+k-1;//Right boundary from current index\\n\\n                 /* If right boundary gets out of range, (right>=n)\\n                Then bring it back to range by taking difference \\n                with the rightmost range(n) of the array\\n                n-((curr+k-1)-n) */\\n\\n                if(right>=n)\\n                right=n+n-k-curr-1;\\n\\n                /*From the observation we get if our left or right boundary lies on\\n                even/odd place then every position from [left,right] will lie on same parity\\n                as every next position is at +2 distance. \\n                */\\n\\n           if(left&1){\\n\\n>            /*For every index i we have found it\\'s left and right\\n             boundary now we will jump +2 steps from [left,right]\\n             and add the unvisited nodes/indexes into the BFS queue,\\n             inserting the visited node again and again will be of\\n             no help so, it will be better to skip it.\\n             And also traversing every index from [left,right] to \\n             check if it\\'s visited or not-visited will cost us linear\\n             time.\\n             Overall it will become a costly operation, but\\n             to skip the visited node in best time we can do this:\\n\\n           ->We know that every index/node is parent of itself.\\n\\n           -> To make sure we don\\'t visit the visited index again\\n             we will change/point the parent of the visited index \\'i\\'\\n             to its next index/child which is at +2 distance,\\n             this will skip the visited index visiting again in \\n             the next iteration. \\n             We can use Disjoint Set Union(DSU) Parent finding\\n             method to do this in in optimized way.\\n\\n           ->Initially every node is parent of itself.\\n             When we will visit any parent will change its parent\\n             to its next element(+2).\\n             So when next time we reach a visited index \\'i\\'\\n             it will skip us to it\\'s next unvisited child/index.\\n\\n           ->Doing this same thing for even case.\\n               */\\n\\n                for(int i=odd_par(left);i<=right;i=odd_par(i)){\\n                   ans[i]=dis;\\n                    odd[i]=i+2;\\n                    q.push(i);\\n                 }\\n           }else{\\n              for(int i=even_par(left);i<=right;i=even_par(i)){\\n                    ans[i]=dis;\\n                    even[i]=i+2;\\n                    q.push(i);\\n                 }\\n            }\\n       }\\n    }\\n       return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384082,
                "title": "python3-optimized-bfs-algorithm",
                "content": "\\n# Code\\n```\\nfrom bisect import bisect_left, bisect_right\\nfrom collections import deque\\n\\nclass Solution:\\n    def minReverseOperations(self, n, p, banned_vals, K):\\n        remaining = [[], []]\\n        banned = set(banned_vals)\\n        for u in range(n):\\n            if u != p and u not in banned:\\n                remaining[u & 1].append(u)\\n\\n        for i in range(2):\\n            remaining[i].sort()\\n\\n        queue = deque([p])\\n        dist = [-1] * n\\n        dist[p] = 0\\n        while queue:\\n            node = queue.popleft()\\n            lo = max(node - K + 1, 0)\\n            lo = 2 * lo + K - 1 - node\\n            hi = min(node + K - 1, n - 1) - (K - 1)\\n            hi = 2 * hi + K - 1 - node\\n\\n            idx_lo = bisect_left(remaining[lo % 2], lo)\\n            idx_hi = bisect_right(remaining[lo % 2], hi)\\n\\n            for idx in range(idx_lo, idx_hi):\\n                nei = remaining[lo % 2][idx]\\n                queue.append(nei)\\n                dist[nei] = dist[node] + 1\\n\\n            del remaining[lo % 2][idx_lo:idx_hi]\\n        \\n        return dist\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom bisect import bisect_left, bisect_right\\nfrom collections import deque\\n\\nclass Solution:\\n    def minReverseOperations(self, n, p, banned_vals, K):\\n        remaining = [[], []]\\n        banned = set(banned_vals)\\n        for u in range(n):\\n            if u != p and u not in banned:\\n                remaining[u & 1].append(u)\\n\\n        for i in range(2):\\n            remaining[i].sort()\\n\\n        queue = deque([p])\\n        dist = [-1] * n\\n        dist[p] = 0\\n        while queue:\\n            node = queue.popleft()\\n            lo = max(node - K + 1, 0)\\n            lo = 2 * lo + K - 1 - node\\n            hi = min(node + K - 1, n - 1) - (K - 1)\\n            hi = 2 * hi + K - 1 - node\\n\\n            idx_lo = bisect_left(remaining[lo % 2], lo)\\n            idx_hi = bisect_right(remaining[lo % 2], hi)\\n\\n            for idx in range(idx_lo, idx_hi):\\n                nei = remaining[lo % 2][idx]\\n                queue.append(nei)\\n                dist[nei] = dist[node] + 1\\n\\n            del remaining[lo % 2][idx_lo:idx_hi]\\n        \\n        return dist\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376308,
                "title": "c-beats-100",
                "content": "# Intuition\\nWhat an interesting challenge! I wonder why this task has such a low acceptance rate? (graph traversal)\\n\\n# Approach\\nPain (bfs).\\n\\n# Complexity\\n- Time complexity: Nerve cells. o(n * log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Tear Napkins. o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public int[] MinReverseOperations(int n, int p, int[] bannedVals, int K)\\n    {\\n        List<SortedSet<int>> remaining = new List<SortedSet<int>> { new SortedSet<int>(), new SortedSet<int>() };\\n        HashSet<int> banned = new HashSet<int>(bannedVals);\\n        for (int u = 0; u < n; u++)\\n        {\\n            if (u != p && !banned.Contains(u))\\n            {\\n                remaining[u & 1].Add(u);\\n            }\\n        }\\n\\n        Queue<int> queue = new Queue<int>();\\n        queue.Enqueue(p);\\n        int[] dist = new int[n];\\n        Array.Fill(dist, -1);\\n        dist[p] = 0;\\n\\n        while (queue.Count > 0)\\n        {\\n            int node = queue.Dequeue();\\n            int lo = Math.Max(node - K + 1, 0);\\n            lo = 2 * lo + K - 1 - node;\\n            int hi = Math.Min(node + K - 1, n - 1) - (K - 1);\\n            hi = 2 * hi + K - 1 - node;\\n\\n            List<int> toRemove = new List<int>();\\n            foreach (int nei in remaining[lo % 2].GetViewBetween(lo, hi))\\n            {\\n                queue.Enqueue(nei);\\n                dist[nei] = dist[node] + 1;\\n                toRemove.Add(nei);\\n            }\\n\\n            foreach (int nei in toRemove)\\n            {\\n                remaining[lo % 2].Remove(nei);\\n            }\\n        }\\n\\n        return dist;\\n    }\\n}\\n\\npublic static class SortedSetExtensions\\n{\\n    public static IEnumerable<T> GetViewBetween<T>(this SortedSet<T> set, T lowerValue, T upperValue) where T : IComparable<T>\\n    {\\n        if (set == null)\\n            throw new ArgumentNullException(nameof(set));\\n\\n        return set.GetViewBetween(new Range<T>(lowerValue, upperValue));\\n    }\\n    \\n    public static SortedSet<T> GetViewBetween<T>(this SortedSet<T> set, Range<T> range) where T : IComparable<T>\\n    {\\n        if (set == null)\\n            throw new ArgumentNullException(nameof(set));\\n\\n        return set.GetViewBetween(range.LowerValue, range.UpperValue);\\n    }\\n}\\n\\npublic readonly struct Range<T> where T : IComparable<T>\\n{\\n    public T LowerValue { get; }\\n    public T UpperValue { get; }\\n\\n    public Range(T lowerValue, T upperValue)\\n    {\\n        if (lowerValue.CompareTo(upperValue) > 0)\\n            throw new ArgumentException(\"Lower value must be less than or equal to the upper value.\");\\n\\n        LowerValue = lowerValue;\\n        UpperValue = upperValue;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int[] MinReverseOperations(int n, int p, int[] bannedVals, int K)\\n    {\\n        List<SortedSet<int>> remaining = new List<SortedSet<int>> { new SortedSet<int>(), new SortedSet<int>() };\\n        HashSet<int> banned = new HashSet<int>(bannedVals);\\n        for (int u = 0; u < n; u++)\\n        {\\n            if (u != p && !banned.Contains(u))\\n            {\\n                remaining[u & 1].Add(u);\\n            }\\n        }\\n\\n        Queue<int> queue = new Queue<int>();\\n        queue.Enqueue(p);\\n        int[] dist = new int[n];\\n        Array.Fill(dist, -1);\\n        dist[p] = 0;\\n\\n        while (queue.Count > 0)\\n        {\\n            int node = queue.Dequeue();\\n            int lo = Math.Max(node - K + 1, 0);\\n            lo = 2 * lo + K - 1 - node;\\n            int hi = Math.Min(node + K - 1, n - 1) - (K - 1);\\n            hi = 2 * hi + K - 1 - node;\\n\\n            List<int> toRemove = new List<int>();\\n            foreach (int nei in remaining[lo % 2].GetViewBetween(lo, hi))\\n            {\\n                queue.Enqueue(nei);\\n                dist[nei] = dist[node] + 1;\\n                toRemove.Add(nei);\\n            }\\n\\n            foreach (int nei in toRemove)\\n            {\\n                remaining[lo % 2].Remove(nei);\\n            }\\n        }\\n\\n        return dist;\\n    }\\n}\\n\\npublic static class SortedSetExtensions\\n{\\n    public static IEnumerable<T> GetViewBetween<T>(this SortedSet<T> set, T lowerValue, T upperValue) where T : IComparable<T>\\n    {\\n        if (set == null)\\n            throw new ArgumentNullException(nameof(set));\\n\\n        return set.GetViewBetween(new Range<T>(lowerValue, upperValue));\\n    }\\n    \\n    public static SortedSet<T> GetViewBetween<T>(this SortedSet<T> set, Range<T> range) where T : IComparable<T>\\n    {\\n        if (set == null)\\n            throw new ArgumentNullException(nameof(set));\\n\\n        return set.GetViewBetween(range.LowerValue, range.UpperValue);\\n    }\\n}\\n\\npublic readonly struct Range<T> where T : IComparable<T>\\n{\\n    public T LowerValue { get; }\\n    public T UpperValue { get; }\\n\\n    public Range(T lowerValue, T upperValue)\\n    {\\n        if (lowerValue.CompareTo(upperValue) > 0)\\n            throw new ArgumentException(\"Lower value must be less than or equal to the upper value.\");\\n\\n        LowerValue = lowerValue;\\n        UpperValue = upperValue;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372849,
                "title": "javascript-bfs-binary-search-5044ms",
                "content": "```\\n////////////////////////// Template ////////////////////////////////////\\nfunction Bisect() {\\n    return { insort_right, insort_left, bisect_left, bisect_right }\\n    function insort_right(a, x, lo = 0, hi = null) {\\n        lo = bisect_right(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_right(a, x, lo = 0, hi = null) { // > upper_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] > x ? hi = mid : lo = mid + 1;\\n        }\\n        return lo;\\n    }\\n    function insort_left(a, x, lo = 0, hi = null) {\\n        lo = bisect_left(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_left(a, x, lo = 0, hi = null) { // >= lower_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] < x ? lo = mid + 1 : hi = mid;\\n        }\\n        return lo;\\n    }\\n}\\n///////////////////////////////////////////////////////////////////\\n\\nconst minReverseOperations = (n, p, banned, k) => {\\n    let res = Array(n).fill(-1), evenOdd = [[], []], q = [p], bi = new Bisect();\\n    if (k == 1) {\\n        res[p] = 0;\\n        return res;\\n    }\\n    banned = new Set(banned);\\n    for (let i = 0; i < n; i++) {\\n        if (i != p && !banned.has(i)) evenOdd[i % 2].push(i);\\n    }\\n    res[p] = 0;\\n    while (q.length) {\\n        let cur = q.shift();\\n        let L = Math.max(-(k - 1), k - 1 - cur * 2), R = Math.min(k - 1, -(k - 1) + (n - cur - 1) * 2); // caculate the jump range\\n        let x = (cur + k - 1) % 2, idx = bi.bisect_left(evenOdd[x], cur + L);\\n        while (1) { // not reached position, can be jump from current position (cur -> next)\\n            let next = evenOdd[x][idx];\\n            if (next == undefined || next > cur + R) break;\\n            res[next] = res[cur] + 1;\\n            q.push(next);\\n            evenOdd[x].splice(idx, 1);\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n////////////////////////// Template ////////////////////////////////////\\nfunction Bisect() {\\n    return { insort_right, insort_left, bisect_left, bisect_right }\\n    function insort_right(a, x, lo = 0, hi = null) {\\n        lo = bisect_right(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_right(a, x, lo = 0, hi = null) { // > upper_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] > x ? hi = mid : lo = mid + 1;\\n        }\\n        return lo;\\n    }\\n    function insort_left(a, x, lo = 0, hi = null) {\\n        lo = bisect_left(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_left(a, x, lo = 0, hi = null) { // >= lower_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] < x ? lo = mid + 1 : hi = mid;\\n        }\\n        return lo;\\n    }\\n}\\n///////////////////////////////////////////////////////////////////\\n\\nconst minReverseOperations = (n, p, banned, k) => {\\n    let res = Array(n).fill(-1), evenOdd = [[], []], q = [p], bi = new Bisect();\\n    if (k == 1) {\\n        res[p] = 0;\\n        return res;\\n    }\\n    banned = new Set(banned);\\n    for (let i = 0; i < n; i++) {\\n        if (i != p && !banned.has(i)) evenOdd[i % 2].push(i);\\n    }\\n    res[p] = 0;\\n    while (q.length) {\\n        let cur = q.shift();\\n        let L = Math.max(-(k - 1), k - 1 - cur * 2), R = Math.min(k - 1, -(k - 1) + (n - cur - 1) * 2); // caculate the jump range\\n        let x = (cur + k - 1) % 2, idx = bi.bisect_left(evenOdd[x], cur + L);\\n        while (1) { // not reached position, can be jump from current position (cur -> next)\\n            let next = evenOdd[x][idx];\\n            if (next == undefined || next > cur + R) break;\\n            res[next] = res[cur] + 1;\\n            q.push(next);\\n            evenOdd[x].splice(idx, 1);\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3372118,
                "title": "100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    set<int> mp[2];\\n    vector<int> dp;\\n\\n    void insert(int i) {\\n        if (dp[i] != INT_MAX) return;\\n        mp[(i % 2)].insert(i);\\n    }\\n\\n    void mark(int l, int r, int i, int k, deque<int>& q) {\\n        if (r < l) return;\\n        int b = i % 2;\\n        set<int>& se = (k % 2) ? mp[b] : mp[1 - b];\\n        auto iter = se.lower_bound(l);\\n        while (iter != se.end()) {\\n            int cur = *iter;\\n            if ((cur) > r) break;\\n            dp[cur] = dp[i] + 1;\\n            q.push_back(cur);\\n            iter = se.erase(iter);\\n        }\\n    }\\n   \\n    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {       \\n        dp = vector<int>(n, INT_MAX);\\n        dp[p] = 0;\\n        for (auto b : banned) dp[b] = -1;\\n        for (int i = 0; i < n; i++) insert(i);\\n\\n        deque<int> q;\\n        q.push_back(p);\\n        while (!q.empty()) {\\n            int len = q.size();\\n            for (int i = 0; i < len; i++) {\\n                int cur = q.front();\\n                q.pop_front();\\n\\n                int l = (cur - k + 1) >= 0 ? \\n                           cur - k + 1 : k - 1 - cur ;\\n                int r = (cur + k -1) <= n ? \\n                            cur + k - 1 : n + n - k - 1 - cur;\\n                mark(l, r, cur, k, q);\\n            }\\n        }\\n\\n        for (auto& c : dp) if (c == INT_MAX) c = -1;\\n        return dp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    set<int> mp[2];\\n    vector<int> dp;\\n\\n    void insert(int i) {\\n        if (dp[i] != INT_MAX) return;\\n        mp[(i % 2)].insert(i);\\n    }\\n\\n    void mark(int l, int r, int i, int k, deque<int>& q) {\\n        if (r < l) return;\\n        int b = i % 2;\\n        set<int>& se = (k % 2) ? mp[b] : mp[1 - b];\\n        auto iter = se.lower_bound(l);\\n        while (iter != se.end()) {\\n            int cur = *iter;\\n            if ((cur) > r) break;\\n            dp[cur] = dp[i] + 1;\\n            q.push_back(cur);\\n            iter = se.erase(iter);\\n        }\\n    }\\n   \\n    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {       \\n        dp = vector<int>(n, INT_MAX);\\n        dp[p] = 0;\\n        for (auto b : banned) dp[b] = -1;\\n        for (int i = 0; i < n; i++) insert(i);\\n\\n        deque<int> q;\\n        q.push_back(p);\\n        while (!q.empty()) {\\n            int len = q.size();\\n            for (int i = 0; i < len; i++) {\\n                int cur = q.front();\\n                q.pop_front();\\n\\n                int l = (cur - k + 1) >= 0 ? \\n                           cur - k + 1 : k - 1 - cur ;\\n                int r = (cur + k -1) <= n ? \\n                            cur + k - 1 : n + n - k - 1 - cur;\\n                mark(l, r, cur, k, q);\\n            }\\n        }\\n\\n        for (auto& c : dp) if (c == INT_MAX) c = -1;\\n        return dp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371896,
                "title": "c-o-nlogn-bfs-bst",
                "content": "# Intuition\\nConsider the position of the $$1$$ in the array as a state, e.g. let node k represent $$1$$ is at position k in the array. Then the reverse operation is just an edge between 2 states. Thus, the question become finding the shortest path from initial state to all other states.\\n\\n# Approach\\nIf we do the bfs in a naive way, the complexity would become $$O(nk)$$ since there are $$nk$$ edges which would be TLE. However, we know that actual number of edges needed to access in bfs is just $$n-1$$ (bfs tree). So we would try to optimize by reducing the number of edges to access.\\n\\nFirst, let\\'s use a set $$s$$ to store all accessible nodes. After we access the node in bfs, we would remove it from the $$s$$. However, we still need to perform a $$O(k)$$ check to the nodes in $$s$$ and the complexity does not reduced.\\n\\nSecond, note that node $$i$$ could only access either odd nodes or even nodes and the accessible nodes are continuous after spliting. So let split the nodes into odd and even nodes. Then with the help of $$lower\\\\_bound$$(binary search), we could get the accessible nodes with $$O(logn)$$. Since all nodes would only be accessed once and the overall complexity can be reduced to $$O(nlongn)$$.\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {\\n        vector<int> result(n, -1);\\n        set<int> even, odd;\\n        for (int i = 0; i < n; i++) {\\n            if (i & 1) {\\n                odd.insert(i);\\n            } else {\\n                even.insert(i);\\n            }\\n        }\\n        result[p] = 0;\\n        // remove init pos and banned nodes\\n        odd.erase(p);\\n        even.erase(p);\\n        for (int v : banned) {\\n            odd.erase(v);\\n            even.erase(v);\\n        }\\n        queue<int> q;\\n        q.push(p);\\n        while (!q.empty()) {\\n            int v = q.front();\\n            q.pop();\\n            // choose correct parity set to work on\\n            set<int> &s = (v + k) & 1 ? even : odd;\\n            auto it = s.lower_bound(abs(v - k + 1));\\n            vector<int> temp;\\n            // get all nodes between [abs(v - k + 1), (n - 1 - abs(v + k - n)] with same parity \\n            while (it != s.end() && (*it) <= (n - 1 - abs(v + k - n))) {\\n                temp.push_back((*it));\\n                it++;\\n            }\\n            for (int t: temp) {\\n                result[t] = result[v] + 1;\\n                q.push(t);\\n                // remove the accessed node\\n                s.erase(t);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {\\n        vector<int> result(n, -1);\\n        set<int> even, odd;\\n        for (int i = 0; i < n; i++) {\\n            if (i & 1) {\\n                odd.insert(i);\\n            } else {\\n                even.insert(i);\\n            }\\n        }\\n        result[p] = 0;\\n        // remove init pos and banned nodes\\n        odd.erase(p);\\n        even.erase(p);\\n        for (int v : banned) {\\n            odd.erase(v);\\n            even.erase(v);\\n        }\\n        queue<int> q;\\n        q.push(p);\\n        while (!q.empty()) {\\n            int v = q.front();\\n            q.pop();\\n            // choose correct parity set to work on\\n            set<int> &s = (v + k) & 1 ? even : odd;\\n            auto it = s.lower_bound(abs(v - k + 1));\\n            vector<int> temp;\\n            // get all nodes between [abs(v - k + 1), (n - 1 - abs(v + k - n)] with same parity \\n            while (it != s.end() && (*it) <= (n - 1 - abs(v + k - n))) {\\n                temp.push_back((*it));\\n                it++;\\n            }\\n            for (int t: temp) {\\n                result[t] = result[v] + 1;\\n                q.push(t);\\n                // remove the accessed node\\n                s.erase(t);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371510,
                "title": "c-working-solution",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    public int[] MinReverseOperations(int n, int p, int[] banned, int k)\\n    {\\n        var bs = new HashSet<int>(banned) { p };\\n        \\n        SortedSet<int>[] choice =\\n        {\\n            new(Enumerable.Range(0, n).Where(i => i % 2 == 0).Except(bs)),\\n            new(Enumerable.Range(0, n).Where(i => i % 2 == 1).Except(bs))\\n        };\\n\\n        IEnumerable<int> Rotate(int pos)\\n        {\\n            var l = Math.Max(pos - k + 1, 0) * 2 + k - 1 - pos;\\n            var r = Math.Min(pos + 1, n - k + 1) * 2 + k - 1 - pos;\\n            var currChoice = choice[l % 2];\\n            var result = currChoice.GetViewBetween(l, r - 1).ToList();\\n            \\n            foreach (var i in result)\\n                currChoice.Remove(i);\\n\\n            return result;\\n        }\\n\\n        var bfs = new List<int> { p };\\n        var visited = new Dictionary<int, int> { { p, 0 } };\\n\\n        for (var i = 0; i < bfs.Count; i++)\\n        {\\n            var vi = visited[bfs[i]] + 1;\\n\\n            foreach (var j in Rotate(bfs[i]).Where(j => !visited.ContainsKey(j)))\\n            {\\n                visited[j] = vi;\\n                bfs.Add(j);\\n            }\\n        }\\n\\n        var result = Enumerable.Repeat(-1, n).ToArray();\\n        \\n        foreach (var pair in visited)\\n            result[pair.Key] = pair.Value;\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int[] MinReverseOperations(int n, int p, int[] banned, int k)\\n    {\\n        var bs = new HashSet<int>(banned) { p };\\n        \\n        SortedSet<int>[] choice =\\n        {\\n            new(Enumerable.Range(0, n).Where(i => i % 2 == 0).Except(bs)),\\n            new(Enumerable.Range(0, n).Where(i => i % 2 == 1).Except(bs))\\n        };\\n\\n        IEnumerable<int> Rotate(int pos)\\n        {\\n            var l = Math.Max(pos - k + 1, 0) * 2 + k - 1 - pos;\\n            var r = Math.Min(pos + 1, n - k + 1) * 2 + k - 1 - pos;\\n            var currChoice = choice[l % 2];\\n            var result = currChoice.GetViewBetween(l, r - 1).ToList();\\n            \\n            foreach (var i in result)\\n                currChoice.Remove(i);\\n\\n            return result;\\n        }\\n\\n        var bfs = new List<int> { p };\\n        var visited = new Dictionary<int, int> { { p, 0 } };\\n\\n        for (var i = 0; i < bfs.Count; i++)\\n        {\\n            var vi = visited[bfs[i]] + 1;\\n\\n            foreach (var j in Rotate(bfs[i]).Where(j => !visited.ContainsKey(j)))\\n            {\\n                visited[j] = vi;\\n                bfs.Add(j);\\n            }\\n        }\\n\\n        var result = Enumerable.Repeat(-1, n).ToArray();\\n        \\n        foreach (var pair in visited)\\n            result[pair.Key] = pair.Value;\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370853,
                "title": "explain-the-reverse-in-graph",
                "content": "# base i rightmost less than n\\n![Screen Shot 2023-04-02 at 21.21.46.png](https://assets.leetcode.com/users/images/d34fd583-ee82-472c-a4ab-08cd24486aed_1680441774.540572.png)\\n\\n# base i rightmost greater than n\\n\\n![Screen Shot 2023-04-02 at 21.29.22.png](https://assets.leetcode.com/users/images/114d800b-c3bd-459b-86f3-dc42528a1236_1680442186.427925.png)\\n\\n```\\nso the rightmost index is min(i + k - 1, 2 * n - k - 1 - i)\\n```\\n\\n# same idea to get leftmost index\\n\\n\\n",
                "solutionTags": [
                    "Graph"
                ],
                "code": "```\\nso the rightmost index is min(i + k - 1, 2 * n - k - 1 - i)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3370658,
                "title": "python-simple-bfs-with-tree-cutting-derivation-explanation-o-nlogn",
                "content": "\\n# Explanation\\nSame ideas as other\\'s,I used the below formula for neighbour i.e\\np\\' = 2s + k -1 - p\\nwhere :-\\np\\' is new index of 1\\np - old index\\ns - starting position which ranges max(0,pp-k+1),min(pp+1,n-k+1)\\nk - given length\\n\\nIf you are finding it hard to understand where it comes from just take copy pen and do the calculations yourself!\\n\\nhint: you can start here, s-p=e-p\\' , e = ending = p+k-1\\n## Optimize \\nNow to optimize, we need to realize that we are traversing visited node again and again. \\nie. p\\' should only be calculated when it isn\\'t visited before.\\n\\nTo do this i mentain a ordered list so we can remove visited values of p\\'.\\n\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedSet\\nclass Solution:\\n    def minReverseOperations(self, n: int, p: int, bn: List[int], k: int) -> List[int]:\\n        res = [-1]*n\\n        res[p] = 0\\n        no_need = [False]*n\\n        no_need[p] = True\\n        for i in bn: no_need[i] = True\\n        q = deque() # bfs where nodes are the position of 1\\n        q.append((p,0))\\n        ev = SortedSet([i for i in range(0,n,2) if(not no_need[i]) ]) # important to make TC O(N)\\n        od = SortedSet([i for i in range(1,n,2) if(not no_need[i]) ])\\n        while(q):\\n            pp,m = q.popleft()\\n            left,right = max(0,pp-k+1),min(pp+1,n-k+1) # find range for starting positions of K len array containing 1\\n            c = k-1-pp # constant as per the eq\\n            ls = ev if (2*left+c)%2==0 else od # select the correct list\\n            st = ls.bisect_left(2*left+c) # find begining position\\n            end = ls.bisect_left(2*right+c) # ending position\\n            sl = ls[st:end] # create a view \\n            for i in sl:\\n                ls.remove(i) # cut the original arr\\n                res[i] = m+1\\n                q.append((i,m+1))\\n        return res\\n```\\nUpvote if you find it useful!\\nThanks",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedSet\\nclass Solution:\\n    def minReverseOperations(self, n: int, p: int, bn: List[int], k: int) -> List[int]:\\n        res = [-1]*n\\n        res[p] = 0\\n        no_need = [False]*n\\n        no_need[p] = True\\n        for i in bn: no_need[i] = True\\n        q = deque() # bfs where nodes are the position of 1\\n        q.append((p,0))\\n        ev = SortedSet([i for i in range(0,n,2) if(not no_need[i]) ]) # important to make TC O(N)\\n        od = SortedSet([i for i in range(1,n,2) if(not no_need[i]) ])\\n        while(q):\\n            pp,m = q.popleft()\\n            left,right = max(0,pp-k+1),min(pp+1,n-k+1) # find range for starting positions of K len array containing 1\\n            c = k-1-pp # constant as per the eq\\n            ls = ev if (2*left+c)%2==0 else od # select the correct list\\n            st = ls.bisect_left(2*left+c) # find begining position\\n            end = ls.bisect_left(2*right+c) # ending position\\n            sl = ls[st:end] # create a view \\n            for i in sl:\\n                ls.remove(i) # cut the original arr\\n                res[i] = m+1\\n                q.append((i,m+1))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370165,
                "title": "bfs-with-c-set-and-lower-bound-upper-bound",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem seems to be a BFS or SSSP(single source shortest path) problem. But given the input size, the general approach won\\'t work . We need to find and use the specificity of the problem\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n## Rephrase the problem\\nStart from the BFS or SSSP problem, the starting point is P and every legal operation that covers a vertice is an outgoing \"edge\" of a vertice. But given the number of nodes (10 ** 5) and number of edges (n * k, 10 ** 10 in the worst case), naive BFS or SSSP won\\'t work.\\n\\n## Reduce the number of edges\\nImagine how the naive method will be implemented. In a BFS, for current vertice, we try to find the vertices that are reachable by this vertice. To reduce the redundancy, if a vertice is banned or visited before, we should skip that vertice.\\n\\nWe can maintain an unvisited nodes list and only traverse nodes in the list. Consider the specificity of the problem -- the nodes are array indices and the \"edges\" are in a contiguous range. We need a data structure that could add, remove elements and get elements in a given range. So:\\n\\n- When start, all the vertices are in the list\\n- In BFS, we calculate the reachable range, query the list to get unvisited nodes in the range\\n- Once a vertice is visited, remove it from the list\\n\\nSo we could skip visited vertices. It\\'s doable with C++ set or Java TreeSet. A BST will work as well.\\n\\n## Parity \\nFor k = 3, 5, 7... the \\'1\\' could only move even steps, that is to say only half of the array which has the same parity of P is reachable. \\n\\nFor k = 2, 4, 6.... the \\'1\\' could move odd steps, by moving +1 -3, it creates +2. So all the array is reachable.\\n\\nI tried to use parity to solve the problem but that doesn\\'t work. However, this discovers a corner case. If k is odd, half of the array is not reachable and will never be removed from the list. We need either not to add them into the list, or split the list by parity.\\n\\n# Complexity\\n- Time complexity: O(nlogn), Use amortized analysis.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {\\n        const int inf = 1E9;\\n        vector<int> dist(n, inf);\\n        queue<int> q;\\n        dist[p] = 0;\\n        q.push(p);\\n        \\n        set<int> allowed[2];\\n        for (int i = 0; i < n; i++) {\\n            allowed[i % 2].insert(i);\\n        }\\n        allowed[p % 2].erase(p);\\n        for (int e : banned) {\\n            allowed[e % 2].erase(e);\\n        }\\n        \\n        while (q.size()) {\\n            int now = q.front();\\n            q.pop();\\n\\n            int op_left = max(0, now - k + 1);\\n            int op_right = min(now, n - k);\\n\\n            if (op_left > op_right) {\\n                continue;\\n            }\\n\\n            int l = op_left + (k - 1) - (now - op_left);\\n            int r = op_right + (k - 1) - (now - op_right);\\n            \\n            //                    k % 2 == 0   k % 2 == 1\\n            //   now % 2 == 0              1            0\\n            //   now % 2 == 1              0            1\\n            auto &allowed_ref = allowed[1 ^ (k % 2) ^ (now % 2)];\\n\\n            auto lower = allowed_ref.lower_bound(l);\\n            auto upper = allowed_ref.upper_bound(r);\\n            vector<int> to_erase;\\n            for (auto it = lower; it != upper; it++) {\\n                int next = *it;                \\n                if (dist[next] > dist[now] + 1) {\\n                    dist[next] = dist[now] + 1;\\n                    q.push(next);\\n                    to_erase.push_back(next);\\n                }\\n            }\\n            for (auto e: to_erase) {\\n                allowed[e % 2].erase(e);\\n            }\\n        }\\n        for (auto &e : dist) {\\n            if (e == inf) {\\n                e = -1;\\n            }\\n        }\\n        return dist;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {\\n        const int inf = 1E9;\\n        vector<int> dist(n, inf);\\n        queue<int> q;\\n        dist[p] = 0;\\n        q.push(p);\\n        \\n        set<int> allowed[2];\\n        for (int i = 0; i < n; i++) {\\n            allowed[i % 2].insert(i);\\n        }\\n        allowed[p % 2].erase(p);\\n        for (int e : banned) {\\n            allowed[e % 2].erase(e);\\n        }\\n        \\n        while (q.size()) {\\n            int now = q.front();\\n            q.pop();\\n\\n            int op_left = max(0, now - k + 1);\\n            int op_right = min(now, n - k);\\n\\n            if (op_left > op_right) {\\n                continue;\\n            }\\n\\n            int l = op_left + (k - 1) - (now - op_left);\\n            int r = op_right + (k - 1) - (now - op_right);\\n            \\n            //                    k % 2 == 0   k % 2 == 1\\n            //   now % 2 == 0              1            0\\n            //   now % 2 == 1              0            1\\n            auto &allowed_ref = allowed[1 ^ (k % 2) ^ (now % 2)];\\n\\n            auto lower = allowed_ref.lower_bound(l);\\n            auto upper = allowed_ref.upper_bound(r);\\n            vector<int> to_erase;\\n            for (auto it = lower; it != upper; it++) {\\n                int next = *it;                \\n                if (dist[next] > dist[now] + 1) {\\n                    dist[next] = dist[now] + 1;\\n                    q.push(next);\\n                    to_erase.push_back(next);\\n                }\\n            }\\n            for (auto e: to_erase) {\\n                allowed[e % 2].erase(e);\\n            }\\n        }\\n        for (auto &e : dist) {\\n            if (e == inf) {\\n                e = -1;\\n            }\\n        }\\n        return dist;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369850,
                "title": "easiest-and-fastest-c-solution",
                "content": "# Intuition\\nbreadth first search from given position of one\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nbinary search to find next valid index\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:o(nlong(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> minReverseOperations(int n, int p, vector<int>& b, int k) {\\n        vector<int> d(n,-1);\\n        set<int> s;\\n        for(int i:b)s.insert(i);\\n        queue<int> q;\\n        map<int,bool> vis; \\n        vis[p]=true;\\n        q.push(p);\\n        int dis=0;\\n        vector<set<int>> vs(2);\\n        for(int i=0;i<n;i++){ vs[i%2].insert(i); }\\n        for(int j:b)vs[j%2].erase(j);\\n        vs[p%2].erase(p);\\n        while(q.size()){\\n            int sz=q.size();\\n            while(sz--){\\n                int a=q.front();\\n                q.pop();\\n                d[a]=dis;\\n                int z=a;\\n                int mn=max(0,a-k+1);\\n                int y=a-mn;\\n                int j=mn+(k-1-y);\\n                int p=j;\\n            \\n                vector<int> v;\\n                int mx=mn+k-1;\\n                for(auto k1=vs[j%2].lower_bound(j) ;k1!=vs[j%2].end()&&*k1<=(a+k-1)&&(mx+((*k1-p)/2)<n);k1++){\\n                 \\n                if(vis[*k1]==false){\\n                    vis[*k1]=true;\\n                    q.push(*k1);\\n                    v.push_back(*k1);\\n                }\\n                    \\n                    \\n                }\\n                for(int i:v)vs[i%2].erase(i);\\n              \\n            }\\n            dis++;\\n            \\n        }\\n        return d;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minReverseOperations(int n, int p, vector<int>& b, int k) {\\n        vector<int> d(n,-1);\\n        set<int> s;\\n        for(int i:b)s.insert(i);\\n        queue<int> q;\\n        map<int,bool> vis; \\n        vis[p]=true;\\n        q.push(p);\\n        int dis=0;\\n        vector<set<int>> vs(2);\\n        for(int i=0;i<n;i++){ vs[i%2].insert(i); }\\n        for(int j:b)vs[j%2].erase(j);\\n        vs[p%2].erase(p);\\n        while(q.size()){\\n            int sz=q.size();\\n            while(sz--){\\n                int a=q.front();\\n                q.pop();\\n                d[a]=dis;\\n                int z=a;\\n                int mn=max(0,a-k+1);\\n                int y=a-mn;\\n                int j=mn+(k-1-y);\\n                int p=j;\\n            \\n                vector<int> v;\\n                int mx=mn+k-1;\\n                for(auto k1=vs[j%2].lower_bound(j) ;k1!=vs[j%2].end()&&*k1<=(a+k-1)&&(mx+((*k1-p)/2)<n);k1++){\\n                 \\n                if(vis[*k1]==false){\\n                    vis[*k1]=true;\\n                    q.push(*k1);\\n                    v.push_back(*k1);\\n                }\\n                    \\n                    \\n                }\\n                for(int i:v)vs[i%2].erase(i);\\n              \\n            }\\n            dis++;\\n            \\n        }\\n        return d;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369682,
                "title": "o-n-using-bfs-with-two-queues-and-limiting-min-max",
                "content": "# Main Idea\\n+ BFS with two queues using rotating 1\\n+ k=1: ans[i] = (1) -1 with i!=p (2) 0 with i=p\\n+ k>0:\\n```\\nq1 <- [p] with p is initial value 1\\nans[i] = {-1 with i!=p and 0 with i=p}\\nwhile q1 not empty:\\n  \\n  # optimization for complexity\\n  tt = [calculating [vmin, vmax] for all u in q1]\\n  sorted(tt) -> get vmin, vmax in tt\\n  \\n  # bfs two queues\\n  q2 = []\\n  for v in [vmin, vmax] with step=2:\\n    if check[v] is False and v not in banned:\\n      check[v] = true\\n      ans[v] = ans[u] + 1\\n      q2.append(v)\\n  q1 = q2\\n```\\n\\n# Examples\\n```\\nExample 1: n = 4, p = 0, banned = [1, 2], k = 4\\n\\n--- q1 = [0] ---\\n+ [vmin, vmax] = [3, 3]\\n+ q2 = [3]\\n+ chk = [True, False, False, True]\\n\\n--- q1 = [3] ---\\n+ [vmin, vmax] = [0, 0]\\n+ q2 = []\\n+ chk = [True, False, False, True]\\n\\n--- ans ---\\nans = [0, -1, -1, 1]\\n----------\\n\\nExample 2: n = 5, p = 0, banned = [2, 4], k = 3\\n\\n--- q1 = [0] ---\\n+ [vmin, vmax] = [2, 2]\\n+ q2 = []\\n+ chk = [True, False, False, False, False]\\n\\n--- ans ---\\nans = [0, -1, -1, -1, -1]\\n----------\\n\\nExample 3: n = 6, p = 2, banned = [], k = 4\\n\\n--- q1 = [2] ---\\n+ [vmin, vmax] = [1, 5]\\n+ q2 = [1, 3, 5]\\n+ chk = [False, True, True, True, False, True]\\n\\n--- q1 = [1, 3, 5] ---\\n+ [vmin, vmax] = [0, 4]\\n+ q2 = [0, 4]\\n+ chk = [True, True, True, True, True, True]\\n\\n--- q1 = [0, 4] ---\\n+ [vmin, vmax] = [1, 3]\\n+ q2 = []\\n+ chk = [True, True, True, True, True, True]\\n\\n--- ans ---\\nans = [2, 1, 0, 1, 2, 1]\\n----------\\n```\\n\\n# Code\\n```\\n# DEBUG = True\\nD = lambda fn: fn() if globals().get(\"DEBUG\", False) else lambda fn: ()\\n\\nclass Solution:\\n    def minReverseOperations(self, n: int, p: int, banned: List[int], k: int) -> List[int]:\\n        D(lambda: print(f\\'Example: n = {n}, p = {p}, banned = {banned}, k = {k}\\\\n\\'))\\n        ans = [-1] * n\\n        ans[p] = 0\\n        if k>1:\\n            avoid = [0] * n\\n            for i in range(len(banned)):\\n                avoid[banned[i]] = 1\\n            chk = [False] * n\\n            chk[p] = True\\n            q1 = [p]\\n            cnt = 1\\n            v_chan = [-1, -1]\\n            v_le = [-1, -1]\\n            \\n            while len(q1)>0:\\n                D(lambda: print(f\\'--- q1 = {q1} ---\\'))\\n                q2 = []\\n                \\n                tt = []\\n                for u in q1:\\n                    step_min = max(0, u - k + 1) - (u - k + 1)\\n                    step_max = (k-1) - max(0, (u + k - 1) - min(n - 1, u + k - 1))\\n                    v_min = (u - k + 1) + 2 * step_min\\n                    v_max = (u - k + 1) + 2 * step_max\\n                    tt.append(v_min)\\n                    tt.append(v_max)\\n                tt = sorted(tt)   \\n                v_min, v_max = tt[0], tt[-1]\\n                D(lambda: print(f\\'+ [vmin, vmax] = [{v_min}, {v_max}]\\'))\\n                \\n                for v in range(v_min, v_max+1, 2):\\n                    if chk[v] is False and avoid[v]==0:\\n                        chk[v] = True\\n                        ans[v] = ans[u] + 1\\n                        q2.append(v)\\n                D(lambda: print(f\"+ q2 = {q2}\"))\\n                D(lambda: print(f\"+ chk = {chk}\\\\n\"))\\n                q1 = q2\\n        D(lambda: print(f\\'--- ans ---\\\\nans = {ans}\\\\n----------\\\\n\\\\n\\'))\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nq1 <- [p] with p is initial value 1\\nans[i] = {-1 with i!=p and 0 with i=p}\\nwhile q1 not empty:\\n  \\n  # optimization for complexity\\n  tt = [calculating [vmin, vmax] for all u in q1]\\n  sorted(tt) -> get vmin, vmax in tt\\n  \\n  # bfs two queues\\n  q2 = []\\n  for v in [vmin, vmax] with step=2:\\n    if check[v] is False and v not in banned:\\n      check[v] = true\\n      ans[v] = ans[u] + 1\\n      q2.append(v)\\n  q1 = q2\\n```\n```\\nExample 1: n = 4, p = 0, banned = [1, 2], k = 4\\n\\n--- q1 = [0] ---\\n+ [vmin, vmax] = [3, 3]\\n+ q2 = [3]\\n+ chk = [True, False, False, True]\\n\\n--- q1 = [3] ---\\n+ [vmin, vmax] = [0, 0]\\n+ q2 = []\\n+ chk = [True, False, False, True]\\n\\n--- ans ---\\nans = [0, -1, -1, 1]\\n----------\\n\\nExample 2: n = 5, p = 0, banned = [2, 4], k = 3\\n\\n--- q1 = [0] ---\\n+ [vmin, vmax] = [2, 2]\\n+ q2 = []\\n+ chk = [True, False, False, False, False]\\n\\n--- ans ---\\nans = [0, -1, -1, -1, -1]\\n----------\\n\\nExample 3: n = 6, p = 2, banned = [], k = 4\\n\\n--- q1 = [2] ---\\n+ [vmin, vmax] = [1, 5]\\n+ q2 = [1, 3, 5]\\n+ chk = [False, True, True, True, False, True]\\n\\n--- q1 = [1, 3, 5] ---\\n+ [vmin, vmax] = [0, 4]\\n+ q2 = [0, 4]\\n+ chk = [True, True, True, True, True, True]\\n\\n--- q1 = [0, 4] ---\\n+ [vmin, vmax] = [1, 3]\\n+ q2 = []\\n+ chk = [True, True, True, True, True, True]\\n\\n--- ans ---\\nans = [2, 1, 0, 1, 2, 1]\\n----------\\n```\n```\\n# DEBUG = True\\nD = lambda fn: fn() if globals().get(\"DEBUG\", False) else lambda fn: ()\\n\\nclass Solution:\\n    def minReverseOperations(self, n: int, p: int, banned: List[int], k: int) -> List[int]:\\n        D(lambda: print(f\\'Example: n = {n}, p = {p}, banned = {banned}, k = {k}\\\\n\\'))\\n        ans = [-1] * n\\n        ans[p] = 0\\n        if k>1:\\n            avoid = [0] * n\\n            for i in range(len(banned)):\\n                avoid[banned[i]] = 1\\n            chk = [False] * n\\n            chk[p] = True\\n            q1 = [p]\\n            cnt = 1\\n            v_chan = [-1, -1]\\n            v_le = [-1, -1]\\n            \\n            while len(q1)>0:\\n                D(lambda: print(f\\'--- q1 = {q1} ---\\'))\\n                q2 = []\\n                \\n                tt = []\\n                for u in q1:\\n                    step_min = max(0, u - k + 1) - (u - k + 1)\\n                    step_max = (k-1) - max(0, (u + k - 1) - min(n - 1, u + k - 1))\\n                    v_min = (u - k + 1) + 2 * step_min\\n                    v_max = (u - k + 1) + 2 * step_max\\n                    tt.append(v_min)\\n                    tt.append(v_max)\\n                tt = sorted(tt)   \\n                v_min, v_max = tt[0], tt[-1]\\n                D(lambda: print(f\\'+ [vmin, vmax] = [{v_min}, {v_max}]\\'))\\n                \\n                for v in range(v_min, v_max+1, 2):\\n                    if chk[v] is False and avoid[v]==0:\\n                        chk[v] = True\\n                        ans[v] = ans[u] + 1\\n                        q2.append(v)\\n                D(lambda: print(f\"+ q2 = {q2}\"))\\n                D(lambda: print(f\"+ chk = {chk}\\\\n\"))\\n                q1 = q2\\n        D(lambda: print(f\\'--- ans ---\\\\nans = {ans}\\\\n----------\\\\n\\\\n\\'))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369459,
                "title": "dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n![image.png](https://assets.leetcode.com/users/images/bd132b55-c0eb-40dd-880b-f3fe66ea382b_1680419897.5582774.png)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {\\n        const int pos_max = n - 1;\\n        const int window_len = k;\\n        const auto find_range = [&](const int pivot) -> std::pair<int, int> {\\n            const int l1 = std::max(0, pivot - window_len + 1);\\n            const int r1 = l1 + window_len - 1;\\n            assert(r1 >= pivot);\\n            const int lhs_diff = r1 - pivot;\\n            const int lhs = l1 + lhs_diff;\\n\\n            const int r2 = std::min(pos_max, pivot + window_len - 1);\\n            const int l2 = r2 - window_len + 1;\\n            assert(l2 <= pivot);\\n            const int rhs_diff = pivot - l2;\\n            const int rhs = r2 - rhs_diff;\\n            \\n            return {lhs, rhs};\\n        };\\n\\n        std::vector<bool> tbl_banned(n, false);\\n        for (const int pos : banned) {\\n            tbl_banned[pos] = true;\\n        }\\n        std::set<int> avail_pos_by_parity[2];\\n        for (int pos = 0; pos < n; ++pos) {\\n            if (tbl_banned[pos] || (pos == p)) {\\n                continue;\\n            }\\n            avail_pos_by_parity[pos % 2].insert(pos);\\n        }\\n\\n        std::vector<int> tbl_min_ops(n, -1);\\n        tbl_min_ops[p] = 0;\\n        std::queue<int> pos_ord;\\n        pos_ord.push(p);\\n        while (!pos_ord.empty()) {\\n            const int target = pos_ord.front();\\n            pos_ord.pop();\\n            const auto [lhs, rhs] = find_range(target);\\n            const int parity = \\n                (window_len % 2 == 0) ? (1 - (target % 2)) : (target % 2);\\n            auto &avail_pos = avail_pos_by_parity[parity];\\n            auto it_init = avail_pos.lower_bound(lhs);\\n            auto it_fini = avail_pos.upper_bound(rhs);\\n            const int num_ops = tbl_min_ops[target];\\n            assert(num_ops >= 0);\\n            for (auto it = it_init; it != it_fini; ++it) {\\n                tbl_min_ops[*it] = num_ops + 1;\\n                pos_ord.push(*it);\\n            }\\n            avail_pos.erase(it_init, it_fini);\\n        }\\n        return tbl_min_ops;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {\\n        const int pos_max = n - 1;\\n        const int window_len = k;\\n        const auto find_range = [&](const int pivot) -> std::pair<int, int> {\\n            const int l1 = std::max(0, pivot - window_len + 1);\\n            const int r1 = l1 + window_len - 1;\\n            assert(r1 >= pivot);\\n            const int lhs_diff = r1 - pivot;\\n            const int lhs = l1 + lhs_diff;\\n\\n            const int r2 = std::min(pos_max, pivot + window_len - 1);\\n            const int l2 = r2 - window_len + 1;\\n            assert(l2 <= pivot);\\n            const int rhs_diff = pivot - l2;\\n            const int rhs = r2 - rhs_diff;\\n            \\n            return {lhs, rhs};\\n        };\\n\\n        std::vector<bool> tbl_banned(n, false);\\n        for (const int pos : banned) {\\n            tbl_banned[pos] = true;\\n        }\\n        std::set<int> avail_pos_by_parity[2];\\n        for (int pos = 0; pos < n; ++pos) {\\n            if (tbl_banned[pos] || (pos == p)) {\\n                continue;\\n            }\\n            avail_pos_by_parity[pos % 2].insert(pos);\\n        }\\n\\n        std::vector<int> tbl_min_ops(n, -1);\\n        tbl_min_ops[p] = 0;\\n        std::queue<int> pos_ord;\\n        pos_ord.push(p);\\n        while (!pos_ord.empty()) {\\n            const int target = pos_ord.front();\\n            pos_ord.pop();\\n            const auto [lhs, rhs] = find_range(target);\\n            const int parity = \\n                (window_len % 2 == 0) ? (1 - (target % 2)) : (target % 2);\\n            auto &avail_pos = avail_pos_by_parity[parity];\\n            auto it_init = avail_pos.lower_bound(lhs);\\n            auto it_fini = avail_pos.upper_bound(rhs);\\n            const int num_ops = tbl_min_ops[target];\\n            assert(num_ops >= 0);\\n            for (auto it = it_init; it != it_fini; ++it) {\\n                tbl_min_ops[*it] = num_ops + 1;\\n                pos_ord.push(*it);\\n            }\\n            avail_pos.erase(it_init, it_fini);\\n        }\\n        return tbl_min_ops;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369428,
                "title": "c-runtime-error-message-out-of-memory-test-case-697-710",
                "content": "**UPD**: Problem solved\\nThe most essential part was to distinguish `even` vs `odd` indices. Somehow having two sorted sorted sets based on parity is more efficient than iterating one set and skip half of its elements...\\n\\nHello community.\\n\\nI have a solution in C#. It seems to be similar to accepted ones in other languages. But I can\\'t get over my **Runtime Error: Out of memory** on **Test Case 697 / 710**\\n\\nI tried different optimizations but none of them helped to fix the memory issue.\\n\\nJava solutions suggested here use **TreeSet** class. I even had a similar solution with **SortedSet** which is an equivalent in C#.\\nBut this solution fails with TLE. So I had to replace it with **List** with **BinarySearch** to overcome TLE.\\n\\nI tried to look for other C# solutions from the other contestants but I could not find a single one that uses C#.\\n\\nCan anyone sugggest what am I missing?\\n\\n```csharp\\npublic class Solution\\n{\\n    public int[] MinReverseOperations(int n, int p, int[] banned, int k)\\n    {\\n        const int impossible = -1;\\n        var ans = Enumerable.Repeat(impossible, n).ToArray();\\n        var bannedSet = banned.ToHashSet();\\n        var indicesToCheck = new List<int>();\\n\\n        for (var i = 0; i < n; i++)\\n        {\\n            if (bannedSet.Contains(i))\\n            {\\n                continue;\\n            }\\n\\n            if (i == p)\\n            {\\n                continue;\\n            }\\n\\n            indicesToCheck.Add(i);\\n        }\\n\\n        var queue = new Queue<int>();\\n        queue.Enqueue(p);\\n        var step = 0;\\n\\n        while (queue.Count > 0)\\n        {\\n            var count = queue.Count;\\n\\n            for (var _ = 0; _ < count; _++)\\n            {\\n                var i = queue.Dequeue();\\n\\n                if (ans[i] != impossible)\\n                {\\n                    continue;\\n                }\\n\\n                ans[i] = step;\\n                indicesToCheck.Remove(i);\\n\\n                var low = Math.Abs(i - k + 1);\\n                var high = new[] { i + k - 1, 2 * n - k - 1 - i, n - 1 }.Min();\\n\\n                if (low > high)\\n                {\\n                    continue;\\n                }\\n\\n                var lowIndex = indicesToCheck.BinarySearch(low);\\n\\n                if (lowIndex < 0)\\n                {\\n                    lowIndex = ~lowIndex;\\n                }\\n\\n                var highIndex = indicesToCheck.BinarySearch(high);\\n\\n                if (highIndex < 0)\\n                {\\n                    highIndex = ~highIndex - 1;\\n                }\\n\\n                for (var index = lowIndex; index <= highIndex; index++)\\n                {\\n                    var j = indicesToCheck[index];\\n\\n                    if ((i + j + k + 1) % 2 != 0)\\n                    {\\n                        continue;\\n                    }\\n\\n                    queue.Enqueue(j);\\n                }\\n            }\\n\\n            step++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic class Solution\\n{\\n    public int[] MinReverseOperations(int n, int p, int[] banned, int k)\\n    {\\n        const int impossible = -1;\\n        var ans = Enumerable.Repeat(impossible, n).ToArray();\\n        var bannedSet = banned.ToHashSet();\\n        var indicesToCheck = new List<int>();\\n\\n        for (var i = 0; i < n; i++)\\n        {\\n            if (bannedSet.Contains(i))\\n            {\\n                continue;\\n            }\\n\\n            if (i == p)\\n            {\\n                continue;\\n            }\\n\\n            indicesToCheck.Add(i);\\n        }\\n\\n        var queue = new Queue<int>();\\n        queue.Enqueue(p);\\n        var step = 0;\\n\\n        while (queue.Count > 0)\\n        {\\n            var count = queue.Count;\\n\\n            for (var _ = 0; _ < count; _++)\\n            {\\n                var i = queue.Dequeue();\\n\\n                if (ans[i] != impossible)\\n                {\\n                    continue;\\n                }\\n\\n                ans[i] = step;\\n                indicesToCheck.Remove(i);\\n\\n                var low = Math.Abs(i - k + 1);\\n                var high = new[] { i + k - 1, 2 * n - k - 1 - i, n - 1 }.Min();\\n\\n                if (low > high)\\n                {\\n                    continue;\\n                }\\n\\n                var lowIndex = indicesToCheck.BinarySearch(low);\\n\\n                if (lowIndex < 0)\\n                {\\n                    lowIndex = ~lowIndex;\\n                }\\n\\n                var highIndex = indicesToCheck.BinarySearch(high);\\n\\n                if (highIndex < 0)\\n                {\\n                    highIndex = ~highIndex - 1;\\n                }\\n\\n                for (var index = lowIndex; index <= highIndex; index++)\\n                {\\n                    var j = indicesToCheck[index];\\n\\n                    if ((i + j + k + 1) % 2 != 0)\\n                    {\\n                        continue;\\n                    }\\n\\n                    queue.Enqueue(j);\\n                }\\n            }\\n\\n            step++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369427,
                "title": "python-and-c-solutions-from-tle-solution-during-contest-to-accepted-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAfter reading the question instruction, one should realize BFS is the way to go. From the point p, we check all the possible next flip positions and add 1 extra step\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe logic of the code is pretty simple. However, if $k$ becomes as large as $n$, the code could not pass within $10$ seconds ($700+$ testcases). I note that the time consuming part is the $j$-loop to look for all possible $k$-subarrays which contains the current node of interest. We therefore need a faster lookup data structure to keep the remaining (possibly) reachable nodes instead of constantly looking up the visited set.\\n\\nWhen we check carefully, we observe that the next reachable nodes are parity separated: $2*j + k - 1 - i$ is either odd or even regardless of value of $j$, but only depends on the parity of k - 1 - i. Therefore, if we keep the odd and even nodes in two binary search trees (sortedlist in Python, SortedSet in C#), we can binary search to get all the remaining relevant nodes, put them in the queue and remove them from the trees. This way we do not even need to refer to the visited / banned set.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nk)$$ for TLE solution, $$O(nlogk)$$ if use 2 sorted lists\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n- TLE solution, but provides the skeleton:\\n\\n```\\nclass Solution:\\n    def minReverseOperations(self, n: int, p: int, banned: List[int], k: int) -> List[int]:\\n        result = [-1]*n\\n        bannedSet = set(banned)\\n        dq = deque()\\n        dq.append([p, 0])\\n        bannedSet.add(p)\\n        while dq:\\n            i, flip = dq.popleft()\\n            result[i] = flip\\n            for j in range(max(0, i - k + 1), min(i + 1, n + 1 - k)):\\n                indexflip = 2*j + k - 1 - i\\n                if indexflip not in bannedSet and result[indexflip] == -1:\\n                    dq.append([indexflip, flip + 1])\\n                    bannedSet.add(indexflip)\\n        return result\\n\\n```\\n- accepted solution:\\n\\n```\\nfrom collections import deque\\nfrom typing import List\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def minReverseOperations(self, n: int, p: int, banned: List[int], k: int) -> List[int]:\\n        result = [-1]*n\\n        slOdd = SortedList()\\n        slEven = SortedList()\\n        bannedSet = set(banned)\\n        for i in range(n):\\n            if i not in bannedSet:\\n                if i % 2 == 1:\\n                    slOdd.add(i)\\n                else:\\n                    slEven.add(i)\\n\\n        dq = deque()\\n        dq.append([p, 0])\\n        if p % 2 == 1:\\n            slOdd.remove(p)\\n        else:\\n            slEven.remove(p)\\n        while dq:\\n            i, flip = dq.popleft()\\n            result[i] = flip\\n            lowerLimit = 2*max(0, i - k + 1) + k - 1 - i\\n            upperLimit = 2*min(i + 1, n + 1 - k) + k - 3 - i\\n            tree = slOdd if (k - 1 - i) % 2 == 1 else slEven\\n            lstToRemove = list(tree.irange(lowerLimit, upperLimit))\\n            for j in lstToRemove:\\n                tree.remove(j)\\n                dq.append([j, flip + 1])         \\n        return result\\n```\\nC# solution using SortedSet\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\npublic class Solution \\n{\\n    public int[] MinReverseOperations(int n, int p, int[] banned, int k) \\n    {\\n        int[] result = new int[n];\\n        Array.Fill(result, -1);\\n\\n        SortedSet<int>[] trees = new SortedSet<int>[2];\\n        trees = trees.Select(x => new SortedSet<int>()).ToArray();\\n        HashSet<int> bannedSet = new HashSet<int>(banned);\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (!bannedSet.Contains(i))\\n            {\\n                trees[i % 2].Add(i);\\n            }\\n        }\\n\\n        Queue<int[]> queue = new Queue<int[]>();\\n        queue.Enqueue(new int[2]{p, 0});\\n        trees[p % 2].Remove(p);\\n        while (queue.TryDequeue(out int[] item))\\n        {\\n            result[item[0]] = item[1];\\n            int[] nodesToRemove = trees[Math.Abs(k - 1 - item[0]) % 2].GetViewBetween(2*Math.Max(0, item[0] - k + 1) + k - 1 - item[0], 2*Math.Min(item[0] + 1, n + 1 - k) + k - 3 - item[0]).ToArray();\\n            foreach (int node in nodesToRemove)\\n            {\\n                trees[Math.Abs(k - 1 - item[0]) % 2].Remove(node);\\n                queue.Enqueue(new int[2]{node, item[1] + 1});\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minReverseOperations(self, n: int, p: int, banned: List[int], k: int) -> List[int]:\\n        result = [-1]*n\\n        bannedSet = set(banned)\\n        dq = deque()\\n        dq.append([p, 0])\\n        bannedSet.add(p)\\n        while dq:\\n            i, flip = dq.popleft()\\n            result[i] = flip\\n            for j in range(max(0, i - k + 1), min(i + 1, n + 1 - k)):\\n                indexflip = 2*j + k - 1 - i\\n                if indexflip not in bannedSet and result[indexflip] == -1:\\n                    dq.append([indexflip, flip + 1])\\n                    bannedSet.add(indexflip)\\n        return result\\n\\n```\n```\\nfrom collections import deque\\nfrom typing import List\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def minReverseOperations(self, n: int, p: int, banned: List[int], k: int) -> List[int]:\\n        result = [-1]*n\\n        slOdd = SortedList()\\n        slEven = SortedList()\\n        bannedSet = set(banned)\\n        for i in range(n):\\n            if i not in bannedSet:\\n                if i % 2 == 1:\\n                    slOdd.add(i)\\n                else:\\n                    slEven.add(i)\\n\\n        dq = deque()\\n        dq.append([p, 0])\\n        if p % 2 == 1:\\n            slOdd.remove(p)\\n        else:\\n            slEven.remove(p)\\n        while dq:\\n            i, flip = dq.popleft()\\n            result[i] = flip\\n            lowerLimit = 2*max(0, i - k + 1) + k - 1 - i\\n            upperLimit = 2*min(i + 1, n + 1 - k) + k - 3 - i\\n            tree = slOdd if (k - 1 - i) % 2 == 1 else slEven\\n            lstToRemove = list(tree.irange(lowerLimit, upperLimit))\\n            for j in lstToRemove:\\n                tree.remove(j)\\n                dq.append([j, flip + 1])         \\n        return result\\n```\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\npublic class Solution \\n{\\n    public int[] MinReverseOperations(int n, int p, int[] banned, int k) \\n    {\\n        int[] result = new int[n];\\n        Array.Fill(result, -1);\\n\\n        SortedSet<int>[] trees = new SortedSet<int>[2];\\n        trees = trees.Select(x => new SortedSet<int>()).ToArray();\\n        HashSet<int> bannedSet = new HashSet<int>(banned);\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (!bannedSet.Contains(i))\\n            {\\n                trees[i % 2].Add(i);\\n            }\\n        }\\n\\n        Queue<int[]> queue = new Queue<int[]>();\\n        queue.Enqueue(new int[2]{p, 0});\\n        trees[p % 2].Remove(p);\\n        while (queue.TryDequeue(out int[] item))\\n        {\\n            result[item[0]] = item[1];\\n            int[] nodesToRemove = trees[Math.Abs(k - 1 - item[0]) % 2].GetViewBetween(2*Math.Max(0, item[0] - k + 1) + k - 1 - item[0], 2*Math.Min(item[0] + 1, n + 1 - k) + k - 3 - item[0]).ToArray();\\n            foreach (int node in nodesToRemove)\\n            {\\n                trees[Math.Abs(k - 1 - item[0]) % 2].Remove(node);\\n                queue.Enqueue(new int[2]{node, item[1] + 1});\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369402,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn min_reverse_operations(n: i32, p: i32, banned: Vec<i32>, k: i32) -> Vec<i32> {\\n        let mut distances = vec![std::i32::MAX; n as usize];\\n        for &x in banned.iter() {\\n            distances[x as usize] = -1;\\n        }\\n        let mut nodes = Vec::new();\\n        let mut new_nodes = Vec::new();\\n        distances[p as usize] = 0;\\n        nodes.push(p);\\n        while !nodes.is_empty() {\\n            let mut i_min = std::i32::MAX;\\n            let mut i_max = std::i32::MIN;\\n            for &node in nodes.iter() {\\n                let base = node - k + 1;\\n                let j2i = |j| base + (j - base) * 2;\\n                let mut update = |i| {\\n                    if distances[i as usize] == std::i32::MAX {\\n                        distances[i as usize] = distances[node as usize] + 1;\\n                        new_nodes.push(i);\\n                    }\\n                };\\n                let lo = j2i(base.max(0));\\n                let hi = j2i((node + k).min(n) - k);\\n                for i in (lo..(i_min - 2).min(hi) + 1).step_by(2) {\\n                    update(i);\\n                }\\n                for i in ((i_max + 2).max(lo)..hi + 1).step_by(2) {\\n                    update(i);\\n                }\\n                i_min = i_min.min(lo);\\n                i_max = i_max.max(hi);\\n            }\\n            std::mem::swap(&mut nodes, &mut new_nodes);\\n            new_nodes.clear();\\n        }\\n        for x in distances.iter_mut() {\\n            if *x == std::i32::MAX {\\n                *x = -1;\\n            }\\n        }\\n        distances\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_reverse_operations(n: i32, p: i32, banned: Vec<i32>, k: i32) -> Vec<i32> {\\n        let mut distances = vec![std::i32::MAX; n as usize];\\n        for &x in banned.iter() {\\n            distances[x as usize] = -1;\\n        }\\n        let mut nodes = Vec::new();\\n        let mut new_nodes = Vec::new();\\n        distances[p as usize] = 0;\\n        nodes.push(p);\\n        while !nodes.is_empty() {\\n            let mut i_min = std::i32::MAX;\\n            let mut i_max = std::i32::MIN;\\n            for &node in nodes.iter() {\\n                let base = node - k + 1;\\n                let j2i = |j| base + (j - base) * 2;\\n                let mut update = |i| {\\n                    if distances[i as usize] == std::i32::MAX {\\n                        distances[i as usize] = distances[node as usize] + 1;\\n                        new_nodes.push(i);\\n                    }\\n                };\\n                let lo = j2i(base.max(0));\\n                let hi = j2i((node + k).min(n) - k);\\n                for i in (lo..(i_min - 2).min(hi) + 1).step_by(2) {\\n                    update(i);\\n                }\\n                for i in ((i_max + 2).max(lo)..hi + 1).step_by(2) {\\n                    update(i);\\n                }\\n                i_min = i_min.min(lo);\\n                i_max = i_max.max(hi);\\n            }\\n            std::mem::swap(&mut nodes, &mut new_nodes);\\n            new_nodes.clear();\\n        }\\n        for x in distances.iter_mut() {\\n            if *x == std::i32::MAX {\\n                *x = -1;\\n            }\\n        }\\n        distances\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3369074,
                "title": "my-solution",
                "content": "```\\nclass Solution {\\n public:\\n  vector<int> minReverseOperations(const int n, const int p, const vector<int> &banned, const int k) {\\n    bool banned_indices[n];\\n    memset(banned_indices, 0, sizeof(banned_indices));\\n    for (const int b : banned) {\\n      banned_indices[b] = true;\\n    }\\n    \\n    set<int> all_candidates[2];\\n    for (int i = 0; i < n; ++i) {\\n      if (!banned_indices[i] && i != p) {\\n        all_candidates[i % 2].emplace(i);\\n      }\\n    }\\n    vector<int> ret(n, -1);\\n    queue<int> q({p});\\n    int step = 0;\\n    ret[p] = step;\\n    while (!q.empty()) {\\n      ++step;\\n      for (size_t qs = q.size(); qs > 0; --qs) {\\n        const int index = q.front();\\n        q.pop();\\n        const int lower = 2 * max(0, index - k + 1) + k - index - 1;\\n        const int upper = 2 * (min(index + k, n) - k + 1) + k - index - 1;\\n        set<int> &candidates = all_candidates[lower % 2];\\n        for (auto itr = candidates.lower_bound(lower); itr != candidates.end() && *itr < upper; ) {\\n          ret[*itr] = step;\\n          q.emplace(*itr);\\n          itr = candidates.erase(itr);\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n public:\\n  vector<int> minReverseOperations(const int n, const int p, const vector<int> &banned, const int k) {\\n    bool banned_indices[n];\\n    memset(banned_indices, 0, sizeof(banned_indices));\\n    for (const int b : banned) {\\n      banned_indices[b] = true;\\n    }\\n    \\n    set<int> all_candidates[2];\\n    for (int i = 0; i < n; ++i) {\\n      if (!banned_indices[i] && i != p) {\\n        all_candidates[i % 2].emplace(i);\\n      }\\n    }\\n    vector<int> ret(n, -1);\\n    queue<int> q({p});\\n    int step = 0;\\n    ret[p] = step;\\n    while (!q.empty()) {\\n      ++step;\\n      for (size_t qs = q.size(); qs > 0; --qs) {\\n        const int index = q.front();\\n        q.pop();\\n        const int lower = 2 * max(0, index - k + 1) + k - index - 1;\\n        const int upper = 2 * (min(index + k, n) - k + 1) + k - index - 1;\\n        set<int> &candidates = all_candidates[lower % 2];\\n        for (auto itr = candidates.lower_bound(lower); itr != candidates.end() && *itr < upper; ) {\\n          ret[*itr] = step;\\n          q.emplace(*itr);\\n          itr = candidates.erase(itr);\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369053,
                "title": "c-fast-bfs-solution-beats-100",
                "content": "# Approach\\nIn this problem, vanilla BFS would be $$O(n^2)$$. Taking advantage of the fact that the range of neighbors of adjacent nodes mostly overlap, we can keep track of the ones already processed and avoid repeatedly processing them.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\nRuntime: 221 ms (currently beats 100%)\\nMemory Usage: 99.9 MB (currently beats 100%)\\nhttps://leetcode.com/submissions/detail/926416250/\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {\\n        vector<int> distances(n, INT_MAX);\\n        for (int x: banned) {\\n            distances[x] = -1;\\n        }\\n        \\n        vector<int> nodes, new_nodes;\\n        distances[p] = 0;\\n        nodes.push_back(p);\\n        \\n        while (nodes.size()) {\\n            int i_min = INT_MAX;\\n            int i_max = INT_MIN;\\n            \\n            for (int node: nodes) {\\n                int base = node - k + 1;\\n                \\n                // j: segment start position\\n                // i: update position\\n                auto j2i = [=](int j) {\\n                    return base + (j - base) * 2;\\n                };\\n                \\n                auto update = [&](int i) {\\n                    if (distances[i] == INT_MAX) {\\n                        distances[i] = distances[node] + 1;\\n                        new_nodes.push_back(i);\\n                    }\\n                };\\n                \\n                // inclusive\\n                int lo = j2i(max(0, base));\\n                int hi = j2i(min(node + k, n) - k);\\n                for (int i = lo; i <= min(hi, i_min-2); i += 2) update(i);\\n                for (int i = max(lo, i_max+2); i <= hi; i += 2) update(i);\\n                i_min = min(i_min, lo);\\n                i_max = max(i_max, hi);\\n            }\\n            \\n            swap(nodes, new_nodes);\\n            new_nodes.clear();\\n        }\\n        \\n        for (int &x: distances) {\\n            if (x == INT_MAX) x = -1;\\n        }\\n        return distances;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {\\n        vector<int> distances(n, INT_MAX);\\n        for (int x: banned) {\\n            distances[x] = -1;\\n        }\\n        \\n        vector<int> nodes, new_nodes;\\n        distances[p] = 0;\\n        nodes.push_back(p);\\n        \\n        while (nodes.size()) {\\n            int i_min = INT_MAX;\\n            int i_max = INT_MIN;\\n            \\n            for (int node: nodes) {\\n                int base = node - k + 1;\\n                \\n                // j: segment start position\\n                // i: update position\\n                auto j2i = [=](int j) {\\n                    return base + (j - base) * 2;\\n                };\\n                \\n                auto update = [&](int i) {\\n                    if (distances[i] == INT_MAX) {\\n                        distances[i] = distances[node] + 1;\\n                        new_nodes.push_back(i);\\n                    }\\n                };\\n                \\n                // inclusive\\n                int lo = j2i(max(0, base));\\n                int hi = j2i(min(node + k, n) - k);\\n                for (int i = lo; i <= min(hi, i_min-2); i += 2) update(i);\\n                for (int i = max(lo, i_max+2); i <= hi; i += 2) update(i);\\n                i_min = min(i_min, lo);\\n                i_max = max(i_max, hi);\\n            }\\n            \\n            swap(nodes, new_nodes);\\n            new_nodes.clear();\\n        }\\n        \\n        for (int &x: distances) {\\n            if (x == INT_MAX) x = -1;\\n        }\\n        return distances;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368795,
                "title": "bfs-with-optimizations",
                "content": "# Code\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def minReverseOperations(self, n: int, p: int, banned: List[int], k: int) -> List[int]:\\n        banned = set(banned)\\n        ans = [-1] * n\\n        for i in banned:\\n            ans[i] = -2\\n        \\n        un = [SortedList(), SortedList()]\\n        \\n        for i in range(n):\\n            if ans[i] != -2:\\n                un[i % 2].add(i)\\n        \\n        def getNei(i):\\n            nei = []\\n            # shrink the available range so that we dont need to loop so many rounds\\n            left = max(i - k + 1, k - i - 1)\\n            right = min(i+k, n - (i - n + k) + 1)\\n            \\n            # take the index from the correct list only, reduce half the time\\n            if k % 2 == i % 2:\\n                arr = un[1]\\n            else:\\n                arr = un[0]\\n            \\n            idx = arr.bisect_left(left)\\n            N = len(arr)\\n            for x in range(idx, N):\\n                j = arr[x]\\n                if j >= right: # out of range\\n                    break\\n                nei.append(j)\\n            \\n            return nei\\n                    \\n        ans[p] = 0\\n        q = deque([p])\\n        un[p % 2].remove(p)\\n\\n        # bfs with unvisited neighbors\\n        while q:\\n            node = q.popleft()\\n            dist = ans[node]\\n            for nei in getNei(node):\\n                q.append(nei)\\n                ans[nei] = dist+1\\n                un[nei % 2].remove(nei)\\n                    \\n        for i in banned:\\n            ans[i] = -1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def minReverseOperations(self, n: int, p: int, banned: List[int], k: int) -> List[int]:\\n        banned = set(banned)\\n        ans = [-1] * n\\n        for i in banned:\\n            ans[i] = -2\\n        \\n        un = [SortedList(), SortedList()]\\n        \\n        for i in range(n):\\n            if ans[i] != -2:\\n                un[i % 2].add(i)\\n        \\n        def getNei(i):\\n            nei = []\\n            # shrink the available range so that we dont need to loop so many rounds\\n            left = max(i - k + 1, k - i - 1)\\n            right = min(i+k, n - (i - n + k) + 1)\\n            \\n            # take the index from the correct list only, reduce half the time\\n            if k % 2 == i % 2:\\n                arr = un[1]\\n            else:\\n                arr = un[0]\\n            \\n            idx = arr.bisect_left(left)\\n            N = len(arr)\\n            for x in range(idx, N):\\n                j = arr[x]\\n                if j >= right: # out of range\\n                    break\\n                nei.append(j)\\n            \\n            return nei\\n                    \\n        ans[p] = 0\\n        q = deque([p])\\n        un[p % 2].remove(p)\\n\\n        # bfs with unvisited neighbors\\n        while q:\\n            node = q.popleft()\\n            dist = ans[node]\\n            for nei in getNei(node):\\n                q.append(nei)\\n                ans[nei] = dist+1\\n                un[nei % 2].remove(nei)\\n                    \\n        for i in banned:\\n            ans[i] = -1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368607,
                "title": "o-nlogn-throw-a-random-data-structure-and-pass-the-question",
                "content": "Clearly it is BFS, and it is easily to determine in a range which indexes are valid from this index (but be careful about parity). However, it isn\\'t clear about how to find the edges in BFS efficiently.\\n\\nSo I just throwed a segment tree on the question and passed. Actually we could just use a set but I was too lazy to think at that time.\\n\\n```cpp\\nconstexpr int MAXN = 1e5 + 5;\\nconstexpr int INF = 0x3f3f3f3f;\\n\\nint M;\\npair<int,int> segodd[MAXN << 2];\\npair<int,int> segeven[MAXN << 2];\\n\\ninline void maintain(int x) {\\n    segodd[x] = min(segodd[x << 1], segodd[x << 1 | 1]);\\n    segeven[x] = min(segeven[x << 1], segeven[x << 1 | 1]);\\n}\\n\\ninline void build(int N) {\\n    for (M = 1; M <= N + 1; M <<= 1);\\n    for (int i = M + 1; i <= 2 * M; i ++) {\\n        segodd[i] = segeven[i] = {0, i - M};\\n    }\\n    for (int i = M - 1; i >= 1; i --) {\\n        maintain(i);\\n    }\\n}\\n\\ninline void updodd(int x) {\\n    for (segodd[x += M].first = 1, x >>= 1; x; x >>= 1) {\\n        maintain(x);\\n    }\\n}\\n\\ninline void updeven(int x) {\\n    for (segeven[x += M].first = 1, x >>= 1; x; x >>= 1) {\\n        maintain(x);\\n    }\\n}\\n\\ninline pair<int,int> queryodd(int l, int r, int N) {\\n    if (l > r) {\\n        return {1, 0x3f3f3f3f};\\n    }\\n    if (l < 1) {\\n        l = 1;\\n    }\\n    if (r > N) {\\n        r = N;\\n    }\\n    pair<int,int> ans = {1, 0x3f3f3f3f};\\n    for (l += M - 1, r += M + 1; l ^ r ^ 1; l >>= 1,r >>= 1) {\\n        if (~l & 1) {\\n            ans = min(ans, segodd[l ^ 1]);\\n        }\\n        if (r & 1) {\\n            ans = min(ans, segodd[r ^ 1]);\\n        }\\n    }\\n    return ans;\\n}\\n\\ninline pair<int,int> queryeven(int l, int r, int N) {\\n    if (l > r) {\\n        return {1, 0x3f3f3f3f};\\n    }\\n    if (l < 1) {\\n        l = 1;\\n    }\\n    if (r > N) {\\n        r = N;\\n    }\\n    pair<int,int> ans = {1, 0x3f3f3f3f};\\n    for (l += M - 1, r += M + 1; l ^ r ^ 1; l >>= 1,r >>= 1) {\\n        if (~l & 1) {\\n            ans = min(ans, segeven[l ^ 1]);\\n        }\\n        if (r & 1) {\\n            ans = min(ans, segeven[r ^ 1]);\\n        }\\n    }\\n    return ans;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {\\n        p ++;\\n        build(n);\\n        if (p & 1) {\\n            updodd(p);\\n        } else {\\n            updeven(p);\\n        }\\n        \\n        \\n        vector<int> ans(n + 1, -1);\\n        for (auto x: banned) {\\n            ans[x + 1] = -1;\\n            if ((x + 1) & 1) {\\n                updodd(x + 1);\\n            } else {\\n                updeven(x + 1);\\n            }\\n        }\\n        for (int i = 1; i <= n; i ++) {\\n            if (i & 1) {\\n                updeven(i);\\n            } else {\\n                updodd(i);\\n            }\\n        }\\n        ans[p] = 0;\\n        \\n        queue<int> q;\\n        q.push(p);\\n        \\n        while (!q.empty()) {\\n            int on =q.front();\\n            int i = on;\\n            \\n            q.pop();\\n            \\n            int to = n - (k - (n - i + 1) + 1) + 1;\\n            int from = k - i + 1;\\n            to = min(to, i + k - 1);\\n            from = max(from, i - k + 1);\\n            \\n            if (k & 1) {\\n                if (i % 2 == 1) {\\n                    auto [a, b] = queryodd(from, to, n);\\n                    while (a == 0) {\\n                        q.push(b);\\n                        ans[b] = ans[on] + 1;\\n                        updodd(b);\\n                        auto [x, y] = queryodd(from, to, n);\\n                        a = x;\\n                        b = y;\\n                    }\\n                } else {\\n                    auto [a, b] = queryeven(from, to, n);\\n                    while (a == 0) {\\n                        q.push(b);\\n                        ans[b] = ans[on] + 1;\\n                        updeven(b);\\n                        auto [x, y] = queryeven(from, to, n);\\n                        a = x;\\n                        b = y;\\n                    }\\n                }\\n            } else {\\n                if (i % 2 == 1) {\\n                    auto [a, b] = queryeven(from, to, n);\\n                    while (a == 0) {\\n                        q.push(b);\\n                        ans[b] = ans[on] + 1;\\n                        updeven(b);\\n                        auto [x, y] = queryeven(from, to, n);\\n                        a = x;\\n                        b = y;\\n                    }\\n                } else {\\n                    auto [a, b] = queryodd(from, to, n);\\n                    while (a == 0) {\\n                        q.push(b);\\n                        ans[b] = ans[on] + 1;\\n                        updodd(b);\\n                        auto [x, y] = queryodd(from, to, n);\\n                        a = x;\\n                        b = y;\\n                    }\\n                }\\n            }\\n        }\\n        ans.erase(ans.begin());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nconstexpr int MAXN = 1e5 + 5;\\nconstexpr int INF = 0x3f3f3f3f;\\n\\nint M;\\npair<int,int> segodd[MAXN << 2];\\npair<int,int> segeven[MAXN << 2];\\n\\ninline void maintain(int x) {\\n    segodd[x] = min(segodd[x << 1], segodd[x << 1 | 1]);\\n    segeven[x] = min(segeven[x << 1], segeven[x << 1 | 1]);\\n}\\n\\ninline void build(int N) {\\n    for (M = 1; M <= N + 1; M <<= 1);\\n    for (int i = M + 1; i <= 2 * M; i ++) {\\n        segodd[i] = segeven[i] = {0, i - M};\\n    }\\n    for (int i = M - 1; i >= 1; i --) {\\n        maintain(i);\\n    }\\n}\\n\\ninline void updodd(int x) {\\n    for (segodd[x += M].first = 1, x >>= 1; x; x >>= 1) {\\n        maintain(x);\\n    }\\n}\\n\\ninline void updeven(int x) {\\n    for (segeven[x += M].first = 1, x >>= 1; x; x >>= 1) {\\n        maintain(x);\\n    }\\n}\\n\\ninline pair<int,int> queryodd(int l, int r, int N) {\\n    if (l > r) {\\n        return {1, 0x3f3f3f3f};\\n    }\\n    if (l < 1) {\\n        l = 1;\\n    }\\n    if (r > N) {\\n        r = N;\\n    }\\n    pair<int,int> ans = {1, 0x3f3f3f3f};\\n    for (l += M - 1, r += M + 1; l ^ r ^ 1; l >>= 1,r >>= 1) {\\n        if (~l & 1) {\\n            ans = min(ans, segodd[l ^ 1]);\\n        }\\n        if (r & 1) {\\n            ans = min(ans, segodd[r ^ 1]);\\n        }\\n    }\\n    return ans;\\n}\\n\\ninline pair<int,int> queryeven(int l, int r, int N) {\\n    if (l > r) {\\n        return {1, 0x3f3f3f3f};\\n    }\\n    if (l < 1) {\\n        l = 1;\\n    }\\n    if (r > N) {\\n        r = N;\\n    }\\n    pair<int,int> ans = {1, 0x3f3f3f3f};\\n    for (l += M - 1, r += M + 1; l ^ r ^ 1; l >>= 1,r >>= 1) {\\n        if (~l & 1) {\\n            ans = min(ans, segeven[l ^ 1]);\\n        }\\n        if (r & 1) {\\n            ans = min(ans, segeven[r ^ 1]);\\n        }\\n    }\\n    return ans;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) {\\n        p ++;\\n        build(n);\\n        if (p & 1) {\\n            updodd(p);\\n        } else {\\n            updeven(p);\\n        }\\n        \\n        \\n        vector<int> ans(n + 1, -1);\\n        for (auto x: banned) {\\n            ans[x + 1] = -1;\\n            if ((x + 1) & 1) {\\n                updodd(x + 1);\\n            } else {\\n                updeven(x + 1);\\n            }\\n        }\\n        for (int i = 1; i <= n; i ++) {\\n            if (i & 1) {\\n                updeven(i);\\n            } else {\\n                updodd(i);\\n            }\\n        }\\n        ans[p] = 0;\\n        \\n        queue<int> q;\\n        q.push(p);\\n        \\n        while (!q.empty()) {\\n            int on =q.front();\\n            int i = on;\\n            \\n            q.pop();\\n            \\n            int to = n - (k - (n - i + 1) + 1) + 1;\\n            int from = k - i + 1;\\n            to = min(to, i + k - 1);\\n            from = max(from, i - k + 1);\\n            \\n            if (k & 1) {\\n                if (i % 2 == 1) {\\n                    auto [a, b] = queryodd(from, to, n);\\n                    while (a == 0) {\\n                        q.push(b);\\n                        ans[b] = ans[on] + 1;\\n                        updodd(b);\\n                        auto [x, y] = queryodd(from, to, n);\\n                        a = x;\\n                        b = y;\\n                    }\\n                } else {\\n                    auto [a, b] = queryeven(from, to, n);\\n                    while (a == 0) {\\n                        q.push(b);\\n                        ans[b] = ans[on] + 1;\\n                        updeven(b);\\n                        auto [x, y] = queryeven(from, to, n);\\n                        a = x;\\n                        b = y;\\n                    }\\n                }\\n            } else {\\n                if (i % 2 == 1) {\\n                    auto [a, b] = queryeven(from, to, n);\\n                    while (a == 0) {\\n                        q.push(b);\\n                        ans[b] = ans[on] + 1;\\n                        updeven(b);\\n                        auto [x, y] = queryeven(from, to, n);\\n                        a = x;\\n                        b = y;\\n                    }\\n                } else {\\n                    auto [a, b] = queryodd(from, to, n);\\n                    while (a == 0) {\\n                        q.push(b);\\n                        ans[b] = ans[on] + 1;\\n                        updodd(b);\\n                        auto [x, y] = queryodd(from, to, n);\\n                        a = x;\\n                        b = y;\\n                    }\\n                }\\n            }\\n        }\\n        ans.erase(ans.begin());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368556,
                "title": "bfs-optimized-with-sortedlist",
                "content": "# Intuition\\nBFS, optimized to make sure that each unbanned position is only checked once.\\n\\n# Approach\\n1. Convert `banned` to `set` and add `p` to it: We don\\'t need to visit the starting position again.\\n2. Keep even & odd unbanned position separately in `SortedList`\\n3. BFS, but the tricky part is figuring out the rules of flipping subarrays. From position `i`, the relevant and admittable starting position of the subarray goes from `max(0, i - k + 1)` (leftmost) to `min(n - k, i)` (rightmost). Whether the flipped position falls to the left or right of `i` depends on whether the center of the subarray `(starting position) + (k - 1) / 2` falls to the left or right of `i`. Calculate the range of possible flipped positions accordingly.\\n4. Finally, parity also matters: if `k` is even, the flipped positions must have the opposite parity. if `k` is odd, the flipped positions must have the same parity. Traverse through the correct `SortedList` and add all the unbanned positions in the range to the next step.\\n5. Repeat till no new positions can be reached per standard BFS.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n \\\\log n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def minReverseOperations(self, n: int, p: int, banned: List[int], k: int) -> List[int]:\\n        banned = set(banned)\\n        banned.add(p)\\n        odd = k % 2\\n        odd_sl = SortedList(i for i in range(1, n, 2) if i not in banned)\\n        even_sl = SortedList(i for i in range(0, n, 2) if i not in banned)\\n        ans = [-1] * n\\n        ans[p] = 0\\n        curr = [p]\\n        step = 1\\n        while curr:\\n            new = []\\n            for i in curr:\\n                \\n                leftmost = max(0, i - k + 1)\\n                center2 = 2 * leftmost + k - 1\\n                leftmost = center2 - i\\n                \\n                rightmost = min(n - k, i)\\n                center2 = 2 * rightmost + k - 1\\n                rightmost = center2 - i\\n                \\n                odd_i = i % 2\\n                if odd:\\n                    target = odd_sl if odd_i else even_sl\\n                else:\\n                    target = even_sl if odd_i else odd_sl\\n                index = target.bisect_left(leftmost)\\n                while index < len(target) and target[index] <= rightmost:\\n                    next_i = target.pop(index)\\n                    ans[next_i] = step\\n                    new.append(next_i)\\n            curr = new\\n            step += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def minReverseOperations(self, n: int, p: int, banned: List[int], k: int) -> List[int]:\\n        banned = set(banned)\\n        banned.add(p)\\n        odd = k % 2\\n        odd_sl = SortedList(i for i in range(1, n, 2) if i not in banned)\\n        even_sl = SortedList(i for i in range(0, n, 2) if i not in banned)\\n        ans = [-1] * n\\n        ans[p] = 0\\n        curr = [p]\\n        step = 1\\n        while curr:\\n            new = []\\n            for i in curr:\\n                \\n                leftmost = max(0, i - k + 1)\\n                center2 = 2 * leftmost + k - 1\\n                leftmost = center2 - i\\n                \\n                rightmost = min(n - k, i)\\n                center2 = 2 * rightmost + k - 1\\n                rightmost = center2 - i\\n                \\n                odd_i = i % 2\\n                if odd:\\n                    target = odd_sl if odd_i else even_sl\\n                else:\\n                    target = even_sl if odd_i else odd_sl\\n                index = target.bisect_left(leftmost)\\n                while index < len(target) and target[index] <= rightmost:\\n                    next_i = target.pop(index)\\n                    ans[next_i] = step\\n                    new.append(next_i)\\n            curr = new\\n            step += 1\\n        return ans\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1851002,
                "content": [
                    {
                        "username": "Bharat_295",
                        "content": "My mind after seeing the acceptance in contest-: don\\'t even read! :)"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "people complaining Q3>>>>>>>>Q4 in previous contest. \\nLe Leetcode in Today\\'s contest: Q4>>>>>>>>>>>>>>>>>All questions on Leetcode"
                    },
                    {
                        "username": "EXBORN",
                        "content": "Tried BFS but TLE, apparently this is the approach most people took. Can\\'t think of an elegant way to improve time complexity."
                    },
                    {
                        "username": "Finesse",
                        "content": "Finally, I've found a way to optimize the BFS. Normally in BFS, when you walk from some node (array index), you check every reachable node, and visit only those that weren't visited. This approach takes `O(n*k)` time. To optimize it, you need to know the unvisited nodes without checking all the reachable somehow.\n\nMy idea is to use a BST (binary search tree) to store nodes that weren't visited, and remove the nodes from the tree as you perform the BFS. In fact, you need 2 trees: for even and odd array indices, otherwise it times-out. Thus, every node is not only visited once, but also checked once, the time complexity becomes `O(n*log(n))`.\n\nI can't call it elegant, because [my Python implementation](https://leetcode.com/problems/minimum-reverse-operations/submissions/926451022/) takes 140 lines, 115 of which are the tree implementation. But it's easy to grok because it's composed of smaller independent problems."
                    },
                    {
                        "username": "Finesse",
                        "content": "Trivial for odd `k`s, but none of my ideas works for even `k`s \\uD83E\\uDD2F"
                    },
                    {
                        "username": "mochy",
                        "content": "same :("
                    },
                    {
                        "username": "oystermajor",
                        "content": "Acceptance rate 1.8% lmao"
                    },
                    {
                        "username": "Finesse",
                        "content": "At least I don\\'t feel like an idiot after seeing the rate"
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Great problem, poorly written statement"
                    },
                    {
                        "username": "brinuke",
                        "content": "Yes, it needs a comma before *'representing a 0-indexed array'* and `arr[banned[i]] = 0` duplicates `banned[i] != p`."
                    },
                    {
                        "username": "prashik712",
                        "content": "I saw this question before the contest on Infosys power programmer OA 2 months back.  :\\'("
                    },
                    {
                        "username": "czjnbb",
                        "content": "1.7% acc rate. Lowest ever?"
                    },
                    {
                        "username": "darshanbhimani999",
                        "content": "This is correct solution. but i don\\'t know leetcode is doing which type of activity. try this in Vscode or else.\\n\\n/*Darshan Bhimani - Svnit*/\\n \\n#include <bits/stdc++.h>\\n#include <iostream>\\n#include <string.h>\\n#include <math.h>\\n#include <bitset>\\n#include <vector>\\nusing namespace std;\\n#define ff first\\n#define ull unsigned long long int \\n#define uld unsigned long double\\n#define ss second\\n#define ll long long \\n#define pb push_back\\n#define mp make_pair\\n#define FOR(i, a, b) for (ll i = a; i < b; i++)\\n#define RFOR(i, a, b) for (int i = a; i >= b; i--)\\n\\nvector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) \\n{\\n    vector<int> ans;\\n\\n    if(k==1)\\n    {\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==p)\\n            {\\n                ans.push_back(0);\\n            }\\n            else\\n            {\\n                ans.push_back(-1);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n    else if(k%2!=0)\\n    {\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(0);\\n            v.push_back(0);\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n        ans[p]=1;\\n        v[p]=1;\\n\\n        if(p%2==0)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(i%2!=0)\\n                {\\n                    ans[i]=-1;\\n                    v[i]=-1;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(i%2==0)\\n                {\\n                    ans[i]=-1;\\n                    v[i]=-1;\\n                }\\n            }\\n        }\\n\\n        int x=log(n);\\n        while(x--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(ans[i]==0)\\n                {\\n                    int a[k];\\n                    int p=0;\\n                    a[0]=i-k+1;\\n                    for(int j=1;j<k;j++)\\n                    {\\n                        a[j]=a[j-1]+2;\\n                    }\\n\\n                    for(int j=0;j<k;j++)\\n                    {\\n                        if((a[j]>=0 && ans[a[j]]==-1) || (a[j]<0) || (i==a[j]))\\n                        {\\n                            p++;\\n                        }\\n                        else if(a[j]>=0 && ans[a[j]]==1)\\n                        {\\n                            ans[i]=1;\\n\\n                            if(v[i]==0)\\n                            {\\n                                v[i]=v[a[j]]+1;\\n                            }\\n                            if(v[i]!=0)\\n                            {\\n                                v[i]=min(v[i],v[a[j]]+1);\\n                            }\\n                        }\\n                    }\\n\\n                    if(p==k)\\n                    {\\n                        v[i]=-1;\\n                        ans[i]=-1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if (v[i]>=0)\\n            {\\n                v[i]--;\\n            }\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n\\n        return v;\\n    }\\n    else\\n    {\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(0);\\n            v.push_back(0);\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n        ans[p]=1;\\n        v[p]=1;\\n\\n        int x=log(n);\\n        while(x--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(ans[i]==0)\\n                {\\n                    int a[k];\\n                    int p=0;\\n                    a[0]=i-k+1;\\n                    for(int j=1;j<k;j++)\\n                    {\\n                        a[j]=a[j-1]+2;\\n                    }\\n\\n                    for(int j=0;j<k;j++)\\n                    {\\n                        if((a[j]>=0 && ans[a[j]]==-1) || (a[j]<0) || (i==a[j]))\\n                        {\\n                            p++;\\n                        }\\n                        else if(a[j]>=0 && ans[a[j]]==1)\\n                        {\\n                            ans[i]=1;\\n\\n                            if(v[i]==0)\\n                            {\\n                                v[i]=v[a[j]]+1;\\n                            }\\n                            if(v[i]!=0)\\n                            {\\n                                v[i]=min(v[i],v[a[j]]+1);\\n                            }\\n                        }\\n                    }\\n\\n                    if(p==k)\\n                    {\\n                        v[i]=-1;\\n                        ans[i]=-1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if (v[i]>=0)\\n            {\\n                v[i]--;\\n            }\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n\\n        return v;\\n    }\\n}\\n\\nint main()\\n{\\n    int n,k,p,bs;\\n    vector<int> banned={1,2};\\n\\n    cin>>n;\\n    cin>>p;\\n    cin>>bs;\\n    FOR(i,0,bs)\\n    {\\n        int x;\\n        cin>>x;\\n        banned.push_back(x);\\n    }\\n    cin>>k;\\n\\n    vector<int> v=minReverseOperations(n,p,banned,k);\\n\\n    FOR(i,0,n)\\n    {\\n        cout<<v[i]<<\" \";\\n    }\\n\\n    cout<<endl;\\n}\\n\\n\\ngive input according to int main()."
                    },
                    {
                        "username": "PrathameshTheCoder",
                        "content": "I wrote complete code on basis of foundational programming knowledge(if else, for loop), but getting TLE"
                    },
                    {
                        "username": "janis__",
                        "content": "To solve this problem, you need to explore all possible nodes reachable from the starting point while considering the restrictions. Use a breadth-first search (BFS) approach, starting from the start_point, and at each step, calculate the possible nodes you can jump to within the given range. Keep track of visited nodes and their distances from the start to avoid redundant exploration and to determine the minimum number of operations needed to reach each node."
                    }
                ]
            },
            {
                "id": 1850958,
                "content": [
                    {
                        "username": "Bharat_295",
                        "content": "My mind after seeing the acceptance in contest-: don\\'t even read! :)"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "people complaining Q3>>>>>>>>Q4 in previous contest. \\nLe Leetcode in Today\\'s contest: Q4>>>>>>>>>>>>>>>>>All questions on Leetcode"
                    },
                    {
                        "username": "EXBORN",
                        "content": "Tried BFS but TLE, apparently this is the approach most people took. Can\\'t think of an elegant way to improve time complexity."
                    },
                    {
                        "username": "Finesse",
                        "content": "Finally, I've found a way to optimize the BFS. Normally in BFS, when you walk from some node (array index), you check every reachable node, and visit only those that weren't visited. This approach takes `O(n*k)` time. To optimize it, you need to know the unvisited nodes without checking all the reachable somehow.\n\nMy idea is to use a BST (binary search tree) to store nodes that weren't visited, and remove the nodes from the tree as you perform the BFS. In fact, you need 2 trees: for even and odd array indices, otherwise it times-out. Thus, every node is not only visited once, but also checked once, the time complexity becomes `O(n*log(n))`.\n\nI can't call it elegant, because [my Python implementation](https://leetcode.com/problems/minimum-reverse-operations/submissions/926451022/) takes 140 lines, 115 of which are the tree implementation. But it's easy to grok because it's composed of smaller independent problems."
                    },
                    {
                        "username": "Finesse",
                        "content": "Trivial for odd `k`s, but none of my ideas works for even `k`s \\uD83E\\uDD2F"
                    },
                    {
                        "username": "mochy",
                        "content": "same :("
                    },
                    {
                        "username": "oystermajor",
                        "content": "Acceptance rate 1.8% lmao"
                    },
                    {
                        "username": "Finesse",
                        "content": "At least I don\\'t feel like an idiot after seeing the rate"
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Great problem, poorly written statement"
                    },
                    {
                        "username": "brinuke",
                        "content": "Yes, it needs a comma before *'representing a 0-indexed array'* and `arr[banned[i]] = 0` duplicates `banned[i] != p`."
                    },
                    {
                        "username": "prashik712",
                        "content": "I saw this question before the contest on Infosys power programmer OA 2 months back.  :\\'("
                    },
                    {
                        "username": "czjnbb",
                        "content": "1.7% acc rate. Lowest ever?"
                    },
                    {
                        "username": "darshanbhimani999",
                        "content": "This is correct solution. but i don\\'t know leetcode is doing which type of activity. try this in Vscode or else.\\n\\n/*Darshan Bhimani - Svnit*/\\n \\n#include <bits/stdc++.h>\\n#include <iostream>\\n#include <string.h>\\n#include <math.h>\\n#include <bitset>\\n#include <vector>\\nusing namespace std;\\n#define ff first\\n#define ull unsigned long long int \\n#define uld unsigned long double\\n#define ss second\\n#define ll long long \\n#define pb push_back\\n#define mp make_pair\\n#define FOR(i, a, b) for (ll i = a; i < b; i++)\\n#define RFOR(i, a, b) for (int i = a; i >= b; i--)\\n\\nvector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) \\n{\\n    vector<int> ans;\\n\\n    if(k==1)\\n    {\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==p)\\n            {\\n                ans.push_back(0);\\n            }\\n            else\\n            {\\n                ans.push_back(-1);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n    else if(k%2!=0)\\n    {\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(0);\\n            v.push_back(0);\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n        ans[p]=1;\\n        v[p]=1;\\n\\n        if(p%2==0)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(i%2!=0)\\n                {\\n                    ans[i]=-1;\\n                    v[i]=-1;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(i%2==0)\\n                {\\n                    ans[i]=-1;\\n                    v[i]=-1;\\n                }\\n            }\\n        }\\n\\n        int x=log(n);\\n        while(x--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(ans[i]==0)\\n                {\\n                    int a[k];\\n                    int p=0;\\n                    a[0]=i-k+1;\\n                    for(int j=1;j<k;j++)\\n                    {\\n                        a[j]=a[j-1]+2;\\n                    }\\n\\n                    for(int j=0;j<k;j++)\\n                    {\\n                        if((a[j]>=0 && ans[a[j]]==-1) || (a[j]<0) || (i==a[j]))\\n                        {\\n                            p++;\\n                        }\\n                        else if(a[j]>=0 && ans[a[j]]==1)\\n                        {\\n                            ans[i]=1;\\n\\n                            if(v[i]==0)\\n                            {\\n                                v[i]=v[a[j]]+1;\\n                            }\\n                            if(v[i]!=0)\\n                            {\\n                                v[i]=min(v[i],v[a[j]]+1);\\n                            }\\n                        }\\n                    }\\n\\n                    if(p==k)\\n                    {\\n                        v[i]=-1;\\n                        ans[i]=-1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if (v[i]>=0)\\n            {\\n                v[i]--;\\n            }\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n\\n        return v;\\n    }\\n    else\\n    {\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(0);\\n            v.push_back(0);\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n        ans[p]=1;\\n        v[p]=1;\\n\\n        int x=log(n);\\n        while(x--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(ans[i]==0)\\n                {\\n                    int a[k];\\n                    int p=0;\\n                    a[0]=i-k+1;\\n                    for(int j=1;j<k;j++)\\n                    {\\n                        a[j]=a[j-1]+2;\\n                    }\\n\\n                    for(int j=0;j<k;j++)\\n                    {\\n                        if((a[j]>=0 && ans[a[j]]==-1) || (a[j]<0) || (i==a[j]))\\n                        {\\n                            p++;\\n                        }\\n                        else if(a[j]>=0 && ans[a[j]]==1)\\n                        {\\n                            ans[i]=1;\\n\\n                            if(v[i]==0)\\n                            {\\n                                v[i]=v[a[j]]+1;\\n                            }\\n                            if(v[i]!=0)\\n                            {\\n                                v[i]=min(v[i],v[a[j]]+1);\\n                            }\\n                        }\\n                    }\\n\\n                    if(p==k)\\n                    {\\n                        v[i]=-1;\\n                        ans[i]=-1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if (v[i]>=0)\\n            {\\n                v[i]--;\\n            }\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n\\n        return v;\\n    }\\n}\\n\\nint main()\\n{\\n    int n,k,p,bs;\\n    vector<int> banned={1,2};\\n\\n    cin>>n;\\n    cin>>p;\\n    cin>>bs;\\n    FOR(i,0,bs)\\n    {\\n        int x;\\n        cin>>x;\\n        banned.push_back(x);\\n    }\\n    cin>>k;\\n\\n    vector<int> v=minReverseOperations(n,p,banned,k);\\n\\n    FOR(i,0,n)\\n    {\\n        cout<<v[i]<<\" \";\\n    }\\n\\n    cout<<endl;\\n}\\n\\n\\ngive input according to int main()."
                    },
                    {
                        "username": "PrathameshTheCoder",
                        "content": "I wrote complete code on basis of foundational programming knowledge(if else, for loop), but getting TLE"
                    },
                    {
                        "username": "janis__",
                        "content": "To solve this problem, you need to explore all possible nodes reachable from the starting point while considering the restrictions. Use a breadth-first search (BFS) approach, starting from the start_point, and at each step, calculate the possible nodes you can jump to within the given range. Keep track of visited nodes and their distances from the start to avoid redundant exploration and to determine the minimum number of operations needed to reach each node."
                    }
                ]
            },
            {
                "id": 1850931,
                "content": [
                    {
                        "username": "Bharat_295",
                        "content": "My mind after seeing the acceptance in contest-: don\\'t even read! :)"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "people complaining Q3>>>>>>>>Q4 in previous contest. \\nLe Leetcode in Today\\'s contest: Q4>>>>>>>>>>>>>>>>>All questions on Leetcode"
                    },
                    {
                        "username": "EXBORN",
                        "content": "Tried BFS but TLE, apparently this is the approach most people took. Can\\'t think of an elegant way to improve time complexity."
                    },
                    {
                        "username": "Finesse",
                        "content": "Finally, I've found a way to optimize the BFS. Normally in BFS, when you walk from some node (array index), you check every reachable node, and visit only those that weren't visited. This approach takes `O(n*k)` time. To optimize it, you need to know the unvisited nodes without checking all the reachable somehow.\n\nMy idea is to use a BST (binary search tree) to store nodes that weren't visited, and remove the nodes from the tree as you perform the BFS. In fact, you need 2 trees: for even and odd array indices, otherwise it times-out. Thus, every node is not only visited once, but also checked once, the time complexity becomes `O(n*log(n))`.\n\nI can't call it elegant, because [my Python implementation](https://leetcode.com/problems/minimum-reverse-operations/submissions/926451022/) takes 140 lines, 115 of which are the tree implementation. But it's easy to grok because it's composed of smaller independent problems."
                    },
                    {
                        "username": "Finesse",
                        "content": "Trivial for odd `k`s, but none of my ideas works for even `k`s \\uD83E\\uDD2F"
                    },
                    {
                        "username": "mochy",
                        "content": "same :("
                    },
                    {
                        "username": "oystermajor",
                        "content": "Acceptance rate 1.8% lmao"
                    },
                    {
                        "username": "Finesse",
                        "content": "At least I don\\'t feel like an idiot after seeing the rate"
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Great problem, poorly written statement"
                    },
                    {
                        "username": "brinuke",
                        "content": "Yes, it needs a comma before *'representing a 0-indexed array'* and `arr[banned[i]] = 0` duplicates `banned[i] != p`."
                    },
                    {
                        "username": "prashik712",
                        "content": "I saw this question before the contest on Infosys power programmer OA 2 months back.  :\\'("
                    },
                    {
                        "username": "czjnbb",
                        "content": "1.7% acc rate. Lowest ever?"
                    },
                    {
                        "username": "darshanbhimani999",
                        "content": "This is correct solution. but i don\\'t know leetcode is doing which type of activity. try this in Vscode or else.\\n\\n/*Darshan Bhimani - Svnit*/\\n \\n#include <bits/stdc++.h>\\n#include <iostream>\\n#include <string.h>\\n#include <math.h>\\n#include <bitset>\\n#include <vector>\\nusing namespace std;\\n#define ff first\\n#define ull unsigned long long int \\n#define uld unsigned long double\\n#define ss second\\n#define ll long long \\n#define pb push_back\\n#define mp make_pair\\n#define FOR(i, a, b) for (ll i = a; i < b; i++)\\n#define RFOR(i, a, b) for (int i = a; i >= b; i--)\\n\\nvector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) \\n{\\n    vector<int> ans;\\n\\n    if(k==1)\\n    {\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==p)\\n            {\\n                ans.push_back(0);\\n            }\\n            else\\n            {\\n                ans.push_back(-1);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n    else if(k%2!=0)\\n    {\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(0);\\n            v.push_back(0);\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n        ans[p]=1;\\n        v[p]=1;\\n\\n        if(p%2==0)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(i%2!=0)\\n                {\\n                    ans[i]=-1;\\n                    v[i]=-1;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(i%2==0)\\n                {\\n                    ans[i]=-1;\\n                    v[i]=-1;\\n                }\\n            }\\n        }\\n\\n        int x=log(n);\\n        while(x--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(ans[i]==0)\\n                {\\n                    int a[k];\\n                    int p=0;\\n                    a[0]=i-k+1;\\n                    for(int j=1;j<k;j++)\\n                    {\\n                        a[j]=a[j-1]+2;\\n                    }\\n\\n                    for(int j=0;j<k;j++)\\n                    {\\n                        if((a[j]>=0 && ans[a[j]]==-1) || (a[j]<0) || (i==a[j]))\\n                        {\\n                            p++;\\n                        }\\n                        else if(a[j]>=0 && ans[a[j]]==1)\\n                        {\\n                            ans[i]=1;\\n\\n                            if(v[i]==0)\\n                            {\\n                                v[i]=v[a[j]]+1;\\n                            }\\n                            if(v[i]!=0)\\n                            {\\n                                v[i]=min(v[i],v[a[j]]+1);\\n                            }\\n                        }\\n                    }\\n\\n                    if(p==k)\\n                    {\\n                        v[i]=-1;\\n                        ans[i]=-1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if (v[i]>=0)\\n            {\\n                v[i]--;\\n            }\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n\\n        return v;\\n    }\\n    else\\n    {\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(0);\\n            v.push_back(0);\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n        ans[p]=1;\\n        v[p]=1;\\n\\n        int x=log(n);\\n        while(x--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(ans[i]==0)\\n                {\\n                    int a[k];\\n                    int p=0;\\n                    a[0]=i-k+1;\\n                    for(int j=1;j<k;j++)\\n                    {\\n                        a[j]=a[j-1]+2;\\n                    }\\n\\n                    for(int j=0;j<k;j++)\\n                    {\\n                        if((a[j]>=0 && ans[a[j]]==-1) || (a[j]<0) || (i==a[j]))\\n                        {\\n                            p++;\\n                        }\\n                        else if(a[j]>=0 && ans[a[j]]==1)\\n                        {\\n                            ans[i]=1;\\n\\n                            if(v[i]==0)\\n                            {\\n                                v[i]=v[a[j]]+1;\\n                            }\\n                            if(v[i]!=0)\\n                            {\\n                                v[i]=min(v[i],v[a[j]]+1);\\n                            }\\n                        }\\n                    }\\n\\n                    if(p==k)\\n                    {\\n                        v[i]=-1;\\n                        ans[i]=-1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if (v[i]>=0)\\n            {\\n                v[i]--;\\n            }\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n\\n        return v;\\n    }\\n}\\n\\nint main()\\n{\\n    int n,k,p,bs;\\n    vector<int> banned={1,2};\\n\\n    cin>>n;\\n    cin>>p;\\n    cin>>bs;\\n    FOR(i,0,bs)\\n    {\\n        int x;\\n        cin>>x;\\n        banned.push_back(x);\\n    }\\n    cin>>k;\\n\\n    vector<int> v=minReverseOperations(n,p,banned,k);\\n\\n    FOR(i,0,n)\\n    {\\n        cout<<v[i]<<\" \";\\n    }\\n\\n    cout<<endl;\\n}\\n\\n\\ngive input according to int main()."
                    },
                    {
                        "username": "PrathameshTheCoder",
                        "content": "I wrote complete code on basis of foundational programming knowledge(if else, for loop), but getting TLE"
                    },
                    {
                        "username": "janis__",
                        "content": "To solve this problem, you need to explore all possible nodes reachable from the starting point while considering the restrictions. Use a breadth-first search (BFS) approach, starting from the start_point, and at each step, calculate the possible nodes you can jump to within the given range. Keep track of visited nodes and their distances from the start to avoid redundant exploration and to determine the minimum number of operations needed to reach each node."
                    }
                ]
            },
            {
                "id": 1850877,
                "content": [
                    {
                        "username": "Bharat_295",
                        "content": "My mind after seeing the acceptance in contest-: don\\'t even read! :)"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "people complaining Q3>>>>>>>>Q4 in previous contest. \\nLe Leetcode in Today\\'s contest: Q4>>>>>>>>>>>>>>>>>All questions on Leetcode"
                    },
                    {
                        "username": "EXBORN",
                        "content": "Tried BFS but TLE, apparently this is the approach most people took. Can\\'t think of an elegant way to improve time complexity."
                    },
                    {
                        "username": "Finesse",
                        "content": "Finally, I've found a way to optimize the BFS. Normally in BFS, when you walk from some node (array index), you check every reachable node, and visit only those that weren't visited. This approach takes `O(n*k)` time. To optimize it, you need to know the unvisited nodes without checking all the reachable somehow.\n\nMy idea is to use a BST (binary search tree) to store nodes that weren't visited, and remove the nodes from the tree as you perform the BFS. In fact, you need 2 trees: for even and odd array indices, otherwise it times-out. Thus, every node is not only visited once, but also checked once, the time complexity becomes `O(n*log(n))`.\n\nI can't call it elegant, because [my Python implementation](https://leetcode.com/problems/minimum-reverse-operations/submissions/926451022/) takes 140 lines, 115 of which are the tree implementation. But it's easy to grok because it's composed of smaller independent problems."
                    },
                    {
                        "username": "Finesse",
                        "content": "Trivial for odd `k`s, but none of my ideas works for even `k`s \\uD83E\\uDD2F"
                    },
                    {
                        "username": "mochy",
                        "content": "same :("
                    },
                    {
                        "username": "oystermajor",
                        "content": "Acceptance rate 1.8% lmao"
                    },
                    {
                        "username": "Finesse",
                        "content": "At least I don\\'t feel like an idiot after seeing the rate"
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Great problem, poorly written statement"
                    },
                    {
                        "username": "brinuke",
                        "content": "Yes, it needs a comma before *'representing a 0-indexed array'* and `arr[banned[i]] = 0` duplicates `banned[i] != p`."
                    },
                    {
                        "username": "prashik712",
                        "content": "I saw this question before the contest on Infosys power programmer OA 2 months back.  :\\'("
                    },
                    {
                        "username": "czjnbb",
                        "content": "1.7% acc rate. Lowest ever?"
                    },
                    {
                        "username": "darshanbhimani999",
                        "content": "This is correct solution. but i don\\'t know leetcode is doing which type of activity. try this in Vscode or else.\\n\\n/*Darshan Bhimani - Svnit*/\\n \\n#include <bits/stdc++.h>\\n#include <iostream>\\n#include <string.h>\\n#include <math.h>\\n#include <bitset>\\n#include <vector>\\nusing namespace std;\\n#define ff first\\n#define ull unsigned long long int \\n#define uld unsigned long double\\n#define ss second\\n#define ll long long \\n#define pb push_back\\n#define mp make_pair\\n#define FOR(i, a, b) for (ll i = a; i < b; i++)\\n#define RFOR(i, a, b) for (int i = a; i >= b; i--)\\n\\nvector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) \\n{\\n    vector<int> ans;\\n\\n    if(k==1)\\n    {\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==p)\\n            {\\n                ans.push_back(0);\\n            }\\n            else\\n            {\\n                ans.push_back(-1);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n    else if(k%2!=0)\\n    {\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(0);\\n            v.push_back(0);\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n        ans[p]=1;\\n        v[p]=1;\\n\\n        if(p%2==0)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(i%2!=0)\\n                {\\n                    ans[i]=-1;\\n                    v[i]=-1;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(i%2==0)\\n                {\\n                    ans[i]=-1;\\n                    v[i]=-1;\\n                }\\n            }\\n        }\\n\\n        int x=log(n);\\n        while(x--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(ans[i]==0)\\n                {\\n                    int a[k];\\n                    int p=0;\\n                    a[0]=i-k+1;\\n                    for(int j=1;j<k;j++)\\n                    {\\n                        a[j]=a[j-1]+2;\\n                    }\\n\\n                    for(int j=0;j<k;j++)\\n                    {\\n                        if((a[j]>=0 && ans[a[j]]==-1) || (a[j]<0) || (i==a[j]))\\n                        {\\n                            p++;\\n                        }\\n                        else if(a[j]>=0 && ans[a[j]]==1)\\n                        {\\n                            ans[i]=1;\\n\\n                            if(v[i]==0)\\n                            {\\n                                v[i]=v[a[j]]+1;\\n                            }\\n                            if(v[i]!=0)\\n                            {\\n                                v[i]=min(v[i],v[a[j]]+1);\\n                            }\\n                        }\\n                    }\\n\\n                    if(p==k)\\n                    {\\n                        v[i]=-1;\\n                        ans[i]=-1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if (v[i]>=0)\\n            {\\n                v[i]--;\\n            }\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n\\n        return v;\\n    }\\n    else\\n    {\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(0);\\n            v.push_back(0);\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n        ans[p]=1;\\n        v[p]=1;\\n\\n        int x=log(n);\\n        while(x--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(ans[i]==0)\\n                {\\n                    int a[k];\\n                    int p=0;\\n                    a[0]=i-k+1;\\n                    for(int j=1;j<k;j++)\\n                    {\\n                        a[j]=a[j-1]+2;\\n                    }\\n\\n                    for(int j=0;j<k;j++)\\n                    {\\n                        if((a[j]>=0 && ans[a[j]]==-1) || (a[j]<0) || (i==a[j]))\\n                        {\\n                            p++;\\n                        }\\n                        else if(a[j]>=0 && ans[a[j]]==1)\\n                        {\\n                            ans[i]=1;\\n\\n                            if(v[i]==0)\\n                            {\\n                                v[i]=v[a[j]]+1;\\n                            }\\n                            if(v[i]!=0)\\n                            {\\n                                v[i]=min(v[i],v[a[j]]+1);\\n                            }\\n                        }\\n                    }\\n\\n                    if(p==k)\\n                    {\\n                        v[i]=-1;\\n                        ans[i]=-1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if (v[i]>=0)\\n            {\\n                v[i]--;\\n            }\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n\\n        return v;\\n    }\\n}\\n\\nint main()\\n{\\n    int n,k,p,bs;\\n    vector<int> banned={1,2};\\n\\n    cin>>n;\\n    cin>>p;\\n    cin>>bs;\\n    FOR(i,0,bs)\\n    {\\n        int x;\\n        cin>>x;\\n        banned.push_back(x);\\n    }\\n    cin>>k;\\n\\n    vector<int> v=minReverseOperations(n,p,banned,k);\\n\\n    FOR(i,0,n)\\n    {\\n        cout<<v[i]<<\" \";\\n    }\\n\\n    cout<<endl;\\n}\\n\\n\\ngive input according to int main()."
                    },
                    {
                        "username": "PrathameshTheCoder",
                        "content": "I wrote complete code on basis of foundational programming knowledge(if else, for loop), but getting TLE"
                    },
                    {
                        "username": "janis__",
                        "content": "To solve this problem, you need to explore all possible nodes reachable from the starting point while considering the restrictions. Use a breadth-first search (BFS) approach, starting from the start_point, and at each step, calculate the possible nodes you can jump to within the given range. Keep track of visited nodes and their distances from the start to avoid redundant exploration and to determine the minimum number of operations needed to reach each node."
                    }
                ]
            },
            {
                "id": 1851125,
                "content": [
                    {
                        "username": "Bharat_295",
                        "content": "My mind after seeing the acceptance in contest-: don\\'t even read! :)"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "people complaining Q3>>>>>>>>Q4 in previous contest. \\nLe Leetcode in Today\\'s contest: Q4>>>>>>>>>>>>>>>>>All questions on Leetcode"
                    },
                    {
                        "username": "EXBORN",
                        "content": "Tried BFS but TLE, apparently this is the approach most people took. Can\\'t think of an elegant way to improve time complexity."
                    },
                    {
                        "username": "Finesse",
                        "content": "Finally, I've found a way to optimize the BFS. Normally in BFS, when you walk from some node (array index), you check every reachable node, and visit only those that weren't visited. This approach takes `O(n*k)` time. To optimize it, you need to know the unvisited nodes without checking all the reachable somehow.\n\nMy idea is to use a BST (binary search tree) to store nodes that weren't visited, and remove the nodes from the tree as you perform the BFS. In fact, you need 2 trees: for even and odd array indices, otherwise it times-out. Thus, every node is not only visited once, but also checked once, the time complexity becomes `O(n*log(n))`.\n\nI can't call it elegant, because [my Python implementation](https://leetcode.com/problems/minimum-reverse-operations/submissions/926451022/) takes 140 lines, 115 of which are the tree implementation. But it's easy to grok because it's composed of smaller independent problems."
                    },
                    {
                        "username": "Finesse",
                        "content": "Trivial for odd `k`s, but none of my ideas works for even `k`s \\uD83E\\uDD2F"
                    },
                    {
                        "username": "mochy",
                        "content": "same :("
                    },
                    {
                        "username": "oystermajor",
                        "content": "Acceptance rate 1.8% lmao"
                    },
                    {
                        "username": "Finesse",
                        "content": "At least I don\\'t feel like an idiot after seeing the rate"
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Great problem, poorly written statement"
                    },
                    {
                        "username": "brinuke",
                        "content": "Yes, it needs a comma before *'representing a 0-indexed array'* and `arr[banned[i]] = 0` duplicates `banned[i] != p`."
                    },
                    {
                        "username": "prashik712",
                        "content": "I saw this question before the contest on Infosys power programmer OA 2 months back.  :\\'("
                    },
                    {
                        "username": "czjnbb",
                        "content": "1.7% acc rate. Lowest ever?"
                    },
                    {
                        "username": "darshanbhimani999",
                        "content": "This is correct solution. but i don\\'t know leetcode is doing which type of activity. try this in Vscode or else.\\n\\n/*Darshan Bhimani - Svnit*/\\n \\n#include <bits/stdc++.h>\\n#include <iostream>\\n#include <string.h>\\n#include <math.h>\\n#include <bitset>\\n#include <vector>\\nusing namespace std;\\n#define ff first\\n#define ull unsigned long long int \\n#define uld unsigned long double\\n#define ss second\\n#define ll long long \\n#define pb push_back\\n#define mp make_pair\\n#define FOR(i, a, b) for (ll i = a; i < b; i++)\\n#define RFOR(i, a, b) for (int i = a; i >= b; i--)\\n\\nvector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) \\n{\\n    vector<int> ans;\\n\\n    if(k==1)\\n    {\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==p)\\n            {\\n                ans.push_back(0);\\n            }\\n            else\\n            {\\n                ans.push_back(-1);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n    else if(k%2!=0)\\n    {\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(0);\\n            v.push_back(0);\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n        ans[p]=1;\\n        v[p]=1;\\n\\n        if(p%2==0)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(i%2!=0)\\n                {\\n                    ans[i]=-1;\\n                    v[i]=-1;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(i%2==0)\\n                {\\n                    ans[i]=-1;\\n                    v[i]=-1;\\n                }\\n            }\\n        }\\n\\n        int x=log(n);\\n        while(x--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(ans[i]==0)\\n                {\\n                    int a[k];\\n                    int p=0;\\n                    a[0]=i-k+1;\\n                    for(int j=1;j<k;j++)\\n                    {\\n                        a[j]=a[j-1]+2;\\n                    }\\n\\n                    for(int j=0;j<k;j++)\\n                    {\\n                        if((a[j]>=0 && ans[a[j]]==-1) || (a[j]<0) || (i==a[j]))\\n                        {\\n                            p++;\\n                        }\\n                        else if(a[j]>=0 && ans[a[j]]==1)\\n                        {\\n                            ans[i]=1;\\n\\n                            if(v[i]==0)\\n                            {\\n                                v[i]=v[a[j]]+1;\\n                            }\\n                            if(v[i]!=0)\\n                            {\\n                                v[i]=min(v[i],v[a[j]]+1);\\n                            }\\n                        }\\n                    }\\n\\n                    if(p==k)\\n                    {\\n                        v[i]=-1;\\n                        ans[i]=-1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if (v[i]>=0)\\n            {\\n                v[i]--;\\n            }\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n\\n        return v;\\n    }\\n    else\\n    {\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(0);\\n            v.push_back(0);\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n        ans[p]=1;\\n        v[p]=1;\\n\\n        int x=log(n);\\n        while(x--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(ans[i]==0)\\n                {\\n                    int a[k];\\n                    int p=0;\\n                    a[0]=i-k+1;\\n                    for(int j=1;j<k;j++)\\n                    {\\n                        a[j]=a[j-1]+2;\\n                    }\\n\\n                    for(int j=0;j<k;j++)\\n                    {\\n                        if((a[j]>=0 && ans[a[j]]==-1) || (a[j]<0) || (i==a[j]))\\n                        {\\n                            p++;\\n                        }\\n                        else if(a[j]>=0 && ans[a[j]]==1)\\n                        {\\n                            ans[i]=1;\\n\\n                            if(v[i]==0)\\n                            {\\n                                v[i]=v[a[j]]+1;\\n                            }\\n                            if(v[i]!=0)\\n                            {\\n                                v[i]=min(v[i],v[a[j]]+1);\\n                            }\\n                        }\\n                    }\\n\\n                    if(p==k)\\n                    {\\n                        v[i]=-1;\\n                        ans[i]=-1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if (v[i]>=0)\\n            {\\n                v[i]--;\\n            }\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n\\n        return v;\\n    }\\n}\\n\\nint main()\\n{\\n    int n,k,p,bs;\\n    vector<int> banned={1,2};\\n\\n    cin>>n;\\n    cin>>p;\\n    cin>>bs;\\n    FOR(i,0,bs)\\n    {\\n        int x;\\n        cin>>x;\\n        banned.push_back(x);\\n    }\\n    cin>>k;\\n\\n    vector<int> v=minReverseOperations(n,p,banned,k);\\n\\n    FOR(i,0,n)\\n    {\\n        cout<<v[i]<<\" \";\\n    }\\n\\n    cout<<endl;\\n}\\n\\n\\ngive input according to int main()."
                    },
                    {
                        "username": "PrathameshTheCoder",
                        "content": "I wrote complete code on basis of foundational programming knowledge(if else, for loop), but getting TLE"
                    },
                    {
                        "username": "janis__",
                        "content": "To solve this problem, you need to explore all possible nodes reachable from the starting point while considering the restrictions. Use a breadth-first search (BFS) approach, starting from the start_point, and at each step, calculate the possible nodes you can jump to within the given range. Keep track of visited nodes and their distances from the start to avoid redundant exploration and to determine the minimum number of operations needed to reach each node."
                    }
                ]
            },
            {
                "id": 1853551,
                "content": [
                    {
                        "username": "Bharat_295",
                        "content": "My mind after seeing the acceptance in contest-: don\\'t even read! :)"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "people complaining Q3>>>>>>>>Q4 in previous contest. \\nLe Leetcode in Today\\'s contest: Q4>>>>>>>>>>>>>>>>>All questions on Leetcode"
                    },
                    {
                        "username": "EXBORN",
                        "content": "Tried BFS but TLE, apparently this is the approach most people took. Can\\'t think of an elegant way to improve time complexity."
                    },
                    {
                        "username": "Finesse",
                        "content": "Finally, I've found a way to optimize the BFS. Normally in BFS, when you walk from some node (array index), you check every reachable node, and visit only those that weren't visited. This approach takes `O(n*k)` time. To optimize it, you need to know the unvisited nodes without checking all the reachable somehow.\n\nMy idea is to use a BST (binary search tree) to store nodes that weren't visited, and remove the nodes from the tree as you perform the BFS. In fact, you need 2 trees: for even and odd array indices, otherwise it times-out. Thus, every node is not only visited once, but also checked once, the time complexity becomes `O(n*log(n))`.\n\nI can't call it elegant, because [my Python implementation](https://leetcode.com/problems/minimum-reverse-operations/submissions/926451022/) takes 140 lines, 115 of which are the tree implementation. But it's easy to grok because it's composed of smaller independent problems."
                    },
                    {
                        "username": "Finesse",
                        "content": "Trivial for odd `k`s, but none of my ideas works for even `k`s \\uD83E\\uDD2F"
                    },
                    {
                        "username": "mochy",
                        "content": "same :("
                    },
                    {
                        "username": "oystermajor",
                        "content": "Acceptance rate 1.8% lmao"
                    },
                    {
                        "username": "Finesse",
                        "content": "At least I don\\'t feel like an idiot after seeing the rate"
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Great problem, poorly written statement"
                    },
                    {
                        "username": "brinuke",
                        "content": "Yes, it needs a comma before *'representing a 0-indexed array'* and `arr[banned[i]] = 0` duplicates `banned[i] != p`."
                    },
                    {
                        "username": "prashik712",
                        "content": "I saw this question before the contest on Infosys power programmer OA 2 months back.  :\\'("
                    },
                    {
                        "username": "czjnbb",
                        "content": "1.7% acc rate. Lowest ever?"
                    },
                    {
                        "username": "darshanbhimani999",
                        "content": "This is correct solution. but i don\\'t know leetcode is doing which type of activity. try this in Vscode or else.\\n\\n/*Darshan Bhimani - Svnit*/\\n \\n#include <bits/stdc++.h>\\n#include <iostream>\\n#include <string.h>\\n#include <math.h>\\n#include <bitset>\\n#include <vector>\\nusing namespace std;\\n#define ff first\\n#define ull unsigned long long int \\n#define uld unsigned long double\\n#define ss second\\n#define ll long long \\n#define pb push_back\\n#define mp make_pair\\n#define FOR(i, a, b) for (ll i = a; i < b; i++)\\n#define RFOR(i, a, b) for (int i = a; i >= b; i--)\\n\\nvector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) \\n{\\n    vector<int> ans;\\n\\n    if(k==1)\\n    {\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==p)\\n            {\\n                ans.push_back(0);\\n            }\\n            else\\n            {\\n                ans.push_back(-1);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n    else if(k%2!=0)\\n    {\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(0);\\n            v.push_back(0);\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n        ans[p]=1;\\n        v[p]=1;\\n\\n        if(p%2==0)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(i%2!=0)\\n                {\\n                    ans[i]=-1;\\n                    v[i]=-1;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(i%2==0)\\n                {\\n                    ans[i]=-1;\\n                    v[i]=-1;\\n                }\\n            }\\n        }\\n\\n        int x=log(n);\\n        while(x--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(ans[i]==0)\\n                {\\n                    int a[k];\\n                    int p=0;\\n                    a[0]=i-k+1;\\n                    for(int j=1;j<k;j++)\\n                    {\\n                        a[j]=a[j-1]+2;\\n                    }\\n\\n                    for(int j=0;j<k;j++)\\n                    {\\n                        if((a[j]>=0 && ans[a[j]]==-1) || (a[j]<0) || (i==a[j]))\\n                        {\\n                            p++;\\n                        }\\n                        else if(a[j]>=0 && ans[a[j]]==1)\\n                        {\\n                            ans[i]=1;\\n\\n                            if(v[i]==0)\\n                            {\\n                                v[i]=v[a[j]]+1;\\n                            }\\n                            if(v[i]!=0)\\n                            {\\n                                v[i]=min(v[i],v[a[j]]+1);\\n                            }\\n                        }\\n                    }\\n\\n                    if(p==k)\\n                    {\\n                        v[i]=-1;\\n                        ans[i]=-1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if (v[i]>=0)\\n            {\\n                v[i]--;\\n            }\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n\\n        return v;\\n    }\\n    else\\n    {\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(0);\\n            v.push_back(0);\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n        ans[p]=1;\\n        v[p]=1;\\n\\n        int x=log(n);\\n        while(x--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(ans[i]==0)\\n                {\\n                    int a[k];\\n                    int p=0;\\n                    a[0]=i-k+1;\\n                    for(int j=1;j<k;j++)\\n                    {\\n                        a[j]=a[j-1]+2;\\n                    }\\n\\n                    for(int j=0;j<k;j++)\\n                    {\\n                        if((a[j]>=0 && ans[a[j]]==-1) || (a[j]<0) || (i==a[j]))\\n                        {\\n                            p++;\\n                        }\\n                        else if(a[j]>=0 && ans[a[j]]==1)\\n                        {\\n                            ans[i]=1;\\n\\n                            if(v[i]==0)\\n                            {\\n                                v[i]=v[a[j]]+1;\\n                            }\\n                            if(v[i]!=0)\\n                            {\\n                                v[i]=min(v[i],v[a[j]]+1);\\n                            }\\n                        }\\n                    }\\n\\n                    if(p==k)\\n                    {\\n                        v[i]=-1;\\n                        ans[i]=-1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if (v[i]>=0)\\n            {\\n                v[i]--;\\n            }\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n\\n        return v;\\n    }\\n}\\n\\nint main()\\n{\\n    int n,k,p,bs;\\n    vector<int> banned={1,2};\\n\\n    cin>>n;\\n    cin>>p;\\n    cin>>bs;\\n    FOR(i,0,bs)\\n    {\\n        int x;\\n        cin>>x;\\n        banned.push_back(x);\\n    }\\n    cin>>k;\\n\\n    vector<int> v=minReverseOperations(n,p,banned,k);\\n\\n    FOR(i,0,n)\\n    {\\n        cout<<v[i]<<\" \";\\n    }\\n\\n    cout<<endl;\\n}\\n\\n\\ngive input according to int main()."
                    },
                    {
                        "username": "PrathameshTheCoder",
                        "content": "I wrote complete code on basis of foundational programming knowledge(if else, for loop), but getting TLE"
                    },
                    {
                        "username": "janis__",
                        "content": "To solve this problem, you need to explore all possible nodes reachable from the starting point while considering the restrictions. Use a breadth-first search (BFS) approach, starting from the start_point, and at each step, calculate the possible nodes you can jump to within the given range. Keep track of visited nodes and their distances from the start to avoid redundant exploration and to determine the minimum number of operations needed to reach each node."
                    }
                ]
            },
            {
                "id": 1850886,
                "content": [
                    {
                        "username": "Bharat_295",
                        "content": "My mind after seeing the acceptance in contest-: don\\'t even read! :)"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "people complaining Q3>>>>>>>>Q4 in previous contest. \\nLe Leetcode in Today\\'s contest: Q4>>>>>>>>>>>>>>>>>All questions on Leetcode"
                    },
                    {
                        "username": "EXBORN",
                        "content": "Tried BFS but TLE, apparently this is the approach most people took. Can\\'t think of an elegant way to improve time complexity."
                    },
                    {
                        "username": "Finesse",
                        "content": "Finally, I've found a way to optimize the BFS. Normally in BFS, when you walk from some node (array index), you check every reachable node, and visit only those that weren't visited. This approach takes `O(n*k)` time. To optimize it, you need to know the unvisited nodes without checking all the reachable somehow.\n\nMy idea is to use a BST (binary search tree) to store nodes that weren't visited, and remove the nodes from the tree as you perform the BFS. In fact, you need 2 trees: for even and odd array indices, otherwise it times-out. Thus, every node is not only visited once, but also checked once, the time complexity becomes `O(n*log(n))`.\n\nI can't call it elegant, because [my Python implementation](https://leetcode.com/problems/minimum-reverse-operations/submissions/926451022/) takes 140 lines, 115 of which are the tree implementation. But it's easy to grok because it's composed of smaller independent problems."
                    },
                    {
                        "username": "Finesse",
                        "content": "Trivial for odd `k`s, but none of my ideas works for even `k`s \\uD83E\\uDD2F"
                    },
                    {
                        "username": "mochy",
                        "content": "same :("
                    },
                    {
                        "username": "oystermajor",
                        "content": "Acceptance rate 1.8% lmao"
                    },
                    {
                        "username": "Finesse",
                        "content": "At least I don\\'t feel like an idiot after seeing the rate"
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Great problem, poorly written statement"
                    },
                    {
                        "username": "brinuke",
                        "content": "Yes, it needs a comma before *'representing a 0-indexed array'* and `arr[banned[i]] = 0` duplicates `banned[i] != p`."
                    },
                    {
                        "username": "prashik712",
                        "content": "I saw this question before the contest on Infosys power programmer OA 2 months back.  :\\'("
                    },
                    {
                        "username": "czjnbb",
                        "content": "1.7% acc rate. Lowest ever?"
                    },
                    {
                        "username": "darshanbhimani999",
                        "content": "This is correct solution. but i don\\'t know leetcode is doing which type of activity. try this in Vscode or else.\\n\\n/*Darshan Bhimani - Svnit*/\\n \\n#include <bits/stdc++.h>\\n#include <iostream>\\n#include <string.h>\\n#include <math.h>\\n#include <bitset>\\n#include <vector>\\nusing namespace std;\\n#define ff first\\n#define ull unsigned long long int \\n#define uld unsigned long double\\n#define ss second\\n#define ll long long \\n#define pb push_back\\n#define mp make_pair\\n#define FOR(i, a, b) for (ll i = a; i < b; i++)\\n#define RFOR(i, a, b) for (int i = a; i >= b; i--)\\n\\nvector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) \\n{\\n    vector<int> ans;\\n\\n    if(k==1)\\n    {\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==p)\\n            {\\n                ans.push_back(0);\\n            }\\n            else\\n            {\\n                ans.push_back(-1);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n    else if(k%2!=0)\\n    {\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(0);\\n            v.push_back(0);\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n        ans[p]=1;\\n        v[p]=1;\\n\\n        if(p%2==0)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(i%2!=0)\\n                {\\n                    ans[i]=-1;\\n                    v[i]=-1;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(i%2==0)\\n                {\\n                    ans[i]=-1;\\n                    v[i]=-1;\\n                }\\n            }\\n        }\\n\\n        int x=log(n);\\n        while(x--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(ans[i]==0)\\n                {\\n                    int a[k];\\n                    int p=0;\\n                    a[0]=i-k+1;\\n                    for(int j=1;j<k;j++)\\n                    {\\n                        a[j]=a[j-1]+2;\\n                    }\\n\\n                    for(int j=0;j<k;j++)\\n                    {\\n                        if((a[j]>=0 && ans[a[j]]==-1) || (a[j]<0) || (i==a[j]))\\n                        {\\n                            p++;\\n                        }\\n                        else if(a[j]>=0 && ans[a[j]]==1)\\n                        {\\n                            ans[i]=1;\\n\\n                            if(v[i]==0)\\n                            {\\n                                v[i]=v[a[j]]+1;\\n                            }\\n                            if(v[i]!=0)\\n                            {\\n                                v[i]=min(v[i],v[a[j]]+1);\\n                            }\\n                        }\\n                    }\\n\\n                    if(p==k)\\n                    {\\n                        v[i]=-1;\\n                        ans[i]=-1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if (v[i]>=0)\\n            {\\n                v[i]--;\\n            }\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n\\n        return v;\\n    }\\n    else\\n    {\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(0);\\n            v.push_back(0);\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n        ans[p]=1;\\n        v[p]=1;\\n\\n        int x=log(n);\\n        while(x--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(ans[i]==0)\\n                {\\n                    int a[k];\\n                    int p=0;\\n                    a[0]=i-k+1;\\n                    for(int j=1;j<k;j++)\\n                    {\\n                        a[j]=a[j-1]+2;\\n                    }\\n\\n                    for(int j=0;j<k;j++)\\n                    {\\n                        if((a[j]>=0 && ans[a[j]]==-1) || (a[j]<0) || (i==a[j]))\\n                        {\\n                            p++;\\n                        }\\n                        else if(a[j]>=0 && ans[a[j]]==1)\\n                        {\\n                            ans[i]=1;\\n\\n                            if(v[i]==0)\\n                            {\\n                                v[i]=v[a[j]]+1;\\n                            }\\n                            if(v[i]!=0)\\n                            {\\n                                v[i]=min(v[i],v[a[j]]+1);\\n                            }\\n                        }\\n                    }\\n\\n                    if(p==k)\\n                    {\\n                        v[i]=-1;\\n                        ans[i]=-1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if (v[i]>=0)\\n            {\\n                v[i]--;\\n            }\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n\\n        return v;\\n    }\\n}\\n\\nint main()\\n{\\n    int n,k,p,bs;\\n    vector<int> banned={1,2};\\n\\n    cin>>n;\\n    cin>>p;\\n    cin>>bs;\\n    FOR(i,0,bs)\\n    {\\n        int x;\\n        cin>>x;\\n        banned.push_back(x);\\n    }\\n    cin>>k;\\n\\n    vector<int> v=minReverseOperations(n,p,banned,k);\\n\\n    FOR(i,0,n)\\n    {\\n        cout<<v[i]<<\" \";\\n    }\\n\\n    cout<<endl;\\n}\\n\\n\\ngive input according to int main()."
                    },
                    {
                        "username": "PrathameshTheCoder",
                        "content": "I wrote complete code on basis of foundational programming knowledge(if else, for loop), but getting TLE"
                    },
                    {
                        "username": "janis__",
                        "content": "To solve this problem, you need to explore all possible nodes reachable from the starting point while considering the restrictions. Use a breadth-first search (BFS) approach, starting from the start_point, and at each step, calculate the possible nodes you can jump to within the given range. Keep track of visited nodes and their distances from the start to avoid redundant exploration and to determine the minimum number of operations needed to reach each node."
                    }
                ]
            },
            {
                "id": 1898053,
                "content": [
                    {
                        "username": "Bharat_295",
                        "content": "My mind after seeing the acceptance in contest-: don\\'t even read! :)"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "people complaining Q3>>>>>>>>Q4 in previous contest. \\nLe Leetcode in Today\\'s contest: Q4>>>>>>>>>>>>>>>>>All questions on Leetcode"
                    },
                    {
                        "username": "EXBORN",
                        "content": "Tried BFS but TLE, apparently this is the approach most people took. Can\\'t think of an elegant way to improve time complexity."
                    },
                    {
                        "username": "Finesse",
                        "content": "Finally, I've found a way to optimize the BFS. Normally in BFS, when you walk from some node (array index), you check every reachable node, and visit only those that weren't visited. This approach takes `O(n*k)` time. To optimize it, you need to know the unvisited nodes without checking all the reachable somehow.\n\nMy idea is to use a BST (binary search tree) to store nodes that weren't visited, and remove the nodes from the tree as you perform the BFS. In fact, you need 2 trees: for even and odd array indices, otherwise it times-out. Thus, every node is not only visited once, but also checked once, the time complexity becomes `O(n*log(n))`.\n\nI can't call it elegant, because [my Python implementation](https://leetcode.com/problems/minimum-reverse-operations/submissions/926451022/) takes 140 lines, 115 of which are the tree implementation. But it's easy to grok because it's composed of smaller independent problems."
                    },
                    {
                        "username": "Finesse",
                        "content": "Trivial for odd `k`s, but none of my ideas works for even `k`s \\uD83E\\uDD2F"
                    },
                    {
                        "username": "mochy",
                        "content": "same :("
                    },
                    {
                        "username": "oystermajor",
                        "content": "Acceptance rate 1.8% lmao"
                    },
                    {
                        "username": "Finesse",
                        "content": "At least I don\\'t feel like an idiot after seeing the rate"
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Great problem, poorly written statement"
                    },
                    {
                        "username": "brinuke",
                        "content": "Yes, it needs a comma before *'representing a 0-indexed array'* and `arr[banned[i]] = 0` duplicates `banned[i] != p`."
                    },
                    {
                        "username": "prashik712",
                        "content": "I saw this question before the contest on Infosys power programmer OA 2 months back.  :\\'("
                    },
                    {
                        "username": "czjnbb",
                        "content": "1.7% acc rate. Lowest ever?"
                    },
                    {
                        "username": "darshanbhimani999",
                        "content": "This is correct solution. but i don\\'t know leetcode is doing which type of activity. try this in Vscode or else.\\n\\n/*Darshan Bhimani - Svnit*/\\n \\n#include <bits/stdc++.h>\\n#include <iostream>\\n#include <string.h>\\n#include <math.h>\\n#include <bitset>\\n#include <vector>\\nusing namespace std;\\n#define ff first\\n#define ull unsigned long long int \\n#define uld unsigned long double\\n#define ss second\\n#define ll long long \\n#define pb push_back\\n#define mp make_pair\\n#define FOR(i, a, b) for (ll i = a; i < b; i++)\\n#define RFOR(i, a, b) for (int i = a; i >= b; i--)\\n\\nvector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) \\n{\\n    vector<int> ans;\\n\\n    if(k==1)\\n    {\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==p)\\n            {\\n                ans.push_back(0);\\n            }\\n            else\\n            {\\n                ans.push_back(-1);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n    else if(k%2!=0)\\n    {\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(0);\\n            v.push_back(0);\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n        ans[p]=1;\\n        v[p]=1;\\n\\n        if(p%2==0)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(i%2!=0)\\n                {\\n                    ans[i]=-1;\\n                    v[i]=-1;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(i%2==0)\\n                {\\n                    ans[i]=-1;\\n                    v[i]=-1;\\n                }\\n            }\\n        }\\n\\n        int x=log(n);\\n        while(x--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(ans[i]==0)\\n                {\\n                    int a[k];\\n                    int p=0;\\n                    a[0]=i-k+1;\\n                    for(int j=1;j<k;j++)\\n                    {\\n                        a[j]=a[j-1]+2;\\n                    }\\n\\n                    for(int j=0;j<k;j++)\\n                    {\\n                        if((a[j]>=0 && ans[a[j]]==-1) || (a[j]<0) || (i==a[j]))\\n                        {\\n                            p++;\\n                        }\\n                        else if(a[j]>=0 && ans[a[j]]==1)\\n                        {\\n                            ans[i]=1;\\n\\n                            if(v[i]==0)\\n                            {\\n                                v[i]=v[a[j]]+1;\\n                            }\\n                            if(v[i]!=0)\\n                            {\\n                                v[i]=min(v[i],v[a[j]]+1);\\n                            }\\n                        }\\n                    }\\n\\n                    if(p==k)\\n                    {\\n                        v[i]=-1;\\n                        ans[i]=-1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if (v[i]>=0)\\n            {\\n                v[i]--;\\n            }\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n\\n        return v;\\n    }\\n    else\\n    {\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(0);\\n            v.push_back(0);\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n        ans[p]=1;\\n        v[p]=1;\\n\\n        int x=log(n);\\n        while(x--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(ans[i]==0)\\n                {\\n                    int a[k];\\n                    int p=0;\\n                    a[0]=i-k+1;\\n                    for(int j=1;j<k;j++)\\n                    {\\n                        a[j]=a[j-1]+2;\\n                    }\\n\\n                    for(int j=0;j<k;j++)\\n                    {\\n                        if((a[j]>=0 && ans[a[j]]==-1) || (a[j]<0) || (i==a[j]))\\n                        {\\n                            p++;\\n                        }\\n                        else if(a[j]>=0 && ans[a[j]]==1)\\n                        {\\n                            ans[i]=1;\\n\\n                            if(v[i]==0)\\n                            {\\n                                v[i]=v[a[j]]+1;\\n                            }\\n                            if(v[i]!=0)\\n                            {\\n                                v[i]=min(v[i],v[a[j]]+1);\\n                            }\\n                        }\\n                    }\\n\\n                    if(p==k)\\n                    {\\n                        v[i]=-1;\\n                        ans[i]=-1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if (v[i]>=0)\\n            {\\n                v[i]--;\\n            }\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n\\n        return v;\\n    }\\n}\\n\\nint main()\\n{\\n    int n,k,p,bs;\\n    vector<int> banned={1,2};\\n\\n    cin>>n;\\n    cin>>p;\\n    cin>>bs;\\n    FOR(i,0,bs)\\n    {\\n        int x;\\n        cin>>x;\\n        banned.push_back(x);\\n    }\\n    cin>>k;\\n\\n    vector<int> v=minReverseOperations(n,p,banned,k);\\n\\n    FOR(i,0,n)\\n    {\\n        cout<<v[i]<<\" \";\\n    }\\n\\n    cout<<endl;\\n}\\n\\n\\ngive input according to int main()."
                    },
                    {
                        "username": "PrathameshTheCoder",
                        "content": "I wrote complete code on basis of foundational programming knowledge(if else, for loop), but getting TLE"
                    },
                    {
                        "username": "janis__",
                        "content": "To solve this problem, you need to explore all possible nodes reachable from the starting point while considering the restrictions. Use a breadth-first search (BFS) approach, starting from the start_point, and at each step, calculate the possible nodes you can jump to within the given range. Keep track of visited nodes and their distances from the start to avoid redundant exploration and to determine the minimum number of operations needed to reach each node."
                    }
                ]
            },
            {
                "id": 2060519,
                "content": [
                    {
                        "username": "Bharat_295",
                        "content": "My mind after seeing the acceptance in contest-: don\\'t even read! :)"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "people complaining Q3>>>>>>>>Q4 in previous contest. \\nLe Leetcode in Today\\'s contest: Q4>>>>>>>>>>>>>>>>>All questions on Leetcode"
                    },
                    {
                        "username": "EXBORN",
                        "content": "Tried BFS but TLE, apparently this is the approach most people took. Can\\'t think of an elegant way to improve time complexity."
                    },
                    {
                        "username": "Finesse",
                        "content": "Finally, I've found a way to optimize the BFS. Normally in BFS, when you walk from some node (array index), you check every reachable node, and visit only those that weren't visited. This approach takes `O(n*k)` time. To optimize it, you need to know the unvisited nodes without checking all the reachable somehow.\n\nMy idea is to use a BST (binary search tree) to store nodes that weren't visited, and remove the nodes from the tree as you perform the BFS. In fact, you need 2 trees: for even and odd array indices, otherwise it times-out. Thus, every node is not only visited once, but also checked once, the time complexity becomes `O(n*log(n))`.\n\nI can't call it elegant, because [my Python implementation](https://leetcode.com/problems/minimum-reverse-operations/submissions/926451022/) takes 140 lines, 115 of which are the tree implementation. But it's easy to grok because it's composed of smaller independent problems."
                    },
                    {
                        "username": "Finesse",
                        "content": "Trivial for odd `k`s, but none of my ideas works for even `k`s \\uD83E\\uDD2F"
                    },
                    {
                        "username": "mochy",
                        "content": "same :("
                    },
                    {
                        "username": "oystermajor",
                        "content": "Acceptance rate 1.8% lmao"
                    },
                    {
                        "username": "Finesse",
                        "content": "At least I don\\'t feel like an idiot after seeing the rate"
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Great problem, poorly written statement"
                    },
                    {
                        "username": "brinuke",
                        "content": "Yes, it needs a comma before *'representing a 0-indexed array'* and `arr[banned[i]] = 0` duplicates `banned[i] != p`."
                    },
                    {
                        "username": "prashik712",
                        "content": "I saw this question before the contest on Infosys power programmer OA 2 months back.  :\\'("
                    },
                    {
                        "username": "czjnbb",
                        "content": "1.7% acc rate. Lowest ever?"
                    },
                    {
                        "username": "darshanbhimani999",
                        "content": "This is correct solution. but i don\\'t know leetcode is doing which type of activity. try this in Vscode or else.\\n\\n/*Darshan Bhimani - Svnit*/\\n \\n#include <bits/stdc++.h>\\n#include <iostream>\\n#include <string.h>\\n#include <math.h>\\n#include <bitset>\\n#include <vector>\\nusing namespace std;\\n#define ff first\\n#define ull unsigned long long int \\n#define uld unsigned long double\\n#define ss second\\n#define ll long long \\n#define pb push_back\\n#define mp make_pair\\n#define FOR(i, a, b) for (ll i = a; i < b; i++)\\n#define RFOR(i, a, b) for (int i = a; i >= b; i--)\\n\\nvector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) \\n{\\n    vector<int> ans;\\n\\n    if(k==1)\\n    {\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==p)\\n            {\\n                ans.push_back(0);\\n            }\\n            else\\n            {\\n                ans.push_back(-1);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n    else if(k%2!=0)\\n    {\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(0);\\n            v.push_back(0);\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n        ans[p]=1;\\n        v[p]=1;\\n\\n        if(p%2==0)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(i%2!=0)\\n                {\\n                    ans[i]=-1;\\n                    v[i]=-1;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(i%2==0)\\n                {\\n                    ans[i]=-1;\\n                    v[i]=-1;\\n                }\\n            }\\n        }\\n\\n        int x=log(n);\\n        while(x--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(ans[i]==0)\\n                {\\n                    int a[k];\\n                    int p=0;\\n                    a[0]=i-k+1;\\n                    for(int j=1;j<k;j++)\\n                    {\\n                        a[j]=a[j-1]+2;\\n                    }\\n\\n                    for(int j=0;j<k;j++)\\n                    {\\n                        if((a[j]>=0 && ans[a[j]]==-1) || (a[j]<0) || (i==a[j]))\\n                        {\\n                            p++;\\n                        }\\n                        else if(a[j]>=0 && ans[a[j]]==1)\\n                        {\\n                            ans[i]=1;\\n\\n                            if(v[i]==0)\\n                            {\\n                                v[i]=v[a[j]]+1;\\n                            }\\n                            if(v[i]!=0)\\n                            {\\n                                v[i]=min(v[i],v[a[j]]+1);\\n                            }\\n                        }\\n                    }\\n\\n                    if(p==k)\\n                    {\\n                        v[i]=-1;\\n                        ans[i]=-1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if (v[i]>=0)\\n            {\\n                v[i]--;\\n            }\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n\\n        return v;\\n    }\\n    else\\n    {\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(0);\\n            v.push_back(0);\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n        ans[p]=1;\\n        v[p]=1;\\n\\n        int x=log(n);\\n        while(x--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(ans[i]==0)\\n                {\\n                    int a[k];\\n                    int p=0;\\n                    a[0]=i-k+1;\\n                    for(int j=1;j<k;j++)\\n                    {\\n                        a[j]=a[j-1]+2;\\n                    }\\n\\n                    for(int j=0;j<k;j++)\\n                    {\\n                        if((a[j]>=0 && ans[a[j]]==-1) || (a[j]<0) || (i==a[j]))\\n                        {\\n                            p++;\\n                        }\\n                        else if(a[j]>=0 && ans[a[j]]==1)\\n                        {\\n                            ans[i]=1;\\n\\n                            if(v[i]==0)\\n                            {\\n                                v[i]=v[a[j]]+1;\\n                            }\\n                            if(v[i]!=0)\\n                            {\\n                                v[i]=min(v[i],v[a[j]]+1);\\n                            }\\n                        }\\n                    }\\n\\n                    if(p==k)\\n                    {\\n                        v[i]=-1;\\n                        ans[i]=-1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if (v[i]>=0)\\n            {\\n                v[i]--;\\n            }\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n\\n        return v;\\n    }\\n}\\n\\nint main()\\n{\\n    int n,k,p,bs;\\n    vector<int> banned={1,2};\\n\\n    cin>>n;\\n    cin>>p;\\n    cin>>bs;\\n    FOR(i,0,bs)\\n    {\\n        int x;\\n        cin>>x;\\n        banned.push_back(x);\\n    }\\n    cin>>k;\\n\\n    vector<int> v=minReverseOperations(n,p,banned,k);\\n\\n    FOR(i,0,n)\\n    {\\n        cout<<v[i]<<\" \";\\n    }\\n\\n    cout<<endl;\\n}\\n\\n\\ngive input according to int main()."
                    },
                    {
                        "username": "PrathameshTheCoder",
                        "content": "I wrote complete code on basis of foundational programming knowledge(if else, for loop), but getting TLE"
                    },
                    {
                        "username": "janis__",
                        "content": "To solve this problem, you need to explore all possible nodes reachable from the starting point while considering the restrictions. Use a breadth-first search (BFS) approach, starting from the start_point, and at each step, calculate the possible nodes you can jump to within the given range. Keep track of visited nodes and their distances from the start to avoid redundant exploration and to determine the minimum number of operations needed to reach each node."
                    }
                ]
            },
            {
                "id": 2042926,
                "content": [
                    {
                        "username": "Bharat_295",
                        "content": "My mind after seeing the acceptance in contest-: don\\'t even read! :)"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "people complaining Q3>>>>>>>>Q4 in previous contest. \\nLe Leetcode in Today\\'s contest: Q4>>>>>>>>>>>>>>>>>All questions on Leetcode"
                    },
                    {
                        "username": "EXBORN",
                        "content": "Tried BFS but TLE, apparently this is the approach most people took. Can\\'t think of an elegant way to improve time complexity."
                    },
                    {
                        "username": "Finesse",
                        "content": "Finally, I've found a way to optimize the BFS. Normally in BFS, when you walk from some node (array index), you check every reachable node, and visit only those that weren't visited. This approach takes `O(n*k)` time. To optimize it, you need to know the unvisited nodes without checking all the reachable somehow.\n\nMy idea is to use a BST (binary search tree) to store nodes that weren't visited, and remove the nodes from the tree as you perform the BFS. In fact, you need 2 trees: for even and odd array indices, otherwise it times-out. Thus, every node is not only visited once, but also checked once, the time complexity becomes `O(n*log(n))`.\n\nI can't call it elegant, because [my Python implementation](https://leetcode.com/problems/minimum-reverse-operations/submissions/926451022/) takes 140 lines, 115 of which are the tree implementation. But it's easy to grok because it's composed of smaller independent problems."
                    },
                    {
                        "username": "Finesse",
                        "content": "Trivial for odd `k`s, but none of my ideas works for even `k`s \\uD83E\\uDD2F"
                    },
                    {
                        "username": "mochy",
                        "content": "same :("
                    },
                    {
                        "username": "oystermajor",
                        "content": "Acceptance rate 1.8% lmao"
                    },
                    {
                        "username": "Finesse",
                        "content": "At least I don\\'t feel like an idiot after seeing the rate"
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Great problem, poorly written statement"
                    },
                    {
                        "username": "brinuke",
                        "content": "Yes, it needs a comma before *'representing a 0-indexed array'* and `arr[banned[i]] = 0` duplicates `banned[i] != p`."
                    },
                    {
                        "username": "prashik712",
                        "content": "I saw this question before the contest on Infosys power programmer OA 2 months back.  :\\'("
                    },
                    {
                        "username": "czjnbb",
                        "content": "1.7% acc rate. Lowest ever?"
                    },
                    {
                        "username": "darshanbhimani999",
                        "content": "This is correct solution. but i don\\'t know leetcode is doing which type of activity. try this in Vscode or else.\\n\\n/*Darshan Bhimani - Svnit*/\\n \\n#include <bits/stdc++.h>\\n#include <iostream>\\n#include <string.h>\\n#include <math.h>\\n#include <bitset>\\n#include <vector>\\nusing namespace std;\\n#define ff first\\n#define ull unsigned long long int \\n#define uld unsigned long double\\n#define ss second\\n#define ll long long \\n#define pb push_back\\n#define mp make_pair\\n#define FOR(i, a, b) for (ll i = a; i < b; i++)\\n#define RFOR(i, a, b) for (int i = a; i >= b; i--)\\n\\nvector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) \\n{\\n    vector<int> ans;\\n\\n    if(k==1)\\n    {\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==p)\\n            {\\n                ans.push_back(0);\\n            }\\n            else\\n            {\\n                ans.push_back(-1);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n    else if(k%2!=0)\\n    {\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(0);\\n            v.push_back(0);\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n        ans[p]=1;\\n        v[p]=1;\\n\\n        if(p%2==0)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(i%2!=0)\\n                {\\n                    ans[i]=-1;\\n                    v[i]=-1;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(i%2==0)\\n                {\\n                    ans[i]=-1;\\n                    v[i]=-1;\\n                }\\n            }\\n        }\\n\\n        int x=log(n);\\n        while(x--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(ans[i]==0)\\n                {\\n                    int a[k];\\n                    int p=0;\\n                    a[0]=i-k+1;\\n                    for(int j=1;j<k;j++)\\n                    {\\n                        a[j]=a[j-1]+2;\\n                    }\\n\\n                    for(int j=0;j<k;j++)\\n                    {\\n                        if((a[j]>=0 && ans[a[j]]==-1) || (a[j]<0) || (i==a[j]))\\n                        {\\n                            p++;\\n                        }\\n                        else if(a[j]>=0 && ans[a[j]]==1)\\n                        {\\n                            ans[i]=1;\\n\\n                            if(v[i]==0)\\n                            {\\n                                v[i]=v[a[j]]+1;\\n                            }\\n                            if(v[i]!=0)\\n                            {\\n                                v[i]=min(v[i],v[a[j]]+1);\\n                            }\\n                        }\\n                    }\\n\\n                    if(p==k)\\n                    {\\n                        v[i]=-1;\\n                        ans[i]=-1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if (v[i]>=0)\\n            {\\n                v[i]--;\\n            }\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n\\n        return v;\\n    }\\n    else\\n    {\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(0);\\n            v.push_back(0);\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n        ans[p]=1;\\n        v[p]=1;\\n\\n        int x=log(n);\\n        while(x--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(ans[i]==0)\\n                {\\n                    int a[k];\\n                    int p=0;\\n                    a[0]=i-k+1;\\n                    for(int j=1;j<k;j++)\\n                    {\\n                        a[j]=a[j-1]+2;\\n                    }\\n\\n                    for(int j=0;j<k;j++)\\n                    {\\n                        if((a[j]>=0 && ans[a[j]]==-1) || (a[j]<0) || (i==a[j]))\\n                        {\\n                            p++;\\n                        }\\n                        else if(a[j]>=0 && ans[a[j]]==1)\\n                        {\\n                            ans[i]=1;\\n\\n                            if(v[i]==0)\\n                            {\\n                                v[i]=v[a[j]]+1;\\n                            }\\n                            if(v[i]!=0)\\n                            {\\n                                v[i]=min(v[i],v[a[j]]+1);\\n                            }\\n                        }\\n                    }\\n\\n                    if(p==k)\\n                    {\\n                        v[i]=-1;\\n                        ans[i]=-1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if (v[i]>=0)\\n            {\\n                v[i]--;\\n            }\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n\\n        return v;\\n    }\\n}\\n\\nint main()\\n{\\n    int n,k,p,bs;\\n    vector<int> banned={1,2};\\n\\n    cin>>n;\\n    cin>>p;\\n    cin>>bs;\\n    FOR(i,0,bs)\\n    {\\n        int x;\\n        cin>>x;\\n        banned.push_back(x);\\n    }\\n    cin>>k;\\n\\n    vector<int> v=minReverseOperations(n,p,banned,k);\\n\\n    FOR(i,0,n)\\n    {\\n        cout<<v[i]<<\" \";\\n    }\\n\\n    cout<<endl;\\n}\\n\\n\\ngive input according to int main()."
                    },
                    {
                        "username": "PrathameshTheCoder",
                        "content": "I wrote complete code on basis of foundational programming knowledge(if else, for loop), but getting TLE"
                    },
                    {
                        "username": "janis__",
                        "content": "To solve this problem, you need to explore all possible nodes reachable from the starting point while considering the restrictions. Use a breadth-first search (BFS) approach, starting from the start_point, and at each step, calculate the possible nodes you can jump to within the given range. Keep track of visited nodes and their distances from the start to avoid redundant exploration and to determine the minimum number of operations needed to reach each node."
                    }
                ]
            },
            {
                "id": 1851002,
                "content": [
                    {
                        "username": "Bharat_295",
                        "content": "My mind after seeing the acceptance in contest-: don\\'t even read! :)"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "people complaining Q3>>>>>>>>Q4 in previous contest. \\nLe Leetcode in Today\\'s contest: Q4>>>>>>>>>>>>>>>>>All questions on Leetcode"
                    },
                    {
                        "username": "EXBORN",
                        "content": "Tried BFS but TLE, apparently this is the approach most people took. Can\\'t think of an elegant way to improve time complexity."
                    },
                    {
                        "username": "Finesse",
                        "content": "Finally, I've found a way to optimize the BFS. Normally in BFS, when you walk from some node (array index), you check every reachable node, and visit only those that weren't visited. This approach takes `O(n*k)` time. To optimize it, you need to know the unvisited nodes without checking all the reachable somehow.\n\nMy idea is to use a BST (binary search tree) to store nodes that weren't visited, and remove the nodes from the tree as you perform the BFS. In fact, you need 2 trees: for even and odd array indices, otherwise it times-out. Thus, every node is not only visited once, but also checked once, the time complexity becomes `O(n*log(n))`.\n\nI can't call it elegant, because [my Python implementation](https://leetcode.com/problems/minimum-reverse-operations/submissions/926451022/) takes 140 lines, 115 of which are the tree implementation. But it's easy to grok because it's composed of smaller independent problems."
                    },
                    {
                        "username": "Finesse",
                        "content": "Trivial for odd `k`s, but none of my ideas works for even `k`s \\uD83E\\uDD2F"
                    },
                    {
                        "username": "mochy",
                        "content": "same :("
                    },
                    {
                        "username": "oystermajor",
                        "content": "Acceptance rate 1.8% lmao"
                    },
                    {
                        "username": "Finesse",
                        "content": "At least I don\\'t feel like an idiot after seeing the rate"
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Great problem, poorly written statement"
                    },
                    {
                        "username": "brinuke",
                        "content": "Yes, it needs a comma before *'representing a 0-indexed array'* and `arr[banned[i]] = 0` duplicates `banned[i] != p`."
                    },
                    {
                        "username": "prashik712",
                        "content": "I saw this question before the contest on Infosys power programmer OA 2 months back.  :\\'("
                    },
                    {
                        "username": "czjnbb",
                        "content": "1.7% acc rate. Lowest ever?"
                    },
                    {
                        "username": "darshanbhimani999",
                        "content": "This is correct solution. but i don\\'t know leetcode is doing which type of activity. try this in Vscode or else.\\n\\n/*Darshan Bhimani - Svnit*/\\n \\n#include <bits/stdc++.h>\\n#include <iostream>\\n#include <string.h>\\n#include <math.h>\\n#include <bitset>\\n#include <vector>\\nusing namespace std;\\n#define ff first\\n#define ull unsigned long long int \\n#define uld unsigned long double\\n#define ss second\\n#define ll long long \\n#define pb push_back\\n#define mp make_pair\\n#define FOR(i, a, b) for (ll i = a; i < b; i++)\\n#define RFOR(i, a, b) for (int i = a; i >= b; i--)\\n\\nvector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) \\n{\\n    vector<int> ans;\\n\\n    if(k==1)\\n    {\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==p)\\n            {\\n                ans.push_back(0);\\n            }\\n            else\\n            {\\n                ans.push_back(-1);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n    else if(k%2!=0)\\n    {\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(0);\\n            v.push_back(0);\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n        ans[p]=1;\\n        v[p]=1;\\n\\n        if(p%2==0)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(i%2!=0)\\n                {\\n                    ans[i]=-1;\\n                    v[i]=-1;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(i%2==0)\\n                {\\n                    ans[i]=-1;\\n                    v[i]=-1;\\n                }\\n            }\\n        }\\n\\n        int x=log(n);\\n        while(x--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(ans[i]==0)\\n                {\\n                    int a[k];\\n                    int p=0;\\n                    a[0]=i-k+1;\\n                    for(int j=1;j<k;j++)\\n                    {\\n                        a[j]=a[j-1]+2;\\n                    }\\n\\n                    for(int j=0;j<k;j++)\\n                    {\\n                        if((a[j]>=0 && ans[a[j]]==-1) || (a[j]<0) || (i==a[j]))\\n                        {\\n                            p++;\\n                        }\\n                        else if(a[j]>=0 && ans[a[j]]==1)\\n                        {\\n                            ans[i]=1;\\n\\n                            if(v[i]==0)\\n                            {\\n                                v[i]=v[a[j]]+1;\\n                            }\\n                            if(v[i]!=0)\\n                            {\\n                                v[i]=min(v[i],v[a[j]]+1);\\n                            }\\n                        }\\n                    }\\n\\n                    if(p==k)\\n                    {\\n                        v[i]=-1;\\n                        ans[i]=-1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if (v[i]>=0)\\n            {\\n                v[i]--;\\n            }\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n\\n        return v;\\n    }\\n    else\\n    {\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(0);\\n            v.push_back(0);\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n        ans[p]=1;\\n        v[p]=1;\\n\\n        int x=log(n);\\n        while(x--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(ans[i]==0)\\n                {\\n                    int a[k];\\n                    int p=0;\\n                    a[0]=i-k+1;\\n                    for(int j=1;j<k;j++)\\n                    {\\n                        a[j]=a[j-1]+2;\\n                    }\\n\\n                    for(int j=0;j<k;j++)\\n                    {\\n                        if((a[j]>=0 && ans[a[j]]==-1) || (a[j]<0) || (i==a[j]))\\n                        {\\n                            p++;\\n                        }\\n                        else if(a[j]>=0 && ans[a[j]]==1)\\n                        {\\n                            ans[i]=1;\\n\\n                            if(v[i]==0)\\n                            {\\n                                v[i]=v[a[j]]+1;\\n                            }\\n                            if(v[i]!=0)\\n                            {\\n                                v[i]=min(v[i],v[a[j]]+1);\\n                            }\\n                        }\\n                    }\\n\\n                    if(p==k)\\n                    {\\n                        v[i]=-1;\\n                        ans[i]=-1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if (v[i]>=0)\\n            {\\n                v[i]--;\\n            }\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n\\n        return v;\\n    }\\n}\\n\\nint main()\\n{\\n    int n,k,p,bs;\\n    vector<int> banned={1,2};\\n\\n    cin>>n;\\n    cin>>p;\\n    cin>>bs;\\n    FOR(i,0,bs)\\n    {\\n        int x;\\n        cin>>x;\\n        banned.push_back(x);\\n    }\\n    cin>>k;\\n\\n    vector<int> v=minReverseOperations(n,p,banned,k);\\n\\n    FOR(i,0,n)\\n    {\\n        cout<<v[i]<<\" \";\\n    }\\n\\n    cout<<endl;\\n}\\n\\n\\ngive input according to int main()."
                    },
                    {
                        "username": "PrathameshTheCoder",
                        "content": "I wrote complete code on basis of foundational programming knowledge(if else, for loop), but getting TLE"
                    },
                    {
                        "username": "janis__",
                        "content": "To solve this problem, you need to explore all possible nodes reachable from the starting point while considering the restrictions. Use a breadth-first search (BFS) approach, starting from the start_point, and at each step, calculate the possible nodes you can jump to within the given range. Keep track of visited nodes and their distances from the start to avoid redundant exploration and to determine the minimum number of operations needed to reach each node."
                    }
                ]
            },
            {
                "id": 1850958,
                "content": [
                    {
                        "username": "Bharat_295",
                        "content": "My mind after seeing the acceptance in contest-: don\\'t even read! :)"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "people complaining Q3>>>>>>>>Q4 in previous contest. \\nLe Leetcode in Today\\'s contest: Q4>>>>>>>>>>>>>>>>>All questions on Leetcode"
                    },
                    {
                        "username": "EXBORN",
                        "content": "Tried BFS but TLE, apparently this is the approach most people took. Can\\'t think of an elegant way to improve time complexity."
                    },
                    {
                        "username": "Finesse",
                        "content": "Finally, I've found a way to optimize the BFS. Normally in BFS, when you walk from some node (array index), you check every reachable node, and visit only those that weren't visited. This approach takes `O(n*k)` time. To optimize it, you need to know the unvisited nodes without checking all the reachable somehow.\n\nMy idea is to use a BST (binary search tree) to store nodes that weren't visited, and remove the nodes from the tree as you perform the BFS. In fact, you need 2 trees: for even and odd array indices, otherwise it times-out. Thus, every node is not only visited once, but also checked once, the time complexity becomes `O(n*log(n))`.\n\nI can't call it elegant, because [my Python implementation](https://leetcode.com/problems/minimum-reverse-operations/submissions/926451022/) takes 140 lines, 115 of which are the tree implementation. But it's easy to grok because it's composed of smaller independent problems."
                    },
                    {
                        "username": "Finesse",
                        "content": "Trivial for odd `k`s, but none of my ideas works for even `k`s \\uD83E\\uDD2F"
                    },
                    {
                        "username": "mochy",
                        "content": "same :("
                    },
                    {
                        "username": "oystermajor",
                        "content": "Acceptance rate 1.8% lmao"
                    },
                    {
                        "username": "Finesse",
                        "content": "At least I don\\'t feel like an idiot after seeing the rate"
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Great problem, poorly written statement"
                    },
                    {
                        "username": "brinuke",
                        "content": "Yes, it needs a comma before *'representing a 0-indexed array'* and `arr[banned[i]] = 0` duplicates `banned[i] != p`."
                    },
                    {
                        "username": "prashik712",
                        "content": "I saw this question before the contest on Infosys power programmer OA 2 months back.  :\\'("
                    },
                    {
                        "username": "czjnbb",
                        "content": "1.7% acc rate. Lowest ever?"
                    },
                    {
                        "username": "darshanbhimani999",
                        "content": "This is correct solution. but i don\\'t know leetcode is doing which type of activity. try this in Vscode or else.\\n\\n/*Darshan Bhimani - Svnit*/\\n \\n#include <bits/stdc++.h>\\n#include <iostream>\\n#include <string.h>\\n#include <math.h>\\n#include <bitset>\\n#include <vector>\\nusing namespace std;\\n#define ff first\\n#define ull unsigned long long int \\n#define uld unsigned long double\\n#define ss second\\n#define ll long long \\n#define pb push_back\\n#define mp make_pair\\n#define FOR(i, a, b) for (ll i = a; i < b; i++)\\n#define RFOR(i, a, b) for (int i = a; i >= b; i--)\\n\\nvector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) \\n{\\n    vector<int> ans;\\n\\n    if(k==1)\\n    {\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==p)\\n            {\\n                ans.push_back(0);\\n            }\\n            else\\n            {\\n                ans.push_back(-1);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n    else if(k%2!=0)\\n    {\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(0);\\n            v.push_back(0);\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n        ans[p]=1;\\n        v[p]=1;\\n\\n        if(p%2==0)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(i%2!=0)\\n                {\\n                    ans[i]=-1;\\n                    v[i]=-1;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(i%2==0)\\n                {\\n                    ans[i]=-1;\\n                    v[i]=-1;\\n                }\\n            }\\n        }\\n\\n        int x=log(n);\\n        while(x--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(ans[i]==0)\\n                {\\n                    int a[k];\\n                    int p=0;\\n                    a[0]=i-k+1;\\n                    for(int j=1;j<k;j++)\\n                    {\\n                        a[j]=a[j-1]+2;\\n                    }\\n\\n                    for(int j=0;j<k;j++)\\n                    {\\n                        if((a[j]>=0 && ans[a[j]]==-1) || (a[j]<0) || (i==a[j]))\\n                        {\\n                            p++;\\n                        }\\n                        else if(a[j]>=0 && ans[a[j]]==1)\\n                        {\\n                            ans[i]=1;\\n\\n                            if(v[i]==0)\\n                            {\\n                                v[i]=v[a[j]]+1;\\n                            }\\n                            if(v[i]!=0)\\n                            {\\n                                v[i]=min(v[i],v[a[j]]+1);\\n                            }\\n                        }\\n                    }\\n\\n                    if(p==k)\\n                    {\\n                        v[i]=-1;\\n                        ans[i]=-1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if (v[i]>=0)\\n            {\\n                v[i]--;\\n            }\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n\\n        return v;\\n    }\\n    else\\n    {\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(0);\\n            v.push_back(0);\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n        ans[p]=1;\\n        v[p]=1;\\n\\n        int x=log(n);\\n        while(x--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(ans[i]==0)\\n                {\\n                    int a[k];\\n                    int p=0;\\n                    a[0]=i-k+1;\\n                    for(int j=1;j<k;j++)\\n                    {\\n                        a[j]=a[j-1]+2;\\n                    }\\n\\n                    for(int j=0;j<k;j++)\\n                    {\\n                        if((a[j]>=0 && ans[a[j]]==-1) || (a[j]<0) || (i==a[j]))\\n                        {\\n                            p++;\\n                        }\\n                        else if(a[j]>=0 && ans[a[j]]==1)\\n                        {\\n                            ans[i]=1;\\n\\n                            if(v[i]==0)\\n                            {\\n                                v[i]=v[a[j]]+1;\\n                            }\\n                            if(v[i]!=0)\\n                            {\\n                                v[i]=min(v[i],v[a[j]]+1);\\n                            }\\n                        }\\n                    }\\n\\n                    if(p==k)\\n                    {\\n                        v[i]=-1;\\n                        ans[i]=-1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if (v[i]>=0)\\n            {\\n                v[i]--;\\n            }\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n\\n        return v;\\n    }\\n}\\n\\nint main()\\n{\\n    int n,k,p,bs;\\n    vector<int> banned={1,2};\\n\\n    cin>>n;\\n    cin>>p;\\n    cin>>bs;\\n    FOR(i,0,bs)\\n    {\\n        int x;\\n        cin>>x;\\n        banned.push_back(x);\\n    }\\n    cin>>k;\\n\\n    vector<int> v=minReverseOperations(n,p,banned,k);\\n\\n    FOR(i,0,n)\\n    {\\n        cout<<v[i]<<\" \";\\n    }\\n\\n    cout<<endl;\\n}\\n\\n\\ngive input according to int main()."
                    },
                    {
                        "username": "PrathameshTheCoder",
                        "content": "I wrote complete code on basis of foundational programming knowledge(if else, for loop), but getting TLE"
                    },
                    {
                        "username": "janis__",
                        "content": "To solve this problem, you need to explore all possible nodes reachable from the starting point while considering the restrictions. Use a breadth-first search (BFS) approach, starting from the start_point, and at each step, calculate the possible nodes you can jump to within the given range. Keep track of visited nodes and their distances from the start to avoid redundant exploration and to determine the minimum number of operations needed to reach each node."
                    }
                ]
            },
            {
                "id": 1850931,
                "content": [
                    {
                        "username": "Bharat_295",
                        "content": "My mind after seeing the acceptance in contest-: don\\'t even read! :)"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "people complaining Q3>>>>>>>>Q4 in previous contest. \\nLe Leetcode in Today\\'s contest: Q4>>>>>>>>>>>>>>>>>All questions on Leetcode"
                    },
                    {
                        "username": "EXBORN",
                        "content": "Tried BFS but TLE, apparently this is the approach most people took. Can\\'t think of an elegant way to improve time complexity."
                    },
                    {
                        "username": "Finesse",
                        "content": "Finally, I've found a way to optimize the BFS. Normally in BFS, when you walk from some node (array index), you check every reachable node, and visit only those that weren't visited. This approach takes `O(n*k)` time. To optimize it, you need to know the unvisited nodes without checking all the reachable somehow.\n\nMy idea is to use a BST (binary search tree) to store nodes that weren't visited, and remove the nodes from the tree as you perform the BFS. In fact, you need 2 trees: for even and odd array indices, otherwise it times-out. Thus, every node is not only visited once, but also checked once, the time complexity becomes `O(n*log(n))`.\n\nI can't call it elegant, because [my Python implementation](https://leetcode.com/problems/minimum-reverse-operations/submissions/926451022/) takes 140 lines, 115 of which are the tree implementation. But it's easy to grok because it's composed of smaller independent problems."
                    },
                    {
                        "username": "Finesse",
                        "content": "Trivial for odd `k`s, but none of my ideas works for even `k`s \\uD83E\\uDD2F"
                    },
                    {
                        "username": "mochy",
                        "content": "same :("
                    },
                    {
                        "username": "oystermajor",
                        "content": "Acceptance rate 1.8% lmao"
                    },
                    {
                        "username": "Finesse",
                        "content": "At least I don\\'t feel like an idiot after seeing the rate"
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Great problem, poorly written statement"
                    },
                    {
                        "username": "brinuke",
                        "content": "Yes, it needs a comma before *'representing a 0-indexed array'* and `arr[banned[i]] = 0` duplicates `banned[i] != p`."
                    },
                    {
                        "username": "prashik712",
                        "content": "I saw this question before the contest on Infosys power programmer OA 2 months back.  :\\'("
                    },
                    {
                        "username": "czjnbb",
                        "content": "1.7% acc rate. Lowest ever?"
                    },
                    {
                        "username": "darshanbhimani999",
                        "content": "This is correct solution. but i don\\'t know leetcode is doing which type of activity. try this in Vscode or else.\\n\\n/*Darshan Bhimani - Svnit*/\\n \\n#include <bits/stdc++.h>\\n#include <iostream>\\n#include <string.h>\\n#include <math.h>\\n#include <bitset>\\n#include <vector>\\nusing namespace std;\\n#define ff first\\n#define ull unsigned long long int \\n#define uld unsigned long double\\n#define ss second\\n#define ll long long \\n#define pb push_back\\n#define mp make_pair\\n#define FOR(i, a, b) for (ll i = a; i < b; i++)\\n#define RFOR(i, a, b) for (int i = a; i >= b; i--)\\n\\nvector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) \\n{\\n    vector<int> ans;\\n\\n    if(k==1)\\n    {\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==p)\\n            {\\n                ans.push_back(0);\\n            }\\n            else\\n            {\\n                ans.push_back(-1);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n    else if(k%2!=0)\\n    {\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(0);\\n            v.push_back(0);\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n        ans[p]=1;\\n        v[p]=1;\\n\\n        if(p%2==0)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(i%2!=0)\\n                {\\n                    ans[i]=-1;\\n                    v[i]=-1;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(i%2==0)\\n                {\\n                    ans[i]=-1;\\n                    v[i]=-1;\\n                }\\n            }\\n        }\\n\\n        int x=log(n);\\n        while(x--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(ans[i]==0)\\n                {\\n                    int a[k];\\n                    int p=0;\\n                    a[0]=i-k+1;\\n                    for(int j=1;j<k;j++)\\n                    {\\n                        a[j]=a[j-1]+2;\\n                    }\\n\\n                    for(int j=0;j<k;j++)\\n                    {\\n                        if((a[j]>=0 && ans[a[j]]==-1) || (a[j]<0) || (i==a[j]))\\n                        {\\n                            p++;\\n                        }\\n                        else if(a[j]>=0 && ans[a[j]]==1)\\n                        {\\n                            ans[i]=1;\\n\\n                            if(v[i]==0)\\n                            {\\n                                v[i]=v[a[j]]+1;\\n                            }\\n                            if(v[i]!=0)\\n                            {\\n                                v[i]=min(v[i],v[a[j]]+1);\\n                            }\\n                        }\\n                    }\\n\\n                    if(p==k)\\n                    {\\n                        v[i]=-1;\\n                        ans[i]=-1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if (v[i]>=0)\\n            {\\n                v[i]--;\\n            }\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n\\n        return v;\\n    }\\n    else\\n    {\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(0);\\n            v.push_back(0);\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n        ans[p]=1;\\n        v[p]=1;\\n\\n        int x=log(n);\\n        while(x--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(ans[i]==0)\\n                {\\n                    int a[k];\\n                    int p=0;\\n                    a[0]=i-k+1;\\n                    for(int j=1;j<k;j++)\\n                    {\\n                        a[j]=a[j-1]+2;\\n                    }\\n\\n                    for(int j=0;j<k;j++)\\n                    {\\n                        if((a[j]>=0 && ans[a[j]]==-1) || (a[j]<0) || (i==a[j]))\\n                        {\\n                            p++;\\n                        }\\n                        else if(a[j]>=0 && ans[a[j]]==1)\\n                        {\\n                            ans[i]=1;\\n\\n                            if(v[i]==0)\\n                            {\\n                                v[i]=v[a[j]]+1;\\n                            }\\n                            if(v[i]!=0)\\n                            {\\n                                v[i]=min(v[i],v[a[j]]+1);\\n                            }\\n                        }\\n                    }\\n\\n                    if(p==k)\\n                    {\\n                        v[i]=-1;\\n                        ans[i]=-1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if (v[i]>=0)\\n            {\\n                v[i]--;\\n            }\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n\\n        return v;\\n    }\\n}\\n\\nint main()\\n{\\n    int n,k,p,bs;\\n    vector<int> banned={1,2};\\n\\n    cin>>n;\\n    cin>>p;\\n    cin>>bs;\\n    FOR(i,0,bs)\\n    {\\n        int x;\\n        cin>>x;\\n        banned.push_back(x);\\n    }\\n    cin>>k;\\n\\n    vector<int> v=minReverseOperations(n,p,banned,k);\\n\\n    FOR(i,0,n)\\n    {\\n        cout<<v[i]<<\" \";\\n    }\\n\\n    cout<<endl;\\n}\\n\\n\\ngive input according to int main()."
                    },
                    {
                        "username": "PrathameshTheCoder",
                        "content": "I wrote complete code on basis of foundational programming knowledge(if else, for loop), but getting TLE"
                    },
                    {
                        "username": "janis__",
                        "content": "To solve this problem, you need to explore all possible nodes reachable from the starting point while considering the restrictions. Use a breadth-first search (BFS) approach, starting from the start_point, and at each step, calculate the possible nodes you can jump to within the given range. Keep track of visited nodes and their distances from the start to avoid redundant exploration and to determine the minimum number of operations needed to reach each node."
                    }
                ]
            },
            {
                "id": 1850877,
                "content": [
                    {
                        "username": "Bharat_295",
                        "content": "My mind after seeing the acceptance in contest-: don\\'t even read! :)"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "people complaining Q3>>>>>>>>Q4 in previous contest. \\nLe Leetcode in Today\\'s contest: Q4>>>>>>>>>>>>>>>>>All questions on Leetcode"
                    },
                    {
                        "username": "EXBORN",
                        "content": "Tried BFS but TLE, apparently this is the approach most people took. Can\\'t think of an elegant way to improve time complexity."
                    },
                    {
                        "username": "Finesse",
                        "content": "Finally, I've found a way to optimize the BFS. Normally in BFS, when you walk from some node (array index), you check every reachable node, and visit only those that weren't visited. This approach takes `O(n*k)` time. To optimize it, you need to know the unvisited nodes without checking all the reachable somehow.\n\nMy idea is to use a BST (binary search tree) to store nodes that weren't visited, and remove the nodes from the tree as you perform the BFS. In fact, you need 2 trees: for even and odd array indices, otherwise it times-out. Thus, every node is not only visited once, but also checked once, the time complexity becomes `O(n*log(n))`.\n\nI can't call it elegant, because [my Python implementation](https://leetcode.com/problems/minimum-reverse-operations/submissions/926451022/) takes 140 lines, 115 of which are the tree implementation. But it's easy to grok because it's composed of smaller independent problems."
                    },
                    {
                        "username": "Finesse",
                        "content": "Trivial for odd `k`s, but none of my ideas works for even `k`s \\uD83E\\uDD2F"
                    },
                    {
                        "username": "mochy",
                        "content": "same :("
                    },
                    {
                        "username": "oystermajor",
                        "content": "Acceptance rate 1.8% lmao"
                    },
                    {
                        "username": "Finesse",
                        "content": "At least I don\\'t feel like an idiot after seeing the rate"
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Great problem, poorly written statement"
                    },
                    {
                        "username": "brinuke",
                        "content": "Yes, it needs a comma before *'representing a 0-indexed array'* and `arr[banned[i]] = 0` duplicates `banned[i] != p`."
                    },
                    {
                        "username": "prashik712",
                        "content": "I saw this question before the contest on Infosys power programmer OA 2 months back.  :\\'("
                    },
                    {
                        "username": "czjnbb",
                        "content": "1.7% acc rate. Lowest ever?"
                    },
                    {
                        "username": "darshanbhimani999",
                        "content": "This is correct solution. but i don\\'t know leetcode is doing which type of activity. try this in Vscode or else.\\n\\n/*Darshan Bhimani - Svnit*/\\n \\n#include <bits/stdc++.h>\\n#include <iostream>\\n#include <string.h>\\n#include <math.h>\\n#include <bitset>\\n#include <vector>\\nusing namespace std;\\n#define ff first\\n#define ull unsigned long long int \\n#define uld unsigned long double\\n#define ss second\\n#define ll long long \\n#define pb push_back\\n#define mp make_pair\\n#define FOR(i, a, b) for (ll i = a; i < b; i++)\\n#define RFOR(i, a, b) for (int i = a; i >= b; i--)\\n\\nvector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) \\n{\\n    vector<int> ans;\\n\\n    if(k==1)\\n    {\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==p)\\n            {\\n                ans.push_back(0);\\n            }\\n            else\\n            {\\n                ans.push_back(-1);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n    else if(k%2!=0)\\n    {\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(0);\\n            v.push_back(0);\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n        ans[p]=1;\\n        v[p]=1;\\n\\n        if(p%2==0)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(i%2!=0)\\n                {\\n                    ans[i]=-1;\\n                    v[i]=-1;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(i%2==0)\\n                {\\n                    ans[i]=-1;\\n                    v[i]=-1;\\n                }\\n            }\\n        }\\n\\n        int x=log(n);\\n        while(x--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(ans[i]==0)\\n                {\\n                    int a[k];\\n                    int p=0;\\n                    a[0]=i-k+1;\\n                    for(int j=1;j<k;j++)\\n                    {\\n                        a[j]=a[j-1]+2;\\n                    }\\n\\n                    for(int j=0;j<k;j++)\\n                    {\\n                        if((a[j]>=0 && ans[a[j]]==-1) || (a[j]<0) || (i==a[j]))\\n                        {\\n                            p++;\\n                        }\\n                        else if(a[j]>=0 && ans[a[j]]==1)\\n                        {\\n                            ans[i]=1;\\n\\n                            if(v[i]==0)\\n                            {\\n                                v[i]=v[a[j]]+1;\\n                            }\\n                            if(v[i]!=0)\\n                            {\\n                                v[i]=min(v[i],v[a[j]]+1);\\n                            }\\n                        }\\n                    }\\n\\n                    if(p==k)\\n                    {\\n                        v[i]=-1;\\n                        ans[i]=-1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if (v[i]>=0)\\n            {\\n                v[i]--;\\n            }\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n\\n        return v;\\n    }\\n    else\\n    {\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(0);\\n            v.push_back(0);\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n        ans[p]=1;\\n        v[p]=1;\\n\\n        int x=log(n);\\n        while(x--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(ans[i]==0)\\n                {\\n                    int a[k];\\n                    int p=0;\\n                    a[0]=i-k+1;\\n                    for(int j=1;j<k;j++)\\n                    {\\n                        a[j]=a[j-1]+2;\\n                    }\\n\\n                    for(int j=0;j<k;j++)\\n                    {\\n                        if((a[j]>=0 && ans[a[j]]==-1) || (a[j]<0) || (i==a[j]))\\n                        {\\n                            p++;\\n                        }\\n                        else if(a[j]>=0 && ans[a[j]]==1)\\n                        {\\n                            ans[i]=1;\\n\\n                            if(v[i]==0)\\n                            {\\n                                v[i]=v[a[j]]+1;\\n                            }\\n                            if(v[i]!=0)\\n                            {\\n                                v[i]=min(v[i],v[a[j]]+1);\\n                            }\\n                        }\\n                    }\\n\\n                    if(p==k)\\n                    {\\n                        v[i]=-1;\\n                        ans[i]=-1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if (v[i]>=0)\\n            {\\n                v[i]--;\\n            }\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n\\n        return v;\\n    }\\n}\\n\\nint main()\\n{\\n    int n,k,p,bs;\\n    vector<int> banned={1,2};\\n\\n    cin>>n;\\n    cin>>p;\\n    cin>>bs;\\n    FOR(i,0,bs)\\n    {\\n        int x;\\n        cin>>x;\\n        banned.push_back(x);\\n    }\\n    cin>>k;\\n\\n    vector<int> v=minReverseOperations(n,p,banned,k);\\n\\n    FOR(i,0,n)\\n    {\\n        cout<<v[i]<<\" \";\\n    }\\n\\n    cout<<endl;\\n}\\n\\n\\ngive input according to int main()."
                    },
                    {
                        "username": "PrathameshTheCoder",
                        "content": "I wrote complete code on basis of foundational programming knowledge(if else, for loop), but getting TLE"
                    },
                    {
                        "username": "janis__",
                        "content": "To solve this problem, you need to explore all possible nodes reachable from the starting point while considering the restrictions. Use a breadth-first search (BFS) approach, starting from the start_point, and at each step, calculate the possible nodes you can jump to within the given range. Keep track of visited nodes and their distances from the start to avoid redundant exploration and to determine the minimum number of operations needed to reach each node."
                    }
                ]
            },
            {
                "id": 1851125,
                "content": [
                    {
                        "username": "Bharat_295",
                        "content": "My mind after seeing the acceptance in contest-: don\\'t even read! :)"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "people complaining Q3>>>>>>>>Q4 in previous contest. \\nLe Leetcode in Today\\'s contest: Q4>>>>>>>>>>>>>>>>>All questions on Leetcode"
                    },
                    {
                        "username": "EXBORN",
                        "content": "Tried BFS but TLE, apparently this is the approach most people took. Can\\'t think of an elegant way to improve time complexity."
                    },
                    {
                        "username": "Finesse",
                        "content": "Finally, I've found a way to optimize the BFS. Normally in BFS, when you walk from some node (array index), you check every reachable node, and visit only those that weren't visited. This approach takes `O(n*k)` time. To optimize it, you need to know the unvisited nodes without checking all the reachable somehow.\n\nMy idea is to use a BST (binary search tree) to store nodes that weren't visited, and remove the nodes from the tree as you perform the BFS. In fact, you need 2 trees: for even and odd array indices, otherwise it times-out. Thus, every node is not only visited once, but also checked once, the time complexity becomes `O(n*log(n))`.\n\nI can't call it elegant, because [my Python implementation](https://leetcode.com/problems/minimum-reverse-operations/submissions/926451022/) takes 140 lines, 115 of which are the tree implementation. But it's easy to grok because it's composed of smaller independent problems."
                    },
                    {
                        "username": "Finesse",
                        "content": "Trivial for odd `k`s, but none of my ideas works for even `k`s \\uD83E\\uDD2F"
                    },
                    {
                        "username": "mochy",
                        "content": "same :("
                    },
                    {
                        "username": "oystermajor",
                        "content": "Acceptance rate 1.8% lmao"
                    },
                    {
                        "username": "Finesse",
                        "content": "At least I don\\'t feel like an idiot after seeing the rate"
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Great problem, poorly written statement"
                    },
                    {
                        "username": "brinuke",
                        "content": "Yes, it needs a comma before *'representing a 0-indexed array'* and `arr[banned[i]] = 0` duplicates `banned[i] != p`."
                    },
                    {
                        "username": "prashik712",
                        "content": "I saw this question before the contest on Infosys power programmer OA 2 months back.  :\\'("
                    },
                    {
                        "username": "czjnbb",
                        "content": "1.7% acc rate. Lowest ever?"
                    },
                    {
                        "username": "darshanbhimani999",
                        "content": "This is correct solution. but i don\\'t know leetcode is doing which type of activity. try this in Vscode or else.\\n\\n/*Darshan Bhimani - Svnit*/\\n \\n#include <bits/stdc++.h>\\n#include <iostream>\\n#include <string.h>\\n#include <math.h>\\n#include <bitset>\\n#include <vector>\\nusing namespace std;\\n#define ff first\\n#define ull unsigned long long int \\n#define uld unsigned long double\\n#define ss second\\n#define ll long long \\n#define pb push_back\\n#define mp make_pair\\n#define FOR(i, a, b) for (ll i = a; i < b; i++)\\n#define RFOR(i, a, b) for (int i = a; i >= b; i--)\\n\\nvector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) \\n{\\n    vector<int> ans;\\n\\n    if(k==1)\\n    {\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==p)\\n            {\\n                ans.push_back(0);\\n            }\\n            else\\n            {\\n                ans.push_back(-1);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n    else if(k%2!=0)\\n    {\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(0);\\n            v.push_back(0);\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n        ans[p]=1;\\n        v[p]=1;\\n\\n        if(p%2==0)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(i%2!=0)\\n                {\\n                    ans[i]=-1;\\n                    v[i]=-1;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(i%2==0)\\n                {\\n                    ans[i]=-1;\\n                    v[i]=-1;\\n                }\\n            }\\n        }\\n\\n        int x=log(n);\\n        while(x--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(ans[i]==0)\\n                {\\n                    int a[k];\\n                    int p=0;\\n                    a[0]=i-k+1;\\n                    for(int j=1;j<k;j++)\\n                    {\\n                        a[j]=a[j-1]+2;\\n                    }\\n\\n                    for(int j=0;j<k;j++)\\n                    {\\n                        if((a[j]>=0 && ans[a[j]]==-1) || (a[j]<0) || (i==a[j]))\\n                        {\\n                            p++;\\n                        }\\n                        else if(a[j]>=0 && ans[a[j]]==1)\\n                        {\\n                            ans[i]=1;\\n\\n                            if(v[i]==0)\\n                            {\\n                                v[i]=v[a[j]]+1;\\n                            }\\n                            if(v[i]!=0)\\n                            {\\n                                v[i]=min(v[i],v[a[j]]+1);\\n                            }\\n                        }\\n                    }\\n\\n                    if(p==k)\\n                    {\\n                        v[i]=-1;\\n                        ans[i]=-1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if (v[i]>=0)\\n            {\\n                v[i]--;\\n            }\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n\\n        return v;\\n    }\\n    else\\n    {\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(0);\\n            v.push_back(0);\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n        ans[p]=1;\\n        v[p]=1;\\n\\n        int x=log(n);\\n        while(x--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(ans[i]==0)\\n                {\\n                    int a[k];\\n                    int p=0;\\n                    a[0]=i-k+1;\\n                    for(int j=1;j<k;j++)\\n                    {\\n                        a[j]=a[j-1]+2;\\n                    }\\n\\n                    for(int j=0;j<k;j++)\\n                    {\\n                        if((a[j]>=0 && ans[a[j]]==-1) || (a[j]<0) || (i==a[j]))\\n                        {\\n                            p++;\\n                        }\\n                        else if(a[j]>=0 && ans[a[j]]==1)\\n                        {\\n                            ans[i]=1;\\n\\n                            if(v[i]==0)\\n                            {\\n                                v[i]=v[a[j]]+1;\\n                            }\\n                            if(v[i]!=0)\\n                            {\\n                                v[i]=min(v[i],v[a[j]]+1);\\n                            }\\n                        }\\n                    }\\n\\n                    if(p==k)\\n                    {\\n                        v[i]=-1;\\n                        ans[i]=-1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if (v[i]>=0)\\n            {\\n                v[i]--;\\n            }\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n\\n        return v;\\n    }\\n}\\n\\nint main()\\n{\\n    int n,k,p,bs;\\n    vector<int> banned={1,2};\\n\\n    cin>>n;\\n    cin>>p;\\n    cin>>bs;\\n    FOR(i,0,bs)\\n    {\\n        int x;\\n        cin>>x;\\n        banned.push_back(x);\\n    }\\n    cin>>k;\\n\\n    vector<int> v=minReverseOperations(n,p,banned,k);\\n\\n    FOR(i,0,n)\\n    {\\n        cout<<v[i]<<\" \";\\n    }\\n\\n    cout<<endl;\\n}\\n\\n\\ngive input according to int main()."
                    },
                    {
                        "username": "PrathameshTheCoder",
                        "content": "I wrote complete code on basis of foundational programming knowledge(if else, for loop), but getting TLE"
                    },
                    {
                        "username": "janis__",
                        "content": "To solve this problem, you need to explore all possible nodes reachable from the starting point while considering the restrictions. Use a breadth-first search (BFS) approach, starting from the start_point, and at each step, calculate the possible nodes you can jump to within the given range. Keep track of visited nodes and their distances from the start to avoid redundant exploration and to determine the minimum number of operations needed to reach each node."
                    }
                ]
            },
            {
                "id": 1853551,
                "content": [
                    {
                        "username": "Bharat_295",
                        "content": "My mind after seeing the acceptance in contest-: don\\'t even read! :)"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "people complaining Q3>>>>>>>>Q4 in previous contest. \\nLe Leetcode in Today\\'s contest: Q4>>>>>>>>>>>>>>>>>All questions on Leetcode"
                    },
                    {
                        "username": "EXBORN",
                        "content": "Tried BFS but TLE, apparently this is the approach most people took. Can\\'t think of an elegant way to improve time complexity."
                    },
                    {
                        "username": "Finesse",
                        "content": "Finally, I've found a way to optimize the BFS. Normally in BFS, when you walk from some node (array index), you check every reachable node, and visit only those that weren't visited. This approach takes `O(n*k)` time. To optimize it, you need to know the unvisited nodes without checking all the reachable somehow.\n\nMy idea is to use a BST (binary search tree) to store nodes that weren't visited, and remove the nodes from the tree as you perform the BFS. In fact, you need 2 trees: for even and odd array indices, otherwise it times-out. Thus, every node is not only visited once, but also checked once, the time complexity becomes `O(n*log(n))`.\n\nI can't call it elegant, because [my Python implementation](https://leetcode.com/problems/minimum-reverse-operations/submissions/926451022/) takes 140 lines, 115 of which are the tree implementation. But it's easy to grok because it's composed of smaller independent problems."
                    },
                    {
                        "username": "Finesse",
                        "content": "Trivial for odd `k`s, but none of my ideas works for even `k`s \\uD83E\\uDD2F"
                    },
                    {
                        "username": "mochy",
                        "content": "same :("
                    },
                    {
                        "username": "oystermajor",
                        "content": "Acceptance rate 1.8% lmao"
                    },
                    {
                        "username": "Finesse",
                        "content": "At least I don\\'t feel like an idiot after seeing the rate"
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Great problem, poorly written statement"
                    },
                    {
                        "username": "brinuke",
                        "content": "Yes, it needs a comma before *'representing a 0-indexed array'* and `arr[banned[i]] = 0` duplicates `banned[i] != p`."
                    },
                    {
                        "username": "prashik712",
                        "content": "I saw this question before the contest on Infosys power programmer OA 2 months back.  :\\'("
                    },
                    {
                        "username": "czjnbb",
                        "content": "1.7% acc rate. Lowest ever?"
                    },
                    {
                        "username": "darshanbhimani999",
                        "content": "This is correct solution. but i don\\'t know leetcode is doing which type of activity. try this in Vscode or else.\\n\\n/*Darshan Bhimani - Svnit*/\\n \\n#include <bits/stdc++.h>\\n#include <iostream>\\n#include <string.h>\\n#include <math.h>\\n#include <bitset>\\n#include <vector>\\nusing namespace std;\\n#define ff first\\n#define ull unsigned long long int \\n#define uld unsigned long double\\n#define ss second\\n#define ll long long \\n#define pb push_back\\n#define mp make_pair\\n#define FOR(i, a, b) for (ll i = a; i < b; i++)\\n#define RFOR(i, a, b) for (int i = a; i >= b; i--)\\n\\nvector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) \\n{\\n    vector<int> ans;\\n\\n    if(k==1)\\n    {\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==p)\\n            {\\n                ans.push_back(0);\\n            }\\n            else\\n            {\\n                ans.push_back(-1);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n    else if(k%2!=0)\\n    {\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(0);\\n            v.push_back(0);\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n        ans[p]=1;\\n        v[p]=1;\\n\\n        if(p%2==0)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(i%2!=0)\\n                {\\n                    ans[i]=-1;\\n                    v[i]=-1;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(i%2==0)\\n                {\\n                    ans[i]=-1;\\n                    v[i]=-1;\\n                }\\n            }\\n        }\\n\\n        int x=log(n);\\n        while(x--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(ans[i]==0)\\n                {\\n                    int a[k];\\n                    int p=0;\\n                    a[0]=i-k+1;\\n                    for(int j=1;j<k;j++)\\n                    {\\n                        a[j]=a[j-1]+2;\\n                    }\\n\\n                    for(int j=0;j<k;j++)\\n                    {\\n                        if((a[j]>=0 && ans[a[j]]==-1) || (a[j]<0) || (i==a[j]))\\n                        {\\n                            p++;\\n                        }\\n                        else if(a[j]>=0 && ans[a[j]]==1)\\n                        {\\n                            ans[i]=1;\\n\\n                            if(v[i]==0)\\n                            {\\n                                v[i]=v[a[j]]+1;\\n                            }\\n                            if(v[i]!=0)\\n                            {\\n                                v[i]=min(v[i],v[a[j]]+1);\\n                            }\\n                        }\\n                    }\\n\\n                    if(p==k)\\n                    {\\n                        v[i]=-1;\\n                        ans[i]=-1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if (v[i]>=0)\\n            {\\n                v[i]--;\\n            }\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n\\n        return v;\\n    }\\n    else\\n    {\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(0);\\n            v.push_back(0);\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n        ans[p]=1;\\n        v[p]=1;\\n\\n        int x=log(n);\\n        while(x--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(ans[i]==0)\\n                {\\n                    int a[k];\\n                    int p=0;\\n                    a[0]=i-k+1;\\n                    for(int j=1;j<k;j++)\\n                    {\\n                        a[j]=a[j-1]+2;\\n                    }\\n\\n                    for(int j=0;j<k;j++)\\n                    {\\n                        if((a[j]>=0 && ans[a[j]]==-1) || (a[j]<0) || (i==a[j]))\\n                        {\\n                            p++;\\n                        }\\n                        else if(a[j]>=0 && ans[a[j]]==1)\\n                        {\\n                            ans[i]=1;\\n\\n                            if(v[i]==0)\\n                            {\\n                                v[i]=v[a[j]]+1;\\n                            }\\n                            if(v[i]!=0)\\n                            {\\n                                v[i]=min(v[i],v[a[j]]+1);\\n                            }\\n                        }\\n                    }\\n\\n                    if(p==k)\\n                    {\\n                        v[i]=-1;\\n                        ans[i]=-1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if (v[i]>=0)\\n            {\\n                v[i]--;\\n            }\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n\\n        return v;\\n    }\\n}\\n\\nint main()\\n{\\n    int n,k,p,bs;\\n    vector<int> banned={1,2};\\n\\n    cin>>n;\\n    cin>>p;\\n    cin>>bs;\\n    FOR(i,0,bs)\\n    {\\n        int x;\\n        cin>>x;\\n        banned.push_back(x);\\n    }\\n    cin>>k;\\n\\n    vector<int> v=minReverseOperations(n,p,banned,k);\\n\\n    FOR(i,0,n)\\n    {\\n        cout<<v[i]<<\" \";\\n    }\\n\\n    cout<<endl;\\n}\\n\\n\\ngive input according to int main()."
                    },
                    {
                        "username": "PrathameshTheCoder",
                        "content": "I wrote complete code on basis of foundational programming knowledge(if else, for loop), but getting TLE"
                    },
                    {
                        "username": "janis__",
                        "content": "To solve this problem, you need to explore all possible nodes reachable from the starting point while considering the restrictions. Use a breadth-first search (BFS) approach, starting from the start_point, and at each step, calculate the possible nodes you can jump to within the given range. Keep track of visited nodes and their distances from the start to avoid redundant exploration and to determine the minimum number of operations needed to reach each node."
                    }
                ]
            },
            {
                "id": 1850886,
                "content": [
                    {
                        "username": "Bharat_295",
                        "content": "My mind after seeing the acceptance in contest-: don\\'t even read! :)"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "people complaining Q3>>>>>>>>Q4 in previous contest. \\nLe Leetcode in Today\\'s contest: Q4>>>>>>>>>>>>>>>>>All questions on Leetcode"
                    },
                    {
                        "username": "EXBORN",
                        "content": "Tried BFS but TLE, apparently this is the approach most people took. Can\\'t think of an elegant way to improve time complexity."
                    },
                    {
                        "username": "Finesse",
                        "content": "Finally, I've found a way to optimize the BFS. Normally in BFS, when you walk from some node (array index), you check every reachable node, and visit only those that weren't visited. This approach takes `O(n*k)` time. To optimize it, you need to know the unvisited nodes without checking all the reachable somehow.\n\nMy idea is to use a BST (binary search tree) to store nodes that weren't visited, and remove the nodes from the tree as you perform the BFS. In fact, you need 2 trees: for even and odd array indices, otherwise it times-out. Thus, every node is not only visited once, but also checked once, the time complexity becomes `O(n*log(n))`.\n\nI can't call it elegant, because [my Python implementation](https://leetcode.com/problems/minimum-reverse-operations/submissions/926451022/) takes 140 lines, 115 of which are the tree implementation. But it's easy to grok because it's composed of smaller independent problems."
                    },
                    {
                        "username": "Finesse",
                        "content": "Trivial for odd `k`s, but none of my ideas works for even `k`s \\uD83E\\uDD2F"
                    },
                    {
                        "username": "mochy",
                        "content": "same :("
                    },
                    {
                        "username": "oystermajor",
                        "content": "Acceptance rate 1.8% lmao"
                    },
                    {
                        "username": "Finesse",
                        "content": "At least I don\\'t feel like an idiot after seeing the rate"
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Great problem, poorly written statement"
                    },
                    {
                        "username": "brinuke",
                        "content": "Yes, it needs a comma before *'representing a 0-indexed array'* and `arr[banned[i]] = 0` duplicates `banned[i] != p`."
                    },
                    {
                        "username": "prashik712",
                        "content": "I saw this question before the contest on Infosys power programmer OA 2 months back.  :\\'("
                    },
                    {
                        "username": "czjnbb",
                        "content": "1.7% acc rate. Lowest ever?"
                    },
                    {
                        "username": "darshanbhimani999",
                        "content": "This is correct solution. but i don\\'t know leetcode is doing which type of activity. try this in Vscode or else.\\n\\n/*Darshan Bhimani - Svnit*/\\n \\n#include <bits/stdc++.h>\\n#include <iostream>\\n#include <string.h>\\n#include <math.h>\\n#include <bitset>\\n#include <vector>\\nusing namespace std;\\n#define ff first\\n#define ull unsigned long long int \\n#define uld unsigned long double\\n#define ss second\\n#define ll long long \\n#define pb push_back\\n#define mp make_pair\\n#define FOR(i, a, b) for (ll i = a; i < b; i++)\\n#define RFOR(i, a, b) for (int i = a; i >= b; i--)\\n\\nvector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) \\n{\\n    vector<int> ans;\\n\\n    if(k==1)\\n    {\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==p)\\n            {\\n                ans.push_back(0);\\n            }\\n            else\\n            {\\n                ans.push_back(-1);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n    else if(k%2!=0)\\n    {\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(0);\\n            v.push_back(0);\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n        ans[p]=1;\\n        v[p]=1;\\n\\n        if(p%2==0)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(i%2!=0)\\n                {\\n                    ans[i]=-1;\\n                    v[i]=-1;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(i%2==0)\\n                {\\n                    ans[i]=-1;\\n                    v[i]=-1;\\n                }\\n            }\\n        }\\n\\n        int x=log(n);\\n        while(x--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(ans[i]==0)\\n                {\\n                    int a[k];\\n                    int p=0;\\n                    a[0]=i-k+1;\\n                    for(int j=1;j<k;j++)\\n                    {\\n                        a[j]=a[j-1]+2;\\n                    }\\n\\n                    for(int j=0;j<k;j++)\\n                    {\\n                        if((a[j]>=0 && ans[a[j]]==-1) || (a[j]<0) || (i==a[j]))\\n                        {\\n                            p++;\\n                        }\\n                        else if(a[j]>=0 && ans[a[j]]==1)\\n                        {\\n                            ans[i]=1;\\n\\n                            if(v[i]==0)\\n                            {\\n                                v[i]=v[a[j]]+1;\\n                            }\\n                            if(v[i]!=0)\\n                            {\\n                                v[i]=min(v[i],v[a[j]]+1);\\n                            }\\n                        }\\n                    }\\n\\n                    if(p==k)\\n                    {\\n                        v[i]=-1;\\n                        ans[i]=-1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if (v[i]>=0)\\n            {\\n                v[i]--;\\n            }\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n\\n        return v;\\n    }\\n    else\\n    {\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(0);\\n            v.push_back(0);\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n        ans[p]=1;\\n        v[p]=1;\\n\\n        int x=log(n);\\n        while(x--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(ans[i]==0)\\n                {\\n                    int a[k];\\n                    int p=0;\\n                    a[0]=i-k+1;\\n                    for(int j=1;j<k;j++)\\n                    {\\n                        a[j]=a[j-1]+2;\\n                    }\\n\\n                    for(int j=0;j<k;j++)\\n                    {\\n                        if((a[j]>=0 && ans[a[j]]==-1) || (a[j]<0) || (i==a[j]))\\n                        {\\n                            p++;\\n                        }\\n                        else if(a[j]>=0 && ans[a[j]]==1)\\n                        {\\n                            ans[i]=1;\\n\\n                            if(v[i]==0)\\n                            {\\n                                v[i]=v[a[j]]+1;\\n                            }\\n                            if(v[i]!=0)\\n                            {\\n                                v[i]=min(v[i],v[a[j]]+1);\\n                            }\\n                        }\\n                    }\\n\\n                    if(p==k)\\n                    {\\n                        v[i]=-1;\\n                        ans[i]=-1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if (v[i]>=0)\\n            {\\n                v[i]--;\\n            }\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n\\n        return v;\\n    }\\n}\\n\\nint main()\\n{\\n    int n,k,p,bs;\\n    vector<int> banned={1,2};\\n\\n    cin>>n;\\n    cin>>p;\\n    cin>>bs;\\n    FOR(i,0,bs)\\n    {\\n        int x;\\n        cin>>x;\\n        banned.push_back(x);\\n    }\\n    cin>>k;\\n\\n    vector<int> v=minReverseOperations(n,p,banned,k);\\n\\n    FOR(i,0,n)\\n    {\\n        cout<<v[i]<<\" \";\\n    }\\n\\n    cout<<endl;\\n}\\n\\n\\ngive input according to int main()."
                    },
                    {
                        "username": "PrathameshTheCoder",
                        "content": "I wrote complete code on basis of foundational programming knowledge(if else, for loop), but getting TLE"
                    },
                    {
                        "username": "janis__",
                        "content": "To solve this problem, you need to explore all possible nodes reachable from the starting point while considering the restrictions. Use a breadth-first search (BFS) approach, starting from the start_point, and at each step, calculate the possible nodes you can jump to within the given range. Keep track of visited nodes and their distances from the start to avoid redundant exploration and to determine the minimum number of operations needed to reach each node."
                    }
                ]
            },
            {
                "id": 1898053,
                "content": [
                    {
                        "username": "Bharat_295",
                        "content": "My mind after seeing the acceptance in contest-: don\\'t even read! :)"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "people complaining Q3>>>>>>>>Q4 in previous contest. \\nLe Leetcode in Today\\'s contest: Q4>>>>>>>>>>>>>>>>>All questions on Leetcode"
                    },
                    {
                        "username": "EXBORN",
                        "content": "Tried BFS but TLE, apparently this is the approach most people took. Can\\'t think of an elegant way to improve time complexity."
                    },
                    {
                        "username": "Finesse",
                        "content": "Finally, I've found a way to optimize the BFS. Normally in BFS, when you walk from some node (array index), you check every reachable node, and visit only those that weren't visited. This approach takes `O(n*k)` time. To optimize it, you need to know the unvisited nodes without checking all the reachable somehow.\n\nMy idea is to use a BST (binary search tree) to store nodes that weren't visited, and remove the nodes from the tree as you perform the BFS. In fact, you need 2 trees: for even and odd array indices, otherwise it times-out. Thus, every node is not only visited once, but also checked once, the time complexity becomes `O(n*log(n))`.\n\nI can't call it elegant, because [my Python implementation](https://leetcode.com/problems/minimum-reverse-operations/submissions/926451022/) takes 140 lines, 115 of which are the tree implementation. But it's easy to grok because it's composed of smaller independent problems."
                    },
                    {
                        "username": "Finesse",
                        "content": "Trivial for odd `k`s, but none of my ideas works for even `k`s \\uD83E\\uDD2F"
                    },
                    {
                        "username": "mochy",
                        "content": "same :("
                    },
                    {
                        "username": "oystermajor",
                        "content": "Acceptance rate 1.8% lmao"
                    },
                    {
                        "username": "Finesse",
                        "content": "At least I don\\'t feel like an idiot after seeing the rate"
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Great problem, poorly written statement"
                    },
                    {
                        "username": "brinuke",
                        "content": "Yes, it needs a comma before *'representing a 0-indexed array'* and `arr[banned[i]] = 0` duplicates `banned[i] != p`."
                    },
                    {
                        "username": "prashik712",
                        "content": "I saw this question before the contest on Infosys power programmer OA 2 months back.  :\\'("
                    },
                    {
                        "username": "czjnbb",
                        "content": "1.7% acc rate. Lowest ever?"
                    },
                    {
                        "username": "darshanbhimani999",
                        "content": "This is correct solution. but i don\\'t know leetcode is doing which type of activity. try this in Vscode or else.\\n\\n/*Darshan Bhimani - Svnit*/\\n \\n#include <bits/stdc++.h>\\n#include <iostream>\\n#include <string.h>\\n#include <math.h>\\n#include <bitset>\\n#include <vector>\\nusing namespace std;\\n#define ff first\\n#define ull unsigned long long int \\n#define uld unsigned long double\\n#define ss second\\n#define ll long long \\n#define pb push_back\\n#define mp make_pair\\n#define FOR(i, a, b) for (ll i = a; i < b; i++)\\n#define RFOR(i, a, b) for (int i = a; i >= b; i--)\\n\\nvector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) \\n{\\n    vector<int> ans;\\n\\n    if(k==1)\\n    {\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==p)\\n            {\\n                ans.push_back(0);\\n            }\\n            else\\n            {\\n                ans.push_back(-1);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n    else if(k%2!=0)\\n    {\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(0);\\n            v.push_back(0);\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n        ans[p]=1;\\n        v[p]=1;\\n\\n        if(p%2==0)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(i%2!=0)\\n                {\\n                    ans[i]=-1;\\n                    v[i]=-1;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(i%2==0)\\n                {\\n                    ans[i]=-1;\\n                    v[i]=-1;\\n                }\\n            }\\n        }\\n\\n        int x=log(n);\\n        while(x--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(ans[i]==0)\\n                {\\n                    int a[k];\\n                    int p=0;\\n                    a[0]=i-k+1;\\n                    for(int j=1;j<k;j++)\\n                    {\\n                        a[j]=a[j-1]+2;\\n                    }\\n\\n                    for(int j=0;j<k;j++)\\n                    {\\n                        if((a[j]>=0 && ans[a[j]]==-1) || (a[j]<0) || (i==a[j]))\\n                        {\\n                            p++;\\n                        }\\n                        else if(a[j]>=0 && ans[a[j]]==1)\\n                        {\\n                            ans[i]=1;\\n\\n                            if(v[i]==0)\\n                            {\\n                                v[i]=v[a[j]]+1;\\n                            }\\n                            if(v[i]!=0)\\n                            {\\n                                v[i]=min(v[i],v[a[j]]+1);\\n                            }\\n                        }\\n                    }\\n\\n                    if(p==k)\\n                    {\\n                        v[i]=-1;\\n                        ans[i]=-1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if (v[i]>=0)\\n            {\\n                v[i]--;\\n            }\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n\\n        return v;\\n    }\\n    else\\n    {\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(0);\\n            v.push_back(0);\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n        ans[p]=1;\\n        v[p]=1;\\n\\n        int x=log(n);\\n        while(x--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(ans[i]==0)\\n                {\\n                    int a[k];\\n                    int p=0;\\n                    a[0]=i-k+1;\\n                    for(int j=1;j<k;j++)\\n                    {\\n                        a[j]=a[j-1]+2;\\n                    }\\n\\n                    for(int j=0;j<k;j++)\\n                    {\\n                        if((a[j]>=0 && ans[a[j]]==-1) || (a[j]<0) || (i==a[j]))\\n                        {\\n                            p++;\\n                        }\\n                        else if(a[j]>=0 && ans[a[j]]==1)\\n                        {\\n                            ans[i]=1;\\n\\n                            if(v[i]==0)\\n                            {\\n                                v[i]=v[a[j]]+1;\\n                            }\\n                            if(v[i]!=0)\\n                            {\\n                                v[i]=min(v[i],v[a[j]]+1);\\n                            }\\n                        }\\n                    }\\n\\n                    if(p==k)\\n                    {\\n                        v[i]=-1;\\n                        ans[i]=-1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if (v[i]>=0)\\n            {\\n                v[i]--;\\n            }\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n\\n        return v;\\n    }\\n}\\n\\nint main()\\n{\\n    int n,k,p,bs;\\n    vector<int> banned={1,2};\\n\\n    cin>>n;\\n    cin>>p;\\n    cin>>bs;\\n    FOR(i,0,bs)\\n    {\\n        int x;\\n        cin>>x;\\n        banned.push_back(x);\\n    }\\n    cin>>k;\\n\\n    vector<int> v=minReverseOperations(n,p,banned,k);\\n\\n    FOR(i,0,n)\\n    {\\n        cout<<v[i]<<\" \";\\n    }\\n\\n    cout<<endl;\\n}\\n\\n\\ngive input according to int main()."
                    },
                    {
                        "username": "PrathameshTheCoder",
                        "content": "I wrote complete code on basis of foundational programming knowledge(if else, for loop), but getting TLE"
                    },
                    {
                        "username": "janis__",
                        "content": "To solve this problem, you need to explore all possible nodes reachable from the starting point while considering the restrictions. Use a breadth-first search (BFS) approach, starting from the start_point, and at each step, calculate the possible nodes you can jump to within the given range. Keep track of visited nodes and their distances from the start to avoid redundant exploration and to determine the minimum number of operations needed to reach each node."
                    }
                ]
            },
            {
                "id": 2060519,
                "content": [
                    {
                        "username": "Bharat_295",
                        "content": "My mind after seeing the acceptance in contest-: don\\'t even read! :)"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "people complaining Q3>>>>>>>>Q4 in previous contest. \\nLe Leetcode in Today\\'s contest: Q4>>>>>>>>>>>>>>>>>All questions on Leetcode"
                    },
                    {
                        "username": "EXBORN",
                        "content": "Tried BFS but TLE, apparently this is the approach most people took. Can\\'t think of an elegant way to improve time complexity."
                    },
                    {
                        "username": "Finesse",
                        "content": "Finally, I've found a way to optimize the BFS. Normally in BFS, when you walk from some node (array index), you check every reachable node, and visit only those that weren't visited. This approach takes `O(n*k)` time. To optimize it, you need to know the unvisited nodes without checking all the reachable somehow.\n\nMy idea is to use a BST (binary search tree) to store nodes that weren't visited, and remove the nodes from the tree as you perform the BFS. In fact, you need 2 trees: for even and odd array indices, otherwise it times-out. Thus, every node is not only visited once, but also checked once, the time complexity becomes `O(n*log(n))`.\n\nI can't call it elegant, because [my Python implementation](https://leetcode.com/problems/minimum-reverse-operations/submissions/926451022/) takes 140 lines, 115 of which are the tree implementation. But it's easy to grok because it's composed of smaller independent problems."
                    },
                    {
                        "username": "Finesse",
                        "content": "Trivial for odd `k`s, but none of my ideas works for even `k`s \\uD83E\\uDD2F"
                    },
                    {
                        "username": "mochy",
                        "content": "same :("
                    },
                    {
                        "username": "oystermajor",
                        "content": "Acceptance rate 1.8% lmao"
                    },
                    {
                        "username": "Finesse",
                        "content": "At least I don\\'t feel like an idiot after seeing the rate"
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Great problem, poorly written statement"
                    },
                    {
                        "username": "brinuke",
                        "content": "Yes, it needs a comma before *'representing a 0-indexed array'* and `arr[banned[i]] = 0` duplicates `banned[i] != p`."
                    },
                    {
                        "username": "prashik712",
                        "content": "I saw this question before the contest on Infosys power programmer OA 2 months back.  :\\'("
                    },
                    {
                        "username": "czjnbb",
                        "content": "1.7% acc rate. Lowest ever?"
                    },
                    {
                        "username": "darshanbhimani999",
                        "content": "This is correct solution. but i don\\'t know leetcode is doing which type of activity. try this in Vscode or else.\\n\\n/*Darshan Bhimani - Svnit*/\\n \\n#include <bits/stdc++.h>\\n#include <iostream>\\n#include <string.h>\\n#include <math.h>\\n#include <bitset>\\n#include <vector>\\nusing namespace std;\\n#define ff first\\n#define ull unsigned long long int \\n#define uld unsigned long double\\n#define ss second\\n#define ll long long \\n#define pb push_back\\n#define mp make_pair\\n#define FOR(i, a, b) for (ll i = a; i < b; i++)\\n#define RFOR(i, a, b) for (int i = a; i >= b; i--)\\n\\nvector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) \\n{\\n    vector<int> ans;\\n\\n    if(k==1)\\n    {\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==p)\\n            {\\n                ans.push_back(0);\\n            }\\n            else\\n            {\\n                ans.push_back(-1);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n    else if(k%2!=0)\\n    {\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(0);\\n            v.push_back(0);\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n        ans[p]=1;\\n        v[p]=1;\\n\\n        if(p%2==0)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(i%2!=0)\\n                {\\n                    ans[i]=-1;\\n                    v[i]=-1;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(i%2==0)\\n                {\\n                    ans[i]=-1;\\n                    v[i]=-1;\\n                }\\n            }\\n        }\\n\\n        int x=log(n);\\n        while(x--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(ans[i]==0)\\n                {\\n                    int a[k];\\n                    int p=0;\\n                    a[0]=i-k+1;\\n                    for(int j=1;j<k;j++)\\n                    {\\n                        a[j]=a[j-1]+2;\\n                    }\\n\\n                    for(int j=0;j<k;j++)\\n                    {\\n                        if((a[j]>=0 && ans[a[j]]==-1) || (a[j]<0) || (i==a[j]))\\n                        {\\n                            p++;\\n                        }\\n                        else if(a[j]>=0 && ans[a[j]]==1)\\n                        {\\n                            ans[i]=1;\\n\\n                            if(v[i]==0)\\n                            {\\n                                v[i]=v[a[j]]+1;\\n                            }\\n                            if(v[i]!=0)\\n                            {\\n                                v[i]=min(v[i],v[a[j]]+1);\\n                            }\\n                        }\\n                    }\\n\\n                    if(p==k)\\n                    {\\n                        v[i]=-1;\\n                        ans[i]=-1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if (v[i]>=0)\\n            {\\n                v[i]--;\\n            }\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n\\n        return v;\\n    }\\n    else\\n    {\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(0);\\n            v.push_back(0);\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n        ans[p]=1;\\n        v[p]=1;\\n\\n        int x=log(n);\\n        while(x--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(ans[i]==0)\\n                {\\n                    int a[k];\\n                    int p=0;\\n                    a[0]=i-k+1;\\n                    for(int j=1;j<k;j++)\\n                    {\\n                        a[j]=a[j-1]+2;\\n                    }\\n\\n                    for(int j=0;j<k;j++)\\n                    {\\n                        if((a[j]>=0 && ans[a[j]]==-1) || (a[j]<0) || (i==a[j]))\\n                        {\\n                            p++;\\n                        }\\n                        else if(a[j]>=0 && ans[a[j]]==1)\\n                        {\\n                            ans[i]=1;\\n\\n                            if(v[i]==0)\\n                            {\\n                                v[i]=v[a[j]]+1;\\n                            }\\n                            if(v[i]!=0)\\n                            {\\n                                v[i]=min(v[i],v[a[j]]+1);\\n                            }\\n                        }\\n                    }\\n\\n                    if(p==k)\\n                    {\\n                        v[i]=-1;\\n                        ans[i]=-1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if (v[i]>=0)\\n            {\\n                v[i]--;\\n            }\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n\\n        return v;\\n    }\\n}\\n\\nint main()\\n{\\n    int n,k,p,bs;\\n    vector<int> banned={1,2};\\n\\n    cin>>n;\\n    cin>>p;\\n    cin>>bs;\\n    FOR(i,0,bs)\\n    {\\n        int x;\\n        cin>>x;\\n        banned.push_back(x);\\n    }\\n    cin>>k;\\n\\n    vector<int> v=minReverseOperations(n,p,banned,k);\\n\\n    FOR(i,0,n)\\n    {\\n        cout<<v[i]<<\" \";\\n    }\\n\\n    cout<<endl;\\n}\\n\\n\\ngive input according to int main()."
                    },
                    {
                        "username": "PrathameshTheCoder",
                        "content": "I wrote complete code on basis of foundational programming knowledge(if else, for loop), but getting TLE"
                    },
                    {
                        "username": "janis__",
                        "content": "To solve this problem, you need to explore all possible nodes reachable from the starting point while considering the restrictions. Use a breadth-first search (BFS) approach, starting from the start_point, and at each step, calculate the possible nodes you can jump to within the given range. Keep track of visited nodes and their distances from the start to avoid redundant exploration and to determine the minimum number of operations needed to reach each node."
                    }
                ]
            },
            {
                "id": 2042926,
                "content": [
                    {
                        "username": "Bharat_295",
                        "content": "My mind after seeing the acceptance in contest-: don\\'t even read! :)"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "people complaining Q3>>>>>>>>Q4 in previous contest. \\nLe Leetcode in Today\\'s contest: Q4>>>>>>>>>>>>>>>>>All questions on Leetcode"
                    },
                    {
                        "username": "EXBORN",
                        "content": "Tried BFS but TLE, apparently this is the approach most people took. Can\\'t think of an elegant way to improve time complexity."
                    },
                    {
                        "username": "Finesse",
                        "content": "Finally, I've found a way to optimize the BFS. Normally in BFS, when you walk from some node (array index), you check every reachable node, and visit only those that weren't visited. This approach takes `O(n*k)` time. To optimize it, you need to know the unvisited nodes without checking all the reachable somehow.\n\nMy idea is to use a BST (binary search tree) to store nodes that weren't visited, and remove the nodes from the tree as you perform the BFS. In fact, you need 2 trees: for even and odd array indices, otherwise it times-out. Thus, every node is not only visited once, but also checked once, the time complexity becomes `O(n*log(n))`.\n\nI can't call it elegant, because [my Python implementation](https://leetcode.com/problems/minimum-reverse-operations/submissions/926451022/) takes 140 lines, 115 of which are the tree implementation. But it's easy to grok because it's composed of smaller independent problems."
                    },
                    {
                        "username": "Finesse",
                        "content": "Trivial for odd `k`s, but none of my ideas works for even `k`s \\uD83E\\uDD2F"
                    },
                    {
                        "username": "mochy",
                        "content": "same :("
                    },
                    {
                        "username": "oystermajor",
                        "content": "Acceptance rate 1.8% lmao"
                    },
                    {
                        "username": "Finesse",
                        "content": "At least I don\\'t feel like an idiot after seeing the rate"
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "Great problem, poorly written statement"
                    },
                    {
                        "username": "brinuke",
                        "content": "Yes, it needs a comma before *'representing a 0-indexed array'* and `arr[banned[i]] = 0` duplicates `banned[i] != p`."
                    },
                    {
                        "username": "prashik712",
                        "content": "I saw this question before the contest on Infosys power programmer OA 2 months back.  :\\'("
                    },
                    {
                        "username": "czjnbb",
                        "content": "1.7% acc rate. Lowest ever?"
                    },
                    {
                        "username": "darshanbhimani999",
                        "content": "This is correct solution. but i don\\'t know leetcode is doing which type of activity. try this in Vscode or else.\\n\\n/*Darshan Bhimani - Svnit*/\\n \\n#include <bits/stdc++.h>\\n#include <iostream>\\n#include <string.h>\\n#include <math.h>\\n#include <bitset>\\n#include <vector>\\nusing namespace std;\\n#define ff first\\n#define ull unsigned long long int \\n#define uld unsigned long double\\n#define ss second\\n#define ll long long \\n#define pb push_back\\n#define mp make_pair\\n#define FOR(i, a, b) for (ll i = a; i < b; i++)\\n#define RFOR(i, a, b) for (int i = a; i >= b; i--)\\n\\nvector<int> minReverseOperations(int n, int p, vector<int>& banned, int k) \\n{\\n    vector<int> ans;\\n\\n    if(k==1)\\n    {\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i==p)\\n            {\\n                ans.push_back(0);\\n            }\\n            else\\n            {\\n                ans.push_back(-1);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n    else if(k%2!=0)\\n    {\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(0);\\n            v.push_back(0);\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n        ans[p]=1;\\n        v[p]=1;\\n\\n        if(p%2==0)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(i%2!=0)\\n                {\\n                    ans[i]=-1;\\n                    v[i]=-1;\\n                }\\n            }\\n        }\\n        else\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(i%2==0)\\n                {\\n                    ans[i]=-1;\\n                    v[i]=-1;\\n                }\\n            }\\n        }\\n\\n        int x=log(n);\\n        while(x--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(ans[i]==0)\\n                {\\n                    int a[k];\\n                    int p=0;\\n                    a[0]=i-k+1;\\n                    for(int j=1;j<k;j++)\\n                    {\\n                        a[j]=a[j-1]+2;\\n                    }\\n\\n                    for(int j=0;j<k;j++)\\n                    {\\n                        if((a[j]>=0 && ans[a[j]]==-1) || (a[j]<0) || (i==a[j]))\\n                        {\\n                            p++;\\n                        }\\n                        else if(a[j]>=0 && ans[a[j]]==1)\\n                        {\\n                            ans[i]=1;\\n\\n                            if(v[i]==0)\\n                            {\\n                                v[i]=v[a[j]]+1;\\n                            }\\n                            if(v[i]!=0)\\n                            {\\n                                v[i]=min(v[i],v[a[j]]+1);\\n                            }\\n                        }\\n                    }\\n\\n                    if(p==k)\\n                    {\\n                        v[i]=-1;\\n                        ans[i]=-1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if (v[i]>=0)\\n            {\\n                v[i]--;\\n            }\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n\\n        return v;\\n    }\\n    else\\n    {\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(0);\\n            v.push_back(0);\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n        ans[p]=1;\\n        v[p]=1;\\n\\n        int x=log(n);\\n        while(x--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if(ans[i]==0)\\n                {\\n                    int a[k];\\n                    int p=0;\\n                    a[0]=i-k+1;\\n                    for(int j=1;j<k;j++)\\n                    {\\n                        a[j]=a[j-1]+2;\\n                    }\\n\\n                    for(int j=0;j<k;j++)\\n                    {\\n                        if((a[j]>=0 && ans[a[j]]==-1) || (a[j]<0) || (i==a[j]))\\n                        {\\n                            p++;\\n                        }\\n                        else if(a[j]>=0 && ans[a[j]]==1)\\n                        {\\n                            ans[i]=1;\\n\\n                            if(v[i]==0)\\n                            {\\n                                v[i]=v[a[j]]+1;\\n                            }\\n                            if(v[i]!=0)\\n                            {\\n                                v[i]=min(v[i],v[a[j]]+1);\\n                            }\\n                        }\\n                    }\\n\\n                    if(p==k)\\n                    {\\n                        v[i]=-1;\\n                        ans[i]=-1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if (v[i]>=0)\\n            {\\n                v[i]--;\\n            }\\n        }\\n        for(int i=0;i<banned.size();i++)\\n        {\\n            ans[banned[i]]=-1;\\n            v[banned[i]]=-1;\\n        }\\n\\n        return v;\\n    }\\n}\\n\\nint main()\\n{\\n    int n,k,p,bs;\\n    vector<int> banned={1,2};\\n\\n    cin>>n;\\n    cin>>p;\\n    cin>>bs;\\n    FOR(i,0,bs)\\n    {\\n        int x;\\n        cin>>x;\\n        banned.push_back(x);\\n    }\\n    cin>>k;\\n\\n    vector<int> v=minReverseOperations(n,p,banned,k);\\n\\n    FOR(i,0,n)\\n    {\\n        cout<<v[i]<<\" \";\\n    }\\n\\n    cout<<endl;\\n}\\n\\n\\ngive input according to int main()."
                    },
                    {
                        "username": "PrathameshTheCoder",
                        "content": "I wrote complete code on basis of foundational programming knowledge(if else, for loop), but getting TLE"
                    },
                    {
                        "username": "janis__",
                        "content": "To solve this problem, you need to explore all possible nodes reachable from the starting point while considering the restrictions. Use a breadth-first search (BFS) approach, starting from the start_point, and at each step, calculate the possible nodes you can jump to within the given range. Keep track of visited nodes and their distances from the start to avoid redundant exploration and to determine the minimum number of operations needed to reach each node."
                    }
                ]
            }
        ]
    }
]