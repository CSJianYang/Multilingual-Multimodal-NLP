[
    {
        "title": "Longest Ideal Subsequence",
        "question_content": "You are given a string s consisting of lowercase letters and an integer k. We call a string t ideal if the following conditions are satisfied:\n\n\tt is a subsequence of the string s.\n\tThe absolute difference in the alphabet order of every two adjacent letters in t is less than or equal to k.\n\nReturn the length of the longest ideal string.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\nNote that the alphabet order is not cyclic. For example, the absolute difference in the alphabet order of 'a' and 'z' is 25, not 1.\n&nbsp;\nExample 1:\n\nInput: s = \"acfgbd\", k = 2\nOutput: 4\nExplanation: The longest ideal string is \"acbd\". The length of this string is 4, so 4 is returned.\nNote that \"acfgbd\" is not ideal because 'c' and 'f' have a difference of 3 in alphabet order.\nExample 2:\n\nInput: s = \"abcd\", k = 3\nOutput: 4\nExplanation: The longest ideal string is \"abcd\". The length of this string is 4, so 4 is returned.\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 105\n\t0 <= k <= 25\n\ts consists of lowercase English letters.",
        "solutions": [
            {
                "id": 2390512,
                "title": "java-c-python-dp-solution",
                "content": "# **Explanation**\\n`dp[c]` means the length of the longest ideal subsequence\\nending with character `c`.\\n\\nIterate the character `i` in string `s`,\\n`c` can be the next character for string ending from `i - k` to `i + k`.\\nSo that `dp[i] = max(dp[i-k], dp[i-k+1] ... , dp[i+k]) + 1`.\\n\\nreturn the `max(dp)` as result.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(128)`\\n<br>\\n\\n**Java**\\n```java\\n    public int longestIdealString(String s, int k) {\\n        int res = 0, n = s.length(), dp[] = new int[150];\\n        for (int ci = 0; ci < n; ++ci) {\\n            int i = s.charAt(ci);\\n            for (int j = i - k; j <= i + k; ++j)\\n                dp[i] = Math.max(dp[i], dp[j]);\\n            res = Math.max(res, ++dp[i]);\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int longestIdealString(string s, int k) {\\n        int dp[150] = {}, res = 0;\\n        for (auto& i : s) {\\n            for (int j = i - k; j <= i + k; ++j)\\n                dp[i] = max(dp[i], dp[j]);\\n            res = max(res, ++dp[i]);\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python**\\nCan be improved to O(128) space.\\n```py\\n    def longestIdealString(self, s, k):\\n        dp = [0] * 128\\n        for c in s:\\n            i = ord(c)\\n            dp[i] = max(dp[i - k : i + k + 1]) + 1\\n        return max(dp)\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int longestIdealString(String s, int k) {\\n        int res = 0, n = s.length(), dp[] = new int[150];\\n        for (int ci = 0; ci < n; ++ci) {\\n            int i = s.charAt(ci);\\n            for (int j = i - k; j <= i + k; ++j)\\n                dp[i] = Math.max(dp[i], dp[j]);\\n            res = Math.max(res, ++dp[i]);\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int longestIdealString(string s, int k) {\\n        int dp[150] = {}, res = 0;\\n        for (auto& i : s) {\\n            for (int j = i - k; j <= i + k; ++j)\\n                dp[i] = max(dp[i], dp[j]);\\n            res = max(res, ++dp[i]);\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def longestIdealString(self, s, k):\\n        dp = [0] * 128\\n        for c in s:\\n            i = ord(c)\\n            dp[i] = max(dp[i - k : i + k + 1]) + 1\\n        return max(dp)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2390850,
                "title": "easy-to-understand-dp-lis-o-n",
                "content": "**Approach**\\n\\nSimilar to longest increasing subsequence with slight modification, consider a DP array of size 26 where each index coresponds to the size of maximum subsequence which ends with the character i (here characters are mapped from 0 - 25, i.e. a -> 0, b -> 1, .... z -> 25).\\n\\nNow consider iterating from every character in the string from left to right name this iterator **ch**\\nNow for every ch there is some index (int)ch - \\'a\\' in the DP array say it i\\nNow for every j from max(0, i - k) to min(25, i + k) DP[i] = max(DP[i], DP[j] + 1)\\nThis is, every character that ends with character j that can be used to append this character i, with maximum 1 + DP[j] length.\\n\\nHere the case where j = i should be taken separately because it might happen that it apear earlier and you might modify it several times.\\n\\n**Time Complexity**\\nO(n) all the elements in string are iterated once and each iteration rquires maximum of 26 operations which is constant.\\n\\n**Space Complexity**\\nO(1) constant size (26) array for DP\\n\\n**Code**\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        int DP[26] = {0}, ans = 1;\\n        \\n        for (char &ch: s) {\\n            int i = ch - \\'a\\';\\n            DP[i] = DP[i] + 1;\\n            \\n            for (int j = max(0, i - k); j <= min(25, i + k); j++)\\n                if (j != i)\\n                    DP[i] = max(DP[i], DP[j] + 1);\\n            \\n            ans = max(ans, DP[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```\\nclass Solution:\\n    def longestIdealString(self, s: str, k: int) -> int:\\n        DP = [0 for _ in range(26)]\\n        ans = 1\\n        \\n        for ch in s:\\n            i = ord(ch) - ord(\\'a\\')\\n            DP[i] = DP[i] + 1\\n            \\n            for j in range(max(0, i - k), min(25, i + k) + 1):\\n                if j != i:\\n                    DP[i] = max(DP[i], DP[j] + 1)\\n            \\n            ans = max(ans, DP[i])\\n        \\n        return ans\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    public int longestIdealString(String s, int k) {\\n        int DP[] = new int[26], ans = 1;\\n        \\n        for (int ch = 0, n = s.length(); ch < n; ch++) {\\n            int i = s.charAt(ch) - \\'a\\';\\n            DP[i] = DP[i] + 1;\\n            \\n            for (int j = Math.max(0, i - k); j <= Math.min(25, i + k); j++)\\n                if (j != i)\\n                    DP[i] = Math.max(DP[i], DP[j] + 1);\\n            \\n            ans = Math.max(ans, DP[i]);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        int DP[26] = {0}, ans = 1;\\n        \\n        for (char &ch: s) {\\n            int i = ch - \\'a\\';\\n            DP[i] = DP[i] + 1;\\n            \\n            for (int j = max(0, i - k); j <= min(25, i + k); j++)\\n                if (j != i)\\n                    DP[i] = max(DP[i], DP[j] + 1);\\n            \\n            ans = max(ans, DP[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def longestIdealString(self, s: str, k: int) -> int:\\n        DP = [0 for _ in range(26)]\\n        ans = 1\\n        \\n        for ch in s:\\n            i = ord(ch) - ord(\\'a\\')\\n            DP[i] = DP[i] + 1\\n            \\n            for j in range(max(0, i - k), min(25, i + k) + 1):\\n                if j != i:\\n                    DP[i] = max(DP[i], DP[j] + 1)\\n            \\n            ans = max(ans, DP[i])\\n        \\n        return ans\\n```\n```\\nclass Solution {\\n    public int longestIdealString(String s, int k) {\\n        int DP[] = new int[26], ans = 1;\\n        \\n        for (int ch = 0, n = s.length(); ch < n; ch++) {\\n            int i = s.charAt(ch) - \\'a\\';\\n            DP[i] = DP[i] + 1;\\n            \\n            for (int j = Math.max(0, i - k); j <= Math.min(25, i + k); j++)\\n                if (j != i)\\n                    DP[i] = Math.max(DP[i], DP[j] + 1);\\n            \\n            ans = Math.max(ans, DP[i]);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390499,
                "title": "top-down-dp-dp-s-length-ascii-value-dp-meme",
                "content": "top down dp ,\\n\\ndp states are dp[index][lastPickedChar] \\nas I don\\'t want to mess in code so I have taken DP dimension as s.length()*150 where max 150 is ascii value of alphabets\\n\\n```\\nclass Solution {\\n    int helper_function(String s,int k,int idx,char ch,int dp[][]){\\n        if(idx==s.length()) return 0;\\n        if(dp[idx][ch]!=-1) return dp[idx][ch];\\n        int pick=0;\\n             if(Math.abs(ch-s.charAt(idx))<=k || ch==\\'#\\') pick=1+helper_function(s,k,idx+1,s.charAt(idx),dp);\\n            int notpick=helper_function(s,k,idx+1,ch,dp);\\n       return dp[idx][ch]=Math.max(pick,notpick);\\n        \\n    }\\n    public int longestIdealString(String s, int k) {\\n        int n=s.length();\\n        int dp[][]=new int[n+1][150];\\n        for(int sub_array[]:dp)\\n         Arrays.fill(sub_array,-1);\\n        return helper_function(s,k,0,\\'#\\',dp); // taken # as dummy char becuase in ascii table # is adjcent of z , so it will automatically cover by 150 dimension of dp\\n        \\n    }\\n\\n}\\n```\\n\\n**Iterative Version**\\n\\n```\\nclass Solution {\\n    public int longestIdealString(String s, int k) {\\n        int ans=0,n=s.length();\\n        int dp[]=new int[26];\\n        for(int i=0; i<n; i++){\\n            int ch=s.charAt(i)-\\'a\\';\\n            dp[ch]+=1;\\n            for(int j=Math.max(0,ch-k); j<=Math.min(25,ch+k); j++){\\n                if(j!=ch)\\n                    dp[ch]=Math.max(dp[j]+1,dp[ch]);\\n            }\\n            ans=Math.max(ans,dp[ch]);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nMEME :\\n\\n![image](https://assets.leetcode.com/users/images/eb2ccd7d-0e88-4882-81db-a7b3b9b6c042_1659895023.3251915.png)\\n\\n\\n**Please Upvote if You like My Solution**",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int helper_function(String s,int k,int idx,char ch,int dp[][]){\\n        if(idx==s.length()) return 0;\\n        if(dp[idx][ch]!=-1) return dp[idx][ch];\\n        int pick=0;\\n             if(Math.abs(ch-s.charAt(idx))<=k || ch==\\'#\\') pick=1+helper_function(s,k,idx+1,s.charAt(idx),dp);\\n            int notpick=helper_function(s,k,idx+1,ch,dp);\\n       return dp[idx][ch]=Math.max(pick,notpick);\\n        \\n    }\\n    public int longestIdealString(String s, int k) {\\n        int n=s.length();\\n        int dp[][]=new int[n+1][150];\\n        for(int sub_array[]:dp)\\n         Arrays.fill(sub_array,-1);\\n        return helper_function(s,k,0,\\'#\\',dp); // taken # as dummy char becuase in ascii table # is adjcent of z , so it will automatically cover by 150 dimension of dp\\n        \\n    }\\n\\n}\\n```\n```\\nclass Solution {\\n    public int longestIdealString(String s, int k) {\\n        int ans=0,n=s.length();\\n        int dp[]=new int[26];\\n        for(int i=0; i<n; i++){\\n            int ch=s.charAt(i)-\\'a\\';\\n            dp[ch]+=1;\\n            for(int j=Math.max(0,ch-k); j<=Math.min(25,ch+k); j++){\\n                if(j!=ch)\\n                    dp[ch]=Math.max(dp[j]+1,dp[ch]);\\n            }\\n            ans=Math.max(ans,dp[ch]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390471,
                "title": "dp",
                "content": "For character `s[i]`, `dp[s[i]]` indicates the longest subsequence that ends at that character.\\n    \\nFor character `s[i + 1]`, `dp[s[i + 1]] = 1 + max(dp[reachable])`, where `abs(s[i + 1] - reachable) <= k`.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def longestIdealString(self, s: str, k: int) -> int:\\n        dp = [0] * 26\\n        for ch in s:\\n            i = ord(ch) - ord(\"a\")\\n            dp[i] = 1 + max(dp[max(0, i - k) : min(26, i + k + 1)])\\n        return max(dp)\\n```\\n**C++**\\n\\'No raw loops\\' version, just for fun.\\n```cpp\\nint longestIdealString(string s, int k) {\\n    int dp[26] = {};\\n    return k == 26 ? s.size() : accumulate(begin(s), end(s), 0, [&](int s, char ch){\\n        return max(s, dp[ch - \\'a\\'] = 1 + *max_element(\\n            begin(dp) + max(0, ch - \\'a\\' - k), begin(dp) + min(26, ch - \\'a\\' + k + 1)));\\n    });\\n}\\n```\\n\\n**Java**\\n```java\\npublic int longestIdealString(String s, int k) {\\n    int dp[] = new int[26];\\n    for (int i = 0; i < s.length(); ++i) {\\n        int a = s.charAt(i) - \\'a\\', mx = 0;\\n        for (int b = Math.max(0, a - k); b <= Math.min(25, a + k); ++b)\\n            mx = Math.max(mx, dp[b]);\\n        dp[a] = 1 + mx;\\n    }\\n    return Arrays.stream(dp).max().getAsInt();\\n}\\n```\\n    \\n**Complexity Analysis**\\n- Time: O(n); for each element, we check up to 26 characters.\\n- Memory: O(1); we use a fixed-size `dp` array.",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def longestIdealString(self, s: str, k: int) -> int:\\n        dp = [0] * 26\\n        for ch in s:\\n            i = ord(ch) - ord(\"a\")\\n            dp[i] = 1 + max(dp[max(0, i - k) : min(26, i + k + 1)])\\n        return max(dp)\\n```\n```cpp\\nint longestIdealString(string s, int k) {\\n    int dp[26] = {};\\n    return k == 26 ? s.size() : accumulate(begin(s), end(s), 0, [&](int s, char ch){\\n        return max(s, dp[ch - \\'a\\'] = 1 + *max_element(\\n            begin(dp) + max(0, ch - \\'a\\' - k), begin(dp) + min(26, ch - \\'a\\' + k + 1)));\\n    });\\n}\\n```\n```java\\npublic int longestIdealString(String s, int k) {\\n    int dp[] = new int[26];\\n    for (int i = 0; i < s.length(); ++i) {\\n        int a = s.charAt(i) - \\'a\\', mx = 0;\\n        for (int b = Math.max(0, a - k); b <= Math.min(25, a + k); ++b)\\n            mx = Math.max(mx, dp[b]);\\n        dp[a] = 1 + mx;\\n    }\\n    return Arrays.stream(dp).max().getAsInt();\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390654,
                "title": "c-dp-memoization-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(string& s,int index,int prev,int &k,vector<vector<int>>& dp){\\n        if(index>=s.size())return 0;\\n        \\n        if(dp[index][prev]!=-1)return dp[index][prev];\\n        \\n        int inc=0,notinc=0;\\n        if(prev==0 || abs(s[index]-prev)<=k){\\n            inc=1+solve(s,index+1,s[index],k,dp);\\n        }\\n        notinc=solve(s,index+1,prev,k,dp);\\n        \\n        return dp[index][prev]=max(inc,notinc);\\n    }\\n    \\n    int longestIdealString(string s, int k) {\\n        vector<vector<int>>dp (s.size()+1,vector<int>(150,-1));\\n        return solve(s,0,0,k,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(string& s,int index,int prev,int &k,vector<vector<int>>& dp){\\n        if(index>=s.size())return 0;\\n        \\n        if(dp[index][prev]!=-1)return dp[index][prev];\\n        \\n        int inc=0,notinc=0;\\n        if(prev==0 || abs(s[index]-prev)<=k){\\n            inc=1+solve(s,index+1,s[index],k,dp);\\n        }\\n        notinc=solve(s,index+1,prev,k,dp);\\n        \\n        return dp[index][prev]=max(inc,notinc);\\n    }\\n    \\n    int longestIdealString(string s, int k) {\\n        vector<vector<int>>dp (s.size()+1,vector<int>(150,-1));\\n        return solve(s,0,0,k,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390840,
                "title": "dp-o-n-time-o-1-space",
                "content": "We iterate over each character and keep track of for each character that ***\"what is the longest ideal subsequence ending at this character\"*** ? \\nWe update the result for the current character after evaluation.\\n\\nHere **dp[i] = longest ideal character ending on character (char) (\\'a\\' + i)**\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\tint longestIdealString(string s, int k) {\\n\\t\\tvector<int> dp(26, 0);\\n\\t\\tfor (int i = 0; i < s.size(); ++i) {\\n\\t\\t\\tint charIndex = s[i] - \\'a\\';\\n\\t\\t\\tint ans = 1;\\n\\t\\t\\tfor (int j = 0; j < 26; ++j) {\\n\\t\\t\\t\\tif (abs(j - charIndex) <= k) {\\n\\t\\t\\t\\t\\tans = max(ans, dp[j] + 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tdp[charIndex] = ans;\\n\\t\\t}\\n\\t\\treturn *max_element(dp.begin(), dp.end());\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n\\tint longestIdealString(string s, int k) {\\n\\t\\tvector<int> dp(26, 0);\\n\\t\\tfor (int i = 0; i < s.size(); ++i) {\\n\\t\\t\\tint charIndex = s[i] - \\'a\\';\\n\\t\\t\\tint ans = 1;\\n\\t\\t\\tfor (int j = 0; j < 26; ++j) {\\n\\t\\t\\t\\tif (abs(j - charIndex) <= k) {\\n\\t\\t\\t\\t\\tans = max(ans, dp[j] + 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tdp[charIndex] = ans;\\n\\t\\t}\\n\\t\\treturn *max_element(dp.begin(), dp.end());\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390526,
                "title": "java-python-3-o-k-n-dp-codes-w-brief-explanation-and-analysis",
                "content": "Use an array `dp` to record the currently longest subsequence ending at `a, b, c, ...,  z`, respectively.\\n\\n1. Traverse the input `s`; for each character, update `dp[s.charAt(i) - \\'a\\']` to the maximum value within the given offset range `[-k, k]`; then increase by `1`;\\n2. Return the largest out of `dp`.\\n\\n```java\\n    public int longestIdealString(String s, int k) {\\n        int[] dp = new int[26];\\n        for (int i = 0; i < s.length(); ++i) {\\n            int cur = s.charAt(i) - \\'a\\';\\n            for (int j = Math.max(0, cur - k); j <= Math.min(25, cur + k); ++j) {\\n                dp[cur] = Math.max(dp[cur], dp[j]);\\n            }\\n            ++dp[cur];\\n        }\\n        return IntStream.of(dp).max().getAsInt();\\n    }\\n```\\nSome complains the performance of the above code. We can remove the Java Stream code in the last line and rewrite it as follows to improve the time performance:\\n\\n```java\\n    public int longestIdealString(String s, int k) {\\n        int[] dp = new int[26];\\n        int longest = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            int cur = s.charAt(i) - \\'a\\';\\n            for (int j = Math.max(0, cur - k); j <= Math.min(25, cur + k); ++j) {\\n                dp[cur] = Math.max(dp[cur], dp[j]);\\n            }\\n            longest = Math.max(longest, ++dp[cur]);\\n        }\\n        return longest;\\n    }\\n```\\n\\n```python\\n    def longestIdealString(self, s: str, k: int) -> int:\\n        dp = [0] * 26\\n        for c in s:\\n            cur = ord(c) - ord(\\'a\\')\\n            for i in range(max(0, cur - k), min(25, cur + k) + 1):\\n                dp[cur] = max(dp[i], dp[cur])\\n            dp[cur] += 1    \\n        return max(dp)\\n```\\n**Analysis:**\\n\\nTime: O(k * n), space: `O(A)`, where `n = s.length(), A = alphabetic range`, which is `26` for the problem.",
                "solutionTags": [],
                "code": "```java\\n    public int longestIdealString(String s, int k) {\\n        int[] dp = new int[26];\\n        for (int i = 0; i < s.length(); ++i) {\\n            int cur = s.charAt(i) - \\'a\\';\\n            for (int j = Math.max(0, cur - k); j <= Math.min(25, cur + k); ++j) {\\n                dp[cur] = Math.max(dp[cur], dp[j]);\\n            }\\n            ++dp[cur];\\n        }\\n        return IntStream.of(dp).max().getAsInt();\\n    }\\n```\n```java\\n    public int longestIdealString(String s, int k) {\\n        int[] dp = new int[26];\\n        int longest = 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            int cur = s.charAt(i) - \\'a\\';\\n            for (int j = Math.max(0, cur - k); j <= Math.min(25, cur + k); ++j) {\\n                dp[cur] = Math.max(dp[cur], dp[j]);\\n            }\\n            longest = Math.max(longest, ++dp[cur]);\\n        }\\n        return longest;\\n    }\\n```\n```python\\n    def longestIdealString(self, s: str, k: int) -> int:\\n        dp = [0] * 26\\n        for c in s:\\n            cur = ord(c) - ord(\\'a\\')\\n            for i in range(max(0, cur - k), min(25, cur + k) + 1):\\n                dp[cur] = max(dp[i], dp[cur])\\n            dp[cur] += 1    \\n        return max(dp)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2391928,
                "title": "c-java-python-easy-to-understand",
                "content": "**Naive approach**: A brute force solution is to generate all the possible subsequences of various lengths and compute the maximum length of the valid subsequence. The time complexity will be exponential.\\n\\n**Efficient Approach**: An efficient approach is to use the concept **Dynamic Programming** \\n\\n* Create an array dp of 0\\u2019s with size equal to length of string.\\n* Create a supporting array max_length with 0\\u2019s of size 26.\\n* Iterate the string character by character and for each character determine the upper and lower bounds.\\n* Iterate nested loop in the range of lower and upper bounds.\\n* Fill the dp array with the maximum value between current dp indices and current max_length indices+1.\\n* Fill the max_length array with the maximum value between current dp indices and current max_length indices.\\n* Longest sub sequence length is the maximum value in dp array.\\n\\n**Let us consider an example:**\\n![image](https://assets.leetcode.com/users/images/886cd9f5-85e3-4e1b-8b32-95a656780380_1659857222.168042.png)\\n\\n**C++ program for the above approach**\\n```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\n// Function to find\\n// the longest Special Sequence\\nint longestIdealString(String s, int k)\\n{\\n\\tint n = s.size();\\n\\t// Creating a list with\\n\\t// all 0\\'s of size``\\n\\t// equal to the length of string\\n\\tvector<int> dp(n, 0);\\n\\n\\t// Supporting list with\\n\\t// all 0\\'s of size 26 since\\n\\t// the given string consists\\n\\t// of only lower case alphabets\\n\\tint max_length[26] = {0};\\n\\n\\tfor (int i = 0; i < n; i++)\\n\\t{\\n\\n\\t\\t// Converting the ascii value to\\n\\t\\t// list indices\\n\\t\\tint curr = s[i] - \\'a\\';\\n\\n\\t\\t// Determining the lower bound\\n\\t\\tint lower = max(0, curr - k);\\n\\n\\t\\t// Determining the upper bound\\n\\t\\tint upper = min(25, curr + k);\\n\\n\\t\\t// Filling the dp array with values\\n\\t\\tfor (int j = lower; j < upper + 1; j++)\\n\\t\\t{\\n\\t\\t\\tdp[i] = max(dp[i], max_length[j] + 1);\\n\\t\\t}\\n\\t\\t//Filling the max_length array with max\\n\\t\\t//length of subsequence till now\\n\\t\\tmax_length[curr] = max(dp[i], max_length[curr]);\\n\\t}\\n\\n\\tint ans = 0;\\n\\n\\tfor(int i:dp) ans = max(i, ans);\\n\\n\\t// return the max length of subsequence\\n\\treturn ans;\\n}\\n```\\n\\n**Java**\\n```\\npublic int longestIdealString(String s, int k) {\\n\\t\\tint n = s.size();\\n\\t\\t// Creating a list with\\n\\t\\t// all 0\\'s of size\\n\\t\\t// equal to the length of String\\n\\t\\tint []dp = new int[n];\\n\\n\\t\\t// Supporting list with\\n\\t\\t// all 0\\'s of size 26 since\\n\\t\\t// the given String consists\\n\\t\\t// of only lower case alphabets\\n\\t\\tint []max_length = new int[26];\\n\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t{\\n\\n\\t\\t\\t// Converting the ascii value to\\n\\t\\t\\t// list indices\\n\\t\\t\\tint curr = s.charAt(i) - \\'a\\';\\n\\n\\t\\t\\t// Determining the lower bound\\n\\t\\t\\tint lower = Math.max(0, curr - k);\\n\\n\\t\\t\\t// Determining the upper bound\\n\\t\\t\\tint upper = Math.min(25, curr + k);\\n\\n\\t\\t\\t// Filling the dp array with values\\n\\t\\t\\tfor (int j = lower; j < upper + 1; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdp[i] = Math.max(dp[i], max_length[j] + 1);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Filling the max_length array with max\\n\\t\\t\\t// length of subsequence till now\\n\\t\\t\\tmax_length[curr] = Math.max(dp[i], max_length[curr]);\\n\\t\\t}\\n\\n\\t\\tint ans = 0;\\n\\n\\t\\tfor(int i:dp) ans = Math.max(i, ans);\\n\\n\\t\\t// return the max length of subsequence\\n\\t\\treturn ans;\\n   }\\n```\\n\\n**Python3**\\n```\\n\\tdef longestIdealString(self, s: str, k: int) -> int:\\n\\tn = len(s)\\n\\t# Creating a list with\\n    # all 0\\'s of size\\n    # equal to the length of string\\n    dp = [0] * n\\n     \\n    # Supporting list with\\n    # all 0\\'s of size 26 since\\n    # the given string consists\\n    # of only lower case alphabets\\n    max_length = [0] * 26\\n \\n    for i in range(n):\\n \\n        # Converting the ascii value to\\n        # list indices\\n        curr = ord(s[i]) - ord(\\'a\\')\\n        # Determining the lower bound\\n        lower = max(0, curr - k)\\n        # Determining the upper bound\\n        upper = min(25, curr + k)\\n        # Filling the dp array with values\\n        for j in range(lower, upper + 1):\\n \\n            dp[i] = max(dp[i], max_length[j]+1)\\n        # Filling the max_length array with max\\n        # length of subsequence till now\\n        max_length[curr] = max(dp[i], max_length[curr])\\n \\n    # return the max length of subsequence\\n    return max(dp)\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\n// Function to find\\n// the longest Special Sequence\\nint longestIdealString(String s, int k)\\n{\\n\\tint n = s.size();\\n\\t// Creating a list with\\n\\t// all 0\\'s of size``\\n\\t// equal to the length of string\\n\\tvector<int> dp(n, 0);\\n\\n\\t// Supporting list with\\n\\t// all 0\\'s of size 26 since\\n\\t// the given string consists\\n\\t// of only lower case alphabets\\n\\tint max_length[26] = {0};\\n\\n\\tfor (int i = 0; i < n; i++)\\n\\t{\\n\\n\\t\\t// Converting the ascii value to\\n\\t\\t// list indices\\n\\t\\tint curr = s[i] - \\'a\\';\\n\\n\\t\\t// Determining the lower bound\\n\\t\\tint lower = max(0, curr - k);\\n\\n\\t\\t// Determining the upper bound\\n\\t\\tint upper = min(25, curr + k);\\n\\n\\t\\t// Filling the dp array with values\\n\\t\\tfor (int j = lower; j < upper + 1; j++)\\n\\t\\t{\\n\\t\\t\\tdp[i] = max(dp[i], max_length[j] + 1);\\n\\t\\t}\\n\\t\\t//Filling the max_length array with max\\n\\t\\t//length of subsequence till now\\n\\t\\tmax_length[curr] = max(dp[i], max_length[curr]);\\n\\t}\\n\\n\\tint ans = 0;\\n\\n\\tfor(int i:dp) ans = max(i, ans);\\n\\n\\t// return the max length of subsequence\\n\\treturn ans;\\n}\\n```\n```\\npublic int longestIdealString(String s, int k) {\\n\\t\\tint n = s.size();\\n\\t\\t// Creating a list with\\n\\t\\t// all 0\\'s of size\\n\\t\\t// equal to the length of String\\n\\t\\tint []dp = new int[n];\\n\\n\\t\\t// Supporting list with\\n\\t\\t// all 0\\'s of size 26 since\\n\\t\\t// the given String consists\\n\\t\\t// of only lower case alphabets\\n\\t\\tint []max_length = new int[26];\\n\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t{\\n\\n\\t\\t\\t// Converting the ascii value to\\n\\t\\t\\t// list indices\\n\\t\\t\\tint curr = s.charAt(i) - \\'a\\';\\n\\n\\t\\t\\t// Determining the lower bound\\n\\t\\t\\tint lower = Math.max(0, curr - k);\\n\\n\\t\\t\\t// Determining the upper bound\\n\\t\\t\\tint upper = Math.min(25, curr + k);\\n\\n\\t\\t\\t// Filling the dp array with values\\n\\t\\t\\tfor (int j = lower; j < upper + 1; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdp[i] = Math.max(dp[i], max_length[j] + 1);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Filling the max_length array with max\\n\\t\\t\\t// length of subsequence till now\\n\\t\\t\\tmax_length[curr] = Math.max(dp[i], max_length[curr]);\\n\\t\\t}\\n\\n\\t\\tint ans = 0;\\n\\n\\t\\tfor(int i:dp) ans = Math.max(i, ans);\\n\\n\\t\\t// return the max length of subsequence\\n\\t\\treturn ans;\\n   }\\n```\n```\\n\\tdef longestIdealString(self, s: str, k: int) -> int:\\n\\tn = len(s)\\n\\t# Creating a list with\\n    # all 0\\'s of size\\n    # equal to the length of string\\n    dp = [0] * n\\n     \\n    # Supporting list with\\n    # all 0\\'s of size 26 since\\n    # the given string consists\\n    # of only lower case alphabets\\n    max_length = [0] * 26\\n \\n    for i in range(n):\\n \\n        # Converting the ascii value to\\n        # list indices\\n        curr = ord(s[i]) - ord(\\'a\\')\\n        # Determining the lower bound\\n        lower = max(0, curr - k)\\n        # Determining the upper bound\\n        upper = min(25, curr + k)\\n        # Filling the dp array with values\\n        for j in range(lower, upper + 1):\\n \\n            dp[i] = max(dp[i], max_length[j]+1)\\n        # Filling the max_length array with max\\n        # length of subsequence till now\\n        max_length[curr] = max(dp[i], max_length[curr])\\n \\n    # return the max length of subsequence\\n    return max(dp)\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2390645,
                "title": "c-dp-memoization-slight-modification-of-lcs",
                "content": "\\t// we are using the lowest common subsequence code  but slightly modified it by checking the condition \\n\\t// if absolute difference between current and last character is <= k then only taking \\n\\t// the current character else not taking the current character \\n\\n    int func(int i,char last,string &s,int k,vector<vector<int>> &dp)\\n    {\\n        if(i<0)    return 0;\\n\\t\\t\\t\\n        int l;\\n        if(last==\\'$\\')\\n            l = 26;\\n        else\\n            l = last-\\'a\\';\\n        \\n        if(dp[i][l]!=-1)\\n            return dp[i][l];\\n        \\n        int notTake = func(i-1,last,s,k,dp);\\n        \\n        int take = 0;\\n        if(last==\\'$\\')     // if current element is the first element then  (since last == $\\') we can take any element without checking anything\\n\\t\\t{\\n            take = 1+func(i-1,s[i],s,k,dp);\\n        }\\n\\t\\telse if( abs(last-s[i])<=k )\\n        {\\n\\t\\t\\ttake = 1+func(i-1,s[i],s,k,dp);\\n        }\\n\\t\\t\\n        return dp[i][l] = max(take,notTake);\\n    }\\n  \\n    int longestIdealString(string s, int k) \\n\\t{\\n        vector<vector<int>> dp(n+1,vector<int>(27,-1));\\n        char last=\\'$\\';              // using \\'$\\' symbol when initially no elements are taken \\n \\n        return func(n-1,last,s,k,dp);   \\n    }\\n\\t\\n\\t// if you found this helpful pls upvote\\n\\t// if you are still not able to understand this code then dont be sad , firstly understand finding LCS problem then you will be able\\n\\t//to understand this completely :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "\\t// we are using the lowest common subsequence code  but slightly modified it by checking the condition \\n\\t// if absolute difference between current and last character is <= k then only taking \\n\\t// the current character else not taking the current character \\n\\n    int func(int i,char last,string &s,int k,vector<vector<int>> &dp)\\n    {\\n        if(i<0)    return 0;\\n\\t\\t\\t\\n        int l;\\n        if(last==\\'$\\')\\n            l = 26;\\n        else\\n            l = last-\\'a\\';\\n        \\n        if(dp[i][l]!=-1)\\n            return dp[i][l];\\n        \\n        int notTake = func(i-1,last,s,k,dp);\\n        \\n        int take = 0;\\n        if(last==\\'$\\')     // if current element is the first element then  (since last == $\\') we can take any element without checking anything\\n\\t\\t{\\n            take = 1+func(i-1,s[i],s,k,dp);\\n        }\\n\\t\\telse if( abs(last-s[i])<=k )\\n        {\\n\\t\\t\\ttake = 1+func(i-1,s[i],s,k,dp);\\n        }\\n\\t\\t\\n        return dp[i][l] = max(take,notTake);\\n    }\\n  \\n    int longestIdealString(string s, int k) \\n\\t{\\n        vector<vector<int>> dp(n+1,vector<int>(27,-1));\\n        char last=\\'$\\';              // using \\'$\\' symbol when initially no elements are taken \\n \\n        return func(n-1,last,s,k,dp);   \\n    }\\n\\t\\n\\t// if you found this helpful pls upvote\\n\\t// if you are still not able to understand this code then dont be sad , firstly understand finding LCS problem then you will be able\\n\\t//to understand this completely :)",
                "codeTag": "Unknown"
            },
            {
                "id": 2392789,
                "title": "c-dp-lis-pattern-tle-optimal",
                "content": "```\\n// simple LIS(LONGEST INCREASING SUBSEQUENCE) PATTERN :\\n// recursion with memoization:\\n// 69/84 test cases passed:\\nclass Solution {\\npublic:\\n    int solve(string &s, int &k, int i, int prevInd,vector<vector<int>> &t){\\n        \\n        if(i>=s.size())\\n            return 0;\\n        if(t[i][prevInd+1]!=-1)\\n            return t[i][prevInd+1];\\n        \\n        // not take:\\n        int ans=solve(s,k,i+1,prevInd,t);\\n        \\n        // take:\\n        if(prevInd==-1 || abs((s[i]-\\'a\\') - (s[prevInd]-\\'a\\'))<=k)\\n            ans=max(ans,1+solve(s,k,i+1,i,t));\\n        \\n        return t[i][prevInd+1]=ans;\\n    }\\n    int longestIdealString(string s, int k) {\\n        vector<vector<int>> t(s.size()+1,vector<int>(s.size()+1,-1));\\n        return solve(s,k,0,-1,t);\\n    }\\n};\\n\\n```\\n```\\n// O(N^2) DP \\n//  74 / 84 test cases passed.\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        int n=s.size();\\n        vector<int> dp(n,1);\\n        int maxi=1;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int prevInd=0;prevInd<i;prevInd++){\\n                if(abs((s[i]-\\'a\\') - (s[prevInd]-\\'a\\'))<=k){\\n                    dp[i]=max(dp[i],dp[prevInd]+1);\\n                }\\n                \\n                maxi=max(maxi,dp[i]);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```\\n```\\n/*\\nO(26*N):\\n\\u2705\\u2705 ALL TEST CASES PASSED\\n\\nin the previous methods , we are iterating over the whiole string before the ith index,\\ni.e\\n for(int i=0;i<n;i++){\\n            for(int prevInd=0;prevInd<i;prevInd++){\\n                if(abs((s[i]-\\'a\\') - (s[prevInd]-\\'a\\'))<=k){\\n                    dp[i]=max(dp[i],dp[prevInd]+1);\\n                }\\n           \\nbut if we observe closley , we do not need to traverse the whole \\nstring before the ith index, becuase as we know that only 26 \\ncharacters are there , and all other characters will be repeated i\\nn a big string ,therefore for every index we can check , if the\\ndiff bw them <=k , whether we can obtain   Longest Ideal Subsequenc , \\n\\nin the dp we will store the  Longest Ideal Subsequence obtained till that character \\n*/\\nclass Solution {\\npublic:\\n\\tint longestIdealString(string s, int k) {\\n\\t\\tvector<int> dp(26, 0);\\n\\t\\tfor (int i = 0; i < s.size(); i++) {\\n\\t\\t\\tint ind = s[i] - \\'a\\';\\n\\t\\t\\tint ans = 1;\\n\\t\\t\\tfor (int j = 0; j < 26; j++) {\\n\\t\\t\\t\\tif (abs(j - ind) <= k) {\\n\\t\\t\\t\\t\\tans = max(ans, dp[j] + 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tdp[ind] = ans;\\n\\t\\t}\\n\\t\\treturn *max_element(dp.begin(), dp.end());\\n\\t}\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n// simple LIS(LONGEST INCREASING SUBSEQUENCE) PATTERN :\\n// recursion with memoization:\\n// 69/84 test cases passed:\\nclass Solution {\\npublic:\\n    int solve(string &s, int &k, int i, int prevInd,vector<vector<int>> &t){\\n        \\n        if(i>=s.size())\\n            return 0;\\n        if(t[i][prevInd+1]!=-1)\\n            return t[i][prevInd+1];\\n        \\n        // not take:\\n        int ans=solve(s,k,i+1,prevInd,t);\\n        \\n        // take:\\n        if(prevInd==-1 || abs((s[i]-\\'a\\') - (s[prevInd]-\\'a\\'))<=k)\\n            ans=max(ans,1+solve(s,k,i+1,i,t));\\n        \\n        return t[i][prevInd+1]=ans;\\n    }\\n    int longestIdealString(string s, int k) {\\n        vector<vector<int>> t(s.size()+1,vector<int>(s.size()+1,-1));\\n        return solve(s,k,0,-1,t);\\n    }\\n};\\n\\n```\n```\\n// O(N^2) DP \\n//  74 / 84 test cases passed.\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        int n=s.size();\\n        vector<int> dp(n,1);\\n        int maxi=1;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int prevInd=0;prevInd<i;prevInd++){\\n                if(abs((s[i]-\\'a\\') - (s[prevInd]-\\'a\\'))<=k){\\n                    dp[i]=max(dp[i],dp[prevInd]+1);\\n                }\\n                \\n                maxi=max(maxi,dp[i]);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```\n```\\n/*\\nO(26*N):\\n\\u2705\\u2705 ALL TEST CASES PASSED\\n\\nin the previous methods , we are iterating over the whiole string before the ith index,\\ni.e\\n for(int i=0;i<n;i++){\\n            for(int prevInd=0;prevInd<i;prevInd++){\\n                if(abs((s[i]-\\'a\\') - (s[prevInd]-\\'a\\'))<=k){\\n                    dp[i]=max(dp[i],dp[prevInd]+1);\\n                }\\n           \\nbut if we observe closley , we do not need to traverse the whole \\nstring before the ith index, becuase as we know that only 26 \\ncharacters are there , and all other characters will be repeated i\\nn a big string ,therefore for every index we can check , if the\\ndiff bw them <=k , whether we can obtain   Longest Ideal Subsequenc , \\n\\nin the dp we will store the  Longest Ideal Subsequence obtained till that character \\n*/\\nclass Solution {\\npublic:\\n\\tint longestIdealString(string s, int k) {\\n\\t\\tvector<int> dp(26, 0);\\n\\t\\tfor (int i = 0; i < s.size(); i++) {\\n\\t\\t\\tint ind = s[i] - \\'a\\';\\n\\t\\t\\tint ans = 1;\\n\\t\\t\\tfor (int j = 0; j < 26; j++) {\\n\\t\\t\\t\\tif (abs(j - ind) <= k) {\\n\\t\\t\\t\\t\\tans = max(ans, dp[j] + 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tdp[ind] = ans;\\n\\t\\t}\\n\\t\\treturn *max_element(dp.begin(), dp.end());\\n\\t}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391162,
                "title": "o-n-26-dp-recursion-memoization-bottom-up",
                "content": "**Stage 1: Recursion (TLE)**\\n\\nIt\\'s not difficult to come up with a recursive solution for this problem. We just have to keep the track of the current index and the last character we have taken in the present subsequence.\\n\\nFor an empty subsequence I have taken the last element as 26.\\n\\nNow, let\\'s talk about the choices that we have,\\n\\n1. For any present index, if no element is already taken, we can take the present element and increase the size by 1.\\n2.  If we have a non empty subsequence, we can take the present index only if the absolute difference between the characters is less than or equal to k.\\n3.  We can always ignore the above two conditions and move on.\\nWe just need the maximum of above three cases.\\n\\n```\\n    int dfs(string s, int i, int k, int last){\\n        if(i<0)return 0;\\n        int ans = 0;\\n        if(last==26){\\n         ans = max(ans, 1+dfs(s, i-1, k, s[i]-\\'a\\'));   \\n        }\\n        else if(abs(s[i]-\\'a\\'-last)<=k){\\n            ans = max(ans, 1+dfs(s, i-1, k, s[i]-\\'a\\'));\\n        }\\n        ans = max(ans, dfs(s, i-1, k, last));\\n        return ans;\\n    }\\n    \\n    int longestIdealString(string s, int k) {\\n        return dfs(s, s.length()-1, k, 26);\\n    }\\n```\\n\\n**Stage 2: Recursion+Memoization (MLE)**\\n\\nIn, the above recursive code, we can notice that the state of same index with same last taken character may come up several times. So, we can just memoize above code with i and last as transition states. \\n\\n```\\n    int dp[(int)(1e5+1)][27];\\n    int dfs(string s, int i, int k, int last){\\n        if(i<0)return 0;\\n        int ans = 0;\\n        if(dp[i][last]!=-1)return dp[i][last];\\n        if(last==26){\\n         ans = max(ans, 1+dfs(s, i-1, k, s[i]-\\'a\\'));   \\n        }\\n        else if(abs(s[i]-\\'a\\'-last)<=k){\\n            ans = max(ans, 1+dfs(s, i-1, k, s[i]-\\'a\\'));\\n        }\\n        ans = max(ans, dfs(s, i-1, k, last));\\n        return dp[i][last] = ans;\\n    }\\n    \\n    int longestIdealString(string s, int k) {\\n        memset(dp, -1, sizeof(dp));\\n        return dfs(s, s.length()-1, k, 26);\\n    }\\n```\\n**Stage 3: Bottom-up (Accepted)**\\n\\n```\\n    int longestIdealString(string s, int k) {\\n        int dp[s.length()+1][27];\\n        memset(dp, 0, sizeof(dp));\\n        for(int i = 1; i<=s.length(); i++){\\n            for(int j = 0; j<=26; j++){\\n                if(j==26){\\n                    dp[i][j] = max(dp[i][j], 1+dp[i-1][s[i-1]-\\'a\\']);\\n                }\\n                else if(abs(s[i-1]-\\'a\\'-j)<=k){\\n                    dp[i][j] = max(dp[i][j], 1+dp[i-1][s[i-1]-\\'a\\']);\\n                }\\n                dp[i][j] = max(dp[i][j], dp[i-1][j]);\\n            }\\n        }\\n        return dp[s.length()][26];\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n    int dfs(string s, int i, int k, int last){\\n        if(i<0)return 0;\\n        int ans = 0;\\n        if(last==26){\\n         ans = max(ans, 1+dfs(s, i-1, k, s[i]-\\'a\\'));   \\n        }\\n        else if(abs(s[i]-\\'a\\'-last)<=k){\\n            ans = max(ans, 1+dfs(s, i-1, k, s[i]-\\'a\\'));\\n        }\\n        ans = max(ans, dfs(s, i-1, k, last));\\n        return ans;\\n    }\\n    \\n    int longestIdealString(string s, int k) {\\n        return dfs(s, s.length()-1, k, 26);\\n    }\\n```\n```\\n    int dp[(int)(1e5+1)][27];\\n    int dfs(string s, int i, int k, int last){\\n        if(i<0)return 0;\\n        int ans = 0;\\n        if(dp[i][last]!=-1)return dp[i][last];\\n        if(last==26){\\n         ans = max(ans, 1+dfs(s, i-1, k, s[i]-\\'a\\'));   \\n        }\\n        else if(abs(s[i]-\\'a\\'-last)<=k){\\n            ans = max(ans, 1+dfs(s, i-1, k, s[i]-\\'a\\'));\\n        }\\n        ans = max(ans, dfs(s, i-1, k, last));\\n        return dp[i][last] = ans;\\n    }\\n    \\n    int longestIdealString(string s, int k) {\\n        memset(dp, -1, sizeof(dp));\\n        return dfs(s, s.length()-1, k, 26);\\n    }\\n```\n```\\n    int longestIdealString(string s, int k) {\\n        int dp[s.length()+1][27];\\n        memset(dp, 0, sizeof(dp));\\n        for(int i = 1; i<=s.length(); i++){\\n            for(int j = 0; j<=26; j++){\\n                if(j==26){\\n                    dp[i][j] = max(dp[i][j], 1+dp[i-1][s[i-1]-\\'a\\']);\\n                }\\n                else if(abs(s[i-1]-\\'a\\'-j)<=k){\\n                    dp[i][j] = max(dp[i][j], 1+dp[i-1][s[i-1]-\\'a\\']);\\n                }\\n                dp[i][j] = max(dp[i][j], dp[i-1][j]);\\n            }\\n        }\\n        return dp[s.length()][26];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2390785,
                "title": "dynamic-programming-java-easy-to-understand-with-detailed-explanation",
                "content": "```\\nYou can simply use memoization here in this question. You need to keep track of two things here in this question -\\n(1) pick : whether you have picked any character till now or not. pick = 0 means you have not picked any character till now and pick = 1 means you \\nhave picked atleast one character before.\\n(2) par : last character or parent character that you picked(only valid if you have picked any character.\\n\\nSo a DP 2D-array of size nx26 will be formed in order to store the different states. Now just iterate over each index and find for both possibilities i.e., \\nnot take and take and whichever gives longest string pick that one. \\nNote: You can only pick if you have not picked any character till now or absolute difference between current character and parent is less than or equal to k.\\n\\nTime Complexity: O(26*N)\\nPlease upvote if you find this explanation helpful \\uD83D\\uDE42\\n```\\n\\n```\\nclass Solution {\\n    public int longestIdealString(String s, int k) {\\n        int n = s.length();\\n        int dp[][] = new int[n][26];\\n        for(int i = 0; i < n; i++){\\n            Arrays.fill(dp[i], -1);\\n        }\\n        return fun(0, (char)(0), 0, n, s, k, dp);\\n    }\\n    private int fun(int pick, char par, int ind, int n, String s, int k, int dp[][]){\\n        if(ind == n){\\n            return 0;\\n        }\\n        if(pick == 1 && dp[ind][par - \\'a\\'] != -1){\\n            return dp[ind][par - \\'a\\'];\\n        }\\n        int notTake = fun(pick, par, ind + 1, n, s, k, dp);\\n        int take = 0;\\n        if(pick == 0 || Math.abs(par - s.charAt(ind)) <= k){\\n            take = 1 + fun(1, s.charAt(ind), ind + 1, n, s, k, dp);\\n        }\\n        int temp = Math.max(notTake, take);\\n        if(pick == 1){\\n            dp[ind][par - \\'a\\'] = temp;\\n        }\\n        return temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nYou can simply use memoization here in this question. You need to keep track of two things here in this question -\\n(1) pick : whether you have picked any character till now or not. pick = 0 means you have not picked any character till now and pick = 1 means you \\nhave picked atleast one character before.\\n(2) par : last character or parent character that you picked(only valid if you have picked any character.\\n\\nSo a DP 2D-array of size nx26 will be formed in order to store the different states. Now just iterate over each index and find for both possibilities i.e., \\nnot take and take and whichever gives longest string pick that one. \\nNote: You can only pick if you have not picked any character till now or absolute difference between current character and parent is less than or equal to k.\\n\\nTime Complexity: O(26*N)\\nPlease upvote if you find this explanation helpful \\uD83D\\uDE42\\n```\n```\\nclass Solution {\\n    public int longestIdealString(String s, int k) {\\n        int n = s.length();\\n        int dp[][] = new int[n][26];\\n        for(int i = 0; i < n; i++){\\n            Arrays.fill(dp[i], -1);\\n        }\\n        return fun(0, (char)(0), 0, n, s, k, dp);\\n    }\\n    private int fun(int pick, char par, int ind, int n, String s, int k, int dp[][]){\\n        if(ind == n){\\n            return 0;\\n        }\\n        if(pick == 1 && dp[ind][par - \\'a\\'] != -1){\\n            return dp[ind][par - \\'a\\'];\\n        }\\n        int notTake = fun(pick, par, ind + 1, n, s, k, dp);\\n        int take = 0;\\n        if(pick == 0 || Math.abs(par - s.charAt(ind)) <= k){\\n            take = 1 + fun(1, s.charAt(ind), ind + 1, n, s, k, dp);\\n        }\\n        int temp = Math.max(notTake, take);\\n        if(pick == 1){\\n            dp[ind][par - \\'a\\'] = temp;\\n        }\\n        return temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390629,
                "title": "python-o-n-dp-explained",
                "content": "First, convert `s` to an integer array with \"a\" = 0, \"b\" = 1 ...\\n\\nThen, let `dp[i][j]` = \"the longest subsequence ending with `j` in the first `i` characters\"\\n\\nWith this we loop `i` from `1` to `len(s)` doing the following:\\n* \\tFirst update each character `j`.\\n\\t`dp[i][j] = dp[i-1][j] for j in [0, 25]`\\n\\t\\n* \\tThen, update `dp[i]` for the current character `c = s[i-1]`.\\n\\t```dp[i][c] = max(dp[i-1][j] + 1, dp[i][c]) for j in [c-k, c+k] ```\\n\\nReturn the maximum of `dp[len(s)]`, so \"the longest subsequence in the first `len(s)` characters aka `s`\".\\n\\n```\\ndef longestIdealString(self, s: str, k: int) -> int:\\n    s = [ord(i) - 97 for i in s]\\n    n = len(s)\\n    dp =[[0 for j in range(26)] for i in range(n+1)]\\n    for i in range(1, n+1):\\n        for j in range(26):\\n            dp[i][j] = dp[i-1][j]\\n        for j in range(max(0, s[i-1]-k), min(26, s[i-1]+k+1)):\\n            dp[i][s[i-1]] = max(dp[i-1][j] + 1, dp[i][s[i-1]])\\n    re = 0\\n    for j in range(26):\\n        re = max(re, dp[n][j])  \\n    return re\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```dp[i][c] = max(dp[i-1][j] + 1, dp[i][c]) for j in [c-k, c+k] ```\n```\\ndef longestIdealString(self, s: str, k: int) -> int:\\n    s = [ord(i) - 97 for i in s]\\n    n = len(s)\\n    dp =[[0 for j in range(26)] for i in range(n+1)]\\n    for i in range(1, n+1):\\n        for j in range(26):\\n            dp[i][j] = dp[i-1][j]\\n        for j in range(max(0, s[i-1]-k), min(26, s[i-1]+k+1)):\\n            dp[i][s[i-1]] = max(dp[i-1][j] + 1, dp[i][s[i-1]])\\n    re = 0\\n    for j in range(26):\\n        re = max(re, dp[n][j])  \\n    return re\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2390620,
                "title": "2d-dp-simple-c-tc-o-n-26",
                "content": "DP states are **cache[index][lastPickedCharacter]**\\n```\\nclass Solution {\\npublic:\\n    int dp(vector <vector<int>>&cache,string &s,int i,char prev,int &k){\\n        if(i==s.size()) return 0;\\n\\t\\t\\n        if(prev==\\'*\\'){\\n            return max(1+dp(cache,s,i+1,s[i],k),dp(cache,s,i+1,prev,k));\\n        }\\n        \\n        int &ans=cache[i][prev-\\'a\\'];\\n        if(ans!=-1) return ans;\\n        \\n        if(abs(s[i]-prev)<=k){\\n            ans=max(1+dp(cache,s,i+1,s[i],k),dp(cache,s,i+1,prev,k));\\n        }\\n        else ans=dp(cache,s,i+1,prev,k);\\n        return ans;\\n    }\\n    \\n    int longestIdealString(string s, int k) {\\n        int n=s.size();\\n        vector <vector<int>> cache(n,vector <int>(26,-1));\\n        return dp(cache,s,0,\\'*\\',k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp(vector <vector<int>>&cache,string &s,int i,char prev,int &k){\\n        if(i==s.size()) return 0;\\n\\t\\t\\n        if(prev==\\'*\\'){\\n            return max(1+dp(cache,s,i+1,s[i],k),dp(cache,s,i+1,prev,k));\\n        }\\n        \\n        int &ans=cache[i][prev-\\'a\\'];\\n        if(ans!=-1) return ans;\\n        \\n        if(abs(s[i]-prev)<=k){\\n            ans=max(1+dp(cache,s,i+1,s[i],k),dp(cache,s,i+1,prev,k));\\n        }\\n        else ans=dp(cache,s,i+1,prev,k);\\n        return ans;\\n    }\\n    \\n    int longestIdealString(string s, int k) {\\n        int n=s.size();\\n        vector <vector<int>> cache(n,vector <int>(26,-1));\\n        return dp(cache,s,0,\\'*\\',k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2427600,
                "title": "0-1-knapsack-easy-solution",
                "content": "##### Please Do **Upvote** If Found Helpful\\n```\\nclass Solution {\\npublic:\\n    int solve(string& s,int k,int ind,int n,vector<vector<int>>& dp,int prevChar)\\n    {\\n        if(ind==n) return 0;\\n        if(dp[ind][prevChar]!=-1) return dp[ind][prevChar];\\n        if(abs((s[ind]-\\'a\\')-(prevChar))<=k || prevChar==26)\\n        {\\n            dp[ind][prevChar]=max(1+solve(s,k,ind+1,n,dp,s[ind]-\\'a\\'),solve(s,k,ind+1,n,dp,prevChar));\\n        }else\\n        {\\n            dp[ind][prevChar]=solve(s,k,ind+1,n,dp,prevChar);\\n        }\\n        return dp[ind][prevChar];\\n    }\\n    int longestIdealString(string s, int k) {\\n        int n=s.length();\\n        vector<vector<int>> dp(n+1,vector<int>(127,-1));  //states are current index and previous character.\\n        int ans=solve(s,k,0,n,dp,26);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(string& s,int k,int ind,int n,vector<vector<int>>& dp,int prevChar)\\n    {\\n        if(ind==n) return 0;\\n        if(dp[ind][prevChar]!=-1) return dp[ind][prevChar];\\n        if(abs((s[ind]-\\'a\\')-(prevChar))<=k || prevChar==26)\\n        {\\n            dp[ind][prevChar]=max(1+solve(s,k,ind+1,n,dp,s[ind]-\\'a\\'),solve(s,k,ind+1,n,dp,prevChar));\\n        }else\\n        {\\n            dp[ind][prevChar]=solve(s,k,ind+1,n,dp,prevChar);\\n        }\\n        return dp[ind][prevChar];\\n    }\\n    int longestIdealString(string s, int k) {\\n        int n=s.length();\\n        vector<vector<int>> dp(n+1,vector<int>(127,-1));  //states are current index and previous character.\\n        int ans=solve(s,k,0,n,dp,26);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2409741,
                "title": "simple-memomization-and-tabulation-c-dp",
                "content": "**MEMOMIZATION**\\n\\n```\\nclass Solution {\\nprivate:\\n    int solve(int ind, string &s, int prev, int k, vector<vector<int>> &dp) {\\n        if(ind == -1) {\\n            return 0;\\n        }\\n        \\n        if(dp[ind][prev] != -1)\\n            return dp[ind][prev];\\n        \\n        int take = 0;\\n        int ch = s[ind] - \\'a\\' + 1;\\n        \\n        if (prev == 0 or abs(ch - prev) <= k) {\\n            take = solve(ind - 1, s, ch, k, dp) + 1;\\n        }\\n        \\n        int notTake = solve(ind - 1, s, prev, k, dp);\\n        return dp[ind][prev] = max(take, notTake);\\n    }\\npublic:\\n    \\n    int longestIdealString(string s, int k) {\\n        \\n        int n = s.size();\\n        vector<vector<int>> dp(n, vector<int>(27, -1)); // 27 because space for 26 alphabets and one more for \\'0\\';\\n        \\n        return solve(n - 1, s, 0, k, dp);\\n    }\\n};\\n```\\n\\n\\n\\n**TABULATION**\\n\\nNow, for tabulation we will shift the indices with 1 because of -1\\nso the updated code would look like this...\\n\\n```\\nclass Solution {\\nprivate:\\n    int solve(int ind, string &s, int prev, int k, vector<vector<int>> &dp) {\\n        if(ind == 0) { // instead of -1 this will be 0\\n            return 0;\\n        }\\n        \\n        if(dp[ind][prev] != -1)\\n            return dp[ind][prev];\\n        \\n        int take = 0;\\n        int ch = s[ind - 1] - \\'a\\' + 1; // have to maintain the indices of the string too \\n        \\n        if (prev == 0 or abs(ch - prev) <= k) {\\n            take = solve(ind - 1, s, ch, k, dp) + 1;\\n        }\\n        \\n        int notTake = solve(ind - 1, s, prev, k, dp);\\n        return dp[ind][prev] = max(take, notTake);\\n    }\\npublic:\\n    \\n    int longestIdealString(string s, int k) {\\n        \\n        int n = s.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(27, -1));\\n        \\n        return solve(n, s, 0, k, dp);\\n    }\\n};\\n```\\n\\n```\\nclass Solution {\\n    public:\\n    \\n    int longestIdealString(string s, int k) {\\n        \\n        int n = s.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(27, 0));\\n        \\n        // base case \\n        for (int prev = 0; prev < 27; prev++) { // can be neglacted because dp is already initailized as 0.\\n            dp[0][prev] = 0;\\n        }\\n        \\n        for (int ind = 1; ind <= n; ind++) {\\n            for (int prev = 0; prev < 27; prev++) {\\n                int take = 0;\\n                int ch = s[ind - 1] - \\'a\\' + 1;\\n                if (prev == 0 or abs(ch - prev) <= k) {\\n                    take = 1 + dp[ind - 1][ch];\\n                }\\n\\n                int notTake = dp[ind - 1][prev];\\n\\n                dp[ind][prev] = max(take, notTake);\\n            }\\n        }\\n        \\n        return dp[n][0];\\n    }\\n};\\n\\n```\\n\\n\\nUpvote if you found it helpful :)",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve(int ind, string &s, int prev, int k, vector<vector<int>> &dp) {\\n        if(ind == -1) {\\n            return 0;\\n        }\\n        \\n        if(dp[ind][prev] != -1)\\n            return dp[ind][prev];\\n        \\n        int take = 0;\\n        int ch = s[ind] - \\'a\\' + 1;\\n        \\n        if (prev == 0 or abs(ch - prev) <= k) {\\n            take = solve(ind - 1, s, ch, k, dp) + 1;\\n        }\\n        \\n        int notTake = solve(ind - 1, s, prev, k, dp);\\n        return dp[ind][prev] = max(take, notTake);\\n    }\\npublic:\\n    \\n    int longestIdealString(string s, int k) {\\n        \\n        int n = s.size();\\n        vector<vector<int>> dp(n, vector<int>(27, -1)); // 27 because space for 26 alphabets and one more for \\'0\\';\\n        \\n        return solve(n - 1, s, 0, k, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int solve(int ind, string &s, int prev, int k, vector<vector<int>> &dp) {\\n        if(ind == 0) { // instead of -1 this will be 0\\n            return 0;\\n        }\\n        \\n        if(dp[ind][prev] != -1)\\n            return dp[ind][prev];\\n        \\n        int take = 0;\\n        int ch = s[ind - 1] - \\'a\\' + 1; // have to maintain the indices of the string too \\n        \\n        if (prev == 0 or abs(ch - prev) <= k) {\\n            take = solve(ind - 1, s, ch, k, dp) + 1;\\n        }\\n        \\n        int notTake = solve(ind - 1, s, prev, k, dp);\\n        return dp[ind][prev] = max(take, notTake);\\n    }\\npublic:\\n    \\n    int longestIdealString(string s, int k) {\\n        \\n        int n = s.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(27, -1));\\n        \\n        return solve(n, s, 0, k, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public:\\n    \\n    int longestIdealString(string s, int k) {\\n        \\n        int n = s.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(27, 0));\\n        \\n        // base case \\n        for (int prev = 0; prev < 27; prev++) { // can be neglacted because dp is already initailized as 0.\\n            dp[0][prev] = 0;\\n        }\\n        \\n        for (int ind = 1; ind <= n; ind++) {\\n            for (int prev = 0; prev < 27; prev++) {\\n                int take = 0;\\n                int ch = s[ind - 1] - \\'a\\' + 1;\\n                if (prev == 0 or abs(ch - prev) <= k) {\\n                    take = 1 + dp[ind - 1][ch];\\n                }\\n\\n                int notTake = dp[ind - 1][prev];\\n\\n                dp[ind][prev] = max(take, notTake);\\n            }\\n        }\\n        \\n        return dp[n][0];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391468,
                "title": "c-space-optimized-dp-solution-time-o-n-26-space-o-26-tabulation-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        int n = s.length();\\n        \\n        vector<int> curr(27, 0);        \\n        vector<int> prev(27, 0);\\n\\n        for(int i = 1; i <= n; i++) {\\n            for(int prev_ch = 0; prev_ch <= 26; prev_ch++) {\\n                int notTake = prev[prev_ch];\\n                int take = 0;\\n                int curr_ch = s[i - 1] - \\'a\\' + 1;\\n                \\n                if(prev_ch == 0 || abs(curr_ch - prev_ch) <= k)\\n                    take = 1 + prev[curr_ch];\\n                \\n                curr[prev_ch] = max(take, notTake);\\n            } \\n            prev = curr;\\n        }\\n        return curr[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        int n = s.length();\\n        \\n        vector<int> curr(27, 0);        \\n        vector<int> prev(27, 0);\\n\\n        for(int i = 1; i <= n; i++) {\\n            for(int prev_ch = 0; prev_ch <= 26; prev_ch++) {\\n                int notTake = prev[prev_ch];\\n                int take = 0;\\n                int curr_ch = s[i - 1] - \\'a\\' + 1;\\n                \\n                if(prev_ch == 0 || abs(curr_ch - prev_ch) <= k)\\n                    take = 1 + prev[curr_ch];\\n                \\n                curr[prev_ch] = max(take, notTake);\\n            } \\n            prev = curr;\\n        }\\n        return curr[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391387,
                "title": "python-dp",
                "content": "Iterate the string from right to left.\\n\\nAt any character `c`, generate all valid character transitions `-k ... k`.\\n\\nAnd take the maximum subsequence value from these characters.\\n\\n```\\nclass Solution:\\n    def longestIdealString(self, s: str, k: int) -> int:\\n        n = len(s)\\n        dp = defaultdict(int)\\n        best = 1\\n        \\n        for i in range(n-1, -1, -1):\\n            c_index = ord(s[i]) - ord(\\'a\\')\\n            c_char = s[i]\\n            \\n            # Must take the current character into account as the first thing to prevent double count.\\n            if c_char in dp:\\n                dp[c_char] = 1 + dp[c_char]\\n            \\n            for j in range(-k, k + 1):\\n                if j == 0: continue\\n                    \\n                j_char = chr(c_index + j + ord(\\'a\\'))\\n                if \\'a\\' <= j_char <= \\'z\\' and j_char in dp:\\n                    dp[c_char] = max(dp[c_char], 1 + dp[j_char])\\n            \\n            dp[c_char] = max(dp[c_char], 1)\\n            best = max(best, dp[c_char])\\n                \\n        return best\\n      \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def longestIdealString(self, s: str, k: int) -> int:\\n        n = len(s)\\n        dp = defaultdict(int)\\n        best = 1\\n        \\n        for i in range(n-1, -1, -1):\\n            c_index = ord(s[i]) - ord(\\'a\\')\\n            c_char = s[i]\\n            \\n            # Must take the current character into account as the first thing to prevent double count.\\n            if c_char in dp:\\n                dp[c_char] = 1 + dp[c_char]\\n            \\n            for j in range(-k, k + 1):\\n                if j == 0: continue\\n                    \\n                j_char = chr(c_index + j + ord(\\'a\\'))\\n                if \\'a\\' <= j_char <= \\'z\\' and j_char in dp:\\n                    dp[c_char] = max(dp[c_char], 1 + dp[j_char])\\n            \\n            dp[c_char] = max(dp[c_char], 1)\\n            best = max(best, dp[c_char])\\n                \\n        return best\\n      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390468,
                "title": "dynamic-programming-and-one-iteration-over-the-string-python",
                "content": "**Logic**\\nIn dp we can keep the max length of the sub sequence ending in letter. \\nSo dp[\"m\"] = 2, means for any subsequence ending in \"m\" has max 2 length of a ideal string.\\nAs we iterate through the string, we can look at all the previous letters seen so far.\\nIf any of the previous letters are within \"k\" difference then we can from a subsequence.\\nWe keep track of max of previous lengths and then add 1 to that.\\n\\n**Complexity**\\nTime O(n)\\nSpace O(26)\\n\\n**Python Code**\\n\\n\\tdef longestIdealString(self, s: str, k: int) -> int:\\n\\t\\tdp = defaultdict(int)\\n        \\n        for ch in s:\\n            newval = 0\\n            for prev in dp:\\n                if abs(ord(prev) - ord(ch)) <= k:\\n                    newval = max(newval, dp[prev])\\n            dp[ch] = newval + 1\\n        \\n        return max(dp.values())\\n\\n**Upvote, comment if you find this useful**",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "**Logic**\\nIn dp we can keep the max length of the sub sequence ending in letter. \\nSo dp[\"m\"] = 2, means for any subsequence ending in \"m\" has max 2 length of a ideal string.\\nAs we iterate through the string, we can look at all the previous letters seen so far.\\nIf any of the previous letters are within \"k\" difference then we can from a subsequence.\\nWe keep track of max of previous lengths and then add 1 to that.\\n\\n**Complexity**\\nTime O(n)\\nSpace O(26)\\n\\n**Python Code**\\n\\n\\tdef longestIdealString(self, s: str, k: int) -> int:\\n\\t\\tdp = defaultdict(int)\\n        \\n        for ch in s:\\n            newval = 0\\n            for prev in dp:\\n                if abs(ord(prev) - ord(ch)) <= k:\\n                    newval = max(newval, dp[prev])\\n            dp[ch] = newval + 1\\n        \\n        return max(dp.values())\\n\\n**Upvote, comment if you find this useful**",
                "codeTag": "Python3"
            },
            {
                "id": 2673899,
                "title": "c-easy-solution-constant-space-three-methods",
                "content": "\\n# Approach\\nWe Have Use Three Different Approaches :\\n1. Recursion + Memoization \\n    TC : O(n^2) , SC : O(n)\\n2. Tabulation Method \\n    TC : O(n^2) , SC : O(n)\\n3.  Tabulatuon With SOace Optimised\\n    TC : O(n^2) , SC : O(1) \\n\\n\\n#Note\\nSC In first two methods is On) and not O(n^2) as size is fixed to 27 for each index hence it is Linear Space ,Similarly for 3rd Method we have optimised to constant space as at any instant we onlt need memory of next 27 blocks  only.\\n\\n#Hope You Liekd It and Upvote are appreciated \\n\\n# Code\\n```\\nclass Solution {\\n\\n\\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\\n   {\\n       if(index == s.length())\\n       return 0;\\n\\n       if(dp[index][prev] != -1)\\n       return dp[index][prev];\\n\\n       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);\\n\\n       int op2 = 0 ;\\n\\n       if(prev == 26)\\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-\\'a\\' , dp);\\n       else if(abs(s[index]-\\'a\\' - prev) <= k)\\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-\\'a\\' , dp);\\n\\n       return dp[index][prev] = max(op1 , op2);\\n   }\\n\\n   int SolveByTab(string &s , int &k )\\n   {\\n        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));\\n       \\n        for(int index = s.length()-1 ; index>=0 ; index--)\\n        {\\n            for(int prev = 0 ; prev<= 26 ; prev++)\\n            {\\n                int op1 = 0 + dp[index+1][prev];\\n                int op2 = 0 ;\\n\\n               if(prev == 26)\\n               op2 = 1 + dp[index+1][s[index]-\\'a\\'];\\n               else if(abs(s[index]-\\'a\\' - prev) <= k)\\n               op2 = 1 + dp[index+1][s[index]-\\'a\\'];\\n\\n               dp[index][prev] = max(op1 , op2);\\n            }\\n        }\\n\\n       return max(dp[0][s[0]-\\'a\\'] , dp[0][26]);\\n   }\\n\\n   int SolveByTabSpaceOptimised(string &s , int &k )\\n   {\\n        vector<int> next(27, 0) ;\\n        vector<int> curr(27, 0);\\n       \\n        for(int index = s.length()-1 ; index>=0 ; index--)\\n        {\\n            for(int prev = 0 ; prev<= 26 ; prev++)\\n            {\\n                int op1 = 0 + next[prev];\\n                int op2 = 0 ;\\n\\n               if(prev == 26)\\n               op2 = 1 + next[s[index]-\\'a\\'];\\n               else if(abs(s[index]-\\'a\\' - prev) <= k)\\n               op2 = 1 + next[s[index]-\\'a\\'];\\n\\n               curr[prev] = max(op1 , op2);\\n            }\\n            next = curr;\\n        }\\n\\n       return max(curr[s[0]-\\'a\\'] , curr[26]);\\n   }\\n\\npublic:\\n    int longestIdealString(string s, int k) {\\n        \\n        // 1. Recursion + Memoization || Top Down Approach\\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\\n        // return SolveByMemo(s, k , 0 , 26, dp);\\n\\n        // 2. Tabulation Method || Bottom Up Approach\\n        // return SolveByTab(s, k);\\n\\n        // 3. Space Optimisation using Tabulation\\n        return SolveByTabSpaceOptimised(s , k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n\\n\\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\\n   {\\n       if(index == s.length())\\n       return 0;\\n\\n       if(dp[index][prev] != -1)\\n       return dp[index][prev];\\n\\n       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);\\n\\n       int op2 = 0 ;\\n\\n       if(prev == 26)\\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-\\'a\\' , dp);\\n       else if(abs(s[index]-\\'a\\' - prev) <= k)\\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-\\'a\\' , dp);\\n\\n       return dp[index][prev] = max(op1 , op2);\\n   }\\n\\n   int SolveByTab(string &s , int &k )\\n   {\\n        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));\\n       \\n        for(int index = s.length()-1 ; index>=0 ; index--)\\n        {\\n            for(int prev = 0 ; prev<= 26 ; prev++)\\n            {\\n                int op1 = 0 + dp[index+1][prev];\\n                int op2 = 0 ;\\n\\n               if(prev == 26)\\n               op2 = 1 + dp[index+1][s[index]-\\'a\\'];\\n               else if(abs(s[index]-\\'a\\' - prev) <= k)\\n               op2 = 1 + dp[index+1][s[index]-\\'a\\'];\\n\\n               dp[index][prev] = max(op1 , op2);\\n            }\\n        }\\n\\n       return max(dp[0][s[0]-\\'a\\'] , dp[0][26]);\\n   }\\n\\n   int SolveByTabSpaceOptimised(string &s , int &k )\\n   {\\n        vector<int> next(27, 0) ;\\n        vector<int> curr(27, 0);\\n       \\n        for(int index = s.length()-1 ; index>=0 ; index--)\\n        {\\n            for(int prev = 0 ; prev<= 26 ; prev++)\\n            {\\n                int op1 = 0 + next[prev];\\n                int op2 = 0 ;\\n\\n               if(prev == 26)\\n               op2 = 1 + next[s[index]-\\'a\\'];\\n               else if(abs(s[index]-\\'a\\' - prev) <= k)\\n               op2 = 1 + next[s[index]-\\'a\\'];\\n\\n               curr[prev] = max(op1 , op2);\\n            }\\n            next = curr;\\n        }\\n\\n       return max(curr[s[0]-\\'a\\'] , curr[26]);\\n   }\\n\\npublic:\\n    int longestIdealString(string s, int k) {\\n        \\n        // 1. Recursion + Memoization || Top Down Approach\\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\\n        // return SolveByMemo(s, k , 0 , 26, dp);\\n\\n        // 2. Tabulation Method || Bottom Up Approach\\n        // return SolveByTab(s, k);\\n\\n        // 3. Space Optimisation using Tabulation\\n        return SolveByTabSpaceOptimised(s , k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585550,
                "title": "python-16-lines",
                "content": "```\\nclass Solution:\\n    def longestIdealString(self, s: str, k: int) -> int:\\n        nums, d, ans = map(ord,list(s)), defaultdict(int), 0\\n        \\n        for n in nums:\\n            d[n] = max(d[i] for i in range(n-k, n+k+1)) + 1\\n            ans = max(ans,d[n])\\n        return ans",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestIdealString(self, s: str, k: int) -> int:\\n        nums, d, ans = map(ord,list(s)), defaultdict(int), 0\\n        \\n        for n in nums:\\n            d[n] = max(d[i] for i in range(n-k, n+k+1)) + 1\\n            ans = max(ans,d[n])\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2390924,
                "title": "dp-memomization-easy-solution-c",
                "content": "this ques is similar to LIS ques\\njust take a prev to know whether we can take current element in sequence or not\\n\\n```\\nclass Solution {\\npublic:\\n    int fn(int ind,int prev,string &s,int &k, vector<vector<int>>&dp)\\n    {\\n        if(ind>=s.size())\\n            return 0;\\n        \\n        if(dp[ind][prev+1]!=-1)\\n            return dp[ind][prev+1];\\n        \\n        \\n        int taken=0;\\n        \\n        if(prev==-1) // if no element is taken in sequence\\n        {\\n            taken=1+fn(ind+1,s[ind]-\\'a\\',s,k,dp);\\n        }\\n        else {\\n            int val=s[ind]-\\'a\\';\\n            \\n            if(abs(val-prev)<=k) //if curr -prev<=k than we can take that element\\n                taken=1+fn(ind+1,s[ind]-\\'a\\',s,k,dp);\\n        }\\n        \\n        int nonTaken=fn(ind+1,prev,s,k,dp);\\n        \\n        return dp[ind][prev+1]= max(taken,nonTaken);\\n        \\n    }\\n    int longestIdealString(string s, int k) {\\n     vector<vector<int>>dp(s.size(),vector<int>(28,-1));\\n                return fn(0,-1,s,k,dp);\\n       \\n    }\\n};\\n```\\n\\nTC:O(n*26)\\nSC:o(n)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fn(int ind,int prev,string &s,int &k, vector<vector<int>>&dp)\\n    {\\n        if(ind>=s.size())\\n            return 0;\\n        \\n        if(dp[ind][prev+1]!=-1)\\n            return dp[ind][prev+1];\\n        \\n        \\n        int taken=0;\\n        \\n        if(prev==-1) // if no element is taken in sequence\\n        {\\n            taken=1+fn(ind+1,s[ind]-\\'a\\',s,k,dp);\\n        }\\n        else {\\n            int val=s[ind]-\\'a\\';\\n            \\n            if(abs(val-prev)<=k) //if curr -prev<=k than we can take that element\\n                taken=1+fn(ind+1,s[ind]-\\'a\\',s,k,dp);\\n        }\\n        \\n        int nonTaken=fn(ind+1,prev,s,k,dp);\\n        \\n        return dp[ind][prev+1]= max(taken,nonTaken);\\n        \\n    }\\n    int longestIdealString(string s, int k) {\\n     vector<vector<int>>dp(s.size(),vector<int>(28,-1));\\n                return fn(0,-1,s,k,dp);\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390869,
                "title": "c-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[100001][27] ;\\n    \\n    int solve(int pos , int prev , int k , string &s){\\n        if(pos >= size(s)) return 0 ;\\n        if(dp[pos][prev] != -1) return dp[pos][prev] ;\\n        int op1 = 0 , op2 = 0 ;\\n        if(prev == 0 || abs(prev - (s[pos]-\\'a\\' + 1)) <= k) op1 = 1 + solve(pos + 1 , (s[pos]-\\'a\\') + 1 , k , s) ;\\n        op2 = solve(pos + 1 , prev , k , s) ;\\n        \\n        return dp[pos][prev] = max(op1,op2);\\n    }\\n    \\n    int longestIdealString(string s, int k) {\\n        memset(dp,-1,sizeof(dp)) ;\\n        return solve(0,0,k,s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[100001][27] ;\\n    \\n    int solve(int pos , int prev , int k , string &s){\\n        if(pos >= size(s)) return 0 ;\\n        if(dp[pos][prev] != -1) return dp[pos][prev] ;\\n        int op1 = 0 , op2 = 0 ;\\n        if(prev == 0 || abs(prev - (s[pos]-\\'a\\' + 1)) <= k) op1 = 1 + solve(pos + 1 , (s[pos]-\\'a\\') + 1 , k , s) ;\\n        op2 = solve(pos + 1 , prev , k , s) ;\\n        \\n        return dp[pos][prev] = max(op1,op2);\\n    }\\n    \\n    int longestIdealString(string s, int k) {\\n        memset(dp,-1,sizeof(dp)) ;\\n        return solve(0,0,k,s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390829,
                "title": "simple-c-solution-using-26-size-vector",
                "content": "```\\n int longestIdealString(string s, int k) {\\n        vector<int>v(26,0);\\n        int ans=0;\\n             int n=s.size();\\n            for(int i=0;i<n;i++){\\n                int c=(int)(s[i]-\\'a\\');\\n            for(int j=0;j<=k;j++){\\n            if(c-j>=0&&v[c-j]>0)v[c]=max(v[c],v[c-j]+1);\\n            }\\n            for(int j=1;j<=k;j++){\\n            if(c+j<26&&v[c+j]>0)v[c]=max(v[c],v[c+j]+1);\\n            }\\n            v[c]=max(v[c],1);\\n             ans=max(ans,v[c]);  \\n            }\\n         return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n int longestIdealString(string s, int k) {\\n        vector<int>v(26,0);\\n        int ans=0;\\n             int n=s.size();\\n            for(int i=0;i<n;i++){\\n                int c=(int)(s[i]-\\'a\\');\\n            for(int j=0;j<=k;j++){\\n            if(c-j>=0&&v[c-j]>0)v[c]=max(v[c],v[c-j]+1);\\n            }\\n            for(int j=1;j<=k;j++){\\n            if(c+j<26&&v[c+j]>0)v[c]=max(v[c],v[c+j]+1);\\n            }\\n            v[c]=max(v[c],1);\\n             ans=max(ans,v[c]);  \\n            }\\n         return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2390735,
                "title": "simple-java-dp-solution-with-memoization",
                "content": "\\n```\\npublic int findLongest(int idx, char prevchar, String s, int k, int[][] dp){\\n        if(idx>=s.length())return 0;\\n        \\n        if(dp[idx][prevchar-\\'a\\']!=-1) return dp[idx][prevchar-\\'a\\'];\\n        \\n        int take = 0;\\n        if(prevchar==\\'{\\' || Math.abs(s.charAt(idx)-prevchar)<=k){\\n            take = 1 + findLongest(idx+1, s.charAt(idx), s, k, dp);\\n        }\\n        \\n        int nottake = findLongest(idx+1, prevchar, s, k, dp);\\n        \\n        return dp[idx][prevchar-\\'a\\'] = Math.max(take, nottake);\\n    }\\n    \\n    public int longestIdealString(String s, int k) {\\n        int n = s.length();\\n        int[][] dp = new int[n][27];\\n        \\n        for(int[] d1 : dp){\\n            Arrays.fill(d1, -1);\\n        }\\n        return findLongest(0, \\'{\\', s, k, dp);      // Ascii value of \\'{\\' is 123;\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\npublic int findLongest(int idx, char prevchar, String s, int k, int[][] dp){\\n        if(idx>=s.length())return 0;\\n        \\n        if(dp[idx][prevchar-\\'a\\']!=-1) return dp[idx][prevchar-\\'a\\'];\\n        \\n        int take = 0;\\n        if(prevchar==\\'{\\' || Math.abs(s.charAt(idx)-prevchar)<=k){\\n            take = 1 + findLongest(idx+1, s.charAt(idx), s, k, dp);\\n        }\\n        \\n        int nottake = findLongest(idx+1, prevchar, s, k, dp);\\n        \\n        return dp[idx][prevchar-\\'a\\'] = Math.max(take, nottake);\\n    }\\n    \\n    public int longestIdealString(String s, int k) {\\n        int n = s.length();\\n        int[][] dp = new int[n][27];\\n        \\n        for(int[] d1 : dp){\\n            Arrays.fill(d1, -1);\\n        }\\n        return findLongest(0, \\'{\\', s, k, dp);      // Ascii value of \\'{\\' is 123;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2390676,
                "title": "cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\nint n = s.size();\\n        int dp[26]{};\\n        for (int i = 0; i < n; i++)\\n        {\\n            int v = s[i] - \\'a\\', t = dp[v];\\n            for (int c = 0; c < 26; c++)\\n            {\\n                if (abs(c - v) <= k)\\n                {\\n                    t = max(t, dp[c] + 1);\\n                }\\n            }\\n            dp[v] = t;\\n        }\\n        return *max_element(begin(dp), end(dp));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\nint n = s.size();\\n        int dp[26]{};\\n        for (int i = 0; i < n; i++)\\n        {\\n            int v = s[i] - \\'a\\', t = dp[v];\\n            for (int c = 0; c < 26; c++)\\n            {\\n                if (abs(c - v) <= k)\\n                {\\n                    t = max(t, dp[c] + 1);\\n                }\\n            }\\n            dp[v] = t;\\n        }\\n        return *max_element(begin(dp), end(dp));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390660,
                "title": "horrible-python-user-experience",
                "content": "k = 25, I assume it as constant.\\n\\nI get it, you could optimize the solution to be O(n) by saving the last result for the character.\\n\\nBut why binary search `nlogn` (logn is the worst case if all characters are the same in the string) TLEs??\\n\\n```\\nclass Solution:\\n    def longestIdealString(self, s: str, k: int) -> int:\\n        alph = [[] for _ in range(26)]\\n        n = len(s)\\n        dp = [1] * n\\n        best = 1\\n        \\n        for i, c in enumerate(s):\\n            index = ord(c) - ord(\\'a\\')\\n            alph[index].append(i)\\n            \\n    \\n        for i in range(n-2, -1, -1):\\n            c_index = ord(s[i]) - ord(\\'a\\')\\n            \\n            for j in range(k, -1, -1):\\n                # neg abs side\\n                if c_index - j >= 0:\\n                    j_alph_index = c_index - j\\n                    next_i = self.next_greater_index(alph[j_alph_index], i)\\n                    if next_i > i:\\n                        dp[i] = max(dp[i], 1 + dp[next_i])\\n                        best = max(best, dp[i])\\n                \\n                # pos abs side\\n                if c_index + j < 26:\\n                    j_alph_index = c_index + j\\n                    next_i = self.next_greater_index(alph[j_alph_index], i)\\n                    if next_i > i:\\n                        dp[i] = max(dp[i], 1 + dp[next_i])\\n                        best = max(best, dp[i])\\n    \\n        return best\\n        \\n    \\n    \\n    def next_greater_index(self, arr: list[int], val: int):\\n        left = 0\\n        right = len(arr) - 1\\n        ans = -1\\n        \\n        while left <= right:\\n            mid = left + (right - left) // 2\\n            if arr[mid] <= val:\\n                left = mid + 1\\n            else:\\n                ans = arr[mid]\\n                right = mid - 1\\n        \\n        return ans\\n```\\n\\nI\\'m 99% sure it won\\'t TLE in cpp..\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestIdealString(self, s: str, k: int) -> int:\\n        alph = [[] for _ in range(26)]\\n        n = len(s)\\n        dp = [1] * n\\n        best = 1\\n        \\n        for i, c in enumerate(s):\\n            index = ord(c) - ord(\\'a\\')\\n            alph[index].append(i)\\n            \\n    \\n        for i in range(n-2, -1, -1):\\n            c_index = ord(s[i]) - ord(\\'a\\')\\n            \\n            for j in range(k, -1, -1):\\n                # neg abs side\\n                if c_index - j >= 0:\\n                    j_alph_index = c_index - j\\n                    next_i = self.next_greater_index(alph[j_alph_index], i)\\n                    if next_i > i:\\n                        dp[i] = max(dp[i], 1 + dp[next_i])\\n                        best = max(best, dp[i])\\n                \\n                # pos abs side\\n                if c_index + j < 26:\\n                    j_alph_index = c_index + j\\n                    next_i = self.next_greater_index(alph[j_alph_index], i)\\n                    if next_i > i:\\n                        dp[i] = max(dp[i], 1 + dp[next_i])\\n                        best = max(best, dp[i])\\n    \\n        return best\\n        \\n    \\n    \\n    def next_greater_index(self, arr: list[int], val: int):\\n        left = 0\\n        right = len(arr) - 1\\n        ans = -1\\n        \\n        while left <= right:\\n            mid = left + (right - left) // 2\\n            if arr[mid] <= val:\\n                left = mid + 1\\n            else:\\n                ans = arr[mid]\\n                right = mid - 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390502,
                "title": "dp-on-asci-index",
                "content": "Intuition: \\n\\nFor each it\\'ll generate an ideal subsequece with any char in the range of char_index - k to char_index + k.\\nso we\\'ll find that and search in the DP array which char in that range gives longest subsequence.\\n\\n\\n```\\nclass Solution {\\n    \\n    public int longestIdealString(String s, int k) {\\n        \\n        int[] dp = new int[27];\\n        int n = s.length();\\n        \\n        for(int i = n-1; i >= 0 ;i--){\\n            char cc = s.charAt(i);\\n            int idx = cc - \\'a\\';\\n            int max  = Integer.MIN_VALUE;\\n            \\n            int left = Math.max((idx-k), 0);\\n            int right = Math.min((idx + k), 26);\\n            \\n            for(int j = left; j <= right ; j++){\\n                max = Math.max(max, dp[j]);\\n            }\\n            \\n            dp[idx] = max+1;\\n        }\\n        \\n        int max = Integer.MIN_VALUE;\\n        \\n        for(int ele : dp){\\n            max = Math.max(ele, max);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int longestIdealString(String s, int k) {\\n        \\n        int[] dp = new int[27];\\n        int n = s.length();\\n        \\n        for(int i = n-1; i >= 0 ;i--){\\n            char cc = s.charAt(i);\\n            int idx = cc - \\'a\\';\\n            int max  = Integer.MIN_VALUE;\\n            \\n            int left = Math.max((idx-k), 0);\\n            int right = Math.min((idx + k), 26);\\n            \\n            for(int j = left; j <= right ; j++){\\n                max = Math.max(max, dp[j]);\\n            }\\n            \\n            dp[idx] = max+1;\\n        }\\n        \\n        int max = Integer.MIN_VALUE;\\n        \\n        for(int ele : dp){\\n            max = Math.max(ele, max);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390454,
                "title": "c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        vector<int> dp(26);\\n        for (char c : s) {\\n            int i = c - \\'a\\';\\n            int cnt = 0;\\n            for (int j = max(0, i - k); j <= min(25, i + k); ++j) {\\n                cnt = max(cnt, dp[j]);\\n            }\\n\\n            dp[i] = cnt + 1;\\n        }\\n\\n        return *max_element(dp.begin(), dp.end());\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        vector<int> dp(26);\\n        for (char c : s) {\\n            int i = c - \\'a\\';\\n            int cnt = 0;\\n            for (int j = max(0, i - k); j <= min(25, i + k); ++j) {\\n                cnt = max(cnt, dp[j]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2654514,
                "title": "c-fastest-submission-very-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n\\tint longestIdealString(string s, int k) \\n\\t{\\n       int idx=0;\\n       char prev=\\'{\\';\\n       dp.resize(s.length()+1,vector<int>(27,-1));\\n\\t   return fun(s,idx,k,prev);\\n    }\\n    int fun(string &str,int idx,int &k,char prev)\\n    {\\n    \\tif(idx>=str.length())\\n    \\t{\\n    \\t\\treturn 0;\\n\\t\\t}\\n\\t\\tif(dp[idx][prev-\\'a\\']!=-1)\\n\\t\\t{\\n\\t\\t\\treturn dp[idx][prev-\\'a\\'];\\n\\t\\t}\\n        if(prev==\\'{\\')                     //\\n        {\\n        \\tint len=0;\\n        \\t//can be taken \\n        \\tint choise1=len=1+fun(str,idx+1,k,str[idx]);\\n        \\t//it cannot be taken by the choise\\n        \\tint choise2=len=0+fun(str,idx+1,k,prev);\\n        \\t\\n        \\treturn dp[idx][prev-\\'a\\'] = max(choise1,choise2);\\n\\t\\t}\\n\\t\\telse if(prev!=\\'{\\')\\n\\t\\t{\\n\\t\\t\\tif(abs(str[idx]-prev)<=k)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint choise1=1+fun(str,idx+1,k,str[idx]);\\n\\t\\t\\t\\tint choise2=0+fun(str,idx+1,k,prev);\\n\\t\\t\\t    return dp[idx][prev-\\'a\\'] = max(choise1,choise2);\\n\\t\\t\\t}\\n\\t\\t\\telse if(abs(str[idx]-prev)>k)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn dp[idx][prev-\\'a\\'] = 0+fun(str,idx+1,k,prev);\\n\\t\\t\\t}\\n\\t\\t}\\n        return 0;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n\\tint longestIdealString(string s, int k) \\n\\t{\\n       int idx=0;\\n       char prev=\\'{\\';\\n       dp.resize(s.length()+1,vector<int>(27,-1));\\n\\t   return fun(s,idx,k,prev);\\n    }\\n    int fun(string &str,int idx,int &k,char prev)\\n    {\\n    \\tif(idx>=str.length())\\n    \\t{\\n    \\t\\treturn 0;\\n\\t\\t}\\n\\t\\tif(dp[idx][prev-\\'a\\']!=-1)\\n\\t\\t{\\n\\t\\t\\treturn dp[idx][prev-\\'a\\'];\\n\\t\\t}\\n        if(prev==\\'{\\')                     //\\n        {\\n        \\tint len=0;\\n        \\t//can be taken \\n        \\tint choise1=len=1+fun(str,idx+1,k,str[idx]);\\n        \\t//it cannot be taken by the choise\\n        \\tint choise2=len=0+fun(str,idx+1,k,prev);\\n        \\t\\n        \\treturn dp[idx][prev-\\'a\\'] = max(choise1,choise2);\\n\\t\\t}\\n\\t\\telse if(prev!=\\'{\\')\\n\\t\\t{\\n\\t\\t\\tif(abs(str[idx]-prev)<=k)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint choise1=1+fun(str,idx+1,k,str[idx]);\\n\\t\\t\\t\\tint choise2=0+fun(str,idx+1,k,prev);\\n\\t\\t\\t    return dp[idx][prev-\\'a\\'] = max(choise1,choise2);\\n\\t\\t\\t}\\n\\t\\t\\telse if(abs(str[idx]-prev)>k)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn dp[idx][prev-\\'a\\'] = 0+fun(str,idx+1,k,prev);\\n\\t\\t\\t}\\n\\t\\t}\\n        return 0;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2639691,
                "title": "c-lcs-approach-memoization",
                "content": "TC;: O( N * 26)\\nSC : O( N * 26 ) + Auxiliary stack space O(N)\\n ```\\n public:\\n    int solve(int idx, int last ,string &str ,int &k,vector<vector<int>>&dp){\\n        //base case\\n        if(idx>=str.size())\\n            return 0;\\n        \\n        //check the cache\\n        if(dp[idx][last]!=-1)\\n            return dp[idx][last];\\n        \\n        int pick=0,notpick=0;\\n        //notpick\\n        notpick= 0 + solve(idx+1,last,str,k,dp);\\n        \\n        //pick\\n        if(last == 0 || abs(str[idx]-\\'a\\'+1 - last) <= k)\\n            pick= 1+ solve(idx+1,str[idx]-\\'a\\'+ 1,str,k,dp);\\n        \\n        return dp[idx][last] = max(pick , notpick);\\n    }\\n    int longestIdealString(string s, int k) {\\n        int n=s.size();\\n        vector<vector<int>>dp(n+1,vector<int>(27,-1));\\n        return solve(0,0,s,k,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\n public:\\n    int solve(int idx, int last ,string &str ,int &k,vector<vector<int>>&dp){\\n        //base case\\n        if(idx>=str.size())\\n            return 0;\\n        \\n        //check the cache\\n        if(dp[idx][last]!=-1)\\n            return dp[idx][last];\\n        \\n        int pick=0,notpick=0;\\n        //notpick\\n        notpick= 0 + solve(idx+1,last,str,k,dp);\\n        \\n        //pick\\n        if(last == 0 || abs(str[idx]-\\'a\\'+1 - last) <= k)\\n            pick= 1+ solve(idx+1,str[idx]-\\'a\\'+ 1,str,k,dp);\\n        \\n        return dp[idx][last] = max(pick , notpick);\\n    }\\n    int longestIdealString(string s, int k) {\\n        int n=s.size();\\n        vector<vector<int>>dp(n+1,vector<int>(27,-1));\\n        return solve(0,0,s,k,dp);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2509338,
                "title": "c-o-n-complexity-dp",
                "content": "APPROACH :\\n  here we iterate the loop for each and every character of the string and observing  the longest subsequence ending for every character. then we update our answer continuously for the recently chosen character .\\n      dp[i]=longest ideal ending of char (\\'a\\' + i)\\n\\t  \\n\\t  \\n CODE:\\n\\t  \\n\\t  class Solution {\\npublic:\\n\\tint longestIdealString(string s, int k) {\\n        int n=s.size();\\n\\t\\tvector<int> dp(26, 0);\\n\\t\\tfor (int i = 0; i <n;i++) {\\n\\t\\t\\tint ch= s[i] - \\'a\\';\\n\\t\\t\\tint ans = 1;\\n\\t\\t\\tfor (int j = 0;j<26;j++) {\\n                int d=abs(j-ch);\\n\\t\\t\\t\\tif (d <= k) {\\n\\t\\t\\t\\t\\tans = max(ans, dp[j] + 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tdp[ch] = ans;\\n\\t\\t}\\n\\t\\treturn *max_element(dp.begin(), dp.end());\\n\\t}\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\tint longestIdealString(string s, int k) {\\n        int n=s.size();\\n\\t\\tvector<int> dp(26, 0);\\n\\t\\tfor (int i = 0; i <n;i++) {\\n\\t\\t\\tint ch= s[i] - \\'a\\';\\n\\t\\t\\tint ans = 1;\\n\\t\\t\\tfor (int j = 0;j<26;j++) {\\n                int d=abs(j-ch);\\n\\t\\t\\t\\tif (d <= k) {\\n\\t\\t\\t\\t\\tans = max(ans, dp[j] + 1);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2447378,
                "title": "c-2-method-o-k-n",
                "content": "\\'\\'\\'\\n\\t\\t\\n        int* arr=new int[s.length()];\\n\\t\\t\\n        vector<int> v1;\\n        v1.push_back(1);\\n        for (int i=0;i<s.length();i++)\\n        {\\n            arr[i]=int(s[i])-int(\\'a\\');\\n        }\\n        for (int i=1;i<s.length();i++)\\n        {\\n            int ele=0;\\n            for (int j=0;j<i;j++)\\n            {\\n                if (abs(arr[j]-arr[i])<=k )\\n                {\\n                    ele=max(ele,v1[j]);\\n                }     \\n            }\\n            v1.push_back(ele+1);\\n        }\\n        delete []arr;\\n        int ans=0;\\n        for (int i=0;i<v1.size();i++)\\n        {\\n            ans=max(ans,v1[i]);\\n        }\\n        return ans;\\n\\t\\t\\'\\'\\'\\n\\t\\t\\'\\'\\'\\n        \\n\\t\\t// Method 2( TC=O(K*N) \\n        vector<int> dp(26,0);\\n        for (int i=0;i<s.length();i++)\\n        {\\n            int ptr=int(s[i])-int(\\'a\\');\\n            int l=max(0,ptr-k);\\n            int r=min(25,ptr+k);\\n            int ele=0;\\n            for (int j=l;j<=r;j++)\\n            {\\n                ele=max(ele,dp[j]);\\n            }\\n            dp[ptr]=ele+1;  \\n        }\\n        int ans=0;\\n        for (int i=0;i<dp.size();i++)\\n        {\\n            ans=max(ans,dp[i]);\\n        }\\n        return ans;\\n\\t\\t\\n\\t\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\t\\t\\n        int* arr=new int[s.length()];\\n\\t\\t\\n        vector<int> v1;\\n        v1.push_back(1);\\n        for (int i=0;i<s.length();i++)\\n        {\\n            arr[i]=int(s[i])-int(\\'a\\');\\n        }\\n        for (int i=1;i<s.length();i++)\\n        {\\n            int ele=0;\\n            for (int j=0;j<i;j++)\\n            {\\n                if (abs(arr[j]-arr[i])<=k )\\n                {\\n                    ele=max(ele,v1[j]);\\n                }     \\n            }\\n            v1.push_back(ele+1);\\n        }\\n        delete []arr;\\n        int ans=0;\\n        for (int i=0;i<v1.size();i++)\\n        {\\n            ans=max(ans,v1[i]);\\n        }\\n        return ans;\\n\\t\\t\\'\\'\\'\\n\\t\\t\\'\\'\\'\\n        \\n\\t\\t// Method 2( TC=O(K*N) \\n        vector<int> dp(26,0);\\n        for (int i=0;i<s.length();i++)\\n        {\\n            int ptr=int(s[i])-int(\\'a\\');\\n            int l=max(0,ptr-k);\\n            int r=min(25,ptr+k);\\n            int ele=0;\\n            for (int j=l;j<=r;j++)\\n            {\\n                ele=max(ele,dp[j]);\\n            }\\n            dp[ptr]=ele+1;  \\n        }\\n        int ans=0;\\n        for (int i=0;i<dp.size();i++)\\n        {\\n            ans=max(ans,dp[i]);\\n        }\\n        return ans;\\n\\t\\t\\n\\t\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2412370,
                "title": "c-easy-solution-from-observation",
                "content": "**C++ Code:**\\n\\n```\\nint f(string s, int k,vector<int>&dp)\\n   {\\n     int ans = 1;\\n     for(int i=0;i<s.length();i++)\\n     {\\n         int e = s[i]-\\'a\\'; \\n         // left \\n         for(int j=e;j>=0 && j>=e-k;j--)\\n         {\\n             if(j==e && dp[j]==0) dp[j] = 1;\\n             else dp[e] = max(dp[e],dp[j]+1);\\n         }\\n         //right\\n         for(int j=e+1;j<=25 && j<=e+k;j++)\\n             dp[e] = max(dp[e],dp[j]+1);\\n\\n         ans = max(ans,dp[e]);\\n     }   \\n      return ans;\\n   }\\n   int longestIdealString(string s, int k) {\\n     vector<int>dp(26,0);\\n     return f(s,k,dp);\\n   }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint f(string s, int k,vector<int>&dp)\\n   {\\n     int ans = 1;\\n     for(int i=0;i<s.length();i++)\\n     {\\n         int e = s[i]-\\'a\\'; \\n         // left \\n         for(int j=e;j>=0 && j>=e-k;j--)\\n         {\\n             if(j==e && dp[j]==0) dp[j] = 1;\\n             else dp[e] = max(dp[e],dp[j]+1);\\n         }\\n         //right\\n         for(int j=e+1;j<=25 && j<=e+k;j++)\\n             dp[e] = max(dp[e],dp[j]+1);\\n\\n         ans = max(ans,dp[e]);\\n     }   \\n      return ans;\\n   }\\n   int longestIdealString(string s, int k) {\\n     vector<int>dp(26,0);\\n     return f(s,k,dp);\\n   }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2410127,
                "title": "python3-o-n-time-and-o-26-space",
                "content": "```\\ndef longestIdealString(self, s: str, k: int) -> int:\\n    \"\"\"a better approach\\n\\n    we maintain a list of length 26 called letter\\n    letter[i] presents the longest length of ideal subsequences that end with letter \\'a\\' + i\\n    \"\"\"\\n    if k == 25: return len(s)\\n    letter = [0] * 26\\n    for i in s:\\n        idx = ord(i) - ord(\\'a\\')\\n        left_boundary, right_boundary = max(0, idx - k), min(25, idx + k)\\n        letter[idx] = max(letter[left_boundary : right_boundary + 1]) + 1\\n    return max(letter)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef longestIdealString(self, s: str, k: int) -> int:\\n    \"\"\"a better approach\\n\\n    we maintain a list of length 26 called letter\\n    letter[i] presents the longest length of ideal subsequences that end with letter \\'a\\' + i\\n    \"\"\"\\n    if k == 25: return len(s)\\n    letter = [0] * 26\\n    for i in s:\\n        idx = ord(i) - ord(\\'a\\')\\n        left_boundary, right_boundary = max(0, idx - k), min(25, idx + k)\\n        letter[idx] = max(letter[left_boundary : right_boundary + 1]) + 1\\n    return max(letter)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2401801,
                "title": "space-optimized-dp-python",
                "content": "```\\nclass Solution:\\n    def longestIdealString(self, s: str, k: int) -> int:\\n        dp = [0 for i in range(27)]\\n        ans = 1\\n        for i in s:\\n            char = ord(i)-97\\n            temp = [dp[i] for i in range(27)]\\n            for j in range(max(0,char-k),min(26,char+k)+1):\\n                temp[char] = max(temp[char], dp[j]+1)\\n            dp = temp\\n        return max(dp)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def longestIdealString(self, s: str, k: int) -> int:\\n        dp = [0 for i in range(27)]\\n        ans = 1\\n        for i in s:\\n            char = ord(i)-97\\n            temp = [dp[i] for i in range(27)]\\n            for j in range(max(0,char-k),min(26,char+k)+1):\\n                temp[char] = max(temp[char], dp[j]+1)\\n            dp = temp\\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2397525,
                "title": "c-dp-memo-lis-variation",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[100001][51];\\n    int n,k;\\n    int fn(string &s, int i, int j)\\n    {\\n        if(i>=n) return 0;\\n        if(j!=-1 and dp[i][j]!=-1) return dp[i][j];\\n        int ni_lo=0;\\n        int lelo=0;\\n        if(j==-1 or abs(s[i]-\\'a\\'-j)<=k)\\n        {\\n            lelo=fn(s,i+1,s[i]-\\'a\\')+1;  // we take the next element and move further(op1)\\n            \\n        }\\n        ni_lo=fn(s,i+1,j); // we do not take the next element and move further (op2)\\n        \\n        // we return the max of op1 and op2\\n        if(j!=-1)\\n            return dp[i][j]=max(lelo,ni_lo);\\n        return dp[i][0]=max(lelo,ni_lo);\\n    }\\n    int longestIdealString(string s, int k) {\\n        memset(dp,-1,sizeof(dp));\\n        this->k=k;\\n        n=size(s);\\n        return fn(s,0,-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[100001][51];\\n    int n,k;\\n    int fn(string &s, int i, int j)\\n    {\\n        if(i>=n) return 0;\\n        if(j!=-1 and dp[i][j]!=-1) return dp[i][j];\\n        int ni_lo=0;\\n        int lelo=0;\\n        if(j==-1 or abs(s[i]-\\'a\\'-j)<=k)\\n        {\\n            lelo=fn(s,i+1,s[i]-\\'a\\')+1;  // we take the next element and move further(op1)\\n            \\n        }\\n        ni_lo=fn(s,i+1,j); // we do not take the next element and move further (op2)\\n        \\n        // we return the max of op1 and op2\\n        if(j!=-1)\\n            return dp[i][j]=max(lelo,ni_lo);\\n        return dp[i][0]=max(lelo,ni_lo);\\n    }\\n    int longestIdealString(string s, int k) {\\n        memset(dp,-1,sizeof(dp));\\n        this->k=k;\\n        n=size(s);\\n        return fn(s,0,-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2392235,
                "title": "c-easy-to-understand-top-down-bottom-up",
                "content": "```\\n   class Solution {\\npublic:\\n\\ntop-down:\\ntime-complexity:-O(n*30);\\nspace-complexity:-O(n*30)+auxillary space\\n\\n    int dp[100005][30];\\n    int solve(int ind,char prev,string &s,int k)\\n    {\\n        if(ind==s.length())\\n            return 0;\\n        if(dp[ind][prev-\\'a\\']!=-1)\\n            return dp[ind][prev-\\'a\\'];\\n        int ans=0;\\n        if(prev==\\'{\\')\\n        {\\n         ans=max(ans,1+solve(ind+1,s[ind],s,k));\\n         ans=max(ans,solve(ind+1,prev,s,k));\\n        }\\n        else\\n        {\\n         if(abs(s[ind]-prev)<=k)\\n          ans=max(ans,1+solve(ind+1,s[ind],s,k));\\n         ans=max(ans,solve(ind+1,prev,s,k));\\n        }\\n        dp[ind][prev-\\'a\\']=ans;\\n        return ans;\\n    }\\n    int longestIdealString(string s, int k) {\\n        int n=s.length();\\n        memset(dp,-1,sizeof dp);\\n        return solve(0,\\'{\\',s,k);\\n    }\\n};\\n.............................................................................................................................................................................................................\\n\\nbottom-up\\ntime-complexity:-O(n*30);\\nspace-complexity:-O(n*30);\\nclass Solution {\\npublic:\\n   \\n    int longestIdealString(string s, int k) \\n    {\\n        int n=s.length();\\n        int dp[n+1][30];\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<30;j++)\\n            {\\n                dp[i][j]=0;\\n            }\\n        }\\n        for(int j=0;j<30;j++)\\n        {\\n            dp[n][j]=0;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i][s[i]-\\'a\\']=1;\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n          char c=s[i];\\n          for(char c1=\\'a\\';c1<=\\'z\\';c1++)\\n          {\\n              if(dp[i+1][c1-\\'a\\']==0)\\n                  continue;\\n              if(abs(c-c1)<=k)\\n              {\\n                  dp[i][c-\\'a\\']=max(dp[i][c-\\'a\\'],dp[i+1][c1-\\'a\\']+1);\\n              }\\n              // else\\n                  dp[i][c1-\\'a\\']=max(dp[i][c1-\\'a\\'],dp[i+1][c1-\\'a\\']);\\n          }\\n        }\\n        int maxi=0;\\n        for(int i=0;i<27;i++)  \\n        {\\n            // if()\\n            maxi=max(maxi,dp[0][i]);\\n        }\\n        return maxi;\\n        \\n    }\\n};\\n..................................................................................................................................................................................................................\\n\\noptimized bottom up;\\ntime-complexity:-O(n*30);\\nspace-complexity:-O(30);\\n\\nclass Solution {\\npublic:\\n   \\n    int longestIdealString(string s, int k) \\n    {\\n        int n=s.length();\\n        int prev[30];\\n        \\n            for(int j=0;j<30;j++)\\n            {\\n                prev[j]=0;\\n            }\\n        // }\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n          char c=s[i];\\n           int curr[30];\\n            for(int j=0;j<30;j++)\\n            {\\n             curr[j]=0;\\n            }\\n          curr[c-\\'a\\']=1;\\n          for(char c1=\\'a\\';c1<=\\'z\\';c1++)\\n          {\\n              if(prev[c1-\\'a\\']==0)\\n                  continue;\\n              if(abs(c-c1)<=k)\\n              {\\n                  curr[c-\\'a\\']=max(curr[c-\\'a\\'],prev[c1-\\'a\\']+1);\\n              }\\n              // else\\n                  curr[c1-\\'a\\']=max(curr[c1-\\'a\\'],prev[c1-\\'a\\']);\\n          }\\n            for(int j=0;j<30;j++)\\n            {\\n                prev[j]=curr[j];\\n            }\\n        }\\n        int maxi=0;\\n        for(int i=0;i<27;i++)\\n        {\\n            // if()\\n            maxi=max(maxi,prev[i]);\\n        }\\n        return maxi;\\n        \\n    }   \\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n   class Solution {\\npublic:\\n\\ntop-down:\\ntime-complexity:-O(n*30);\\nspace-complexity:-O(n*30)+auxillary space\\n\\n    int dp[100005][30];\\n    int solve(int ind,char prev,string &s,int k)\\n    {\\n        if(ind==s.length())\\n            return 0;\\n        if(dp[ind][prev-\\'a\\']!=-1)\\n            return dp[ind][prev-\\'a\\'];\\n        int ans=0;\\n        if(prev==\\'{\\')\\n        {\\n         ans=max(ans,1+solve(ind+1,s[ind],s,k));\\n         ans=max(ans,solve(ind+1,prev,s,k));\\n        }\\n        else\\n        {\\n         if(abs(s[ind]-prev)<=k)\\n          ans=max(ans,1+solve(ind+1,s[ind],s,k));\\n         ans=max(ans,solve(ind+1,prev,s,k));\\n        }\\n        dp[ind][prev-\\'a\\']=ans;\\n        return ans;\\n    }\\n    int longestIdealString(string s, int k) {\\n        int n=s.length();\\n        memset(dp,-1,sizeof dp);\\n        return solve(0,\\'{\\',s,k);\\n    }\\n};\\n.............................................................................................................................................................................................................\\n\\nbottom-up\\ntime-complexity:-O(n*30);\\nspace-complexity:-O(n*30);\\nclass Solution {\\npublic:\\n   \\n    int longestIdealString(string s, int k) \\n    {\\n        int n=s.length();\\n        int dp[n+1][30];\\n        for(int i=0;i<=n;i++)\\n        {\\n            for(int j=0;j<30;j++)\\n            {\\n                dp[i][j]=0;\\n            }\\n        }\\n        for(int j=0;j<30;j++)\\n        {\\n            dp[n][j]=0;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i][s[i]-\\'a\\']=1;\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n          char c=s[i];\\n          for(char c1=\\'a\\';c1<=\\'z\\';c1++)\\n          {\\n              if(dp[i+1][c1-\\'a\\']==0)\\n                  continue;\\n              if(abs(c-c1)<=k)\\n              {\\n                  dp[i][c-\\'a\\']=max(dp[i][c-\\'a\\'],dp[i+1][c1-\\'a\\']+1);\\n              }\\n              // else\\n                  dp[i][c1-\\'a\\']=max(dp[i][c1-\\'a\\'],dp[i+1][c1-\\'a\\']);\\n          }\\n        }\\n        int maxi=0;\\n        for(int i=0;i<27;i++)  \\n        {\\n            // if()\\n            maxi=max(maxi,dp[0][i]);\\n        }\\n        return maxi;\\n        \\n    }\\n};\\n..................................................................................................................................................................................................................\\n\\noptimized bottom up;\\ntime-complexity:-O(n*30);\\nspace-complexity:-O(30);\\n\\nclass Solution {\\npublic:\\n   \\n    int longestIdealString(string s, int k) \\n    {\\n        int n=s.length();\\n        int prev[30];\\n        \\n            for(int j=0;j<30;j++)\\n            {\\n                prev[j]=0;\\n            }\\n        // }\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n          char c=s[i];\\n           int curr[30];\\n            for(int j=0;j<30;j++)\\n            {\\n             curr[j]=0;\\n            }\\n          curr[c-\\'a\\']=1;\\n          for(char c1=\\'a\\';c1<=\\'z\\';c1++)\\n          {\\n              if(prev[c1-\\'a\\']==0)\\n                  continue;\\n              if(abs(c-c1)<=k)\\n              {\\n                  curr[c-\\'a\\']=max(curr[c-\\'a\\'],prev[c1-\\'a\\']+1);\\n              }\\n              // else\\n                  curr[c1-\\'a\\']=max(curr[c1-\\'a\\'],prev[c1-\\'a\\']);\\n          }\\n            for(int j=0;j<30;j++)\\n            {\\n                prev[j]=curr[j];\\n            }\\n        }\\n        int maxi=0;\\n        for(int i=0;i<27;i++)\\n        {\\n            // if()\\n            maxi=max(maxi,prev[i]);\\n        }\\n        return maxi;\\n        \\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391918,
                "title": "java-ez-2-understand",
                "content": "```\\nclass Solution {\\n    //approach: calculate the max subsequence formed at each character\\n    public int longestIdealString(String s, int k) {\\n        return helper(s.toCharArray(),k);\\n    }\\n   public int helper(char arr[],int k) {\\n       int freq[]=new int[26];\\n       for(int i=0;i<arr.length;i++){\\n           int chk1=Math.max(97,arr[i]-k)-97;\\n           int chk2=Math.min(122,arr[i]+k)-97;\\n           int l=0,h=0;\\n           for(int j=chk1;j<=(arr[i]+0)-97;j++)\\n               l=Math.max(freq[j],l);\\n           for(int j=(arr[i]+1)-97;j<=chk2;j++)\\n               h=Math.max(freq[j],h);\\n           int x=Math.max(l,h)+1;\\n           freq[arr[i]-97]=x;\\n       }\\n       int max=0;\\n       for(int i:freq){\\n           max=Math.max(i,max);\\n       }\\n       return max;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "class Solution {\\n    //approach: calculate the max subsequence formed at each character\\n    public int longestIdealString(String s, int k) {\\n        return helper(s.toCharArray(),k);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2391518,
                "title": "c-hashmap-only-easy-understanding",
                "content": "**Approach** :      ***mp[char]*** stores longest subsequence upto that char following all the rules.\\n\\nDuring traversal of each character - \\n* check all possible nearby characters which follows the rules given i.e. **preceding k** and **succeeding k characters**\\n* store the max val of them ( *second value of map* ) in a variable ***longest*** \\n* Now Include this **current char** in the longest subsequence also So, `mp[curr] = longest+1`\\n* Finally store the max length of subsequence in ans variable `ans = max(ans,longest+1);`\\n\\nDo upvote \\u270C\\uFE0F\\n\\n```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        int n=s.size();\\n        \\n        unordered_map<char,int> mp;\\n        int ans = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            int longest = 0;\\n            char curr = s[i];\\n            for(int j=0;j<=k;j++){\\n                char prec = (char)(curr-j);\\n                char suc = (char)(curr+j);\\n                if(mp.count(prec)){\\n                    longest = max(longest,mp[prec]);\\n                }  \\n                if(mp.count(suc)){\\n                    longest = max(longest,mp[suc]);\\n                } \\n            }  \\n            mp[curr] = longest+1;\\n            ans = max(ans,longest+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        int n=s.size();\\n        \\n        unordered_map<char,int> mp;\\n        int ans = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            int longest = 0;\\n            char curr = s[i];\\n            for(int j=0;j<=k;j++){\\n                char prec = (char)(curr-j);\\n                char suc = (char)(curr+j);\\n                if(mp.count(prec)){\\n                    longest = max(longest,mp[prec]);\\n                }  \\n                if(mp.count(suc)){\\n                    longest = max(longest,mp[suc]);\\n                } \\n            }  \\n            mp[curr] = longest+1;\\n            ans = max(ans,longest+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391279,
                "title": "easy-c-knapsack-based-solution",
                "content": "**Approach:**\\nThis question is similar to kanpsack but with a bit of change.For each character in string we have two choices either we do not take it or if it is the first charcater in the subsequence or ist diff from prev is less than k , then we can take it.\\n```\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> dp;\\n    int solve(string &s, int k,int n,int prev)\\n    {\\n        if(n==0)\\n            return 0;\\n        if(dp[n][prev+1]!=-1)\\n            return dp[n][prev+1];\\n        int take=0,nottake=0;\\n        char ch=s[n-1];\\n        if(prev==-1 || abs((ch-\\'a\\')-prev)<=k) // if it is first character in the subsequence or the abs diff is less than k\\n            take=1+solve(s,k,n-1,ch-\\'a\\');     \\n        nottake=solve(s,k,n-1,prev);\\n        return dp[n][prev+1]=max(take,nottake);\\n    }\\n    int longestIdealString(string s, int k) {\\n        int n=s.size();\\n        dp=vector<vector<int>>(n+1,vector<int>(28,-1));\\n        return solve(s,k,s.size(),-1); //prev==-1 indicate that the subsequence is empty \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> dp;\\n    int solve(string &s, int k,int n,int prev)\\n    {\\n        if(n==0)\\n            return 0;\\n        if(dp[n][prev+1]!=-1)\\n            return dp[n][prev+1];\\n        int take=0,nottake=0;\\n        char ch=s[n-1];\\n        if(prev==-1 || abs((ch-\\'a\\')-prev)<=k) // if it is first character in the subsequence or the abs diff is less than k\\n            take=1+solve(s,k,n-1,ch-\\'a\\');     \\n        nottake=solve(s,k,n-1,prev);\\n        return dp[n][prev+1]=max(take,nottake);\\n    }\\n    int longestIdealString(string s, int k) {\\n        int n=s.size();\\n        dp=vector<vector<int>>(n+1,vector<int>(28,-1));\\n        return solve(s,k,s.size(),-1); //prev==-1 indicate that the subsequence is empty \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391020,
                "title": "dp-easy-o-k-n-c-commented",
                "content": "```\\n    int longestIdealString(string s, int k) {\\n        int n=s.length();\\n        vector<int>dp(n+1,1);           // Maximum subsequence starting from i position\\n        unordered_map<int,int>m; //to store the last index of the character\\n        int ans=1;        //Minimum 1 since a single char can be a subsequence\\n        for(int i=0;i<n;i++)\\n        {\\n            int f=s[i]-\\'a\\';           //int value of char\\n            int l=max(0,f-k),r=min(25,f+k);         // Range in which it is valid\\n            for(int j=l;j<=r;j++)\\n            {\\n                if(m.find(j)!=m.end())\\n                    dp[i]=max(dp[i],dp[m[j]]+1),ans=max(ans,dp[i]);    // Update dp similar to coin change problem\\n            }\\n            m[f]=i;  //Update the position in map\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n    int longestIdealString(string s, int k) {\\n        int n=s.length();\\n        vector<int>dp(n+1,1);           // Maximum subsequence starting from i position\\n        unordered_map<int,int>m; //to store the last index of the character\\n        int ans=1;        //Minimum 1 since a single char can be a subsequence\\n        for(int i=0;i<n;i++)\\n        {\\n            int f=s[i]-\\'a\\';           //int value of char\\n            int l=max(0,f-k),r=min(25,f+k);         // Range in which it is valid\\n            for(int j=l;j<=r;j++)\\n            {\\n                if(m.find(j)!=m.end())\\n                    dp[i]=max(dp[i],dp[m[j]]+1),ans=max(ans,dp[i]);    // Update dp similar to coin change problem\\n            }\\n            m[f]=i;  //Update the position in map\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2390598,
                "title": "o-26-n-dp",
                "content": "```\\nclass Solution {\\n    public int longestIdealString(String s, int k) {\\n        int dp[] = new int[26], max=0, maxlen=1;\\n        for(char c: s.toCharArray()){\\n            max=0;\\n            for(int i=Math.max(0, c-\\'a\\'-k); i<=Math.min(25, c-\\'a\\'+k); i++){\\n                max = Math.max(dp[i], max);\\n            }\\n            dp[c-\\'a\\'] = max+1;\\n            maxlen = Math.max(max+1, maxlen);\\n        }\\n        return maxlen;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestIdealString(String s, int k) {\\n        int dp[] = new int[26], max=0, maxlen=1;\\n        for(char c: s.toCharArray()){\\n            max=0;\\n            for(int i=Math.max(0, c-\\'a\\'-k); i<=Math.min(25, c-\\'a\\'+k); i++){\\n                max = Math.max(dp[i], max);\\n            }\\n            dp[c-\\'a\\'] = max+1;\\n            maxlen = Math.max(max+1, maxlen);\\n        }\\n        return maxlen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390494,
                "title": "recursion-memoization",
                "content": "refer comments for better understanding\\n\\n\\n\\n`class Solution {\\n\\n\\tint[][] memo ;\\n    public int longestIdealString(String s, int k) {\\n        //Create a 2d memo for storing the ans\\n        memo = new int[s.length()][28];\\n        //initially fill all with -1\\n        for(int i = 0 ; i < s.length() ;i++){\\n            Arrays.fill(memo[i] , -1);\\n        }\\n        return solve(s , k , 0 , \\'.\\');\\n    }\\n    private int solve(String s , int k , int i ,char p ){\\n        if(i >= s.length())return 0;\\n        \\n        \\n        // if we havent select any character before we have two choices\\n        if(p == \\'.\\'){\\n            if(memo[i][27] >= 0)return memo[i][27];\\n            int ans1 = 1 + solve(s , k ,i+1 , s.charAt(i));\\n            int ans2 = solve(s , k,i+1 ,\\'.\\');\\n            memo[i][27] = Math.max(ans1 , ans2);\\n            return Math.max(ans1 , ans2);\\n        }else{//if we have previous character in our ans the we have to check tha second condition that abs of two letters < k\\n            if(memo[i][p-\\'a\\'] >= 0)return memo[i][p-\\'a\\'];\\n            int ans1 = 0;\\n            \\n            if(Math.abs(s.charAt(i) - p) <= k){\\n                ans1 =1+ solve(s , k ,i+1 , s.charAt(i));\\n            }\\n            int ans2 = solve(s , k ,i+1 ,p);\\n            memo[i][p-\\'a\\'] = Math.max(ans1 , ans2);\\n            return memo[i][p-\\'a\\'];\\n        }\\n        \\n        \\n    }\\n}`\\n",
                "solutionTags": [],
                "code": "class Solution {\\n\\n\\tint[][] memo ;\\n    public int longestIdealString(String s, int k) {\\n        //Create a 2d memo for storing the ans\\n        memo = new int[s.length()][28];\\n        //initially fill all with -1\\n        for(int i = 0 ; i < s.length() ;i++){\\n            Arrays.fill(memo[i] , -1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2390481,
                "title": "java-dfs-solution-with-memoization",
                "content": "```\\nclass Solution {\\n    public int longestIdealString(String s, int k) {\\n        int[][] dp = new int[s.length()][27];\\n        for (int i = 0; i < s.length(); i++) {\\n            for (int j = 0; j < 27; j++) {\\n                dp[i][j] = -1;\\n            }\\n        }\\n        return dfs(s, 0, k, 26, dp);\\n    }\\n    public int dfs(String s, int currentPosition, int k, int previousChar, int[][] dp) {\\n        if (currentPosition >= s.length()) {\\n            return 0;\\n        }\\n        if (dp[currentPosition][previousChar] != -1) {\\n            return dp[currentPosition][previousChar];\\n        }\\n        int currentChar = s.charAt(currentPosition) - \\'a\\';\\n        int result = dfs(s, currentPosition + 1, k, previousChar, dp);\\n        if (previousChar == 26 || Math.abs(currentChar - previousChar) <= k) {\\n            result = Math.max(result, 1 + dfs(s, currentPosition + 1, k, currentChar, dp));\\n        }\\n        dp[currentPosition][previousChar] = result;\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int longestIdealString(String s, int k) {\\n        int[][] dp = new int[s.length()][27];\\n        for (int i = 0; i < s.length(); i++) {\\n            for (int j = 0; j < 27; j++) {\\n                dp[i][j] = -1;\\n            }\\n        }\\n        return dfs(s, 0, k, 26, dp);\\n    }\\n    public int dfs(String s, int currentPosition, int k, int previousChar, int[][] dp) {\\n        if (currentPosition >= s.length()) {\\n            return 0;\\n        }\\n        if (dp[currentPosition][previousChar] != -1) {\\n            return dp[currentPosition][previousChar];\\n        }\\n        int currentChar = s.charAt(currentPosition) - \\'a\\';\\n        int result = dfs(s, currentPosition + 1, k, previousChar, dp);\\n        if (previousChar == 26 || Math.abs(currentChar - previousChar) <= k) {\\n            result = Math.max(result, 1 + dfs(s, currentPosition + 1, k, currentChar, dp));\\n        }\\n        dp[currentPosition][previousChar] = result;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390447,
                "title": "dynamic-programming-on-ascii-with-explanation",
                "content": "##### Rationale\\n* For every `ch`, we need to find a character such that the diff is in the given range and their concatenation results in the maximum subsequence possible\\n* We could traverse the list in reverse so that whenever we encouter a `ch`, we already know that what are the options available for a concatenation\\n* We could use a character frequency array to see which characters are in the range and pick the maximum. Since the frequency array has only `26` elements. This operation will take constant time\\n\\n##### Complexities\\n* Time: `O(n)`\\n* Space: `O(1)`\\n\\n\\n```\\nclass Solution:\\n    def longestIdealString(self, s: str, k: int) -> int:\\n        freq = [0] * 26\\n        key = lambda x: abs(ord(x) - ord(\\'a\\'))\\n        \\n        for ch in s[::-1]:\\n            ch_key = key(ch)\\n            \\n            mx = max(freq[max(0, ch_key - k):min(26, ch_key + k + 1)])\\n            freq[ch_key] = mx + 1\\n            \\n        return max(freq)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def longestIdealString(self, s: str, k: int) -> int:\\n        freq = [0] * 26\\n        key = lambda x: abs(ord(x) - ord(\\'a\\'))\\n        \\n        for ch in s[::-1]:\\n            ch_key = key(ch)\\n            \\n            mx = max(freq[max(0, ch_key - k):min(26, ch_key + k + 1)])\\n            freq[ch_key] = mx + 1\\n            \\n        return max(freq)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3279785,
                "title": "all-three-solution-dp",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int ind, int prev, int k, int n, string &s, vector<vector<int>> &dp)\\n    {\\n        if (ind == n)\\n            return 0;\\n\\n        if (dp[ind][prev] != -1)\\n            return dp[ind][prev];\\n\\n        int notTake = 0 + solve(ind + 1, prev, k, n, s, dp);\\n\\n        int take = 0;\\n        if (prev == 0 or abs(s[ind] - \\'a\\' + 1 - prev) <= k)\\n            take = 1 + solve(ind + 1, s[ind] - \\'a\\' + 1, k, n, s, dp);\\n\\n        return dp[ind][prev] = max(notTake, take);\\n    }\\n\\n    int longestIdealString(string s, int k)\\n    {\\n        int n = s.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(27, -1));\\n        return solve(0, 0, k, n, s, dp);\\n    }\\n\\n    int longestIdealString(string s, int k)\\n    {\\n        int n = s.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(27, 0));\\n\\n        for (int i = n - 1; i >= 0; i--)\\n        {\\n            for (int prev = 0; prev <= 26; prev++)\\n            {\\n                int notPick = dp[i + 1][prev];\\n\\n                int pick = 0;\\n                if (prev == 0 or abs(s[i] - \\'a\\' + 1 - prev) <= k)\\n                    pick = 1 + dp[i + 1][s[i] - \\'a\\' + 1];\\n\\n                dp[i][prev] = max(pick, notPick);\\n            }\\n        }\\n\\n        return dp[0][0];\\n    } \\n\\n    int longestIdealString(string s, int k)\\n    {\\n        int n = s.size();\\n        vector<int> front(27, 0), curr(27, 0);\\n\\n        for (int i = n - 1; i >= 0; i--)\\n        {\\n            for (int prev = 0; prev <= 26; prev++)\\n            {\\n                int notPick = front[prev];\\n\\n                int pick = 0;\\n                if (prev == 0 or abs(s[i] - \\'a\\' + 1 - prev) <= k)\\n                    pick = 1 + front[s[i] - \\'a\\' + 1];\\n\\n                curr[prev] = max(pick, notPick);\\n            }\\n            front = curr;\\n        }\\n\\n        return front[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int ind, int prev, int k, int n, string &s, vector<vector<int>> &dp)\\n    {\\n        if (ind == n)\\n            return 0;\\n\\n        if (dp[ind][prev] != -1)\\n            return dp[ind][prev];\\n\\n        int notTake = 0 + solve(ind + 1, prev, k, n, s, dp);\\n\\n        int take = 0;\\n        if (prev == 0 or abs(s[ind] - \\'a\\' + 1 - prev) <= k)\\n            take = 1 + solve(ind + 1, s[ind] - \\'a\\' + 1, k, n, s, dp);\\n\\n        return dp[ind][prev] = max(notTake, take);\\n    }\\n\\n    int longestIdealString(string s, int k)\\n    {\\n        int n = s.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(27, -1));\\n        return solve(0, 0, k, n, s, dp);\\n    }\\n\\n    int longestIdealString(string s, int k)\\n    {\\n        int n = s.size();\\n        vector<vector<int>> dp(n + 1, vector<int>(27, 0));\\n\\n        for (int i = n - 1; i >= 0; i--)\\n        {\\n            for (int prev = 0; prev <= 26; prev++)\\n            {\\n                int notPick = dp[i + 1][prev];\\n\\n                int pick = 0;\\n                if (prev == 0 or abs(s[i] - \\'a\\' + 1 - prev) <= k)\\n                    pick = 1 + dp[i + 1][s[i] - \\'a\\' + 1];\\n\\n                dp[i][prev] = max(pick, notPick);\\n            }\\n        }\\n\\n        return dp[0][0];\\n    } \\n\\n    int longestIdealString(string s, int k)\\n    {\\n        int n = s.size();\\n        vector<int> front(27, 0), curr(27, 0);\\n\\n        for (int i = n - 1; i >= 0; i--)\\n        {\\n            for (int prev = 0; prev <= 26; prev++)\\n            {\\n                int notPick = front[prev];\\n\\n                int pick = 0;\\n                if (prev == 0 or abs(s[i] - \\'a\\' + 1 - prev) <= k)\\n                    pick = 1 + front[s[i] - \\'a\\' + 1];\\n\\n                curr[prev] = max(pick, notPick);\\n            }\\n            front = curr;\\n        }\\n\\n        return front[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2741222,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        int dp[150] = {}, res = 0;\\n        for (auto& i : s) {\\n            for (int j = i - k; j <= i + k; ++j)\\n                dp[i] = max(dp[i], dp[j]);\\n            res = max(res, ++dp[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        int dp[150] = {}, res = 0;\\n        for (auto& i : s) {\\n            for (int j = i - k; j <= i + k; ++j)\\n                dp[i] = max(dp[i], dp[j]);\\n            res = max(res, ++dp[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2654499,
                "title": "c-fastest-submission",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        vector<vector<int>>dp(s.length(),vector<int>(27,-1));\\n        int idx=0;\\n        char prev=\\'{\\';\\n        return fun(s,idx,prev,k,dp);\\n    }\\n    int fun(string &s,int idx,char prev,int &k,vector<vector<int>>&dp)\\n    {\\n        if(idx>=s.length())\\n        {\\n            return 0;\\n        }\\n        if(dp[idx][prev-\\'a\\']!=-1)\\n        {\\n            return dp[idx][prev-\\'a\\'];\\n        }\\n        if(idx==0 or prev==\\'{\\')\\n        {\\n            return dp[idx][prev-\\'a\\']=max(1+fun(s,idx+1,s[idx],k,dp),fun(s,idx+1,prev,k,dp));\\n        }\\n        if(prev!=\\'{\\' and abs(s[idx]-prev)<=k)\\n        {\\n            return dp[idx][prev-\\'a\\']=max(1+fun(s,idx+1,s[idx],k,dp),fun(s,idx+1,prev,k,dp));\\n        }\\n        if(prev!=\\'{\\' and abs(s[idx]-prev)>k)\\n        {\\n            return dp[idx][prev-\\'a\\']=fun(s,idx+1,prev,k,dp);\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        vector<vector<int>>dp(s.length(),vector<int>(27,-1));\\n        int idx=0;\\n        char prev=\\'{\\';\\n        return fun(s,idx,prev,k,dp);\\n    }\\n    int fun(string &s,int idx,char prev,int &k,vector<vector<int>>&dp)\\n    {\\n        if(idx>=s.length())\\n        {\\n            return 0;\\n        }\\n        if(dp[idx][prev-\\'a\\']!=-1)\\n        {\\n            return dp[idx][prev-\\'a\\'];\\n        }\\n        if(idx==0 or prev==\\'{\\')\\n        {\\n            return dp[idx][prev-\\'a\\']=max(1+fun(s,idx+1,s[idx],k,dp),fun(s,idx+1,prev,k,dp));\\n        }\\n        if(prev!=\\'{\\' and abs(s[idx]-prev)<=k)\\n        {\\n            return dp[idx][prev-\\'a\\']=max(1+fun(s,idx+1,s[idx],k,dp),fun(s,idx+1,prev,k,dp));\\n        }\\n        if(prev!=\\'{\\' and abs(s[idx]-prev)>k)\\n        {\\n            return dp[idx][prev-\\'a\\']=fun(s,idx+1,prev,k,dp);\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2642324,
                "title": "c-modified-lis-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        int n = s.length();\\n        \\n        vector<int> dp(n, 1);\\n\\t\\t// max LIS of a particular character till now\\n        vector<int> prev_max(26, 0);\\n        for(int i = 0; i < n; i++) {\\n            int c = s[i]-\\'a\\';\\n            if(i > 0) {\\n                for(int j = 0; j < 26; j++) {\\n                    if(abs(c-j) <= k)\\n                        dp[i] = max(dp[i], 1 + prev_max[j]);\\n                }\\n            }\\n            prev_max[c] = max(prev_max[c], dp[i]);\\n        }\\n        \\n        return *max_element(dp.begin(), dp.end());\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        int n = s.length();\\n        \\n        vector<int> dp(n, 1);\\n\\t\\t// max LIS of a particular character till now\\n        vector<int> prev_max(26, 0);\\n        for(int i = 0; i < n; i++) {\\n            int c = s[i]-\\'a\\';\\n            if(i > 0) {\\n                for(int j = 0; j < 26; j++) {\\n                    if(abs(c-j) <= k)\\n                        dp[i] = max(dp[i], 1 + prev_max[j]);\\n                }\\n            }\\n            prev_max[c] = max(prev_max[c], dp[i]);\\n        }\\n        \\n        return *max_element(dp.begin(), dp.end());\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2639761,
                "title": "c-fastest-submission-o-1-sc-tabulation-dp",
                "content": "TC: O(N * 26)\\nSC: O(2 * 27) -->~= O(54) ---> ~=O(1) When compared to 10^5\\n```\\nclass Solution {\\npublic:\\n    int longestIdealString(string str, int k) {\\n        int n=str.size();\\n        vector<int>prev(27,0);\\n        vector<int>curr(27,0);\\n        \\n        for(int idx=n-1;idx>=0;idx--){\\n            for(int last=0;last<=26;last++){\\n                int pick=0,notpick=0;\\n                notpick = prev[last];\\n                if(last == 0 || abs(str[idx]-\\'a\\'+1 - last) <= k)\\n                    pick= 1+ prev[str[idx]-\\'a\\'+ 1];\\n                 curr[last] = max(pick , notpick);\\n            }\\n            prev=curr;\\n        }\\n        return prev[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestIdealString(string str, int k) {\\n        int n=str.size();\\n        vector<int>prev(27,0);\\n        vector<int>curr(27,0);\\n        \\n        for(int idx=n-1;idx>=0;idx--){\\n            for(int last=0;last<=26;last++){\\n                int pick=0,notpick=0;\\n                notpick = prev[last];\\n                if(last == 0 || abs(str[idx]-\\'a\\'+1 - last) <= k)\\n                    pick= 1+ prev[str[idx]-\\'a\\'+ 1];\\n                 curr[last] = max(pick , notpick);\\n            }\\n            prev=curr;\\n        }\\n        return prev[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2639741,
                "title": "c-fastest-submission-lcs-approach-tabulation-dp",
                "content": "TC: O(N * 26)\\nSC: O(N * 26)\\n```\\nclass Solution {\\npublic:\\n    int longestIdealString(string str, int k) {\\n        int n=str.size();\\n        vector<vector<int>>dp(n+1,vector<int>(27,0));\\n        \\n        for(int idx=n-1;idx>=0;idx--){\\n            for(int last=0;last<=26;last++){\\n                int pick=0,notpick=0;\\n                notpick = dp[idx+1][last];\\n                if(last == 0 || abs(str[idx]-\\'a\\'+1 - last) <= k)\\n                    pick= 1+ dp[idx+1][str[idx]-\\'a\\'+ 1];\\n                 dp[idx][last] = max(pick , notpick);\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestIdealString(string str, int k) {\\n        int n=str.size();\\n        vector<vector<int>>dp(n+1,vector<int>(27,0));\\n        \\n        for(int idx=n-1;idx>=0;idx--){\\n            for(int last=0;last<=26;last++){\\n                int pick=0,notpick=0;\\n                notpick = dp[idx+1][last];\\n                if(last == 0 || abs(str[idx]-\\'a\\'+1 - last) <= k)\\n                    pick= 1+ dp[idx+1][str[idx]-\\'a\\'+ 1];\\n                 dp[idx][last] = max(pick , notpick);\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2511836,
                "title": "2370-pythn",
                "content": "\\tclass Solution:\\n\\t\\tdef longestIdealString(self, s: str, k: int) -> int:\\n\\t\\t\\tdp = [0]*26\\n\\n\\t\\t\\tfor char in s:\\n\\t\\t\\t\\tidx = ord(char)-ord(\"a\")\\n\\t\\t\\t\\tdp[idx] = max(dp[max(0,idx-k):min(26,idx+k+1)])+1\\n\\n\\t\\t\\treturn max(dp)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef longestIdealString(self, s: str, k: int) -> int:\\n\\t\\t\\tdp = [0]*26\\n\\n\\t\\t\\tfor char in s:\\n\\t\\t\\t\\tidx = ord(char)-ord(\"a\")\\n\\t\\t\\t\\tdp[idx] = max(dp[max(0,idx-k):min(26,idx+k+1)])+1\\n\\n\\t\\t\\treturn max(dp)\\n",
                "codeTag": "Java"
            },
            {
                "id": 2505456,
                "title": "easy-c-solution-recursion-memoization",
                "content": "**UPVOTE IF IT HELPS**\\n```\\nclass Solution {\\npublic:\\n    int lids(int i,int prev,string &s,int k,vector<vector<int>> &dp){\\n        if(i >= s.length()) return 0;\\n        if(dp[i][prev]!=-1) return dp[i][prev];\\n        int take=0;\\n        if(prev==0 || abs(prev - s[i])<=k){\\n            take = 1 + lids(i+1,s[i],s,k,dp);\\n        }\\n        int ntk = 0 + lids(i+1,prev,s,k,dp);\\n        \\n        return dp[i][prev] = max(take,ntk);\\n    }\\n    int longestIdealString(string s, int k) {\\n        int n = s.length();\\n        vector<vector<int>> dp(n+1,vector<int>(150,-1));\\n        return lids(0,0,s,k,dp);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lids(int i,int prev,string &s,int k,vector<vector<int>> &dp){\\n        if(i >= s.length()) return 0;\\n        if(dp[i][prev]!=-1) return dp[i][prev];\\n        int take=0;\\n        if(prev==0 || abs(prev - s[i])<=k){\\n            take = 1 + lids(i+1,s[i],s,k,dp);\\n        }\\n        int ntk = 0 + lids(i+1,prev,s,k,dp);\\n        \\n        return dp[i][prev] = max(take,ntk);\\n    }\\n    int longestIdealString(string s, int k) {\\n        int n = s.length();\\n        vector<vector<int>> dp(n+1,vector<int>(150,-1));\\n        return lids(0,0,s,k,dp);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2491034,
                "title": "100-easy-solution-java",
                "content": "```\\nclass Solution {\\n    public int longestIdealString(String s, int k) {\\n        int n = s.length();\\n        int [] dp = new int[26];\\n        int ans = 0;\\n        for(int i = 0; i < n; i++){\\n            char chi = s.charAt(i);\\n            int lb = Math.max(0, (chi - \\'a\\')- k);\\n            int ub = Math.min(25, (chi - \\'a\\') + k);\\n            int count = 0;\\n            for(int j = lb; j <= ub; j++){\\n                count = Math.max(count, dp[j]);\\n            }\\n            dp[chi - \\'a\\'] = count + 1;\\n            ans = Math.max(ans, dp[chi - \\'a\\']);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestIdealString(String s, int k) {\\n        int n = s.length();\\n        int [] dp = new int[26];\\n        int ans = 0;\\n        for(int i = 0; i < n; i++){\\n            char chi = s.charAt(i);\\n            int lb = Math.max(0, (chi - \\'a\\')- k);\\n            int ub = Math.min(25, (chi - \\'a\\') + k);\\n            int count = 0;\\n            for(int j = lb; j <= ub; j++){\\n                count = Math.max(count, dp[j]);\\n            }\\n            dp[chi - \\'a\\'] = count + 1;\\n            ans = Math.max(ans, dp[chi - \\'a\\']);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489080,
                "title": "python-3-o-n-solution-dp",
                "content": "```\\nclass Solution:\\n    def longestIdealString(self, s: str, k: int) -> int:\\n        \\n        # For storing the largest substring ending at that character \\n        psum=[0]*26\\n        ans=1\\n        for i in range(len(s)):\\n            element=ord(s[i])-97\\n            \\n            # Checking for k characters left to current element i.e. 2 characters left to c will be \\'a\\' and \\'b\\'  \\n            \\n            j=element\\n            while j>-1 and j>=element-k:\\n                psum[element]=max(psum[element],psum[j]+1)\\n                j-=1\\n                \\n            # Checking for k characters right to current element i.e. 2 characters left to c will be \\'d\\' and \\'e\\'     \\n                \\n            j=element+1\\n            while j<26 and j<=element+k:\\n                psum[element]=max(psum[element],psum[j]+1)\\n                j+=1\\n                \\n            ans=max(ans,psum[element])\\n        return ans\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def longestIdealString(self, s: str, k: int) -> int:\\n        \\n        # For storing the largest substring ending at that character \\n        psum=[0]*26\\n        ans=1\\n        for i in range(len(s)):\\n            element=ord(s[i])-97\\n            \\n            # Checking for k characters left to current element i.e. 2 characters left to c will be \\'a\\' and \\'b\\'  \\n            \\n            j=element\\n            while j>-1 and j>=element-k:\\n                psum[element]=max(psum[element],psum[j]+1)\\n                j-=1\\n                \\n            # Checking for k characters right to current element i.e. 2 characters left to c will be \\'d\\' and \\'e\\'     \\n                \\n            j=element+1\\n            while j<26 and j<=element+k:\\n                psum[element]=max(psum[element],psum[j]+1)\\n                j+=1\\n                \\n            ans=max(ans,psum[element])\\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 2484873,
                "title": "c-dp-time-complexity-n-26",
                "content": "```\\n int longestIdealString(string s, int k) {\\n        \\n      int dp[26];\\n        int i;\\n        for(i=0;i<26;i++){\\n            dp[i]=0;\\n        }\\n        int ans=1;\\n        int j;\\n        unordered_map<int,int> mp;\\n        for(i=0;i<s.size();i++){\\n            int c=s[i]-\\'a\\';\\n          if(mp.find(c)!=mp.end()){\\n             \\n              dp[c]=max(dp[c],dp[c]+1);\\n          }\\n            for(j=max(0,c-k);j<=min(25,c+k);j++){\\n                  if(j!=c){\\n                      dp[c]=max(dp[c],dp[j]+1);\\n                  }\\n               \\n            }\\n            if(dp[c]==0){\\n                dp[c]=1;\\n            }\\n            \\n            mp[c]++;\\n          \\n            \\n            ans=max(ans,dp[c]);\\n                     \\n        }\\n        return ans;                        \\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n int longestIdealString(string s, int k) {\\n        \\n      int dp[26];\\n        int i;\\n        for(i=0;i<26;i++){\\n            dp[i]=0;\\n        }\\n        int ans=1;\\n        int j;\\n        unordered_map<int,int> mp;\\n        for(i=0;i<s.size();i++){\\n            int c=s[i]-\\'a\\';\\n          if(mp.find(c)!=mp.end()){\\n             \\n              dp[c]=max(dp[c],dp[c]+1);\\n          }\\n            for(j=max(0,c-k);j<=min(25,c+k);j++){\\n                  if(j!=c){\\n                      dp[c]=max(dp[c],dp[j]+1);\\n                  }\\n               \\n            }\\n            if(dp[c]==0){\\n                dp[c]=1;\\n            }\\n            \\n            mp[c]++;\\n          \\n            \\n            ans=max(ans,dp[c]);\\n                     \\n        }\\n        return ans;                        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2447505,
                "title": "c-dp-o-k-n",
                "content": "DP with each character\\n\\n```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        vector<int> dp(26, 0);\\n        int len = s.length();\\n        for (int i = 0; i < len; ++i) {\\n            char ch = s[i];\\n            int value = dp[ch - \\'a\\'];\\n            for (int j = -k; j <= k; ++j) { \\n                char cur = ch + j;\\n                if (cur - \\'a\\' < 0 || cur - \\'a\\' > 25) {\\n                    continue;\\n                }\\n                if (j == 0) {\\n                    dp[ch - \\'a\\'] = max(value + 1, dp[ch - \\'a\\']);\\n                } else {\\n                    dp[ch - \\'a\\'] = max(dp[ch - \\'a\\'], dp[cur - \\'a\\'] + 1);\\n                }\\n                // cout << cur << \" \" << dp[cur - \\'a\\'] << \" \" << endl;\\n                \\n            }\\n            // cout << dp[ch - \\'a\\'] << endl;\\n        }\\n        int ma = 0;\\n        for (int i = 0; i < 26; ++i) {\\n            ma = max(ma, dp[i]);\\n        }\\n        return ma;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        vector<int> dp(26, 0);\\n        int len = s.length();\\n        for (int i = 0; i < len; ++i) {\\n            char ch = s[i];\\n            int value = dp[ch - \\'a\\'];\\n            for (int j = -k; j <= k; ++j) { \\n                char cur = ch + j;\\n                if (cur - \\'a\\' < 0 || cur - \\'a\\' > 25) {\\n                    continue;\\n                }\\n                if (j == 0) {\\n                    dp[ch - \\'a\\'] = max(value + 1, dp[ch - \\'a\\']);\\n                } else {\\n                    dp[ch - \\'a\\'] = max(dp[ch - \\'a\\'], dp[cur - \\'a\\'] + 1);\\n                }\\n                // cout << cur << \" \" << dp[cur - \\'a\\'] << \" \" << endl;\\n                \\n            }\\n            // cout << dp[ch - \\'a\\'] << endl;\\n        }\\n        int ma = 0;\\n        for (int i = 0; i < 26; ++i) {\\n            ma = max(ma, dp[i]);\\n        }\\n        return ma;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2410804,
                "title": "javascript-c-dp",
                "content": "**JavaScript**\\n```\\nfunction longestIdealString(s, k) {\\n  /**\\n   * dp[i] means max subsequence count for specific alphabet end.\\n   * 0 -> a\\n   * ...\\n   * 25 -> z\\n   */\\n  const dp = Array(26).fill(0)\\n  for (let char of s) {\\n    const i = char.charCodeAt(0) - 97\\n    let minIndex = Math.max(i - k, 0),\\n      maxIndex = Math.min(i + k, 25)\\n    for (let j = minIndex; j <= maxIndex; j++) {\\n      dp[i] = Math.max(dp[j], dp[i])\\n    }\\n    dp[i]++\\n  }\\n  return dp.reduce((maxCount, count) => Math.max(maxCount, count), 0)\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\n    public:\\n        int longestIdealString(string s, int k) {\\n            int dp[26] = {};\\n            int max_count = 0;\\n            for (char & c: s) {\\n                int i = c - \\'a\\';\\n                int min_index = max(i - k, 0);\\n                int max_index = min(i + k, 25);\\n                for (int j = min_index; j <= max_index; ++j) {\\n                    dp[i] = max(dp[i], dp[j]);\\n                }\\n                max_count = max(max_count, ++dp[i]);\\n            }\\n            return max_count;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunction longestIdealString(s, k) {\\n  /**\\n   * dp[i] means max subsequence count for specific alphabet end.\\n   * 0 -> a\\n   * ...\\n   * 25 -> z\\n   */\\n  const dp = Array(26).fill(0)\\n  for (let char of s) {\\n    const i = char.charCodeAt(0) - 97\\n    let minIndex = Math.max(i - k, 0),\\n      maxIndex = Math.min(i + k, 25)\\n    for (let j = minIndex; j <= maxIndex; j++) {\\n      dp[i] = Math.max(dp[j], dp[i])\\n    }\\n    dp[i]++\\n  }\\n  return dp.reduce((maxCount, count) => Math.max(maxCount, count), 0)\\n}\\n```\n```\\nclass Solution {\\n    public:\\n        int longestIdealString(string s, int k) {\\n            int dp[26] = {};\\n            int max_count = 0;\\n            for (char & c: s) {\\n                int i = c - \\'a\\';\\n                int min_index = max(i - k, 0);\\n                int max_index = min(i + k, 25);\\n                for (int j = min_index; j <= max_index; ++j) {\\n                    dp[i] = max(dp[i], dp[j]);\\n                }\\n                max_count = max(max_count, ++dp[i]);\\n            }\\n            return max_count;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401088,
                "title": "c-memoisation-based-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    int dp[100001][26];\\n    int recurs(string& s,int i,int k,char prev)\\n    {\\n        if(i>=s.size())\\n              return 0;\\n        \\n        if(dp[i][prev-\\'a\\']!=-1)\\n              return dp[i][prev-\\'a\\'];\\n        \\n        \\n        int a=0;\\n        if(abs(s[i]-prev)<=k)\\n               a=max(a,recurs(s,i+1,k,s[i])+1);\\n        a=max(a,recurs(s,i+1,k,prev));\\n        return dp[i][prev-\\'a\\']=a;\\n    }\\n    \\n \\n    int longestIdealString(string s, int k) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans=0;\\n        for(int i=0;i<s.size();i++)\\n             ans=max(ans,recurs(s,i+1,k,s[i]));\\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    int dp[100001][26];\\n    int recurs(string& s,int i,int k,char prev)\\n    {\\n        if(i>=s.size())\\n              return 0;\\n        \\n        if(dp[i][prev-\\'a\\']!=-1)\\n              return dp[i][prev-\\'a\\'];\\n        \\n        \\n        int a=0;\\n        if(abs(s[i]-prev)<=k)\\n               a=max(a,recurs(s,i+1,k,s[i])+1);\\n        a=max(a,recurs(s,i+1,k,prev));\\n        return dp[i][prev-\\'a\\']=a;\\n    }\\n    \\n \\n    int longestIdealString(string s, int k) {\\n        memset(dp,-1,sizeof(dp));\\n        int ans=0;\\n        for(int i=0;i<s.size();i++)\\n             ans=max(ans,recurs(s,i+1,k,s[i]));\\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2398688,
                "title": "c-faster-than-100-o-nm-and-a-small-optimization-to-o-nlogm",
                "content": "```cpp\\nconst int MAXN = 1e5 + 5;\\n\\nint dp[27];\\n\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        int N = s.size();\\n        int i, st, ed, v;\\n        memset(dp, 0, sizeof(dp));\\n        for (auto c: s) {\\n            i = c - \\'a\\';\\n            v = 0;\\n            for (st = max(i - k, 0), ed = min(i + k, 25); st <= ed; st ++) {\\n                v = max(v, dp[st] + 1);\\n            }\\n            dp[i] = max(dp[i], v);\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < 26; i ++) {\\n            ans = max(ans, dp[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nThis code is faster than 100%.\\n\\nHowever, the time complexity of this code is O(NM), where N is the length, and M is the size of the alphabet. This works well when the size of alphabet is only 26. If we extend to for example, the ASCII, or even the UTF-8, this code becomes slow.\\n\\nWe can use a **segment tree** to optimize this code into O(N logM). In this case, the memory complexity is still O(M) (because segment tree is O(M)).\\n\\n```cpp\\nconstexpr int MAXN = 1e5 + 5;\\nconstexpr int SIZE_ALPHABET = 30;\\n\\ntemplate<int N>\\nconstexpr int take_size_of_segment_tree(int on) {\\n    return on < N + 2 ? take_size_of_segment_tree<N>(on << 1) : on;\\n}\\n\\nconstexpr int M = take_size_of_segment_tree<26>(1);\\n\\nint seg[SIZE_ALPHABET << 2];\\n\\ninline void build() {\\n    memset(seg, 0, sizeof(seg));\\n}\\n\\ninline void maintain(int x) {\\n    seg[x] = max(seg[x << 1], seg[x << 1 | 1]);\\n}\\n\\ninline void upd(int x, int v) {\\n    x += M;\\n    seg[x] = max(seg[x], v);\\n    for (x >>= 1; x; x >>= 1) {\\n        maintain(x);\\n    }\\n}\\n\\ninline int query(int l, int r) {\\n    static int ret;\\n    for (ret = 0, l += M - 1, r += M + 1; l ^ r ^ 1; l >>= 1, r >>= 1) {\\n        if (~l & 1)\\n            ret = max(ret, seg[l ^ 1]);\\n        if (r & 1)\\n            ret = max(ret, seg[r ^ 1]);\\n    }\\n    return ret;\\n}\\n\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        int N = s.size();\\n        int i, st, ed, v;\\n        build();\\n        for (auto c: s) {\\n            i = c - \\'a\\' + 1;\\n            upd(i, query(max(1, i - k), min(26, i + k)) + 1);\\n        }\\n        return query(1, 26);\\n    }\\n};\\n```\\n\\nThis code is slower than the previous one in this question (because the segment tree has large time constant). However, the influence caused by the size of alphabet on this code is far better.",
                "solutionTags": [
                    "Dynamic Programming",
                    "Tree"
                ],
                "code": "```cpp\\nconst int MAXN = 1e5 + 5;\\n\\nint dp[27];\\n\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        int N = s.size();\\n        int i, st, ed, v;\\n        memset(dp, 0, sizeof(dp));\\n        for (auto c: s) {\\n            i = c - \\'a\\';\\n            v = 0;\\n            for (st = max(i - k, 0), ed = min(i + k, 25); st <= ed; st ++) {\\n                v = max(v, dp[st] + 1);\\n            }\\n            dp[i] = max(dp[i], v);\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < 26; i ++) {\\n            ans = max(ans, dp[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\nconstexpr int MAXN = 1e5 + 5;\\nconstexpr int SIZE_ALPHABET = 30;\\n\\ntemplate<int N>\\nconstexpr int take_size_of_segment_tree(int on) {\\n    return on < N + 2 ? take_size_of_segment_tree<N>(on << 1) : on;\\n}\\n\\nconstexpr int M = take_size_of_segment_tree<26>(1);\\n\\nint seg[SIZE_ALPHABET << 2];\\n\\ninline void build() {\\n    memset(seg, 0, sizeof(seg));\\n}\\n\\ninline void maintain(int x) {\\n    seg[x] = max(seg[x << 1], seg[x << 1 | 1]);\\n}\\n\\ninline void upd(int x, int v) {\\n    x += M;\\n    seg[x] = max(seg[x], v);\\n    for (x >>= 1; x; x >>= 1) {\\n        maintain(x);\\n    }\\n}\\n\\ninline int query(int l, int r) {\\n    static int ret;\\n    for (ret = 0, l += M - 1, r += M + 1; l ^ r ^ 1; l >>= 1, r >>= 1) {\\n        if (~l & 1)\\n            ret = max(ret, seg[l ^ 1]);\\n        if (r & 1)\\n            ret = max(ret, seg[r ^ 1]);\\n    }\\n    return ret;\\n}\\n\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        int N = s.size();\\n        int i, st, ed, v;\\n        build();\\n        for (auto c: s) {\\n            i = c - \\'a\\' + 1;\\n            upd(i, query(max(1, i - k), min(26, i + k)) + 1);\\n        }\\n        return query(1, 26);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2395870,
                "title": "easiest-dp-solution-java-tabulation",
                "content": "```\\nclass Solution {\\n    public int longestIdealString(String s, int k) {\\n        if(s==null || s.length()==0)\\n        {\\n            return 0;\\n        }\\n        int n=s.length();\\n        int dp[]=new int[26];\\n        for(int i=0;i<n;i++)\\n        {\\n            int v=s.charAt(i)-\\'a\\';\\n            int t=dp[v];\\n            for(int c=0;c<26;c++)\\n            {\\n                if(Math.abs(c-v)<=k)\\n                {\\n                    t=Math.max(t,dp[c]+1);\\n                }\\n            }\\n            dp[v]=t;\\n        }\\n        int res=Integer.MIN_VALUE;\\n        for(int i=0;i<dp.length;i++)\\n        {\\n            res=Math.max(res,dp[i]);\\n        }\\n        return res;\\n    }\\n}**\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int longestIdealString(String s, int k) {\\n        if(s==null || s.length()==0)\\n        {\\n            return 0;\\n        }\\n        int n=s.length();\\n        int dp[]=new int[26];\\n        for(int i=0;i<n;i++)\\n        {\\n            int v=s.charAt(i)-\\'a\\';\\n            int t=dp[v];\\n            for(int c=0;c<26;c++)\\n            {\\n                if(Math.abs(c-v)<=k)\\n                {\\n                    t=Math.max(t,dp[c]+1);\\n                }\\n            }\\n            dp[v]=t;\\n        }\\n        int res=Integer.MIN_VALUE;\\n        for(int i=0;i<dp.length;i++)\\n        {\\n            res=Math.max(res,dp[i]);\\n        }\\n        return res;\\n    }\\n}**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2395690,
                "title": "java-dp-solution",
                "content": "Inspired by @lee215 Solution\\n**Explanation**\\ndp is the character array saves the longest length when character c is the end of the longest ideal subsequence.\\n\\nthus character c can be the next character for character` [c-k,c+k]`\\nso `dp[c] = max(dp[c-k],dp[c-k+1],....dp[c+1], dp[c+k])+1;`\\nAnd we should keep the range in `[0,25]`\\nThus the range should be` [max(0,c-k),min(25,c+k)]`\\n\\nthe res is the max value in dp\\n```\\nclass Solution {\\n    public int longestIdealString(String s, int k) {\\n        char[] c = s.toCharArray();\\n        int[] dp = new int[26];\\n        int res = 0;\\n        for(char ch : c){\\n            int ind = ch-\\'a\\';\\n            for(int j=Math.max(0,ind-k); j<=Math.min(25,ind+k); j++){\\n                dp[ind] = Math.max(dp[ind],dp[j]);\\n            }\\n            res = Math.max(res, ++dp[ind]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestIdealString(String s, int k) {\\n        char[] c = s.toCharArray();\\n        int[] dp = new int[26];\\n        int res = 0;\\n        for(char ch : c){\\n            int ind = ch-\\'a\\';\\n            for(int j=Math.max(0,ind-k); j<=Math.min(25,ind+k); j++){\\n                dp[ind] = Math.max(dp[ind],dp[j]);\\n            }\\n            res = Math.max(res, ++dp[ind]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2395657,
                "title": "python-o-n-time-and-o-1-space-dp-beat-100",
                "content": "```\\nfrom string import ascii_lowercase\\n\\nclass Solution:\\n    def longestIdealString(self, s: str, k: int) -> int:\\n        chidx = {c : i for i, c in enumerate(ascii_lowercase)}\\n        dp = [0] * 26\\n        for c in s:\\n            c = chidx[c]\\n            dp[c] = max(dp[max(0, c - k) : min(26, c + k + 1)]) + 1\\n        return max(dp)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom string import ascii_lowercase\\n\\nclass Solution:\\n    def longestIdealString(self, s: str, k: int) -> int:\\n        chidx = {c : i for i, c in enumerate(ascii_lowercase)}\\n        dp = [0] * 26\\n        for c in s:\\n            c = chidx[c]\\n            dp[c] = max(dp[max(0, c - k) : min(26, c + k + 1)]) + 1\\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2394904,
                "title": "python-n-k-log-n-solution",
                "content": "Very slow one but worked for me (after some optimzations) during the contest.\\n\\n**Idea:**\\n\\n1. Convert characters into numbers\\n2. For each number make a list of postions\\n3. Greate a graph with possible move for each numbers knowing that you can move only as far as k in absolute difference\\n4. For current postion and for each possible next move binary search index of the next move\\n5. DP of 4 with the max\\n\\n\\n```python\\nclass Solution:\\n    def longestIdealString(self, s, k):\\n        \"\"\"\\n        :type s: str\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        A = [ord(l) - ord(\\'a\\') for l in s]\\n        N = len(A)\\n        \\n        # unique letter inxeses\\n        s = set(A)\\n        \\n        # indexes of the letter index\\n        hm = defaultdict(list)\\n        for i,a in enumerate(A):\\n            hm[a].append(i)\\n        \\n        # make graph with possible positions for the next move for each letter index\\n        graph = defaultdict(set)\\n        for x in s:\\n            for y in s:\\n                if abs((x - y)) <= k:\\n                    graph[x].add(y)\\n                    graph[y].add(x)\\n        \\n        @cache\\n        def dp(i):\\n            if i == N:\\n                return 0    \\n            \\n            ans = 0\\n            for j in graph[A[i]]:\\n                next_ind = bisect_right(hm[j],i)\\n                if next_ind < len(hm[j]):\\n                    ans = max(ans, 1 + dp(hm[j][next_ind]))\\n            return ans\\n        \\n        ans = 1\\n        for i in range(N):\\n            ans = max(ans, 1 + dp(i))\\n        return ans\\n```\\n\\nTime: `O(N K logN)`\\nSpace: `O(N)`\\n",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def longestIdealString(self, s, k):\\n        \"\"\"\\n        :type s: str\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        A = [ord(l) - ord(\\'a\\') for l in s]\\n        N = len(A)\\n        \\n        # unique letter inxeses\\n        s = set(A)\\n        \\n        # indexes of the letter index\\n        hm = defaultdict(list)\\n        for i,a in enumerate(A):\\n            hm[a].append(i)\\n        \\n        # make graph with possible positions for the next move for each letter index\\n        graph = defaultdict(set)\\n        for x in s:\\n            for y in s:\\n                if abs((x - y)) <= k:\\n                    graph[x].add(y)\\n                    graph[y].add(x)\\n        \\n        @cache\\n        def dp(i):\\n            if i == N:\\n                return 0    \\n            \\n            ans = 0\\n            for j in graph[A[i]]:\\n                next_ind = bisect_right(hm[j],i)\\n                if next_ind < len(hm[j]):\\n                    ans = max(ans, 1 + dp(hm[j][next_ind]))\\n            return ans\\n        \\n        ans = 1\\n        for i in range(N):\\n            ans = max(ans, 1 + dp(i))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2394412,
                "title": "easiest-and-most-concise-solution",
                "content": "class Solution {\\npublic:\\n\\n    int longestIdealString(string s, int k) {\\n        vector<int>hp(26,0);\\n        int x,bg,eg;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            x=0;\\n            bg=s[i]-\\'a\\'-k;\\n            eg=s[i]-\\'a\\'+k;\\n            \\n            if(bg<0)\\n                bg=0;\\n            if(eg>=26)\\n                eg=25;\\n            //cout<<bg<<\\' \\'<<eg<<endl;\\n            for(int j=bg;j<=eg;j++)\\n            {\\n                x=max(hp[j],x);\\n            }\\n            hp[s[i]-\\'a\\']=1+x;\\n        }\\n        int ans=0;\\n        for(int i=0;i<26;i++)\\n            ans=max(ans,hp[i]);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int longestIdealString(string s, int k) {\\n        vector<int>hp(26,0);\\n        int x,bg,eg;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            x=0;\\n            bg=s[i]-\\'a\\'-k;\\n            eg=s[i]-\\'a\\'+k;\\n            \\n            if(bg<0)\\n                bg=0;\\n            if(eg>=26)\\n                eg=25;\\n            //cout<<bg<<\\' \\'<<eg<<endl;\\n            for(int j=bg;j<=eg;j++)\\n            {\\n                x=max(hp[j],x);\\n            }",
                "codeTag": "C++"
            },
            {
                "id": 2394188,
                "title": "dp-tc-o-n-k-similar-to-lis",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k)\\n    {\\n        int n=s.size();\\n        vector<int> a(n,0);\\n        for(int i=0;i<n;i++){\\n            a[i]=s[i]-\\'a\\';\\n        }\\n        \\n        vector<int> dp(n,1);\\n        vector<int> freq(26,-1);\\n        freq[a[0]]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            \\n            for(int j=max(0,a[i]-k);j<=min(25,a[i]+k);j++)\\n            {\\n                if(freq[j]>=0)\\n                {\\n                    dp[i]=max(dp[i],dp[freq[j]]+1);\\n                }\\n            }\\n            freq[a[i]]=i;\\n        }\\n      \\n        return *max_element(dp.begin(),dp.end());\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int longestIdealString(string s, int k)\\n    {\\n        int n=s.size();\\n        vector<int> a(n,0);\\n        for(int i=0;i<n;i++){\\n            a[i]=s[i]-\\'a\\';\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2393250,
                "title": "easy-solution-for-beginners-and-intermediaters-in-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int f(int ind,int prev,string &s,int k,vector<vector<int>>&dp){\\n        if(ind<0)return 0;\\n        if(dp[ind][prev]!=-1)return dp[ind][prev];\\n        int pick=0,notpick=0;\\n        if(prev==0 || abs(s[ind]-prev)<=k) pick=1+f(ind-1,s[ind],s,k,dp);\\n        notpick=f(ind-1,prev,s,k,dp);\\n        return dp[ind][prev]=max(pick,notpick);\\n    }\\n    int longestIdealString(string s, int k) {\\n        int n=s.size();\\n        vector<vector<int>>dp(n+1,vector<int>(150,-1));\\n        return f(n-1,0,s,k,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int ind,int prev,string &s,int k,vector<vector<int>>&dp){\\n        if(ind<0)return 0;\\n        if(dp[ind][prev]!=-1)return dp[ind][prev];\\n        int pick=0,notpick=0;\\n        if(prev==0 || abs(s[ind]-prev)<=k) pick=1+f(ind-1,s[ind],s,k,dp);\\n        notpick=f(ind-1,prev,s,k,dp);\\n        return dp[ind][prev]=max(pick,notpick);\\n    }\\n    int longestIdealString(string s, int k) {\\n        int n=s.size();\\n        vector<vector<int>>dp(n+1,vector<int>(150,-1));\\n        return f(n-1,0,s,k,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2393126,
                "title": "c-solution-lis",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int dp[100005][27];\\n    int find(string&s,int index,char prev,int &k)\\n    {\\n        if(index>=n)\\n        {\\n            return 0;\\n        }\\n        int prev_index=0;\\n        if(prev==\\'#\\')\\n        {\\n            prev_index=26;\\n        }\\n        else\\n        {\\n            prev_index=int(prev-\\'a\\');\\n        }\\n        if(dp[index][prev_index]!=-1)\\n        {\\n            return dp[index][prev_index];\\n        }\\n        int ans=0;\\n        if(prev==\\'#\\'||abs(prev-s[index])<=k)\\n        {\\n            ans=max(ans,1+find(s,index+1,s[index],k));\\n        }\\n        ans=max(ans,find(s,index+1,prev,k));\\n        return dp[index][prev_index]= ans;\\n    }\\n    int longestIdealString(string s, int k) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        n=s.size();\\n        return find(s,0,\\'#\\',k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int dp[100005][27];\\n    int find(string&s,int index,char prev,int &k)\\n    {\\n        if(index>=n)\\n        {\\n            return 0;\\n        }\\n        int prev_index=0;\\n        if(prev==\\'#\\')\\n        {\\n            prev_index=26;\\n        }\\n        else\\n        {\\n            prev_index=int(prev-\\'a\\');\\n        }\\n        if(dp[index][prev_index]!=-1)\\n        {\\n            return dp[index][prev_index];\\n        }\\n        int ans=0;\\n        if(prev==\\'#\\'||abs(prev-s[index])<=k)\\n        {\\n            ans=max(ans,1+find(s,index+1,s[index],k));\\n        }\\n        ans=max(ans,find(s,index+1,prev,k));\\n        return dp[index][prev_index]= ans;\\n    }\\n    int longestIdealString(string s, int k) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        n=s.size();\\n        return find(s,0,\\'#\\',k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2392415,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Recursion && Memoization***\\n\\n* ***Time Complexity :- O(N * 27)***\\n\\n* ***Space Complexity :- O(N * 27)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // declare a dp\\n    \\n    vector<vector<int>> dp;\\n    \\n    int helper(string &str, int i, int n, char last_char, int k)\\n    {\\n        // base case\\n        \\n        if(i == n)\\n        {\\n            return 0;\\n        }\\n        \\n        // if there is no. character in ideal string then take last index as 26\\n        \\n        int last_idx = 26;\\n        \\n        // if there is atleast one character in ideal string\\n        \\n        if(last_char != \\'#\\')\\n        {\\n            last_idx = last_char - \\'a\\';\\n        }\\n        \\n        // if already calculated\\n        \\n        if(dp[i][last_idx] != -1)\\n        {\\n            return dp[i][last_idx];\\n        }\\n        \\n        int maxi = INT_MIN;\\n        \\n        // inclusion part\\n        \\n        // if there is no character included\\n        \\n        if(last_char == \\'#\\')\\n        {\\n            maxi = max(maxi, 1 + helper(str, i + 1, n, str[i], k));\\n        }\\n        \\n        // atleast one character is included\\n        \\n        else\\n        {\\n            if(abs(str[i] - last_char) <= k)\\n            {\\n                maxi = max(maxi, 1 + helper(str, i + 1, n, str[i], k));\\n            }\\n        }  \\n        \\n        // exclusion part\\n        \\n        maxi = max(maxi, helper(str, i + 1, n, last_char, k));\\n        \\n        // store the result and return it\\n        \\n        return dp[i][last_idx] = maxi;\\n    }\\n    \\n    int longestIdealString(string str, int k) {\\n        \\n        int n = str.size();\\n        \\n        // initialize dp\\n        \\n        dp.resize(n + 1);\\n        \\n        dp.assign(n + 1, vector<int> (27, - 1));\\n        \\n        return helper(str, 0, n, \\'#\\', k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // declare a dp\\n    \\n    vector<vector<int>> dp;\\n    \\n    int helper(string &str, int i, int n, char last_char, int k)\\n    {\\n        // base case\\n        \\n        if(i == n)\\n        {\\n            return 0;\\n        }\\n        \\n        // if there is no. character in ideal string then take last index as 26\\n        \\n        int last_idx = 26;\\n        \\n        // if there is atleast one character in ideal string\\n        \\n        if(last_char != \\'#\\')\\n        {\\n            last_idx = last_char - \\'a\\';\\n        }\\n        \\n        // if already calculated\\n        \\n        if(dp[i][last_idx] != -1)\\n        {\\n            return dp[i][last_idx];\\n        }\\n        \\n        int maxi = INT_MIN;\\n        \\n        // inclusion part\\n        \\n        // if there is no character included\\n        \\n        if(last_char == \\'#\\')\\n        {\\n            maxi = max(maxi, 1 + helper(str, i + 1, n, str[i], k));\\n        }\\n        \\n        // atleast one character is included\\n        \\n        else\\n        {\\n            if(abs(str[i] - last_char) <= k)\\n            {\\n                maxi = max(maxi, 1 + helper(str, i + 1, n, str[i], k));\\n            }\\n        }  \\n        \\n        // exclusion part\\n        \\n        maxi = max(maxi, helper(str, i + 1, n, last_char, k));\\n        \\n        // store the result and return it\\n        \\n        return dp[i][last_idx] = maxi;\\n    }\\n    \\n    int longestIdealString(string str, int k) {\\n        \\n        int n = str.size();\\n        \\n        // initialize dp\\n        \\n        dp.resize(n + 1);\\n        \\n        dp.assign(n + 1, vector<int> (27, - 1));\\n        \\n        return helper(str, 0, n, \\'#\\', k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2392116,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def longestIdealString(self, s: str, k: int) -> int:\\n        a=[0]*128\\n        for i in range(len(s)):\\n            j=ord(s[i])\\n            a[j]=max(a[j-k:j+k+1])+1\\n        return max(a)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestIdealString(self, s: str, k: int) -> int:\\n        a=[0]*128\\n        for i in range(len(s)):\\n            j=ord(s[i])\\n            a[j]=max(a[j-k:j+k+1])+1\\n        return max(a)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391867,
                "title": "tle-with-python-but-ac-with-c-why",
                "content": "AC soln in C++\\n```\\nint solve(string &s, int idx, int prev, int k, vector<vector<int>> &dp){\\n    if(idx>s.size())\\n        return 0;\\n    \\n    if(dp[idx][prev]!=-1)\\n        return dp[idx][prev];\\n    \\n    int inc=0; \\n    int notinc=0;\\n    if(prev==0 || abs(s[idx]-prev)<=k)\\n        inc=1+solve(s,idx+1,s[idx],k,dp);\\n    \\n    notinc=solve(s,idx+1,prev,k,dp);\\n    \\n    return dp[idx][prev]=max(inc,notinc);\\n}\\n\\n\\nint longestIdealString(string s, int k) {\\n    int n=s.size();\\n    vector<vector<int>> dp(n+1, vector<int>(150,-1));\\n    \\n    return solve(s,0,0,k,dp);\\n}\\n\\n\\n```\\n\\nTLE with python\\n\\n```\\nclass Solution:\\n    def longestIdealString(self, s: str, k: int) -> int:\\n        memo = {}\\n        \\n        def solve(n, prev):\\n            \\n            if n == 0:\\n                return 0\\n            if (n, prev) in memo:\\n                return memo[(n, prev)]\\n            \\n            take = 0\\n            if prev == None or abs(ord(s[n-1]) - ord(prev)) <= k:\\n                take = solve(n-1, s[n-1]) + 1\\n            \\n            not_take = solve(n-1, prev)\\n            \\n            memo[(n, prev)] = max(take, not_take)\\n            return memo[(n, prev)]\\n        \\n        return solve(len(s), None)\\n\\n```\\n\\nCan anyone please explain why is it so?",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint solve(string &s, int idx, int prev, int k, vector<vector<int>> &dp){\\n    if(idx>s.size())\\n        return 0;\\n    \\n    if(dp[idx][prev]!=-1)\\n        return dp[idx][prev];\\n    \\n    int inc=0; \\n    int notinc=0;\\n    if(prev==0 || abs(s[idx]-prev)<=k)\\n        inc=1+solve(s,idx+1,s[idx],k,dp);\\n    \\n    notinc=solve(s,idx+1,prev,k,dp);\\n    \\n    return dp[idx][prev]=max(inc,notinc);\\n}\\n\\n\\nint longestIdealString(string s, int k) {\\n    int n=s.size();\\n    vector<vector<int>> dp(n+1, vector<int>(150,-1));\\n    \\n    return solve(s,0,0,k,dp);\\n}\\n\\n\\n```\n```\\nclass Solution:\\n    def longestIdealString(self, s: str, k: int) -> int:\\n        memo = {}\\n        \\n        def solve(n, prev):\\n            \\n            if n == 0:\\n                return 0\\n            if (n, prev) in memo:\\n                return memo[(n, prev)]\\n            \\n            take = 0\\n            if prev == None or abs(ord(s[n-1]) - ord(prev)) <= k:\\n                take = solve(n-1, s[n-1]) + 1\\n            \\n            not_take = solve(n-1, prev)\\n            \\n            memo[(n, prev)] = max(take, not_take)\\n            return memo[(n, prev)]\\n        \\n        return solve(len(s), None)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391684,
                "title": "simple-c-top-down-dp",
                "content": "**Code** :\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int dp[100002][27];\\n    \\n    int f(string &s,char prev,int n,int k){\\n        if(n==0){\\n            if(prev==\\'{\\') return 1;\\n            \\n            if(abs(prev-s[0])<=k) return 1;\\n            return 0;\\n        }\\n        \\n        int &ans=dp[n][prev-\\'a\\'];\\n        if(ans!=-1) return ans;\\n        \\n        if(prev==\\'{\\' or abs(prev-s[n])<=k) return ans=max(1+f(s,s[n],n-1,k),f(s,prev,n-1,k));\\n        else return ans=f(s,prev,n-1,k);\\n    }\\n    \\n    int longestIdealString(string s, int k) {\\n        int n=s.size();\\n        memset(dp,-1,sizeof(dp));\\n        return f(s,\\'{\\',n-1,k);\\n    }\\n};\\n```\\n\\nTime Complexity : **0(n * 27)**   [27 --> 26 alphabet character + \\'{\\' for marking no previous element]\\nSpace Complexity : **0(n * 27)**\\n\\nHope this helps :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[100002][27];\\n    \\n    int f(string &s,char prev,int n,int k){\\n        if(n==0){\\n            if(prev==\\'{\\') return 1;\\n            \\n            if(abs(prev-s[0])<=k) return 1;\\n            return 0;\\n        }\\n        \\n        int &ans=dp[n][prev-\\'a\\'];\\n        if(ans!=-1) return ans;\\n        \\n        if(prev==\\'{\\' or abs(prev-s[n])<=k) return ans=max(1+f(s,s[n],n-1,k),f(s,prev,n-1,k));\\n        else return ans=f(s,prev,n-1,k);\\n    }\\n    \\n    int longestIdealString(string s, int k) {\\n        int n=s.size();\\n        memset(dp,-1,sizeof(dp));\\n        return f(s,\\'{\\',n-1,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391648,
                "title": "java-recursion-with-memoization",
                "content": "```\\nclass Solution {\\n    public int longestIdealString(String s, int k) {\\n        Integer[][] memo = new Integer[s.length()+1][27];\\n        return find(s, 1, 0, k, memo);\\n    }\\n    \\n    private int find(String s, int idx, int prev, int k, Integer memo[][]) {\\n        if(idx-1==s.length()) return 0;\\n        \\n        if(memo[idx][prev]!=null) return memo[idx][prev];\\n        \\n        int res = 0;\\n        if(prev==0 || Math.abs(s.charAt(idx-1) -\\'a\\' - prev+1) <=k) {\\n            res = 1 + find(s, idx+1, s.charAt(idx-1)-\\'a\\'+1, k, memo);\\n        } \\n        res = Math.max(res, find(s, idx+1, prev, k, memo));\\n        memo[idx][prev] = res;\\n        \\n        return memo[idx][prev];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int longestIdealString(String s, int k) {\\n        Integer[][] memo = new Integer[s.length()+1][27];\\n        return find(s, 1, 0, k, memo);\\n    }\\n    \\n    private int find(String s, int idx, int prev, int k, Integer memo[][]) {\\n        if(idx-1==s.length()) return 0;\\n        \\n        if(memo[idx][prev]!=null) return memo[idx][prev];\\n        \\n        int res = 0;\\n        if(prev==0 || Math.abs(s.charAt(idx-1) -\\'a\\' - prev+1) <=k) {\\n            res = 1 + find(s, idx+1, s.charAt(idx-1)-\\'a\\'+1, k, memo);\\n        } \\n        res = Math.max(res, find(s, idx+1, prev, k, memo));\\n        memo[idx][prev] = res;\\n        \\n        return memo[idx][prev];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391315,
                "title": "c-dp-memoization-recursion-easy",
                "content": "Idea\\nIntuitive\\nsimilar to Longest Increasing Subsequence: using dp[i] store ending with s[i], longest length.\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    \\n    int solve(string &s, int idx, int prev, int k, vector<vector<int>> &dp){\\n        if(idx>s.size())\\n            return 0;\\n        \\n        if(dp[idx][prev]!=-1)\\n            return dp[idx][prev];\\n        \\n        int inc=0; \\n        int notinc=0;\\n        if(prev==0 || abs(s[idx]-prev)<=k)\\n            inc=1+solve(s,idx+1,s[idx],k,dp);\\n        \\n        notinc=solve(s,idx+1,prev,k,dp);\\n        \\n        return dp[idx][prev]=max(inc,notinc);\\n    }\\n    \\n    \\n    int longestIdealString(string s, int k) {\\n        int n=s.size();\\n        vector<vector<int>> dp(n+1, vector<int>(150,-1));\\n        \\n        return solve(s,0,0,k,dp);\\n    }\\n};\\n\\nif u like , **UPVOTE** IT",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int solve(string &s, int idx, int prev, int k, vector<vector<int>> &dp){\\n        if(idx>s.size())\\n            return 0;\\n        \\n        if(dp[idx][prev]!=-1)\\n            return dp[idx][prev];\\n        \\n        int inc=0; \\n        int notinc=0;\\n        if(prev==0 || abs(s[idx]-prev)<=k)\\n            inc=1+solve(s,idx+1,s[idx],k,dp);\\n        \\n        notinc=solve(s,idx+1,prev,k,dp);\\n        \\n        return dp[idx][prev]=max(inc,notinc);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2391311,
                "title": "python-top-down-memoization-mle",
                "content": "```\\nclass Solution:\\n    def longestIdealString(self, s: str, k: int) -> int:        \\n        @cache\\n        def dfs(cur, prev):\\n            if cur == len(s):\\n                return 0\\n            val = dfs(cur + 1, prev)\\n            if prev is None or abs(ord(s[cur]) - ord(s[prev])) <= k:\\n                val = max(val, 1 + dfs(cur + 1, cur))\\n            return val\\n        return dfs(0, None)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestIdealString(self, s: str, k: int) -> int:        \\n        @cache\\n        def dfs(cur, prev):\\n            if cur == len(s):\\n                return 0\\n            val = dfs(cur + 1, prev)\\n            if prev is None or abs(ord(s[cur]) - ord(s[prev])) <= k:\\n                val = max(val, 1 + dfs(cur + 1, cur))\\n            return val\\n        return dfs(0, None)",
                "codeTag": "Java"
            },
            {
                "id": 2391259,
                "title": "same-code-but-tle-during-contest",
                "content": "![image](https://assets.leetcode.com/users/images/bb0776e4-0550-4e65-ac3e-8b7e0243d88d_1659850658.399882.png)\\n\\nI don\\'t know why my code was TLE during the contest and AC after the contest.\\n\\nI had to switch to c++ to pass this and it cost me more time and 1 penalty.\\n\\nI wish Leetcode will solve this issue.\\n",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/bb0776e4-0550-4e65-ac3e-8b7e0243d88d_1659850658.399882.png)\\n\\nI don\\'t know why my code was TLE during the contest and AC after the contest.\\n\\nI had to switch to c++ to pass this and it cost me more time and 1 penalty.\\n\\nI wish Leetcode will solve this issue.\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2391235,
                "title": "c-iterative-dp-o-26-extra-space",
                "content": "**PLEASE UPVOTE IF U FIND MY SOLUTION HELPFUL :)**\\n\\n```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) \\n    {\\n        int n=s.length();\\n        int dp[26]={0};\\n        dp[s[0]-\\'a\\']=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            int temp=1;\\n            for(int j=max(0,s[i]-\\'a\\'-k);j<min(s[i]-\\'a\\'+k+1,26);j++)\\n            {\\n                temp=max(temp,1+dp[j]);\\n            }\\n            dp[s[i]-\\'a\\']=temp;\\n        }\\n        \\n        int res=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            res=max(res,dp[i]);\\n        }\\n            \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) \\n    {\\n        int n=s.length();\\n        int dp[26]={0};\\n        dp[s[0]-\\'a\\']=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            int temp=1;\\n            for(int j=max(0,s[i]-\\'a\\'-k);j<min(s[i]-\\'a\\'+k+1,26);j++)\\n            {\\n                temp=max(temp,1+dp[j]);\\n            }\\n            dp[s[i]-\\'a\\']=temp;\\n        }\\n        \\n        int res=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            res=max(res,dp[i]);\\n        }\\n            \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391191,
                "title": "c-dp-o-n-easy-to-understand",
                "content": "if s[i] == \\'c\\' and k = 2, the previous character of the sequence ending at s[i] could be\\n\\t\\t- \\'c\\'-2 = \\'a\\'\\n\\t\\t- \\'c\\'-1 = \\'b\\'\\n\\t\\t- \\'c\\'-0 = \\'c\\'\\n\\t\\t- \\'c\\'+1 = \\'d\\'\\n\\t\\t- \\'c\\'+2 = \\'e\\'\\n so longest ideal sequence ending at s[i]=\\'c\\' is 1 + max of longest ideal sequence before i that ends in either \\'a\\', \\'b\\', \\'c\\' , \\'d\\' or \\'e\\'.\\n\\n```\\nint longestIdealString(string s, int k) {\\n\\tint n = s.size();\\n\\tunordered_map<char, int> lg;\\n\\tlg.insert({s[0], 1});\\n\\tint res = 1;\\n\\n\\tfor(int i=1;i<n;i++){\\n\\t\\tint cur = 1;\\n\\t\\tfor(int j=-k;j<=k;j++){ // absolute difference at most k\\n\\t\\t\\tchar t = s[i]+j;\\n\\t\\t\\tif(lg.find(t) != lg.end()){\\n\\t\\t\\t\\tcur = max(cur, lg[t]+1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tlg[s[i]] = cur; // Longest ideal sequence ending at s[i]\\n\\t\\tres = max(res, lg[s[i]]);\\n\\t}\\n\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nint longestIdealString(string s, int k) {\\n\\tint n = s.size();\\n\\tunordered_map<char, int> lg;\\n\\tlg.insert({s[0], 1});\\n\\tint res = 1;\\n\\n\\tfor(int i=1;i<n;i++){\\n\\t\\tint cur = 1;\\n\\t\\tfor(int j=-k;j<=k;j++){ // absolute difference at most k\\n\\t\\t\\tchar t = s[i]+j;\\n\\t\\t\\tif(lg.find(t) != lg.end()){\\n\\t\\t\\t\\tcur = max(cur, lg[t]+1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tlg[s[i]] = cur; // Longest ideal sequence ending at s[i]\\n\\t\\tres = max(res, lg[s[i]]);\\n\\t}\\n\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2391090,
                "title": "c-solution-time-o-n-k-memory-o-n-easy-to-understand-using-dictionary",
                "content": "```C#\\npublic class Solution {\\n    public int LongestIdealString(string s, int k) {\\n        Dictionary<char, int> d = new ();\\n        \\n        int max = 0;\\n        for (int i = 0; i < s.Length; i++) {\\n            int longest = 0;\\n            for (int j = 0; j <= k; j++) {\\n                char preceding = (char)(s[i] - j), succeeding = (char)(s[i] + j);\\n                if (d.ContainsKey(preceding)) longest = Math.Max(longest, d[preceding]);\\n                if (d.ContainsKey(succeeding)) longest = Math.Max(longest, d[succeeding]);\\n            }\\n            \\n            int current = longest + 1;\\n            d[s[i]] = current;\\n            max = Math.Max(max, current);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```C#\\npublic class Solution {\\n    public int LongestIdealString(string s, int k) {\\n        Dictionary<char, int> d = new ();\\n        \\n        int max = 0;\\n        for (int i = 0; i < s.Length; i++) {\\n            int longest = 0;\\n            for (int j = 0; j <= k; j++) {\\n                char preceding = (char)(s[i] - j), succeeding = (char)(s[i] + j);\\n                if (d.ContainsKey(preceding)) longest = Math.Max(longest, d[preceding]);\\n                if (d.ContainsKey(succeeding)) longest = Math.Max(longest, d[succeeding]);\\n            }\\n            \\n            int current = longest + 1;\\n            d[s[i]] = current;\\n            max = Math.Max(max, current);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391070,
                "title": "c-hash-map-soln-o-n-k-solution",
                "content": "C++  || Easy to understand || using map\\n```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        int n= s.size();\\n        \\n         unordered_map<char,int>mp;\\n        \\n        int ans=1;\\n        \\n        mp[s[0]]=1;\\n        \\n        for (int i=1; i<n; i++)\\n        {\\n            int temp=1;\\n            for (int j=0; j<=k; j++)\\n            {\\n                if (s[i]-j>=\\'a\\' && mp.find(s[i]-j)!= mp.end())\\n                {\\n                    if (temp< mp[s[i]-j]+1)\\n                    {\\n                        temp= mp[s[i]-j]+1;\\n                    } \\n                }\\n                if (s[i]+j<=\\'z\\' && mp.find(s[i]+j)!= mp.end())\\n                {\\n                    if (temp< mp[s[i]+j]+1)\\n                    {\\n                        temp= mp[s[i]+j]+1;\\n                    }\\n                }\\n                \\n            }\\n            mp[s[i]]=temp;\\n            ans= max(ans, temp);\\n        }\\n         \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        int n= s.size();\\n        \\n         unordered_map<char,int>mp;\\n        \\n        int ans=1;\\n        \\n        mp[s[0]]=1;\\n        \\n        for (int i=1; i<n; i++)\\n        {\\n            int temp=1;\\n            for (int j=0; j<=k; j++)\\n            {\\n                if (s[i]-j>=\\'a\\' && mp.find(s[i]-j)!= mp.end())\\n                {\\n                    if (temp< mp[s[i]-j]+1)\\n                    {\\n                        temp= mp[s[i]-j]+1;\\n                    } \\n                }\\n                if (s[i]+j<=\\'z\\' && mp.find(s[i]+j)!= mp.end())\\n                {\\n                    if (temp< mp[s[i]+j]+1)\\n                    {\\n                        temp= mp[s[i]+j]+1;\\n                    }\\n                }\\n                \\n            }\\n            mp[s[i]]=temp;\\n            ans= max(ans, temp);\\n        }\\n         \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391024,
                "title": "can-anyone-tell-me-why-it-failed-most-cases-although-my-code-logic-is-correct",
                "content": "Please have a look and it will be really helpful if you can point out the mistakes where it failed.\\n```\\n\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    vector<vector<int>> dp;\\n    int helper(int i, int l, char a, string &s, int k){\\n        if(i == s.size()){\\n            ans = max(ans, l);\\n            return l;\\n        }\\n        if(l != 0){\\n            if(dp[i][a-\\'a\\'] != -1){\\n                return dp[i][a-\\'a\\'];\\n            }\\n\\n        }\\n        else{\\n            if(dp[i][26] != -1){\\n                return dp[i][26];\\n            }\\n        }\\n        \\n        int c = 0;\\n        if(l == 0 || (abs(s[i]-a)<=k)){\\n            c = helper(i+1, l+1, s[i], s, k);\\n        }\\n        int b =helper(i+1, l, a, s, k);\\n        if(l != 0 ){\\n            dp[i][a-\\'a\\'] = max(b, c);\\n            return dp[i][a-\\'a\\'];\\n        }\\n        else{\\n            dp[i][26] = max(b, c);\\n            return dp[i][26];\\n        }\\n        return 0;\\n\\n    }\\n    int longestIdealString(string s, int k) {\\n        int n = s.size();\\n        dp.resize(n+1, vector<int>(27, -1));\\n        int a = helper(0, 0, \\'a\\', s, k);\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    vector<vector<int>> dp;\\n    int helper(int i, int l, char a, string &s, int k){\\n        if(i == s.size()){\\n            ans = max(ans, l);\\n            return l;\\n        }\\n        if(l != 0){\\n            if(dp[i][a-\\'a\\'] != -1){\\n                return dp[i][a-\\'a\\'];\\n            }\\n\\n        }\\n        else{\\n            if(dp[i][26] != -1){\\n                return dp[i][26];\\n            }\\n        }\\n        \\n        int c = 0;\\n        if(l == 0 || (abs(s[i]-a)<=k)){\\n            c = helper(i+1, l+1, s[i], s, k);\\n        }\\n        int b =helper(i+1, l, a, s, k);\\n        if(l != 0 ){\\n            dp[i][a-\\'a\\'] = max(b, c);\\n            return dp[i][a-\\'a\\'];\\n        }\\n        else{\\n            dp[i][26] = max(b, c);\\n            return dp[i][26];\\n        }\\n        return 0;\\n\\n    }\\n    int longestIdealString(string s, int k) {\\n        int n = s.size();\\n        dp.resize(n+1, vector<int>(27, -1));\\n        int a = helper(0, 0, \\'a\\', s, k);\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390884,
                "title": "c-similar-to-lcs",
                "content": "```\\nclass Solution {\\nprivate:\\n    int f(int i, int prev, string &s, int &n, int &k, vector<vector<int>> &dp)\\n    {\\n        if(i == n) return 0;\\n        \\n        if(dp[i][prev] != -1)\\n            return dp[i][prev];\\n        \\n        // move to next index, if we are not picking\\n        int notPick = f(i+1, prev, s, n, k, dp);\\n        \\n        int pick = 0;\\n        \\n        // if prev val is 0 or\\n        // absolute difference of prev and cur is less than or equal to k, then pick current idx\\n        if(prev == 0 || abs(prev - (s[i] - \\'a\\' + 1)) <= k)\\n            pick = 1 + f(i+1, s[i] - \\'a\\' + 1, s, n, k, dp);\\n        \\n        // find max\\n        return dp[i][prev] = max(pick, notPick);\\n    }\\n    \\npublic:\\n    int longestIdealString(string s, int k) {\\n        \\n        int n = s.size();\\n        \\n        vector<vector<int>> dp(n+1, vector<int>(27, -1));\\n\\n        \\n        return f(0, 0, s, n, k, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int f(int i, int prev, string &s, int &n, int &k, vector<vector<int>> &dp)\\n    {\\n        if(i == n) return 0;\\n        \\n        if(dp[i][prev] != -1)\\n            return dp[i][prev];\\n        \\n        // move to next index, if we are not picking\\n        int notPick = f(i+1, prev, s, n, k, dp);\\n        \\n        int pick = 0;\\n        \\n        // if prev val is 0 or\\n        // absolute difference of prev and cur is less than or equal to k, then pick current idx\\n        if(prev == 0 || abs(prev - (s[i] - \\'a\\' + 1)) <= k)\\n            pick = 1 + f(i+1, s[i] - \\'a\\' + 1, s, n, k, dp);\\n        \\n        // find max\\n        return dp[i][prev] = max(pick, notPick);\\n    }\\n    \\npublic:\\n    int longestIdealString(string s, int k) {\\n        \\n        int n = s.size();\\n        \\n        vector<vector<int>> dp(n+1, vector<int>(27, -1));\\n\\n        \\n        return f(0, 0, s, n, k, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390883,
                "title": "c-dp-with-o-26-space-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        vector<int> v(26,0);\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int x=s[i]-\\'a\\';\\n            int t=1;\\n            for(int j=0;j<=k;j++)\\n            {\\n                if(j+x<26)\\n                    t=max(t,1+v[j+x]);\\n                if(x-j>=0)\\n                    t=max(t,1+v[x-j]);\\n            }\\n            v[x]=t;\\n        }\\n        return *max_element(v.begin(),v.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        vector<int> v(26,0);\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int x=s[i]-\\'a\\';\\n            int t=1;\\n            for(int j=0;j<=k;j++)\\n            {\\n                if(j+x<26)\\n                    t=max(t,1+v[j+x]);\\n                if(x-j>=0)\\n                    t=max(t,1+v[x-j]);\\n            }\\n            v[x]=t;\\n        }\\n        return *max_element(v.begin(),v.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390828,
                "title": "recursion-memoization",
                "content": "```\\nint f(int idx,string &s, int k, int prev,vector<vector<int>>&dp){\\n        if(idx==s.size()) return 0;\\n        if(dp[idx][prev]!=-1) return dp[idx][prev];\\n        int pick =0, no_pick=0;\\n        if(prev==0){\\n            pick = 1+f(idx+1,s,k,(int)s[idx],dp);\\n            no_pick = f(idx+1,s,k,prev,dp);\\n        }\\n        else{\\n            int temp = (int)s[idx];\\n            if(abs(temp-prev)<=k){\\n                pick = 1+f(idx+1,s,k,temp,dp);\\n            }\\n            no_pick = f(idx+1,s,k,prev,dp);\\n        }\\n        \\n        return dp[idx][prev]=max(pick,no_pick);\\n    }\\n    int longestIdealString(string s, int k) {\\n        int prev=0;\\n        vector<vector<int>>dp(s.size()+2,vector<int>(258,-1));\\n        return f(0,s,k,prev,dp);\\n    }",
                "solutionTags": [],
                "code": "```\\nint f(int idx,string &s, int k, int prev,vector<vector<int>>&dp){\\n        if(idx==s.size()) return 0;\\n        if(dp[idx][prev]!=-1) return dp[idx][prev];\\n        int pick =0, no_pick=0;\\n        if(prev==0){\\n            pick = 1+f(idx+1,s,k,(int)s[idx],dp);\\n            no_pick = f(idx+1,s,k,prev,dp);\\n        }\\n        else{\\n            int temp = (int)s[idx];\\n            if(abs(temp-prev)<=k){\\n                pick = 1+f(idx+1,s,k,temp,dp);\\n            }\\n            no_pick = f(idx+1,s,k,prev,dp);\\n        }\\n        \\n        return dp[idx][prev]=max(pick,no_pick);\\n    }\\n    int longestIdealString(string s, int k) {\\n        int prev=0;\\n        vector<vector<int>>dp(s.size()+2,vector<int>(258,-1));\\n        return f(0,s,k,prev,dp);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2390815,
                "title": "easy-solution-single-iteration-o-n-dp-lis-o-n-2",
                "content": "**`Please upvote if you like the solution`**\\n\\nYou can solve this question using multiple approaches. I\\'ll be discussing 2 approaches here\\n- LIS (Longest Increasing Subsequence) - `O(N^2)`\\n- Single iteration - `O(N)`\\n\\n**LIS(Longest Increasing Subsequence): `O(N^2)`**\\n\\nExplanation: The only difference with respect to LIS is: In LIS, we see if the current index is greater than already iterated values than we add it. Here, we see if the current index is in `k` range with the previously iterated indexes. \\n\\n```\\npublic int longestIdealString(String s, int k) {\\n        int n = s.length(), maxIdeal = 0;\\n        int lis[] = new int[n];\\n        \\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<n; j++) {\\n\\t\\t\\t\\t// The only diff is the below condition\\n                if(Math.abs(s.charAt(i)-s.charAt(j)) <= k)\\n                    lis[i] = Math.max(lis[i], lis[j]+1);\\n            }\\n            maxIdeal = Math.max(maxIdeal, lis[i]);\\n        }\\n        return maxIdeal; \\n    }\\n```\\n\\n**Single Iteration: `O(N)`**\\n\\nFact: We can see here that only lowercase chars are allowed i.e.; a-z which is basically 26 in total. We can use this fact to make the inner loop of LIS run at-max 26 times which will make the solution to be O(N\\\\*26) ~ O(N)\\n\\nExplanation: While iterating from left to right, we can see that for current char `ch` we can consider it only if there is a character within a range `k` to the left of it. \\nSo in the inner loop, we basically search from `ch-k` to `ch+k` i.e.; for `f` and `k=2` we\\'ll search from `\\'f\\'-2 = d` to `\\'f\\'+2 = h` and take the longest subsequence already present and add it to that. \\n\\n```\\npublic int longestIdealString(String s, int k) {\\n        int n = s.length(), maxIdeal = 0;\\n        int value[] = new int[26];\\n        \\n        for(char ch: s.toCharArray()) {\\n            int max = 0;\\n            for(int i=Math.max(0, ch-\\'a\\'-k); i<Math.min(26, ch-\\'a\\'+k); i++)\\n                max = Math.max(max, value[i]);\\n            value[ch-\\'a\\'] = max+1;\\n            maxIdeal = Math.max(maxIdeal, value[ch-\\'a\\']);\\n        }\\n        \\n        return maxIdeal;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic int longestIdealString(String s, int k) {\\n        int n = s.length(), maxIdeal = 0;\\n        int lis[] = new int[n];\\n        \\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<n; j++) {\\n\\t\\t\\t\\t// The only diff is the below condition\\n                if(Math.abs(s.charAt(i)-s.charAt(j)) <= k)\\n                    lis[i] = Math.max(lis[i], lis[j]+1);\\n            }\\n            maxIdeal = Math.max(maxIdeal, lis[i]);\\n        }\\n        return maxIdeal; \\n    }\\n```\n```\\npublic int longestIdealString(String s, int k) {\\n        int n = s.length(), maxIdeal = 0;\\n        int value[] = new int[26];\\n        \\n        for(char ch: s.toCharArray()) {\\n            int max = 0;\\n            for(int i=Math.max(0, ch-\\'a\\'-k); i<Math.min(26, ch-\\'a\\'+k); i++)\\n                max = Math.max(max, value[i]);\\n            value[ch-\\'a\\'] = max+1;\\n            maxIdeal = Math.max(maxIdeal, value[ch-\\'a\\']);\\n        }\\n        \\n        return maxIdeal;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2390803,
                "title": "beginner-friendly-c-solution",
                "content": "use hash map to store longest subsequence till that index.\\n```\\n int longestIdealString(string s, int k) {\\n       unordered_map<char,int> mp;\\n        mp[s[0]]=1;     \\n        for(int i=1;i<s.size();i++){\\n            int x=1;\\n           for(auto j:mp){\\n               if(abs(j.first-s[i])<=k) {\\n                  if(j.second+1>x) x=j.second+1; \\n               }\\n           }\\n            mp[s[i]]=x;  // will store longest subsequence till that index whose last character is s[i].\\n        }\\n        int ans=0;\\n        for(auto i:mp){\\n            if(i.second>ans) ans=i.second;\\n        }\\n        return ans;\\n    }\\n```\\nmp[s[0]] and x are initialize with 1 becuase minium length subsequence formed will be always a character itself.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n int longestIdealString(string s, int k) {\\n       unordered_map<char,int> mp;\\n        mp[s[0]]=1;     \\n        for(int i=1;i<s.size();i++){\\n            int x=1;\\n           for(auto j:mp){\\n               if(abs(j.first-s[i])<=k) {\\n                  if(j.second+1>x) x=j.second+1; \\n               }\\n           }\\n            mp[s[i]]=x;  // will store longest subsequence till that index whose last character is s[i].\\n        }\\n        int ans=0;\\n        for(auto i:mp){\\n            if(i.second>ans) ans=i.second;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2390705,
                "title": "1d-dp-and-hash-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        int n=s.size();\\n        vector<int>lis(n,1);\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=k;j++){\\n                if(mp.find(s[i]+j)!=mp.end()) lis[i]=max(lis[i],1+mp[s[i]+j]);\\n                \\n                if(mp.find(abs(s[i]-j))!=mp.end()) lis[i]=max(lis[i],1+mp[abs(s[i]-j)]);\\n            }\\n            mp[s[i]]=max(mp[s[i]],lis[i]);\\n        }\\n        return *max_element(lis.begin(),lis.end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        int n=s.size();\\n        vector<int>lis(n,1);\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<=k;j++){\\n                if(mp.find(s[i]+j)!=mp.end()) lis[i]=max(lis[i],1+mp[s[i]+j]);\\n                \\n                if(mp.find(abs(s[i]-j))!=mp.end()) lis[i]=max(lis[i],1+mp[abs(s[i]-j)]);\\n            }\\n            mp[s[i]]=max(mp[s[i]],lis[i]);\\n        }\\n        return *max_element(lis.begin(),lis.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390640,
                "title": "dp-top-down-tle",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp(string &s,int &k,int in,vector<int> &v)\\n    {\\n        if(v[in]!=-1){return v[in];}\\n        int m=0;\\n        for(int i=in+1;i<s.size();i++)\\n        {\\n            if(abs(s[in]-s[i])>k){continue;}\\n            m=max(m,dp(s,k,i,v)+1);\\n        }\\n        return v[in]=m;\\n        \\n    }\\n    int longestIdealString(string s, int k) {\\n        int n=s.size();\\n        vector<int> v(n,-1);\\n        int m=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            m=max(m,dp(s,k,i,v));\\n        }\\n        return m+1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp(string &s,int &k,int in,vector<int> &v)\\n    {\\n        if(v[in]!=-1){return v[in];}\\n        int m=0;\\n        for(int i=in+1;i<s.size();i++)\\n        {\\n            if(abs(s[in]-s[i])>k){continue;}\\n            m=max(m,dp(s,k,i,v)+1);\\n        }\\n        return v[in]=m;\\n        \\n    }\\n    int longestIdealString(string s, int k) {\\n        int n=s.size();\\n        vector<int> v(n,-1);\\n        int m=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            m=max(m,dp(s,k,i,v));\\n        }\\n        return m+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390622,
                "title": "c-dp",
                "content": "```\\n    public int LongestIdealString(string s, int k) \\n    {\\n        int n = s.Length;\\n        int[] dp = new int[26];\\n        for (int i = 0; i < n; i++)\\n        {\\n            int curr = s[i] - \\'a\\';\\n            int currMax = 0;\\n            for (int j = Math.Max(0 , curr-k); j <= Math.Min(25, curr + k); j++)\\n            {\\n                currMax = Math.Max(currMax, dp[j]);\\n            }\\n            dp[curr] = currMax + 1;\\n        }\\n        return dp.Max();\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n    public int LongestIdealString(string s, int k) \\n    {\\n        int n = s.Length;\\n        int[] dp = new int[26];\\n        for (int i = 0; i < n; i++)\\n        {\\n            int curr = s[i] - \\'a\\';\\n            int currMax = 0;\\n            for (int j = Math.Max(0 , curr-k); j <= Math.Min(25, curr + k); j++)\\n            {\\n                currMax = Math.Max(currMax, dp[j]);\\n            }\\n            dp[curr] = currMax + 1;\\n        }\\n        return dp.Max();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2390607,
                "title": "c-simple-solution-less-code",
                "content": "class Solution {\\npublic:\\n    \\n    \\n    \\nint longest_subseq(int n, int k, string s)\\n{\\n\\n    vector<int> dp(n, 0);\\n    int max_length[26] = {0};\\n \\n    for (int i = 0; i < n; i++)\\n    {\\n        int curr = s[i] - \\'a\\';\\n        int lower = max(0, curr - k);\\n        int upper = min(25, curr + k);\\n        for (int j = lower; j < upper + 1; j++)\\n        {\\n            dp[i] = max(dp[i], max_length[j] + 1);\\n        }\\n        max_length[curr] = max(dp[i], max_length[curr]);\\n    }\\n \\n    int ans = 0;\\n    for(int i:dp) ans = max(i, ans);\\n    return ans;\\n}\\n    \\n    \\n    \\n    int longestIdealString(string s, int k) {\\n        \\n        int n=s.size();\\n//         vector<int>dist(n,1);\\n//         int count=0;\\n        \\n        \\n//         for(int i=1;i<n;i++)\\n//         {\\n//             int maxi=0;\\n//             for(int j=0;j<i;j++)\\n//             {\\n//                 int x=s[i]-\\'a\\'+1;\\n//                 int y=s[j]-\\'a\\'+1;\\n//                 if(abs(x-y)<=k)\\n//                 {\\n//                     maxi=max(maxi,dist[j]);\\n//                 }\\n//             }\\n//             dist[i]=1+maxi;\\n//             count=max(count,dist[i]);\\n//         }\\n//         return count;\\n        \\n        return longest_subseq(n,k,s);\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    \\n    \\nint longest_subseq(int n, int k, string s)\\n{\\n\\n    vector<int> dp(n, 0);\\n    int max_length[26] = {0}",
                "codeTag": "Java"
            },
            {
                "id": 2390573,
                "title": "c-take-or-not-take-do-not-overthink-apply-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int n;\\n    int dp[100001][28];\\n    //i is the index and ch is the previous character that you have taken \\n    int func(int i,int ch,int k,string &s){\\n        \\n        if(i == n){\\n            return 0;\\n        }\\n        \\n        int l = 0, r = 0;\\n        \\n        if(dp[i][ch+1] != -1) return dp[i][ch+1];\\n        \\n        if(ch == -1 or abs( (s[i] - \\'a\\') - ch ) <= k){\\n            l = 1 + func(i+1,s[i] - \\'a\\',k,s);           //taking the element\\n        }\\n        \\n        r = func(i+1,ch,k,s);     //not taking the element \\n        \\n        return dp[i][ch+1] = max(l,r);\\n        \\n    }\\n    \\n    int longestIdealString(string s, int k) {\\n        n = s.size();\\n        memset(dp,-1,sizeof(dp));\\n        return func(0,-1,k,s);    \\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int n;\\n    int dp[100001][28];\\n    //i is the index and ch is the previous character that you have taken \\n    int func(int i,int ch,int k,string &s){\\n        \\n        if(i == n){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2390555,
                "title": "java-map-solution",
                "content": "\\n```\\n    public int longestIdealString(String s, int k) {\\n        Map<Character, Integer> char2len = new HashMap<>();\\n        for (Character c : s.toCharArray()) {\\n            int maxLen = 1;\\n            for (Map.Entry<Character, Integer> entry : char2len.entrySet()) {\\n                if (Math.abs(entry.getKey() - c) <= k) {\\n                    maxLen = Math.max(maxLen, entry.getValue() + 1);\\n                }\\n            }\\n            char2len.put(c, maxLen);\\n        }\\n        int maxLen = 1;\\n        for (Map.Entry<Character, Integer> entry : char2len.entrySet()) {\\n            maxLen = Math.max(maxLen, entry.getValue());\\n        }\\n        return maxLen;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n```\\n    public int longestIdealString(String s, int k) {\\n        Map<Character, Integer> char2len = new HashMap<>();\\n        for (Character c : s.toCharArray()) {\\n            int maxLen = 1;\\n            for (Map.Entry<Character, Integer> entry : char2len.entrySet()) {\\n                if (Math.abs(entry.getKey() - c) <= k) {\\n                    maxLen = Math.max(maxLen, entry.getValue() + 1);\\n                }\\n            }\\n            char2len.put(c, maxLen);\\n        }\\n        int maxLen = 1;\\n        for (Map.Entry<Character, Integer> entry : char2len.entrySet()) {\\n            maxLen = Math.max(maxLen, entry.getValue());\\n        }\\n        return maxLen;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2390527,
                "title": "easy-dp-recursion-memoization-c-0-1-knapsack-variation",
                "content": "It is a simple dp problem. It is a variation of 0-1 knapsack problem. Here we have two choices if abs(curr[i]-prev[i]))<=k then we can take it or leave it else leave it\\n\\n    int dp[100001][28];\\n    int solve(int i,char prev,string &s,int k)\\n    {\\n       if(i>=s.size())return 0;\\n        if(dp[i][prev-\\'a\\']!=-1)return dp[i][prev-\\'a\\'];\\n        \\n        if(abs(s[i]-prev)<=k || prev==\\'{\\')\\n            return dp[i][prev-\\'a\\']=max(1+solve(i+1,s[i],s,k),solve(i+1,prev,s,k));\\n        \\n        else\\n            return dp[i][prev-\\'a\\']=solve(i+1,prev,s,k);\\n            \\n    }\\n    \\n    int longestIdealString(string s, int k) {\\n        int n=s.size();\\n        memset(dp,-1,sizeof(dp));\\n        \\n        int ans=solve(0,\\'{\\',s,k);\\n        \\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "It is a simple dp problem. It is a variation of 0-1 knapsack problem. Here we have two choices if abs(curr[i]-prev[i]))<=k then we can take it or leave it else leave it\\n\\n    int dp[100001][28];\\n    int solve(int i,char prev,string &s,int k)\\n    {\\n       if(i>=s.size())return 0;\\n        if(dp[i][prev-\\'a\\']!=-1)return dp[i][prev-\\'a\\'];\\n        \\n        if(abs(s[i]-prev)<=k || prev==\\'{\\')\\n            return dp[i][prev-\\'a\\']=max(1+solve(i+1,s[i],s,k),solve(i+1,prev,s,k));\\n        \\n        else\\n            return dp[i][prev-\\'a\\']=solve(i+1,prev,s,k);\\n            \\n    }\\n    \\n    int longestIdealString(string s, int k) {\\n        int n=s.size();\\n        memset(dp,-1,sizeof(dp));\\n        \\n        int ans=solve(0,\\'{\\',s,k);\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2390448,
                "title": "longest-subsequence-by-character",
                "content": "```\\nclass Solution:\\n    def longestIdealString(self, s: str, k: int) -> int:\\n        n = len(s)\\n        dp = [1] * n\\n        longest = [0] * 26\\n        for i in range(n - 1, -1, -1):\\n            curr = ord(s[i]) - ord(\\'a\\')\\n            for j in range(curr - k, curr + k + 1):\\n                if 0 <= j < 26:\\n                    dp[i] = max(dp[i], 1 + longest[j])\\n            longest[curr] = max(longest[curr], dp[i])\\n        return max(dp)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def longestIdealString(self, s: str, k: int) -> int:\\n        n = len(s)\\n        dp = [1] * n\\n        longest = [0] * 26\\n        for i in range(n - 1, -1, -1):\\n            curr = ord(s[i]) - ord(\\'a\\')\\n            for j in range(curr - k, curr + k + 1):\\n                if 0 <= j < 26:\\n                    dp[i] = max(dp[i], 1 + longest[j])\\n            longest[curr] = max(longest[curr], dp[i])\\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2390444,
                "title": "python-dp-o-nk-straightforward-with-explanation",
                "content": "m is map with key is character and value is the length of longest subsequence ending at this character.\\n\\ne.g.:\\ns = \"acfgbd\", k = 2\\nm: {\\u2018a\\u2019: 1, \\'c\\': 2, \\'f\\': 1, \\'g\\': 2, \\'b\\': 3, \\'d\\': 4}\\nres: 4\\n\\nFor every current character, just need to find maximum length for the characters in k range obtained before, and add the 1 to it. \\n\\nThe result is the largest value in the map.\\n\\n```\\ndef longestIdealString(self, s: str, k: int) -> int:\\n        m = {}\\n        res = 1\\n        for c in s:\\n            mx = 0\\n            for i in range(-k, k+1):\\n                cur = chr(ord(c)+i)\\n                if \\'a\\' <=cur <= \\'z\\' and cur in m:\\n                    mx = max(mx, m[cur])\\n            m[c] = mx+1\\n            res = max(res, m[c])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef longestIdealString(self, s: str, k: int) -> int:\\n        m = {}\\n        res = 1\\n        for c in s:\\n            mx = 0\\n            for i in range(-k, k+1):\\n                cur = chr(ord(c)+i)\\n                if \\'a\\' <=cur <= \\'z\\' and cur in m:\\n                    mx = max(mx, m[cur])\\n            m[c] = mx+1\\n            res = max(res, m[c])\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4046718,
                "title": "c-unordered-map-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        int n=s.size();\\n        unordered_map<char,int> mp;\\n        int ans=0;\\n\\n        for(int i=0;i<n;i++){\\n            int maxi=0;\\n            //checking the value in map in range of k\\n            for(int j=0;j<=k;j++){\\n                if(mp.count(s[i]-j)){\\n                    maxi=max(maxi,mp[s[i]-j]);\\n                }\\n                if(mp.count(s[i]+j)){\\n                    maxi=max(maxi,mp[s[i]+j]);\\n                }\\n            }\\n            mp[s[i]]=1+maxi;\\n            ans=max(ans,mp[s[i]]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        int n=s.size();\\n        unordered_map<char,int> mp;\\n        int ans=0;\\n\\n        for(int i=0;i<n;i++){\\n            int maxi=0;\\n            //checking the value in map in range of k\\n            for(int j=0;j<=k;j++){\\n                if(mp.count(s[i]-j)){\\n                    maxi=max(maxi,mp[s[i]-j]);\\n                }\\n                if(mp.count(s[i]+j)){\\n                    maxi=max(maxi,mp[s[i]+j]);\\n                }\\n            }\\n            mp[s[i]]=1+maxi;\\n            ans=max(ans,mp[s[i]]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029521,
                "title": "take-not-take-simple-dp-memoized",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int find(string &s,int i,int k,int last,vector<vector<int>>&dp)\\n    {   \\n        if(i==s.size())\\n        return 0;\\n        if(dp[i][last]!=-1)\\n        return dp[i][last];\\n        if(last==26 || abs((int)(s[i]-\\'a\\')-last)<=k)\\n        return dp[i][last]=max(1+find(s,i+1,k,(int)(s[i]-\\'a\\'),dp),find(s,i+1,k,last,dp));\\n        else\\n        return dp[i][last]=find(s,i+1,k,last,dp);\\n    }\\n    int longestIdealString(string s, int k) {\\n        vector<vector<int>>dp(s.size(),vector<int>(27,-1));\\n        return find(s,0,k,26,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(string &s,int i,int k,int last,vector<vector<int>>&dp)\\n    {   \\n        if(i==s.size())\\n        return 0;\\n        if(dp[i][last]!=-1)\\n        return dp[i][last];\\n        if(last==26 || abs((int)(s[i]-\\'a\\')-last)<=k)\\n        return dp[i][last]=max(1+find(s,i+1,k,(int)(s[i]-\\'a\\'),dp),find(s,i+1,k,last,dp));\\n        else\\n        return dp[i][last]=find(s,i+1,k,last,dp);\\n    }\\n    int longestIdealString(string s, int k) {\\n        vector<vector<int>>dp(s.size(),vector<int>(27,-1));\\n        return find(s,0,k,26,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029295,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int solve(string& nums,int k,int index,char prev){\\n        if(index >= nums.length())\\n            return 0;\\n        if(dp[index][prev - \\'a\\'] != -1)\\n            return dp[index][prev - \\'a\\'];\\n        int take = 0;\\n        if(prev == \\'{\\' || (abs(nums[index] - prev) <= k))\\n            take = 1 + solve(nums,k,index+1,nums[index]);\\n        int notTake = solve(nums,k,index+1,prev);\\n        return dp[index][prev - \\'a\\'] = max(take,notTake);\\n    }\\n    int longestIdealString(string nums, int k) {\\n        dp = vector<vector<int>>(nums.length(),vector<int>(27,-1));\\n        return solve(nums,k,0,\\'{\\');\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int solve(string& nums,int k,int index,char prev){\\n        if(index >= nums.length())\\n            return 0;\\n        if(dp[index][prev - \\'a\\'] != -1)\\n            return dp[index][prev - \\'a\\'];\\n        int take = 0;\\n        if(prev == \\'{\\' || (abs(nums[index] - prev) <= k))\\n            take = 1 + solve(nums,k,index+1,nums[index]);\\n        int notTake = solve(nums,k,index+1,prev);\\n        return dp[index][prev - \\'a\\'] = max(take,notTake);\\n    }\\n    int longestIdealString(string nums, int k) {\\n        dp = vector<vector<int>>(nums.length(),vector<int>(27,-1));\\n        return solve(nums,k,0,\\'{\\');\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973267,
                "title": "c-beats-100-speed-and-memory",
                "content": "# Intuition\\nFind a way to solve in O(n) with DP.\\n\\n# Approach\\nFor each char in s, we find the different letters that are okay to use as a bridge(ex: for \\'b\\' and k = 2 we would have [\\'a\\', \\'b\\', \\'c\\', \\'d\\']). Then update dp with the current maximum found.\\n\\n# Complexity\\n- Time complexity: **O(n)**\\nFirst for loop is O(n) and .Max() to find the final answer is also O(n). Note that the second for loop is constant O(26).\\n\\n- Space complexity: **O(1)**\\nOnly using an array of constant size O(1) and some variables O(1).\\n\\n# Code\\n```\\npublic class Solution {\\n    public int LongestIdealString(string s, int k) {\\n        int[] dp = Enumerable.Repeat<int>(0, 26).ToArray();\\n        for(int i = 0; i < s.Length; i++) {\\n            int index = s[i] - \\'a\\';\\n            int max = 1;\\n            for (int j = 0; j < 26; ++j) {\\n\\t\\t\\t\\tif (Math.Abs(j - index) <= k) {\\n\\t\\t\\t\\t\\tmax = Math.Max(max, dp[j] + 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n            dp[index] = max;\\n        }\\n        return dp.Max();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution {\\n    public int LongestIdealString(string s, int k) {\\n        int[] dp = Enumerable.Repeat<int>(0, 26).ToArray();\\n        for(int i = 0; i < s.Length; i++) {\\n            int index = s[i] - \\'a\\';\\n            int max = 1;\\n            for (int j = 0; j < 26; ++j) {\\n\\t\\t\\t\\tif (Math.Abs(j - index) <= k) {\\n\\t\\t\\t\\t\\tmax = Math.Max(max, dp[j] + 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n            dp[index] = max;\\n        }\\n        return dp.Max();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943919,
                "title": "dp-linear-time-and-constant-space-beats-92-runtimes",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n  public int longestIdealString(String s, int k) {\\n    int[] dp = new int[26];\\n\\n    int maxIdealLength = 1;\\n\\n    for (int i = 0; i < s.length(); i++) {\\n      int ord = s.charAt(i) - \\'a\\';\\n      int j = Math.max(0, ord - k);\\n      int lim = Math.min(25, ord + k);\\n      int maxTail = -1;\\n      while (j <= lim) {\\n        maxTail = Math.max(maxTail, dp[j++] + 1);\\n      }\\n      dp[ord] = maxTail;\\n      maxIdealLength = Math.max(maxIdealLength, dp[ord]);\\n    }\\n\\n    return maxIdealLength;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n  public int longestIdealString(String s, int k) {\\n    int[] dp = new int[26];\\n\\n    int maxIdealLength = 1;\\n\\n    for (int i = 0; i < s.length(); i++) {\\n      int ord = s.charAt(i) - \\'a\\';\\n      int j = Math.max(0, ord - k);\\n      int lim = Math.min(25, ord + k);\\n      int maxTail = -1;\\n      while (j <= lim) {\\n        maxTail = Math.max(maxTail, dp[j++] + 1);\\n      }\\n      dp[ord] = maxTail;\\n      maxIdealLength = Math.max(maxIdealLength, dp[ord]);\\n    }\\n\\n    return maxIdealLength;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914433,
                "title": "simple-idea-take-a-read",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestIdealString(String s, int k) {\\n        int[] dp = new int[26] ; \\n        int tmax= 0 ; \\n        for(int i= 0 ; i<s.length();i++ ){\\n            int max= 0 ;\\n           int  ch= s.charAt(i)-\\'a\\';\\n            for(int j=Math.max(0,ch-k) ;j<=Math.min(25, ch+k) ; j++){\\n              \\n                    if(dp[j]>max){max=dp[j];}}\\n                \\n            \\n            dp[ch]=max+1;\\n            if(dp[ch]>tmax){tmax= dp[ch];}\\n        }\\n        return tmax;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestIdealString(String s, int k) {\\n        int[] dp = new int[26] ; \\n        int tmax= 0 ; \\n        for(int i= 0 ; i<s.length();i++ ){\\n            int max= 0 ;\\n           int  ch= s.charAt(i)-\\'a\\';\\n            for(int j=Math.max(0,ch-k) ;j<=Math.min(25, ch+k) ; j++){\\n              \\n                    if(dp[j]>max){max=dp[j];}}\\n                \\n            \\n            dp[ch]=max+1;\\n            if(dp[ch]>tmax){tmax= dp[ch];}\\n        }\\n        return tmax;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3907043,
                "title": "easy-java-solution-dp-recursion-top-down-approach-buttom-up-accepted",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRecursion>> top-down approach>> bottum - up (dp) \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n recursion>> TLE\\n Top-down->> TLE\\nBottum-Up>> accepted\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestIdealString(String s, int k) {\\n        int n= s.length();\\n        // return f(s,0,0,n,k);\\n        // return f1(s,0,0,n,k);\\n        return f2(s,n,k);\\n    }\\n    public int f(String s, int ind, int prev, int n, int k){\\n        while(ind==n) return 0;\\n\\n        int nottake= f(s,ind+1,prev ,n, k);\\n        int take= 0;\\n    if(prev==0 || Math.abs(s.charAt(ind)-prev)<=k)  {\\n\\n     take= 1+ f(s,ind+1,s.charAt(ind),n,k );\\n    }  \\n        return Math.max(take, nottake); \\n    }\\n    public int f1(String s, int ind, int prev, int n, int k){\\n        int dp[][]= new int[n+1][150];\\n        for(int row[]:dp){\\n            Arrays.fill(row, -1);\\n        }\\n        if(dp[ind][prev]!=-1) return dp[ind][prev];\\n        while(ind==n) return 0;\\n\\n        int nottake= f1(s,ind+1,prev ,n, k);\\n        int take= 0;\\n    if(prev==0 || Math.abs(s.charAt(ind)-prev)<=k)  {\\n\\n     take= 1+ f1(s,ind+1,s.charAt(ind),n,k );\\n    }  \\n        return dp[ind][prev]= Math.max(take, nottake); \\n    }\\n     public int f2(String s,int n, int k){\\n        int dp[][] =new int[n+1][27];\\n        // memset(dp, 0, sizeof(dp));\\n        for(int i = 1; i<=s.length(); i++){\\n            for(int j = 0; j<=26; j++){\\n                if(j==26){\\n                    dp[i][j] = Math.max(dp[i][j], 1+dp[i-1][s.charAt(i-1)-\\'a\\']);\\n                }\\n                else if(Math.abs(s.charAt(i-1)-\\'a\\'-j)<=k){\\n                    dp[i][j] = Math.max(dp[i][j], 1+dp[i-1][s.charAt(i-1)-\\'a\\']);\\n                }\\n                dp[i][j] = Math.max(dp[i][j], dp[i-1][j]);\\n            }\\n        }\\n        return dp[n][26];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int longestIdealString(String s, int k) {\\n        int n= s.length();\\n        // return f(s,0,0,n,k);\\n        // return f1(s,0,0,n,k);\\n        return f2(s,n,k);\\n    }\\n    public int f(String s, int ind, int prev, int n, int k){\\n        while(ind==n) return 0;\\n\\n        int nottake= f(s,ind+1,prev ,n, k);\\n        int take= 0;\\n    if(prev==0 || Math.abs(s.charAt(ind)-prev)<=k)  {\\n\\n     take= 1+ f(s,ind+1,s.charAt(ind),n,k );\\n    }  \\n        return Math.max(take, nottake); \\n    }\\n    public int f1(String s, int ind, int prev, int n, int k){\\n        int dp[][]= new int[n+1][150];\\n        for(int row[]:dp){\\n            Arrays.fill(row, -1);\\n        }\\n        if(dp[ind][prev]!=-1) return dp[ind][prev];\\n        while(ind==n) return 0;\\n\\n        int nottake= f1(s,ind+1,prev ,n, k);\\n        int take= 0;\\n    if(prev==0 || Math.abs(s.charAt(ind)-prev)<=k)  {\\n\\n     take= 1+ f1(s,ind+1,s.charAt(ind),n,k );\\n    }  \\n        return dp[ind][prev]= Math.max(take, nottake); \\n    }\\n     public int f2(String s,int n, int k){\\n        int dp[][] =new int[n+1][27];\\n        // memset(dp, 0, sizeof(dp));\\n        for(int i = 1; i<=s.length(); i++){\\n            for(int j = 0; j<=26; j++){\\n                if(j==26){\\n                    dp[i][j] = Math.max(dp[i][j], 1+dp[i-1][s.charAt(i-1)-\\'a\\']);\\n                }\\n                else if(Math.abs(s.charAt(i-1)-\\'a\\'-j)<=k){\\n                    dp[i][j] = Math.max(dp[i][j], 1+dp[i-1][s.charAt(i-1)-\\'a\\']);\\n                }\\n                dp[i][j] = Math.max(dp[i][j], dp[i-1][j]);\\n            }\\n        }\\n        return dp[n][26];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905286,
                "title": "java-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestIdealString(String s, int k) {\\n        int dp[][]=new int[s.length()][27];\\n         return helper(s,0,26,k,dp);\\n    }\\n    public  int helper(String str,int idx,int last,int k,int dp[][]){\\n        if(idx==str.length()) {\\n            \\n            return 0;\\n        }\\n        if(dp[idx][last]!=0){\\n            return dp[idx][last];\\n        }\\n        int curr=str.charAt(idx)-\\'a\\';\\n        int res1=0;\\n        if(last==26||Math.abs(curr-last)<=k) {\\n            res1=1+helper(str, idx+1, curr, k,dp);\\n        }\\n            int res2=helper(str, idx+1,last,k,dp);\\n\\n        return dp[idx][last]=Math.max(res1,res2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestIdealString(String s, int k) {\\n        int dp[][]=new int[s.length()][27];\\n         return helper(s,0,26,k,dp);\\n    }\\n    public  int helper(String str,int idx,int last,int k,int dp[][]){\\n        if(idx==str.length()) {\\n            \\n            return 0;\\n        }\\n        if(dp[idx][last]!=0){\\n            return dp[idx][last];\\n        }\\n        int curr=str.charAt(idx)-\\'a\\';\\n        int res1=0;\\n        if(last==26||Math.abs(curr-last)<=k) {\\n            res1=1+helper(str, idx+1, curr, k,dp);\\n        }\\n            int res2=helper(str, idx+1,last,k,dp);\\n\\n        return dp[idx][last]=Math.max(res1,res2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888792,
                "title": "c-2-liner-dp",
                "content": "# Intuition\\n- Build a cache of letters (a - z).\\n- Store the count of largest subsequence in it.\\n- For each char c, check the range $$c - k $$ to $$c + k$$, find the best answer and update $$cache[c]$$\\n- Keep track of maximum.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        int res = 0;\\n        vector<int> cache(150, 0);\\n        for(auto &i : s) {\\n            for(int j = i - k; j <= i + k; ++j)\\n                cache[i] = max(cache[j], cache[i]);\\n            res = max(++cache[i], res);\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        int res = 0;\\n        vector<int> cache(150, 0);\\n        for(auto &i : s) {\\n            for(int j = i - k; j <= i + k; ++j)\\n                cache[i] = max(cache[j], cache[i]);\\n            res = max(++cache[i], res);\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847906,
                "title": "c-hashtable-dynamic-programming",
                "content": "# Complexity\\n- Time complexity: `O(n * k)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:`O(n)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    bool isValid(char ch){\\n        return ch >= \\'a\\' && ch <= \\'z\\';\\n    }\\n\\n    int longestIdealString(string s, int k) {\\n        \\n        int n = s.length();\\n        int maxLen = 1;\\n\\n        unordered_map<char,int>dp;\\n\\n        for(int i=0;i<n;i++){\\n\\n            for(int j=0;j<=k;j++){\\n                \\n                char ch = s[i] - j;\\n\\n                if(isValid(ch) && dp.count(ch)) dp[s[i]] = max(1+dp[ch],dp[s[i]]);\\n                else dp[s[i]] = max(1,dp[s[i]]);\\n\\n                // here we added a condition [ ch != s[i] ] because we already processed for it\\n                // and we definitely get [ ch == s[i] ] because of [ch + 0 = ch]\\n                ch = s[i] + j;\\n                if(isValid(ch) && dp.count(ch) && ch != s[i]){\\n                    dp[s[i]] = max(1+dp[ch],dp[s[i]]);\\n                }\\n\\n            }\\n            \\n            maxLen = max(maxLen,dp[s[i]]);\\n\\n        }\\n\\n        return maxLen;\\n    }\\n\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isValid(char ch){\\n        return ch >= \\'a\\' && ch <= \\'z\\';\\n    }\\n\\n    int longestIdealString(string s, int k) {\\n        \\n        int n = s.length();\\n        int maxLen = 1;\\n\\n        unordered_map<char,int>dp;\\n\\n        for(int i=0;i<n;i++){\\n\\n            for(int j=0;j<=k;j++){\\n                \\n                char ch = s[i] - j;\\n\\n                if(isValid(ch) && dp.count(ch)) dp[s[i]] = max(1+dp[ch],dp[s[i]]);\\n                else dp[s[i]] = max(1,dp[s[i]]);\\n\\n                // here we added a condition [ ch != s[i] ] because we already processed for it\\n                // and we definitely get [ ch == s[i] ] because of [ch + 0 = ch]\\n                ch = s[i] + j;\\n                if(isValid(ch) && dp.count(ch) && ch != s[i]){\\n                    dp[s[i]] = max(1+dp[ch],dp[s[i]]);\\n                }\\n\\n            }\\n            \\n            maxLen = max(maxLen,dp[s[i]]);\\n\\n        }\\n\\n        return maxLen;\\n    }\\n\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845330,
                "title": "dp-i-made-it",
                "content": "# Intuition\\nFirst, i thought the dp array should be as long as s size, so define dp as dp[s.size()], and define another array to remember the largest position of every character, as pos[26].\\n\\nBut when i begin to write code, i found that i can\\'t get the transfer function. Then i realized that pos[26] is the true dp array, and the value of this array is not the position of every char, but the longest ideal subsequence end with this char.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        int n = s.size();\\n\\n        vector<int> dp(26, 0);\\n\\n        for (int i = 0; i < n; i++) {\\n            int pos = s[i]-\\'a\\';\\n            for (int j = max(0, pos-k); j <= min(25, pos+k); j++)\\n                dp[pos] = max(dp[pos], dp[j]);\\n            \\n            dp[pos] += 1;\\n        }\\n\\n        int ans = 0;\\n        for (auto x : dp)\\n            ans = max(ans, x);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        int n = s.size();\\n\\n        vector<int> dp(26, 0);\\n\\n        for (int i = 0; i < n; i++) {\\n            int pos = s[i]-\\'a\\';\\n            for (int j = max(0, pos-k); j <= min(25, pos+k); j++)\\n                dp[pos] = max(dp[pos], dp[j]);\\n            \\n            dp[pos] += 1;\\n        }\\n\\n        int ans = 0;\\n        for (auto x : dp)\\n            ans = max(ans, x);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839134,
                "title": "share-my-dp-solution",
                "content": "# Intuition\\n\\nAgain. Just focus on fundamentals. Its a straightforward solution if you look at the recurrance relation. Here is the recurrance relation in case its unclear. \\n\\n{a1, a2, a3, a4....an-1}\\nSuppose I know the solution in the above range and a new character an comes into the picture. What is the solution for it? \\n\\nWell, we just need to look for solutions before this character such that the characters are in range [an-k, an+k]. And there you go, this will be the solution for the array ending at the character an. \\n\\nJust do it for the entire string and you have the solution. Btw, some interesting questions to ask here :- \\n\\n1. What if we see duplicates? Does that change the outcome? And the answer is no. Why? Because if you see duplicates in a0.....ak, and then an is the same character as ak, then worst case, it remains the same solution and doesn\\'t extend anything. Otherwise it extends it and you get a new solution which should be used for future lookups for this character. \\n\\n# Approach\\n\\n1. Initialize the dp array.\\n2. For each character in the array dp[ch] = Max(dp[ch], 1 + dp[ch-k], dp[ch+k])\\n3. Update max accordingly.\\n4. Return the max\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(26)\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestIdealString(String s, int k) {\\n        int[] dp = new int[26];\\n\\n        int res = Integer.MIN_VALUE;\\n        for (char ch : s.toCharArray()) {\\n            int current = 1;\\n            for (int i=-k; i<=k; i++) {\\n                \\n                if (ch-\\'a\\'+i < 26 && ch-\\'a\\'+i>=0) {\\n                    current = Math.max(current, 1 + dp[ch-\\'a\\'+i]);\\n                }\\n            }\\n            \\n            dp[ch-\\'a\\'] = current;\\n            res = Math.max(res, dp[ch - \\'a\\']);\\n        }\\n\\n        return res;\\n    }\\n\\n    public static void main(String[] args) {\\n        Solution solution = new Solution();\\n        solution.longestIdealString(\"abc\", 3);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestIdealString(String s, int k) {\\n        int[] dp = new int[26];\\n\\n        int res = Integer.MIN_VALUE;\\n        for (char ch : s.toCharArray()) {\\n            int current = 1;\\n            for (int i=-k; i<=k; i++) {\\n                \\n                if (ch-\\'a\\'+i < 26 && ch-\\'a\\'+i>=0) {\\n                    current = Math.max(current, 1 + dp[ch-\\'a\\'+i]);\\n                }\\n            }\\n            \\n            dp[ch-\\'a\\'] = current;\\n            res = Math.max(res, dp[ch - \\'a\\']);\\n        }\\n\\n        return res;\\n    }\\n\\n    public static void main(String[] args) {\\n        Solution solution = new Solution();\\n        solution.longestIdealString(\"abc\", 3);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800937,
                "title": "easy-c-solution-using-dp",
                "content": "```\\npublic class Solution {\\n    public int LongestIdealString(string s, int k) {\\n        int n = s.Length;\\n        if(k == 25) return n;\\n        int[][] dp = new int[n][];\\n        for(int i = 0;i < n;i++){\\n            dp[i] = new int[27];\\n            Array.Fill(dp[i],-1);\\n        }\\n        int solve(int idx,int last){\\n            if(idx >= n) return 0;\\n            if(dp[idx][last + 1] != -1) return dp[idx][last + 1];\\n            // take\\n            int cur = s[idx] - \\'a\\';\\n            int take = (last == -1 || Math.Abs(cur - last) <= k) ? solve(idx + 1,cur) + 1 : 0;\\n            // leave\\n            int leave = solve(idx + 1,last);\\n            return dp[idx][last + 1] = Math.Max(take,leave);\\n        }\\n        return solve(0,-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution {\\n    public int LongestIdealString(string s, int k) {\\n        int n = s.Length;\\n        if(k == 25) return n;\\n        int[][] dp = new int[n][];\\n        for(int i = 0;i < n;i++){\\n            dp[i] = new int[27];\\n            Array.Fill(dp[i],-1);\\n        }\\n        int solve(int idx,int last){\\n            if(idx >= n) return 0;\\n            if(dp[idx][last + 1] != -1) return dp[idx][last + 1];\\n            // take\\n            int cur = s[idx] - \\'a\\';\\n            int take = (last == -1 || Math.Abs(cur - last) <= k) ? solve(idx + 1,cur) + 1 : 0;\\n            // leave\\n            int leave = solve(idx + 1,last);\\n            return dp[idx][last + 1] = Math.Max(take,leave);\\n        }\\n        return solve(0,-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759390,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int longestIdealString(string s, int k) \\n    {\\n        int n,ans;\\n        n=s.size();\\n        ans=0;\\n\\n        vector<int> dp(26,1);\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int val;\\n            val=1;\\n\\n            for(int j=s[i]-\\'a\\'-k;j<=s[i]-\\'a\\'+k;j++)\\n            {\\n                if(j>=0 && j<26 && dp[j]!=0)\\n                {\\n                    val=max(val,dp[j]+1);\\n                }\\n            }\\n\\n            dp[s[i]-\\'a\\']=max(dp[s[i]-\\'a\\'],val);\\n            ans=max(ans,dp[s[i]-\\'a\\']);\\n        }        \\n\\n        return ans-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int longestIdealString(string s, int k) \\n    {\\n        int n,ans;\\n        n=s.size();\\n        ans=0;\\n\\n        vector<int> dp(26,1);\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int val;\\n            val=1;\\n\\n            for(int j=s[i]-\\'a\\'-k;j<=s[i]-\\'a\\'+k;j++)\\n            {\\n                if(j>=0 && j<26 && dp[j]!=0)\\n                {\\n                    val=max(val,dp[j]+1);\\n                }\\n            }\\n\\n            dp[s[i]-\\'a\\']=max(dp[s[i]-\\'a\\'],val);\\n            ans=max(ans,dp[s[i]-\\'a\\']);\\n        }        \\n\\n        return ans-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671464,
                "title": "java-70-dp-logic-clean-code",
                "content": "# Approach\\n1. Start from the back, (letter d) and see what is the max chain d can make.As it\\'s the last letter, it can make a chain of 1 (itself)\\n2. Use an int[26] (a-z) to mark the chain length that current letter can make with the letters to the LEFT on its position.\\n    - b has letter d to its left. As b + 2 <= d, d is a valid chain so int[b] = int[d] + 1 (2)\\n3. When deciding what letters are BEST to make a chain FOR the current letter, do not travel to the LEFT of the string, as string can have 10^5 elements, \\n    - Instead travel to the left/right of current letter inside the int[].\\n    - EG: travel k elements to the left and right of b : 2 elements at the left of b inside [] are -1 and a.\\n    - Two elements at the right of b inside int[] are c and d. The max between these 5 is 1 so int[b] = int[d] + 1.\\n4. g -> travel 2 letters to the left of g (e,f) and 2 letters at the right of g (h,i). Determine their max and set int[g] = max + 1.\\n5. When doing this for all letters inside the string, traverse the int[] and return the max value recorded.\\n\\n# Complexity\\n- Time complexity:$$O(n * 2 * k)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestIdealString(String s, int k) {\\n        int[] longestSubsequences = new int[26];\\n        for (int i = s.length() -1; i>= 0; i--) {\\n            setLongestSubsequence(longestSubsequences, s.charAt(i) - \\'a\\', k);\\n        }\\n        int longest = 0;\\n        for (int length : longestSubsequences) {\\n            longest = Math.max(longest, length);\\n        }\\n        return longest;\\n    }\\n\\n    private void setLongestSubsequence(int[] subsequences, int from, int k) {\\n        int max = 0, i = 0;\\n        boolean set = true;\\n        while (set && i <= k) {\\n            set = false;\\n            if (from - i >= 0) {\\n                max = Math.max(max, subsequences[from - i]);\\n                set = true;\\n            }\\n            if (from + i < 26) {\\n                max = Math.max(max, subsequences[from + i]);\\n                set = true;\\n            }\\n            i++;\\n        }\\n        subsequences[from] = max + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestIdealString(String s, int k) {\\n        int[] longestSubsequences = new int[26];\\n        for (int i = s.length() -1; i>= 0; i--) {\\n            setLongestSubsequence(longestSubsequences, s.charAt(i) - \\'a\\', k);\\n        }\\n        int longest = 0;\\n        for (int length : longestSubsequences) {\\n            longest = Math.max(longest, length);\\n        }\\n        return longest;\\n    }\\n\\n    private void setLongestSubsequence(int[] subsequences, int from, int k) {\\n        int max = 0, i = 0;\\n        boolean set = true;\\n        while (set && i <= k) {\\n            set = false;\\n            if (from - i >= 0) {\\n                max = Math.max(max, subsequences[from - i]);\\n                set = true;\\n            }\\n            if (from + i < 26) {\\n                max = Math.max(max, subsequences[from + i]);\\n                set = true;\\n            }\\n            i++;\\n        }\\n        subsequences[from] = max + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670966,
                "title": "c-optimized-dynamic-programming-using-o-k-n-time-o-k-space",
                "content": "# Intuition\\nInitially I considered writing an algorithm with quadratic time complexity that at each character in $s$, we go back to all the characters before it and try to extend previously constructed subsequences. However, we don\\'t need to overthink the problem.\\n\\nImagine we are at index $i$ of $s$ and know the longest possible subsequences ending in each character in the alphabet, using all the characters in $s$ up to and including index $i-1$. The only different element between the set of \"longest possible subsequences\" at index $i-1$ and at index $i$ can be the one that ends in the character $s[i]$ -- how could we append a \\'c\\' to a subsequence and end up with a subsequence that ends in \\'b\\'? (we can\\'t).\\n\\nWhich  subsequences made from the first $i-1$ characters can we can try appending $s[i]$ to? Exactly the ones that are within $k$ distance of $s[i]$. So, at each index $i$ in $s$, we add one to all the subsequences ending with characters that are within $k$ distance of $s[i]$, and choose the longest one to update our \"longest ideal subsequence ending with $s[i]$\". Then the final answer is the maximum of all the longest ideal subsequences ending in different characters, because obviously, a finite sequence has to end in *some* character, given that the sequence is nonempty.\\n\\nBecause finding the answer at index $i$ only requires knowledge of the answers at index $i-1$, we don\\'t need to use much memory. We can just store the previous set of answers in an array of length 26, where the $0$ index represents the longest ideal subsequence ending in \\'a\\', 1 represents \\'b\\', ... , 25 represents \\'z\\'.\\n# Complexity\\n- Time complexity:\\n$O(k * n)$, where $n$ is the number of characters in $s$ and $k$ is the number of distinct possibilities for characters in $s$ (in this case, the 26 lowercase letters of the alphabet)\\n\\n- Space complexity:\\n$O(k)$\\n\\n# Code\\n```C++\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        array<int, 26> best{};\\n        for (const char char_in_s : s) {\\n            int new_best_this_char = 0;  // don\\'t store in array until after for loop\\n            // else we will double count subsequences when \\'char_in_s == char_in_range\\'\\n\\n            // ++best[char_in_s - \\'a\\'];\\n            // have to deal with char max being 127\\n            // e.g. z + 20 wraps around to low numbers so min of chars doesn\\'t work\\n            for (\\n                char char_in_range = (char)max((int)\\'a\\', char_in_s - k);\\n                char_in_range <= (char)min((int)\\'z\\', char_in_s + k);\\n                ++char_in_range\\n            ) {\\n                new_best_this_char = max(\\n                    new_best_this_char,\\n                    1 + best[char_in_range - \\'a\\']\\n                );\\n            }\\n            best[char_in_s - \\'a\\'] = new_best_this_char;\\n        }\\n        return *max_element(best.cbegin(), best.cend());\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        array<int, 26> best{};\\n        for (const char char_in_s : s) {\\n            int new_best_this_char = 0;  // don\\'t store in array until after for loop\\n            // else we will double count subsequences when \\'char_in_s == char_in_range\\'\\n\\n            // ++best[char_in_s - \\'a\\'];\\n            // have to deal with char max being 127\\n            // e.g. z + 20 wraps around to low numbers so min of chars doesn\\'t work\\n            for (\\n                char char_in_range = (char)max((int)\\'a\\', char_in_s - k);\\n                char_in_range <= (char)min((int)\\'z\\', char_in_s + k);\\n                ++char_in_range\\n            ) {\\n                new_best_this_char = max(\\n                    new_best_this_char,\\n                    1 + best[char_in_range - \\'a\\']\\n                );\\n            }\\n            best[char_in_s - \\'a\\'] = new_best_this_char;\\n        }\\n        return *max_element(best.cbegin(), best.cend());\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615100,
                "title": "swift-solution-easy-to-understand-o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func longestIdealString(_ s: String, _ k: Int) -> Int {\\n        let sLength = s.count\\n        var ans = 1\\n        var storeValue = Array(repeating: 0, count: 26)\\n        for iterator in s {\\n            var asciiValue = iterator.asciiValue! - 97\\n            var highestValue = 0\\n            for secondIterator in max(0,Int(asciiValue) - k)...min(25,Int(asciiValue) + k) {\\n                highestValue = max(highestValue,storeValue[secondIterator]) \\n            }\\n            storeValue[Int(asciiValue)] = highestValue + 1\\n            ans = max(ans,highestValue + 1)\\n        }\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func longestIdealString(_ s: String, _ k: Int) -> Int {\\n        let sLength = s.count\\n        var ans = 1\\n        var storeValue = Array(repeating: 0, count: 26)\\n        for iterator in s {\\n            var asciiValue = iterator.asciiValue! - 97\\n            var highestValue = 0\\n            for secondIterator in max(0,Int(asciiValue) - k)...min(25,Int(asciiValue) + k) {\\n                highestValue = max(highestValue,storeValue[secondIterator]) \\n            }\\n            storeValue[Int(asciiValue)] = highestValue + 1\\n            ans = max(ans,highestValue + 1)\\n        }\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565819,
                "title": "java-dp-easy-solution",
                "content": "\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestIdealString(String s, int k) {\\n        int DP[] = new int[26];\\n        DP[s.charAt(s.length()-1)-\\'a\\'] = 1;\\n        for(int i=s.length()-2; i>=0; i--){\\n            char ch = s.charAt(i);\\n            int ans = 0;\\n            for(int j=-k; j<=k; j++){\\n                if(ch-\\'a\\'+j<26&&ch-\\'a\\'+j>=0)\\n                    ans = Math.max(ans, DP[ch-\\'a\\'+j]);\\n            }\\n            DP[ch-\\'a\\'] = ans+1;\\n        }\\n        int ans = 0;\\n        for(int num:DP){\\n            ans =Math.max(ans,num);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int longestIdealString(String s, int k) {\\n        int DP[] = new int[26];\\n        DP[s.charAt(s.length()-1)-\\'a\\'] = 1;\\n        for(int i=s.length()-2; i>=0; i--){\\n            char ch = s.charAt(i);\\n            int ans = 0;\\n            for(int j=-k; j<=k; j++){\\n                if(ch-\\'a\\'+j<26&&ch-\\'a\\'+j>=0)\\n                    ans = Math.max(ans, DP[ch-\\'a\\'+j]);\\n            }\\n            DP[ch-\\'a\\'] = ans+1;\\n        }\\n        int ans = 0;\\n        for(int num:DP){\\n            ans =Math.max(ans,num);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561565,
                "title": "c-dp-memorization-easy",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\nint solve(string &s, int last, int index ,int k, vector <vector<int>> &dp){\\n    if(index>=s.length())\\n    return 0;\\n    if(dp[index][last] != -1)\\n    return dp[index][last];\\n\\n    if(last == 0 || abs( (s[index]-\\'a\\' + 1) - last) <= k){\\n        return dp[index][last] = max( solve(s, last, index+1, k, dp), 1 + solve(s, s[index]-\\'a\\'+1, index+1, k, dp));\\n    }\\n    else\\n    return dp[index][last] = solve(s, last, index+1, k, dp);\\n}\\n\\n    int longestIdealString(string s, int k) {\\n       \\n        vector <vector<int>> dp(s.length()+1, vector <int>(27,-1));\\n        return solve(s, 0, 0, k, dp);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nint solve(string &s, int last, int index ,int k, vector <vector<int>> &dp){\\n    if(index>=s.length())\\n    return 0;\\n    if(dp[index][last] != -1)\\n    return dp[index][last];\\n\\n    if(last == 0 || abs( (s[index]-\\'a\\' + 1) - last) <= k){\\n        return dp[index][last] = max( solve(s, last, index+1, k, dp), 1 + solve(s, s[index]-\\'a\\'+1, index+1, k, dp));\\n    }\\n    else\\n    return dp[index][last] = solve(s, last, index+1, k, dp);\\n}\\n\\n    int longestIdealString(string s, int k) {\\n       \\n        vector <vector<int>> dp(s.length()+1, vector <int>(27,-1));\\n        return solve(s, 0, 0, k, dp);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551796,
                "title": "dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    Integer[][] dp;\\n    public int getIdx(char c){\\n        return c-\\'0\\'-48;\\n    }\\n    public int solve(String s,int k,int idx,char last){\\n        if(idx==s.length())\\n        return 0;\\n        if(dp[idx][last]!=null)\\n        return dp[idx][last];\\n        int pick=0;\\n         if(Math.abs(getIdx(s.charAt(idx)) - getIdx(last))<=k || last==\\'#\\')\\n         pick=1+solve(s,k,idx+1,s.charAt(idx));\\n        int notPick=solve(s,k,idx+1,last);\\n         return dp[idx][last]=Math.max(pick,notPick);\\n\\n    }\\n    public int longestIdealString(String s, int k) {\\n        dp=new Integer[s.length()][150];\\n        return solve(s,k,0,\\'#\\');\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Integer[][] dp;\\n    public int getIdx(char c){\\n        return c-\\'0\\'-48;\\n    }\\n    public int solve(String s,int k,int idx,char last){\\n        if(idx==s.length())\\n        return 0;\\n        if(dp[idx][last]!=null)\\n        return dp[idx][last];\\n        int pick=0;\\n         if(Math.abs(getIdx(s.charAt(idx)) - getIdx(last))<=k || last==\\'#\\')\\n         pick=1+solve(s,k,idx+1,s.charAt(idx));\\n        int notPick=solve(s,k,idx+1,last);\\n         return dp[idx][last]=Math.max(pick,notPick);\\n\\n    }\\n    public int longestIdealString(String s, int k) {\\n        dp=new Integer[s.length()][150];\\n        return solve(s,k,0,\\'#\\');\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537461,
                "title": "simple-dp-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\no(26*n)\\n\\n- Space complexity:\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        int dp[100001]={0},map[27]={0};\\n        int m=1;\\n        map[s[0]-\\'a\\']=1;\\n        int p=0;\\n        dp[0]=1;\\n        for (int i=1;i<s.size();i++){\\n            int f=0,p=-1,q=0;\\n            for (char j=\\'a\\';j<=\\'z\\';j++){\\n                if (map[j-\\'a\\']&&abs(s[i]-j)<=k){\\n                    if (q<=dp[map[j-\\'a\\']-1])\\n                        q=dp[map[j-\\'a\\']-1],f=1,p=map[j-\\'a\\'];\\n                }\\n            }\\n            map[s[i]-\\'a\\']=i+1;\\n            if (f==1)\\n                dp[i]+=dp[p-1];\\n            dp[i]++;\\n        if (dp[i]>=m)\\n            m=dp[i];\\n        }\\n        return m;\\n    }\\n};\\n//eduktdb\\n//edkdb\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        int dp[100001]={0},map[27]={0};\\n        int m=1;\\n        map[s[0]-\\'a\\']=1;\\n        int p=0;\\n        dp[0]=1;\\n        for (int i=1;i<s.size();i++){\\n            int f=0,p=-1,q=0;\\n            for (char j=\\'a\\';j<=\\'z\\';j++){\\n                if (map[j-\\'a\\']&&abs(s[i]-j)<=k){\\n                    if (q<=dp[map[j-\\'a\\']-1])\\n                        q=dp[map[j-\\'a\\']-1],f=1,p=map[j-\\'a\\'];\\n                }\\n            }\\n            map[s[i]-\\'a\\']=i+1;\\n            if (f==1)\\n                dp[i]+=dp[p-1];\\n            dp[i]++;\\n        if (dp[i]>=m)\\n            m=dp[i];\\n        }\\n        return m;\\n    }\\n};\\n//eduktdb\\n//edkdb\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528889,
                "title": "java-solution-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestIdealString(String s, int k) {\\n        int n = s.length();\\n        char[] array = s.toCharArray();\\n        int[] dp = new int[26];\\n        int result = 0;\\n        for(int i = 0; i < array.length; i++){\\n            int index = array[i] - \\'a\\';\\n            int lower = Math.max(0, index - k);\\n            int upper = Math.min(25, index + k);\\n            int currentMax = 0;\\n            for(int j = lower; j <= upper; j++){\\n                currentMax = Math.max(currentMax, dp[j] + 1);\\n            }\\n            dp[index] = Math.max(currentMax, dp[index]);\\n            result = Math.max(result, dp[index]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestIdealString(String s, int k) {\\n        int n = s.length();\\n        char[] array = s.toCharArray();\\n        int[] dp = new int[26];\\n        int result = 0;\\n        for(int i = 0; i < array.length; i++){\\n            int index = array[i] - \\'a\\';\\n            int lower = Math.max(0, index - k);\\n            int upper = Math.min(25, index + k);\\n            int currentMax = 0;\\n            for(int j = lower; j <= upper; j++){\\n                currentMax = Math.max(currentMax, dp[j] + 1);\\n            }\\n            dp[index] = Math.max(currentMax, dp[index]);\\n            result = Math.max(result, dp[index]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513867,
                "title": "java-o-26-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSame issue for [2407. Longest Increasing Subsequence II](https://leetcode.com/problems/longest-increasing-subsequence-ii/description/) without [segment tree solution](https://leetcode.com/problems/longest-increasing-subsequence-ii/solutions/3513802/java-nlgn-max-segmenttree-solution/).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int longestIdealString(String s, int k) {\\n        int[] buckets = new int[26];\\n        int res = 0;\\n        for(int i = 0; i < s.length(); ++i){\\n            int idx = s.charAt(i) - \\'a\\', max = 0;\\n            int min = Math.min(idx + k + 1, buckets.length);            \\n            for(int j = Math.max(idx - k, 0); j < min; ++j){\\n                max = Math.max(max, buckets[j]);\\n            }\\n            buckets[idx] = max + 1;\\n            res = Math.max(res, buckets[idx]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestIdealString(String s, int k) {\\n        int[] buckets = new int[26];\\n        int res = 0;\\n        for(int i = 0; i < s.length(); ++i){\\n            int idx = s.charAt(i) - \\'a\\', max = 0;\\n            int min = Math.min(idx + k + 1, buckets.length);            \\n            for(int j = Math.max(idx - k, 0); j < min; ++j){\\n                max = Math.max(max, buckets[j]);\\n            }\\n            buckets[idx] = max + 1;\\n            res = Math.max(res, buckets[idx]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511936,
                "title": "tabulation-dp-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n*27)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        int n = s.length();\\n        vector<int> next(27,0),cur(27,0);\\n        for(int ind = n-1; ind>=0; ind--){\\n            for(int prev = 0; prev<27; prev++){\\n                int notTake = next[prev];\\n                int take = 0;\\n                int ch = s[ind] - \\'a\\';\\n                if(prev==26 || abs(prev-ch)<=k){\\n                    take = 1 + next[ch];\\n                }\\n                cur[prev] = max(take,notTake);\\n            }\\n            next = cur;\\n        }\\n        return next[26];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        int n = s.length();\\n        vector<int> next(27,0),cur(27,0);\\n        for(int ind = n-1; ind>=0; ind--){\\n            for(int prev = 0; prev<27; prev++){\\n                int notTake = next[prev];\\n                int take = 0;\\n                int ch = s[ind] - \\'a\\';\\n                if(prev==26 || abs(prev-ch)<=k){\\n                    take = 1 + next[ch];\\n                }\\n                cur[prev] = max(take,notTake);\\n            }\\n            next = cur;\\n        }\\n        return next[26];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511191,
                "title": "4-line-codes-dp-full-explanation-beats-92",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLet `dp[i]` to be the length of the longest ideal string ends up with `s[i]`, then `dp[i] = max(dp[i - k : i + k + 1]) + 1` which means we could check all the possible char to concatenate `s[i]`.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Define the dp.\\n2. Go through each char in s and update the dp.\\n3. Return the max among dp.\\n# Complexity\\n- Time complexity: O(n^2) where n is the size of s\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) since the number of char is fixed\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestIdealString(self, s: str, k: int) -> int:\\n        # dp[i] represents the length longest ideal string ends up with s[i]\\n        dp = [0] * 123 # since ord(\\'a\\') = 96\\n        for c in s:\\n            dp[ord(c)] = max(dp[ord(c) - k : ord(c) + k + 1]) + 1\\n        return max(dp)\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def longestIdealString(self, s: str, k: int) -> int:\\n        # dp[i] represents the length longest ideal string ends up with s[i]\\n        dp = [0] * 123 # since ord(\\'a\\') = 96\\n        for c in s:\\n            dp[ord(c)] = max(dp[ord(c) - k : ord(c) + k + 1]) + 1\\n        return max(dp)\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3510229,
                "title": "python-dp-o-n-k",
                "content": "```\\nclass Solution:\\n    def longestIdealString(self, s: str, k: int) -> int:\\n        dp = [0] * 26\\n        for char in s:\\n            idx = ord(char) - ord(\\'a\\')\\n            dp[idx] = 1 + max(dp[max(0, idx - k) : min(26, idx + k + 1)])\\n        return max(dp)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def longestIdealString(self, s: str, k: int) -> int:\\n        dp = [0] * 26\\n        for char in s:\\n            idx = ord(char) - ord(\\'a\\')\\n            dp[idx] = 1 + max(dp[max(0, idx - k) : min(26, idx + k + 1)])\\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3504529,
                "title": "c-python-dp-solution-with-explanation",
                "content": "```dp[26]``` is the length of the longest subsequence ending with the nearest letter```a~z```before the current letter.\\nfor example, s = ```c..c..c..f...```, current letter is ```f```, and ```c```s are candidates of sequence member, \\nthe sequence ending with ```f``` is the sequence ending with last ```c``` add a ```f```.\\n\\nso ```dp[current letter] = max(dp[current letter-k], dp[current letter-k+1], ..., dp[current letter+k], if dp[i] is available) + 1``` \\n\\ntc is O(n), sc is O(1)\\n\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        int dp[26] {0};\\n        int ans = 0;\\n        int curleng;\\n        for(char& ch: s) {\\n            curleng = 1;\\n            for (int i = max(ch - \\'a\\' - k, 0); i <= min(ch - \\'a\\' + k, 25); i+=1) curleng = max(curleng, dp[i]+1);\\n            ans = max(ans, curleng);\\n            dp[ch-\\'a\\'] = curleng;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n### python\\n```python\\nclass Solution:\\n    def longestIdealString(self, s: str, k: int) -> int:\\n        dp = [0] * 26\\n        ans = 0\\n        for le in s:\\n            curleng = 1\\n            for i in range(max(0, ord(le) - ord(\\'a\\') - k), min(26, ord(le) - ord(\\'a\\') + k + 1)): curleng = max(curleng, dp[i]+1)\\n            ans = max(ans, curleng)\\n            dp[ord(le) - ord(\\'a\\')] = curleng\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```dp[26]```\n```a~z```\n```c..c..c..f...```\n```f```\n```c```\n```f```\n```c```\n```f```\n```dp[current letter] = max(dp[current letter-k], dp[current letter-k+1], ..., dp[current letter+k], if dp[i] is available) + 1```\n```cpp\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        int dp[26] {0};\\n        int ans = 0;\\n        int curleng;\\n        for(char& ch: s) {\\n            curleng = 1;\\n            for (int i = max(ch - \\'a\\' - k, 0); i <= min(ch - \\'a\\' + k, 25); i+=1) curleng = max(curleng, dp[i]+1);\\n            ans = max(ans, curleng);\\n            dp[ch-\\'a\\'] = curleng;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def longestIdealString(self, s: str, k: int) -> int:\\n        dp = [0] * 26\\n        ans = 0\\n        for le in s:\\n            curleng = 1\\n            for i in range(max(0, ord(le) - ord(\\'a\\') - k), min(26, ord(le) - ord(\\'a\\') + k + 1)): curleng = max(curleng, dp[i]+1)\\n            ans = max(ans, curleng)\\n            dp[ord(le) - ord(\\'a\\')] = curleng\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3487706,
                "title": "longest-ideal-subsequence-short-but-not-simple-beats-60",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {number}\\n */\\nvar longestIdealString = function(s, k) {\\n    arr = new Array(26).fill(0)\\n\\n    for (let i = 0; i < s.length; i++) { \\n        char_code = s.charCodeAt(i) - 97       \\n        subarray = arr.slice(Math.max(char_code - k, 0), Math.min(char_code + k + 1, 26))\\n        count = Math.max(...subarray), count ++        \\n        arr[char_code] = count\\n    }\\n    \\n    return Math.max(...arr)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number} k\\n * @return {number}\\n */\\nvar longestIdealString = function(s, k) {\\n    arr = new Array(26).fill(0)\\n\\n    for (let i = 0; i < s.length; i++) { \\n        char_code = s.charCodeAt(i) - 97       \\n        subarray = arr.slice(Math.max(char_code - k, 0), Math.min(char_code + k + 1, 26))\\n        count = Math.max(...subarray), count ++        \\n        arr[char_code] = count\\n    }\\n    \\n    return Math.max(...arr)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3476028,
                "title": "ez-dp-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        vector<int>dp(26,0);\\n        int n = s.size();\\n        int res = 0;\\n        for(int i = 0;i<n;i++){\\n            int index = s[i]-\\'a\\';\\n            int tmp = dp[index];\\n            for(int j = 0;j<=k && index-j >= 0;j++){\\n                tmp = max(dp[index-j]+1,tmp);\\n            }\\n            for(int j = 0;j<=k && index+j < 26;j++){\\n                tmp = max(dp[index+j]+1,tmp);\\n            }\\n            dp[index] = tmp;\\n            res = max(res,dp[index]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        vector<int>dp(26,0);\\n        int n = s.size();\\n        int res = 0;\\n        for(int i = 0;i<n;i++){\\n            int index = s[i]-\\'a\\';\\n            int tmp = dp[index];\\n            for(int j = 0;j<=k && index-j >= 0;j++){\\n                tmp = max(dp[index-j]+1,tmp);\\n            }\\n            for(int j = 0;j<=k && index+j < 26;j++){\\n                tmp = max(dp[index+j]+1,tmp);\\n            }\\n            dp[index] = tmp;\\n            res = max(res,dp[index]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464924,
                "title": "hash-table-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLongest increasing subsequence\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- if directly using naive longest increasing subsequence, it will TLE, because O(n^2) is 10 ** 10\\n- according to the value of n, we can use O(n) algorithm, the method is the same as longest increasing subsequence, but in the second loop, we only need to search the value in hash table.\\n- This is becaues they are letters not numbers, we can store (current alphabet: longest ideal subsequence) pairs in dp\\n- According to the value of k, we can prepare a getWindowCharacters(c) function to get the windows for each character, e.g. the character is c, then we have a window: \\'abcde\\', just find the max of the 5 characters, then plus 1, get the final result.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n): dp[c] = max(dp[i] for i in getWindowCharacters(c)) + 1 is O(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1): dp = defaultdict(int) is O(1)\\n# Code\\n```\\nclass Solution:\\n    def longestIdealString(self, s: str, k: int) -> int:\\n        # use dict as dp storing (current alphabet: longest ideal subsequence) pairs\\n        def getWindowCharacters(c):\\n            res = \\'\\'\\n            for i in range(-k, k + 1):\\n                res += chr(ord(c) + i)\\n            return res\\n\\n        dp = defaultdict(int)\\n        for c in s:\\n            dp[c] = max(dp[i] for i in getWindowCharacters(c)) + 1\\n        return max(dp.values())\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestIdealString(self, s: str, k: int) -> int:\\n        # use dict as dp storing (current alphabet: longest ideal subsequence) pairs\\n        def getWindowCharacters(c):\\n            res = \\'\\'\\n            for i in range(-k, k + 1):\\n                res += chr(ord(c) + i)\\n            return res\\n\\n        dp = defaultdict(int)\\n        for c in s:\\n            dp[c] = max(dp[i] for i in getWindowCharacters(c)) + 1\\n        return max(dp.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385255,
                "title": "c-map-bottom-up-dp",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        unordered_map<char, int> mp;\\n        for(int i = 0; i < s.size(); i++){\\n            int l = max(s[i] - k, (int)\\'a\\');\\n            int r = min(s[i] + k, (int)\\'z\\');\\n            int v = 0;\\n            for(int j = l; j <= r; j++){\\n                if(mp.count(j)) v = max(v, mp[j]);\\n            }\\n            mp[s[i]] = v + 1;\\n        }\\n        int m = 0;\\n        for(auto it = mp.begin(); it != mp.end(); ++it) m = max(m, it->second);\\n        return m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        unordered_map<char, int> mp;\\n        for(int i = 0; i < s.size(); i++){\\n            int l = max(s[i] - k, (int)\\'a\\');\\n            int r = min(s[i] + k, (int)\\'z\\');\\n            int v = 0;\\n            for(int j = l; j <= r; j++){\\n                if(mp.count(j)) v = max(v, mp[j]);\\n            }\\n            mp[s[i]] = v + 1;\\n        }\\n        int m = 0;\\n        for(auto it = mp.begin(); it != mp.end(); ++it) m = max(m, it->second);\\n        return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381933,
                "title": "simple-c-solution-using-dynamic-programming",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int n , k;\\n    int solve(int i , char prev ,string &s ,vector<vector<int>> &dp ){\\n        if(i==n) return 0;\\n\\n        if(dp[i][prev]!=-1) return dp[i][prev];\\n        if(abs(s[i]-prev)<=k){\\n            return dp[i][prev] =  max(1+ solve(i+1 , s[i] , s , dp) ,\\n             solve(i+1 , prev , s,dp));\\n        }\\n\\n        return dp[i][prev] = solve(i+1 , prev , s , dp);\\n    }\\n    int longestIdealString(string s, int K) {\\n        n = s.size();\\n        k = K;\\n\\n        vector<vector<int>> dp(n , vector<int>(256 , -1));\\n\\n        int maxx = 0;\\n\\n        for(int i=0 ; i<26 ; i++){\\n            maxx = max(maxx , solve(0 , \\'a\\'+i , s , dp));\\n        }\\n\\n        return maxx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n , k;\\n    int solve(int i , char prev ,string &s ,vector<vector<int>> &dp ){\\n        if(i==n) return 0;\\n\\n        if(dp[i][prev]!=-1) return dp[i][prev];\\n        if(abs(s[i]-prev)<=k){\\n            return dp[i][prev] =  max(1+ solve(i+1 , s[i] , s , dp) ,\\n             solve(i+1 , prev , s,dp));\\n        }\\n\\n        return dp[i][prev] = solve(i+1 , prev , s , dp);\\n    }\\n    int longestIdealString(string s, int K) {\\n        n = s.size();\\n        k = K;\\n\\n        vector<vector<int>> dp(n , vector<int>(256 , -1));\\n\\n        int maxx = 0;\\n\\n        for(int i=0 ; i<26 ; i++){\\n            maxx = max(maxx , solve(0 , \\'a\\'+i , s , dp));\\n        }\\n\\n        return maxx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327232,
                "title": "dp-memo-simple-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(int i,int prev,string&a,int k,vector<vector<int>>&dp){\\n        int n=a.size();\\n        if(i==n) return 0;\\n        if(dp[i][prev]!=-1) return dp[i][prev];\\n        int le=0,ri=0;\\n        le=f(i+1,prev,a,k,dp);\\n        if(prev==26||abs((a[i]-\\'a\\')-prev)<=k)\\n        ri=1+f(i+1,a[i]-\\'a\\',a,k,dp);\\n        return dp[i][prev]=max(le,ri);\\n    }\\n    int longestIdealString(string s, int k) {\\n        int n=s.size();\\n        vector<vector<int>>dp(n,vector<int>(27,-1));\\n        return f(0,26,s,k,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int i,int prev,string&a,int k,vector<vector<int>>&dp){\\n        int n=a.size();\\n        if(i==n) return 0;\\n        if(dp[i][prev]!=-1) return dp[i][prev];\\n        int le=0,ri=0;\\n        le=f(i+1,prev,a,k,dp);\\n        if(prev==26||abs((a[i]-\\'a\\')-prev)<=k)\\n        ri=1+f(i+1,a[i]-\\'a\\',a,k,dp);\\n        return dp[i][prev]=max(le,ri);\\n    }\\n    int longestIdealString(string s, int k) {\\n        int n=s.size();\\n        vector<vector<int>>dp(n,vector<int>(27,-1));\\n        return f(0,26,s,k,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3292677,
                "title": "prabal-kumar-pandey",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        vector<int> dp(26);\\n        for (const auto& c : s) {\\n            const int x = c - \\'a\\';\\n            dp[x] = *max_element(cbegin(dp) + max(x - k, 0), cbegin(dp) + min(x + k + 1, 26)) + 1;\\n        }\\n        return *max_element(cbegin(dp), cend(dp));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        vector<int> dp(26);\\n        for (const auto& c : s) {\\n            const int x = c - \\'a\\';\\n            dp[x] = *max_element(cbegin(dp) + max(x - k, 0), cbegin(dp) + min(x + k + 1, 26)) + 1;\\n        }\\n        return *max_element(cbegin(dp), cend(dp));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276927,
                "title": "java-o-n-solution",
                "content": "```\\nclass Solution {\\n    public int longestIdealString(String s, int k) {\\n        int len = s.length();\\n        \\n        int ans = 1;\\n        int[] dp = new int[26];\\n        \\n        for(int i = 0;i < len;i++){\\n            int max = 1;\\n            \\n            int ptr = s.charAt(i) - \\'a\\';\\n            \\n            int start = Math.max(0, ptr - k);\\n            int end = Math.min(25, ptr + k);\\n            \\n            for(int j = start;j <= end;j++){\\n                max = Math.max(dp[j] + 1, max);\\n            }\\n            \\n            dp[ptr] = Math.max(dp[ptr], max);\\n            ans = Math.max(ans, max);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int longestIdealString(String s, int k) {\\n        int len = s.length();\\n        \\n        int ans = 1;\\n        int[] dp = new int[26];\\n        \\n        for(int i = 0;i < len;i++){\\n            int max = 1;\\n            \\n            int ptr = s.charAt(i) - \\'a\\';\\n            \\n            int start = Math.max(0, ptr - k);\\n            int end = Math.min(25, ptr + k);\\n            \\n            for(int j = start;j <= end;j++){\\n                max = Math.max(dp[j] + 1, max);\\n            }\\n            \\n            dp[ptr] = Math.max(dp[ptr], max);\\n            ans = Math.max(ans, max);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255061,
                "title": "dp-approach-java-solution-clean-code",
                "content": "# Complexity\\n- Time complexity: $O(26 * n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java\\nclass Solution {\\n    public int longestIdealString(String s, int k) {\\n        int dp[] = new int[26];\\n        int ans = 1;\\n        for(int i = 0;i < s.length();i++){\\n            int c = s.charAt(i) - \\'a\\';\\n            for(int j = c;j >= 0 && c - j <= k;--j){\\n                dp[c] = Math.max(dp[c],dp[j] + 1);\\n            }\\n            for(int j = c + 1;j < 26 && j - c <= k;++j){\\n                dp[c] = Math.max(dp[c],dp[j] + 1);\\n            }\\n            ans = Math.max(ans,dp[c]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```java\\nclass Solution {\\n    public int longestIdealString(String s, int k) {\\n        int dp[] = new int[26];\\n        int ans = 1;\\n        for(int i = 0;i < s.length();i++){\\n            int c = s.charAt(i) - \\'a\\';\\n            for(int j = c;j >= 0 && c - j <= k;--j){\\n                dp[c] = Math.max(dp[c],dp[j] + 1);\\n            }\\n            for(int j = c + 1;j < 26 && j - c <= k;++j){\\n                dp[c] = Math.max(dp[c],dp[j] + 1);\\n            }\\n            ans = Math.max(ans,dp[c]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205812,
                "title": "memoization-c",
                "content": "```\\nclass Solution {\\n    int dfs(int i, char last, int n, string &s, int k, vector<vector<int>> &dp) {\\n        if(i == n) return 0;\\n        if(last != \\'#\\' && dp[i][last - \\'a\\'] != -1) return dp[i][last - \\'a\\'];\\n\\n        int notPick = dfs(i + 1, last, n, s, k, dp), pick = 0;\\n        if(last == \\'#\\') pick = 1 + dfs(i + 1, s[i], n, s, k, dp);\\n        else pick = abs(last - s[i]) <= k ? 1 + dfs(i + 1, s[i], n, s, k, dp) : 0;\\n        \\n        if(last != \\'#\\') dp[i][last - \\'a\\'] = max(pick, notPick);\\n        return max(pick, notPick);\\n    }\\npublic:\\n    int longestIdealString(string s, int k) {\\n        int n = s.size();\\n        vector<vector<int>> dp(n, vector<int>(26, -1));\\n\\n        return dfs(0, \\'#\\', n, s, k, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(int i, char last, int n, string &s, int k, vector<vector<int>> &dp) {\\n        if(i == n) return 0;\\n        if(last != \\'#\\' && dp[i][last - \\'a\\'] != -1) return dp[i][last - \\'a\\'];\\n\\n        int notPick = dfs(i + 1, last, n, s, k, dp), pick = 0;\\n        if(last == \\'#\\') pick = 1 + dfs(i + 1, s[i], n, s, k, dp);\\n        else pick = abs(last - s[i]) <= k ? 1 + dfs(i + 1, s[i], n, s, k, dp) : 0;\\n        \\n        if(last != \\'#\\') dp[i][last - \\'a\\'] = max(pick, notPick);\\n        return max(pick, notPick);\\n    }\\npublic:\\n    int longestIdealString(string s, int k) {\\n        int n = s.size();\\n        vector<vector<int>> dp(n, vector<int>(26, -1));\\n\\n        return dfs(0, \\'#\\', n, s, k, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3165835,
                "title": "c-easy-array",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        const int N = s.size();\\n        array<int, 26U> dp = {0};\\n        int ans = 0;\\n        for(char c : s) {\\n            const char low = max(c - k, \\'a\\' + 0);\\n            const char high = min(c + k, \\'z\\' + 0);\\n\\n            int val = 1;            \\n            \\n            for(char cc = low; cc <= high; ++cc) {\\n                val = max(val, dp[cc - \\'a\\'] + 1);\\n            }\\n            dp[c - \\'a\\'] = val;\\n            ans = max(ans, val);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        const int N = s.size();\\n        array<int, 26U> dp = {0};\\n        int ans = 0;\\n        for(char c : s) {\\n            const char low = max(c - k, \\'a\\' + 0);\\n            const char high = min(c + k, \\'z\\' + 0);\\n\\n            int val = 1;            \\n            \\n            for(char cc = low; cc <= high; ++cc) {\\n                val = max(val, dp[cc - \\'a\\'] + 1);\\n            }\\n            dp[c - \\'a\\'] = val;\\n            ans = max(ans, val);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3139993,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint n;\\n    int rec(int ind,string &s,int k,int c,vector<vector<int>>&dp)\\n    {\\n       if (ind==n) return 0;\\n       int pick=0;\\n       if (dp[ind][c]!=-1) return dp[ind][c];\\n       if (c==26 || abs((s[ind]-\\'a\\')-c)<=k)\\n       {\\n           pick=1+rec(ind+1,s,k,s[ind]-\\'a\\',dp);\\n       }\\n       int notPick=rec(ind+1,s,k,c,dp);\\n      return dp[ind][c]=max(pick,notPick);\\n    }\\n    int longestIdealString(string s, int k) \\n    {\\n        n=s.size();\\n        vector<vector<int>>dp(n,vector<int>(27,-1));\\n        return rec(0,s,k,26,dp);\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint n;\\n    int rec(int ind,string &s,int k,int c,vector<vector<int>>&dp)\\n    {\\n       if (ind==n) return 0;\\n       int pick=0;\\n       if (dp[ind][c]!=-1) return dp[ind][c];\\n       if (c==26 || abs((s[ind]-\\'a\\')-c)<=k)\\n       {\\n           pick=1+rec(ind+1,s,k,s[ind]-\\'a\\',dp);\\n       }\\n       int notPick=rec(ind+1,s,k,c,dp);\\n      return dp[ind][c]=max(pick,notPick);\\n    }\\n    int longestIdealString(string s, int k) \\n    {\\n        n=s.size();\\n        vector<vector<int>>dp(n,vector<int>(27,-1));\\n        return rec(0,s,k,26,dp);\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3123690,
                "title": "take-it-easy",
                "content": "\\n    int longestIdealString(string s, int k) \\n    {\\n        int ans=1;\\n        vector<int> dp(26,0);\\n        for(char ch:s)\\n        {\\n            int maxi=0;\\n            int idx=ch-\\'a\\';\\n            for(int i=0;(i<=k && idx>=i);i++)\\n            {\\n                maxi=max(maxi,dp[idx-i]);\\n            }\\n            for(int i=0;(i<=k && idx+i<26);i++)\\n            {\\n                maxi=max(maxi,dp[idx+i]);\\n            }\\n            \\n            \\n            dp[ch-\\'a\\']=maxi+1;\\n        }\\n        for(int ele:dp)\\n        {\\n            ans=max(ans,ele);\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\n    int longestIdealString(string s, int k) \\n    {\\n        int ans=1;\\n        vector<int> dp(26,0);\\n        for(char ch:s)\\n        {\\n            int maxi=0;\\n            int idx=ch-\\'a\\';\\n            for(int i=0;(i<=k && idx>=i);i++)\\n            {\\n                maxi=max(maxi,dp[idx-i]);\\n            }\\n            for(int i=0;(i<=k && idx+i<26);i++)\\n            {\\n                maxi=max(maxi,dp[idx+i]);\\n            }\\n            \\n            \\n            dp[ch-\\'a\\']=maxi+1;\\n        }\\n        for(int ele:dp)\\n        {\\n            ans=max(ans,ele);\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3091198,
                "title": "c-clean-code-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        map<char,int> p;int a=0;\\n        for(char i : s)\\n        {\\n           int m=0;\\n            for(int j=0;j<=k;j++)\\n            { m=max(m,p[int(i)-j]);\\n              m=max(m,p[j+int(i)]);\\n            }\\n               p[int(i)]=1+m;\\n               a=max(a,p[i]);\\n        }\\n        return a;\\n    }\\n};\\n//Upvote if u like it\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        map<char,int> p;int a=0;\\n        for(char i : s)\\n        {\\n           int m=0;\\n            for(int j=0;j<=k;j++)\\n            { m=max(m,p[int(i)-j]);\\n              m=max(m,p[j+int(i)]);\\n            }\\n               p[int(i)]=1+m;\\n               a=max(a,p[i]);\\n        }\\n        return a;\\n    }\\n};\\n//Upvote if u like it\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050578,
                "title": "1-liner-dp",
                "content": "```\\nint longestIdealString(string s, int k) \\n{\\n\\treturn accumulate(begin(s), end(s), 0, [&, d=vector(26,0)](auto M, auto c)mutable{ return max(M, d[c-\\'a\\']=1+*max_element(begin(d)+max(0, c-\\'a\\'-k), begin(d)+min(26, c-\\'a\\'+k+1))); });\\n}\\n```\\n||\\n```\\nint longestIdealString(string s, int k) \\n{\\n\\tint out{};\\n\\tfor(int i{}, d[26]{}; i<size(s); ++i)\\n\\t\\tout = max(out, d[s[i]-\\'a\\']=1+*max_element(begin(d)+max(0, s[i]-\\'a\\'-k), begin(d)+min(26, 1+s[i]-\\'a\\'+k)));\\n\\treturn out;\\n}\\n```\\n||\\n```\\nint longestIdealString(string s, int k) \\n{\\n\\tint out{};\\n\\tfor(int i{}, d[26]{}; i<size(s); ++i)\\n\\t{\\n\\t\\tint M{};\\n\\t\\tfor(int j{max(0, s[i]-\\'a\\'-k)}; j<min(26, s[i]-\\'a\\'+k+1); ++j)\\n\\t\\t\\tM = max(M, 1+d[j]);\\n\\t\\tout = max(out, d[s[i]-\\'a\\']=M);\\n\\t}\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint longestIdealString(string s, int k) \\n{\\n\\treturn accumulate(begin(s), end(s), 0, [&, d=vector(26,0)](auto M, auto c)mutable{ return max(M, d[c-\\'a\\']=1+*max_element(begin(d)+max(0, c-\\'a\\'-k), begin(d)+min(26, c-\\'a\\'+k+1))); });\\n}\\n```\n```\\nint longestIdealString(string s, int k) \\n{\\n\\tint out{};\\n\\tfor(int i{}, d[26]{}; i<size(s); ++i)\\n\\t\\tout = max(out, d[s[i]-\\'a\\']=1+*max_element(begin(d)+max(0, s[i]-\\'a\\'-k), begin(d)+min(26, 1+s[i]-\\'a\\'+k)));\\n\\treturn out;\\n}\\n```\n```\\nint longestIdealString(string s, int k) \\n{\\n\\tint out{};\\n\\tfor(int i{}, d[26]{}; i<size(s); ++i)\\n\\t{\\n\\t\\tint M{};\\n\\t\\tfor(int j{max(0, s[i]-\\'a\\'-k)}; j<min(26, s[i]-\\'a\\'+k+1); ++j)\\n\\t\\t\\tM = max(M, 1+d[j]);\\n\\t\\tout = max(out, d[s[i]-\\'a\\']=M);\\n\\t}\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2994628,
                "title": "java-o-n-dp-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestIdealString(String s, int k) {\\n        int n = s.length();\\n        int[] dp = new int[26];\\n        int res = 0;\\n        for (int i = 0; i < n; i++) {\\n            int c = s.charAt(i) - \\'a\\';\\n            int start = Math.max(0, c - k), end = Math.min(25, c + k);\\n            dp[c]++;\\n            for (int j = start; j <= end; j++) {\\n                if (j == c) continue;\\n                dp[c] = Math.max(dp[c], dp[j] + 1);\\n            }\\n        }\\n\\n        for (int i = 0; i < 26; i++) res = Math.max(res, dp[i]);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestIdealString(String s, int k) {\\n        int n = s.length();\\n        int[] dp = new int[26];\\n        int res = 0;\\n        for (int i = 0; i < n; i++) {\\n            int c = s.charAt(i) - \\'a\\';\\n            int start = Math.max(0, c - k), end = Math.min(25, c + k);\\n            dp[c]++;\\n            for (int j = start; j <= end; j++) {\\n                if (j == c) continue;\\n                dp[c] = Math.max(dp[c], dp[j] + 1);\\n            }\\n        }\\n\\n        for (int i = 0; i < 26; i++) res = Math.max(res, dp[i]);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2966873,
                "title": "c-memo",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[100002][27];\\n    int find(int i,int p,string &s,int k)\\n    {\\n        if(i>=s.size())\\n            return 0;\\n        if(dp[i][p]!=-1)\\n            return dp[i][p];\\n        int res=find(i+1,p,s,k),c=s[i]-\\'a\\'+1;\\n        if(p==0 || abs(p-c)<=k)\\n            res=max(res,1+find(i+1,c,s,k));\\n        return dp[i][p]=res;\\n    }\\n    int longestIdealString(string s, int k) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        return find(0,0,s,k);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[100002][27];\\n    int find(int i,int p,string &s,int k)\\n    {\\n        if(i>=s.size())\\n            return 0;\\n        if(dp[i][p]!=-1)\\n            return dp[i][p];\\n        int res=find(i+1,p,s,k),c=s[i]-\\'a\\'+1;\\n        if(p==0 || abs(p-c)<=k)\\n            res=max(res,1+find(i+1,c,s,k));\\n        return dp[i][p]=res;\\n    }\\n    int longestIdealString(string s, int k) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        return find(0,0,s,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946425,
                "title": "simple-and-intutive-bottom-up-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n int func(string s,int idx, char last,int k, vector<vector<int>>dp){\\n     if(idx == s.length()) return 0;\\n     int pick =INT_MIN;\\n     int nonpick =INT_MIN;\\n     if(last!=\\'!\\' && dp[idx][last-\\'a\\']!=-1) return dp[idx][last-\\'a\\'];\\n     if(last==\\'!\\') pick = func(s,idx+1, s[idx],k,dp)+1;\\n     if(last!=\\'!\\' && (abs(last-s[idx])<=k))pick = func(s,idx+1, s[idx],k,dp)+1;\\n     nonpick =  func(s,idx+1,last,k,dp);\\n     if(last!=\\'!\\') return dp[idx][last-\\'a\\'] = max(pick,nonpick);\\n     return max(pick,nonpick);\\n }\\npublic:\\n    int longestIdealString(string s, int k) {\\n        vector<vector<int>>dp(s.size()+1,vector<int>(27));\\n        int n= s.size();\\n        for(int i = 0;i<=26;i++) dp[n][i] = 0;\\n        for(int i = n-1;i>=0;i--){\\n            for(int last=0;last<=26;last++){\\n                 int pick =INT_MIN;\\n                 int nonpick =INT_MIN;\\n                if(last == 0){\\n                   pick =dp[i+1][s[i]-\\'a\\'+1]+1;\\n                }\\n                if(last!=0 && (abs(last-(s[i]-\\'a\\'+1))<=k)){\\n                    pick =dp[i+1][s[i]-\\'a\\'+1]+1;\\n                }\\n                 nonpick =  dp[i+1][last];\\n                dp[i][last] = max(pick,nonpick);\\n            }\\n           \\n          \\n\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n int func(string s,int idx, char last,int k, vector<vector<int>>dp){\\n     if(idx == s.length()) return 0;\\n     int pick =INT_MIN;\\n     int nonpick =INT_MIN;\\n     if(last!=\\'!\\' && dp[idx][last-\\'a\\']!=-1) return dp[idx][last-\\'a\\'];\\n     if(last==\\'!\\') pick = func(s,idx+1, s[idx],k,dp)+1;\\n     if(last!=\\'!\\' && (abs(last-s[idx])<=k))pick = func(s,idx+1, s[idx],k,dp)+1;\\n     nonpick =  func(s,idx+1,last,k,dp);\\n     if(last!=\\'!\\') return dp[idx][last-\\'a\\'] = max(pick,nonpick);\\n     return max(pick,nonpick);\\n }\\npublic:\\n    int longestIdealString(string s, int k) {\\n        vector<vector<int>>dp(s.size()+1,vector<int>(27));\\n        int n= s.size();\\n        for(int i = 0;i<=26;i++) dp[n][i] = 0;\\n        for(int i = n-1;i>=0;i--){\\n            for(int last=0;last<=26;last++){\\n                 int pick =INT_MIN;\\n                 int nonpick =INT_MIN;\\n                if(last == 0){\\n                   pick =dp[i+1][s[i]-\\'a\\'+1]+1;\\n                }\\n                if(last!=0 && (abs(last-(s[i]-\\'a\\'+1))<=k)){\\n                    pick =dp[i+1][s[i]-\\'a\\'+1]+1;\\n                }\\n                 nonpick =  dp[i+1][last];\\n                dp[i][last] = max(pick,nonpick);\\n            }\\n           \\n          \\n\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2917248,
                "title": "java-100-faster-o-n-k-time-o-26-space-hash-table-dynamic-programming",
                "content": "```\\nclass Solution {\\n    public int longestIdealString(String s, int k) {\\n        int[] dp = new int[26];\\n        int max = 1;\\n        \\n        for(int i = s.length()-1; i >= 0; i--) {\\n            \\n            int idx = s.charAt(i) - \\'a\\';\\n            int l = idx, r = idx;\\n            int maxCon = 0;\\n            \\n            while((l >= 0) && (idx-l <= k)) {\\n                maxCon = Math.max(dp[l], maxCon);\\n                l--;\\n            }\\n            \\n            while((r < 26) && (r-idx <= k)) {\\n                maxCon = Math.max(dp[r], maxCon);\\n                r++;\\n            }\\n            \\n            dp[idx] = maxCon+1;\\n            max = Math.max(max, dp[idx]);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int longestIdealString(String s, int k) {\\n        int[] dp = new int[26];\\n        int max = 1;\\n        \\n        for(int i = s.length()-1; i >= 0; i--) {\\n            \\n            int idx = s.charAt(i) - \\'a\\';\\n            int l = idx, r = idx;\\n            int maxCon = 0;\\n            \\n            while((l >= 0) && (idx-l <= k)) {\\n                maxCon = Math.max(dp[l], maxCon);\\n                l--;\\n            }\\n            \\n            while((r < 26) && (r-idx <= k)) {\\n                maxCon = Math.max(dp[r], maxCon);\\n                r++;\\n            }\\n            \\n            dp[idx] = maxCon+1;\\n            max = Math.max(max, dp[idx]);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2916648,
                "title": "c-solution-recursion-memoization-tabulation-space-optimisation-o-1-space-tle-on-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    \\nint solveSpaceOptimised(string s,int k){\\n\\tint n = s.size();\\n\\tvector<int> next(27,0);\\n\\tvector<int> dp(27,0);\\n\\t\\n\\tfor(int index=n-1;index>=0;index--){\\n\\t\\tfor(int prev=0;prev<=26;prev++){\\n\\t\\t\\tint casted = prev+97;\\n\\t\\t\\tint ans=-1; \\n\\t\\t\\tif(casted==123 || abs(casted-s[index]) <= k)\\n\\t\\t\\t\\tans = max(ans,1+next[s[index]-97]);\\n\\t\\t\\tans = max(ans,next[prev]);\\n\\t\\t\\tdp[casted-97] = ans;\\n\\t\\t}\\n\\t\\tnext = dp;\\n\\t}\\n\\t\\n\\treturn dp[26];\\n}\\n    \\nint solveTabulation(string s,int k){\\n\\tint n = s.size();\\n\\tvector<vector<int>> dp(n+1,vector<int>(27,0));\\n\\t\\n\\tfor(int index=n-1;index>=0;index--){\\n\\t\\tfor(int prev=0;prev<=26;prev++){\\n\\t\\t\\tint casted = prev+97;\\n\\t\\t\\tint ans=-1; \\n\\t\\t\\tif(casted==123 || abs(casted-s[index]) <= k)\\n\\t\\t\\t\\tans = max(ans,1+dp[index+1][s[index]-97]);\\n\\t\\t\\tans = max(ans,dp[index+1][prev]);\\n\\t\\t\\tdp[index][casted-97] = ans;\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn dp[0][26];\\n\\t\\n}\\n\\n\\nint solve(string s,int index,char prev,int k,vector<vector<int>> & dp){\\n\\t\\n\\tif(index>=s.size()) return 0;\\n\\tint casted = (int)prev;\\n\\tif(dp[index][casted-97]!=-1) return dp[index][casted-97];\\n\\tint ans = solve(s,index+1,prev,k,dp);\\n\\tif(casted==123 || abs(casted-s[index]) <= k)\\n\\t\\tans = max(ans,1+solve(s,index+1,s[index],k,dp));\\n\\treturn  dp[index][casted-97] = ans;\\n\\t\\n}\\n\\n\\nint longestIdealString(string s, int k) {\\n\\t// vector<vector<int>> dp(s.size()+1,vector<int>(27,-1));\\n\\t// return solve(s,0,123,k,dp);\\n\\t// return solveTabulation(s,k);\\n\\treturn solveSpaceOptimised(s,k);\\n}\\n};\\n```\\n\\nMemoization solution will give you TLE here in this problem\\nTabulation and space optimised solution will get accepted\\n\\nupvote if it helps :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\nint solveSpaceOptimised(string s,int k){\\n\\tint n = s.size();\\n\\tvector<int> next(27,0);\\n\\tvector<int> dp(27,0);\\n\\t\\n\\tfor(int index=n-1;index>=0;index--){\\n\\t\\tfor(int prev=0;prev<=26;prev++){\\n\\t\\t\\tint casted = prev+97;\\n\\t\\t\\tint ans=-1; \\n\\t\\t\\tif(casted==123 || abs(casted-s[index]) <= k)\\n\\t\\t\\t\\tans = max(ans,1+next[s[index]-97]);\\n\\t\\t\\tans = max(ans,next[prev]);\\n\\t\\t\\tdp[casted-97] = ans;\\n\\t\\t}\\n\\t\\tnext = dp;\\n\\t}\\n\\t\\n\\treturn dp[26];\\n}\\n    \\nint solveTabulation(string s,int k){\\n\\tint n = s.size();\\n\\tvector<vector<int>> dp(n+1,vector<int>(27,0));\\n\\t\\n\\tfor(int index=n-1;index>=0;index--){\\n\\t\\tfor(int prev=0;prev<=26;prev++){\\n\\t\\t\\tint casted = prev+97;\\n\\t\\t\\tint ans=-1; \\n\\t\\t\\tif(casted==123 || abs(casted-s[index]) <= k)\\n\\t\\t\\t\\tans = max(ans,1+dp[index+1][s[index]-97]);\\n\\t\\t\\tans = max(ans,dp[index+1][prev]);\\n\\t\\t\\tdp[index][casted-97] = ans;\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn dp[0][26];\\n\\t\\n}\\n\\n\\nint solve(string s,int index,char prev,int k,vector<vector<int>> & dp){\\n\\t\\n\\tif(index>=s.size()) return 0;\\n\\tint casted = (int)prev;\\n\\tif(dp[index][casted-97]!=-1) return dp[index][casted-97];\\n\\tint ans = solve(s,index+1,prev,k,dp);\\n\\tif(casted==123 || abs(casted-s[index]) <= k)\\n\\t\\tans = max(ans,1+solve(s,index+1,s[index],k,dp));\\n\\treturn  dp[index][casted-97] = ans;\\n\\t\\n}\\n\\n\\nint longestIdealString(string s, int k) {\\n\\t// vector<vector<int>> dp(s.size()+1,vector<int>(27,-1));\\n\\t// return solve(s,0,123,k,dp);\\n\\t// return solveTabulation(s,k);\\n\\treturn solveSpaceOptimised(s,k);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891912,
                "title": "constant-space-solution-tc-o-s-size-dynamic-programming-most-optimal",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k){\\n        vector<int> dp(26, 0);\\n        for(int i = 0; i < s.size(); ++i){\\n            int mx = 0;\\n            int l = s[i] - \\'a\\';\\n            for(int z = 0; z <= min(25 - l, k); ++z){\\n                mx = max({dp[l + z], mx});\\n            }\\n            for(int z = 1; z <= min(l, k); ++z){\\n                mx = max({dp[l - z], mx});\\n            }\\n            dp[l] = max(dp[l], mx + 1);\\n        }\\n        return *max_element(dp.begin(), dp.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k){\\n        vector<int> dp(26, 0);\\n        for(int i = 0; i < s.size(); ++i){\\n            int mx = 0;\\n            int l = s[i] - \\'a\\';\\n            for(int z = 0; z <= min(25 - l, k); ++z){\\n                mx = max({dp[l + z], mx});\\n            }\\n            for(int z = 1; z <= min(l, k); ++z){\\n                mx = max({dp[l - z], mx});\\n            }\\n            dp[l] = max(dp[l], mx + 1);\\n        }\\n        return *max_element(dp.begin(), dp.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891284,
                "title": "simple-dp-o-n-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        int ans=1,n=s.length();\\n        vector<int> prev(27,0);\\n        prev[s.back()-\\'a\\']=1;\\n        for(int i=n-2;i>=0;i--){\\n            int c=s[i]-\\'a\\',mx=0;\\n            for(int j=max(c-k,0);j<=min(25,c+k);j++)\\n                if(abs(j-c)<=k)\\n                    mx=max(mx,prev[j]);\\n            prev[c]=max(prev[c],1+mx);\\n            ans=max(ans,prev[c]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestIdealString(string s, int k) {\\n        int ans=1,n=s.length();\\n        vector<int> prev(27,0);\\n        prev[s.back()-\\'a\\']=1;\\n        for(int i=n-2;i>=0;i--){\\n            int c=s[i]-\\'a\\',mx=0;\\n            for(int j=max(c-k,0);j<=min(25,c+k);j++)\\n                if(abs(j-c)<=k)\\n                    mx=max(mx,prev[j]);\\n            prev[c]=max(prev[c],1+mx);\\n            ans=max(ans,prev[c]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868641,
                "title": "problem-2370-longest-ideal-subsequence-c-solution-memoization",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int rec(string &s,int i,int &k,char c){\\n        if(i>=s.size()) return 0;\\n        if(dp[i][c-\\'a\\']!=-1) return dp[i][c-\\'a\\'];\\n        if(c==\\'{\\') return  dp[i][c-\\'a\\']=max(1+rec(s,i+1,k,s[i]),rec(s,i+1,k,c));\\n        if(abs(s[i]-c)<=k) return  dp[i][c-\\'a\\']=max(1+rec(s,i+1,k,s[i]),rec(s,i+1,k,c));\\n        else  return dp[i][c-\\'a\\']=rec(s,i+1,k,c);\\n    }\\n    int longestIdealString(string s, int k) {\\n        dp=vector<vector<int>>(s.size(),vector<int>(27,-1));\\n        return rec(s,0,k,\\'{\\');\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int rec(string &s,int i,int &k,char c){\\n        if(i>=s.size()) return 0;\\n        if(dp[i][c-\\'a\\']!=-1) return dp[i][c-\\'a\\'];\\n        if(c==\\'{\\') return  dp[i][c-\\'a\\']=max(1+rec(s,i+1,k,s[i]),rec(s,i+1,k,c));\\n        if(abs(s[i]-c)<=k) return  dp[i][c-\\'a\\']=max(1+rec(s,i+1,k,s[i]),rec(s,i+1,k,c));\\n        else  return dp[i][c-\\'a\\']=rec(s,i+1,k,c);\\n    }\\n    int longestIdealString(string s, int k) {\\n        dp=vector<vector<int>>(s.size(),vector<int>(27,-1));\\n        return rec(s,0,k,\\'{\\');\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2839704,
                "title": "video-walkthrough-easy-3-line-solution-python",
                "content": "[Click Here For Video Walkthrough](https://youtu.be/b1DEvIl7_fg)\\n```\\nclass Solution:\\n    def longestIdealString(self, s: str, k: int) -> int:\\n        D = [0] * 26\\n        for c in map(lambda c: ord(c) - ord(\\'a\\'), s): D[c] = max(D[max(c-k,0):c+k+1]) + 1\\n        return max(D)\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def longestIdealString(self, s: str, k: int) -> int:\\n        D = [0] * 26\\n        for c in map(lambda c: ord(c) - ord(\\'a\\'), s): D[c] = max(D[max(c-k,0):c+k+1]) + 1\\n        return max(D)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808439,
                "title": "python3-dp-o-n-time-beats-90-space-beats-96",
                "content": "Scan the string, and store the length of longest ideal subsequence for alphabets, finally caculate the maximum.\\n```\\nclass Solution:\\n    def longestIdealString(self, s: str, k: int) -> int:\\n        lis = [0] * 26\\n        for ch in s:\\n            idx = ord(ch) - ord(\"a\")\\n            mi, ma = max(0, idx - k), min(25, idx + k)\\n            last_lis = max(lis[mi: ma + 1])\\n            lis[idx] = last_lis + 1\\n        return max(lis)\\n```\\n![image](https://assets.leetcode.com/users/images/1d486cd4-17ab-4736-ab79-1e6798774d38_1668299390.174544.png)\\n",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def longestIdealString(self, s: str, k: int) -> int:\\n        lis = [0] * 26\\n        for ch in s:\\n            idx = ord(ch) - ord(\"a\")\\n            mi, ma = max(0, idx - k), min(25, idx + k)\\n            last_lis = max(lis[mi: ma + 1])\\n            lis[idx] = last_lis + 1\\n        return max(lis)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791249,
                "title": "python-o-26n-dp-with-intuition",
                "content": "DP definition: dp[i] longest length of ideal subsequence s[:i]\\nand we get state transfer eq.:\\n`dp[i] = max(dp[i], dp[j]+1) for every abs(ord(s[i])-ord(s[j])) <= k`\\n\\nwe also maintain an array `closest` to store index of X character\\n- X is last character of longest ideal subsequence ending at j-th position.\\n- X is from `a` to `z`\\n```\\nex.\\n\"kpaaaaavkccccji\", k=4, ans:2\\n j\\'      j    i  => consider s[i], append after j position is longer than appending after j\\'\\n j = closest[\"k\"]\\n```\\n\\n##### O(26n)\\n```python\\nclass Solution:\\n    def longestIdealString(self, s: str, k: int) -> int:\\n        N = len(s)\\n        OFFSET = ord(\"a\")\\n\\n        dp = [1] * N\\n        closest = [-1] * 26 # index of a-z closest to s[i]\\n        longest = 1\\n        for i in range(0, N):\\n            shift = ord(s[i])-OFFSET\\n            for alphabet in range(max(0, shift-k), min(26, shift+k+1)):\\n                j = closest[alphabet]\\n                if j != -1:\\n                    dp[i] = max(dp[i], dp[j]+1)\\n            closest[ord(s[i])-OFFSET] = i\\n            longest = max(longest, dp[i])\\n\\n        return longest\\n```\\n\\n##### top-down\\nsince subsequence is not consecutive, we can keep tracking longest length of ideal subsequence ending with a-z at every i-th position\\n\\nkind of greedy\\n```python\\nclass Solution:\\n    def longestIdealString(self, s: str, k: int) -> int:\\n        N = len(s)\\n        OFFSET = ord(\"a\")\\n\\n        def dfs(i):\\n            if i == -1: return [0] * 26\\n            \\n            seq = dfs(i-1)\\n\\n            num = ord(s[i])-OFFSET\\n            lo = max(0, ord(s[i])-OFFSET-k)\\n            hi = min(26, ord(s[i])-OFFSET+k+1)\\n            seq[num] = max(seq[lo:hi])+1\\n            return seq\\n        return max(dfs(N-1))\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nex.\\n\"kpaaaaavkccccji\", k=4, ans:2\\n j\\'      j    i  => consider s[i], append after j position is longer than appending after j\\'\\n j = closest[\"k\"]\\n```\n```python\\nclass Solution:\\n    def longestIdealString(self, s: str, k: int) -> int:\\n        N = len(s)\\n        OFFSET = ord(\"a\")\\n\\n        dp = [1] * N\\n        closest = [-1] * 26 # index of a-z closest to s[i]\\n        longest = 1\\n        for i in range(0, N):\\n            shift = ord(s[i])-OFFSET\\n            for alphabet in range(max(0, shift-k), min(26, shift+k+1)):\\n                j = closest[alphabet]\\n                if j != -1:\\n                    dp[i] = max(dp[i], dp[j]+1)\\n            closest[ord(s[i])-OFFSET] = i\\n            longest = max(longest, dp[i])\\n\\n        return longest\\n```\n```python\\nclass Solution:\\n    def longestIdealString(self, s: str, k: int) -> int:\\n        N = len(s)\\n        OFFSET = ord(\"a\")\\n\\n        def dfs(i):\\n            if i == -1: return [0] * 26\\n            \\n            seq = dfs(i-1)\\n\\n            num = ord(s[i])-OFFSET\\n            lo = max(0, ord(s[i])-OFFSET-k)\\n            hi = min(26, ord(s[i])-OFFSET+k+1)\\n            seq[num] = max(seq[lo:hi])+1\\n            return seq\\n        return max(dfs(N-1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788660,
                "title": "python3-dp",
                "content": "class Solution:\\n\\n    def longestIdealString(self, s: str, k: int) -> int:\\n        count = [0]*26\\n        n = len(s) - 1\\n        ordA = ord(\\'a\\')\\n        count[ord(s[-1])-ordA] = 1\\n        \\n        for i in reversed(range(n)):\\n            char = s[i]\\n            pos = ord(char)-ordA\\n            lb,ub = max(0,pos-k),1 + min(25,pos+k)\\n            \\n            maximum = 0\\n            for j in range(lb,ub):\\n                maximum = max(maximum,count[j])\\n            count[pos] = 1 + maximum\\n            \\n        return max(count)",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def longestIdealString(self, s: str, k: int) -> int:\\n        count = [0]*26\\n        n = len(s) - 1\\n        ordA = ord(\\'a\\')\\n        count[ord(s[-1])-ordA] = 1\\n        \\n        for i in reversed(range(n)):\\n            char = s[i]\\n            pos = ord(char)-ordA\\n            lb,ub = max(0,pos-k),1 + min(25,pos+k)\\n            \\n            maximum = 0\\n            for j in range(lb,ub):\\n                maximum = max(maximum,count[j])\\n            count[pos] = 1 + maximum\\n            \\n        return max(count)",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1966962,
                "content": [
                    {
                        "username": "real_potatohead",
                        "content": "The use of ASCII character rather than the index in the prev was quite tricky to understand in the first go, got TLE several times\\uD83E\\uDD72"
                    },
                    {
                        "username": "mayankindia0122",
                        "content": "// can anyone tell me what is wrong in this code\\nclass Solution {\\npublic:\\n int solve(int curr, int prev, vector<vector<int> >&dp,string s,int k)\\n    {\\n        if(curr>=s.size()) return 0;\\n        if(dp[curr][prev+1]!=-1) return dp[curr][prev+1];\\n        \\n        int inc=0;\\n        int exc=0;\\n        if(prev==-1 || abs(s[curr]-s[prev]<=k) )\\n        {\\n           inc=1+solve(curr+1,curr,dp,s,k);\\n        }\\n        exc=solve(curr+1,prev,dp,s,k);\\n        //return max(inc,exc);\\n        return dp[curr][prev+1]=max(inc,exc);\\n    }\\n    int longestIdealString(string s, int k) {\\n        int curr=0,prev=-1;\\n        int n=s.size();\\n        vector<vector<int> >dp(n,vector<int>(n+1,-1));\\n        return solve(curr,prev,dp,s,k);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "CursedAiM",
                        "content": "Store int(s[i]-\\'a\\') instead of the index (prev) itself. The time complexity via the latter would be O(n^2) while the former would be O(27*n). The constraints mean the solution should be better than O(n^2) and thats why you are getting TLE. There is also a typo in your code in the if condition, the brackets position in the abs() part."
                    },
                    {
                        "username": "mohit_srivastava",
                        "content": "`Don't know how to convert this code to memorization dp?` \nclass Solution {  \npublic:\n    int longestIdealString(string s, int k) {\n       vector<>  \n        int a=newf(s,k,0,\"\");\n        return a;\n    }\n   int newf(string s,int k,int i,string c){\n        if(i==s.length())\n        {\n            \n             return c.length();\n        }\n        \n         else if(c.size()==0)\n         return max(newf(s,k,i+1,c+s[i]),newf(s,k,i+1,c));\n         else if(abs(s[i]-c[c.size()-1])<=k){\n          return  max(newf(s,k,i+1,c+s[i]),newf(s,k,i+1,c));\n         }\n         else{\n             return newf(s,k,i+1,c);\n         }\n    }\n} "
                    },
                    {
                        "username": "SriShourya001",
                        "content": "Don\\'t know why my solution is giving TLE?\\n\\n```cpp\\nclass Solution {\\npublic:\\nvector<vector<int>>t;\\n    int helper(string s, int k, int i, int prev ){\\n        if(i==s.length()) return 0;\\n\\n        if(t[i][prev+1]!=-1) return t[i][prev+1];\\n\\n        int ex, in;\\n        ex = helper(s,k,i+1,prev);\\n        in = 0;\\n        if(prev==-1 || abs(s[i]-s[prev])<=k){\\n\\n            in = 1+ helper(s,k,i+1, i);\\n        }\\n        return t[i][prev+1] = max(in,ex);\\n    }\\n    int longestIdealString(string s, int k) {\\n        int n = s.length();\\n        t.resize(n, vector<int>(n+1,-1));\\n        return helper(s,k,0,-1);\\n    }\\n};\\n```\\n\\n"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "Try storing the previous character\\'s ASCII code instead of storing it\\'s index"
                    }
                ]
            },
            {
                "id": 1795566,
                "content": [
                    {
                        "username": "real_potatohead",
                        "content": "The use of ASCII character rather than the index in the prev was quite tricky to understand in the first go, got TLE several times\\uD83E\\uDD72"
                    },
                    {
                        "username": "mayankindia0122",
                        "content": "// can anyone tell me what is wrong in this code\\nclass Solution {\\npublic:\\n int solve(int curr, int prev, vector<vector<int> >&dp,string s,int k)\\n    {\\n        if(curr>=s.size()) return 0;\\n        if(dp[curr][prev+1]!=-1) return dp[curr][prev+1];\\n        \\n        int inc=0;\\n        int exc=0;\\n        if(prev==-1 || abs(s[curr]-s[prev]<=k) )\\n        {\\n           inc=1+solve(curr+1,curr,dp,s,k);\\n        }\\n        exc=solve(curr+1,prev,dp,s,k);\\n        //return max(inc,exc);\\n        return dp[curr][prev+1]=max(inc,exc);\\n    }\\n    int longestIdealString(string s, int k) {\\n        int curr=0,prev=-1;\\n        int n=s.size();\\n        vector<vector<int> >dp(n,vector<int>(n+1,-1));\\n        return solve(curr,prev,dp,s,k);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "CursedAiM",
                        "content": "Store int(s[i]-\\'a\\') instead of the index (prev) itself. The time complexity via the latter would be O(n^2) while the former would be O(27*n). The constraints mean the solution should be better than O(n^2) and thats why you are getting TLE. There is also a typo in your code in the if condition, the brackets position in the abs() part."
                    },
                    {
                        "username": "mohit_srivastava",
                        "content": "`Don't know how to convert this code to memorization dp?` \nclass Solution {  \npublic:\n    int longestIdealString(string s, int k) {\n       vector<>  \n        int a=newf(s,k,0,\"\");\n        return a;\n    }\n   int newf(string s,int k,int i,string c){\n        if(i==s.length())\n        {\n            \n             return c.length();\n        }\n        \n         else if(c.size()==0)\n         return max(newf(s,k,i+1,c+s[i]),newf(s,k,i+1,c));\n         else if(abs(s[i]-c[c.size()-1])<=k){\n          return  max(newf(s,k,i+1,c+s[i]),newf(s,k,i+1,c));\n         }\n         else{\n             return newf(s,k,i+1,c);\n         }\n    }\n} "
                    },
                    {
                        "username": "SriShourya001",
                        "content": "Don\\'t know why my solution is giving TLE?\\n\\n```cpp\\nclass Solution {\\npublic:\\nvector<vector<int>>t;\\n    int helper(string s, int k, int i, int prev ){\\n        if(i==s.length()) return 0;\\n\\n        if(t[i][prev+1]!=-1) return t[i][prev+1];\\n\\n        int ex, in;\\n        ex = helper(s,k,i+1,prev);\\n        in = 0;\\n        if(prev==-1 || abs(s[i]-s[prev])<=k){\\n\\n            in = 1+ helper(s,k,i+1, i);\\n        }\\n        return t[i][prev+1] = max(in,ex);\\n    }\\n    int longestIdealString(string s, int k) {\\n        int n = s.length();\\n        t.resize(n, vector<int>(n+1,-1));\\n        return helper(s,k,0,-1);\\n    }\\n};\\n```\\n\\n"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "Try storing the previous character\\'s ASCII code instead of storing it\\'s index"
                    }
                ]
            },
            {
                "id": 1789180,
                "content": [
                    {
                        "username": "real_potatohead",
                        "content": "The use of ASCII character rather than the index in the prev was quite tricky to understand in the first go, got TLE several times\\uD83E\\uDD72"
                    },
                    {
                        "username": "mayankindia0122",
                        "content": "// can anyone tell me what is wrong in this code\\nclass Solution {\\npublic:\\n int solve(int curr, int prev, vector<vector<int> >&dp,string s,int k)\\n    {\\n        if(curr>=s.size()) return 0;\\n        if(dp[curr][prev+1]!=-1) return dp[curr][prev+1];\\n        \\n        int inc=0;\\n        int exc=0;\\n        if(prev==-1 || abs(s[curr]-s[prev]<=k) )\\n        {\\n           inc=1+solve(curr+1,curr,dp,s,k);\\n        }\\n        exc=solve(curr+1,prev,dp,s,k);\\n        //return max(inc,exc);\\n        return dp[curr][prev+1]=max(inc,exc);\\n    }\\n    int longestIdealString(string s, int k) {\\n        int curr=0,prev=-1;\\n        int n=s.size();\\n        vector<vector<int> >dp(n,vector<int>(n+1,-1));\\n        return solve(curr,prev,dp,s,k);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "CursedAiM",
                        "content": "Store int(s[i]-\\'a\\') instead of the index (prev) itself. The time complexity via the latter would be O(n^2) while the former would be O(27*n). The constraints mean the solution should be better than O(n^2) and thats why you are getting TLE. There is also a typo in your code in the if condition, the brackets position in the abs() part."
                    },
                    {
                        "username": "mohit_srivastava",
                        "content": "`Don't know how to convert this code to memorization dp?` \nclass Solution {  \npublic:\n    int longestIdealString(string s, int k) {\n       vector<>  \n        int a=newf(s,k,0,\"\");\n        return a;\n    }\n   int newf(string s,int k,int i,string c){\n        if(i==s.length())\n        {\n            \n             return c.length();\n        }\n        \n         else if(c.size()==0)\n         return max(newf(s,k,i+1,c+s[i]),newf(s,k,i+1,c));\n         else if(abs(s[i]-c[c.size()-1])<=k){\n          return  max(newf(s,k,i+1,c+s[i]),newf(s,k,i+1,c));\n         }\n         else{\n             return newf(s,k,i+1,c);\n         }\n    }\n} "
                    },
                    {
                        "username": "SriShourya001",
                        "content": "Don\\'t know why my solution is giving TLE?\\n\\n```cpp\\nclass Solution {\\npublic:\\nvector<vector<int>>t;\\n    int helper(string s, int k, int i, int prev ){\\n        if(i==s.length()) return 0;\\n\\n        if(t[i][prev+1]!=-1) return t[i][prev+1];\\n\\n        int ex, in;\\n        ex = helper(s,k,i+1,prev);\\n        in = 0;\\n        if(prev==-1 || abs(s[i]-s[prev])<=k){\\n\\n            in = 1+ helper(s,k,i+1, i);\\n        }\\n        return t[i][prev+1] = max(in,ex);\\n    }\\n    int longestIdealString(string s, int k) {\\n        int n = s.length();\\n        t.resize(n, vector<int>(n+1,-1));\\n        return helper(s,k,0,-1);\\n    }\\n};\\n```\\n\\n"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "Try storing the previous character\\'s ASCII code instead of storing it\\'s index"
                    }
                ]
            },
            {
                "id": 1685975,
                "content": [
                    {
                        "username": "real_potatohead",
                        "content": "The use of ASCII character rather than the index in the prev was quite tricky to understand in the first go, got TLE several times\\uD83E\\uDD72"
                    },
                    {
                        "username": "mayankindia0122",
                        "content": "// can anyone tell me what is wrong in this code\\nclass Solution {\\npublic:\\n int solve(int curr, int prev, vector<vector<int> >&dp,string s,int k)\\n    {\\n        if(curr>=s.size()) return 0;\\n        if(dp[curr][prev+1]!=-1) return dp[curr][prev+1];\\n        \\n        int inc=0;\\n        int exc=0;\\n        if(prev==-1 || abs(s[curr]-s[prev]<=k) )\\n        {\\n           inc=1+solve(curr+1,curr,dp,s,k);\\n        }\\n        exc=solve(curr+1,prev,dp,s,k);\\n        //return max(inc,exc);\\n        return dp[curr][prev+1]=max(inc,exc);\\n    }\\n    int longestIdealString(string s, int k) {\\n        int curr=0,prev=-1;\\n        int n=s.size();\\n        vector<vector<int> >dp(n,vector<int>(n+1,-1));\\n        return solve(curr,prev,dp,s,k);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "CursedAiM",
                        "content": "Store int(s[i]-\\'a\\') instead of the index (prev) itself. The time complexity via the latter would be O(n^2) while the former would be O(27*n). The constraints mean the solution should be better than O(n^2) and thats why you are getting TLE. There is also a typo in your code in the if condition, the brackets position in the abs() part."
                    },
                    {
                        "username": "mohit_srivastava",
                        "content": "`Don't know how to convert this code to memorization dp?` \nclass Solution {  \npublic:\n    int longestIdealString(string s, int k) {\n       vector<>  \n        int a=newf(s,k,0,\"\");\n        return a;\n    }\n   int newf(string s,int k,int i,string c){\n        if(i==s.length())\n        {\n            \n             return c.length();\n        }\n        \n         else if(c.size()==0)\n         return max(newf(s,k,i+1,c+s[i]),newf(s,k,i+1,c));\n         else if(abs(s[i]-c[c.size()-1])<=k){\n          return  max(newf(s,k,i+1,c+s[i]),newf(s,k,i+1,c));\n         }\n         else{\n             return newf(s,k,i+1,c);\n         }\n    }\n} "
                    },
                    {
                        "username": "SriShourya001",
                        "content": "Don\\'t know why my solution is giving TLE?\\n\\n```cpp\\nclass Solution {\\npublic:\\nvector<vector<int>>t;\\n    int helper(string s, int k, int i, int prev ){\\n        if(i==s.length()) return 0;\\n\\n        if(t[i][prev+1]!=-1) return t[i][prev+1];\\n\\n        int ex, in;\\n        ex = helper(s,k,i+1,prev);\\n        in = 0;\\n        if(prev==-1 || abs(s[i]-s[prev])<=k){\\n\\n            in = 1+ helper(s,k,i+1, i);\\n        }\\n        return t[i][prev+1] = max(in,ex);\\n    }\\n    int longestIdealString(string s, int k) {\\n        int n = s.length();\\n        t.resize(n, vector<int>(n+1,-1));\\n        return helper(s,k,0,-1);\\n    }\\n};\\n```\\n\\n"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "Try storing the previous character\\'s ASCII code instead of storing it\\'s index"
                    }
                ]
            }
        ]
    }
]