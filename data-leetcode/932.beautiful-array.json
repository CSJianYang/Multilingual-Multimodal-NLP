[
    {
        "title": "Beautiful Array",
        "question_content": "An array nums of length n is beautiful if:\n\n\tnums is a permutation of the integers in the range [1, n].\n\tFor every 0 <= i < j < n, there is no index k with i < k < j where 2 * nums[k] == nums[i] + nums[j].\n\nGiven the integer n, return any beautiful array nums of length n. There will be at least one valid answer for the given n.\n&nbsp;\nExample 1:\nInput: n = 4\nOutput: [2,1,4,3]\nExample 2:\nInput: n = 5\nOutput: [3,1,2,5,4]\n&nbsp;\nConstraints:\n\n\t1 <= n <= 1000",
        "solutions": [
            {
                "id": 186679,
                "title": "odd-even-pattern-o-n",
                "content": "# **Intuition**:\\nTry to divide and conquer,\\nso we have left part, right part.\\n\\nOne way is to divide into [1, N / 2] and [N / 2 + 1, N].\\nBut it will cause problems when we merge them.\\n\\nAnother way is to divide into odds part and evens part.\\nSo there is no `k` with `A[k] * 2 = odd + even`\\n\\nI brute force all permutations when N = 5:\\n20 beautiful array found,\\nonly 4 don\\'t fit odd + even pattern:\\n`[2, 1, 4, 5, 3]`\\n`[3, 1, 2, 5, 4]`\\n`[3, 5, 4, 1, 2]`\\n`[4, 5, 2, 1, 3]`\\n</br>\\n\\n# **Beautiful Array Properties**\\n\\nSaying that an array is beautiful,\\nthere is no `i < k < j`,\\nsuch that `A[k] * 2 = A[i] + A[j]`\\n\\nApply these 3 following changes a beautiful array,\\nwe can get a new beautiful array\\n</br>\\n\\n**1. Deletion**\\nEasy to prove.\\n\\n**2. Addition**\\nIf we have `A[k] * 2 != A[i] + A[j]`,\\n`(A[k] + x) * 2 = A[k] * 2 + 2x != A[i] + A[j] + 2x = (A[i] + x) + (A[j] + x)`\\n\\nE.g: `[1,3,2] + 1  = [2,4,3]`.\\n\\n\\n**3. Multiplication**\\nIf we have `A[k] * 2 != A[i] + A[j]`,\\nfor any `x != 0`,\\n`(A[k] * x) * 2 = A[k] * 2 * x != (A[i] + A[j]) * x = (A[i] * x) + (A[j] * x)`\\n\\nE.g: `[1,3,2] * 2  = [2,6,4]`\\n</br>\\n\\n# **Explanation**\\nWith the observations above, we can easily construct any beautiful array.\\nAssume we have a beautiful array `A` with length `N`\\n\\n`A1 = A * 2 - 1` is beautiful with only odds from `1` to `N * 2 -1`\\n`A2 = A * 2` is beautiful with only even from `2` to `N * 2`\\n`B = A1 + A2` beautiful array with length `N * 2`\\n\\nE.g:\\n```\\nA = [2, 1, 4, 5, 3]\\nA1 = [3, 1, 7, 9, 5]\\nA2 = [4, 2, 8, 10, 6]\\nB = A1 + A2 = [3, 1, 7, 9, 5, 4, 2, 8, 10, 6]\\n```\\n</br>\\n\\n# **Time Complexity**:\\nI have iteration version here `O(N)`\\nNaive recursion is `O(NlogN)`\\nRecursion with one call or with cache is `O(N)`\\n</br>\\n# **Solution**:\\n**C++:**\\n```\\n    vector<int> beautifulArray(int N) {\\n        vector<int> res = {1};\\n        while (res.size() < N) {\\n            vector<int> tmp;\\n            for (int i : res) if (i * 2 - 1 <= N) tmp.push_back(i * 2 - 1);\\n            for (int i : res) if (i * 2 <= N) tmp.push_back(i * 2);\\n            res = tmp;\\n        }\\n        return res;\\n    }\\n```\\n\\n**Java:**\\n```\\n    public int[] beautifulArray(int N) {\\n        ArrayList<Integer> res = new ArrayList<>();\\n        res.add(1);\\n        while (res.size() < N) {\\n            ArrayList<Integer> tmp = new ArrayList<>();\\n            for (int i : res) if (i * 2 - 1 <= N) tmp.add(i * 2 - 1);\\n            for (int i : res) if (i * 2 <= N) tmp.add(i * 2);\\n            res = tmp;\\n        }\\n        return res.stream().mapToInt(i -> i).toArray();\\n    }\\n```\\n\\n**Python:**\\n```\\n    def beautifulArray(self, N):\\n        res = [1]\\n        while len(res) < N:\\n            res = [i * 2 - 1 for i in res] + [i * 2 for i in res]\\n        return [i for i in res if i <= N]\\n```\\n</br>\\n\\n## **Advanced**:\\nSome other ideas: https://leetcode.com/problems/beautiful-array/discuss/186680\\nAuthor: lee215\\n",
                "solutionTags": [],
                "code": "```\\nA = [2, 1, 4, 5, 3]\\nA1 = [3, 1, 7, 9, 5]\\nA2 = [4, 2, 8, 10, 6]\\nB = A1 + A2 = [3, 1, 7, 9, 5, 4, 2, 8, 10, 6]\\n```\n```\\n    vector<int> beautifulArray(int N) {\\n        vector<int> res = {1};\\n        while (res.size() < N) {\\n            vector<int> tmp;\\n            for (int i : res) if (i * 2 - 1 <= N) tmp.push_back(i * 2 - 1);\\n            for (int i : res) if (i * 2 <= N) tmp.push_back(i * 2);\\n            res = tmp;\\n        }\\n        return res;\\n    }\\n```\n```\\n    public int[] beautifulArray(int N) {\\n        ArrayList<Integer> res = new ArrayList<>();\\n        res.add(1);\\n        while (res.size() < N) {\\n            ArrayList<Integer> tmp = new ArrayList<>();\\n            for (int i : res) if (i * 2 - 1 <= N) tmp.add(i * 2 - 1);\\n            for (int i : res) if (i * 2 <= N) tmp.add(i * 2);\\n            res = tmp;\\n        }\\n        return res.stream().mapToInt(i -> i).toArray();\\n    }\\n```\n```\\n    def beautifulArray(self, N):\\n        res = [1]\\n        while len(res) < N:\\n            res = [i * 2 - 1 for i in res] + [i * 2 for i in res]\\n        return [i for i in res if i <= N]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 187669,
                "title": "share-my-o-nlogn-c-solution-with-proof-and-explanation",
                "content": "---\\n## 1. Problem\\n\\n---\\nFor some fixed ```N```, an array ```A``` is *beautiful* if it is a permutation of the integers ```1, 2, ..., N```, such that:\\n\\nFor every ```i < j```, there is **no** ```k``` with ```i < k < j``` such that ```A[k] * 2 = A[i] + A[j]```.\\n\\nGiven ```N```, return **any** beautiful array ```A```.  (It is guaranteed that one exists.)\\n\\n**Example 1:**\\n```\\nInput: 4\\nOutput: [2,1,4,3]\\n```\\n**Example 2:**\\n```\\nInput: 5\\nOutput: [3,1,2,5,4]\\n```\\nNote:\\n\\n* ```1 <= N <= 1000```\\n\\n---\\n## 2. Thinking process\\n\\n---\\n#### 2.1 Analysis\\n\\n---\\nThe problem is to make a permutation of integers 1 to N in an array A. For every i < j, there is no k with i < k < j such that A[k] * 2 = A[i] + A[j].\\n\\n**A[k]** here is the **average number of A[i] and A[j]**, which means the rule here can be expressed as\\n\\n>#### There is **no average number of A[i] and A[j] between A[i] and A[j]** (i < j).\\n\\nAt first glance, the rule is a little bit complicated, but we can find an **interesting fact**.\\n\\nThe **fact** is\\n\\n>#### **The average number of an odd number and an even one is not an integer.**\\n\\n---\\n#### 2.2 First level partition\\n\\n---\\n\\nIn order to explain the problem easily, here we take **N = 10** as an example.\\n\\nThe numbers to be processed are\\n\\n**Universal set:**\\n>#### **S = [1,2,3,4,5,6,7,8,9,10]**.\\n\\nNow it is divided into 2 subsets **S1** and **S2**:\\n\\n**Subset 1 (odd):**\\n>#### **S1 = [1,3,5,7,9]**.\\n\\nIn **S1**, \\n>#### the **0-th binary digit(LSB) of all elements** are **same (equals 1)**.\\nwhich means for **all A[i] \\u2208 S1**\\n>#### **A[i] & 1 \\u2260 0**.\\n\\n**Subset 2 (even):**\\n>#### **S2 = [2,4,6,8,10]**.\\n\\nIn **S2**, \\n>#### the **0-th binary digit(LSB) of all elements** are **same (equals 0)**.\\nwhich means for **all A[i] \\u2208 S2**\\n>#### **A[i] & 1 = 0**.\\n\\nNow think about the average of **all A[i]-A[j] pairs** (i < j) in the **universal set**, there are **3 situations**:\\n1. **one** from **S1**, **the other** also from **S1**. **The average** may be\\n    * in **S1** (for example: 1 and 5, the average is 3).\\n    * in **S2** (for example: 1 and 3, the average is 2).\\n2. **one** from **S2**, **the other** also from **S2**. **The average** may be\\n    * in **S1** (for example: 2 and 4, the average is 3).\\n    * in **S2** (for example: 2 and 6, the average is 4).\\n3. **one** from **S1**, **the other** from **S2**. **The average** is **NOT** in **both S1 and S2**.\\n\\nIf we put all numbers of **S1** **before** all numbers of **S2**, we will get a permutation\\n>#### [**1**,**3**,**5**,**7**,**9**,*2*,*4*,*6*,*8*,*10*].\\n\\nIn this case, there are no need for us to worry about situation 3.\\n>#### **S1** and **S2** may be processed **separately**.\\n\\nBut how?\\n\\n---\\n#### 2.3 Second level partition\\n\\n---\\nIn section 2.2, although the position of a certain element in S hasn\\'t been determined yet, the relative position of all S1 elements and S2 elements has been determined.\\n\\nThe **Exclusion Rule** is\\n>#### After **dividing the universal set S into 2 subsets S1 and S2**, it should be **guaranteed** that\\n>#### For **any A[i] \\u2208 S1, A[j] \\u2208 S2**, **the average of A[i] and A[j] will NOT appear in BOTH S1 and S2.**\\n\\nIf the **universal set** is **S1 in section 2.2**, can it be divided into **2 new Subsets** following the **Exclusion Rule**?\\n\\nSince **S1 is an odd set**, all its elements p can be expressed as\\n>#### **p = 2k + 1**.\\n\\nChoosing 2 elements **m, n \\u2208 S1**, if\\n\\n>#### **m = 2x + 1, n = 2y + 1**.\\n\\nthe average will be\\n\\n>#### **(m + n)/2 = x + y + 1**.\\n\\nAs the rule says, if S1 can be divided into 2 subsets, the average\\n\\n>#### **x + y + 1** is **not in S1**.\\n\\nwhich means\\n\\n>#### **x + y + 1** is **even**, **x + y** is **odd**.\\n>#### **x** and **y** have **different parity**.\\n\\nNow S1 can be divided into 2 subsets according to k = (A[i] - 1) / 2.\\n**Subset 1.1 (odd k):**\\n>#### **S11 = [3,7]**.\\n\\nIn **S11**, \\n>#### **the 1-st, 0-th binary digits of all elements** are **same (equals 11)**.\\nwhich means for **all A[i] \\u2208 S11**\\n>#### **A[i] & 2 \\u2260 0**.\\n\\n**Subset 1.2 (even k):**\\n>#### **S12 = [1,5,9]**.\\n\\nIn **S12**, \\n>#### **the 1-st, 0-th binary digits of all elements** are **same (equals 01)**.\\nwhich means for **all A[i] \\u2208 S12**\\n>#### **A[i] & 2 = 0**.\\n\\n---\\n\\nNow we focus on S2.\\n\\nIf the **universal set** is **S2 in section 2.2**, can it be divided into **2 new Subsets** following the **Exclusion Rule**?\\n\\nSince **S2 is an even set**, all its elements p can be expressed as\\n>#### **p = 2k**.\\n\\nChoosing 2 elements **m, n \\u2208 S2**, if\\n\\n>#### **m = 2x, n = 2y**.\\n\\nthe average will be\\n\\n>#### **(m + n)/2 = x + y**.\\n\\nAs the rule says, if S2 can be divided into 2 subsets, the average\\n\\n>#### **x + y** is **not in S2**.\\n\\nwhich means\\n\\n>#### **x + y** is **odd**.\\n>#### **x** and **y** have **different parity**.\\n\\nNow S2 can be divided into 2 subsets according to k = A[i] / 2.\\n**Subset 2.1 (odd k):**\\n>#### **S21 = [2,6,10]**.\\n\\nIn **S21**, \\n>#### **the 1-st, 0-th binary digits of all elements** are **same (equals 10)**.\\nwhich means for **all A[i] \\u2208 S21**\\n>#### **A[i] & 2 \\u2260 0**.\\n\\n**Subset 2.2 (even k):**\\n>#### **S22 = [4,8]**.\\n\\nIn **S22**, \\n>#### **the 1-st, 0-th binary digits of all elements** are **same (equals 00)**.\\nwhich means for **all A[i] \\u2208 S22**\\n>#### **A[i] & 2 = 0**.\\n\\nAfter first and second level partition, the permutation becomes\\n>#### [**3**,**7**,*1*,*5*,*9*,***2***,***6***,***10***,4,8].\\n\\n---\\n#### 2.4 Two guesses\\n\\n---\\nIf A[i]\\'s binary representation is\\n\\n>#### **A[i] = M(r)M(r-1)M(r-2)...M(0), M(i) = 0 or 1, 0 \\u2264 i \\u2264 r, r > 0**.\\n\\nThe **first level partition** focuses on **A[i] & 1 - in other words, the 1st LSB M(0)**.\\n\\n* If M(0) = 1, A[i] \\u2208 S1. If M(0) = 0, A[i] \\u2208 S2.\\n\\nThe **second level partition** focuses on **A[i] & 2 - in other words, the 2nd LSB M(1)**.\\n\\n* If M(0) = 1,\\n  * If M(1) = 1, A[i] \\u2208 S11.\\n  * If M(1) = 0, A[i] \\u2208 S12.\\n* If M(0) = 0,\\n  * If M(1) = 1, A[i] \\u2208 S21.\\n  * If M(1) = 0, A[i] \\u2208 S22.\\n\\n**......**\\n\\nwe can infer that the **Partition Rule** is\\n>#### The k-th (k > 0) level partition is based on A[i] & 2^(k - 1) - in other words, the k-th LSB M(k-1) is 1 or 0.\\n\\nAs shown in section 2.2 and 2.3,\\n\\nAfter **first level partition**,\\n\\n>#### The **0-th binary digit (1 least significant bit, LSB)** of all elements in S1 (or S2) are **same**. \\n\\nAfter **second level partition**,\\n\\n>#### The **1-st, 0-th binary digits (2 LSBs)** of all elements in S11 (or S12, S21, S22) are same.\\n\\n**......**\\n\\nwe guess\\n\\n**Guess A:**\\nIf we follow the **Partition Rule**,\\n\\n>#### **after k-th (k > 0) level partition, the k LSBs of all elements in each generated subsets are same.**\\n\\n**Guess B:**\\nIf we follow the **Partition Rule**,\\n\\n>#### **the generated subsets will ALWAYS satisfy the Exclusion Rule in section 2.3.**\\n\\n---\\n#### 2.5 Proof\\n\\n---\\nIn order to prove Guess A and B, the mathematical Induction is applied.\\n\\n**Guess A:**\\n\\nif we follow the **Partition Rule**\\n\\n**Base case:**\\n\\nWhen k = 1, as shown in section 2.2,\\n\\nafter first level partition, the LSB of all elements in each generated subsets (S1 or S2) are same.\\n\\n**Step case:**\\n\\nAfter k-th level partition, the k LSBs of all elements in each generated subsets are same.\\n\\nChoosing any subset U generated after k-th level partition,\\n\\nsupposing the k+1 LSBs of one element x \\u2208 U is M(k)M(k-1)...M(0).\\n\\nwhen doing the k+1-th partition, the binary digit M(k) will be checked,\\n\\n* If M(k) = 1, x \\u2208 U1.\\n* If M(k) = 0, x \\u2208 U2.\\n\\nBefore k+1-th partition, all elements in U have same M(k-1)...M(0).\\n\\nAfter k+1-th partition, all elements with same M(k) are put into one subset, which means\\n\\n>#### **all elements in U1 (or U2) have same M(k)M(k-1)... M(0) (k + 1 LSBs). Proved.**\\n\\n---\\n**Guess B:**\\n\\nFor any elements A[i] \\u2208 S1, A[j] \\u2208 S2, if we follow the **Partition Rule**,\\n\\n**Base case:**\\n\\nWhen k = 1, as shown in section 2.2,\\n\\nif we follows the **Partition Rule**, the average of any A[i]-A[j] pair is not an integer. (not in both S1 and S2).\\n\\n**Step case:**\\n\\nAs proved Guess A, after k-th level partition, the k LSBs of all elements in each generated subsets are same.\\n\\nChoosing any subset U generated after k-th level partition,\\n\\nsupposing the k+1 LSBs of one element x \\u2208 U is M(k)M(k-1)...M(0).\\n\\nwhen doing the k+1-th partition, the binary digit M(k) will be checked,\\n\\n- If M(k) = 1, x \\u2208 U1.\\n- If M(k) = 0, x \\u2208 U2.\\n\\nChoosing any A[i] \\u2208 U1, A[j] \\u2208 U2\\n\\nif P is odd, Q is even (P,Q \\u2265 0), and\\n\\n>#### **res = M(k-1)...M(0).**\\n\\nA[i] and A[j] can be represented as\\n\\n>#### **A[i] = P \\xD7 2^k + res.**\\n\\n>#### **A[j] = Q \\xD7 2^k + res.**\\n\\nThe average\\n\\n>#### **(A[i] + A[j])/2 = (P + Q) \\xD7 2^(k - 1) + res.**\\n\\nSince P is odd, Q is even, P + Q is odd, which means\\n\\n>#### **1 will be added to M(k-1) - the most significant bit (MSB) of res.**\\n\\nwhich means\\n\\n>#### **The k LSBs of the average is different from those of both A[i] and A[j].**\\n\\nThat is to say,\\n\\n>#### **The average is not in both U1 and U2. Proved.**\\n\\n---\\n## 3. Algorithm\\n\\n---\\n\\nAs been discussed above, this is a divide and conquer problem, which is suitable for recursion.\\n\\n**Stop situation:**\\n\\nWhen the generated subset\\'s size is small enough (contains **0** or **1** element), the recursion should stop.\\n\\n**Recursion logic:**\\n\\nAs the problem can be treated as a special sorting problem, \\n\\nthe whole logic can be divided into patition part and sorting part .\\n\\nWhen sorting, there are 4 inputs,\\n\\n* vector **v**.\\n* start index **start**.\\n* end index **end**.\\n* **mask** for judging elements and put them into subsets.\\n\\nAfter the inputs are introduced to partition part,\\n\\nthe elements in **v** from **start** to **end** are swapped like doing quicksort, the border index **mid** is returned.\\n\\nAfter doing partition\\n\\n* all elements from index **start** to index **mid - 1** belongs to Subset **1**.\\n\\n* all elements from index **mid** to index **end** belongs to Subset **2**.\\n\\nWhen the partition finished, we can sort on **start** to **mid - 1** and **mid** to **end** recursively, \\n\\nAccoring to the **Partition Rule**, the **mask** should be **doubled**.\\n\\n**Initial values:**\\n\\n* v = [1,2,3,4,...,N].\\n* start = 0.\\n* end = N-1.\\n* mask = 1.\\n\\n---\\n## 4. Complexity Analysis\\n\\n---\\n\\n#### 4.1 Time complexity\\n\\n---\\nOn each level, the recursion branch will iterate over all elements.\\n\\nOn k-th level, the k-th LSB will be checked. \\n\\nThe number of iteration will be **AT MOST log2N**.\\n\\n>#### The time complexity is **O(NlogN)**.\\n\\n---\\n\\n#### 4.2 Space complexity\\n\\n---\\n\\nThe algorithm is an **in-place implementation**. \\nAs it\\'s a recursion algorithm, and the depth of the recursion tree is AT MOST log2N.\\n\\n>#### The space complexity is **O(N)**.\\n\\n---\\n## 5. Code\\n\\n---\\n```\\nclass Solution {\\npublic:\\n    int partition(vector<int> &v, int start, int end, int mask)\\n    {\\n        int j = start;\\n        for(int i = start; i <= end; i++)\\n        {\\n            if((v[i] & mask) != 0)\\n            {\\n                swap(v[i], v[j]);\\n                j++;\\n            }\\n        }\\n        return j;\\n    }\\n    \\n    void sort(vector<int> & v, int start, int end, int mask)\\n    {\\n        if(start >= end) return;\\n        int mid = partition(v, start, end, mask);\\n        sort(v, start, mid - 1, mask << 1);\\n        sort(v, mid, end, mask << 1);\\n    }\\n    \\n    vector<int> beautifulArray(int N) {\\n        vector<int> ans;\\n        for(int i = 0; i < N; i++) ans.push_back(i + 1);\\n        sort(ans, 0, N - 1, 1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Divide and Conquer"
                ],
                "code": "```N```\n```A```\n```1, 2, ..., N```\n```i < j```\n```k```\n```i < k < j```\n```A[k] * 2 = A[i] + A[j]```\n```N```\n```A```\n```\\nInput: 4\\nOutput: [2,1,4,3]\\n```\n```\\nInput: 5\\nOutput: [3,1,2,5,4]\\n```\n```1 <= N <= 1000```\n```\\nclass Solution {\\npublic:\\n    int partition(vector<int> &v, int start, int end, int mask)\\n    {\\n        int j = start;\\n        for(int i = start; i <= end; i++)\\n        {\\n            if((v[i] & mask) != 0)\\n            {\\n                swap(v[i], v[j]);\\n                j++;\\n            }\\n        }\\n        return j;\\n    }\\n    \\n    void sort(vector<int> & v, int start, int end, int mask)\\n    {\\n        if(start >= end) return;\\n        int mid = partition(v, start, end, mask);\\n        sort(v, start, mid - 1, mask << 1);\\n        sort(v, mid, end, mask << 1);\\n    }\\n    \\n    vector<int> beautifulArray(int N) {\\n        vector<int> ans;\\n        for(int i = 0; i < N; i++) ans.push_back(i + 1);\\n        sort(ans, 0, N - 1, 1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186680,
                "title": "python-three-1-line-solutions",
                "content": "Sort by reversed binary\\n```\\n    def beautifulArray(self, N):\\n        return sorted(range(1, N + 1), key=lambda x: bin(x)[:1:-1])\\n```\\n\\nNaive recursion\\n```\\n    def beautifulArray(self, N):\\n        return [i * 2 for i in self.beautifulArray(N / 2)] + [i * 2 - 1 for i in self.beautifulArray((N + 1) / 2)] if N > 1 else [1]\\n```\\n\\nBinary Reverse\\n```\\n    def beautifulArray(self, N):\\n        return [i for i in [int(\\'{:010b}\\'.format(i)[::-1], 2) for i in range(1, 1 << 10)] if i <= N]\\n```",
                "solutionTags": [],
                "code": "```\\n    def beautifulArray(self, N):\\n        return sorted(range(1, N + 1), key=lambda x: bin(x)[:1:-1])\\n```\n```\\n    def beautifulArray(self, N):\\n        return [i * 2 for i in self.beautifulArray(N / 2)] + [i * 2 - 1 for i in self.beautifulArray((N + 1) / 2)] if N > 1 else [1]\\n```\n```\\n    def beautifulArray(self, N):\\n        return [i for i in [int(\\'{:010b}\\'.format(i)[::-1], 2) for i in range(1, 1 << 10)] if i <= N]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 583910,
                "title": "easy-explanation-of-concept-concise-c",
                "content": "Credit : i_love_xiaoshagua_cpp for code.\\nUPVOTE will be highly appreciated!\\n\\nFirstly we must understand that :PROPERTY 1: given a series of beautiful-array if we\\n* multiply each element by 2 OR\\n* multiply each element by 2 and subtract one from it\\n\\nthe resulting series is also beautiful (just take them a,b,c and try out, the twos get cancelled in A[k] * 2 = A[i] + A[j].)\\n\\nPROPERTY 2 : Now second thing is combining two beautiful arrays:\\n RESULT  = {ARRAY ONE} {ARRAY TWO}\\n If array one & array two are beautiful then\\n if array one is made up of all odd nos. and array 2 is made up of all even nos.\\n And let a1 & a2 be elements from array1 and array2 respectively.\\n (a1+a2)/2 is fraction and is not present in resulting array thus by 3 reasons:\\n \\n*array1 is beautiful  \\n*array2 is beautiful  \\n*(a1+a2)/2 is fraction and is not present in resulting array\\n\\nresulting array is also beautiful.\\n\\nNow lastly to make a beautiful array of N.\\n* make beautiful array of all even nos. till N \\n* make beautiful array of all odd nos. till N \\nJOIN them up !\\n\\nTo make beautiful arrays of all even and odd smaller than N will use property 1.\\n\\nEx: For N = 5        beautiful( { 2 , 4 } ) +  beautiful( { 1 , 3 , 5} )\\n\\nTo get beautiful of { 2 , 4 } get beautiful of N = 2 and multiply by 2\\nTo get beautiful of { 1 , 3 , 5}  get beautiful of N = 3 and multiply by 2 and subtract by 1.\\nThen JOIN them !\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        if(n==1)\\n            return {1};\\n        vector<int> even = beautifulArray(n/2);\\n        vector<int> odd = beautifulArray(n-(n/2));\\n        vector<int>ans;\\n        for(auto e:even)\\n            ans.push_back(2*e);\\n        for(auto e:odd)\\n            ans.push_back((2*e)-1);\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        if(n==1)\\n            return {1};\\n        vector<int> even = beautifulArray(n/2);\\n        vector<int> odd = beautifulArray(n-(n/2));\\n        vector<int>ans;\\n        for(auto e:even)\\n            ans.push_back(2*e);\\n        for(auto e:odd)\\n            ans.push_back((2*e)-1);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368125,
                "title": "detailed-explanation-with-diagrams-a-collection-of-ideas-from-multiple-posts-python3",
                "content": "## 0. Introduction\\nThis post is a collection of all the posts, comments and discussions of the LeetCode community. References mentioned at the bottom! I\\'ve attempted to explain things in detail, with diagrams to help understand the intuitions as well.\\n\\n## 1. Naive Solution\\nThe first thing anyone can think of is using `permutations(array)` to enumerate all the permutations in `O(N!)` time. This is bad in itself, but it gets worse. We still need to check the validity of the resultant array. We can do this in `O(N^3)` time, iterative over every possible combination of `i`, `j` and `k`.\\n\\nBelow is the code for it.\\n```\\nfrom itertools import permutations\\nclass Solution:\\n    def invalid(self, x):\\n        n = len(x)\\n        flag = False\\n        for i in range(n):\\n            if flag: break\\n            for j in range(i+2, n):\\n                if flag: break\\n                for k in range(i+1, j):\\n                    if 2*x[k] == x[i]+x[j]: flag = True; break\\n        return flag\\n        \\n    def beautifulArray(self, n: int) -> List[int]:\\n        for perm in permutations(range(1, n+1)):\\n            if not self.invalid(perm):\\n                return perm\\n```\\n\\nThis is clearly a dead end. The time complexity is enormous and impractical. But, what to do?\\n\\n## 2. Thinking in Terms of Bits\\n**Whenever stuck, think in terms of bits.**\\n\\nIt always helps to think in terms of bits, so let\\'s do that. Reformulating the problem, `nums[i]+nums[j] = 2*nums[k]` is not allowed.\\n\\nIn terms of bits, we can start with thinking what would happen if `nums[i]` or `nums[j]` is odd or even.\\n\\n\\n| nums[i] | nums[j] |   nums[k]    |\\n| ------- | ------- |:------------:|\\n| even    | even    |   even/odd   |\\n| odd     | odd     |   even/odd   |\\n| even    | odd     | non-existent |\\n| odd     | even    | non-existent |\\n\\n**Clearly, it looks like we want to focus on the last two cases. Ensuring that will ensure the validity of the solution.**\\n\\n## 3. Finding Recursion\\nWe know splitting the array into odds and evens is beneficial. The trivial case is `[odd numbers here] [even numbers here]`, or the opposite `[even numbers here] [odd numbers here]`. Both will work. For convenience, I\\'ll take the first one.\\n\\nexample: `n = 7`\\n`1 2 3 4 5 6 7` -> `1 3 5 7 | 2 4 6`\\n\\nThis clearly won\\'t work since `1 3 5 7` and `2 4 6` are troublesome in themselves, but if `i` is pointing to `1 3 5 7` and `j` to `2 4 6`, we can stay safe.\\n\\nNow, what if ... we break the `1 3 5 7` into two again? How? Just do a right-shift operation. (this is one of those problems whose solutions make sense once you know them lmao)\\n\\nThis makes the problem: `0 1 2 3`. Doesn\\'t this look eerily similar to the orignial problem? We can break this down as `1 3 | 0 2`. This will work for `evens` as well (think why). **We have found a recursion!** \\n\\nThe below diagram should explain it better.\\n\\n![](https://i.imgur.com/sxoCWG0.png)\\n\\nNote that the right shifting is done for explaination reasons, the goal is to actually just consider alternate elements. \\n\\n## 4. Code for Recursive Solution\\n```\\nclass Solution:\\n    def recurse(self, nums):\\n        if len(nums) <= 2: return nums\\n        return self.recurse(nums[::2]) + self.recurse(nums[1::2])\\n    \\n    def beautifulArray(self, n: int) -> List[int]:\\n        return self.recurse([i for i in range(1, n+1)])\\n```\\n\\n## 5. One-liner Solution\\nThe final one-liner solution is based on a very interesting observation. Recall how we worked with the trees, where each following height involved right-shifting the binary representation by one. Alternatively, think like this: What happened in the grand scheme? We considered the 0th bit first, then the 1st, then the 2nd and so on.\\n\\n![](https://i.imgur.com/r2w55ie.png)\\n\\nIf you note, this is equivalent to a sorting problem! The only difference is that we are considering the number in reverse, in binary. This brings us to the godly one liner solution by lee215.\\n\\n```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        return sorted(range(1, n+1), key=lambda x: bin(x)[:1:-1])\\n```\\n\\n## 6. References\\n- https://leetcode.com/r0bertz/ \\'s post https://leetcode.com/problems/beautiful-array/discuss/644612/Python3-solution-with-detailed-explanation-Beautiful-Array\\n- https://leetcode.com/lee215/ \\'s post https://leetcode.com/problems/beautiful-array/discuss/186680/Python-Three-1-line-Solutions\\n- https://leetcode.com/lee215/ \\'s post https://leetcode.com/problems/beautiful-array/discuss/186679/Odd-%2B-Even-Pattern-O(N)\\n\\n\\nIf you want another look at the problem in a different format, here\\'s my video explanation.\\nhttps://www.youtube.com/watch?v=jHHdiMIJcr0.\\n\\nFeel free to ask any questions! Criticisms and comments are most welcome. If this helps you, upvote! It gives me motivation to be better :D",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom itertools import permutations\\nclass Solution:\\n    def invalid(self, x):\\n        n = len(x)\\n        flag = False\\n        for i in range(n):\\n            if flag: break\\n            for j in range(i+2, n):\\n                if flag: break\\n                for k in range(i+1, j):\\n                    if 2*x[k] == x[i]+x[j]: flag = True; break\\n        return flag\\n        \\n    def beautifulArray(self, n: int) -> List[int]:\\n        for perm in permutations(range(1, n+1)):\\n            if not self.invalid(perm):\\n                return perm\\n```\n```\\nclass Solution:\\n    def recurse(self, nums):\\n        if len(nums) <= 2: return nums\\n        return self.recurse(nums[::2]) + self.recurse(nums[1::2])\\n    \\n    def beautifulArray(self, n: int) -> List[int]:\\n        return self.recurse([i for i in range(1, n+1)])\\n```\n```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        return sorted(range(1, n+1), key=lambda x: bin(x)[:1:-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367891,
                "title": "python-o-n-solution-with-proof-explained",
                "content": "In this problem we have `n = 1000`, which is too big to use dfs/backtracking, so we need to find some pattern. We need to avoid structures like `i < k < j` with `nums[i] + nums[j] = 2 * nums[k]`, which means that `nums[i]` and `nums[j]` has the same parity: they are both odd or even. This lead us to the following idea: let us split all numbers into `2` groups: all **odd** numbers and then all **even** numbers.\\n\\n`[ odd numbers ] [ even numbers ]`\\n\\nThen if `i, j, k` lies in two different groups, we are OK, we will hever have forbidden pattern. Also, if we look at odd numbers, imagine `n = 12`, then we have `[1, 3, 5, 7, 9, 11]` and if we subtract `1` to each number and divide each number by `2` then we have  `[0, 1, 2, 3, 4, 5]`. Note, that is **linear** transform: when we did this transformation, if we did not have forbidden pattern, we still do not have it! So, what we need to do is to run function recursively for `odd` and `even` numbers and concatenate them.\\n\\n#### Complexity\\nFrom the first sight, time complexity is `O(n log n)`, because we have recursion `C(n) = C(n//2) + C((n+1)//2)`, which lead to `O(n log n)`. However it can be shown that it is `O(n)`. Imagine case `n = 105`, then we have `105 -> (52, 53) -> (26, 26, 27, 27) -> (13, 13, 13, 13, 14, 14, 14, 14)` and if we use memoisation, no need to solve problem each time for `13`, we can do it only once. On each level we will have at most **two** values in our recursion tree. Space complexity is `O(n)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def beautifulArray(self, N):\\n        @lru_cache(None)\\n        def dfs(N):\\n            if N == 1: return (1,)\\n            t1 = dfs((N+1)//2)\\n            t2 = dfs(N//2)\\n            return [i*2-1 for i in t1] + [i*2 for i in t2]\\n        \\n        return dfs(N)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Divide and Conquer",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def beautifulArray(self, N):\\n        @lru_cache(None)\\n        def dfs(N):\\n            if N == 1: return (1,)\\n            t1 = dfs((N+1)//2)\\n            t2 = dfs(N//2)\\n            return [i*2-1 for i in t1] + [i*2 for i in t2]\\n        \\n        return dfs(N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186901,
                "title": "javascript-how-i-understand-the-solution-with-verification-of-the-solution",
                "content": "### How I got the pattern by analysing the answer of input 100\\nI didn\\'t know how to solve this problem but I got the answer right by submitting and checking the right answer of input `100`. \\nYes I got lucky and got it right.\\nThe feedback answer was\\n```\\n[1,65,33,97,17,81,49,9,73,41,25,89,57,5,69,37,21,85,53,13,77,45,29,93,61,3,67,35,99,19,83,51,11,75,43,27,91,59,7,71,39,23,87,55,15,79,47,31,95,63,2,66,34,98,18,82,50,10,74,42,26,90,58,6,70,38,22,86,54,14,78,46,30,94,62,4,68,36,100,20,84,52,12,76,44,28,92,60,8,72,40,24,88,56,16,80,48,32,96,64]\\n```\\nAnd after I analysed it, I find that it can be divided into two parts:\\n```\\n[1,65,33,97,17,81,49,9,73,41,25,89,57,5,69,37,21,85,53,13,77,45,29,93,61,3,67,35,99,19,83,51,11,75,43,27,91,59,7,71,39,23,87,55,15,79,47,31,95,63]\\n[2,66,34,98,18,82,50,10,74,42,26,90,58,6,70,38,22,86,54,14,78,46,30,94,62,4,68,36,100,20,84,52,12,76,44,28,92,60,8,72,40,24,88,56,16,80,48,32,96,64]\\n```\\nAnd each part can be divided into two parts, and so on......\\n```\\n[1,65,33,97,17,81,49,9,73,41,25,89,57,5,69,37,21,85,53,13,77,45,29,93,61]\\n[3,67,35,99,19,83,51,11,75,43,27,91,59,7,71,39,23,87,55,15,79,47,31,95,63]\\n[2,66,34,98,18,82,50,10,74,42,26,90,58,6,70,38,22,86,54,14,78,46,30,94,62]\\n[4,68,36,100,20,84,52,12,76,44,28,92,60,8,72,40,24,88,56,16,80,48,32,96,64]\\n```\\n```\\n......\\n```\\nAnd as you can see the pattern is pretty clear here. So I came up with the code below.\\n\\n### The Code\\n```\\nvar beautifulArray = function(N) {\\n    let arr=Array.from({length:N}, (x,i)=>i+1);\\n    return helper(arr);\\n\\n    function helper(arr){\\n    \\tif(arr.length===1) return arr;\\n    \\tlet o=[], e=[]; //odd index and even index\\n    \\tfor(let i=0; i<arr.length; i++){\\n    \\t\\tif(i%2===0) e.push(arr[i]);\\n    \\t\\telse o.push(arr[i]);\\n    \\t}\\n    \\treturn helper(e).concat(helper(o));\\n    }\\n};\\n```\\n\\n### The Why\\nWhy can this solution come up with a beautiful array? I tried to figure it out.\\nThe rule of a beautiful array is : `for every i < j, there is no k with i < k < j such that A[k] * 2 = A[i] + A[j].`\\nMeaning the **difference** between any `i` and `k` and `k` and `j` **can not be the same**.\\nSo how the above solution guarantees this?\\nFirst, by dividing the array into **odd** part and **even** part:\\n```\\n1,3,5,7,9..... | 2,4,6,8,10.....\\n```\\nIt guarantees that there is no such `j` for `i` and `k`:\\n```\\ni      k                j\\n-------------------------\\n1      2,4,6,8,10...\\n3      2,4,6,8,10...\\n5      2,4,6,8,10...\\n7      2,4,6,8,10...\\n9      2,4,6,8,10...\\n......\\n```\\nThen let\\'s see the first part (the second part will be similar):\\n```\\n1,3,5,7,9......\\n```\\nIt will be divided into two parts:\\n```\\n1,5,9,... | 3,7,11,...\\n```\\nAnd this time it guarantees that there is no such `j` for `i` and `k`:\\n```\\ni      k                j\\n--------------------------\\n1      3,7,11,...\\n5      3,7,11,...\\n9      3,7,11,...\\n......\\n```\\nAnd we continue this process until the length of the odd and even array reach 1, which means that there will be no `j` for any `i` and `k` ( for input 100):\\n```\\ni      k      j\\n----------------\\n1      65\\n......\\n```\\n### Conclusion\\nBecause by doing so we can always guarantee that:\\n1. there is no `j` in the **second part** for any `i` `k` in the **first part**, (this pattern I didn\\'t point it out above but it\\'s pretty clear)\\n2. there is no `j` for `i` in the **first part** and `k` in the **second part**, (this pattern is pointed out above)\\n3. the **second part** can always be transformed from the first part ( by adding one to all elements in the first part, which influence nothing), which means that it holds the same rule as the **first part**,\\n4. the **first part** is a beautiful array.\\n\\nwe can safely conclude that in this way we can always come up with a beautiful array.\\n\\n### PS\\nIt may be a little tricky to follow the thought.\\nIf you are still confused, try analysing the array of input 100.\\nBy dividing the array until its length reach 1, you\\'ll know why.",
                "solutionTags": [],
                "code": "```\\n[1,65,33,97,17,81,49,9,73,41,25,89,57,5,69,37,21,85,53,13,77,45,29,93,61,3,67,35,99,19,83,51,11,75,43,27,91,59,7,71,39,23,87,55,15,79,47,31,95,63,2,66,34,98,18,82,50,10,74,42,26,90,58,6,70,38,22,86,54,14,78,46,30,94,62,4,68,36,100,20,84,52,12,76,44,28,92,60,8,72,40,24,88,56,16,80,48,32,96,64]\\n```\n```\\n[1,65,33,97,17,81,49,9,73,41,25,89,57,5,69,37,21,85,53,13,77,45,29,93,61,3,67,35,99,19,83,51,11,75,43,27,91,59,7,71,39,23,87,55,15,79,47,31,95,63]\\n[2,66,34,98,18,82,50,10,74,42,26,90,58,6,70,38,22,86,54,14,78,46,30,94,62,4,68,36,100,20,84,52,12,76,44,28,92,60,8,72,40,24,88,56,16,80,48,32,96,64]\\n```\n```\\n[1,65,33,97,17,81,49,9,73,41,25,89,57,5,69,37,21,85,53,13,77,45,29,93,61]\\n[3,67,35,99,19,83,51,11,75,43,27,91,59,7,71,39,23,87,55,15,79,47,31,95,63]\\n[2,66,34,98,18,82,50,10,74,42,26,90,58,6,70,38,22,86,54,14,78,46,30,94,62]\\n[4,68,36,100,20,84,52,12,76,44,28,92,60,8,72,40,24,88,56,16,80,48,32,96,64]\\n```\n```\\n......\\n```\n```\\nvar beautifulArray = function(N) {\\n    let arr=Array.from({length:N}, (x,i)=>i+1);\\n    return helper(arr);\\n\\n    function helper(arr){\\n    \\tif(arr.length===1) return arr;\\n    \\tlet o=[], e=[]; //odd index and even index\\n    \\tfor(let i=0; i<arr.length; i++){\\n    \\t\\tif(i%2===0) e.push(arr[i]);\\n    \\t\\telse o.push(arr[i]);\\n    \\t}\\n    \\treturn helper(e).concat(helper(o));\\n    }\\n};\\n```\n```\\n1,3,5,7,9..... | 2,4,6,8,10.....\\n```\n```\\ni      k                j\\n-------------------------\\n1      2,4,6,8,10...\\n3      2,4,6,8,10...\\n5      2,4,6,8,10...\\n7      2,4,6,8,10...\\n9      2,4,6,8,10...\\n......\\n```\n```\\n1,3,5,7,9......\\n```\n```\\n1,5,9,... | 3,7,11,...\\n```\n```\\ni      k                j\\n--------------------------\\n1      3,7,11,...\\n5      3,7,11,...\\n9      3,7,11,...\\n......\\n```\n```\\ni      k      j\\n----------------\\n1      65\\n......\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1370870,
                "title": "java-break-up-every-arithmetic-sequence-with-visual-intuition",
                "content": "**Short algorithm:**\\n* On every step, split array in half by taking all odd-indexed elements in one half and even-indexed in another half. \\n* recursively repeat it with already split parts\\n* return any array of size 2 or less, because it is already beautifully arranged by definition\\n* combine the results of the recursive calls into one array and return it.\\n\\n**Some visual intuition:**\\n\\nWe\\'re basically splitting all possible arithmetic sequences of the original sequence. Arithmetic sequence is a sequence of numbers such that the difference between the consecutive terms is constant.\\n\\nLet\\'s take an example of `n = 15`:\\n![image](https://assets.leetcode.com/users/images/17363ba3-3bdb-4f08-9bb9-de4e4dc081cf_1627578554.3805828.png)\\n\\nNumbers in the original array form an arithmetic sequence with distance between elements equal to 1.\\n\\nIf you pick any start number, and then start counting from it at regular intervals, you will get yourself another arithmetic sequence with bigger intervals between elements.\\n\\nHere\\'s a bunch of arithmetic subsequences with distance 2:\\n![image](https://assets.leetcode.com/users/images/24f56eeb-680d-4471-aa4e-a8fba8fcda15_1627578918.2668414.png)\\n\\nHere\\'s arithmetic subsequences with distance 3:\\n![image](https://assets.leetcode.com/users/images/f008b8c8-f0c8-4e6e-a1d0-420fe85c5cc3_1627583177.4423501.png)\\n\\nAny arithmetic sequence in our output will be problematic. Here\\'s why. In the original arithmetic sequence, if you take any consequent three numbers, the beautiful condition will always be violated, and the doubled middle element will always be equal to the sum of its neighbours:\\n\\n![image](https://assets.leetcode.com/users/images/a5ba7916-6dad-4db4-931d-b61223d59761_1627579282.14404.png)\\nIt\\'s very easy to prove, take three elements: `n - 1`, `n`, `n + 1`\\nAnd you can see that the sum of the neighbours is `n - 1 + n + 1 = 2n` \\n\\nThe same holds on the larger scale:\\n![image](https://assets.leetcode.com/users/images/a7076ad8-f082-4116-89fd-eccdb3779bf3_1627579651.9805753.png)\\n\\nSimilarly easy to prove, take three elements: `n - a`, `n`, `n + a`\\nSum of the neighbours is `n - a + n + a = 2n`\\n\\nSo in case of `1`, `2,` `3`, it\\'s important that in our output 2 is never between `1` and `3`, so you can split these numbers into two groups, grouping up `1` and `3`:\\n![image](https://assets.leetcode.com/users/images/cbaec3c3-f872-4696-9e51-ebe73318bcd2_1627580260.6508982.png)\\n\\nSimilarly for bigger numbers, you never want the middle to be between two numbers that are at the same distance from it, so in case of 3 elements, you can group the equidistant elements up:\\n\\n![image](https://assets.leetcode.com/users/images/5b3e8e03-ccc8-427e-b2be-e6bfdf768bc8_1627580424.684246.png)\\n\\n**Visual example of how algorithm works:**\\n\\nNow let\\'s apply the algorithm described above to earlier example of `n = 15` and let\\'s look what happenes when we split array in half on each step by taking every other element:\\n\\n**Step 1:**\\n\\n![image](https://assets.leetcode.com/users/images/f8392c5d-ca94-425f-9b62-bd5ef5e89b4c_1627582766.3520532.png)\\n\\nWe split array into two subarrays, taking every other element.\\nNotice how left subarray is still forming an arithmetic subsequence, and right one is forming another one.\\n\\n**Step 2:**\\n![image](https://assets.leetcode.com/users/images/1b3b1b8d-6444-44f9-9875-6b8adc0f95c6_1627582818.6821275.png)\\nWe repeat the process for subarrays formed on the previous step.\\nSimilarly, each subarray is still anarithmetic subsequence with bigger distance than on the previous step, so those need to be split up.\\n\\n**Step 3:**\\n![image](https://assets.leetcode.com/users/images/18c228da-50ab-46cb-8763-a8568fa7483c_1627582851.741937.png)\\n\\nHere, each smaller array is of size 2 or less, so we can stop, since two elements are arranged beautifully by definition.\\nSo `1`, `9`, `5,` `13`, `3`, `11`, `7`, `15`, `2`, `10`, `6`, `14`, `4`, `12`, `8` is our final answer.\\n\\nIf you trace these formed groups back in the original array, you\\'ll have this picture:\\n![image](https://assets.leetcode.com/users/images/4406f5f6-890a-45f1-b6a5-c876e0c18a79_1627583022.382805.png)\\n\\nNotice how each pair has the same distance between each other, `9 - 1 = 8`, `10-2 = 8`, and so on. We\\'re basically splitting array into (n / 2) pairs of grouped elements, with equal distance between them.\\n\\n\\n**Code:**\\n\\n```\\nclass Solution {\\n      \\n    public int[] beautifulArray(int n) {\\n        List<Integer> ordered = IntStream.rangeClosed(1, n).boxed().collect(Collectors.toList());\\n        return arrangeBeautifully(ordered).stream().mapToInt(it -> it).toArray();\\n    }\\n   \\n    private List<Integer> arrangeBeautifully(List<Integer> numbers) {\\n        // two numbers or less are already arranged\\n        if (numbers.size() <= 2) {\\n            return numbers;\\n        }\\n        \\n        // split into two lists by taking every other number. all odds indexes go left, all even indexes go right\\n        List<Integer> left = new ArrayList<>();\\n        List<Integer> right = new ArrayList<>();\\n        for (int i = 0; i < numbers.size(); ++i) {\\n            if (i % 2 == 0) {\\n                left.add(numbers.get(i));\\n            } else {\\n                right.add(numbers.get(i));\\n            }            \\n        }\\n        \\n        // arrange both halves recursively\\n        List<Integer> arrangedLeft = arrangeBeautifully(left);\\n        List<Integer> arrangedRight = arrangeBeautifully(right);\\n        \\n        // combine arranged halves into one list\\n        arrangedLeft.addAll(arrangedRight);\\n        return arrangedLeft;        \\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n      \\n    public int[] beautifulArray(int n) {\\n        List<Integer> ordered = IntStream.rangeClosed(1, n).boxed().collect(Collectors.toList());\\n        return arrangeBeautifully(ordered).stream().mapToInt(it -> it).toArray();\\n    }\\n   \\n    private List<Integer> arrangeBeautifully(List<Integer> numbers) {\\n        // two numbers or less are already arranged\\n        if (numbers.size() <= 2) {\\n            return numbers;\\n        }\\n        \\n        // split into two lists by taking every other number. all odds indexes go left, all even indexes go right\\n        List<Integer> left = new ArrayList<>();\\n        List<Integer> right = new ArrayList<>();\\n        for (int i = 0; i < numbers.size(); ++i) {\\n            if (i % 2 == 0) {\\n                left.add(numbers.get(i));\\n            } else {\\n                right.add(numbers.get(i));\\n            }            \\n        }\\n        \\n        // arrange both halves recursively\\n        List<Integer> arrangedLeft = arrangeBeautifully(left);\\n        List<Integer> arrangedRight = arrangeBeautifully(right);\\n        \\n        // combine arranged halves into one list\\n        arrangedLeft.addAll(arrangedRight);\\n        return arrangedLeft;        \\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367982,
                "title": "c-0ms-100-bit-sorting-with-comments",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Beautiful Array.\\nMemory Usage: 6.8 MB, less than 97.21% of C++ online submissions for Beautiful Array.\\n![image](https://assets.leetcode.com/users/images/bd208253-2d55-46f9-b7e3-0a2fd16665f5_1627465447.185023.png)\\n**note** we will have other right answer = {7, 11, 3, 13, 5, 9, 1, 6, 10, 2, 12, 4, 8}, because we sort strictly (for not equal bit position we give preference for bit \\'1\\'). We also can change condition in sorting comparator and we will have in answer firstly numbers with \\'0\\' in bit position. \\n\\n```\\nclass Solution {\\npublic:\\n  static bool comp(const int &a, const int &b){\\n    int mask = 1;\\n    while(true)\\n      if((a&mask) == (b&mask)) mask = mask<<1;\\n      else return (a&mask) > (b&mask); \\n  }\\n  \\n  vector<int> beautifulArray(int n) {\\n    vector<int> answer;\\n    while(n) answer.push_back(n--);\\n    \\n    sort(answer.begin(), answer.end(), comp);\\n    \\n    return answer;\\n  }\\n};\\n```\\n**p.s.** I think we also can find out \"sorting condition\" in bit operation for this bit problem.\\n\\n**and I done it :**\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Beautiful Array.\\nMemory Usage: 6.8 MB, less than 93.03% of C++ online submissions for Beautiful Array.\\n```\\nclass Solution {\\npublic:\\n  static bool comp(const int &a, const int &b){\\n \\xA0 \\xA0int mask = (a^b); \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0  //xOr for transform the same right most positions into \\'0\\'\\n    mask = mask & (-mask);             //fetch the most right \\'1\\'\\n    return a & mask;                     //check if the right most \\'1\\' is belonged a or b   \\n  }\\n  \\n  \\n  vector<int> beautifulArray(int n) {\\n    vector<int> answer;\\n    while(n) answer.push_back(n--);\\n    \\n    sort(answer.begin(), answer.end(), comp);\\n    \\n    return answer;\\n  }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  static bool comp(const int &a, const int &b){\\n    int mask = 1;\\n    while(true)\\n      if((a&mask) == (b&mask)) mask = mask<<1;\\n      else return (a&mask) > (b&mask); \\n  }\\n  \\n  vector<int> beautifulArray(int n) {\\n    vector<int> answer;\\n    while(n) answer.push_back(n--);\\n    \\n    sort(answer.begin(), answer.end(), comp);\\n    \\n    return answer;\\n  }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n  static bool comp(const int &a, const int &b){\\n \\xA0 \\xA0int mask = (a^b); \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0  //xOr for transform the same right most positions into \\'0\\'\\n    mask = mask & (-mask);             //fetch the most right \\'1\\'\\n    return a & mask;                     //check if the right most \\'1\\' is belonged a or b   \\n  }\\n  \\n  \\n  vector<int> beautifulArray(int n) {\\n    vector<int> answer;\\n    while(n) answer.push_back(n--);\\n    \\n    sort(answer.begin(), answer.end(), comp);\\n    \\n    return answer;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186727,
                "title": "leetcode-weekly-contest-108-screencast-only-record-10-mins",
                "content": "I record the screencast on Windows with a trial version of Bandicam, didn't realize only the first 10 mins is recorded...\n\nHope next time, I won't screw it up.\n\nhttps://www.youtube.com/watch?v=X3sYZBBviY8",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=X3sYZBBviY8",
                "codeTag": "Unknown"
            },
            {
                "id": 186661,
                "title": "3-solutions-4-lines-in-python-divide-conquer-dp-top-down-and-bottom-up",
                "content": "**Divide and Conquer:**\\n\\nDivide and conquer strategy:\\n  l gives beautiful array of even numbers\\n\\tr gives beautiful array of odd numbers\\n```\\ndef beautifulArray(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if N==1: return [1]\\n\\tl=self.beautifulArray(N//2)\\n\\tr=self.beautifulArray(N-N//2)\\n\\treturn [x*2 for x in l]+[x*2-1 for x in r]\\n```\\nYou can optimize this by having only 1 recrusive call :\\n```\\ndef beautifulArray(self, N):\\n        if N == 1: return [1]\\n        half = self.beautifulArray(N - N / 2)\\n        return [i * 2 - 1 for i in half] + [i * 2 for i in half if i * 2 <= N]\\n```\\nThanks [@lee215](https://leetcode.com/lee215/) for suggesting this.\\n\\n**Top-Down DP (memoization):**\\n\\nYou can see overallping subproblems if you draw recursion tree, hence you can use memoization:\\n```\\n\\nclass Solution:\\n    memo = {}\\n    def beautifulArray(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if N==1: return [1]\\n        if N in self.memo: return self.memo[N]\\n        l=self.beautifulArray(N//2)\\n        r=self.beautifulArray(N-N//2)\\n        self.memo[N] = [x*2 for x in l]+[x*2-1 for x in r]\\n        return self.memo[N]\\n```\\n\\n**DP (bottom up):**\\nYou construct the tree in bottom up manner:\\n\\n```\\ndef beautifulArray(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: List[int]\\n        \"\"\"\\n        dp = {}\\n        dp[1] = [1]\\n        for i in range(2,N+1):\\n            dp[i] = [x*2 for x in dp[i//2]] + [x*2-1 for x in dp[i-i//2]]\\n        \\n        return dp[N]\\n```",
                "solutionTags": [],
                "code": "```\\ndef beautifulArray(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if N==1: return [1]\\n\\tl=self.beautifulArray(N//2)\\n\\tr=self.beautifulArray(N-N//2)\\n\\treturn [x*2 for x in l]+[x*2-1 for x in r]\\n```\n```\\ndef beautifulArray(self, N):\\n        if N == 1: return [1]\\n        half = self.beautifulArray(N - N / 2)\\n        return [i * 2 - 1 for i in half] + [i * 2 for i in half if i * 2 <= N]\\n```\n```\\n\\nclass Solution:\\n    memo = {}\\n    def beautifulArray(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if N==1: return [1]\\n        if N in self.memo: return self.memo[N]\\n        l=self.beautifulArray(N//2)\\n        r=self.beautifulArray(N-N//2)\\n        self.memo[N] = [x*2 for x in l]+[x*2-1 for x in r]\\n        return self.memo[N]\\n```\n```\\ndef beautifulArray(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: List[int]\\n        \"\"\"\\n        dp = {}\\n        dp[1] = [1]\\n        for i in range(2,N+1):\\n            dp[i] = [x*2 for x in dp[i//2]] + [x*2-1 for x in dp[i-i//2]]\\n        \\n        return dp[N]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367779,
                "title": "beautiful-array-easy-clean-w-2-approach",
                "content": "# **APPROACH 1:**\\n* **Iterative/sorting-**\\n![Meaning Of Using Bits](https://assets.leetcode.com/users/images/8a56cda7-5496-49b8-89be-2eae3e4ad95b_1627456380.537388.png)\\n\\n\\n```\\nvector<int> beautifulArray(int n) \\n{\\n\\tvector<int> ans(n);\\n\\tiota(begin(out), end(out), 1);\\n\\tsort(begin(out), end(out), [](auto & x, auto & y){ return -(x^y)&x&~y; });\\n\\treturn ans;  \\n}\\n```\\n**Time Complexity: O(NlogN)\\nSpace Complexity: O(1)**\\n\\n\\n\\n# **APPROACH 2:**\\n**ALGORITHM:**\\n* Create a vector called ans, insert 1 into ans\\n* While size of ans < N\\n\\t* create a vector temp\\n\\t* for i in range 0 to size of ans \\u2013 1 \\n\\t\\t* if ans[i] * 2 \\u2013 1 <= N, then insert ans[i] * 2 \\u2013 1 into temp array \\n\\t* for i in range 0 to size of ans \\u2013 1\\n\\t\\t* if ans[i] * 2 <= N, then insert ans[i] * 2 into temp array\\n\\t* set ans := temp\\n* return ans\\n\\n**SOLUTION:**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> ans ;\\n        ans.push_back(1) ;\\n        while(ans.size() < n)\\n        {\\n            vector<int> temp ;\\n            for(auto i:ans)\\n            {\\n                if(i*2 - 1 <= n)\\n                {\\n                    temp.push_back(i*2 - 1) ;\\n                }\\n            }\\n            for(auto i:ans)\\n            {\\n                if(i*2 <= n)\\n                {\\n                    temp.push_back(i*2) ;\\n                }\\n            }\\n            ans = temp ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nvector<int> beautifulArray(int n) \\n{\\n\\tvector<int> ans(n);\\n\\tiota(begin(out), end(out), 1);\\n\\tsort(begin(out), end(out), [](auto & x, auto & y){ return -(x^y)&x&~y; });\\n\\treturn ans;  \\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> ans ;\\n        ans.push_back(1) ;\\n        while(ans.size() < n)\\n        {\\n            vector<int> temp ;\\n            for(auto i:ans)\\n            {\\n                if(i*2 - 1 <= n)\\n                {\\n                    temp.push_back(i*2 - 1) ;\\n                }\\n            }\\n            for(auto i:ans)\\n            {\\n                if(i*2 <= n)\\n                {\\n                    temp.push_back(i*2) ;\\n                }\\n            }\\n            ans = temp ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186660,
                "title": "python-recursion",
                "content": "\\n\\nExample:\\n1,2,3,4,5,6,7,8,9\\n-->\\n1,3,5,7,9,2,4,6,8\\n-->\\n1,5,9,3,7,2,6,4,8\\n-->\\n1,9,5,3,7,2,6,4,8\\n```\\nclass Solution(object):\\n    def beautifulArray(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: List[int]\\n        \"\"\"\\n        return self.helper(range(1,N+1))\\n        \\n    def helper(self, lst):\\n        if len(lst)<=2:         return lst\\n        return self.helper(lst[::2]) + self.helper(lst[1::2])\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def beautifulArray(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: List[int]\\n        \"\"\"\\n        return self.helper(range(1,N+1))\\n        \\n    def helper(self, lst):\\n        if len(lst)<=2:         return lst\\n        return self.helper(lst[::2]) + self.helper(lst[1::2])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 644612,
                "title": "python3-solution-with-detailed-explanation-beautiful-array",
                "content": "First, divide the array into even numbers and odd numbers so that we only need to further arrange numbers within even or odd numbers themselves because nums[i] and nums[j] must be both even or odd and can\\'t be one even and one old. \\n\\nThen, further divide each division into numbers at even indices and odd indices till the division length is either 1 or 2 at which time just return the division. This works the same way as the first step, because if you divide all even numbers by 2, you will have even and odd number again, e.g. `[2,4,6,8,10] -> [1,2,3,4,5]`. If you add odd numbers by 1 and divide by 2, you will also have even and odd numbers, e.g. `[1,3,5,7,9] -> [2,4,6,8,10] -> [1,2,3,4,5]`.\\n\\n```\\nclass Solution:\\n    def beautifulArray(self, N: int) -> List[int]:\\n        nums = list(range(1, N+1))\\n        \\n        def helper(nums) -> List[int]:\\n            if len(nums) < 3:\\n                return nums\\n            even = nums[::2]\\n            odd = nums[1::2]\\n            return helper(even) + helper(old)\\n        return helper(nums)   \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulArray(self, N: int) -> List[int]:\\n        nums = list(range(1, N+1))\\n        \\n        def helper(nums) -> List[int]:\\n            if len(nums) < 3:\\n                return nums\\n            even = nums[::2]\\n            odd = nums[1::2]\\n            return helper(even) + helper(old)\\n        return helper(nums)   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 371380,
                "title": "c-separate-odd-index-with-even-index",
                "content": "Different with the most voted solution, I generate the permutaion in the begining. \\n```\\nint S* = {1,2,3,4,5,6,7,8}\\n```\\nObviously, it\\'s not a beautiful array, let\\'s make it a beautiful one.\\nMy intuition is: sifting all possible  A[k] out until it\\'s beautiful.\\n\\nI extract the elements with even index(i.e. 0,2,4...) to the front of subarray while the odd to the back of subarray. Like\\n```\\nint A* = {1,3,5,7};\\nint B* = {2,4,6,8};\\n//update S\\nS= {1,3,5,7,2,4,6,8};\\n```\\nBut in subarray itself, it\\'s still not beautiful, let\\'s look at left subarray.\\n```\\nint * A = {1,3,5,7} \\n2*A[1] = A[0] * A[2]; //broke the rule\\n```\\nSo let\\'s do the same thing for this subarray, move elements with even index forward, while the odd backward.\\n```\\n//update A\\nA = {1,5,3,7}\\n```\\nKeep dividing until the array size <= 2,  then all the possible A[k] are separted with A[i], A[j].\\n//Talk is cheap, here is the code:)\\n```\\n    vector<int> beautifulArray(int N) {\\n        vector<int> S;\\n        for (int i = 1; i <= N; ++i) {\\n            S.push_back(i);\\n        }\\n        divide(S, 0, N - 1);\\n        return S;\\n    }\\n    \\n    void divide(vector<int>& S, int l, int r) {\\n        if (r - l <= 1) return;\\n        vector<int> odd, even;\\n        for (int i = l; i <= r; ++i) {\\n            if ((i + 1 - l) & 1) { //using relative index\\n                odd.push_back(S[i]);\\n            } else {\\n                even.push_back(S[i]);\\n            }\\n        }\\n        std::copy(odd.begin(), odd.end(), S.begin() + l);\\n        std::copy(even.begin(), even.end(), S.begin() + l + odd.size());\\n        int m = (r - l) / 2 + l;\\n        divide(S, l, m);\\n        divide(S, m + 1, r);\\n    }\\n```\\nT(N) = 2(T/2) + O(N)\\naccording to master theorem\\uFF0C T(N) = O(NlogN)",
                "solutionTags": [
                    "Divide and Conquer"
                ],
                "code": "```\\nint S* = {1,2,3,4,5,6,7,8}\\n```\n```\\nint A* = {1,3,5,7};\\nint B* = {2,4,6,8};\\n//update S\\nS= {1,3,5,7,2,4,6,8};\\n```\n```\\nint * A = {1,3,5,7} \\n2*A[1] = A[0] * A[2]; //broke the rule\\n```\n```\\n//update A\\nA = {1,5,3,7}\\n```\n```\\n    vector<int> beautifulArray(int N) {\\n        vector<int> S;\\n        for (int i = 1; i <= N; ++i) {\\n            S.push_back(i);\\n        }\\n        divide(S, 0, N - 1);\\n        return S;\\n    }\\n    \\n    void divide(vector<int>& S, int l, int r) {\\n        if (r - l <= 1) return;\\n        vector<int> odd, even;\\n        for (int i = l; i <= r; ++i) {\\n            if ((i + 1 - l) & 1) { //using relative index\\n                odd.push_back(S[i]);\\n            } else {\\n                even.push_back(S[i]);\\n            }\\n        }\\n        std::copy(odd.begin(), odd.end(), S.begin() + l);\\n        std::copy(even.begin(), even.end(), S.begin() + l + odd.size());\\n        int m = (r - l) / 2 + l;\\n        divide(S, l, m);\\n        divide(S, m + 1, r);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1373064,
                "title": "java-clear-thinking-process-divide-and-conquer",
                "content": "I did not solve the problem first. And I was also confused by looking at the official solutions. Here are my thinking process of how I finally got to understand it.\\n\\nBefore getting into the algorithmn, there are some observations we can make on a normal array with elements {1, 2, ... n}:\\n1. \\tThe only condition here is `2*nums[k] = nums[i] + nums[j] (i < k < j)`. If we know what nums[k] is, how can we make this equation true? The only way to achieve this equation is when nums[k] is the midpoint of the nums[i] and nums[j]. With math, it is simple to prove: 2*nums[k] = nums[i] + nums[j] --> nums[k] - nums[i] = nums[j] - nums[k] (nums[i] < nums[k] < nums[j] since we are on the normal array right now) Therefore, **to avoid making this equation true, we have to choose two values that each has a different distance from the other to nums[k], from each of the two sides of nums[k].**\\n2. \\t Based on observation 1, if we think further, if nums[i] and nums[j] both have equal distance to nums[k], nums[i] and nums[j] must be both odd or both even numbers, in a normal array (This is the start of the approach).\\n\\nTo conclude, in order to find a beautiful array, we need to rearrange each element so that whenever we choose an element as nums[k], **we cannot find any two elements nums[i] and nums[j] from each side with equal distance**. How are we going to do this? \\n\\nObservation 2 already gives part of the answer. We know for sure that nums[i] and nums[j] must have same distance from nums[k]. In this normal array, the interval between each element is 1. (1+1* 0, 1+1* 1, 1+1* 2, ... ) Therefore, the difference bewteen nums[k] to nums[i] and nums[j] has to be 1 * \"something\" (1 is the interval here). The only two results will be: it suffices the equation--the difference is the same; or it doesn\\'t fit--the difference is different. Now, what is one thing or the **property of natural numbers** that can categorize the \"something\" part of the interval into 2 groups so that we immediately know the number (nums[i]) we pick in that group will not have the same distance as the other number (nums[j]) we pick in the other part? \\n\\nEven and Odd! Since even numbers are always different, or to be speficic, 1 unit (This is the interval right now in the array, This is important for explanation later!) different from odd numbers. (Keep in mind that the even and odd here is the \"something\" part mentioned above, not the values in the array) So if we pick nums[i] from a bunch of odd numbers, we know for sure that if nums[j] is even (or different from nums[i], to be general), it is never going to fit the condition. \\n\\nHowever, if nums[i], and nums[j] are both odd or even, it still suffices the equation. How can we prevent this from happening?\\nRemember, there is another constraint hidden in the statement, that is i and j (the indices) has to be on the two sides of k. If we can put all odd numbers on one side and all even numbers on the other side of the array, we can make sure that if k (the index) is on the even side, if nums[i] or nums[j] is chosen among the odd numbers, it will not work because in that case nums[i] and nums[j] has both to be in the odd side, which is both on the left side of nums[k]. (If we put odd nums on the left and even nums on the right, see example below later)\\n\\nBut think about the statement above, \"if k (the index) is on the even side, nums[i] or nums[j] chosen among the odd numbers won\\'t work\", there is an extra case we didn\\'t address, that is if nums[i], nums[j] and nums[k] are all on the odd side or even side, it will still work. However, that leads us to a smaller version of the original problem on the normal array, where elements are no longer `1, 2, ... n` , but `1, 3, 5, 7...` or `2, 4, 6, 8 ...`.\\n\\nNow, which algorithmn allows us to break a large problem into smaller solvable problems while we need to keep cactegorizing and dividing the 2 groups of numbers?\\n\\n### **Divide and Conquer**\\n\\nThe algorithmn is already quite clear now:\\n1. construct a normal array\\n2. divide the array into 2 groups\\n3. put the one group of numbers all on the left and the other on the right\\n4. repeat steps 2 and 3\\n\\nWe only need to specify step 2 here. In above, we stopped after having the array with `1, 3, 5, 7... 2, 4, 6, 8...`. And now we need to make the equation wrong even when nums[i] and nums[j]  and nums[k] are all on one side. \\n\\nThe idea of interval becomes clear now. if we only look at the subarray on the left, which is `1, 3, 5, 7...`, we notice that every number still maintain equal distance with adjacent one, that is, (1+2* 0, 1+2* 1, 1+2* 2 ...). Same for the even numbers.\\nHere, the interval turns into 2 instead of 1. But the key doesn\\'t change, if have nums[i] even number of units away from nums[k], nums[j] has also to be an even number of units away from nums[k]. \"Units\" here is exactly the interval, which is 2 now, and 1 before. Similarly we can categorize these odd numbers into two groups, one contains numbers that have even number of intervals from each adjacent element, the other has numbers with odd number of intervals from each adjacent one.  Now whenever we choose nums[k] in one the two groups, nums[i] and nums[j] has to be at least both from one of the groups, which comes back to the same situation above, never gonna fit in the equation!\\n\\nHere is an example with `n=10`:\\n1. Creating original array \\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\\n2. First grouping\\n[1, 3, 5, 7, 9, 2, 4, 6, 8, 10]\\nLeft:\\n3. Group the left\\n[1, 5, 9, 3, 7...\\n4. Group the left from step 3\\n[1. 9, 5...\\n5. Group the right from step 3\\n[... 3, 7...\\nRight:\\n6. Group the right\\n... 2, 6, 10, 4, 8]\\n7. Group the left from step 6\\n... 2, 10, 6 ...]\\n8. Group the right from step 6\\n... 4, 8]\\n\\nFinal result:\\n[1, 9, 5, 3, 7, 2, 10, 6, 4, 8]\\n\\nThe steps above are described in a recursive structure. The implementation is below:\\n\\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        int[] ans = new int[n];\\n        for(int i = 0; i  < n; i++){\\n            ans[i] = i+1;\\n        }\\n        recursion(ans, 0, n-1);\\n        return ans;\\n    }\\n    \\n    public void recursion(int[] arr, int left, int right){\\n        if(left >= right)\\n            return;\\n        ArrayList<Integer> l = new ArrayList<>();\\n        ArrayList<Integer> r = new ArrayList<>();\\n\\t\\t\\n        boolean alt = true;// Not worry about whether the factor of the interval is even or odd too much, they can be grouped by \\n\\t\\t\\t\\t\\t\\t\\t// just picking one and skip one\\n\\t\\t\\t\\t\\t\\t\\t\\n        for(int i = left; i <= right; i++){ // picking the elements and put them into the two groups\\n            if(alt)\\n                l.add(arr[i]);\\n            else\\n                r.add(arr[i]);\\n            alt = !alt;\\n        }\\n\\n        for(int i = left; i <= right; i++){ // merging them into the final array\\n            if(!l.isEmpty())\\n                arr[i] = l.remove(0);\\n            else\\n                arr[i] = r.remove(0);\\n        }\\n        recursion(arr, left, (right+left)/2);\\n        recursion(arr, (left+right)/2+1, right);\\n    }\\n}\\n```\\n\\nMay not be the fastest, but hope to be the easiest to understand!\\nAnd this is my first time posting, please tell me if anything didn\\'t explain well!",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        int[] ans = new int[n];\\n        for(int i = 0; i  < n; i++){\\n            ans[i] = i+1;\\n        }\\n        recursion(ans, 0, n-1);\\n        return ans;\\n    }\\n    \\n    public void recursion(int[] arr, int left, int right){\\n        if(left >= right)\\n            return;\\n        ArrayList<Integer> l = new ArrayList<>();\\n        ArrayList<Integer> r = new ArrayList<>();\\n\\t\\t\\n        boolean alt = true;// Not worry about whether the factor of the interval is even or odd too much, they can be grouped by \\n\\t\\t\\t\\t\\t\\t\\t// just picking one and skip one\\n\\t\\t\\t\\t\\t\\t\\t\\n        for(int i = left; i <= right; i++){ // picking the elements and put them into the two groups\\n            if(alt)\\n                l.add(arr[i]);\\n            else\\n                r.add(arr[i]);\\n            alt = !alt;\\n        }\\n\\n        for(int i = left; i <= right; i++){ // merging them into the final array\\n            if(!l.isEmpty())\\n                arr[i] = l.remove(0);\\n            else\\n                arr[i] = r.remove(0);\\n        }\\n        recursion(arr, left, (right+left)/2);\\n        recursion(arr, (left+right)/2+1, right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 189066,
                "title": "a-concise-python-recursive-solution-with-explanation-o-n",
                "content": "```python\\nclass Solution:\\n\\t def beautifulArray(self, N):\\n        \"\"\"\\n        If we have a beautiful array A, then it means for any i < k < j. A[k] * 2 != A[i] + A[j]. Let\\'s add x to all\\n        elements of beautiful array. In that case (A[k] + x) * 2 != A[i] + x + A[j] + x => A[k] * 2 + 2x != A[i] + A[j] + 2x =>\\n        A[k] * 2 != A[i] + A[j]. Which proves that, adding same number to beatiful array doesn\\'t make it ugly.\\n        \\n        Now let\\'s multiply x with all numbers in beautiful array. (A[k] * 2) * x != A[i] * x + A[j] * x =>\\n        (A[k] * 2) * x != (A[i] + A[j]) * x => A[k] * 2 != A[i] + A[j]. Which proves that multiplying some number to \\n        beautiful array doesn\\'t make it ugly. If we delete some number from beautiful array, it\\'ll not make it ugly\\n        i.e. A[k] * 2 != A[i] + A[j] we can prove it by intuition.\\n        \\n        So If we want to know the beautiful array with element [1, N] and we already known the beautiful array for [1, N/2],\\n        We can multiply all elements of that array by 2, and we\\'ll get a new beautiful array with all even numbers from b/w\\n        [1, N] and if we subtract 1 from each element of this new even beauiful array, we get a new beautiful array with\\n        all odd elements b/w [1, N]. Now we got two beautiful arrays one has all odd elements and other has all even elements.\\n        Now we know that for beautiful array A[k] * 2 != A[i] + A[j]. If A[i] and A[j] have different partiy (one is odd and\\n        other is even) then their sum would be odd always and A[k] * 2 != A[i] + A[j] condition will always met as left side of\\n        the condition is even so for right side of the condition to be even both A[i] and A[j] shoud have same parity. It means\\n        that if we simply concatenate two beautiful arrays with even and odd elements, the new aray would still be beautiful.\\n        \\n        One Last observation is what if N is odd then it\\'s not divisible by 2. We can simply add 1 to it and make it even\\n        to find beautiful array for [1, N + 1] and once we find it, we can simply remove N + 1 from answer. \\n        \\n        In each function call, we are taking half of the elements so depth of recursion or total funcion calls would be O(LogN)\\n        and in each execution, O(N / k) process would be done. So in first call, O(N) work would be done in pre-processing\\n        and concatenation, in second, call O(N / 2), in third O(N / 4) and so on. If we add all these processing times then\\n        using geometric series Sum would be O(2N) = O(N) so runtime is O(N) and Memory complexity is O(N).\\n        :type N: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if N == 1: return [1]\\n        b_array = self.beautifulArray((N if N % 2 == 0 else N + 1) // 2)\\n        return filter(lambda x: x != N + 1, map(lambda x: 2 * x, b_array) + map(lambda x: 2 * x - 1, b_array))\\n\\t\\t\\t\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n\\t def beautifulArray(self, N):\\n        \"\"\"\\n        If we have a beautiful array A, then it means for any i < k < j. A[k] * 2 != A[i] + A[j]. Let\\'s add x to all\\n        elements of beautiful array. In that case (A[k] + x) * 2 != A[i] + x + A[j] + x => A[k] * 2 + 2x != A[i] + A[j] + 2x =>\\n        A[k] * 2 != A[i] + A[j]. Which proves that, adding same number to beatiful array doesn\\'t make it ugly.\\n        \\n        Now let\\'s multiply x with all numbers in beautiful array. (A[k] * 2) * x != A[i] * x + A[j] * x =>\\n        (A[k] * 2) * x != (A[i] + A[j]) * x => A[k] * 2 != A[i] + A[j]. Which proves that multiplying some number to \\n        beautiful array doesn\\'t make it ugly. If we delete some number from beautiful array, it\\'ll not make it ugly\\n        i.e. A[k] * 2 != A[i] + A[j] we can prove it by intuition.\\n        \\n        So If we want to know the beautiful array with element [1, N] and we already known the beautiful array for [1, N/2],\\n        We can multiply all elements of that array by 2, and we\\'ll get a new beautiful array with all even numbers from b/w\\n        [1, N] and if we subtract 1 from each element of this new even beauiful array, we get a new beautiful array with\\n        all odd elements b/w [1, N]. Now we got two beautiful arrays one has all odd elements and other has all even elements.\\n        Now we know that for beautiful array A[k] * 2 != A[i] + A[j]. If A[i] and A[j] have different partiy (one is odd and\\n        other is even) then their sum would be odd always and A[k] * 2 != A[i] + A[j] condition will always met as left side of\\n        the condition is even so for right side of the condition to be even both A[i] and A[j] shoud have same parity. It means\\n        that if we simply concatenate two beautiful arrays with even and odd elements, the new aray would still be beautiful.\\n        \\n        One Last observation is what if N is odd then it\\'s not divisible by 2. We can simply add 1 to it and make it even\\n        to find beautiful array for [1, N + 1] and once we find it, we can simply remove N + 1 from answer. \\n        \\n        In each function call, we are taking half of the elements so depth of recursion or total funcion calls would be O(LogN)\\n        and in each execution, O(N / k) process would be done. So in first call, O(N) work would be done in pre-processing\\n        and concatenation, in second, call O(N / 2), in third O(N / 4) and so on. If we add all these processing times then\\n        using geometric series Sum would be O(2N) = O(N) so runtime is O(N) and Memory complexity is O(N).\\n        :type N: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if N == 1: return [1]\\n        b_array = self.beautifulArray((N if N % 2 == 0 else N + 1) // 2)\\n        return filter(lambda x: x != N + 1, map(lambda x: 2 * x, b_array) + map(lambda x: 2 * x - 1, b_array))\\n\\t\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1192798,
                "title": "4-liner",
                "content": "**Iterative/sorting**\\n**time: `O(NlogN)`, space: `O(1)`**\\n```\\nvector<int> beautifulArray(int n) \\n{\\n\\tvector<int> out(n);\\n\\tiota(begin(out), end(out), 1);\\n\\tsort(begin(out), end(out), [](auto & x, auto & y){ return -(x^y)&x&~y; });\\n\\treturn out;  \\n}\\n```\\n**Divide and conquer**\\n\\nFirst populate the array with numbers `1...N`. Now we need to rearrange the numbers in the array to make it beautiful.\\nThe logic is simple: in order `A[k]*2=A[i]+A[j] i<k<j` to hold we need `A[i]` and `A[j]` to have the same parity. So if you place all odd elements prior to all even elements you *divide* your problem *\"reposition elements in the array so that `A[k]*2\\u2260A[i]+A[j]`\"* into two \"nonoverlapping\" subproblems: \\n* *reposition elements in the contiguous \"odd subarray\" so that `A[k]*2\\u2260A[i]+A[j]`*;\\n* *reposition elements in the contiguous \"even subarray\" so that `A[k]*2\\u2260A[i]+A[j]`*.\\n\\n![image](https://assets.leetcode.com/users/images/6c2524a0-a463-4f6f-867a-0e166a34ccd7_1620233440.041865.png)\\n<br>\\n\\nNote that you\\'ve segregated the numbers based on the question *\"Do elements have the same remainder modulo `2`?\"*\\nYou can do the same using custom sorting so that odd elements are less than even. \\nThe next question will be `\"Do even/odd elements have the same remainder modulo `4`?\" etc...\\n\\n**Sorting**\\n\\nYou can do all segregating of the elements via sorting procedure.\\nComparison of elements should be based on their remainder modulo `1/2^i` \\u2014 binary digits of numbers `1..N`.\\nThe comparison lambda could be written in few ways and its work is equivalent to the following.\\n\\n> Travese binary digits from **right** to **left** untill `x` and `y` have **different** digits. \\nIf this digit is `1` for `x` and `0` for `y` then `x` is smaller, otherwise `y` is smaller.\\n\\n> Here\\'s another explanation. Let `x` has binary representation `\"00010101001000\"` and `y` - `\"00001011011000\"`.\\nYou can get the lambda\\'s result if you reverse these strings and `return` `reverse(\"00010101001000\") > reverse(\"00001011011000\")` \\n(**lexicographical order** of reversed strings that represent binary representation of numbers).\\n\\nMy lambda does exactly this but using bitwise magic. `-(x^y)` finds the first mismatching digit from the right (leaving some \"garbage\" to the left of it). Then you `&` it with `x` and `~y`. This deletes the \"gardage\" and returns `true` if `x` has `1` on the `first_from_the_right_mismatching_spot` and `y` has `0` on the same spot (and return `false` otherwise).\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/26ad4531-fa92-4553-9935-6aa0518cdaa0_1620226589.684505.png)\\n\\n<br>\\n\\n**Final note**: There exists a more efficient linear time solution based on the same idea. Check out the [post](https://leetcode.com/problems/beautiful-array/discuss/186679/Odd-%2B-Even-Pattern-O(N)) by Lee for this solution.\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> beautifulArray(int n) \\n{\\n\\tvector<int> out(n);\\n\\tiota(begin(out), end(out), 1);\\n\\tsort(begin(out), end(out), [](auto & x, auto & y){ return -(x^y)&x&~y; });\\n\\treturn out;  \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1368347,
                "title": "recursive-java-solution-with-explanation",
                "content": "First of all, I want to explane why it works:\\n- the formula that defines a \"beautiful\" array is arr[k]***2** != arr[i]+arr[j] and it contains a doubling. It means that if arr[i] is odd and arr[j] is even, or vice versa, the formula won\\'t work. It means that if we put all odd elements in the left part of an array and all the even elements in the right, we should only be sure that an odd part is \"beautiful\" and an even part is \"beautiful\". If so, together they also are \"beautiful\".\\n- an array with n elements contains (n+1)/2 odd elements and n/2 even elements.\\n - If there is a \"beautiful\" array and we multiply every element of this array, it will still be \"beautiful\" because the formula above is linear. What I want to say is that\\n ```\\n [1,3,2] is \"beautiful\".\\n ```\\n If we double it, it still will be \"beautiful\" and all the elements will be **even**\\n ```\\n [1,3,2]*2 => [2,6,4]\\n ```\\n If we after doubling decrease 1, the array will also be \"beautiful\", but all the elements will be **odd**\\n \\n ```\\n  ([1,3,2]*2)-1 => [1,5,3]\\n ```\\n \\n Using the ideas above, it\\'s possible to conclude that it\\'s enough to break recursively the base array[n]. Than turn a \"beautiful\" subarray into the array of odd numbers and concatenate a \"beautiful\" subarray that was turned into an array of even numbers. And that\\'s it.\\n \\n The solution in Java:\\n\\n```\\n\\nclass Solution {\\n    Map<Integer,int[]> cache;\\n    public int[] beautifulArray(int n) {\\n        if (cache==null) cache = new HashMap();\\n        if (cache.containsKey(n)) return cache.get(n); //Beautiful array of this length already was created. Just get it from cache.\\n        \\n        int[] arr = new int[n];\\n        if (n==1){\\n            arr[0]=1;\\n        }else{\\n            int[] oddArr = beautifulArray((n+1)/2); //Beautiful subarray with a length as a number of odd elements in the current array;\\n            int[] evenArr = beautifulArray((n)/2);//The same for even numbers\\n            int j=0;\\n            for (int i=0; i<oddArr.length; i++){\\n                arr[j]=oddArr[i]*2-1;\\n                j++;\\n            }\\n            for (int i=0; i<evenArr.length; i++){\\n                arr[j]=evenArr[i]*2;\\n                j++;\\n            }\\n        }\\n        cache.put(n,arr);\\n        return arr;\\n    }    \\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n [1,3,2] is \"beautiful\".\\n ```\n```\\n [1,3,2]*2 => [2,6,4]\\n ```\n```\\n  ([1,3,2]*2)-1 => [1,5,3]\\n ```\n```\\n\\nclass Solution {\\n    Map<Integer,int[]> cache;\\n    public int[] beautifulArray(int n) {\\n        if (cache==null) cache = new HashMap();\\n        if (cache.containsKey(n)) return cache.get(n); //Beautiful array of this length already was created. Just get it from cache.\\n        \\n        int[] arr = new int[n];\\n        if (n==1){\\n            arr[0]=1;\\n        }else{\\n            int[] oddArr = beautifulArray((n+1)/2); //Beautiful subarray with a length as a number of odd elements in the current array;\\n            int[] evenArr = beautifulArray((n)/2);//The same for even numbers\\n            int j=0;\\n            for (int i=0; i<oddArr.length; i++){\\n                arr[j]=oddArr[i]*2-1;\\n                j++;\\n            }\\n            for (int i=0; i<evenArr.length; i++){\\n                arr[j]=evenArr[i]*2;\\n                j++;\\n            }\\n        }\\n        cache.put(n,arr);\\n        return arr;\\n    }    \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 905426,
                "title": "python3-o-nlogn-solution-without-mathematical-skills",
                "content": "Seriously, this question should be categorized as hard to those who have no experience of ACM, such like me.\\nhowever, there still is a way to come across the solution **without mathematical intuition and reasoning skills**, which needs a pen and  a paper, of coz, and a little bit observation.\\n\\nFirst, it is not hard to figure out that,\\n**odd + even = odd != 2 * x**\\nso devide the array from 1 to N into two parts (take N=10 as example),\\n*1 3 5 7 9 | 2 4 6 8 10*\\nthen the question becomes how to make the left or the right be \"beautiful array\". \\nlook at the right part that includes even numbers, here the pen and paper are in need.\\nsay we have *2 ,4*, where should we put 6? apprently not the right most position, while the left most slot is ok, so we get *6, 2, 4*.\\nlikewisely, we get *6, 2, 4, 8*, and it is beautiful too. Given this, it seems that we can rebuild the left part spirally, but can it work always?\\nUnfortunately, the answer is no. *10, 6, 2, 4, 8* is not beautiful. \\nhere comes the **KEY** -- if we splitted the spiral array into two parts and rebuild each part spirally again, we got two beautiful arrays,\\n*10 2 6 | 4 8*, **AND**, any number in the sub left plus any number in the sub right is a double of **odd**, while all numbers in this array are **even**.\\nbut are we to the end? *18 10 2 6 14* is not beautiful once more. so split and rebuild, *18 2 10 | 6 14*, **(left x + right y) / 2 is not in the array itself**.\\nit can be easily verified that all the above steps are also feasible on original odd subarrays.\\nhaving gone so far, it is not difficult to think of **devide and conquer** and **recursion**, and **TRY**.\\nso here comes the naive recursion solution,\\n```\\ndef beautifulArray(self, N: int) -> List[int]:\\n        def _split(arr):\\n            if len(arr) <= 2:\\n                return arr\\n            odd, even = [], []\\n            for i, n in enumerate(arr):\\n                if i % 2: even.append(n)\\n                else: odd.append(n)\\n            return _split(odd) + _split(even)\\n\\n        return _split([i for i in range(1, N + 1)])\\n```",
                "solutionTags": [],
                "code": "```\\ndef beautifulArray(self, N: int) -> List[int]:\\n        def _split(arr):\\n            if len(arr) <= 2:\\n                return arr\\n            odd, even = [], []\\n            for i, n in enumerate(arr):\\n                if i % 2: even.append(n)\\n                else: odd.append(n)\\n            return _split(odd) + _split(even)\\n\\n        return _split([i for i in range(1, N + 1)])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 762659,
                "title": "java-divide-and-conquer",
                "content": "```\\nclass Solution {\\n    public int[] beautifulArray(int N) {\\n        List<Integer> pass = new ArrayList<>();\\n        for(int i=1; i<N+1; i++) pass.add(i);\\n        \\n        List<Integer> ans = dfs(pass);\\n        \\n        return ans.stream().mapToInt(i -> i).toArray();\\n    }\\n    \\n    private List<Integer> dfs(List<Integer> arr){\\n        if(arr.size() < 3) return arr;\\n        \\n        List<Integer> odd = new ArrayList<>();\\n        List<Integer> even = new ArrayList<>();\\n        \\n        for(int i=0; i<arr.size(); i++){\\n            if(i%2 == 0) even.add(arr.get(i));\\n            else odd.add(arr.get(i));\\n        }\\n        \\n        odd = dfs(odd);\\n        even = dfs(even);\\n        List<Integer> tmp = new ArrayList<>();\\n        tmp.addAll(odd);\\n        tmp.addAll(even);\\n        \\n        return tmp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int N) {\\n        List<Integer> pass = new ArrayList<>();\\n        for(int i=1; i<N+1; i++) pass.add(i);\\n        \\n        List<Integer> ans = dfs(pass);\\n        \\n        return ans.stream().mapToInt(i -> i).toArray();\\n    }\\n    \\n    private List<Integer> dfs(List<Integer> arr){\\n        if(arr.size() < 3) return arr;\\n        \\n        List<Integer> odd = new ArrayList<>();\\n        List<Integer> even = new ArrayList<>();\\n        \\n        for(int i=0; i<arr.size(); i++){\\n            if(i%2 == 0) even.add(arr.get(i));\\n            else odd.add(arr.get(i));\\n        }\\n        \\n        odd = dfs(odd);\\n        even = dfs(even);\\n        List<Integer> tmp = new ArrayList<>();\\n        tmp.addAll(odd);\\n        tmp.addAll(even);\\n        \\n        return tmp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 315467,
                "title": "python3-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef beautifulArray(self, N: int) -> List[int]:\\n\\t\\t\\tres=[1]\\n\\t\\t\\twhile len(res)<N:\\n\\t\\t\\t\\todd=[2*i-1 for i in res]\\n\\t\\t\\t\\teven=[2*i for i in res]\\n\\t\\t\\t\\tres=odd+even\\n\\t\\t\\treturn [i for i in res if i<=N]",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef beautifulArray(self, N: int) -> List[int]:\\n\\t\\t\\tres=[1]\\n\\t\\t\\twhile len(res)<N:\\n\\t\\t\\t\\todd=[2*i-1 for i in res]\\n\\t\\t\\t\\teven=[2*i for i in res]\\n\\t\\t\\t\\tres=odd+even\\n\\t\\t\\treturn [i for i in res if i<=N]",
                "codeTag": "Java"
            },
            {
                "id": 1367962,
                "title": "explained-recursion-fast-easy-c",
                "content": "Example 123456 -> 135 246 -> 15 3 26 4 -> 153264\\n\\n2. Use Divide n Conquer Algorithm\\n2. Take the odd alteranate numbers in t1 and even alternate in t2\\n3. Join them back if the size of t1 or t2 is less than 3\\n4. return final answer \\n\\n```\\nvector<int> fun(vector<int> v){\\n\\n\\tif(v.size()<3)\\n\\t\\treturn v;\\n\\n\\tvector<int> t1;\\n\\tvector<int> t2;\\n\\n\\tfor(int i=0;i<v.size();i++){\\n\\t\\tif(i%2==0)\\n\\t\\t\\tt1.push_back(v[i]);\\n\\t\\telse\\n\\t\\t\\tt2.push_back(v[i]);\\n\\t}\\n\\n\\tt1=fun(t1);\\n\\tt2=fun(t2);\\n\\n\\tvector<int> t3;\\n\\tfor(int i=0;i<t1.size();i++)\\n\\t\\tt3.push_back(t1[i]);\\n\\tfor(int i=0;i<t2.size();i++)\\n\\t\\tt3.push_back(t2[i]);\\n\\n\\treturn t3;\\n}\\nvector<int> beautifulArray(int n) {\\n\\n\\tvector<int> t(n);\\n\\tfor(int i=1;i<=n;i++)\\n\\t\\tt[i-1]=i;\\n\\n\\treturn fun(t);\\n}\\n```\\n\\nIf it helps. Do Upvote !",
                "solutionTags": [],
                "code": "```\\nvector<int> fun(vector<int> v){\\n\\n\\tif(v.size()<3)\\n\\t\\treturn v;\\n\\n\\tvector<int> t1;\\n\\tvector<int> t2;\\n\\n\\tfor(int i=0;i<v.size();i++){\\n\\t\\tif(i%2==0)\\n\\t\\t\\tt1.push_back(v[i]);\\n\\t\\telse\\n\\t\\t\\tt2.push_back(v[i]);\\n\\t}\\n\\n\\tt1=fun(t1);\\n\\tt2=fun(t2);\\n\\n\\tvector<int> t3;\\n\\tfor(int i=0;i<t1.size();i++)\\n\\t\\tt3.push_back(t1[i]);\\n\\tfor(int i=0;i<t2.size();i++)\\n\\t\\tt3.push_back(t2[i]);\\n\\n\\treturn t3;\\n}\\nvector<int> beautifulArray(int n) {\\n\\n\\tvector<int> t(n);\\n\\tfor(int i=1;i<=n;i++)\\n\\t\\tt[i-1]=i;\\n\\n\\treturn fun(t);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1367878,
                "title": "beautiful-array-recursion-with-short-explanation-c",
                "content": "Approach:\\n\\t\\n\\tRecursion: At first, we can put all even numbers on the left, and all odd numbers on the right.\\n\\t\\n    1. In this case, we only need to make left subarray beautiful, and right subarray beautiful,\\n    because any number on the left + any number on the right is odd, which cannot be divided by 2.\\n    2.Then we can recursively get the beautiful subarray on the left and on the right, then map them\\n    to the actual number from 1 to N.\\n    3.For even numbers, aka left subarray, left[i] *= 2. E.g. if N = 4, the left subarray will be (1, 2),\\n    and we need to multiply 2 for each number.\\n    we need to make them as (1, 5, 3).\\n\\t\\n\\t\\n\\t\\nCode:\\n\\n\\tclass Solution\\n\\t{\\n\\tpublic:\\n    vector<int> beautifulArray(int n)\\n    {\\n\\n        if(n==1)\\n        {\\n            return {1};\\n        }\\n        int even=n/2;\\n        int odd=(n+1)/2;\\n        vector<int>right=beautifulArray(odd);\\n        vector<int>left=beautifulArray(even);\\n\\n        for(int i=0; i<left.size(); i++)\\n        {\\n            left[i]=left[i]*2;\\n        }\\n        for(int i=0; i<right.size(); i++)\\n        {\\n            right[i]=right[i]*2-1;\\n        }\\n\\n        left.insert(left.end(),right.begin(),right.end());\\n\\n\\t\\t\\treturn left;\\n\\t\\t}\\n\\t};\\n\\n",
                "solutionTags": [],
                "code": "class Solution\\n\\t{\\n\\tpublic:\\n    vector<int> beautifulArray(int n)\\n    {\\n\\n        if(n==1)\\n        {\\n            return {1}",
                "codeTag": "Java"
            },
            {
                "id": 552796,
                "title": "concise-c-solution",
                "content": "Very concise solution:\\n\\n```C++\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        if (N == 1) return {1};\\n        vector<int> even = beautifulArray(N / 2);\\n        vector<int> odd = beautifulArray(N - N / 2);\\n        vector<int> rtn;\\n        for (int x : even) rtn.push_back(x * 2);\\n        for (int x : odd) rtn.push_back(x * 2 - 1);\\n        return rtn;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        if (N == 1) return {1};\\n        vector<int> even = beautifulArray(N / 2);\\n        vector<int> odd = beautifulArray(N - N / 2);\\n        vector<int> rtn;\\n        for (int x : even) rtn.push_back(x * 2);\\n        for (int x : odd) rtn.push_back(x * 2 - 1);\\n        return rtn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368607,
                "title": "java-0-ms-100-00-fast-explained-2-solutions",
                "content": "**# Approach 1** \\uD83D\\uDE80\\n```\\n// Runtime: 0 ms, faster than 100.00% of Java online submissions for Beautiful Array.\\n// Memory Usage: 38.5 MB, less than 85.53% of Java online submissions for Beautiful Array.\\n```\\n **- Using recursion**\\n\\nTake case of n=4 and n=8\\nfor n=4, we will get [1,3,2,4]\\n- which is derived when there are 2 array of size 2\\n- left = [1,2] and right = [1,2]\\n- we run 1st loop and it fills all even elements to result array\\nso array become [ _ , _ , 2 , 4 ]\\n- because every new element is calculated as right[i-left.length] * 2\\n- we run 2nd loop and it fills all odd elements to result array\\nso array become [ 1 , 3 , 2 , 4 ]\\n- because every new element is calculated as left[i] * 2 - 1\\n\\nnow if we observe the array it follows the key principle of magic array i.e.\\nAn array nums of length n is beautiful if:\\n- nums is a permutation of the integers in the range [1, n].\\n- For every 0 <= i < j < n, there is no index k with i < k < j where 2 * nums[k] == nums[i] + nums[j]\\n\\nfor n=8, we will get [1,5,3,7,2,6,4,8]\\n- this is because 2 subarray were left==right==[1,3,2,4]\\n\\n\\n\\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n       int[] answer = new int[n]; \\n        if(n == 1) {\\n            answer[0] = 1;\\n            return answer;\\n        }\\n            int[] right =beautifulArray(n/2);\\n            int[] left = beautifulArray((n+1)/2);\\n\\t\\t\\t\\n            for(int i=left.length; i<n; i++) {      //This loop adds all even elements at end\\n                answer[i] = right[i-left.length] * 2; \\n            }\\n            for(int i=0; i<left.length; i++) {      //This loop adds all odd elements at start\\n                answer[i] = left[i] * 2 - 1;     \\n            }\\n        return answer;\\n    }\\n}\\n```\\n\\n**# Approach 2** \\uD83D\\uDE80\\n```\\n// Runtime: 4 ms, faster than 27.04% of Java online submissions for Beautiful Array.\\n// Memory Usage: 38.6 MB, less than 85.53% of Java online submissions for Beautiful Array.\\n```\\n\\n - **Using loop to calculate next element**\\n\\nIdea is simple ->\\n* generate 2 sub array \\n  1st array calculate  elements as  -> 2 * element-1\\n  2nd array calculate elements as -> 2 * element\\n* add element in arrays only if new element is less than or equal to current length\\n* merge these array\\n\\n```\\n\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        ArrayList<Integer> answer=new ArrayList<>();\\n        answer.add(1);\\n        while(answer.size()<n){\\n            ArrayList<Integer> temp=new ArrayList<>();\\n                    for(int element:answer)\\n                        if(2*element-1<=n)\\n                            temp.add(element*2-1);\\n            \\n                    for(int element:answer)\\n                        if(2*element<=n)\\n                            temp.add(element*2);\\n                    \\n\\t\\t\\t\\t\\t//in different loops because we want to maintain order\\n            answer=temp;\\n        }\\n        return answer.stream().mapToInt(i -> i).toArray();\\n    }\\n}\\n```\\n\\n \\nPlease upvote to motivate me \\uD83D\\uDE80\\uD83D\\uDE80\\uD83D\\uDE80",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n// Runtime: 0 ms, faster than 100.00% of Java online submissions for Beautiful Array.\\n// Memory Usage: 38.5 MB, less than 85.53% of Java online submissions for Beautiful Array.\\n```\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n       int[] answer = new int[n]; \\n        if(n == 1) {\\n            answer[0] = 1;\\n            return answer;\\n        }\\n            int[] right =beautifulArray(n/2);\\n            int[] left = beautifulArray((n+1)/2);\\n\\t\\t\\t\\n            for(int i=left.length; i<n; i++) {      //This loop adds all even elements at end\\n                answer[i] = right[i-left.length] * 2; \\n            }\\n            for(int i=0; i<left.length; i++) {      //This loop adds all odd elements at start\\n                answer[i] = left[i] * 2 - 1;     \\n            }\\n        return answer;\\n    }\\n}\\n```\n```\\n// Runtime: 4 ms, faster than 27.04% of Java online submissions for Beautiful Array.\\n// Memory Usage: 38.6 MB, less than 85.53% of Java online submissions for Beautiful Array.\\n```\n```\\n\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        ArrayList<Integer> answer=new ArrayList<>();\\n        answer.add(1);\\n        while(answer.size()<n){\\n            ArrayList<Integer> temp=new ArrayList<>();\\n                    for(int element:answer)\\n                        if(2*element-1<=n)\\n                            temp.add(element*2-1);\\n            \\n                    for(int element:answer)\\n                        if(2*element<=n)\\n                            temp.add(element*2);\\n                    \\n\\t\\t\\t\\t\\t//in different loops because we want to maintain order\\n            answer=temp;\\n        }\\n        return answer.stream().mapToInt(i -> i).toArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367966,
                "title": "beautiful-array-cpp-simple-iterative-solution-explained",
                "content": "As per the the question if nums[k] multiply with 2 == nums[i]+nums[j] where i<k<j then the array is not beautiful . so we will use some basic maths now to solve this question .\\nnow as we know that (2 multiply with even number ) == even and also (odd*2) == even. so we can clearly say that in order to achieve desired result we have to make right hand side of following equation odd because left hand side be always even.\\nso in order to do that we will seperate both odd elements and even elements and place odd elements in left side of array and even in right side . hence making array beautiful.\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        vector<int> res = {1};\\n        while (res.size() < N) {\\n            vector<int> tmp;\\n            for (int i : res) if (i * 2 - 1 <= N) tmp.push_back(i * 2 - 1);\\n            for (int i : res) if (i * 2 <= N) tmp.push_back(i * 2);\\n            res = tmp;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Please upvote if you like the solution**",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        vector<int> res = {1};\\n        while (res.size() < N) {\\n            vector<int> tmp;\\n            for (int i : res) if (i * 2 - 1 <= N) tmp.push_back(i * 2 - 1);\\n            for (int i : res) if (i * 2 <= N) tmp.push_back(i * 2);\\n            res = tmp;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1072005,
                "title": "c-recursion-with-short-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        // Recursion: first, we can put all even numbers on the left, and all odd numbers on the right.\\n        // In this case, we only need to make left subarray beautiful, and right subarray beautiful,\\n        // because any number on the left + any number on the right is odd, which cannot be divided by 2.\\n        // Then we can recursively get the beautiful subarray on the left and on the right, then map them\\n        // to the actual number from 1 to N.\\n        // For even numbers, aka left subarray, left[i] *= 2. E.g. if N = 4, the left subarray will be (1, 2),\\n        // and we need to multiply 2 for each number.\\n        // For odd numbers, right[i] = right[i] * 2 - 1. E.g. if N = 5, the right subarray is (1, 3, 2), and \\n        // we need to make them as (1, 5, 3).\\n        if (N == 1)\\n        {\\n            return {1};\\n        }\\n        \\n        int evens = N / 2, odds = (N + 1) / 2;\\n        vector<int> left = beautifulArray(evens);\\n        vector<int> right = beautifulArray(odds);\\n        \\n        for (int i = 0; i < left.size(); ++i)\\n        {\\n            left[i] *= 2;\\n        }\\n        \\n        for (int i = 0; i < right.size(); ++i)\\n        {\\n            right[i] = right[i] * 2 - 1;\\n        }\\n        \\n        left.insert(left.end(), right.begin(), right.end());\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        // Recursion: first, we can put all even numbers on the left, and all odd numbers on the right.\\n        // In this case, we only need to make left subarray beautiful, and right subarray beautiful,\\n        // because any number on the left + any number on the right is odd, which cannot be divided by 2.\\n        // Then we can recursively get the beautiful subarray on the left and on the right, then map them\\n        // to the actual number from 1 to N.\\n        // For even numbers, aka left subarray, left[i] *= 2. E.g. if N = 4, the left subarray will be (1, 2),\\n        // and we need to multiply 2 for each number.\\n        // For odd numbers, right[i] = right[i] * 2 - 1. E.g. if N = 5, the right subarray is (1, 3, 2), and \\n        // we need to make them as (1, 5, 3).\\n        if (N == 1)\\n        {\\n            return {1};\\n        }\\n        \\n        int evens = N / 2, odds = (N + 1) / 2;\\n        vector<int> left = beautifulArray(evens);\\n        vector<int> right = beautifulArray(odds);\\n        \\n        for (int i = 0; i < left.size(); ++i)\\n        {\\n            left[i] *= 2;\\n        }\\n        \\n        for (int i = 0; i < right.size(); ++i)\\n        {\\n            right[i] = right[i] * 2 - 1;\\n        }\\n        \\n        left.insert(left.end(), right.begin(), right.end());\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687713,
                "title": "c-solution-beautiful-array",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        return solve(n);\\n    }\\n    \\n    vector<int> solve(int n){\\n        //base case\\n        if(n==1) {\\n            vector<int> k = {1};\\n            return k;\\n        }\\n        \\n        vector<int> ans = solve(n-1);\\n        vector<int> temp;\\n        for(int i = 0; i < ans.size(); i++){\\n            if(2*ans[i]-1 <= n) temp.push_back(2*ans[i]-1);\\n        }\\n        for(int i = 0; i < ans.size(); i++){\\n            if(2*ans[i] <= n) temp.push_back(2*ans[i]);\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Divide and Conquer",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        return solve(n);\\n    }\\n    \\n    vector<int> solve(int n){\\n        //base case\\n        if(n==1) {\\n            vector<int> k = {1};\\n            return k;\\n        }\\n        \\n        vector<int> ans = solve(n-1);\\n        vector<int> temp;\\n        for(int i = 0; i < ans.size(); i++){\\n            if(2*ans[i]-1 <= n) temp.push_back(2*ans[i]-1);\\n        }\\n        for(int i = 0; i < ans.size(); i++){\\n            if(2*ans[i] <= n) temp.push_back(2*ans[i]);\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401361,
                "title": "easy-solution-c-without-recursion",
                "content": "the key observation here is we can make beautiful arr from a beautiful arr by multiplying 2i and 2i-1 to all element of arr and taking value which is <=n\\n\\nlet me explain..\\n\\nlets just start with smallest beautiful array \\nwhen n=1\\narr->{1} now this is a beautiful array \\n\\nnow coming on equation 2*arr[k]!=arr[i]+arr[j]\\nif we multiply 2*i on both side equation remain same  //here i is any element of beautiful array\\n->2i*(2*arr[k])!=2i*(arr[i]+arr[j])\\n->this means that if i multiply 2 with all element of array then new array will also be beautiful\\n\\nfor ex:when n=1 arr={1}\\n->now multiplying 2 to every element arr become :{2} you can see that this also a beautiful arr\\n\\nnow again if we multiply (2i-1) to both side the equation remain same \\n->2i-1*(2*nums[k])!=(2i-1)*(nums[i]+nums[j])\\n->this means that if we multiply 2i-1 to arr element than new arr is also beautiful arr\\n\\nfor ex: n=1 arr={1}\\n->now multiply 2i-1 to every element : arr={1} you can see that rhis is beautiful array \\n\\n->now if we concatenate to beautiful arr we get a beautiful arr\\n\\nso concatenating {1}+{2}={1,2} is also a beautiful array \\n->now we got arr of size 2 from 1 \\n->for n=3 we have arr={1,2}\\nmultiply 2 to every element\\narr={2,4} //beautiful\\n\\nmultiply 2*i-1 to every element     // here i is element like when i=2 =2*2-1=3\\narr={1,3}\\n\\nnow add to arr={2,4}+{1,3}={2,4,1,3} //beautiful arr\\nbut here 4>3 so we delete it \\nnow arr become ->{2,1,3} // beautiful arr\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n      vector<int>ans;\\n        ans.push_back(1); //smallest beautiful arr\\n        \\n        int val=2; \\n        while(val<=n)\\n        {\\n            vector<int>temp;\\n            for(int it:ans)\\n                if(2*it-1<=val) //checking the element in bound of arr size\\n                    temp.push_back(2*it-1);\\n            \\n            for(int it:ans)\\n                if(2*it<=val)\\n                    temp.push_back(2*it);\\n            \\n            ans=temp;\\n            val++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n      vector<int>ans;\\n        ans.push_back(1); //smallest beautiful arr\\n        \\n        int val=2; \\n        while(val<=n)\\n        {\\n            vector<int>temp;\\n            for(int it:ans)\\n                if(2*it-1<=val) //checking the element in bound of arr size\\n                    temp.push_back(2*it-1);\\n            \\n            for(int it:ans)\\n                if(2*it<=val)\\n                    temp.push_back(2*it);\\n            \\n            ans=temp;\\n            val++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368108,
                "title": "java-easy-to-understand-even-odd-pattern-divide-and-conquer",
                "content": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {            \\n        int[] res = new int[n];     //odd,even \\n        if(n == 1) {\\n            res[0] = 1;\\n            return res;\\n        }\\n            int[] right =beautifulArray(n/2);\\n            int[] left = beautifulArray((n+1)/2);\\n            //Adding The Even nos.\\n            for(int i=left.length; i<n; i++) {\\n                res[i] = right[i-left.length] * 2; \\n            }\\n            // Adding the  odd nos.\\n            for(int i=0; i<left.length; i++) {\\n                res[i] = left[i] * 2 - 1;     \\n            }\\n        return res;\\n}\\n}\\n```\\n**Please Upvote If You Liked The Soln**",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {            \\n        int[] res = new int[n];     //odd,even \\n        if(n == 1) {\\n            res[0] = 1;\\n            return res;\\n        }\\n            int[] right =beautifulArray(n/2);\\n            int[] left = beautifulArray((n+1)/2);\\n            //Adding The Even nos.\\n            for(int i=left.length; i<n; i++) {\\n                res[i] = right[i-left.length] * 2; \\n            }\\n            // Adding the  odd nos.\\n            for(int i=0; i<left.length; i++) {\\n                res[i] = left[i] * 2 - 1;     \\n            }\\n        return res;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1184882,
                "title": "python3-divide-conquer",
                "content": "\\n```\\nclass Solution:\\n    def beautifulArray(self, N: int) -> List[int]:\\n        \\n        def fn(nums): \\n            \"\"\"Return beautiful array by rearraning elements in nums.\"\"\"\\n            if len(nums) <= 1: return nums\\n            return fn(nums[::2]) + fn(nums[1::2])\\n        \\n        return fn(list(range(1, N+1)))\\n```\\n\\nEdited on 7/28/2021\\nAlternative bottom-up implementation\\n```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        ans = [1]\\n        while len(ans) < n: \\n            ans = [2*x-1 for x in ans] + [2*x for x in ans]\\n        return [x for x in ans if x <= n]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulArray(self, N: int) -> List[int]:\\n        \\n        def fn(nums): \\n            \"\"\"Return beautiful array by rearraning elements in nums.\"\"\"\\n            if len(nums) <= 1: return nums\\n            return fn(nums[::2]) + fn(nums[1::2])\\n        \\n        return fn(list(range(1, N+1)))\\n```\n```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        ans = [1]\\n        while len(ans) < n: \\n            ans = [2*x-1 for x in ans] + [2*x for x in ans]\\n        return [x for x in ans if x <= n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 798542,
                "title": "simple-iterative-solution-c-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> res{1};\\n        if(n==1) return res ; \\n        \\n        while(res.size()<n){\\n            vector<int> tmp;\\n            for(int i  :res){\\n                if(2*i <= n){\\n                    tmp.push_back(2*i);\\n                }\\n            }\\n             for(int i  :res){\\n                if(2*i -1 <= n){\\n                    tmp.push_back(2*i-1);\\n                }\\n            }\\n            res = tmp;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\ngo through solution and observe output for n = 1,2,3,....\\n```\\nn=1\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t 1\\nn=2\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t2 1\\nn=3\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   2 1 3\\nn=4\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  4 2 3 1\\nn=5\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t 4 2 3 5 1\\nn=6\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t4 6 2 3 5 1\\nn=7\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   4 6 2 7 3 5 1\\nn=8\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  8 4 6 2 7 3 5 1\\n```\\nstart from 1 an at each step take the previous beautiful array and insrt even elements less than n in the same order as the previous arr by multiplying each element by 2 (insert 2*\\\\i in array )\\nthen add all odd elements into the array by taking previous array (beautiful(n-1)) multipying by 2 and suntract 1 ( insert 2\\\\*n -1 in array if 2\\\\*n-1 <n)\\nif u can\\'t understand read leetcode soln and if u want try generating the above pattern by hand. using  above code.\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> res{1};\\n        if(n==1) return res ; \\n        \\n        while(res.size()<n){\\n            vector<int> tmp;\\n            for(int i  :res){\\n                if(2*i <= n){\\n                    tmp.push_back(2*i);\\n                }\\n            }\\n             for(int i  :res){\\n                if(2*i -1 <= n){\\n                    tmp.push_back(2*i-1);\\n                }\\n            }\\n            res = tmp;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nn=1\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t 1\\nn=2\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t2 1\\nn=3\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   2 1 3\\nn=4\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  4 2 3 1\\nn=5\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t 4 2 3 5 1\\nn=6\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t4 6 2 3 5 1\\nn=7\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   4 6 2 7 3 5 1\\nn=8\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  8 4 6 2 7 3 5 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 694087,
                "title": "divide-and-conquer",
                "content": "I would like to walk through my path to the final solution.\\n\\nFirstly I observed that the condition `2 * A[k]` is an even, so naturally I think of splitting the array into 2 parts: odds + evens, then any number in odd part + any number in even part will result in an odd, which will satisfy the condition.\\n\\nThen we need to make sure numbers in each part satisfies the condition as well. Let\\'s take a look at the odd part first. Each number in this array could be denoted using the form `2ni + 1`, where i is the index of this number.\\n\\nWe need to make sure\\n```\\n2ni + 1 + 2nj + 1 != 2 * (2nk + 1), which simplifies to\\ni + j != 2k, where i, j, k are index of each number\\n```\\n\\nWe are seeing this form again :D So we can apply the same strategy as we apply earlier: split the array into 2 parts based on their index, odd index into 1 array and even index into another, and doing this recursively for each array:\\n\\n```\\nfunc split(s []int) []int {\\n    if len(s) <= 1 {\\n\\t\\treturn s\\n\\t}\\n\\t\\n\\todd, even := []int{}, []int{}\\n\\tfor i := 0; i < len(s); i ++ {\\n\\t\\tif i % 2 ==.0 {\\n\\t\\t\\teven = append(even, s[i])\\n\\t\\t} else {\\n\\t\\t\\todd = append(odd, s[i])\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn append(split(odd), split(even)...)\\n}\\n```",
                "solutionTags": [
                    "Divide and Conquer"
                ],
                "code": "```\\n2ni + 1 + 2nj + 1 != 2 * (2nk + 1), which simplifies to\\ni + j != 2k, where i, j, k are index of each number\\n```\n```\\nfunc split(s []int) []int {\\n    if len(s) <= 1 {\\n\\t\\treturn s\\n\\t}\\n\\t\\n\\todd, even := []int{}, []int{}\\n\\tfor i := 0; i < len(s); i ++ {\\n\\t\\tif i % 2 ==.0 {\\n\\t\\t\\teven = append(even, s[i])\\n\\t\\t} else {\\n\\t\\t\\todd = append(odd, s[i])\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn append(split(odd), split(even)...)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 186944,
                "title": "python-solution-with-chinese-explanation-showing-my-thinking-process",
                "content": "https://buptwc.github.io/2018/10/28/Leetcode-932-Beautiful-Array/\\nI can\\'t express my thoughts very well in English. Sorry for my poor English.\\nThe final idea is the same as others.\\n```python\\n# 28ms\\nclass Solution(object):\\n    def beautifulArray(self, N):\\n        cache = {}\\n        def solve(N):\\n            if N == 1: return [1]\\n            if N in cache: return cache[N]\\n            \\n            even_index = N // 2\\n            odd_index = N - even_index\\n            even = solve(even_index)\\n            odd = solve(odd_index)\\n            even = [2*val for val in even]\\n            odd = [2*val-1 for val in odd]\\n            cache[N] = even + odd\\n            return cache[N]\\n        return solve(N)\\n```",
                "solutionTags": [],
                "code": "```python\\n# 28ms\\nclass Solution(object):\\n    def beautifulArray(self, N):\\n        cache = {}\\n        def solve(N):\\n            if N == 1: return [1]\\n            if N in cache: return cache[N]\\n            \\n            even_index = N // 2\\n            odd_index = N - even_index\\n            even = solve(even_index)\\n            odd = solve(odd_index)\\n            even = [2*val for val in even]\\n            odd = [2*val-1 for val in odd]\\n            cache[N] = even + odd\\n            return cache[N]\\n        return solve(N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676288,
                "title": "python-easy-solution",
                "content": "```\\ndef beautifulArray(self, n: int) -> List[int]:\\n\\tans = [1]\\n\\twhile len(ans) < n:\\n\\t\\tres = []\\n\\t\\tfor el in ans:\\n\\t\\t\\tif 2 * el - 1 <= n:\\n\\t\\t\\t\\tres.append(el * 2 - 1)\\n\\n\\t\\tfor el in ans: \\n\\t\\t\\tif 2 * el <= n:\\n\\t\\t\\t\\tres.append(el * 2)\\n\\n\\t\\tans = res\\n\\treturn ans\\n\\n# odd ele -> 2 * el - 1\\n# even ele -> 2 * el\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef beautifulArray(self, n: int) -> List[int]:\\n\\tans = [1]\\n\\twhile len(ans) < n:\\n\\t\\tres = []\\n\\t\\tfor el in ans:\\n\\t\\t\\tif 2 * el - 1 <= n:\\n\\t\\t\\t\\tres.append(el * 2 - 1)\\n\\n\\t\\tfor el in ans: \\n\\t\\t\\tif 2 * el <= n:\\n\\t\\t\\t\\tres.append(el * 2)\\n\\n\\t\\tans = res\\n\\treturn ans\\n\\n# odd ele -> 2 * el - 1\\n# even ele -> 2 * el\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1483741,
                "title": "a-simple-solution-c-0ms-o-n-time-o-1-space-explanation",
                "content": "A very simple fast solution  (C++)  O(N) time O(1) space\\n\\nIt generates one specific beautiful array for each N. \\n\\n**The inspiration:**\\nIt comes from the 4 observations\\n\\n1  The binary tree shown naturally sorts 2^N numbers into beautiful arrays.\\n\\n![image](https://assets.leetcode.com/users/images/93eb1233-a128-49d4-927e-b9823dfa2b08_1632560687.4727483.jpeg)\\n\\n\\n2.  The binary is sorting numbers in reverse bit order\\n\\n3.  Every ordered subset of N items in such a 2^M array, where 1 <= N <= M and where elements > N are removed, is also a beautiful array. \\nNote: I have not bothered to prove that, but I tested it up to N = 1000 which is the problem limit. \\n\\n4.  The 1..N array is a specialisation of 0..N\\n\\n**The implementation:**\\nTake a group of  1 - N integers,   say 1,2,3,4,5,6,7,8 ,9\\nCalculate the smallest power of two greater than N, in this case is 16. \\nAll the numbers up to 16 can be represented by 4 bits. \\nReverse the order of the bits of each of the 4 bit numbers, from 1 to 15  \\n\\t1  = 0001   becomes   8  = 1000\\n\\t2  = 0010   becomes   4  = 0100\\n    etc.\\n\\t\\nHere is the conversion of each number from 1 to 15 \\n\\n    Numbers       1  2  3  4  5   6   7  8  9 10 11 12 13 14 15   \\n\\tBit reversed  8 4 12  2 10  6 14  1  9   5 13   3  11  7 15\\n\\t\\nIf you increase the depth of the binary tree to 4 bits, those numbers will be in that order along the bottom. \\n\\nThe 15 values give you a beautiful array for any N from 1 to 15  by selecting the values in order that are <= N.\\nFor example where N = 9  the number <= 9 in order\\n\\t8  4 12  2 10  6 14  1  9   5 13   3 11   7 15. \\n\\t8  4       2       6       1  9   5        3        7\\nThat is a beautiful array for N = 9 \\n\\nNote: The algorithm is O(1) as it doesn\\'t store  the 2^N - 1 array.\\n\\nFrom point 4 above, the 1 to N soultions are a specialisation of 0 to N \\nIf you change the code to work from 0 to N you get\\n[ 0 2 1 ] is beautiful\\n[ 0 2 1 3 ] is beautiful\\n[ 0 4 2 1 3 ] is beautiful\\n[ 0 4 2 1 5 3 ] is beautiful\\n[ 0 4 2 6 1 5 3 ] is beautiful\\n[ 0 4 2 6 1 5 3 7 ] is beautiful\\n[ 0 8 4 2 6 1 5 3 7 ] is beautiful\\n[ 0 8 4 2 6 1 9 5 3 7 ] is beautiful\\n[ 0 8 4 2 10 6 1 9 5 3 7 ] is beautiful\\n[ 0 8 4 2 10 6 1 9 5 3 11 7 ] is beautiful\\n[ 0 8 4 12 2 10 6 1 9 5 3 11 7 ] is beautiful\\n[ 0 8 4 12 2 10 6 1 9 5 13 3 11 7 ] is beautiful\\n[ 0 8 4 12 2 10 6 14 1 9 5 13 3 11 7 ] is beautiful\\n[ 0 8 4 12 2 10 6 14 1 9 5 13 3 11 7 15 ] is beautiful\\n\\n\\n\\nTo calculate where  N  = 1000,  you make the table for 2^10 (1024) and use 10 bit numbers which you reverse in the same way. \\n\\nThe beautifull array it generates for N =1000 array is below (after the code) \\nFrom that you can extract a beautiful array for every N from 1 to 1000 from it.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\tvector<int> beautifulArray(int n)\\n\\t\\t{\\t\\t\\t\\n    \\t    int maxbit; // max n is 1000\\n\\t\\t\\tfor (int i = 9; i >= 0; --i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (n & (1 << i)) { maxbit = i;\\tbreak;\\t}\\n\\t\\t\\t}\\t\\n\\t\\t\\tint powerOfTwo = (1 << maxbit + 1);\\n\\t    \\tauto array = vector<int>(n); \\n\\t\\t\\tfor (int i = 1, a = 0; i < powerOfTwo; ++i)\\n\\t    \\t{\\n\\t    \\t    int x = invertBits(i, maxbit + 1);\\n\\t    \\t\\tif (x > 0 && x <= n)\\n\\t    \\t\\t{\\n\\t    \\t\\t \\tarray[a++] = x;\\n\\t\\t\\t\\t}\\t    \\t\\t\\n\\t\\t\\t}\\t\\n\\t\\t\\treturn array;\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t    uint16_t invertBits(uint16_t b, int maxbits = 16) {\\n\\t\\t   uint16_t mask = 0b1111111100000000;\\n\\t\\t   b = (b & mask) >> 8 | (b & ~mask) << 8;\\n\\t\\t   mask = 0b1111000011110000;\\n\\t\\t   b = (b & mask) >> 4 | (b & ~mask) << 4;\\n\\t\\t   mask = 0b1100110011001100;\\n\\t\\t   b = (b & mask) >> 2 | (b & ~mask) << 2;\\n\\t\\t   mask = 0b1010101010101010;\\n\\t\\t   b = (b & mask) >> 1 | (b & ~mask) << 1;\\n\\t\\t   return b >> (16 - maxbits);\\n\\t\\t}\\n```\\n\\n\\n\\n```\\nvector<int> beautiful1000 = \\n{ 512, 256, 768, 128, 640, 384, 896, 64, 576, 320, 832, 192, 704, 448,\\n960, 32, 544, 288, 800, 160, 672, 416, 928, 96, 608, 352, 864, 224, \\n736, 480, 992, 16, 528, 272, 784, 144, 656, 400, 912, 80, 592, 336, \\n848, 208, 720, 464, 976, 48, 560, 304, 816, 176, 688, 432, 944, 112, \\n624, 368, 880, 240, 752, 496, 8, 520, 264, 776, 136, 648, 392, 904, \\n72, 584, 328, 840, 200, 712, 456, 968, 40, 552, 296, 808, 168, 680, \\n424, 936, 104, 616, 360, 872, 232, 744, 488, 1000, 24, 536, 280, 792, \\n152, 664, 408, 920, 88, 600, 344, 856, 216, 728, 472, 984, 56, 568, \\n312, 824, 184, 696, 440, 952, 120, 632, 376, 888, 248, 760, 504, 4, \\n516, 260, 772, 132, 644, 388, 900, 68, 580, 324, 836, 196, 708, 452, \\n964, 36, 548, 292, 804, 164, 676, 420, 932, 100, 612, 356, 868, 228, \\n740, 484, 996, 20, 532, 276, 788, 148, 660, 404, 916, 84, 596, 340, \\n852, 212, 724, 468, 980, 52, 564, 308, 820, 180, 692, 436, 948, 116, \\n628, 372, 884, 244, 756, 500, 12, 524, 268, 780, 140, 652, 396, 908, \\n76, 588, 332, 844, 204, 716, 460, 972, 44, 556, 300, 812, 172, 684, \\n428, 940, 108, 620, 364, 876, 236, 748, 492, 28, 540, 284, 796, 156, \\n668, 412, 924, 92, 604, 348, 860, 220, 732, 476, 988, 60, 572, 316, \\n828, 188, 700, 444, 956, 124, 636, 380, 892, 252, 764, 508, 2, 514, \\n258, 770, 130, 642, 386, 898, 66, 578, 322, 834, 194, 706, 450, 962, \\n34, 546, 290, 802, 162, 674, 418, 930, 98, 610, 354, 866, 226, 738, \\n482, 994, 18, 530, 274, 786, 146, 658, 402, 914, 82, 594, 338, 850, \\n210, 722, 466, 978, 50, 562, 306, 818, 178, 690, 434, 946, 114, 626, \\n370, 882, 242, 754, 498, 10, 522, 266, 778, 138, 650, 394, 906, 74, \\n586, 330, 842, 202, 714, 458, 970, 42, 554, 298, 810, 170, 682, 426,\\n938, 106, 618, 362, 874, 234, 746, 490, 26, 538, 282, 794, 154, 666, \\n410, 922, 90, 602, 346, 858, 218, 730, 474, 986, 58, 570, 314, 826, \\n186, 698, 442, 954, 122, 634, 378, 890, 250, 762, 506, 6, 518, 262, \\n774, 134, 646, 390, 902, 70, 582, 326, 838, 198, 710, 454, 966, 38, \\n550, 294, 806, 166, 678, 422, 934, 102, 614, 358, 870, 230, 742, 486, \\n998, 22, 534, 278, 790, 150, 662, 406, 918, 86, 598, 342, 854, 214, \\n726, 470, 982, 54, 566, 310, 822, 182, 694, 438, 950, 118, 630, 374, \\n886, 246, 758, 502, 14, 526, 270, 782, 142, 654, 398, 910, 78, 590, \\n334, 846, 206, 718, 462, 974, 46, 558, 302, 814, 174, 686, 430, 942, \\n110, 622, 366, 878, 238, 750, 494, 30, 542, 286, 798, 158, 670, 414, \\n926, 94, 606, 350, 862, 222, 734, 478, 990, 62, 574, 318, 830, 190, \\n702, 446, 958, 126, 638, 382, 894, 254, 766, 510, 1, 513, 257, 769, \\n129, 641, 385, 897, 65, 577, 321, 833, 193, 705, 449, 961, 33, 545, \\n289, 801, 161, 673, 417, 929, 97, 609, 353, 865, 225, 737, 481, 993, \\n17, 529, 273, 785, 145, 657, 401, 913, 81, 593, 337, 849, 209, 721, \\n465, 977, 49, 561, 305, 817, 177, 689, 433, 945, 113, 625, 369, 881, \\n241, 753, 497, 9, 521, 265, 777, 137, 649, 393, 905, 73, 585, 329, \\n841, 201, 713, 457, 969, 41, 553, 297, 809, 169, 681, 425, 937, 105, \\n617, 361, 873, 233, 745, 489, 25, 537, 281, 793, 153, 665, 409, 921, \\n89, 601, 345, 857, 217, 729, 473, 985, 57, 569, 313, 825, 185, 697, \\n441, 953, 121, 633, 377, 889, 249, 761, 505, 5, 517, 261, 773, 133, \\n645, 389, 901, 69, 581, 325, 837, 197, 709, 453, 965, 37, 549, 293, \\n805, 165, 677, 421, 933, 101, 613, 357, 869, 229, 741, 485, 997, 21, \\n533, 277, 789, 149, 661, 405, 917, 85, 597, 341, 853, 213, 725, 469, \\n981, 53, 565, 309, 821, 181, 693, 437, 949, 117, 629, 373, 885, 245, \\n757, 501, 13, 525, 269, 781, 141, 653, 397, 909, 77, 589, 333, 845, \\n205, 717, 461, 973, 45, 557, 301, 813, 173, 685, 429, 941, 109, 621, \\n365, 877, 237, 749, 493, 29, 541, 285, 797, 157, 669, 413, 925, 93, \\n605, 349, 861, 221, 733, 477, 989, 61, 573, 317, 829, 189, 701, 445, \\n957, 125, 637, 381, 893, 253, 765, 509, 3, 515, 259, 771, 131, 643, \\n387, 899, 67, 579, 323, 835, 195, 707, 451, 963, 35, 547, 291, 803, \\n163, 675, 419, 931, 99, 611, 355, 867, 227, 739, 483, 995, 19, 531, \\n275, 787, 147, 659, 403, 915, 83, 595, 339, 851, 211, 723, 467, 979, \\n51, 563, 307, 819, 179, 691, 435, 947, 115, 627, 371, 883, 243, 755, \\n499, 11, 523, 267, 779, 139, 651, 395, 907, 75, 587, 331, 843, 203, \\n715, 459, 971, 43, 555, 299, 811, 171, 683, 427, 939, 107, 619, 363, \\n875, 235, 747, 491, 27, 539, 283, 795, 155, 667, 411, 923, 91, 603, \\n347, 859, 219, 731, 475, 987, 59, 571, 315, 827, 187, 699, 443, 955, \\n123, 635, 379, 891, 251, 763, 507, 7, 519, 263, 775, 135, 647, 391, \\n903, 71, 583, 327, 839, 199, 711, 455, 967, 39, 551, 295, 807, 167, \\n679, 423, 935, 103, 615, 359, 871, 231, 743, 487, 999, 23, 535, 279, \\n791, 151, 663, 407, 919, 87, 599, 343, 855, 215, 727, 471, 983, 55, \\n567, 311, 823, 183, 695, 439, 951, 119, 631, 375, 887, 247, 759, 503, \\n15, 527, 271, 783, 143, 655, 399, 911, 79, 591, 335, 847, 207, 719, \\n463, 975, 47, 559, 303, 815, 175, 687, 431, 943, 111, 623, 367, 879, \\n239, 751, 495, 31, 543, 287, 799, 159, 671, 415, 927, 95, 607, 351, \\n863, 223, 735, 479, 991, 63, 575, 319, 831, 191, 703, 447, 959, 127, \\n639, 383, 895, 255, 767, 511 }; // beautiful\\n\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\tvector<int> beautifulArray(int n)\\n\\t\\t{\\t\\t\\t\\n    \\t    int maxbit; // max n is 1000\\n\\t\\t\\tfor (int i = 9; i >= 0; --i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (n & (1 << i)) { maxbit = i;\\tbreak;\\t}\\n\\t\\t\\t}\\t\\n\\t\\t\\tint powerOfTwo = (1 << maxbit + 1);\\n\\t    \\tauto array = vector<int>(n); \\n\\t\\t\\tfor (int i = 1, a = 0; i < powerOfTwo; ++i)\\n\\t    \\t{\\n\\t    \\t    int x = invertBits(i, maxbit + 1);\\n\\t    \\t\\tif (x > 0 && x <= n)\\n\\t    \\t\\t{\\n\\t    \\t\\t \\tarray[a++] = x;\\n\\t\\t\\t\\t}\\t    \\t\\t\\n\\t\\t\\t}\\t\\n\\t\\t\\treturn array;\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t    uint16_t invertBits(uint16_t b, int maxbits = 16) {\\n\\t\\t   uint16_t mask = 0b1111111100000000;\\n\\t\\t   b = (b & mask) >> 8 | (b & ~mask) << 8;\\n\\t\\t   mask = 0b1111000011110000;\\n\\t\\t   b = (b & mask) >> 4 | (b & ~mask) << 4;\\n\\t\\t   mask = 0b1100110011001100;\\n\\t\\t   b = (b & mask) >> 2 | (b & ~mask) << 2;\\n\\t\\t   mask = 0b1010101010101010;\\n\\t\\t   b = (b & mask) >> 1 | (b & ~mask) << 1;\\n\\t\\t   return b >> (16 - maxbits);\\n\\t\\t}\\n```\n```\\nvector<int> beautiful1000 = \\n{ 512, 256, 768, 128, 640, 384, 896, 64, 576, 320, 832, 192, 704, 448,\\n960, 32, 544, 288, 800, 160, 672, 416, 928, 96, 608, 352, 864, 224, \\n736, 480, 992, 16, 528, 272, 784, 144, 656, 400, 912, 80, 592, 336, \\n848, 208, 720, 464, 976, 48, 560, 304, 816, 176, 688, 432, 944, 112, \\n624, 368, 880, 240, 752, 496, 8, 520, 264, 776, 136, 648, 392, 904, \\n72, 584, 328, 840, 200, 712, 456, 968, 40, 552, 296, 808, 168, 680, \\n424, 936, 104, 616, 360, 872, 232, 744, 488, 1000, 24, 536, 280, 792, \\n152, 664, 408, 920, 88, 600, 344, 856, 216, 728, 472, 984, 56, 568, \\n312, 824, 184, 696, 440, 952, 120, 632, 376, 888, 248, 760, 504, 4, \\n516, 260, 772, 132, 644, 388, 900, 68, 580, 324, 836, 196, 708, 452, \\n964, 36, 548, 292, 804, 164, 676, 420, 932, 100, 612, 356, 868, 228, \\n740, 484, 996, 20, 532, 276, 788, 148, 660, 404, 916, 84, 596, 340, \\n852, 212, 724, 468, 980, 52, 564, 308, 820, 180, 692, 436, 948, 116, \\n628, 372, 884, 244, 756, 500, 12, 524, 268, 780, 140, 652, 396, 908, \\n76, 588, 332, 844, 204, 716, 460, 972, 44, 556, 300, 812, 172, 684, \\n428, 940, 108, 620, 364, 876, 236, 748, 492, 28, 540, 284, 796, 156, \\n668, 412, 924, 92, 604, 348, 860, 220, 732, 476, 988, 60, 572, 316, \\n828, 188, 700, 444, 956, 124, 636, 380, 892, 252, 764, 508, 2, 514, \\n258, 770, 130, 642, 386, 898, 66, 578, 322, 834, 194, 706, 450, 962, \\n34, 546, 290, 802, 162, 674, 418, 930, 98, 610, 354, 866, 226, 738, \\n482, 994, 18, 530, 274, 786, 146, 658, 402, 914, 82, 594, 338, 850, \\n210, 722, 466, 978, 50, 562, 306, 818, 178, 690, 434, 946, 114, 626, \\n370, 882, 242, 754, 498, 10, 522, 266, 778, 138, 650, 394, 906, 74, \\n586, 330, 842, 202, 714, 458, 970, 42, 554, 298, 810, 170, 682, 426,\\n938, 106, 618, 362, 874, 234, 746, 490, 26, 538, 282, 794, 154, 666, \\n410, 922, 90, 602, 346, 858, 218, 730, 474, 986, 58, 570, 314, 826, \\n186, 698, 442, 954, 122, 634, 378, 890, 250, 762, 506, 6, 518, 262, \\n774, 134, 646, 390, 902, 70, 582, 326, 838, 198, 710, 454, 966, 38, \\n550, 294, 806, 166, 678, 422, 934, 102, 614, 358, 870, 230, 742, 486, \\n998, 22, 534, 278, 790, 150, 662, 406, 918, 86, 598, 342, 854, 214, \\n726, 470, 982, 54, 566, 310, 822, 182, 694, 438, 950, 118, 630, 374, \\n886, 246, 758, 502, 14, 526, 270, 782, 142, 654, 398, 910, 78, 590, \\n334, 846, 206, 718, 462, 974, 46, 558, 302, 814, 174, 686, 430, 942, \\n110, 622, 366, 878, 238, 750, 494, 30, 542, 286, 798, 158, 670, 414, \\n926, 94, 606, 350, 862, 222, 734, 478, 990, 62, 574, 318, 830, 190, \\n702, 446, 958, 126, 638, 382, 894, 254, 766, 510, 1, 513, 257, 769, \\n129, 641, 385, 897, 65, 577, 321, 833, 193, 705, 449, 961, 33, 545, \\n289, 801, 161, 673, 417, 929, 97, 609, 353, 865, 225, 737, 481, 993, \\n17, 529, 273, 785, 145, 657, 401, 913, 81, 593, 337, 849, 209, 721, \\n465, 977, 49, 561, 305, 817, 177, 689, 433, 945, 113, 625, 369, 881, \\n241, 753, 497, 9, 521, 265, 777, 137, 649, 393, 905, 73, 585, 329, \\n841, 201, 713, 457, 969, 41, 553, 297, 809, 169, 681, 425, 937, 105, \\n617, 361, 873, 233, 745, 489, 25, 537, 281, 793, 153, 665, 409, 921, \\n89, 601, 345, 857, 217, 729, 473, 985, 57, 569, 313, 825, 185, 697, \\n441, 953, 121, 633, 377, 889, 249, 761, 505, 5, 517, 261, 773, 133, \\n645, 389, 901, 69, 581, 325, 837, 197, 709, 453, 965, 37, 549, 293, \\n805, 165, 677, 421, 933, 101, 613, 357, 869, 229, 741, 485, 997, 21, \\n533, 277, 789, 149, 661, 405, 917, 85, 597, 341, 853, 213, 725, 469, \\n981, 53, 565, 309, 821, 181, 693, 437, 949, 117, 629, 373, 885, 245, \\n757, 501, 13, 525, 269, 781, 141, 653, 397, 909, 77, 589, 333, 845, \\n205, 717, 461, 973, 45, 557, 301, 813, 173, 685, 429, 941, 109, 621, \\n365, 877, 237, 749, 493, 29, 541, 285, 797, 157, 669, 413, 925, 93, \\n605, 349, 861, 221, 733, 477, 989, 61, 573, 317, 829, 189, 701, 445, \\n957, 125, 637, 381, 893, 253, 765, 509, 3, 515, 259, 771, 131, 643, \\n387, 899, 67, 579, 323, 835, 195, 707, 451, 963, 35, 547, 291, 803, \\n163, 675, 419, 931, 99, 611, 355, 867, 227, 739, 483, 995, 19, 531, \\n275, 787, 147, 659, 403, 915, 83, 595, 339, 851, 211, 723, 467, 979, \\n51, 563, 307, 819, 179, 691, 435, 947, 115, 627, 371, 883, 243, 755, \\n499, 11, 523, 267, 779, 139, 651, 395, 907, 75, 587, 331, 843, 203, \\n715, 459, 971, 43, 555, 299, 811, 171, 683, 427, 939, 107, 619, 363, \\n875, 235, 747, 491, 27, 539, 283, 795, 155, 667, 411, 923, 91, 603, \\n347, 859, 219, 731, 475, 987, 59, 571, 315, 827, 187, 699, 443, 955, \\n123, 635, 379, 891, 251, 763, 507, 7, 519, 263, 775, 135, 647, 391, \\n903, 71, 583, 327, 839, 199, 711, 455, 967, 39, 551, 295, 807, 167, \\n679, 423, 935, 103, 615, 359, 871, 231, 743, 487, 999, 23, 535, 279, \\n791, 151, 663, 407, 919, 87, 599, 343, 855, 215, 727, 471, 983, 55, \\n567, 311, 823, 183, 695, 439, 951, 119, 631, 375, 887, 247, 759, 503, \\n15, 527, 271, 783, 143, 655, 399, 911, 79, 591, 335, 847, 207, 719, \\n463, 975, 47, 559, 303, 815, 175, 687, 431, 943, 111, 623, 367, 879, \\n239, 751, 495, 31, 543, 287, 799, 159, 671, 415, 927, 95, 607, 351, \\n863, 223, 735, 479, 991, 63, 575, 319, 831, 191, 703, 447, 959, 127, \\n639, 383, 895, 255, 767, 511 }; // beautiful\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368251,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> ff = {1};\\n        int n1 = 2;\\n        while((int)(ff.size()) < n){\\n            vector<int> odd;\\n            vector<int> even;\\n            // compute odd\\n            for(int i=0;i<(int)ff.size();i++){\\n                if((2*ff[i]) - 1 <= n1){\\n                    odd.push_back(2*(ff[i])-1);  \\n                }\\n            }\\n            // compute even\\n            for(int i=0;i<(int)ff.size();i++){\\n                if((2*ff[i]) <= n1){\\n                    even.push_back(2*(ff[i]));  \\n                }\\n            }\\n            // add both\\n            ff.clear();\\n            for(auto it : odd){\\n                ff.push_back(it);\\n            }\\n            for(auto it : even){\\n                ff.push_back(it);\\n            }\\n            n1+=1;\\n        }\\n        return ff;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> ff = {1};\\n        int n1 = 2;\\n        while((int)(ff.size()) < n){\\n            vector<int> odd;\\n            vector<int> even;\\n            // compute odd\\n            for(int i=0;i<(int)ff.size();i++){\\n                if((2*ff[i]) - 1 <= n1){\\n                    odd.push_back(2*(ff[i])-1);  \\n                }\\n            }\\n            // compute even\\n            for(int i=0;i<(int)ff.size();i++){\\n                if((2*ff[i]) <= n1){\\n                    even.push_back(2*(ff[i]));  \\n                }\\n            }\\n            // add both\\n            ff.clear();\\n            for(auto it : odd){\\n                ff.push_back(it);\\n            }\\n            for(auto it : even){\\n                ff.push_back(it);\\n            }\\n            n1+=1;\\n        }\\n        return ff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 507089,
                "title": "c-6-line-code-100-100",
                "content": "class Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        vector<int> ans = {1};\\n        while (ans.size() < N) {\\n            vector<int> temp;\\n            for (int i : ans) if (i * 2 - 1 <= N) temp.push_back(i * 2 - 1);\\n            for (int i : ans) if (i * 2 <= N) temp.push_back(i * 2);\\n            ans = temp;\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        vector<int> ans = {1}",
                "codeTag": "Java"
            },
            {
                "id": 3768579,
                "title": "easy-code-for-beginner-with-one-line",
                "content": "# Intuition\\nfirst i done it on 20 lines but now it is one line\\n\\n# Approach\\ndone through simple reccurrsion\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        return [1] if n<2 else [i*2-1 for i in self.beautifulArray((n+1)//2)]+[i*2 for i in self.beautifulArray(n//2)]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        return [1] if n<2 else [i*2-1 for i in self.beautifulArray((n+1)//2)]+[i*2 for i in self.beautifulArray(n//2)]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692187,
                "title": "recursive-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        if (n==1) return {1};\\n        \\n        vector<int> arr = beautifulArray(n-1);\\n\\n        vector<int> res;\\n        for (auto i: arr)\\n            if (2*i - 1 <= n) \\n                res.push_back(2*i-1);\\n\\n        for (auto i: arr)\\n            if (2*i <= n) \\n                res.push_back(2*i);\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        if (n==1) return {1};\\n        \\n        vector<int> arr = beautifulArray(n-1);\\n\\n        vector<int> res;\\n        for (auto i: arr)\\n            if (2*i - 1 <= n) \\n                res.push_back(2*i-1);\\n\\n        for (auto i: arr)\\n            if (2*i <= n) \\n                res.push_back(2*i);\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826859,
                "title": "beautiful-array",
                "content": "//weird question no logic responded \\n//just you guys have seen the pattern \\n//**even odd type sequence after running few n=5,6,7 etc  you will understand the pattern..**\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) \\n    {\\n        vector<int>ans={1};\\n        while(ans.size()<n)\\n        {\\n            vector<int>temp;\\n            //storing the even values \\n            for(auto x : ans)\\n                if(x*2<=n)\\n                    temp.push_back(x*2);\\n            // storing the odd values\\n            for(auto x : ans)\\n                if(x*2-1<=n)\\n                    temp.push_back(x*2-1);\\n            \\n            ans=temp;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> beautifulArray(int n) \\n    {\\n        vector<int>ans={1}",
                "codeTag": "Java"
            },
            {
                "id": 1506453,
                "title": "c-short-and-simple-explanation",
                "content": "1. If the most left element is even and the most right element is odd, then arr[left] * arr[right] != 2 * arr[i] (it is any number, even or odd, in-between), because expression on the left is always odd and expression on the right is always even.\\n2. Let\\'s think about divide and conquer and get beautiful array for left and right part or array.\\n3. Then make all elements for left part even (multiply all of them to 2 and all elements of right odd (multiply all of them to 2 and substract 1).\\n4. So left and right parts are still beautiful (multiplication and substraction, which we did, will not affect its beauty) and left and right parts become odd and even as well. So concatenation of them will result into beautiful array.\\n\\n```\\nvector<int> beautifulArray(int n) { \\n\\tif (n == 1) return { 1 };\\n\\n\\tauto left = beautifulArray(n / 2);\\n\\tauto right = beautifulArray(n - (n / 2));\\n\\n\\tvector<int> res;\\n\\n\\tfor (auto l : left)\\n\\t\\tres.push_back(l * 2);\\n\\n\\tfor (auto r : right)\\n\\t\\tres.push_back(r * 2 - 1);\\n\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> beautifulArray(int n) { \\n\\tif (n == 1) return { 1 };\\n\\n\\tauto left = beautifulArray(n / 2);\\n\\tauto right = beautifulArray(n - (n / 2));\\n\\n\\tvector<int> res;\\n\\n\\tfor (auto l : left)\\n\\t\\tres.push_back(l * 2);\\n\\n\\tfor (auto r : right)\\n\\t\\tres.push_back(r * 2 - 1);\\n\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1369666,
                "title": "python-different-o-n-solution-proof",
                "content": "My solution is completely different from what I\\'ve seen a bunch of other people do. Instead of divide and conquer, I build a sequence using repeated interleaving (the `double()` function below).\\n\\nProving that the interleaving works was pretty tricky to do; however, we can easily test that it works for N <= 1000 by making use of the fact that this code works for N = 1000. As we can see that the way the construction works gives the same output as if we just took the output for N=1000 and deleted the elements of the array that are too large. Since it\\'s fairly easy to see that if you take a beautiful array and delete some elements, then the resulting array is still beautiful.\\n\\nA proof, however, that this works for all N is below.\\n\\n```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        # We can partition the array into an odd half \\n        # and an even half. This is because the only way \\n        # 2 * nums[k] == nums[i] + nums[j] \\n        # is if nums[i] and nums[j] are the same parity.\\n        \\n        odds = [1, 3]\\n        evens = [2, 4]\\n        \\n        def double(arr):\\n            ans = []\\n            for i in range(len(arr)):\\n                ans.append(arr[i])\\n                ans.append(arr[i] + len(arr) * 2)\\n            return ans\\n        \\n        while len(odds) + len(evens) < n:\\n            odds = double(odds)\\n            evens = double(evens)\\n        \\n\\t\\t# Deleting elements from an array doesn\\'t change whether it\\'s \\n\\t\\t# still beautiful or not.\\n        odds = [v for v in odds if v <= n]\\n        evens = [v for v in evens if v <= n]\\n        return odds + evens\\n```\\n\\nThe space usage is O(N) and the time is also O(N), but this is a bit harder to see. However, we know that `1/2 + 1/4 + 1/8 + ... = 1`, so the `while`-loop in total only takes O(N) time.\\n\\n# **Proof**\\n\\nWe will only prove that our double operation works for the `odds`. Since the `evens` array is just the `odds` array multiplied by 2 and multiplying every number by 2 doesn\\'t affect the beautifulness of an array. **Note that when I say beautiful, I\\'m only refering to the second property.**\\n\\nAssume we have numbers `1, 3, 5, ..., 2(n - 1) + 1`\\n \\nWe can shuffle them into a sequence:\\n \\n`a_1, a_2, ..., a_n`  (sequence 1)\\n \\nRunning `double()` on the above sequence we get:\\n \\n`a_1, a_1 + 2n, a_2, a_2 + 2n, ..., a_n, a_n + 2n` (sequence 2)\\n \\nRunning `double()` a second time we get\\n \\n`a_1, a_1 + 4n, a_1 + 2n, a_1 + 6n, a_2, a_2 + 4n, a_2 + 2n, a_2 + 6n, ..., a_n, a_n + 4n, a_n + 2n, a_n + 6n` (sequence 3)\\n\\n#### Theorem\\n\\nGiven that sequence 1 and 2 are beautiful, we can show that sequence 3 is beautiful too.\\n\\nIf we use [1, 3] and [1, 5, 3, 7] as sequences 1 and 2, respective, then this theorem means that the algorithm works for all N.\\n\\n#### Proof\\nUsing a proof by contraction: Let\\'s assume that sequence 3 isn\\'t beautiful. Then we have,\\n`a_i + {0,2,4,6}_i*n + a_j + {0,2,4,6}_j*n = 2(a_k + {0,2,4,6}_k*n)` where `i <= k <= j`\\n\\nNote that `{0,2,4,6}_i` means that we choose one value from 0, 2, 4 or 6. This is to account for the `+ 0`, `+ 2n`, `+ 4n` and `+ 6n` factors in sequence 3.\\n\\nNow we have 4 cases for `i <= k <= j` to consider.\\n \\n**Case 1**: If `a_i = a_k = a_j`:\\n```\\n   a_i + {0,2,4,6}_i*n + a_j + {0,2,4,6}_j*n = 2(a_k + {0,2,4,6}_k*n)\\n=> a_i + {0,2,4,6}_i*n + a_i + {0,2,4,6}_j*n = 2(a_i + {0,2,4,6}_k*n)\\n=> {0,2,4,6}_i*n + {0,2,4,6}_j*n = 2{0,2,4,6}_k*n\\n```\\n\\nThis is a contradiction as `{0,2,4,6}_i, {0,2,4,6}_k, {0,2,4,6}_j` is some subsequence of [0, 4, 2, 6], but subsequences of beautiful arrays are beautiful.\\n \\n**Case 2**: If `a_i = a_k` and `a_i != a_j`:\\n```\\n   a_i + {0,2,4,6}_i*n + a_j + {0,2,4,6}_j*n = 2(a_k + {0,2,4,6}_k*n)\\n=> a_i + {0,2,4,6}_i*n + a_j + {0,2,4,6}_j*n = 2(a_i + {0,2,4,6}_k*n)\\n=> {0,2,4,6}_i*n + a_j + {0,2,4,6}_j*n = a_i + {0,2,4,6}_k*n\\n=> a_j - a_i = {0,2,4,6}_k*n - {0,2,4,6}_i*n - {0,2,4,6}_j*n\\n```\\n \\nThe LHS is non-zero as `a_i != a_j`. So the RHS must be non-zero too.\\n \\nThe largest *absolute* (i.e., non-negative) value of the LHS is `(2(n - 1) + 1) - 1 = 2n - 2` as we maximize the difference between `a_j` and `a_i` by choosing the smallest and largest possible values.\\n\\nThe smallest non-zero *absolute* value of the RHS is `2n`.\\n \\nTherefore, the equality can never hold and we have a contradiction as the largest absolute value of the LHS is strictly less than the smallest absolute value of the RHS.\\n \\n**Case 3**: If `a_j = a_k` and `a_i != a_j`:\\nSame as argument as case 2.\\n \\n**Case 4**: if `i < k < j`:\\n```\\n    a_i + {0,2,4,6}_i*n + a_j + {0,2,4,6}_j*n = 2(a_k + {0,2,4,6}_k*n)\\n=> 2a_k - a_i - a_j = 2{0,2,4,6}_k*n - {0,2,4,6}_i*n - {0,2,4,6}_j*n\\n ```\\n \\nThe LHS should be non-zero or sequence 1 would be not beautiful. As `2a_k - a_i - a_j = 0` implies `a_i + a_j  = 2a_k`\\n \\nThe greatest the LHS\\'s absolute value can be is `|1 - (2(n-1) - 1) - (2(n-1) - 3)| = |1 - 2n + 3 - 2n + 5| = 4n - 9`. We maximize this by chosing the 2 largest values (for `a_i` and `a_j`) and the smallest value (for `a_k`).\\nThe absolute value of the RHS is at least `2n`. \\n \\nTherefore, RHS absolute value is `2n` and, thus, either `a_i + a_j = 2a_k + 2n` (case 4a) holds or `a_i + a_j = 2a_k - 2n` (case 4b) holds\\n \\n**Case 4a**: `a_i + a_j = 2a_k + 2n`\\n```\\n   a_i + a_j = 2a_k + 2n\\n=> a_i + a_j + 2n = 2a_k + 4n = 2(a_k + 2n)\\n```\\n\\nHowever, if this is true then sequence 2 isn\\'t beautiful, which is a contradiction. This is because we can use the numbers `a_i` and `a_j + 2n` and `a_k + 2n` in sequence 2 and we know from i < k < j, that `a_k + 2n`  lies between `a_i` and `a_j + 2n`. \\n \\n**Case 4b**: `a_i + a_j = 2a_k - 2n`\\n```\\n   a_i + a_j = 2a_k - 2n\\n=> a_i + a_j + 2n = 2a_k\\n```\\n\\nHowever, if this is true then sequence 2 isn\\'t beautiful. Again, like in case 4a, this is because we can use the numbers `a_i` and `a_j + 2n` and `a_k` in sequence 2.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        # We can partition the array into an odd half \\n        # and an even half. This is because the only way \\n        # 2 * nums[k] == nums[i] + nums[j] \\n        # is if nums[i] and nums[j] are the same parity.\\n        \\n        odds = [1, 3]\\n        evens = [2, 4]\\n        \\n        def double(arr):\\n            ans = []\\n            for i in range(len(arr)):\\n                ans.append(arr[i])\\n                ans.append(arr[i] + len(arr) * 2)\\n            return ans\\n        \\n        while len(odds) + len(evens) < n:\\n            odds = double(odds)\\n            evens = double(evens)\\n        \\n\\t\\t# Deleting elements from an array doesn\\'t change whether it\\'s \\n\\t\\t# still beautiful or not.\\n        odds = [v for v in odds if v <= n]\\n        evens = [v for v in evens if v <= n]\\n        return odds + evens\\n```\n```\\n   a_i + {0,2,4,6}_i*n + a_j + {0,2,4,6}_j*n = 2(a_k + {0,2,4,6}_k*n)\\n=> a_i + {0,2,4,6}_i*n + a_i + {0,2,4,6}_j*n = 2(a_i + {0,2,4,6}_k*n)\\n=> {0,2,4,6}_i*n + {0,2,4,6}_j*n = 2{0,2,4,6}_k*n\\n```\n```\\n   a_i + {0,2,4,6}_i*n + a_j + {0,2,4,6}_j*n = 2(a_k + {0,2,4,6}_k*n)\\n=> a_i + {0,2,4,6}_i*n + a_j + {0,2,4,6}_j*n = 2(a_i + {0,2,4,6}_k*n)\\n=> {0,2,4,6}_i*n + a_j + {0,2,4,6}_j*n = a_i + {0,2,4,6}_k*n\\n=> a_j - a_i = {0,2,4,6}_k*n - {0,2,4,6}_i*n - {0,2,4,6}_j*n\\n```\n```\\n    a_i + {0,2,4,6}_i*n + a_j + {0,2,4,6}_j*n = 2(a_k + {0,2,4,6}_k*n)\\n=> 2a_k - a_i - a_j = 2{0,2,4,6}_k*n - {0,2,4,6}_i*n - {0,2,4,6}_j*n\\n ```\n```\\n   a_i + a_j = 2a_k + 2n\\n=> a_i + a_j + 2n = 2a_k + 4n = 2(a_k + 2n)\\n```\n```\\n   a_i + a_j = 2a_k - 2n\\n=> a_i + a_j + 2n = 2a_k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368199,
                "title": "python3-recursive-one-liner",
                "content": "```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        return (\\n            [1, 2][:n]\\n            if n < 3\\n            else [x * 2 - 1 for x in self.beautifulArray((n + 1) // 2)]\\n            + [x * 2 for x in self.beautifulArray(n // 2)]\\n        )\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        return (\\n            [1, 2][:n]\\n            if n < 3\\n            else [x * 2 - 1 for x in self.beautifulArray((n + 1) // 2)]\\n            + [x * 2 for x in self.beautifulArray(n // 2)]\\n        )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367890,
                "title": "932-beautiful-array-python-24ms",
                "content": "```\\nimport functools\\n\\nfdict = {}\\nfdict[1] = [1]\\nfdict[2] = [1,2]\\nfdict[3] = [1,3,2]\\nfdict[4] = [2,1,4,3]\\nfdict[5] = [3,1,2,5,4]\\n\\n@functools.cache\\ndef f(n):\\n    if n < 6:\\n        return fdict[n]\\n    return [2*x-1 for x in f(n//2+n%2)] + [2*x for x in f(n//2)] \\n```\\n\\nNote that an even and odd number always sum to an odd number, which will not interfere with any numbers in between. So we can split the array into [odd numbers, even numbers] which will be beautiful as long as the odd and even sections are individually beautiful. \\n\\nNote that \"beauty\" does not change when numbers are scaled linearly. \\n```(a*i + b) + (a*j + b) = a*(i+j) + 2b ?= a*(2k) + 2b = 2(a*k+b)```\\nFor i+j = 2k, scaled i + scaled j = 2*(scaled k). So the odd and even sections can be made beautiful by using our beautiful array function recursively. \\n\\nThe cache is used to save time when using this function multiple times, and some (more than necessary) base cases are included to aid with the recursion.",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nimport functools\\n\\nfdict = {}\\nfdict[1] = [1]\\nfdict[2] = [1,2]\\nfdict[3] = [1,3,2]\\nfdict[4] = [2,1,4,3]\\nfdict[5] = [3,1,2,5,4]\\n\\n@functools.cache\\ndef f(n):\\n    if n < 6:\\n        return fdict[n]\\n    return [2*x-1 for x in f(n//2+n%2)] + [2*x for x in f(n//2)] \\n```\n```(a*i + b) + (a*j + b) = a*(i+j) + 2b ?= a*(2k) + 2b = 2(a*k+b)```",
                "codeTag": "Python3"
            },
            {
                "id": 1004873,
                "title": "simplest-and-fastest-c-code-with-explanation",
                "content": "```\\n//EXPLANATION\\n/*\\nstart with 1 size array called result= [1]\\nwhile(size<=N){\\n    make a temp array for this iteration\\n    PUSH ODD NUMBERS from result array\\n    for(extract numbers from result array){\\n        let i = extracted number,say 1 and 2*i-1<N\\n        push(2*1-1)into temp array, temp = {1}\\n    }\\n    PUSH EVEN NUMBERS from result array\\n    for(extract numbers from result array){\\n        let i = extracted number,say 1 and 2*i-1<N\\n        push(2*1)into temp array, temp = {1,2}\\n    }\\n    new result array = temp \\n}\\nNEXT ITERATIONS\\n[1,2]=>Enter while loop =>first for loop, push 2*i-1=1(i=1),then 2*i-1=2*2-1=3 =>{1,3}\\n    Enter second while loop => (2*1=2),(2*2=4)={1,3,2,4}\\n[1,3,2,4] => {2*1-1,2*3-1,2*2-1,2*4-1}={1,5,3,7} and even=>{2*1,2*2,2*2,2*4}=>{2,6,4,8}\\n            => {1,5,3,7,2,6,4,8}\\n[1,5,3,7,2,4,6,8]......................and so on\\n\\n\\n\\n*/\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        vector<int> result = {1};\\n        while(result.size()<N){\\n            vector<int> temp;\\n            for(int i : result)\\n                if(i*2-1 <= N)\\n                    temp.push_back(i*2-1);\\n            for(int i:result)\\n                if(i*2 <= N)\\n                    temp.push_back(i*2);\\n            \\n            result = temp;\\n            \\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//EXPLANATION\\n/*\\nstart with 1 size array called result= [1]\\nwhile(size<=N){\\n    make a temp array for this iteration\\n    PUSH ODD NUMBERS from result array\\n    for(extract numbers from result array){\\n        let i = extracted number,say 1 and 2*i-1<N\\n        push(2*1-1)into temp array, temp = {1}\\n    }\\n    PUSH EVEN NUMBERS from result array\\n    for(extract numbers from result array){\\n        let i = extracted number,say 1 and 2*i-1<N\\n        push(2*1)into temp array, temp = {1,2}\\n    }\\n    new result array = temp \\n}\\nNEXT ITERATIONS\\n[1,2]=>Enter while loop =>first for loop, push 2*i-1=1(i=1),then 2*i-1=2*2-1=3 =>{1,3}\\n    Enter second while loop => (2*1=2),(2*2=4)={1,3,2,4}\\n[1,3,2,4] => {2*1-1,2*3-1,2*2-1,2*4-1}={1,5,3,7} and even=>{2*1,2*2,2*2,2*4}=>{2,6,4,8}\\n            => {1,5,3,7,2,6,4,8}\\n[1,5,3,7,2,4,6,8]......................and so on\\n\\n\\n\\n*/\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        vector<int> result = {1};\\n        while(result.size()<N){\\n            vector<int> temp;\\n            for(int i : result)\\n                if(i*2-1 <= N)\\n                    temp.push_back(i*2-1);\\n            for(int i:result)\\n                if(i*2 <= N)\\n                    temp.push_back(i*2);\\n            \\n            result = temp;\\n            \\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 812831,
                "title": "beautiful-array-c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        vector<int> result = {1};\\n        while(result.size()<N){\\n            vector<int> temp;\\n            for(int i : result)\\n                if(i*2-1 <= N)\\n                    temp.push_back(i*2-1);\\n            for(int i:result)\\n                if(i*2 <= N)\\n                    temp.push_back(i*2);\\n            \\n            result = temp;\\n            \\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        vector<int> result = {1};\\n        while(result.size()<N){\\n            vector<int> temp;\\n            for(int i : result)\\n                if(i*2-1 <= N)\\n                    temp.push_back(i*2-1);\\n            for(int i:result)\\n                if(i*2 <= N)\\n                    temp.push_back(i*2);\\n            \\n            result = temp;\\n            \\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 233410,
                "title": "c-recursive-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        vector<int> res,v;\\n        for(int i=1;i<=N;i++)v.push_back(i);\\n        helper(res,v);\\n        return res;   \\n    }\\n    void helper(vector<int>&res,vector<int> v)\\n    {\\n        int size=v.size();\\n        if(size==1)res.push_back(v[0]);\\n        else\\n        {\\n            vector<int> odd,even;\\n            for(int i=0;i<size;i++)i%2?odd.push_back(v[i]):even.push_back(v[i]);\\n            helper(res,even);\\n            helper(res,odd);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        vector<int> res,v;\\n        for(int i=1;i<=N;i++)v.push_back(i);\\n        helper(res,v);\\n        return res;   \\n    }\\n    void helper(vector<int>&res,vector<int> v)\\n    {\\n        int size=v.size();\\n        if(size==1)res.push_back(v[0]);\\n        else\\n        {\\n            vector<int> odd,even;\\n            for(int i=0;i<size;i++)i%2?odd.push_back(v[i]):even.push_back(v[i]);\\n            helper(res,even);\\n            helper(res,odd);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186819,
                "title": "short-java-solution",
                "content": "\\nCredit goes to: https://leetcode.com/problems/beautiful-array/discuss/186679/C++JavaPython-Odd-+-Even-Pattern-O(N)\\n```\\n    public int[] beautifulArray(int N) {\\n        int[] cache = new int[2*N], ret = new int[N];\\n        cache[0] = 1;\\n        \\n        int l = 1;\\n        while(l < N) {\\n            for(int i = 0; i < l; i++) cache[i] *= 2;\\n            for(int i = l; i < l * 2; i++) cache[i] = cache[i-l] - 1;\\n            l *= 2;\\n        }\\n        \\n        int j = 0;\\n        for(int i = 0; i < l; i++) if(cache[i] <= N) ret[j++] = cache[i];\\n        return ret;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] beautifulArray(int N) {\\n        int[] cache = new int[2*N], ret = new int[N];\\n        cache[0] = 1;\\n        \\n        int l = 1;\\n        while(l < N) {\\n            for(int i = 0; i < l; i++) cache[i] *= 2;\\n            for(int i = l; i < l * 2; i++) cache[i] = cache[i-l] - 1;\\n            l *= 2;\\n        }\\n        \\n        int j = 0;\\n        for(int i = 0; i < l; i++) if(cache[i] <= N) ret[j++] = cache[i];\\n        return ret;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 186724,
                "title": "python-solution",
                "content": "# solution\\n\\n```\\nclass Solution:\\n    def beautifulArray(self, N):\\n        a = list(range(1, N + 1))\\n        return self.r_fun(a)\\n        pass\\n\\n    def r_fun(self, a):\\n        if len(a) <= 1:\\n            return a\\n        odd = [v for idx, v in enumerate(a) if idx % 2 == 1]\\n        even = [v for idx, v, in enumerate(a) if idx % 2 == 0]\\n        odd = self.r_fun(odd)\\n        even = self.r_fun(even)\\n        return odd + even\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def beautifulArray(self, N):\\n        a = list(range(1, N + 1))\\n        return self.r_fun(a)\\n        pass\\n\\n    def r_fun(self, a):\\n        if len(a) <= 1:\\n            return a\\n        odd = [v for idx, v in enumerate(a) if idx % 2 == 1]\\n        even = [v for idx, v, in enumerate(a) if idx % 2 == 0]\\n        odd = self.r_fun(odd)\\n        even = self.r_fun(even)\\n        return odd + even\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521764,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> res = {1};\\n        while(res.size() != n){\\n            vector<int> temp;\\n            for(auto &ele : res) if(ele*2-1<=n) temp.push_back(ele*2-1);\\n            for(auto &ele : res) if(ele*2<=n) temp.push_back(ele*2);\\n            res = temp;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        res=[1]\\n        while len(res)<n :\\n            odd=[2*i-1 for i in res]\\n            even=[2*i for i in res]\\n            res=odd+even\\n        return [i for i in res if i<=n]\\n```\\n\\n```Java []\\nclass Solution {\\n    Map<Integer, int[]> memo;\\n    public int[] beautifulArray(int N) {\\n        memo = new HashMap();\\n        return f(N);\\n    }\\n    public int[] f(int N) {\\n        if (memo.containsKey(N))\\n            return memo.get(N);\\n\\n        int[] ans = new int[N];\\n        if (N == 1) {\\n            ans[0] = 1;\\n        } else {\\n            int t = 0;\\n            for (int x: f((N+1)/2))\\n                ans[t++] = 2*x - 1;\\n            for (int x: f(N/2))\\n                ans[t++] = 2*x;\\n        }\\n        memo.put(N, ans);\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> res = {1};\\n        while(res.size() != n){\\n            vector<int> temp;\\n            for(auto &ele : res) if(ele*2-1<=n) temp.push_back(ele*2-1);\\n            for(auto &ele : res) if(ele*2<=n) temp.push_back(ele*2);\\n            res = temp;\\n        }\\n        return res;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        res=[1]\\n        while len(res)<n :\\n            odd=[2*i-1 for i in res]\\n            even=[2*i for i in res]\\n            res=odd+even\\n        return [i for i in res if i<=n]\\n```\n```Java []\\nclass Solution {\\n    Map<Integer, int[]> memo;\\n    public int[] beautifulArray(int N) {\\n        memo = new HashMap();\\n        return f(N);\\n    }\\n    public int[] f(int N) {\\n        if (memo.containsKey(N))\\n            return memo.get(N);\\n\\n        int[] ans = new int[N];\\n        if (N == 1) {\\n            ans[0] = 1;\\n        } else {\\n            int t = 0;\\n            for (int x: f((N+1)/2))\\n                ans[t++] = 2*x - 1;\\n            for (int x: f(N/2))\\n                ans[t++] = 2*x;\\n        }\\n        memo.put(N, ans);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259787,
                "title": "c-code-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        if(n == 1) return {1};\\n        vector<int> ans = {1};\\n\\n        while(ans.size()<n){\\n            vector< int> temp;\\n\\n            for(int it: ans){\\n                if((it*2)-1 <= n) temp.push_back(it*2-1);\\n            }\\n\\n            for(int it: ans){\\n                if((it*2) <= n) temp.push_back(it*2);\\n            }\\n\\n            for(int it: ans){\\n                cout<<it<<\" \";\\n            }\\n            cout<<endl;\\n\\n            ans = temp;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        if(n == 1) return {1};\\n        vector<int> ans = {1};\\n\\n        while(ans.size()<n){\\n            vector< int> temp;\\n\\n            for(int it: ans){\\n                if((it*2)-1 <= n) temp.push_back(it*2-1);\\n            }\\n\\n            for(int it: ans){\\n                if((it*2) <= n) temp.push_back(it*2);\\n            }\\n\\n            for(int it: ans){\\n                cout<<it<<\" \";\\n            }\\n            cout<<endl;\\n\\n            ans = temp;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2587160,
                "title": "java-solution-ugly-array-oops-it-s-beautiful-need-help-with-the-time-space-complexity",
                "content": "### Please Upvote !!!\\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        List<Integer> list = new ArrayList<>();\\n        list.add(1);\\n\\n        while (list.size() < n) {\\n            List<Integer> temp = new ArrayList<>();\\n\\n            for (int i : list) {\\n                if (2*i -1 <= n) temp.add(2*i - 1);\\n            }\\n\\n            for (int i : list) {\\n                if (2*i <= n) temp.add(2 * i);\\n            }\\n\\n            list = temp;\\n        }\\n\\n        return list.stream().mapToInt(i -> i).toArray();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        List<Integer> list = new ArrayList<>();\\n        list.add(1);\\n\\n        while (list.size() < n) {\\n            List<Integer> temp = new ArrayList<>();\\n\\n            for (int i : list) {\\n                if (2*i -1 <= n) temp.add(2*i - 1);\\n            }\\n\\n            for (int i : list) {\\n                if (2*i <= n) temp.add(2 * i);\\n            }\\n\\n            list = temp;\\n        }\\n\\n        return list.stream().mapToInt(i -> i).toArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2158740,
                "title": "java-understandable-solution",
                "content": "We can see that if we seperate odd and even number then there is no possibility that even numbers will voilate rule with odd number and vice versa. Now we have to arrange even and odd numbers is such a way that they do not voilate rule with themselves. For doing so first let say we have a beautiful array of length n and we want to make n+1 size of array so what we do is first put all odd number that lie within 1 to n+1 and then even(WE can do even then odd also) . Beautiful array has property that if we multiply any number with array then it still remains beautiful or if we add or subtract any number from array then it still remains beautiful. For for only obtaining even number from n size array we do 2* num and for obtaining odd size array we do 2 * n-1 .\\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        ArrayList<Integer>ans=new ArrayList<>();\\n        ans.add(1);\\n        \\n        for(int i=2;i<=n;i++){\\n            ArrayList<Integer>temp=new ArrayList<>();\\n            for(Integer e:ans){\\n                if(2*e<=n)temp.add(e*2);\\n            }\\n            for(Integer e:ans){\\n                if(2*e-1<=n)temp.add(e*2-1);\\n            }\\n            \\n            ans=temp;\\n        }\\n        \\n        int []arr=new int[n];\\n        int k=0;\\n        for(Integer i:ans){\\n            arr[k++]=i;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        ArrayList<Integer>ans=new ArrayList<>();\\n        ans.add(1);\\n        \\n        for(int i=2;i<=n;i++){\\n            ArrayList<Integer>temp=new ArrayList<>();\\n            for(Integer e:ans){\\n                if(2*e<=n)temp.add(e*2);\\n            }\\n            for(Integer e:ans){\\n                if(2*e-1<=n)temp.add(e*2-1);\\n            }\\n            \\n            ans=temp;\\n        }\\n        \\n        int []arr=new int[n];\\n        int k=0;\\n        for(Integer i:ans){\\n            arr[k++]=i;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1891168,
                "title": "c-solution-divide-and-conquer",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        if(n == 1) return vector<int>{1};\\n\\n        int evens = n/2;\\n        int odds = n-evens;\\n        auto oddarr = beautifulArray(odds);\\n        auto evenarr = beautifulArray(evens);\\n        vector<int> ans(n);\\n        int i = 0;\\n        for(int j:oddarr) ans[i++] = 2*(j-1)+1;\\n        for(int j:evenarr) ans[i++] = 2*j;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        if(n == 1) return vector<int>{1};\\n\\n        int evens = n/2;\\n        int odds = n-evens;\\n        auto oddarr = beautifulArray(odds);\\n        auto evenarr = beautifulArray(evens);\\n        vector<int> ans(n);\\n        int i = 0;\\n        for(int j:oddarr) ans[i++] = 2*(j-1)+1;\\n        for(int j:evenarr) ans[i++] = 2*j;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1744094,
                "title": "simple-python-solution-divide-and-conquer",
                "content": "```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        \\n        def divide(N):\\n            if N == 1:\\n                return [1]\\n            \\n            odds = divide(N//2 + N%2)\\n            even = divide(N//2)\\n            \\n            return [2*x-1 for x in odds] + [2*x for x in even]\\n        \\n        return divide(n)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        \\n        def divide(N):\\n            if N == 1:\\n                return [1]\\n            \\n            odds = divide(N//2 + N%2)\\n            even = divide(N//2)\\n            \\n            return [2*x-1 for x in odds] + [2*x for x in even]\\n        \\n        return divide(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590422,
                "title": "c-o-n-2-o-n-100-99-72-beautiful-binary-tree-https-leetcode-com-nduru",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) \\n    {\\n        int a[n*2];\\n        int b[n*2];\\n        a[0] = 0;\\n        int *r =  a;\\n        int *r1 = b;\\n        for(int i = 1; i<=n; i*=2)\\n        {\\n            int *t = r;\\n            r = r1;\\n            r1 = t;\\n            for (int j=0,l=0; j<i; j++,l+=2)\\n            {\\n                r[l] = r1[j];                \\n                r[l+1] = r1[j]+i;\\n                // cout  << \", \" << r[l] << \", \" << r[l+1];\\n            }\\n            // cout << endl;\\n        }\\n        vector<int> ans(n);\\n        for(int i = 1, j = 0; j<n; i++)\\n        {\\n            if (r[i] <= n)\\n                ans[j++] = r[i];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) \\n    {\\n        int a[n*2];\\n        int b[n*2];\\n        a[0] = 0;\\n        int *r =  a;\\n        int *r1 = b;\\n        for(int i = 1; i<=n; i*=2)\\n        {\\n            int *t = r;\\n            r = r1;\\n            r1 = t;\\n            for (int j=0,l=0; j<i; j++,l+=2)\\n            {\\n                r[l] = r1[j];                \\n                r[l+1] = r1[j]+i;\\n                // cout  << \", \" << r[l] << \", \" << r[l+1];\\n            }\\n            // cout << endl;\\n        }\\n        vector<int> ans(n);\\n        for(int i = 1, j = 0; j<n; i++)\\n        {\\n            if (r[i] <= n)\\n                ans[j++] = r[i];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1369750,
                "title": "c-solution",
                "content": "**Intuition**\\n\\nIf there are two arrays ```A:[A1, A2, ..., An]``` that only has odd numbers and ```B:[B1, B2, ..., Bn]``` that only has even numbers. If we merge them as ```C:[A1, A2, ..., An,B1, B2, ..., Bn]```, then there won\\'t be any number pair ```A[i]``` and ```B[j]```, such that ```A[i] + B[j] = 2 * C[k]```, because ```A[i] + B[j]``` will always be odd, while ```2 * C[k]``` will always be even. This property ensures the first and second parts of ```C``` follow the beautiful array rule. Let\\'s call it Mege property.\\n\\nNow we need to make sure ```A``` and ```B``` themselves are beautiful arrays. We can achieve this by gradually expanding an exisiting beautiful array to get ```A``` and ```B```. If array ```N:[N1, N2, ..., Nn]``` is a beautiful array, then it has below 3 properties:\\n1. Deletion property: After deleting some numbers from ```N```, the new array ```N\\'``` will still be a beautiful array.\\n2. Addition property: ```N\\':[N1+k, N2+k, ..., Nn+k]``` will still be a beautiful array. \\n3. Multiplication property: ```N\\':[N1*k, N2*k, ..., Nn*k]``` will still be a beautiful array. \\n\\nThe three properties together with merge property can be used to expand a beautiful array. For example, ```N:[N1]``` is a beautiful array.\\n\\n* According to propety 2 and 3, ```N\\': [N1 * 2 - 1]``` and ```N\\'\\': [N1 * 2]``` are beautiful arrays.\\n* We can use property 1 to build ```N\\'``` and ```N\\'\\'``` based on the original array ```N```.\\n* Then we merge ```N\\'``` and ```N\\'\\'``` will be a new beautiful array, which double the length of the original array.\\n\\n\\n```\\npublic class Solution {\\n    public int[] BeautifulArray(int n) {\\n     \\n        List<int> res = new List<int>(){1};\\n        \\n        while(res.Count < n)\\n        {\\n            List<int> odd = new List<int>();\\n            List<int> even = new List<int>();\\n            \\n            // expand an existing beautiful array to new beautiful array and double the size \\n            foreach(var num in res)\\n            {\\n                // ensure all the numbers in the new beautiful array still within [1,n]\\n                if(2 * num - 1 <= n)\\n                    odd.Add(2 * num - 1);\\n                \\n                if(2 * num <= n)\\n                    even.Add(2 * num);\\n            }\\n            \\n            // use  merge rule to merge the odd and even arrays. This will double the size of the beautiful array.\\n            odd.AddRange(even);\\n            // update the result\\n            res = odd;\\n        }\\n        \\n        return res.ToArray(); \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```A:[A1, A2, ..., An]```\n```B:[B1, B2, ..., Bn]```\n```C:[A1, A2, ..., An,B1, B2, ..., Bn]```\n```A[i]```\n```B[j]```\n```A[i] + B[j] = 2 * C[k]```\n```A[i] + B[j]```\n```2 * C[k]```\n```C```\n```A```\n```B```\n```A```\n```B```\n```N:[N1, N2, ..., Nn]```\n```N```\n```N\\'```\n```N\\':[N1+k, N2+k, ..., Nn+k]```\n```N\\':[N1*k, N2*k, ..., Nn*k]```\n```N:[N1]```\n```N\\': [N1 * 2 - 1]```\n```N\\'\\': [N1 * 2]```\n```N\\'```\n```N\\'\\'```\n```N```\n```N\\'```\n```N\\'\\'```\n```\\npublic class Solution {\\n    public int[] BeautifulArray(int n) {\\n     \\n        List<int> res = new List<int>(){1};\\n        \\n        while(res.Count < n)\\n        {\\n            List<int> odd = new List<int>();\\n            List<int> even = new List<int>();\\n            \\n            // expand an existing beautiful array to new beautiful array and double the size \\n            foreach(var num in res)\\n            {\\n                // ensure all the numbers in the new beautiful array still within [1,n]\\n                if(2 * num - 1 <= n)\\n                    odd.Add(2 * num - 1);\\n                \\n                if(2 * num <= n)\\n                    even.Add(2 * num);\\n            }\\n            \\n            // use  merge rule to merge the odd and even arrays. This will double the size of the beautiful array.\\n            odd.AddRange(even);\\n            // update the result\\n            res = odd;\\n        }\\n        \\n        return res.ToArray(); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369611,
                "title": "javascript-simple-solution",
                "content": "Thanks to [@lee215](https://leetcode.com/problems/beautiful-array/discuss/186679/Odd-%2B-Even-Pattern-O(N))\\n```\\n\\n/**\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar beautifulArray = function(n) {\\n    let arr = []\\n    arr.push(1)\\n    while(arr.length < n){\\n        let tmp = []\\n        for(const i of arr) if(i*2-1 <= n) tmp.push(i*2-1)\\n        for(const i of arr) if(i*2 <= n) tmp.push(i*2)\\n        arr = tmp\\n    }\\n\\n    \\n    return arr\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\n/**\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar beautifulArray = function(n) {\\n    let arr = []\\n    arr.push(1)\\n    while(arr.length < n){\\n        let tmp = []\\n        for(const i of arr) if(i*2-1 <= n) tmp.push(i*2-1)\\n        for(const i of arr) if(i*2 <= n) tmp.push(i*2)\\n        arr = tmp\\n    }\\n\\n    \\n    return arr\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1369602,
                "title": "easy-java-solution-with-1-solved-example",
                "content": "```\\nclass Solution {\\n/*\\n    split the input array into two arrays of alternate numbers,\\n    recurse on those to splitted arrays and combine them\\n            [1,2,3,4,5,6,7]    \\n        [1,3,5, 7]         [2,4,6]\\n      [1, 5]  [3,7]      [2, 6] [4]\\n      [1, 5, 3, 7]       [2, 6, 4]\\n            [1,5,3,7,2,6,4] \\n*/\\n    public int[] beautifulArray(int n) {\\n        int[] arr = new int[n];\\n        for(int i=0; i < n; i++)\\n            arr[i] = i+1;\\n        return beautify(arr);\\n    }\\n    \\n    private int[] beautify(int[] arr){\\n        if(arr.length <= 2)\\n            return arr;\\n        int n = arr.length;\\n        int[] leftArray = new int[(n+1)/2];\\n        int[] rightArray = new int[n/2];\\n        \\n        populateAlternateLeftAndRight(leftArray, rightArray, arr);\\n        \\n        leftArray = beautify(leftArray);\\n        rightArray = beautify(rightArray);\\n        \\n        return concatenate(leftArray, rightArray);\\n    }\\n    \\n    void populateAlternateLeftAndRight(int[] left, int[] right, int[] arr){\\n        for(int i=0; i < arr.length; i++){\\n            if(i % 2 == 0)\\n                left[i/2] = arr[i];\\n            else\\n                right[i/2] = arr[i];\\n        }\\n    }\\n    \\n    int[] concatenate(int[] arr1, int[] arr2){\\n        int[] combinedArr = new int[arr1.length + arr2.length];\\n        copyToArr(arr1, 0, combinedArr);\\n        copyToArr(arr2, arr1.length, combinedArr);\\n        return combinedArr;\\n    }\\n    \\n    void copyToArr(int[] source, int start, int[] target){\\n        for(int i=0; i < source.length; i++)\\n            target[start++] = source[i];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n/*\\n    split the input array into two arrays of alternate numbers,\\n    recurse on those to splitted arrays and combine them\\n            [1,2,3,4,5,6,7]    \\n        [1,3,5, 7]         [2,4,6]\\n      [1, 5]  [3,7]      [2, 6] [4]\\n      [1, 5, 3, 7]       [2, 6, 4]\\n            [1,5,3,7,2,6,4] \\n*/\\n    public int[] beautifulArray(int n) {\\n        int[] arr = new int[n];\\n        for(int i=0; i < n; i++)\\n            arr[i] = i+1;\\n        return beautify(arr);\\n    }\\n    \\n    private int[] beautify(int[] arr){\\n        if(arr.length <= 2)\\n            return arr;\\n        int n = arr.length;\\n        int[] leftArray = new int[(n+1)/2];\\n        int[] rightArray = new int[n/2];\\n        \\n        populateAlternateLeftAndRight(leftArray, rightArray, arr);\\n        \\n        leftArray = beautify(leftArray);\\n        rightArray = beautify(rightArray);\\n        \\n        return concatenate(leftArray, rightArray);\\n    }\\n    \\n    void populateAlternateLeftAndRight(int[] left, int[] right, int[] arr){\\n        for(int i=0; i < arr.length; i++){\\n            if(i % 2 == 0)\\n                left[i/2] = arr[i];\\n            else\\n                right[i/2] = arr[i];\\n        }\\n    }\\n    \\n    int[] concatenate(int[] arr1, int[] arr2){\\n        int[] combinedArr = new int[arr1.length + arr2.length];\\n        copyToArr(arr1, 0, combinedArr);\\n        copyToArr(arr2, arr1.length, combinedArr);\\n        return combinedArr;\\n    }\\n    \\n    void copyToArr(int[] source, int start, int[] target){\\n        for(int i=0; i < source.length; i++)\\n            target[start++] = source[i];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369232,
                "title": "c-solution-o-n",
                "content": "Runtime: 4 ms, faster than 74.56% of C++ online submissions for Beautiful Array.\\nMemory Usage: 7.1 MB, less than 74.91% of C++ online submissions for Beautiful Array.\\n\\n\\n**Note** : Solution taken from other posts\\n\\n```\\nHere we need i<k<j such that A[k] * 2 != A[i] + A[j]\\nNow odd + even => odd which has no Integer when divided and so we can partition array in to 2 part\\nsuch that all odds are at the left half and all even are in the right half. Now odds and even list can mismatch\\nthe given condition also. Observation-\\n1. Beatiful array + c => Beautiful array\\n2. Beautiful array * c=> Beautiful array \\n3. Odd and even partition array can be Beautiful array\\n\\nUsing these properties we can build up the Beautiful array with initial array containing 1 only. \\n1. Add all values as Array A * 2 -1 in to temp which actually all odd values generated from current Beautiful array \\n2. Add all values as Array A * 2  in to temp which actually all even values generated from current Beautiful array \\n\\nHere we first add all odd and then the even values. So the result also stays Beautiful.\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        \\n        // initial beatiful array\\n        vector<int>res={1};\\n        \\n        // loop until all N values are generated\\n        while(res.size()<N)\\n        {\\n            vector<int>temp;\\n            \\n            // push all odd values generated from current beautiful array\\n            for(auto &x : res)if(x*2-1 <=N)temp.push_back(x*2-1);\\n            \\n            // push all even values generated from current beautiful array\\n            for(auto &x : res)if(x*2 <=N)temp.push_back(x*2);\\n            \\n            // swap result\\n            res=temp;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Array",
                    "Math"
                ],
                "code": "```\\nHere we need i<k<j such that A[k] * 2 != A[i] + A[j]\\nNow odd + even => odd which has no Integer when divided and so we can partition array in to 2 part\\nsuch that all odds are at the left half and all even are in the right half. Now odds and even list can mismatch\\nthe given condition also. Observation-\\n1. Beatiful array + c => Beautiful array\\n2. Beautiful array * c=> Beautiful array \\n3. Odd and even partition array can be Beautiful array\\n\\nUsing these properties we can build up the Beautiful array with initial array containing 1 only. \\n1. Add all values as Array A * 2 -1 in to temp which actually all odd values generated from current Beautiful array \\n2. Add all values as Array A * 2  in to temp which actually all even values generated from current Beautiful array \\n\\nHere we first add all odd and then the even values. So the result also stays Beautiful.\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        \\n        // initial beatiful array\\n        vector<int>res={1};\\n        \\n        // loop until all N values are generated\\n        while(res.size()<N)\\n        {\\n            vector<int>temp;\\n            \\n            // push all odd values generated from current beautiful array\\n            for(auto &x : res)if(x*2-1 <=N)temp.push_back(x*2-1);\\n            \\n            // push all even values generated from current beautiful array\\n            for(auto &x : res)if(x*2 <=N)temp.push_back(x*2);\\n            \\n            // swap result\\n            res=temp;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369183,
                "title": "c-linq-solution",
                "content": "C# LINQ solution inspired by @lee215\\'s Python list comprehension solution.\\n\\n```res``` is doubled in size after each iteration of the ```while``` loop, keeping odd numbers on the left and evens on the right, making the time complexity O(n log n). At the end, any numbers greater than n are pruned.\\n\\nLoop iterations:\\n```\\n[1]\\n[1,2]\\n[1,3,2,4]\\n[1,5,3,7,2,6,4,8]\\n[1,9,5,13,3,11,7,15,2,10,6,14,4,12,8,16]\\n...\\n```\\n\\n```\\npublic class Solution {\\n    public int [] BeautifulArray(int n) {\\n        List<int> res = new List<int>() {1};\\n        while(res.Count < n) {\\n            var odd = res.Select(a => a * 2 - 1);\\n            var even = res.Select(a => a * 2);\\n            res = odd.Concat(even).ToList();\\n        }\\n        return res.Where(a => a <= n).ToArray();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```res```\n```while```\n```\\n[1]\\n[1,2]\\n[1,3,2,4]\\n[1,5,3,7,2,6,4,8]\\n[1,9,5,13,3,11,7,15,2,10,6,14,4,12,8,16]\\n...\\n```\n```\\npublic class Solution {\\n    public int [] BeautifulArray(int n) {\\n        List<int> res = new List<int>() {1};\\n        while(res.Count < n) {\\n            var odd = res.Select(a => a * 2 - 1);\\n            var even = res.Select(a => a * 2);\\n            res = odd.Concat(even).ToList();\\n        }\\n        return res.Where(a => a <= n).ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369029,
                "title": "easy-java-solution-pattern-based",
                "content": "This is the most weird question I have seen till now.\\n\\nSomeone found this great pattern to solve this question.\\n\\nFor odd length : **2 * element - 1**\\nFor even length : **2 * element**\\n\\nSo, start with adding with to the list and use the pattern above to create new list until you reach \\'n\\'.\\n\\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        ArrayList<Integer> list = new ArrayList();\\n        list.add(1);\\n        \\n        while(list.size() < n){\\n            ArrayList<Integer> temp = new ArrayList();\\n            \\n            for(int el : list){\\n                if(2 * el - 1 <= n){\\n                    temp.add(2*el - 1);\\n                }\\n            }\\n            \\n            for(int el : list){\\n                if(2 * el <= n){\\n                    temp.add(2*el);\\n                }\\n            }\\n            list = temp;\\n        }\\n        \\n        int[] res = new int[n];\\n        for(int i = 0; i < list.size(); i++){\\n            res[i] = list.get(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        ArrayList<Integer> list = new ArrayList();\\n        list.add(1);\\n        \\n        while(list.size() < n){\\n            ArrayList<Integer> temp = new ArrayList();\\n            \\n            for(int el : list){\\n                if(2 * el - 1 <= n){\\n                    temp.add(2*el - 1);\\n                }\\n            }\\n            \\n            for(int el : list){\\n                if(2 * el <= n){\\n                    temp.add(2*el);\\n                }\\n            }\\n            list = temp;\\n        }\\n        \\n        int[] res = new int[n];\\n        for(int i = 0; i < list.size(); i++){\\n            res[i] = list.get(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368809,
                "title": "python3",
                "content": "No one can do by own its pattern based and getting logic of pattern is very rare\\n```\\ndef beautifulArray(self, n: int) -> List[int]:\\n        if n==1:return [1]\\n        prev=self.beautifulArray(n-1)\\n        arr=[]\\n        for nums in prev:\\n            if 2*nums-1<=n:\\n                arr.append(2*nums-1)\\n        for nums in prev:\\n            if 2*nums<=n:\\n                arr.append(2*nums)\\n        return arr",
                "solutionTags": [],
                "code": "No one can do by own its pattern based and getting logic of pattern is very rare\\n```\\ndef beautifulArray(self, n: int) -> List[int]:\\n        if n==1:return [1]\\n        prev=self.beautifulArray(n-1)\\n        arr=[]\\n        for nums in prev:\\n            if 2*nums-1<=n:\\n                arr.append(2*nums-1)\\n        for nums in prev:\\n            if 2*nums<=n:\\n                arr.append(2*nums)\\n        return arr",
                "codeTag": "Python3"
            },
            {
                "id": 1368760,
                "title": "simple-java-solution-with-tracing",
                "content": "\\t\\t\\t\\t\\t\\n# Code:\\nclass Solution {\\n\\n    public int[] beautifulArray(int n) {\\n        List<Integer> result = new ArrayList<Integer>();\\n        result.add(1);\\n        while(result.size() < n) {\\n            List<Integer> temp = new ArrayList<Integer>();\\n            for(int i : result) {\\n                if(i * 2 -1 <= n) temp.add(i * 2 - 1);\\n            }\\n            for(int i : result) {\\n                if(i * 2 <= n) temp.add(i * 2);\\n            }\\n            result = temp;\\n        }\\n        return result.stream().mapToInt(i->i).toArray();\\n    }\\n\\n}\\n\\n# Tracing:\\n\\n```\\nThe tracing of the algorithm seems far better than actual explanation.\\n\\nExample :  n = 13\\nresult : [1]\\n\\t\\t\\t\\t\\t\\t\\tresult                                                                temp   \\nsize = 1 < 13       -----------------after 1st for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1]                                                                    [1]\\n\\t\\t\\t\\t\\t\\t\\t----------------after 2nd for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1]                                                                    [1,2]\\n\\t\\t\\t\\t\\t\\t\\t[1,2]\\n\\t\\t\\t\\t\\t\\t\\t\\nsize = 2 < 13       -----------------after 1st for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,2]                                                                  [1,3]\\n\\t\\t\\t\\t\\t\\t\\t----------------after 2nd for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,2]                                                                  [1,3,2,4]    \\n\\t\\t\\t\\t\\t\\t\\t[1,3,2,4]\\n\\t\\t\\t\\t\\t\\t\\t\\nsize = 4 < 13       -----------------after 1st for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,3,2,4]                                                              [1,5,3,7]\\n\\t\\t\\t\\t\\t\\t\\t----------------after 2nd for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,3,2,4]                                                              [1,5,3,7,2,10,6]    \\n\\t\\t\\t\\t\\t\\t\\t[1,5,3,7,2,10,6]\\n\\t\\t\\t\\t\\t\\t\\t\\nsize = 7 < 13       -----------------after 1st for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,5,3,7,2,10,6]                                                       [1,9,513,3,11]\\n\\t\\t\\t\\t\\t\\t\\t----------------after 2nd for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,5,3,7,2,10,6]                                                       [1,9,5,13,3,11,2,10,6,4,12]    \\n\\t\\t\\t\\t\\t\\t\\t[1,9,5,13,3,11,2,10,6,4,12]\\n\\t\\t\\t\\t\\t\\t\\t\\nsize =11 < 13       -----------------after 1st for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,9,5,13,3,11,2,10,6,4,12]                                            [1,9,5,3,11,7]\\n\\t\\t\\t\\t\\t\\t\\t----------------after 2nd for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,9,5,13,3,11,2,10,6,4,12]                                            [1,9,5,3,11,7,2,10,6,4,12,8]    \\n\\t\\t\\t\\t\\t\\t\\t[1,9,5,3,11,7,2,10,6,4,12,8]\\n\\nsize = 13 < 13 ---X\\nresult = [1,9,5,3,11,7,2,10,6,4,12,8]\\t\\n```\\t\\t\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nThe tracing of the algorithm seems far better than actual explanation.\\n\\nExample :  n = 13\\nresult : [1]\\n\\t\\t\\t\\t\\t\\t\\tresult                                                                temp   \\nsize = 1 < 13       -----------------after 1st for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1]                                                                    [1]\\n\\t\\t\\t\\t\\t\\t\\t----------------after 2nd for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1]                                                                    [1,2]\\n\\t\\t\\t\\t\\t\\t\\t[1,2]\\n\\t\\t\\t\\t\\t\\t\\t\\nsize = 2 < 13       -----------------after 1st for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,2]                                                                  [1,3]\\n\\t\\t\\t\\t\\t\\t\\t----------------after 2nd for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,2]                                                                  [1,3,2,4]    \\n\\t\\t\\t\\t\\t\\t\\t[1,3,2,4]\\n\\t\\t\\t\\t\\t\\t\\t\\nsize = 4 < 13       -----------------after 1st for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,3,2,4]                                                              [1,5,3,7]\\n\\t\\t\\t\\t\\t\\t\\t----------------after 2nd for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,3,2,4]                                                              [1,5,3,7,2,10,6]    \\n\\t\\t\\t\\t\\t\\t\\t[1,5,3,7,2,10,6]\\n\\t\\t\\t\\t\\t\\t\\t\\nsize = 7 < 13       -----------------after 1st for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,5,3,7,2,10,6]                                                       [1,9,513,3,11]\\n\\t\\t\\t\\t\\t\\t\\t----------------after 2nd for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,5,3,7,2,10,6]                                                       [1,9,5,13,3,11,2,10,6,4,12]    \\n\\t\\t\\t\\t\\t\\t\\t[1,9,5,13,3,11,2,10,6,4,12]\\n\\t\\t\\t\\t\\t\\t\\t\\nsize =11 < 13       -----------------after 1st for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,9,5,13,3,11,2,10,6,4,12]                                            [1,9,5,3,11,7]\\n\\t\\t\\t\\t\\t\\t\\t----------------after 2nd for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,9,5,13,3,11,2,10,6,4,12]                                            [1,9,5,3,11,7,2,10,6,4,12,8]    \\n\\t\\t\\t\\t\\t\\t\\t[1,9,5,3,11,7,2,10,6,4,12,8]\\n\\nsize = 13 < 13 ---X\\nresult = [1,9,5,3,11,7,2,10,6,4,12,8]\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1368758,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int>ans;\\n        ans.push_back(1);\\n        while(ans.size() < n){\\n            vector<int>temp;\\n            for(auto i : ans) if(2*i - 1 <= n) temp.push_back(2*i - 1);   //odd numbers\\n            for(auto i : ans) if(2*i <= n) temp.push_back(2*i);   //even numbers\\n            ans = temp;\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int>ans;\\n        ans.push_back(1);\\n        while(ans.size() < n){\\n            vector<int>temp;\\n            for(auto i : ans) if(2*i - 1 <= n) temp.push_back(2*i - 1);   //odd numbers\\n            for(auto i : ans) if(2*i <= n) temp.push_back(2*i);   //even numbers\\n            ans = temp;\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368755,
                "title": "c-dfs-memo-divide-conquer",
                "content": "Approach 1: DFS+memo, divide conquer [1]\\n Time complexity: O(NlogN)\\n Space complexity: O(NlogN)\\nThe solution is very conter-intuitive. \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {        \\n        if(_memo.count(n)) return _memo[n];\\n        vector<int> ans(n);\\n        if(n == 1) ans[0]=1;\\n        else{\\n            int t = 0;\\n            for(int x: beautifulArray((n+1)/2)) ans[t++] = 2* x - 1; // odds\\n            for(int x: beautifulArray(n/2)) ans[t++] = 2* x;  // evens\\n        }\\n        return _memo[n]=ans;        \\n    }\\n    \\nprivate:\\n    unordered_map<int, vector<int> > _memo;\\n};\\n```\\nReference:\\n[1] https://leetcode.com/problems/beautiful-array/solution/",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {        \\n        if(_memo.count(n)) return _memo[n];\\n        vector<int> ans(n);\\n        if(n == 1) ans[0]=1;\\n        else{\\n            int t = 0;\\n            for(int x: beautifulArray((n+1)/2)) ans[t++] = 2* x - 1; // odds\\n            for(int x: beautifulArray(n/2)) ans[t++] = 2* x;  // evens\\n        }\\n        return _memo[n]=ans;        \\n    }\\n    \\nprivate:\\n    unordered_map<int, vector<int> > _memo;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368694,
                "title": "java-solution-easy",
                "content": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        //ODD - 2*EL - 1\\n        //EVEN - 2*EL\\n        ArrayList<Integer> res = new ArrayList<Integer>();\\n        res.add(1);\\n        \\n        while(res.size() < n){\\n            ArrayList<Integer> temp = new ArrayList<Integer>();\\n            //odd\\n            for(int el : res){\\n                if(2*el - 1 <= n){\\n                    temp.add(2*el - 1);\\n                }\\n            }\\n            //even\\n            for(int el : res){\\n                if(2*el <= n){\\n                    temp.add(2*el);\\n                }\\n            }\\n            res = temp;\\n        }\\n        \\n        int[] result = new int[n];\\n        for(int i = 0; i < n ; i++){\\n            result[i] = res.get(i);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        //ODD - 2*EL - 1\\n        //EVEN - 2*EL\\n        ArrayList<Integer> res = new ArrayList<Integer>();\\n        res.add(1);\\n        \\n        while(res.size() < n){\\n            ArrayList<Integer> temp = new ArrayList<Integer>();\\n            //odd\\n            for(int el : res){\\n                if(2*el - 1 <= n){\\n                    temp.add(2*el - 1);\\n                }\\n            }\\n            //even\\n            for(int el : res){\\n                if(2*el <= n){\\n                    temp.add(2*el);\\n                }\\n            }\\n            res = temp;\\n        }\\n        \\n        int[] result = new int[n];\\n        for(int i = 0; i < n ; i++){\\n            result[i] = res.get(i);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368571,
                "title": "c-932-beautiful-array",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> ans = {1}; \\n        while (ans.size() < n) {\\n            vector<int> tmp; \\n            for (auto& x : ans) if (2*x-1 <= n) tmp.push_back(2*x-1); \\n            for (auto& x : ans) if (2*x <= n) tmp.push_back(2*x); \\n            ans = tmp; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> ans = {1}; \\n        while (ans.size() < n) {\\n            vector<int> tmp; \\n            for (auto& x : ans) if (2*x-1 <= n) tmp.push_back(2*x-1); \\n            for (auto& x : ans) if (2*x <= n) tmp.push_back(2*x); \\n            ans = tmp; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368527,
                "title": "c-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> v = {1};\\n        while(v.size() < n) {\\n            vector<int> temp;\\n            for(int i=0; i<v.size(); i++) {\\n                if(2*v[i] - 1 <= n)\\n                    temp.push_back(2*v[i] - 1);\\n            }\\n            for(int i=0; i<v.size(); i++) {\\n                if(2*v[i] <= n)\\n                    temp.push_back(2*v[i]);\\n            }\\n            v = temp;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> v = {1};\\n        while(v.size() < n) {\\n            vector<int> temp;\\n            for(int i=0; i<v.size(); i++) {\\n                if(2*v[i] - 1 <= n)\\n                    temp.push_back(2*v[i] - 1);\\n            }\\n            for(int i=0; i<v.size(); i++) {\\n                if(2*v[i] <= n)\\n                    temp.push_back(2*v[i]);\\n            }\\n            v = temp;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368510,
                "title": "python-o-n-simple",
                "content": "```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        dp = [None]*(n+1)\\n        dp[1]= [1]\\n        for i in range(2,n+1):\\n            #considering odd cases and even cases\\n            dp[i]= [(2*j)-1 for j in dp[(i+1)//2]]+ [(2*j) for j in dp[i//2]]\\n        return dp[n]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        dp = [None]*(n+1)\\n        dp[1]= [1]\\n        for i in range(2,n+1):\\n            #considering odd cases and even cases\\n            dp[i]= [(2*j)-1 for j in dp[(i+1)//2]]+ [(2*j) for j in dp[i//2]]\\n        return dp[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368149,
                "title": "c-solution-using-dp-memoization",
                "content": "Algorithm:\\n1. total odd numbers:  (N+1) / 2  and N / 2 even numbers.\\n2. store these separatly into map (unordered map)\\n3. Add them. store them into dp array; (memoization)\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        unordered_map<int, vector<int>> dp;\\n        if (dp.find(n) != dp.end()){\\n            return dp[n];\\n        }\\n            \\n        vector<int> result(n);\\n        if (n == 1) {\\n            result[0] = 1;\\n        } else {\\n            int i = 0;\\n            for (int x: beautifulArray((n+1)/2)){\\n                result[i++] = 2*x - 1;\\n            } \\n                \\n            for (int x: beautifulArray(n/2)){\\n                result[i++] = 2*x;\\n            }\\n        }\\n        dp[n] = result;\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        unordered_map<int, vector<int>> dp;\\n        if (dp.find(n) != dp.end()){\\n            return dp[n];\\n        }\\n            \\n        vector<int> result(n);\\n        if (n == 1) {\\n            result[0] = 1;\\n        } else {\\n            int i = 0;\\n            for (int x: beautifulArray((n+1)/2)){\\n                result[i++] = 2*x - 1;\\n            } \\n                \\n            for (int x: beautifulArray(n/2)){\\n                result[i++] = 2*x;\\n            }\\n        }\\n        dp[n] = result;\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368040,
                "title": "swift-odd-even-pattern-o-n",
                "content": "Swift solution based on Odd + Even Pattern suggested by lee215\\n\\nhttps://leetcode.com/problems/beautiful-array/discuss/186679/Odd-%2B-Even-Pattern-O(N)\\n\\n```\\nclass Solution {\\n    func beautifulArray(_ n: Int) -> [Int] {\\n        var result: [Int] = [1]\\n        while result.count < n {\\n            var tmp: [Int] = []\\n            for i in result {\\n                if (i * 2 - 1 <= n) {\\n                    tmp.append(i * 2 - 1)\\n                }\\n            }\\n            for i in result {\\n                if (i * 2 <= n) {\\n                    tmp.append(i * 2)\\n                }\\n            }\\n            result = tmp\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func beautifulArray(_ n: Int) -> [Int] {\\n        var result: [Int] = [1]\\n        while result.count < n {\\n            var tmp: [Int] = []\\n            for i in result {\\n                if (i * 2 - 1 <= n) {\\n                    tmp.append(i * 2 - 1)\\n                }\\n            }\\n            for i in result {\\n                if (i * 2 <= n) {\\n                    tmp.append(i * 2)\\n                }\\n            }\\n            result = tmp\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1257565,
                "title": "why-my-answer-is-giving-wa",
                "content": "class Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        a=[]\\n        for _ in range(1,n+1):\\n            a.append(_)\\n        for _ in range(len(a)):\\n            if(_%2!=0):\\n                temp=a[_-1]\\n                a[_-1]=a[_]\\n                a[_]=temp\\n        return a\\n\\t\\t\\n\\t\\t\\n\\t\\t\\nmy basic approach is i m swapping the elements present on the odd indecies with their previous elems.\\nthen the array generated by my approach is also a beautiful array!",
                "solutionTags": [],
                "code": "class Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        a=[]\\n        for _ in range(1,n+1):\\n            a.append(_)\\n        for _ in range(len(a)):\\n            if(_%2!=0):\\n                temp=a[_-1]\\n                a[_-1]=a[_]\\n                a[_]=temp\\n        return a\\n\\t\\t\\n\\t\\t\\n\\t\\t\\nmy basic approach is i m swapping the elements present on the odd indecies with their previous elems.\\nthen the array generated by my approach is also a beautiful array!",
                "codeTag": "Java"
            },
            {
                "id": 1172071,
                "title": "java-beats-100-explained-happy-coding-friend",
                "content": "```\\n// example: N = 9\\n// 1. we divide it into two parts: all odds: 1, 3, 5, 7, 9; all evens: 2, 4, 6, 8\\n//    we put all odds before evens, then if A[i] is from odds and A[j] from even, we will already be valid\\n//    So, all our job is to make sure within all odds and all even themselves are valid!\\n// 2. for all odds if a sequence 5 1 3 9 7 is valid, we take each x as (x+1)/2, then we got --> 3 1 2 5 4 is also valid\\n//        which, is a subproblem beautifulArray(5)\\n// 3. for all even if a sequence 4 2 6 8 is valid, we take each x as x/2, then we got --> 2 1 3 4 is also valid\\n//        which, is a subproblem beautifulArray(4)    \\n// thus, we cal solve it recursively!    \\n\\nclass Solution {\\n    public int[] beautifulArray(int N) { // dfs is not available here for N ~ 1000\\n        int[] res = new int[N];\\n        if (N == 1) {\\n            return new int[] {1};\\n        } else if (N == 2) {\\n            return new int[] {1, 2};\\n        } else {\\n            int[] odds = beautifulArray((N + 1) / 2);\\n            int[] even = beautifulArray(N / 2);\\n            for (int i = 0; i < odds.length; i ++) {\\n                res[i] = odds[i] * 2 - 1;\\n            }\\n            for (int j = 0; j < even.length; j ++) {\\n                res[odds.length + j] = even[j] * 2;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] beautifulArray(int N) { // dfs is not available here for N ~ 1000\\n        int[] res = new int[N];\\n        if (N == 1) {\\n            return new int[] {1}",
                "codeTag": "Java"
            },
            {
                "id": 1148615,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] beautifulArray(int N) {\\n        int[] arr=new int[N];\\n        List<Integer> ls=new ArrayList<>();\\n        ls.add(1);\\n        while(ls.size()<N){\\n            List<Integer> temp=new ArrayList<>();\\n            for(int i:ls){\\n                if(i*2-1<=N)\\n                    temp.add(2*i-1);\\n            }\\n             for(int i:ls){\\n                if(i*2<=N)\\n                    temp.add(2*i);\\n            }\\n             ls=temp;\\n        }\\n       for(int i=0;i<N;i++){\\n           arr[i]=ls.get(i);\\n       }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int N) {\\n        int[] arr=new int[N];\\n        List<Integer> ls=new ArrayList<>();\\n        ls.add(1);\\n        while(ls.size()<N){\\n            List<Integer> temp=new ArrayList<>();\\n            for(int i:ls){\\n                if(i*2-1<=N)\\n                    temp.add(2*i-1);\\n            }\\n             for(int i:ls){\\n                if(i*2<=N)\\n                    temp.add(2*i);\\n            }\\n             ls=temp;\\n        }\\n       for(int i=0;i<N;i++){\\n           arr[i]=ls.get(i);\\n       }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760023,
                "title": "divide-and-conquer-in-python-47-100",
                "content": "```\\nclass Solution:\\n    def beautifulArray(self, N: int) -> List[int]:\\n        res = [0] * N\\n        if N==1:\\n            return [1]\\n        if N==2:\\n            return [1,2]\\n        if N%2 == 0:\\n            half = self.beautifulArray(int(N/2))\\n            for i in range(int(N/2)):\\n                res[i] = half[i] * 2-1\\n            for i in range(int(N/2), N):\\n                res[i] = half[i-int(N/2)] * 2\\n        \\n        else:\\n            res[int((N-1)/2)] = N\\n            whole = self.beautifulArray(N-1)\\n            for i in range(int((N-1)/2)):\\n                res[i] = whole[i+int((N-1)/2)]\\n            for i in range(int((N-1)/2),N-1):\\n                res[i+1] = whole[i-int((N-1)/2)]\\n        return res\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulArray(self, N: int) -> List[int]:\\n        res = [0] * N\\n        if N==1:\\n            return [1]\\n        if N==2:\\n            return [1,2]\\n        if N%2 == 0:\\n            half = self.beautifulArray(int(N/2))\\n            for i in range(int(N/2)):\\n                res[i] = half[i] * 2-1\\n            for i in range(int(N/2), N):\\n                res[i] = half[i-int(N/2)] * 2\\n        \\n        else:\\n            res[int((N-1)/2)] = N\\n            whole = self.beautifulArray(N-1)\\n            for i in range(int((N-1)/2)):\\n                res[i] = whole[i+int((N-1)/2)]\\n            for i in range(int((N-1)/2),N-1):\\n                res[i+1] = whole[i-int((N-1)/2)]\\n        return res\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 656220,
                "title": "python",
                "content": "def beautifulArray(n):\\n\\n    arr = list(range(1, n + 1))\\n    def helper(arr):\\n        if len(arr) < 3:\\n            return arr\\n        even = arr[::2]\\n        odd = arr[1::2]\\n\\n        return helper(even) + helper(odd)\\n    return helper(arr)#pehl call\\n    \\n    \\n\\nn = int(input())\\nk = beautifulArray(n)\\nprint(*k)\\n\\n\\n",
                "solutionTags": [],
                "code": "def beautifulArray(n):\\n\\n    arr = list(range(1, n + 1))\\n    def helper(arr):\\n        if len(arr) < 3:\\n            return arr\\n        even = arr[::2]\\n        odd = arr[1::2]\\n\\n        return helper(even) + helper(odd)\\n    return helper(arr)#pehl call\\n    \\n    \\n\\nn = int(input())\\nk = beautifulArray(n)\\nprint(*k)\\n\\n\\n",
                "codeTag": "Python3"
            },
            {
                "id": 575240,
                "title": "java-solution-divide-conquer",
                "content": "Idea:\\n 1. We are going to find a arthemetic subsequence free array (example 1 3 5  or 2 6 10) can  not exist\\n2. If we can deal a small subset, let\\'s say the answer for N=3 is [1,3,2], [1,3,2] is arthemetic free. Is that the same for [2,6,4] and [1,5,3]??\\n```\\nclass Solution {\\n    //1 2 3 4 5 as example\\n    Map<Integer,int[]>dp=new HashMap<>();\\n    public int[] beautifulArray(int N) {\\n        if(dp.containsKey(N))return dp.get(N);\\n        int res[]=new int[N];\\n        if(N==1){\\n            res[0]=1;return res;\\n        }\\n        int index=0;\\n        int left[]=beautifulArray((N+1)/2); //dealing 1 2 3=>convert to 1 3 5\\n        int right[]=beautifulArray(N/2);\\n        for(int i:left){\\n            res[index++]=i*2-1;\\n        }\\n        for(int i:right){\\n            res[index++]=i*2;\\n        }\\n        dp.put(N,res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //1 2 3 4 5 as example\\n    Map<Integer,int[]>dp=new HashMap<>();\\n    public int[] beautifulArray(int N) {\\n        if(dp.containsKey(N))return dp.get(N);\\n        int res[]=new int[N];\\n        if(N==1){\\n            res[0]=1;return res;\\n        }\\n        int index=0;\\n        int left[]=beautifulArray((N+1)/2); //dealing 1 2 3=>convert to 1 3 5\\n        int right[]=beautifulArray(N/2);\\n        for(int i:left){\\n            res[index++]=i*2-1;\\n        }\\n        for(int i:right){\\n            res[index++]=i*2;\\n        }\\n        dp.put(N,res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 214185,
                "title": "c-recursion-odd-even",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        vector<int> v(N);\\n        fill(N, 0, v);\\n        return v;\\n    }\\n    \\n    void fill(int n, int beg, vector<int>& v)\\n    {\\n        if(n==1)\\n        {\\n            v[beg] = 1;\\n            return;\\n        }\\n       \\n        int n2 = n/2;\\n        fill(n2, beg, v); \\n        for(int i=0;i<n2;i++)\\n            v[beg+i] *= 2;\\n        fill(n-n2, beg+n2, v);\\n        for(int i=0;i<n-n2;i++)\\n            v[beg+n2+i] = v[beg+n2+i]*2-1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        vector<int> v(N);\\n        fill(N, 0, v);\\n        return v;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 199427,
                "title": "c-o-n-recursive-4ms",
                "content": "```\\nclass Solution {\\npublic:\\n    void bar(vector<int>& v, int strt, int size) {\\n        if (size < 3) return;\\n        \\n        int step  = (v[strt + 1] - v[strt])*2;\\n        int lsize = (size + 1)/2;\\n        int ridx  = strt + lsize;\\n        int rsize = size/2;\\n        \\n        v[ridx] = v[strt + 1];\\n        if (ridx + 1 < strt + size) v[ridx + 1] = v[ridx] + step;\\n        v[strt + 1] = v[strt] + step;\\n        \\n        bar(v, strt, lsize);\\n        bar(v, ridx, rsize);\\n    }\\n    \\n    vector<int> beautifulArray(int N) {\\n        vector<int> v(N);\\n        v[0] = 1;\\n        v[1] = 2;\\n        bar(v, 0, N);\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void bar(vector<int>& v, int strt, int size) {\\n        if (size < 3) return;\\n        \\n        int step  = (v[strt + 1] - v[strt])*2;\\n        int lsize = (size + 1)/2;\\n        int ridx  = strt + lsize;\\n        int rsize = size/2;\\n        \\n        v[ridx] = v[strt + 1];\\n        if (ridx + 1 < strt + size) v[ridx + 1] = v[ridx] + step;\\n        v[strt + 1] = v[strt] + step;\\n        \\n        bar(v, strt, lsize);\\n        bar(v, ridx, rsize);\\n    }\\n    \\n    vector<int> beautifulArray(int N) {\\n        vector<int> v(N);\\n        v[0] = 1;\\n        v[1] = 2;\\n        bar(v, 0, N);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186786,
                "title": "c-dp-copied-from-someone-else-i-was-wondering-who-was-the-first-guy-hit-this-in-the-interview",
                "content": "credit goes to https://leetcode.com/problems/beautiful-array/discuss/186679/C++JavaPython-Odd-+-Even-Pattern-O(N)\\n\\nimpossible to figure it out in a 45mins interview. fml...\\n\\n```\\n// reference:\\n// https://leetcode.com/problems/beautiful-array/discuss/186679/C++JavaPython-Odd-+-Even-Pattern-O(N)\\n\\n#include <vector>\\n#include <unordered_map>\\n\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    unordered_map<int, vector<int>> dp;\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        vector<int> res;\\n        if (N == 1) {\\n            res.push_back(1);\\n            return res;\\n        }\\n\\n        if (dp.find(N) != dp.end()) {\\n            return dp[N];\\n        }\\n\\n        auto left = beautifulArray(N / 2);\\n        auto right = beautifulArray(N - N / 2);\\n\\n        for (auto num : left) {\\n            res.push_back(2 * num);\\n        }\\n        for (auto num : right) {\\n            res.push_back(2 * num - 1);\\n        }\\n        dp[N] = res;\\n        return res;\\n    }\\n};\\n\\n#if DEBUG\\nint main(int argc, char** argv) {\\n    return 0;\\n}\\n#endif\\n\\n```",
                "solutionTags": [],
                "code": "```\\n// reference:\\n// https://leetcode.com/problems/beautiful-array/discuss/186679/C++JavaPython-Odd-+-Even-Pattern-O(N)\\n\\n#include <vector>\\n#include <unordered_map>\\n\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    unordered_map<int, vector<int>> dp;\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        vector<int> res;\\n        if (N == 1) {\\n            res.push_back(1);\\n            return res;\\n        }\\n\\n        if (dp.find(N) != dp.end()) {\\n            return dp[N];\\n        }\\n\\n        auto left = beautifulArray(N / 2);\\n        auto right = beautifulArray(N - N / 2);\\n\\n        for (auto num : left) {\\n            res.push_back(2 * num);\\n        }\\n        for (auto num : right) {\\n            res.push_back(2 * num - 1);\\n        }\\n        dp[N] = res;\\n        return res;\\n    }\\n};\\n\\n#if DEBUG\\nint main(int argc, char** argv) {\\n    return 0;\\n}\\n#endif\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4101508,
                "title": "python-o-n-solution",
                "content": "In this problem we have n = 1000, which is too big to use dfs/backtracking, so we need to find some pattern. We need to avoid structures like i < k < j with nums[i] + nums[j] = 2 * nums[k], which means that nums[i] and nums[j] has the same parity: they are both odd or even. This lead us to the following idea: let us split all numbers into 2 groups: all odd numbers and then all even numbers.\\n\\n[ odd numbers ] [ even numbers ]\\n\\nThen if i, j, k lies in two different groups, we are OK, we will hever have forbidden pattern. Also, if we look at odd numbers, imagine n = 12, then we have [1, 3, 5, 7, 9, 11] and if we subtract 1 to each number and divide each number by 2 then we have [0, 1, 2, 3, 4, 5]. Note, that is linear transform: when we did this transformation, if we did not have forbidden pattern, we still do not have it! So, what we need to do is to run function recursively for odd and even numbers and concatenate them.\\n\\n\\n\\n# Complexity\\nFrom the first sight, time complexity is O(n log n), because we have recursion C(n) = C(n//2) + C((n+1)//2), which lead to O(n log n). However it can be shown that it is O(n). Imagine case n = 105, then we have 105 -> (52, 53) -> (26, 26, 27, 27) -> (13, 13, 13, 13, 14, 14, 14, 14) and if we use memoisation, no need to solve problem each time for 13, we can do it only once. On each level we will have at most two values in our recursion tree. Space complexity is O(n).\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def beautifulArray(self, N):\\n        @lru_cache(None)\\n        def dfs(N):\\n            if N == 1: return (1,)\\n            t1 = dfs((N+1)//2)\\n            t2 = dfs(N//2)\\n            return [i*2-1 for i in t1] + [i*2 for i in t2]\\n        \\n        return dfs(N)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulArray(self, N):\\n        @lru_cache(None)\\n        def dfs(N):\\n            if N == 1: return (1,)\\n            t1 = dfs((N+1)//2)\\n            t2 = dfs(N//2)\\n            return [i*2-1 for i in t1] + [i*2 for i in t2]\\n        \\n        return dfs(N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807187,
                "title": "a-memory-efficient-implementation-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt uses a single vector only. The erase operation can be expensive.\\nIf we use two vectors, it will be faster.\\n \\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> array{1};\\n        for (int m = 2; m <= n; m++) {     \\n          for (int i = 0; i < m-1; i++) {\\n              int k = array[i];\\n              if (2 * k -1 <= m) \\n                array.push_back(2 * k - 1);\\n          }\\n          for (int i = 0; i < m-1; i++) {\\n              int k = array.front();\\n              array.erase(array.begin());\\n              if (2 * k <= m) \\n                array.push_back(2 * k);\\n          }         \\n        }\\n\\n        return array; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> array{1};\\n        for (int m = 2; m <= n; m++) {     \\n          for (int i = 0; i < m-1; i++) {\\n              int k = array[i];\\n              if (2 * k -1 <= m) \\n                array.push_back(2 * k - 1);\\n          }\\n          for (int i = 0; i < m-1; i++) {\\n              int k = array.front();\\n              array.erase(array.begin());\\n              if (2 * k <= m) \\n                array.push_back(2 * k);\\n          }         \\n        }\\n\\n        return array; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3790784,
                "title": "explanation-with-details",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBecause of item 2, there will be no average between the two numbers.\\n\\nThe odd part + even part will satisfy this situation. Because the average of an odd and an even will not be an integer.\\n\\nAnd we want to generate an array. So we may use Partition to solve this. \\n\\nAt first we have a beautiful array [1].\\n\\nWe will use it to generate longer array.\\n\\n2 * BA will also be BA\\n\\n2 * BA - 1 will also be BA\\n\\nSo we can use this to generate longer array.\\n\\nlength: 1 \\u2192 2 \\u2192 4 \\u2192 8\\n\\nwhat about length as 5?\\n\\nDeletion will not change the property of BA.\\n\\nSo we can just discard the element out of 1\\u2192n.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> res = {1};\\n        while(res.size() < n)\\n        {\\n            vector<int> tmp;\\n            for(auto& elem : res)\\n            {\\n                if(elem*2 - 1 <= n)\\n                    tmp.push_back(elem * 2 - 1);\\n            }\\n            for(auto & elem: res)\\n            {\\n                if(elem * 2 <= n)\\n                    tmp.push_back(elem * 2);\\n            }\\n            res = tmp;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> res = {1};\\n        while(res.size() < n)\\n        {\\n            vector<int> tmp;\\n            for(auto& elem : res)\\n            {\\n                if(elem*2 - 1 <= n)\\n                    tmp.push_back(elem * 2 - 1);\\n            }\\n            for(auto & elem: res)\\n            {\\n                if(elem * 2 <= n)\\n                    tmp.push_back(elem * 2);\\n            }\\n            res = tmp;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788157,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] beautifulArray(int N) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        ans.add(1);\\n        while(ans.size()<N){\\n            ArrayList<Integer> temp = new ArrayList<>();\\n           for(int ele : ans){\\n               if(2*ele-1 <= N)\\n               temp.add(ele*2-1);\\n           } \\n           for(int ele : ans){\\n               if(2*ele <= N)\\n               temp.add(ele*2);\\n           }\\n           ans=temp;\\n        }\\n        int[] res = new int[N];\\n        for(int i=0; i<N;i++)\\n        {\\n            res[i]=ans.get(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int N) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        ans.add(1);\\n        while(ans.size()<N){\\n            ArrayList<Integer> temp = new ArrayList<>();\\n           for(int ele : ans){\\n               if(2*ele-1 <= N)\\n               temp.add(ele*2-1);\\n           } \\n           for(int ele : ans){\\n               if(2*ele <= N)\\n               temp.add(ele*2);\\n           }\\n           ans=temp;\\n        }\\n        int[] res = new int[N];\\n        for(int i=0; i<N;i++)\\n        {\\n            res[i]=ans.get(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786654,
                "title": "approach-for-this-beautiful-array-1000-mind-blowing-question",
                "content": "# Source: https://youtu.be/7-RZ0Lw6VRg\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach Divide and Conquer technique\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> ans;\\n        ans.push_back(1);\\n        while(ans.size()<n)\\n        {\\n            vector<int> temp;\\n            for(int el:ans)\\n            {\\n                if(2*el-1<=n)\\n                {\\n                    temp.push_back(2*el-1);\\n                }\\n            }\\n            for(int el:ans)\\n            {\\n                if(2*el<=n)\\n                {\\n                    temp.push_back(2*el);\\n                }\\n            }\\n            ans=temp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Divide and Conquer",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> ans;\\n        ans.push_back(1);\\n        while(ans.size()<n)\\n        {\\n            vector<int> temp;\\n            for(int el:ans)\\n            {\\n                if(2*el-1<=n)\\n                {\\n                    temp.push_back(2*el-1);\\n                }\\n            }\\n            for(int el:ans)\\n            {\\n                if(2*el<=n)\\n                {\\n                    temp.push_back(2*el);\\n                }\\n            }\\n            ans=temp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716792,
                "title": "my-solutions",
                "content": "**1. Use the iteration**\\n```\\n/**\\n * let\\'s ignore the first condition of the beautiful array, that is,\\n * `nums` is a permutation of the integers in the range [1, n].\\n *\\n * some observations\\n * if the array `nums1`, whose length is `n`, is beautiful\\n * 1. the array `nums2`, whose length is `n`,\\n *    each element of which, `nums2[i]`, is equal to (2 * `nums1[i]`),\\n *    is beautiful as well\\n * 2. the array `nums3`, whose length is `n`,\\n *    each element of which, `nums3[i]`, is equal to (2 * `nums1[i]` - 1),\\n *    is beautiful as well\\n * 3. every element of `nums2` is even, and every element of `nums3` is odd,\\n *    so a new array `nums4` by concatenating them is beautiful\\n *    \\'cause\\n *    1) `nums2` is beautiful\\n *    2) `nums3` is beautiful\\n *    3) any element `nums4[k]` of `nums4`, where 0 < k < 2 * `n` - 1,\\n *       it\\'s impossible that the condition `nums4[k] == nums4[i] + nums4[j]`\\n *       is true, where 0 <= `i` < `k` < `j` <= 2 * `n` - 1\\n *       the reason is as following,\\n *       i) if `j` <= `n` - 1,\\n *          that is the elements indexed by `i`, `k`, `j` are all from `nums2`\\n *          according to `1)`, the conclusion is true\\n *       ii) if `i` >= `n`,\\n *           that is the elements indexed by `i`, `k`, `j` are all from `nums3`\\n *           according to `2)`, the conclusion is true\\n *       iii) otherwise,\\n *            `nums4[i]` is even because it\\'s from `nums2`, and\\n *            `nums4[j]` is odd because it\\'s from `nums3`\\n *            so no matter `nums4[k]` is even or odd,\\n *            it\\'s impossible that the condition `nums4[k] == nums4[i] + nums4[j]`\\n *            is true, that is the conclusion is true\\n *\\n * the beautiful array of length `n` can be constructed using the following process,\\n * 1. length == 1, the beautiful array is `[1]`\\n * 2. length == 2, the beautiful array can be constructed by `[2]` + `[1]` = `[2, 1]`\\n * 3. length == 3, the beautiful array can be constructed as following\\n *    1) construct a 4-length beautiful array according to the 2-length beautiful array\\n *       `[4, 2]` + `[3, 1]` = `[4, 2, 3, 1]`\\n *    2) remove the element `4` from it, so the final beautiful array is `[2, 3, 1]`\\n * ...\\n * `n`. length == `n`, construct the n-length beautiful array accordingly\\n *\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n */\\nclass Solution {\\n public:\\n  vector<int> beautifulArray(const int n) {\\n    constexpr int range = 2;\\n    vector<int> nums[range];\\n    int previous = 0;\\n    int current = 1;\\n    nums[previous].emplace_back(1);\\n    while (nums[previous].size() < n) {\\n      for (int delta = 0; delta < 2; ++delta) {\\n        for (const int num : nums[previous]) {\\n          nums[current].emplace_back(2 * num - delta);\\n        }\\n      }\\n      \\n      previous ^= 1;\\n      current ^= 1;\\n      nums[current].clear();\\n    }\\n    \\n    if (nums[previous].size() == n) {\\n      return nums[previous];\\n    }\\n\\n    vector<int> ret;\\n    for (const int num : nums[previous]) {\\n      if (num >= 1 && num < n + 1) {\\n        ret.emplace_back(num);\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```\\n**2. Use the memorized Top-Down DP**\\n```\\n/**\\n * let\\'s ignore the first condition of the beautiful array, that is,\\n * `nums` is a permutation of the integers in the range [1, n].\\n *\\n * some observations\\n * if the array `nums1`, whose length is `n`, is beautiful\\n * 1. the array `nums2`, whose length is `n`,\\n *    each element of which, `nums2[i]`, is equal to (2 * `nums1[i]`),\\n *    is beautiful as well\\n * 2. the array `nums3`, whose length is `n`,\\n *    each element of which, `nums3[i]`, is equal to (2 * `nums1[i]` - 1),\\n *    is beautiful as well\\n * 3. every element of `nums2` is even, and every element of `nums3` is odd,\\n *    so a new array `nums4` by concatenating them is beautiful\\n *    \\'cause\\n *    1) `nums2` is beautiful\\n *    2) `nums3` is beautiful\\n *    3) any element `nums4[k]` of `nums4`, where 0 < k < 2 * `n` - 1,\\n *       it\\'s impossible that the condition `nums4[k] == nums4[i] + nums4[j]`\\n *       is true, where 0 <= `i` < `k` < `j` <= 2 * `n` - 1\\n *       the reason is as following,\\n *       i) if `j` <= `n` - 1,\\n *          that is the elements indexed by `i`, `k`, `j` are all from `nums2`\\n *          according to `1)`, the conclusion is true\\n *       ii) if `i` >= `n`,\\n *           that is the elements indexed by `i`, `k`, `j` are all from `nums3`\\n *           according to `2)`, the conclusion is true\\n *       iii) otherwise,\\n *            `nums4[i]` is even because it\\'s from `nums2`, and\\n *            `nums4[j]` is odd because it\\'s from `nums3`\\n *            so no matter `nums4[k]` is even or odd,\\n *            it\\'s impossible that the condition `nums4[k] == nums4[i] + nums4[j]`\\n *            is true, that is the conclusion is true\\n *\\n * the beautiful array of length `n` can be constructed using the following process,\\n * 1. length == 1, the beautiful array is `[1]`\\n * 2. length == 2, the beautiful array can be constructed by `[2]` + `[1]` = `[2, 1]`\\n * 3. length == 3, the beautiful array can be constructed as following\\n *    1) construct a 4-length beautiful array according to the 2-length beautiful array\\n *       `[4, 2]` + `[3, 1]` = `[4, 2, 3, 1]`\\n *    2) remove the element `4` from it, so the final beautiful array is `[2, 3, 1]`\\n * ...\\n * `n`. length == `n`, construct the n-length beautiful array accordingly\\n *\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n */\\nclass Solution {\\n public:\\n  vector<int> beautifulArray(const int n) {\\n    vector<vector<int>> memo(n);\\n    return dfs(n, memo);\\n  }\\n  \\n private:\\n  const vector<int>& dfs(const int n, vector<vector<int>> &memo) {\\n    vector<int> &ret = memo[n - 1];\\n    if (!ret.empty()) {\\n      return ret;\\n    }\\n    \\n    if (n == 1) {\\n      ret.emplace_back(1);\\n      return ret;\\n    }\\n    \\n    const vector<int> &odd = dfs((n + 1) / 2, memo);\\n    const vector<int> &even = dfs(n / 2, memo);\\n    for (const int num : odd) {\\n      ret.emplace_back(2 * num - 1);\\n    }\\n    for (const int num : even) {\\n      ret.emplace_back(2 * num);\\n    }\\n    return ret;\\n  }\\n};\\n```\\n**3. Use the Bottom-Up DP**\\n```\\n/**\\n * let\\'s ignore the first condition of the beautiful array, that is,\\n * `nums` is a permutation of the integers in the range [1, n].\\n *\\n * some observations\\n * if the array `nums1`, whose length is `n`, is beautiful\\n * 1. the array `nums2`, whose length is `n`,\\n *    each element of which, `nums2[i]`, is equal to (2 * `nums1[i]`),\\n *    is beautiful as well\\n * 2. the array `nums3`, whose length is `n`,\\n *    each element of which, `nums3[i]`, is equal to (2 * `nums1[i]` - 1),\\n *    is beautiful as well\\n * 3. every element of `nums2` is even, and every element of `nums3` is odd,\\n *    so a new array `nums4` by concatenating them is beautiful\\n *    \\'cause\\n *    1) `nums2` is beautiful\\n *    2) `nums3` is beautiful\\n *    3) any element `nums4[k]` of `nums4`, where 0 < k < 2 * `n` - 1,\\n *       it\\'s impossible that the condition `nums4[k] == nums4[i] + nums4[j]`\\n *       is true, where 0 <= `i` < `k` < `j` <= 2 * `n` - 1\\n *       the reason is as following,\\n *       i) if `j` <= `n` - 1,\\n *          that is the elements indexed by `i`, `k`, `j` are all from `nums2`\\n *          according to `1)`, the conclusion is true\\n *       ii) if `i` >= `n`,\\n *           that is the elements indexed by `i`, `k`, `j` are all from `nums3`\\n *           according to `2)`, the conclusion is true\\n *       iii) otherwise,\\n *            `nums4[i]` is even because it\\'s from `nums2`, and\\n *            `nums4[j]` is odd because it\\'s from `nums3`\\n *            so no matter `nums4[k]` is even or odd,\\n *            it\\'s impossible that the condition `nums4[k] == nums4[i] + nums4[j]`\\n *            is true, that is the conclusion is true\\n *\\n * the beautiful array of length `n` can be constructed using the following process,\\n * 1. length == 1, the beautiful array is `[1]`\\n * 2. length == 2, the beautiful array can be constructed by `[2]` + `[1]` = `[2, 1]`\\n * 3. length == 3, the beautiful array can be constructed as following\\n *    1) construct a 4-length beautiful array according to the 2-length beautiful array\\n *       `[4, 2]` + `[3, 1]` = `[4, 2, 3, 1]`\\n *    2) remove the element `4` from it, so the final beautiful array is `[2, 3, 1]`\\n * ...\\n * `n`. length == `n`, construct the n-length beautiful array accordingly\\n *\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n */\\nclass Solution {\\n public:\\n  vector<int> beautifulArray(const int n) {\\n    vector<int> subarray_lengths({n});\\n    for (size_t i = 0; i < subarray_lengths.size() && subarray_lengths[i] != 1; ++i) {\\n      if ((subarray_lengths[i] + 1) / 2 != subarray_lengths.back()) {\\n        subarray_lengths.emplace_back((subarray_lengths[i] + 1) / 2);\\n      }\\n      if ((subarray_lengths[i] & 1) == 1) {\\n        // subarray_lengths[i] is odd\\n        subarray_lengths.emplace_back(subarray_lengths[i] / 2);\\n      }\\n    }\\n    \\n    vector<int> dp[n];\\n    dp[0].emplace_back(1);\\n    const int n_subarray_lengths = static_cast<int>(subarray_lengths.size());\\n    for (int i = n_subarray_lengths - 2; i > -1; --i) {\\n      const int subarray_length = subarray_lengths[i];\\n      const vector<int> &odd = dp[(subarray_length + 1) / 2 - 1];\\n      const vector<int> &even = dp[subarray_length / 2 - 1];\\n      for (const int num : odd) {\\n        dp[subarray_length - 1].emplace_back(2 * num - 1);\\n      }\\n      for (const int num : even) {\\n        dp[subarray_length - 1].emplace_back(2 * num);\\n      }\\n    }\\n    return dp[n - 1];\\n  }\\n};\\n```\\n**4. Sort the vector according to the binary representation of the element**\\n```\\n/**\\n * let bit(num, i) be `(num >> i) & 0b1`\\n * construct the array `nums` as [1, 2, ..., `n`]\\n * 1. sort the `nums` by `bit(num, 0)`\\n * 2. if `bit(lhs, 0)` == `bit(rhs, 0)`, sort them by `bit(num, 1)`\\n * 3. if `bit(lhs, 0)` == `bit(rhs, 0)` and `bit(lhs, 1)` == `bit(rhs, 1)`,\\n *    sort them by `bit(num, 2)`\\n * ...\\n * until the order of `num1` and `num2` is determined.\\n *\\n * Time Complexity: O(n * log(n))\\n * Space Complexity: O(n)\\n */\\nclass Solution {\\n public:\\n  vector<int> beautifulArray(const int n) {\\n    vector<int> ret(n);\\n    iota(ret.begin(), ret.end(), 1);\\n    sort(ret.begin(), ret.end(), [](const int lhs, const int rhs) -> bool {\\n      int left = lhs;\\n      int right = rhs;\\n      for (; (left & 0b1) == (right & 0b1); left >>= 1, right >>= 1) {\\n      }\\n      return (left & 0b1) < (right & 0b1);\\n    });\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * let\\'s ignore the first condition of the beautiful array, that is,\\n * `nums` is a permutation of the integers in the range [1, n].\\n *\\n * some observations\\n * if the array `nums1`, whose length is `n`, is beautiful\\n * 1. the array `nums2`, whose length is `n`,\\n *    each element of which, `nums2[i]`, is equal to (2 * `nums1[i]`),\\n *    is beautiful as well\\n * 2. the array `nums3`, whose length is `n`,\\n *    each element of which, `nums3[i]`, is equal to (2 * `nums1[i]` - 1),\\n *    is beautiful as well\\n * 3. every element of `nums2` is even, and every element of `nums3` is odd,\\n *    so a new array `nums4` by concatenating them is beautiful\\n *    \\'cause\\n *    1) `nums2` is beautiful\\n *    2) `nums3` is beautiful\\n *    3) any element `nums4[k]` of `nums4`, where 0 < k < 2 * `n` - 1,\\n *       it\\'s impossible that the condition `nums4[k] == nums4[i] + nums4[j]`\\n *       is true, where 0 <= `i` < `k` < `j` <= 2 * `n` - 1\\n *       the reason is as following,\\n *       i) if `j` <= `n` - 1,\\n *          that is the elements indexed by `i`, `k`, `j` are all from `nums2`\\n *          according to `1)`, the conclusion is true\\n *       ii) if `i` >= `n`,\\n *           that is the elements indexed by `i`, `k`, `j` are all from `nums3`\\n *           according to `2)`, the conclusion is true\\n *       iii) otherwise,\\n *            `nums4[i]` is even because it\\'s from `nums2`, and\\n *            `nums4[j]` is odd because it\\'s from `nums3`\\n *            so no matter `nums4[k]` is even or odd,\\n *            it\\'s impossible that the condition `nums4[k] == nums4[i] + nums4[j]`\\n *            is true, that is the conclusion is true\\n *\\n * the beautiful array of length `n` can be constructed using the following process,\\n * 1. length == 1, the beautiful array is `[1]`\\n * 2. length == 2, the beautiful array can be constructed by `[2]` + `[1]` = `[2, 1]`\\n * 3. length == 3, the beautiful array can be constructed as following\\n *    1) construct a 4-length beautiful array according to the 2-length beautiful array\\n *       `[4, 2]` + `[3, 1]` = `[4, 2, 3, 1]`\\n *    2) remove the element `4` from it, so the final beautiful array is `[2, 3, 1]`\\n * ...\\n * `n`. length == `n`, construct the n-length beautiful array accordingly\\n *\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n */\\nclass Solution {\\n public:\\n  vector<int> beautifulArray(const int n) {\\n    constexpr int range = 2;\\n    vector<int> nums[range];\\n    int previous = 0;\\n    int current = 1;\\n    nums[previous].emplace_back(1);\\n    while (nums[previous].size() < n) {\\n      for (int delta = 0; delta < 2; ++delta) {\\n        for (const int num : nums[previous]) {\\n          nums[current].emplace_back(2 * num - delta);\\n        }\\n      }\\n      \\n      previous ^= 1;\\n      current ^= 1;\\n      nums[current].clear();\\n    }\\n    \\n    if (nums[previous].size() == n) {\\n      return nums[previous];\\n    }\\n\\n    vector<int> ret;\\n    for (const int num : nums[previous]) {\\n      if (num >= 1 && num < n + 1) {\\n        ret.emplace_back(num);\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```\n```\\n/**\\n * let\\'s ignore the first condition of the beautiful array, that is,\\n * `nums` is a permutation of the integers in the range [1, n].\\n *\\n * some observations\\n * if the array `nums1`, whose length is `n`, is beautiful\\n * 1. the array `nums2`, whose length is `n`,\\n *    each element of which, `nums2[i]`, is equal to (2 * `nums1[i]`),\\n *    is beautiful as well\\n * 2. the array `nums3`, whose length is `n`,\\n *    each element of which, `nums3[i]`, is equal to (2 * `nums1[i]` - 1),\\n *    is beautiful as well\\n * 3. every element of `nums2` is even, and every element of `nums3` is odd,\\n *    so a new array `nums4` by concatenating them is beautiful\\n *    \\'cause\\n *    1) `nums2` is beautiful\\n *    2) `nums3` is beautiful\\n *    3) any element `nums4[k]` of `nums4`, where 0 < k < 2 * `n` - 1,\\n *       it\\'s impossible that the condition `nums4[k] == nums4[i] + nums4[j]`\\n *       is true, where 0 <= `i` < `k` < `j` <= 2 * `n` - 1\\n *       the reason is as following,\\n *       i) if `j` <= `n` - 1,\\n *          that is the elements indexed by `i`, `k`, `j` are all from `nums2`\\n *          according to `1)`, the conclusion is true\\n *       ii) if `i` >= `n`,\\n *           that is the elements indexed by `i`, `k`, `j` are all from `nums3`\\n *           according to `2)`, the conclusion is true\\n *       iii) otherwise,\\n *            `nums4[i]` is even because it\\'s from `nums2`, and\\n *            `nums4[j]` is odd because it\\'s from `nums3`\\n *            so no matter `nums4[k]` is even or odd,\\n *            it\\'s impossible that the condition `nums4[k] == nums4[i] + nums4[j]`\\n *            is true, that is the conclusion is true\\n *\\n * the beautiful array of length `n` can be constructed using the following process,\\n * 1. length == 1, the beautiful array is `[1]`\\n * 2. length == 2, the beautiful array can be constructed by `[2]` + `[1]` = `[2, 1]`\\n * 3. length == 3, the beautiful array can be constructed as following\\n *    1) construct a 4-length beautiful array according to the 2-length beautiful array\\n *       `[4, 2]` + `[3, 1]` = `[4, 2, 3, 1]`\\n *    2) remove the element `4` from it, so the final beautiful array is `[2, 3, 1]`\\n * ...\\n * `n`. length == `n`, construct the n-length beautiful array accordingly\\n *\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n */\\nclass Solution {\\n public:\\n  vector<int> beautifulArray(const int n) {\\n    vector<vector<int>> memo(n);\\n    return dfs(n, memo);\\n  }\\n  \\n private:\\n  const vector<int>& dfs(const int n, vector<vector<int>> &memo) {\\n    vector<int> &ret = memo[n - 1];\\n    if (!ret.empty()) {\\n      return ret;\\n    }\\n    \\n    if (n == 1) {\\n      ret.emplace_back(1);\\n      return ret;\\n    }\\n    \\n    const vector<int> &odd = dfs((n + 1) / 2, memo);\\n    const vector<int> &even = dfs(n / 2, memo);\\n    for (const int num : odd) {\\n      ret.emplace_back(2 * num - 1);\\n    }\\n    for (const int num : even) {\\n      ret.emplace_back(2 * num);\\n    }\\n    return ret;\\n  }\\n};\\n```\n```\\n/**\\n * let\\'s ignore the first condition of the beautiful array, that is,\\n * `nums` is a permutation of the integers in the range [1, n].\\n *\\n * some observations\\n * if the array `nums1`, whose length is `n`, is beautiful\\n * 1. the array `nums2`, whose length is `n`,\\n *    each element of which, `nums2[i]`, is equal to (2 * `nums1[i]`),\\n *    is beautiful as well\\n * 2. the array `nums3`, whose length is `n`,\\n *    each element of which, `nums3[i]`, is equal to (2 * `nums1[i]` - 1),\\n *    is beautiful as well\\n * 3. every element of `nums2` is even, and every element of `nums3` is odd,\\n *    so a new array `nums4` by concatenating them is beautiful\\n *    \\'cause\\n *    1) `nums2` is beautiful\\n *    2) `nums3` is beautiful\\n *    3) any element `nums4[k]` of `nums4`, where 0 < k < 2 * `n` - 1,\\n *       it\\'s impossible that the condition `nums4[k] == nums4[i] + nums4[j]`\\n *       is true, where 0 <= `i` < `k` < `j` <= 2 * `n` - 1\\n *       the reason is as following,\\n *       i) if `j` <= `n` - 1,\\n *          that is the elements indexed by `i`, `k`, `j` are all from `nums2`\\n *          according to `1)`, the conclusion is true\\n *       ii) if `i` >= `n`,\\n *           that is the elements indexed by `i`, `k`, `j` are all from `nums3`\\n *           according to `2)`, the conclusion is true\\n *       iii) otherwise,\\n *            `nums4[i]` is even because it\\'s from `nums2`, and\\n *            `nums4[j]` is odd because it\\'s from `nums3`\\n *            so no matter `nums4[k]` is even or odd,\\n *            it\\'s impossible that the condition `nums4[k] == nums4[i] + nums4[j]`\\n *            is true, that is the conclusion is true\\n *\\n * the beautiful array of length `n` can be constructed using the following process,\\n * 1. length == 1, the beautiful array is `[1]`\\n * 2. length == 2, the beautiful array can be constructed by `[2]` + `[1]` = `[2, 1]`\\n * 3. length == 3, the beautiful array can be constructed as following\\n *    1) construct a 4-length beautiful array according to the 2-length beautiful array\\n *       `[4, 2]` + `[3, 1]` = `[4, 2, 3, 1]`\\n *    2) remove the element `4` from it, so the final beautiful array is `[2, 3, 1]`\\n * ...\\n * `n`. length == `n`, construct the n-length beautiful array accordingly\\n *\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n */\\nclass Solution {\\n public:\\n  vector<int> beautifulArray(const int n) {\\n    vector<int> subarray_lengths({n});\\n    for (size_t i = 0; i < subarray_lengths.size() && subarray_lengths[i] != 1; ++i) {\\n      if ((subarray_lengths[i] + 1) / 2 != subarray_lengths.back()) {\\n        subarray_lengths.emplace_back((subarray_lengths[i] + 1) / 2);\\n      }\\n      if ((subarray_lengths[i] & 1) == 1) {\\n        // subarray_lengths[i] is odd\\n        subarray_lengths.emplace_back(subarray_lengths[i] / 2);\\n      }\\n    }\\n    \\n    vector<int> dp[n];\\n    dp[0].emplace_back(1);\\n    const int n_subarray_lengths = static_cast<int>(subarray_lengths.size());\\n    for (int i = n_subarray_lengths - 2; i > -1; --i) {\\n      const int subarray_length = subarray_lengths[i];\\n      const vector<int> &odd = dp[(subarray_length + 1) / 2 - 1];\\n      const vector<int> &even = dp[subarray_length / 2 - 1];\\n      for (const int num : odd) {\\n        dp[subarray_length - 1].emplace_back(2 * num - 1);\\n      }\\n      for (const int num : even) {\\n        dp[subarray_length - 1].emplace_back(2 * num);\\n      }\\n    }\\n    return dp[n - 1];\\n  }\\n};\\n```\n```\\n/**\\n * let bit(num, i) be `(num >> i) & 0b1`\\n * construct the array `nums` as [1, 2, ..., `n`]\\n * 1. sort the `nums` by `bit(num, 0)`\\n * 2. if `bit(lhs, 0)` == `bit(rhs, 0)`, sort them by `bit(num, 1)`\\n * 3. if `bit(lhs, 0)` == `bit(rhs, 0)` and `bit(lhs, 1)` == `bit(rhs, 1)`,\\n *    sort them by `bit(num, 2)`\\n * ...\\n * until the order of `num1` and `num2` is determined.\\n *\\n * Time Complexity: O(n * log(n))\\n * Space Complexity: O(n)\\n */\\nclass Solution {\\n public:\\n  vector<int> beautifulArray(const int n) {\\n    vector<int> ret(n);\\n    iota(ret.begin(), ret.end(), 1);\\n    sort(ret.begin(), ret.end(), [](const int lhs, const int rhs) -> bool {\\n      int left = lhs;\\n      int right = rhs;\\n      for (; (left & 0b1) == (right & 0b1); left >>= 1, right >>= 1) {\\n      }\\n      return (left & 0b1) < (right & 0b1);\\n    });\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629961,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        n1=[1]\\n        while len(n1)<n:\\n            e=[2*i for i in n1]\\n            o=[2*i-1 for i in n1]\\n            n1=e+o\\n        return [i for i in n1 if i<=n]        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        n1=[1]\\n        while len(n1)<n:\\n            e=[2*i for i in n1]\\n            o=[2*i-1 for i in n1]\\n            n1=e+o\\n        return [i for i in n1 if i<=n]        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608130,
                "title": "solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> res(n,0);\\n        int i = 1;\\n        int j = n;\\n        int k =0;\\n        while(i<=j)\\n        {  res[k]=i;\\n           if((k+1)<n)\\n           res[k+1]=j;\\n           k+=2;\\n           j--;\\n           i++;\\n        }\\n         \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> res(n,0);\\n        int i = 1;\\n        int j = n;\\n        int k =0;\\n        while(i<=j)\\n        {  res[k]=i;\\n           if((k+1)<n)\\n           res[k+1]=j;\\n           k+=2;\\n           j--;\\n           i++;\\n        }\\n         \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575996,
                "title": "beats-100-yet-again",
                "content": "class Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        if(n==1)\\n            return {1};\\n        vector<int>v={1};\\n        while(v.size()<n){\\n            vector<int>ans;\\n            for(int it:v){\\n                if((it*2)-1 <= n)\\n                    ans.push_back(it*2-1);\\n            }\\n            for(int it:v){\\n                if((it*2) <= n)\\n                    ans.push_back(it*2);\\n            }\\n            v=ans;\\n        }\\n        return v;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        if(n==1)\\n            return {1}",
                "codeTag": "Java"
            },
            {
                "id": 3506180,
                "title": "c-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int[] BeautifulArray(int n) {\\n        Dictionary<int, int[]> map = new Dictionary<int, int[]>();\\n   \\n        return BeautifulArray(n, map);\\n    }\\n\\n    private int[] BeautifulArray(int n, Dictionary<int, int[]> map) {\\n      if(map.ContainsKey(n)) return map[n];\\n     \\n      int[] ans = new int[n];\\n      if(n == 1) {\\n        ans[0] = 1;\\n      } else {\\n        int i = 0;\\n        foreach(int x in BeautifulArray(n / 2, map)) {\\n          ans[i++] = x * 2;\\n        }\\n\\n        foreach(int x in BeautifulArray((n + 1)/ 2, map)) {\\n          ans[i++] = x * 2 - 1;\\n        }\\n      }\\n      map[n] = ans;\\n     \\n      return ans;\\n     }\\n\\n    public int[] BeautifulArray1(int n) {\\n        List<int> ans = new List<int>() {1};\\n        for(int i = 0; i <= n / 2; i++) {\\n          List<int> temp = new List<int>();\\n          foreach(int num in ans) {\\n            if(num * 2 <= n) temp.Add(num * 2);\\n          }\\n          foreach(int num in ans) {\\n            if(num * 2 - 1 <= n) temp.Add(num * 2 - 1);\\n          }\\n          ans = temp;\\n        }\\n   \\n        return ans.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] BeautifulArray(int n) {\\n        Dictionary<int, int[]> map = new Dictionary<int, int[]>();\\n   \\n        return BeautifulArray(n, map);\\n    }\\n\\n    private int[] BeautifulArray(int n, Dictionary<int, int[]> map) {\\n      if(map.ContainsKey(n)) return map[n];\\n     \\n      int[] ans = new int[n];\\n      if(n == 1) {\\n        ans[0] = 1;\\n      } else {\\n        int i = 0;\\n        foreach(int x in BeautifulArray(n / 2, map)) {\\n          ans[i++] = x * 2;\\n        }\\n\\n        foreach(int x in BeautifulArray((n + 1)/ 2, map)) {\\n          ans[i++] = x * 2 - 1;\\n        }\\n      }\\n      map[n] = ans;\\n     \\n      return ans;\\n     }\\n\\n    public int[] BeautifulArray1(int n) {\\n        List<int> ans = new List<int>() {1};\\n        for(int i = 0; i <= n / 2; i++) {\\n          List<int> temp = new List<int>();\\n          foreach(int num in ans) {\\n            if(num * 2 <= n) temp.Add(num * 2);\\n          }\\n          foreach(int num in ans) {\\n            if(num * 2 - 1 <= n) temp.Add(num * 2 - 1);\\n          }\\n          ans = temp;\\n        }\\n   \\n        return ans.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365948,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) \\n    {\\n      vector<int>ans;\\n      ans.push_back(1);\\n      while(ans.size()!=n) \\n      {\\n          vector<int>temp;\\n          for (auto it: ans)\\n          {\\n              if (it*2-1<=n)\\n              temp.push_back(it*2-1);\\n          }\\n          for (auto it: ans)\\n          {\\n           if(it*2<=n)\\n           temp.push_back(it*2);\\n          }\\n          ans=temp;\\n      }  \\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) \\n    {\\n      vector<int>ans;\\n      ans.push_back(1);\\n      while(ans.size()!=n) \\n      {\\n          vector<int>temp;\\n          for (auto it: ans)\\n          {\\n              if (it*2-1<=n)\\n              temp.push_back(it*2-1);\\n          }\\n          for (auto it: ans)\\n          {\\n           if(it*2<=n)\\n           temp.push_back(it*2);\\n          }\\n          ans=temp;\\n      }  \\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364210,
                "title": "jaa-easy-to-understand-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n       List<Integer>ls=new ArrayList<>();\\n       ls.add(1);\\n       for(int i=0;i<n;i++)\\n       {\\n           ArrayList<Integer>temp=new ArrayList<>();\\n           for(int val:ls)\\n           {\\n               if(2*val<=n)temp.add(2*val);\\n               \\n           }\\n           for(int val:ls)\\n           {\\n               if(2*val-1<=n) temp.add(2*val-1);\\n           }\\n           ls=temp;\\n       } \\n       int[] ans=new int[n];\\n       int k=0;\\n       for(int i:ls)\\n       {\\n           ans[k++]=i;\\n       }\\n    return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n       List<Integer>ls=new ArrayList<>();\\n       ls.add(1);\\n       for(int i=0;i<n;i++)\\n       {\\n           ArrayList<Integer>temp=new ArrayList<>();\\n           for(int val:ls)\\n           {\\n               if(2*val<=n)temp.add(2*val);\\n               \\n           }\\n           for(int val:ls)\\n           {\\n               if(2*val-1<=n) temp.add(2*val-1);\\n           }\\n           ls=temp;\\n       } \\n       int[] ans=new int[n];\\n       int k=0;\\n       for(int i:ls)\\n       {\\n           ans[k++]=i;\\n       }\\n    return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281644,
                "title": "simple-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nmain logic is : odd = 2(element) - 1 || even = 2*(element)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsimple Iterative approach..\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        ans.add(1);\\n        for(int i=2; i<=n; i++) {\\n            ArrayList<Integer> temp = new ArrayList<>();\\n            for(Integer e:ans){\\n                if(2*e <= n){\\n                    temp.add(e*2);\\n                }\\n            }\\n            for(Integer e:ans){\\n                if(2*e-1 <= n){\\n                    temp.add(e*2-1);\\n                }\\n            }\\n            ans = temp;\\n        }\\n        int[] arr = new int[ans.size()];\\n        for(int i=0; i<arr.length; i++){\\n            arr[i] = ans.get(i);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        ans.add(1);\\n        for(int i=2; i<=n; i++) {\\n            ArrayList<Integer> temp = new ArrayList<>();\\n            for(Integer e:ans){\\n                if(2*e <= n){\\n                    temp.add(e*2);\\n                }\\n            }\\n            for(Integer e:ans){\\n                if(2*e-1 <= n){\\n                    temp.add(e*2-1);\\n                }\\n            }\\n            ans = temp;\\n        }\\n        int[] arr = new int[ans.size()];\\n        for(int i=0; i<arr.length; i++){\\n            arr[i] = ans.get(i);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196915,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func beautifulArray(_ n: Int) -> [Int] {\\n\\n        let s = n / 2 + n % 2\\n        var o = [1]\\n        var d = 1\\n        var m = 0\\n        var j = 0\\n\\n        while o.count < s {\\n\\n            var i = 0\\n            d *= 2\\n            \\n            while o.count < s, i < o.count {\\n                if o[i] + d > n {\\n                    i += 1\\n                }\\n                else {\\n                    o.insert(o[i] + d, at: i + 1)\\n\\n                    if o[i] + d > m {\\n                        m = o[i] + d\\n                        j = i + 1\\n                    }\\n\\n                    i += 2\\n                }\\n            }\\n        }\\n\\n        var e = o.map { $0 + 1 }\\n        if n % 2 == 1 { e.remove(at: j) }\\n\\n        return o + e\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func beautifulArray(_ n: Int) -> [Int] {\\n\\n        let s = n / 2 + n % 2\\n        var o = [1]\\n        var d = 1\\n        var m = 0\\n        var j = 0\\n\\n        while o.count < s {\\n\\n            var i = 0\\n            d *= 2\\n            \\n            while o.count < s, i < o.count {\\n                if o[i] + d > n {\\n                    i += 1\\n                }\\n                else {\\n                    o.insert(o[i] + d, at: i + 1)\\n\\n                    if o[i] + d > m {\\n                        m = o[i] + d\\n                        j = i + 1\\n                    }\\n\\n                    i += 2\\n                }\\n            }\\n        }\\n\\n        var e = o.map { $0 + 1 }\\n        if n % 2 == 1 { e.remove(at: j) }\\n\\n        return o + e\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3184256,
                "title": "c-solution-hashmap",
                "content": "# Code\\n```\\nint * bild_array(int n, int **ans_per_n){\\n    if (ans_per_n[n] != NULL){\\n        return ans_per_n[n];\\n    }\\n\\n    int* ans =(int*)malloc(sizeof(int)*n);\\n    if (n == 1){\\n        ans[0] = 1;\\n    } else{\\n        int j = 0;\\n        int * odds = bild_array((n+1)/2,ans_per_n);\\n        for (int x = 0; x < (n+1)/2; x++){\\n            ans[x] = 2*odds[x] - 1;\\n        }\\n        \\n        int * evens = bild_array(n/2,ans_per_n);\\n        for (int y = 0; y < n/2; y++){\\n            ans[((n+1)/2)+y] = 2*evens[y];\\n        }\\n    }\\n    ans_per_n[n] = ans;\\n    return ans;\\n}\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* beautifulArray(int n, int* returnSize){\\n    int * sol =(int*) malloc(sizeof(int)*n);\\n    *returnSize = n;\\n    if (n == 1){\\n        sol[0] = 1;\\n        return sol;\\n    }\\n    if (n == 2){\\n        sol[0] = 1;\\n        sol[1] = 2;\\n        return sol;\\n    }\\n\\n    // create array in this way: -odds-evens-\\n    int ** ans_per_n = (int**)malloc(sizeof(int*)*(n+1));\\n    for (int i = 0; i < n + 1; i++){\\n        ans_per_n[i] = NULL;\\n    }\\n    \\n    sol = bild_array(n,ans_per_n); \\n    *returnSize = n;\\n\\n\\n    // free\\n    for (int i = 0; i < n; i++){\\n        if (ans_per_n[i] != NULL){\\n            free(ans_per_n[i]);\\n        }\\n    }\\n    free(ans_per_n);\\n\\n    return sol;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint * bild_array(int n, int **ans_per_n){\\n    if (ans_per_n[n] != NULL){\\n        return ans_per_n[n];\\n    }\\n\\n    int* ans =(int*)malloc(sizeof(int)*n);\\n    if (n == 1){\\n        ans[0] = 1;\\n    } else{\\n        int j = 0;\\n        int * odds = bild_array((n+1)/2,ans_per_n);\\n        for (int x = 0; x < (n+1)/2; x++){\\n            ans[x] = 2*odds[x] - 1;\\n        }\\n        \\n        int * evens = bild_array(n/2,ans_per_n);\\n        for (int y = 0; y < n/2; y++){\\n            ans[((n+1)/2)+y] = 2*evens[y];\\n        }\\n    }\\n    ans_per_n[n] = ans;\\n    return ans;\\n}\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* beautifulArray(int n, int* returnSize){\\n    int * sol =(int*) malloc(sizeof(int)*n);\\n    *returnSize = n;\\n    if (n == 1){\\n        sol[0] = 1;\\n        return sol;\\n    }\\n    if (n == 2){\\n        sol[0] = 1;\\n        sol[1] = 2;\\n        return sol;\\n    }\\n\\n    // create array in this way: -odds-evens-\\n    int ** ans_per_n = (int**)malloc(sizeof(int*)*(n+1));\\n    for (int i = 0; i < n + 1; i++){\\n        ans_per_n[i] = NULL;\\n    }\\n    \\n    sol = bild_array(n,ans_per_n); \\n    *returnSize = n;\\n\\n\\n    // free\\n    for (int i = 0; i < n; i++){\\n        if (ans_per_n[i] != NULL){\\n            free(ans_per_n[i]);\\n        }\\n    }\\n    free(ans_per_n);\\n\\n    return sol;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3156812,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    vector<int> beautifulArray(int n)\\n    {\\n        vector<int> res{1};\\n        \\n        while(res.size() < n)\\n        {\\n            vector<int> tmp;\\n            \\n            for(auto &x: res)\\n            {\\n                if(2*x - 1 <= n)\\n                {\\n                    tmp.push_back(2*x-1);\\n                }\\n            }\\n            \\n            for(auto &x: res)\\n            {\\n                if(2*x  <= n)\\n                {\\n                    tmp.push_back(2*x);\\n                }\\n            }\\n            \\n            res = tmp;\\n        }\\n        \\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> beautifulArray(int n)\\n    {\\n        vector<int> res{1}",
                "codeTag": "Java"
            },
            {
                "id": 3075044,
                "title": "c",
                "content": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* beautifulArray(int n, int* returnSize){\\n    *returnSize =  n ;\\n    int* ans = malloc(2 * n * sizeof(int) ) ;\\n    ans[0] = 1 ;\\n    if(n == 1){\\n        ans = realloc(ans, n * sizeof(int)) ;\\n        return ans ;\\n    }\\n    int idx = 1 ;\\n    while(idx < n){\\n        for(int i = idx ; i < idx*2; i++){\\n            ans[i] = ans[i-idx] * 2 ;\\n        }\\n        for(int i = 0; i < idx ; i++){\\n            ans[i] = 2 * ans[i] - 1 ;\\n        }\\n        idx *= 2 ;\\n    }\\n    int p = 0 ;\\n    for(int i = 0; i < idx ; i++){\\n        if(ans[i] <= n){\\n            ans[p] = ans[i] ;\\n            p++ ;\\n        }\\n    }\\n    ans = realloc(ans, n * sizeof(int) ) ;\\n    return ans ;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* beautifulArray(int n, int* returnSize){\\n    *returnSize =  n ;\\n    int* ans = malloc(2 * n * sizeof(int) ) ;\\n    ans[0] = 1 ;\\n    if(n == 1){\\n        ans = realloc(ans, n * sizeof(int)) ;\\n        return ans ;\\n    }\\n    int idx = 1 ;\\n    while(idx < n){\\n        for(int i = idx ; i < idx*2; i++){\\n            ans[i] = ans[i-idx] * 2 ;\\n        }\\n        for(int i = 0; i < idx ; i++){\\n            ans[i] = 2 * ans[i] - 1 ;\\n        }\\n        idx *= 2 ;\\n    }\\n    int p = 0 ;\\n    for(int i = 0; i < idx ; i++){\\n        if(ans[i] <= n){\\n            ans[p] = ans[i] ;\\n            p++ ;\\n        }\\n    }\\n    ans = realloc(ans, n * sizeof(int) ) ;\\n    return ans ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2946364,
                "title": "c-o-n-time-and-o-1-extra-space",
                "content": "O(N) time and O(1) extra space (not including output array)!\\n```\\nvector<int> beautifulArray(int n) {\\n    vector <int> ret(n, 1); \\n\\n    // fill in array up to what we can O(N)\\n    // if `n` was always a power of 2 this is all we would need to do\\n    int m;\\n    for (m = 1; 2 * m <= n; m *= 2) {\\n        for (int i = 0; i < m; i++) {\\n            ret[i] = ret[i + m] = ret[i] * 2; // make even and copy\\n            ret[i]--; // odd\\n        }\\n    }\\n    if (m != n) { // `n` is not a power of 2\\n        // one last iterations for the leftovers\\n        m = (n + 1) / 2;\\n        // construct odds on it\\'s own half\\n        for (int i = 0, j = 0; j < m; i++) \\n            if (ret[i] * 2 - 1 <= n)\\n                ret[j++] = ret[i] * 2 - 1;\\n        \\n        // construct evens from odds\\n        for (int i = m, j = 0; j < m; j++) \\n            if (ret[j] + 1 <= n)\\n                ret[i++] = ret[j] + 1;\\n    }\\n    return ret;\\n}\\n```\\n\\nTechnically, this can be combined, but then most of logic is not obvious in the code:\\n```\\nvector<int> beautifulArray(int n) {\\n    vector <int> ret(n, 1);\\n    for (int m = 1; m < n; m *= 2) {\\n        if (m > (n + 1) / 2)\\n            m = (n + 1) / 2;\\n        for (int i = 0, j = 0; j < m; i++) // odds\\n            if (ret[i] * 2 - 1 <= n)\\n                ret[j++] = ret[i] * 2 - 1;\\n        for (int i = m, j = 0; j < m; j++) // evens\\n            if (ret[j] + 1 <= n)\\n                ret[i++] = ret[j] + 1;\\n    }\\n    return ret;\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nvector<int> beautifulArray(int n) {\\n    vector <int> ret(n, 1); \\n\\n    // fill in array up to what we can O(N)\\n    // if `n` was always a power of 2 this is all we would need to do\\n    int m;\\n    for (m = 1; 2 * m <= n; m *= 2) {\\n        for (int i = 0; i < m; i++) {\\n            ret[i] = ret[i + m] = ret[i] * 2; // make even and copy\\n            ret[i]--; // odd\\n        }\\n    }\\n    if (m != n) { // `n` is not a power of 2\\n        // one last iterations for the leftovers\\n        m = (n + 1) / 2;\\n        // construct odds on it\\'s own half\\n        for (int i = 0, j = 0; j < m; i++) \\n            if (ret[i] * 2 - 1 <= n)\\n                ret[j++] = ret[i] * 2 - 1;\\n        \\n        // construct evens from odds\\n        for (int i = m, j = 0; j < m; j++) \\n            if (ret[j] + 1 <= n)\\n                ret[i++] = ret[j] + 1;\\n    }\\n    return ret;\\n}\\n```\n```\\nvector<int> beautifulArray(int n) {\\n    vector <int> ret(n, 1);\\n    for (int m = 1; m < n; m *= 2) {\\n        if (m > (n + 1) / 2)\\n            m = (n + 1) / 2;\\n        for (int i = 0, j = 0; j < m; i++) // odds\\n            if (ret[i] * 2 - 1 <= n)\\n                ret[j++] = ret[i] * 2 - 1;\\n        for (int i = m, j = 0; j < m; j++) // evens\\n            if (ret[j] + 1 <= n)\\n                ret[i++] = ret[j] + 1;\\n    }\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2927166,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        ans.add(1);\\n        while(ans.size()<n) {\\n        ArrayList<Integer> temp = new ArrayList<>();\\n        for(int x : ans){\\n          if(2*x-1<=n)\\n          temp.add(x * 2 -1);\\n         }\\n        for(int x : ans){\\n            if(2*x<=n)\\n            temp.add(x * 2);\\n         }\\n        ans = temp;\\n     }\\n        int res[] = new int[n];\\n        for(int i=0;i<n;i++)\\n           res[i]=ans.get(i);\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        ans.add(1);\\n        while(ans.size()<n) {\\n        ArrayList<Integer> temp = new ArrayList<>();\\n        for(int x : ans){\\n          if(2*x-1<=n)\\n          temp.add(x * 2 -1);\\n         }\\n        for(int x : ans){\\n            if(2*x<=n)\\n            temp.add(x * 2);\\n         }\\n        ans = temp;\\n     }\\n        int res[] = new int[n];\\n        for(int i=0;i<n;i++)\\n           res[i]=ans.get(i);\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2911566,
                "title": "easy-faster-efficient-java-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        List<Integer> al = new ArrayList<>();\\n        if(n == 1){\\n            return new int[]{1};\\n        }\\n        if(n == 2){\\n            return new int[]{1, 2};\\n        }\\n        al.add(1);\\n        al.add(2);\\n        for(int i = 3; i <= n; i++){\\n            List<Integer> odd = new ArrayList<>();\\n            List<Integer> even = new ArrayList<>();\\n            for(int val : al){\\n                int el = 2 * val - 1;\\n                if(el <= n){\\n                    odd.add(el);\\n                }\\n            }\\n            for(int val : al){\\n                int el = 2 * val;\\n                if(el <= n){\\n                    even.add(el);\\n                }\\n            }\\n            al = new ArrayList<>(odd);\\n            for(int val : even){\\n                al.add(val);\\n            }\\n        }\\n        int [] arr = new int[al.size()];\\n        int i = 0;\\n        for(int val : al){\\n            arr[i++] = val;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        List<Integer> al = new ArrayList<>();\\n        if(n == 1){\\n            return new int[]{1};\\n        }\\n        if(n == 2){\\n            return new int[]{1, 2};\\n        }\\n        al.add(1);\\n        al.add(2);\\n        for(int i = 3; i <= n; i++){\\n            List<Integer> odd = new ArrayList<>();\\n            List<Integer> even = new ArrayList<>();\\n            for(int val : al){\\n                int el = 2 * val - 1;\\n                if(el <= n){\\n                    odd.add(el);\\n                }\\n            }\\n            for(int val : al){\\n                int el = 2 * val;\\n                if(el <= n){\\n                    even.add(el);\\n                }\\n            }\\n            al = new ArrayList<>(odd);\\n            for(int val : even){\\n                al.add(val);\\n            }\\n        }\\n        int [] arr = new int[al.size()];\\n        int i = 0;\\n        for(int val : al){\\n            arr[i++] = val;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2909516,
                "title": "python-solution-iteration-divide-and-conquer-faster-than-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Divide and Conquer\\n- Iteration\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        res = [1]\\n        if n==1:\\n            return res \\n\\n        count = 1 \\n        while count<n: \\n            new_list = [2*x for x in res] + [2*x-1 for x in res]  \\n            res = new_list.copy() \\n            count *=2 \\n            new_list.clear() \\n        res_list = list()    \\n        for item in res:  \\n            if item<=n: \\n                res_list += [item]\\n        res.clear() \\n        return res_list \\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        res = [1]\\n        if n==1:\\n            return res \\n\\n        count = 1 \\n        while count<n: \\n            new_list = [2*x for x in res] + [2*x-1 for x in res]  \\n            res = new_list.copy() \\n            count *=2 \\n            new_list.clear() \\n        res_list = list()    \\n        for item in res:  \\n            if item<=n: \\n                res_list += [item]\\n        res.clear() \\n        return res_list \\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723730,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        ArrayList<Integer> ans=new ArrayList<>();\\n        ans.add(1);\\n        while(ans.size()<n){\\n          ArrayList<Integer> tmp=new ArrayList<>();\\n          for(int el:ans){\\n              if(2*el-1<=n){\\n                  tmp.add(el*2-1);\\n              }\\n          }\\n              for(int el:ans){\\n                  if(2*el<=n){\\n                      tmp.add(el*2);\\n                  }\\n              }\\n              ans=tmp;\\n        }\\n        int[] res=new int[n];\\n        for(int i=0;i<n;i++){\\n            res[i]=ans.get(i);\\n        }\\n        return res;\\n        }\\n    }\\n             \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        ArrayList<Integer> ans=new ArrayList<>();\\n        ans.add(1);\\n        while(ans.size()<n){\\n          ArrayList<Integer> tmp=new ArrayList<>();\\n          for(int el:ans){\\n              if(2*el-1<=n){\\n                  tmp.add(el*2-1);\\n              }\\n          }\\n              for(int el:ans){\\n                  if(2*el<=n){\\n                      tmp.add(el*2);\\n                  }\\n              }\\n              ans=tmp;\\n        }\\n        int[] res=new int[n];\\n        for(int i=0;i<n;i++){\\n            res[i]=ans.get(i);\\n        }\\n        return res;\\n        }\\n    }\\n             \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2721557,
                "title": "python-easy-to-understand",
                "content": "class Solution(object):\\n    \\n\\tdef beautifulArray(self, n):\\n       \\n        if n == 1:\\n            return [1]\\n        elif n == 2:\\n            return [1,2]\\n        \\n        even = self.beautifulArray(n // 2)\\n        odd = self.beautifulArray((n + 1)// 2)\\n        even = [2*n for n in even]\\n        odd = [2*n - 1 for n in odd]\\n        \\n        return even + odd\\n",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer"
                ],
                "code": "class Solution(object):\\n    \\n\\tdef beautifulArray(self, n):\\n       \\n        if n == 1:\\n            return [1]\\n        elif n == 2:\\n            return [1,2]\\n        \\n        even = self.beautifulArray(n // 2)\\n        odd = self.beautifulArray((n + 1)// 2)\\n        even = [2*n for n in even]\\n        odd = [2*n - 1 for n in odd]\\n        \\n        return even + odd\\n",
                "codeTag": "Java"
            },
            {
                "id": 2678256,
                "title": "c-solution-beautiful-array-odd-even-pattern-math",
                "content": "**Using Math - Odd Even Pattern**\\n* Time Complexity - O( N )\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> ans = {1};\\n        \\n        while(ans.size() < n){\\n            vector<int> temp;\\n            //For ODD values\\n            for(int i = 0; i < ans.size(); i++){\\n                if( 2*ans[i] - 1 <= n){\\n                    temp.push_back(2*ans[i] - 1);\\n                }\\n            }\\n            //For EVEN Values\\n            for(int i = 0; i < ans.size(); i++){\\n                if( 2*ans[i] <= n){\\n                    temp.push_back(2*ans[i]);\\n                }\\n            }\\n            \\n            ans = temp;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Please Upvote if it helps :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> ans = {1};\\n        \\n        while(ans.size() < n){\\n            vector<int> temp;\\n            //For ODD values\\n            for(int i = 0; i < ans.size(); i++){\\n                if( 2*ans[i] - 1 <= n){\\n                    temp.push_back(2*ans[i] - 1);\\n                }\\n            }\\n            //For EVEN Values\\n            for(int i = 0; i < ans.size(); i++){\\n                if( 2*ans[i] <= n){\\n                    temp.push_back(2*ans[i]);\\n                }\\n            }\\n            \\n            ans = temp;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2555059,
                "title": "o-n-time-o-n-space-clear-explanation-three-lines-of-code",
                "content": "![image](https://assets.leetcode.com/users/images/be4bdebb-f990-42fa-a5dc-95b2db2b0912_1662750147.5099263.png)\\n\\n\\n\\tclass Solution:\\n\\t\\t@functools.cache\\n\\t\\tdef beautifulArray(self, n: int) -> List[int]:\\n\\t\\t\\t\"\"\" O(N)TS \"\"\"\\n\\t\\t\\tif n <= 1:\\n\\t\\t\\t\\treturn [1]\\n\\t\\t\\treturn [2 * x - 1 for x in self.beautifulArray((n + 1) // 2)] + [2 * x for x in self.beautifulArray(n // 2)]\\n\\n\\n![image](https://assets.leetcode.com/users/images/eecd513a-c51d-4ff8-ab1a-adb99e7cbc4a_1662750200.8244958.png)\\n",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/be4bdebb-f990-42fa-a5dc-95b2db2b0912_1662750147.5099263.png)\\n\\n\\n\\tclass Solution:\\n\\t\\t@functools.cache\\n\\t\\tdef beautifulArray(self, n: int) -> List[int]:\\n\\t\\t\\t\"\"\" O(N)TS \"\"\"\\n\\t\\t\\tif n <= 1:\\n\\t\\t\\t\\treturn [1]\\n\\t\\t\\treturn [2 * x - 1 for x in self.beautifulArray((n + 1) // 2)] + [2 * x for x in self.beautifulArray(n // 2)]\\n\\n\\n![image](https://assets.leetcode.com/users/images/eecd513a-c51d-4ff8-ab1a-adb99e7cbc4a_1662750200.8244958.png)\\n",
                "codeTag": "Java"
            },
            {
                "id": 2203813,
                "title": "932-beautiful-array-c-100-faster",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> beautifulArray(int n) {\\n\\n\\t\\t\\tvector<int> v = {1};\\n\\n\\t\\t\\twhile(v.size()<n)\\n\\t\\t\\t{\\n\\t\\t\\t\\tvector<int> x;\\n\\n\\t\\t\\t\\tfor(auto c:v)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(c*2-1<=n)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tx.push_back(c*2-1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor(auto d:v)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(d*2<=n)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tx.push_back(d*2);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tv=x;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn v;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> beautifulArray(int n) {\\n\\n\\t\\t\\tvector<int> v = {1}",
                "codeTag": "Java"
            },
            {
                "id": 2119515,
                "title": "ruby-one-liner-beats-100-100",
                "content": "```\\n# @param {Integer} n\\n# @return {Integer[]}\\ndef beautiful_array(n)\\n  (@a ||= [1, [1]])[n] ||= [0, 1].flat_map { |d| beautiful_array((n + d) / 2).map { _1 * 2 - d } }\\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {Integer} n\\n# @return {Integer[]}\\ndef beautiful_array(n)\\n  (@a ||= [1, [1]])[n] ||= [0, 1].flat_map { |d| beautiful_array((n + d) / 2).map { _1 * 2 - d } }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2116653,
                "title": "ts-solution-divide-and-conquer",
                "content": "```\\nfunction beautifulArray(n: number): number[] {\\n        if(n === 1) return [1];\\n        return beautifulArray(Math.floor(n/2) + Math.floor(n%2))\\n            .map((num : number) => 2 * num -1)\\n            .concat(beautifulArray(Math.floor(n/2)).map((num : number) => 2 * num));\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Divide and Conquer"
                ],
                "code": "```\\nfunction beautifulArray(n: number): number[] {\\n        if(n === 1) return [1];\\n        return beautifulArray(Math.floor(n/2) + Math.floor(n%2))\\n            .map((num : number) => 2 * num -1)\\n            .concat(beautifulArray(Math.floor(n/2)).map((num : number) => 2 * num));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2084864,
                "title": "c-code-editorial-explanation",
                "content": "The solution provided guarantees the left hand side are odd and right hand side are even numbers. so left and right won\\'t have duplicates.\\nIt is not trivial to say put them together it covers all number between (1...N). But not difficult to prove: left hand-side max = 2*((N+1)/2) - 1 = N if N is odd or N-1 if N is even. right hand side max = 2 * (N/2) = N if N is even, N-1 if N is odd. So max is always N.\\nNow check the beautifiulness:\\n3.1 Both sides by themselves are correct because each side just multiplied by a constant and possibly reduced by 1 from an already correct sequence. That won\\'t impact the beautifulness.\\n3.2 how about a sequence with a mixture of left and right? Well any such sequence would make A[i] + A[j] an odd number, which is impossible to be equal to 2*A[k], an even number.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> f(int n, unordered_map<int, vector<int>> &memo) {\\n      if(memo.count(n) > 0) {\\n        return memo[n];\\n      }\\n      vector<int> res(n, 0);\\n      if(n == 1) {\\n        res[0] = 1;\\n      }else {\\n        int pos = 0;\\n        for(auto &i : f((n+1)/2, memo)) {\\n          res[pos++] = 2*i - 1;\\n        }\\n        for(auto &i : f((n)/2, memo)) {\\n          res[pos++] = 2*i;\\n        }\\n      }\\n      memo[n] = res;\\n      return res;\\n    }\\n    vector<int> beautifulArray(int n) {\\n      unordered_map<int, vector<int>> memo;\\n      return f(n, memo);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> f(int n, unordered_map<int, vector<int>> &memo) {\\n      if(memo.count(n) > 0) {\\n        return memo[n];\\n      }\\n      vector<int> res(n, 0);\\n      if(n == 1) {\\n        res[0] = 1;\\n      }else {\\n        int pos = 0;\\n        for(auto &i : f((n+1)/2, memo)) {\\n          res[pos++] = 2*i - 1;\\n        }\\n        for(auto &i : f((n)/2, memo)) {\\n          res[pos++] = 2*i;\\n        }\\n      }\\n      memo[n] = res;\\n      return res;\\n    }\\n    vector<int> beautifulArray(int n) {\\n      unordered_map<int, vector<int>> memo;\\n      return f(n, memo);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1901472,
                "title": "why-my-output-isn-t-beautiful",
                "content": "Did I understand the question wrong?\\n\\n![image](https://assets.leetcode.com/users/images/755a6dce-7807-48fa-afe8-a1ce1f1abed8_1648758119.037145.png)\\n",
                "solutionTags": [],
                "code": "Did I understand the question wrong?\\n\\n![image](https://assets.leetcode.com/users/images/755a6dce-7807-48fa-afe8-a1ce1f1abed8_1648758119.037145.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1846093,
                "title": "a-novel-solution-that-manually-builds-the-array-o-n-2",
                "content": "```\\ntype Node struct {\\n    val int\\n    pre *Node\\n    next *Node\\n}\\n\\nfunc insertNode(dict *map[int]*Node, hash *map[int]int, head *Node, val int, insert *Node, op int) *Node {\\n    var node *Node = &Node{val:val}\\n    if insert != nil {\\n        if op == 1 {\\n            node.next = insert.next\\n            node.pre = insert\\n            if insert.next != nil {\\n                insert.next.pre = node\\n            }\\n            insert.next = node\\n            (*hash)[val] = (*hash)[insert.val]+1\\n            for tmp := node.next; tmp != nil; tmp=tmp.next {\\n                (*hash)[tmp.val]++\\n            }\\n        } else if op == -1 {\\n            node.pre = insert.pre\\n            node.next = insert\\n            if insert.pre != nil {\\n                insert.pre.next = node\\n            }\\n            insert.pre = node\\n            (*hash)[val] = (*hash)[insert.val]\\n            for tmp := insert; tmp != nil; tmp=tmp.next {\\n                (*hash)[tmp.val]++\\n            }\\n            if insert == head {\\n                head = node\\n            }\\n        }\\n    }\\n    if len(*dict) == 0 {\\n        (*hash)[val] = 1\\n        head = node\\n    }\\n    \\n    (*dict)[val] = node\\n    return head\\n}\\n\\nfunc beautifulArray(n int) []int {\\n    ij := [][]int{}\\n    for i := 1; i <= n; i++ {\\n        ij = append(ij, []int{})\\n    }\\n    \\n    for i := 1; i <= n; i++ {\\n        for j := i-1; j >= 1; j-- {\\n            if i*2-j > n {\\n                break  \\n            } \\n            ij[j-1] = append(ij[j-1], i*2-j)\\n            ij[i*2-j-1] = append(ij[i*2-j-1], j)\\n        }\\n    }\\n    \\n    var s, t int\\n    if n % 2 == 0 {\\n        t = -1\\n    } else {\\n        t = 1\\n    }\\n    l := (n+1)/2\\n    \\n    var dict = map[int]*Node{}\\n    var hash = map[int]int{}\\n    var head *Node\\n    for l > 0 && l <= n{\\n        var insertAt, op = (*Node)(nil), 1\\n        min, max := 0, n+1\\n        \\n        for _, r := range ij[l-1] {\\n            mid := (l+r)/2\\n            _, ok1 := dict[mid]\\n            _, ok2 := dict[r]\\n            \\n            if ok1 && ok2 {\\n                if hash[r] < hash[mid] {\\n                    if hash[mid] < max {\\n                        max = hash[mid]\\n                        if hash[r] <= max && hash[r] >= min {\\n                            insertAt, op = dict[r], 1\\n                        }\\n                    }\\n                } else {\\n                    if hash[mid] > min {\\n                        min = hash[mid]\\n                        if hash[r] <= max && hash[r] >= min {\\n                            insertAt, op = dict[r], -1\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if len(hash) > 0 && insertAt == nil{\\n            insertAt = dict[head.val]\\n        }\\n        \\n        head = insertNode(&dict, &hash, head, l, insertAt, op)\\n        \\n        t = -t\\n        s += 1\\n        l += t*s\\n    }\\n    \\n    res := []int{}\\n    for head != nil {\\n        res = append(res, head.val)\\n        head = head.next\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype Node struct {\\n    val int\\n    pre *Node\\n    next *Node\\n}\\n\\nfunc insertNode(dict *map[int]*Node, hash *map[int]int, head *Node, val int, insert *Node, op int) *Node {\\n    var node *Node = &Node{val:val}\\n    if insert != nil {\\n        if op == 1 {\\n            node.next = insert.next\\n            node.pre = insert\\n            if insert.next != nil {\\n                insert.next.pre = node\\n            }\\n            insert.next = node\\n            (*hash)[val] = (*hash)[insert.val]+1\\n            for tmp := node.next; tmp != nil; tmp=tmp.next {\\n                (*hash)[tmp.val]++\\n            }\\n        } else if op == -1 {\\n            node.pre = insert.pre\\n            node.next = insert\\n            if insert.pre != nil {\\n                insert.pre.next = node\\n            }\\n            insert.pre = node\\n            (*hash)[val] = (*hash)[insert.val]\\n            for tmp := insert; tmp != nil; tmp=tmp.next {\\n                (*hash)[tmp.val]++\\n            }\\n            if insert == head {\\n                head = node\\n            }\\n        }\\n    }\\n    if len(*dict) == 0 {\\n        (*hash)[val] = 1\\n        head = node\\n    }\\n    \\n    (*dict)[val] = node\\n    return head\\n}\\n\\nfunc beautifulArray(n int) []int {\\n    ij := [][]int{}\\n    for i := 1; i <= n; i++ {\\n        ij = append(ij, []int{})\\n    }\\n    \\n    for i := 1; i <= n; i++ {\\n        for j := i-1; j >= 1; j-- {\\n            if i*2-j > n {\\n                break  \\n            } \\n            ij[j-1] = append(ij[j-1], i*2-j)\\n            ij[i*2-j-1] = append(ij[i*2-j-1], j)\\n        }\\n    }\\n    \\n    var s, t int\\n    if n % 2 == 0 {\\n        t = -1\\n    } else {\\n        t = 1\\n    }\\n    l := (n+1)/2\\n    \\n    var dict = map[int]*Node{}\\n    var hash = map[int]int{}\\n    var head *Node\\n    for l > 0 && l <= n{\\n        var insertAt, op = (*Node)(nil), 1\\n        min, max := 0, n+1\\n        \\n        for _, r := range ij[l-1] {\\n            mid := (l+r)/2\\n            _, ok1 := dict[mid]\\n            _, ok2 := dict[r]\\n            \\n            if ok1 && ok2 {\\n                if hash[r] < hash[mid] {\\n                    if hash[mid] < max {\\n                        max = hash[mid]\\n                        if hash[r] <= max && hash[r] >= min {\\n                            insertAt, op = dict[r], 1\\n                        }\\n                    }\\n                } else {\\n                    if hash[mid] > min {\\n                        min = hash[mid]\\n                        if hash[r] <= max && hash[r] >= min {\\n                            insertAt, op = dict[r], -1\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if len(hash) > 0 && insertAt == nil{\\n            insertAt = dict[head.val]\\n        }\\n        \\n        head = insertNode(&dict, &hash, head, l, insertAt, op)\\n        \\n        t = -t\\n        s += 1\\n        l += t*s\\n    }\\n    \\n    res := []int{}\\n    for head != nil {\\n        res = append(res, head.val)\\n        head = head.next\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1727328,
                "title": "java-backtracking-memo",
                "content": "~~~java\\n\\nclass Solution {\\n    Map<Integer, int[]> memo;\\n    \\n    public int[] beautifulArray(int n) {\\n        memo = new HashMap<>();\\n        \\n        return helper(n);\\n    }\\n    \\n    private int[] helper(int n) {\\n        if (n == 1) {\\n            memo.put(1, new int[]{1});\\n            return new int[]{1};\\n        }\\n        \\n        if (memo.containsKey(n)) {\\n            return memo.get(n);\\n        }\\n        \\n        int mid = (n + 1) / 2;\\n        int[] left = helper(mid);\\n        int[] right = helper(n - mid);\\n        int[] rst = new int[n];\\n        for (int i = 0; i < mid; i++) {\\n            rst[i] = left[i] * 2 - 1;\\n        }\\n        for (int i = mid; i < n; i++) {\\n            rst[i] = right[i - mid] * 2;\\n        }\\n        \\n        memo.put(n, rst);\\n        return rst;\\n    }\\n}\\n\\n\\n~~~",
                "solutionTags": [],
                "code": "class Solution {\\n    Map<Integer, int[]> memo;\\n    \\n    public int[] beautifulArray(int n) {\\n        memo = new HashMap<>();\\n        \\n        return helper(n);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1643658,
                "title": "a-simple-three-line-solution-o-n",
                "content": "```\\n    def beautifulArray(self, n):\\n        nums = list(range(1,n+1))\\n        nums.sort(key=lambda x: bin(x)[:1:-1])\\n        return nums\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def beautifulArray(self, n):\\n        nums = list(range(1,n+1))\\n        nums.sort(key=lambda x: bin(x)[:1:-1])\\n        return nums\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1539991,
                "title": "golang-simple-solution-beat-100",
                "content": "```go\\nfunc beautifulArray(N int) []int {\\n\\tbeautArray1024 := make([]int, 0, 1024)\\n\\tbeautArray1024 = append(beautArray1024, 1, 2)\\n\\tfor i := 2; i <= 1024; i*=2 {\\n\\t\\ttemp := make([]int, len(beautArray1024))\\n\\t\\tcopy(temp, beautArray1024)\\n\\t\\tfor index, value := range temp {\\n\\t\\t\\ttemp[index] = 2*value\\n\\t\\t}\\n\\t\\tbeautArray1024 = append(beautArray1024, temp...)\\n\\t\\tfor index := range temp {\\n\\t\\t\\tbeautArray1024[index] = temp[index] - 1\\n\\t\\t}\\n\\t}\\n\\tbeautArray := make([]int, 0, N)\\n\\tfor _, v := range beautArray1024 {\\n\\t\\tif v <= N {\\n\\t\\t\\tbeautArray = append(beautArray, v)\\n\\t\\t}\\n\\t}\\n\\treturn beautArray\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc beautifulArray(N int) []int {\\n\\tbeautArray1024 := make([]int, 0, 1024)\\n\\tbeautArray1024 = append(beautArray1024, 1, 2)\\n\\tfor i := 2; i <= 1024; i*=2 {\\n\\t\\ttemp := make([]int, len(beautArray1024))\\n\\t\\tcopy(temp, beautArray1024)\\n\\t\\tfor index, value := range temp {\\n\\t\\t\\ttemp[index] = 2*value\\n\\t\\t}\\n\\t\\tbeautArray1024 = append(beautArray1024, temp...)\\n\\t\\tfor index := range temp {\\n\\t\\t\\tbeautArray1024[index] = temp[index] - 1\\n\\t\\t}\\n\\t}\\n\\tbeautArray := make([]int, 0, N)\\n\\tfor _, v := range beautArray1024 {\\n\\t\\tif v <= N {\\n\\t\\t\\tbeautArray = append(beautArray, v)\\n\\t\\t}\\n\\t}\\n\\treturn beautArray\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1482077,
                "title": "odd-even-java-recursive-solution-o-n-no-extra-space",
                "content": "Let\\'s start from a simple 3 numbers case: `(1, 2, 3)` -> the only thing we need to do is move `2` out of `1` and `3` -> `(1, 3, 2)`.\\nThen what if the case is `(1, 5, 9 )` which has `increment = 4`? It\\'s same thing -> move `3` out of `1` and `5` -> `(1, 9, 5)`.\\nNow, what if the case is `(1, 3, 5, 7, 9)` ? With odd + even or divide + conque idea in mind, we can simply divide it to `(1, 5, 9)` and `(3, 7)`. Since no change needed for 2 numbers case, after following the above steps, we can conque them to `(1, 9, 5, 3, 7)`.\\n\\nNow, coming back the this problem, if input n is `10`, then our case becomes to:\\n\\n\\t                         (1, 2, 3, 4, 5, 6, 7, 8, 9, 10), inc = 1\\n\\t\\t\\t\\t\\t\\t\\t                  |\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  | => [1, 9, 5, 3, 7, 2, 10, 6, 4, 8]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  |\\n\\t\\t  (1, 3, 5, 7, 9),  inc = 2               +              (2, 4, 6, 8, 10),  inc = 2\\n\\t\\t            |                                                      |\\n\\t                | => [1, 9, 5, 3, 7]                                   | => [2, 10, 6, 4, 8]\\n\\t\\t\\t\\t\\t|                                                      |\\n\\t    (1, 5, 9)   +   (3, 7), inc = 4                        (2, 6, 10)   +   (4, 8), inc = 4\\n\\t\\t    |                                                       |\\n\\t        | => [1, 9, 5]                                          | => [2, 10, 6]\\n\\t\\t\\t|                                                       |\\n\\t(1, 9) + (5), inc = 8                                (2, 10) + (6), inc = 8\\n \\n\\n\\n\\n```\\nclass Solution {\\n    int k, n;\\n    int[] res;\\n    public int[] beautifulArray(int n) {\\n        res = new int[n];\\n        k = 0;\\n        this.n = n;\\n        divideConque(1, 1);\\n        return res;\\n    }\\n    private void divideConque(int start, int increment) {\\n        if (start + increment > n) {\\n            res[k++] = start;\\n            return;\\n        }\\n        divideConque(start, 2 * increment);\\n        divideConque(start + increment, 2 * increment);\\n    } \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int k, n;\\n    int[] res;\\n    public int[] beautifulArray(int n) {\\n        res = new int[n];\\n        k = 0;\\n        this.n = n;\\n        divideConque(1, 1);\\n        return res;\\n    }\\n    private void divideConque(int start, int increment) {\\n        if (start + increment > n) {\\n            res[k++] = start;\\n            return;\\n        }\\n        divideConque(start, 2 * increment);\\n        divideConque(start + increment, 2 * increment);\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1437516,
                "title": "c-easy-solution",
                "content": "class Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int>ans;\\n        ans.push_back(1);\\n        while(ans.size()<n)\\n        {\\n            vector<int>t;\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(2*ans[i]-1<=n)\\n                {\\n                    t.push_back(2*ans[i]-1);\\n                }\\n            }\\n                        for(int i=0;i<ans.size();i++)\\n            {\\n                if(2*ans[i]<=n)\\n                {\\n                    t.push_back(2*ans[i]);\\n                }\\n            }\\n            ans=t;\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int>ans;\\n        ans.push_back(1);\\n        while(ans.size()<n)\\n        {\\n            vector<int>t;\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(2*ans[i]-1<=n)\\n                {\\n                    t.push_back(2*ans[i]-1);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1430076,
                "title": "java-nlog-n-0ms-different-recursive-solution-thinking",
                "content": "**Idea / Intuition**\\n* The strategy that I found was that any 3 of the elements which are same distance apart in the same sequence would cause the array to not be beautiful.\\n* That is 1,2,3 are not beautiful and also 1,3,5 . But I realized that if I split the array as odds and evens then between the two subarrays if we pick one from each the beautiful condition was satisfied (ofcourse because even + odd divided by 2 will not be an integer :) ). \\n* Still within each half it was not beautiful. Then I thought for each half as well, if we did the same but not thinking of odds and evens as numbers but indices then it would make the new smaller quarters beautiful. Because the equidistant 3 numbers need to be shuffled, so **we pick alternatively and group them together.**\\n\\n**Example:**\\n\\t[1,2,3,4,5,6]    -> [1,3,5] & [2,4,6] **(beautiful condition satisfied for any i from first half and j from second half)**\\n[1,3,5] & [2,4,6]  -> [1,5] & [3] & [2,6] & [4] ** (now (1+3)/2 was not 5 and same for (2+4)/2)**\\n\\nSo I inferred that if we did it till we reach individual elements we would have a beautiful array. So here is my solution below:\\n**Code:**\\n\\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        int[] res= new int[n];\\n        for(int i=0;i<n;i++)\\n            res[i]=i+1;\\n        recur(0,n-1,res);\\n        return res;\\n    }\\n    \\n    void recur(int i, int j, int[] res){\\n        if(j-i<2) return;\\n        int even=(j-i+1)/2;\\n        int odd=even;\\n        if ((j-i+1)%2==1) odd++;\\n        int[] odarr= new int[odd];\\n        int[] evarr= new int[even];\\n        int ic=i,jc=j,vi=0;\\n        while(ic<=jc){\\n            odarr[vi]=res[ic];\\n            if(ic+1<=jc) evarr[vi]=res[ic+1];\\n            ic+=2;vi++;\\n        }\\n        for(int x=0;x<odd;x++)\\n            res[i+x]=odarr[x];\\n        for(int x=0;x<even;x++)\\n            res[i+odd+x]=evarr[x];\\n        recur(i, i+odd-1, res);\\n        recur(i+odd, j, res);\\n        return;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        int[] res= new int[n];\\n        for(int i=0;i<n;i++)\\n            res[i]=i+1;\\n        recur(0,n-1,res);\\n        return res;\\n    }\\n    \\n    void recur(int i, int j, int[] res){\\n        if(j-i<2) return;\\n        int even=(j-i+1)/2;\\n        int odd=even;\\n        if ((j-i+1)%2==1) odd++;\\n        int[] odarr= new int[odd];\\n        int[] evarr= new int[even];\\n        int ic=i,jc=j,vi=0;\\n        while(ic<=jc){\\n            odarr[vi]=res[ic];\\n            if(ic+1<=jc) evarr[vi]=res[ic+1];\\n            ic+=2;vi++;\\n        }\\n        for(int x=0;x<odd;x++)\\n            res[i+x]=odarr[x];\\n        for(int x=0;x<even;x++)\\n            res[i+odd+x]=evarr[x];\\n        recur(i, i+odd-1, res);\\n        recur(i+odd, j, res);\\n        return;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389201,
                "title": "ruby-sorting-by-lower-bits-of-binary-representation",
                "content": "Sorting numbers by lower bits makes the array beautiful.\\n\\nLet\\'s  take number 8. In binary representation it is `100`. Multiplying by 2 results in `1000`. To make sum of two numbers resulting in `1000` both must have lower bits set, e.g. `111` and `001`, `110` and `010`, `110` and `011`. I.e. all of these numbers go on one side of `100` when sorting by lower bits.\\n\\n```\\ndef beautiful_array(n)\\n \\xA0  (1..n).sort_by{ |x| x.to_s(2).reverse }\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef beautiful_array(n)\\n \\xA0  (1..n).sort_by{ |x| x.to_s(2).reverse }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1387475,
                "title": "ruby-o-n-simple-iterative-solution",
                "content": "```\\ndef beautiful_array(n)\\n    r = [1]\\n\\n    while r.size < n\\n        r = r.map{ |n| n * 2 - 1 } + r.map{ |n| n * 2 }\\n    end\\n\\n    r.reject{ |x| x > n }\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef beautiful_array(n)\\n    r = [1]\\n\\n    while r.size < n\\n        r = r.map{ |n| n * 2 - 1 } + r.map{ |n| n * 2 }\\n    end\\n\\n    r.reject{ |x| x > n }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1375014,
                "title": "c-divide-and-conquer-sln-beats-100",
                "content": "```\\nvector<int> beautifulArray(int n) {\\n        vector<vector<int>> dp(n + 1, vector<int>());\\n        function<vector<int>(int)> get_or_compute;\\n        get_or_compute = [&get_or_compute, &dp](int k) {\\n            if (!dp[k].empty()) {\\n                return dp[k];\\n            }\\n            if (k == 1) {\\n                return dp[1] = {1};\\n            }\\n            int i = 0;\\n            vector<int> res(k);\\n            for (int x : get_or_compute((k + 1) / 2)) {\\n                res[i++] = x * 2 - 1;\\n            }\\n            for (int x : get_or_compute(k / 2)) {\\n                res[i++] = x * 2;\\n            }\\n            return dp[k] = move(res);\\n        };\\n        return get_or_compute(n);\\n    }",
                "solutionTags": [],
                "code": "```\\nvector<int> beautifulArray(int n) {\\n        vector<vector<int>> dp(n + 1, vector<int>());\\n        function<vector<int>(int)> get_or_compute;\\n        get_or_compute = [&get_or_compute, &dp](int k) {\\n            if (!dp[k].empty()) {\\n                return dp[k];\\n            }\\n            if (k == 1) {\\n                return dp[1] = {1};\\n            }\\n            int i = 0;\\n            vector<int> res(k);\\n            for (int x : get_or_compute((k + 1) / 2)) {\\n                res[i++] = x * 2 - 1;\\n            }\\n            for (int x : get_or_compute(k / 2)) {\\n                res[i++] = x * 2;\\n            }\\n            return dp[k] = move(res);\\n        };\\n        return get_or_compute(n);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1373568,
                "title": "is-this-solution-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    void merge_vector(vector<int> &vec)\\n    {\\n        if (vec.size() < 2)\\n            return;\\n        int l = vec.size();\\n        int c = 0;\\n        vector<int> left((l + 1) / 2);\\n        vector<int> right(l / 2);\\n        for (int i = 0; i < l; i += 2)\\n            left[c++] = vec[i];\\n        c = 0;\\n        for (int i = 1; i < l; i += 2)\\n            right[c++] = vec[i];\\n        c = 0;\\n        merge_vector(left);\\n        merge_vector(right);\\n        for (auto &&v : left)\\n            vec[c++] = v;\\n        for (auto &&v : right)\\n            vec[c++] = v;\\n        return;\\n    }\\n    vector<int> beautifulArray(int n) {\\n        vector<int> res(n);\\n        for (int i = 0; i < n; i++)\\n            res[i] = i + 1;\\n        merge_vector(res);\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void merge_vector(vector<int> &vec)\\n    {\\n        if (vec.size() < 2)\\n            return;\\n        int l = vec.size();\\n        int c = 0;\\n        vector<int> left((l + 1) / 2);\\n        vector<int> right(l / 2);\\n        for (int i = 0; i < l; i += 2)\\n            left[c++] = vec[i];\\n        c = 0;\\n        for (int i = 1; i < l; i += 2)\\n            right[c++] = vec[i];\\n        c = 0;\\n        merge_vector(left);\\n        merge_vector(right);\\n        for (auto &&v : left)\\n            vec[c++] = v;\\n        for (auto &&v : right)\\n            vec[c++] = v;\\n        return;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1372686,
                "title": "c-recursive-solution",
                "content": "Split numbers into odd and even parts; in each part, recurisively split. \\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        if (n == 1) return {1};\\n        if (n == 2) return {1,2};\\n        if (n == 3) return {1,3,2};\\n        if (n == 4) return {1,3,2,4};\\n        vector<int> ans(n);\\n        int index = 0;\\n        int k = (n+1)/2;\\n        vector<int> base = beautifulArray(k);\\n        for (int i = 0; i < k; ++i) {\\n            ans[index++] = 2*base[i]-1;   \\n        }\\n        for (int i = 0; i < k; ++i) {\\n            if (2*base[i]>n) continue;\\n            ans[index++] = 2*base[i];   \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        if (n == 1) return {1};\\n        if (n == 2) return {1,2};\\n        if (n == 3) return {1,3,2};\\n        if (n == 4) return {1,3,2,4};\\n        vector<int> ans(n);\\n        int index = 0;\\n        int k = (n+1)/2;\\n        vector<int> base = beautifulArray(k);\\n        for (int i = 0; i < k; ++i) {\\n            ans[index++] = 2*base[i]-1;   \\n        }\\n        for (int i = 0; i < k; ++i) {\\n            if (2*base[i]>n) continue;\\n            ans[index++] = 2*base[i];   \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1371274,
                "title": "c-easy-dfs-solution-with-explicit-explanation",
                "content": "Firstly, we devide array into two partition, one of it consist of odd numbers and other consist of even, then, in the conjunction of two arrays, two of the numbers are in the proper place (for the reason odd + even would not be even) .  \\n\\nand then, odd number could be written as 1+2K_i, as well as even number could be written as 2K_i, we could devided K_i into two partition, odd and even, and, for the same reason, in the conjunction, those number are in the correct place.  If we iterate this process, we could get our beautiful array\\n\\nif we play attention to the detail, we would find out that, after we devided array 1,2,3, ... , n into two part, such as 1,3,5,...,2K+1,2,4,6,...,2K, each number are still with the same key value Ki (or index) , it mean 1,3,5,...,2K+1 also could be written as  1 + 0,1 + 2 * 1,1 + 2 * 2,..., 1 + 2 * k, and the function we use to devide array into two part are still useful to devide the changing array, hence dfs is useful in that situation. \\n```\\nclass Solution {\\npublic:\\n    vector<int> re;\\n    void rearrange(int left,int right){\\n        vector<int> tmp(re.size(),0);\\n        for(int i=left;i<=(right+left)/2;++i){\\n            tmp[i]=re[2*(i-left)+left];\\n        }\\n        for(int i=1+(right+left)/2;i<=right;++i){\\n            tmp[i]=re[2*(i-1-(right+left)/2)+1+left];\\n        }\\n        for(int i=left;i<=right;++i){\\n            re[i]=tmp[i];\\n        }\\n        return ;\\n    }\\n    void dfs(int left,int right){\\n        if(left==right) return ;\\n        rearrange(left,right);\\n        int mid=(left+right)>>1;\\n        dfs(left,mid);\\n        dfs(mid+1,right);\\n        return ;\\n    }\\n    vector<int> beautifulArray(int n) {\\n        for(int i=1;i<=n;++i) re.push_back(i);\\n        dfs(0,re.size()-1);\\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> re;\\n    void rearrange(int left,int right){\\n        vector<int> tmp(re.size(),0);\\n        for(int i=left;i<=(right+left)/2;++i){\\n            tmp[i]=re[2*(i-left)+left];\\n        }\\n        for(int i=1+(right+left)/2;i<=right;++i){\\n            tmp[i]=re[2*(i-1-(right+left)/2)+1+left];\\n        }\\n        for(int i=left;i<=right;++i){\\n            re[i]=tmp[i];\\n        }\\n        return ;\\n    }\\n    void dfs(int left,int right){\\n        if(left==right) return ;\\n        rearrange(left,right);\\n        int mid=(left+right)>>1;\\n        dfs(left,mid);\\n        dfs(mid+1,right);\\n        return ;\\n    }\\n    vector<int> beautifulArray(int n) {\\n        for(int i=1;i<=n;++i) re.push_back(i);\\n        dfs(0,re.size()-1);\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1370218,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        \\n        vector<int>memo = {1};\\n        \\n        while(memo.size() < n)\\n        {\\n             vector<int>curr;\\n            \\n            for(auto x : memo)\\n            {\\n                 if(2*x-1 <= n)\\n                     curr.push_back(2*x-1);\\n            }\\n            for(auto x : memo)\\n            {\\n                 if(2*x <= n)\\n                     curr.push_back(2*x);\\n            }\\n            memo = curr;\\n        }\\n        return memo;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        \\n        vector<int>memo = {1};\\n        \\n        while(memo.size() < n)\\n        {\\n             vector<int>curr;\\n            \\n            for(auto x : memo)\\n            {\\n                 if(2*x-1 <= n)\\n                     curr.push_back(2*x-1);\\n            }\\n            for(auto x : memo)\\n            {\\n                 if(2*x <= n)\\n                     curr.push_back(2*x);\\n            }\\n            memo = curr;\\n        }\\n        return memo;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369773,
                "title": "java-easy-1ms-with-explanation",
                "content": "1. As per problem condition A+B != 2C, where  A<C<B\\nObviously, if  A is odd and  B is even (and vice versa) then we satisfy condition with any C in-between.\\nFor ex.  in the array 2,4,6,8,  1,3,5,7,9 , for any A from 2,4,6,8 and B from 1,3,5,7,9, condition is always valid \\nFinally, every array can be divided into odds and evens, so both groups will co-satisfy condition.\\nBut what to do with each group itsef?\\n\\n2. Let\\'s talk about even group.\\nA+B != 2C, all are evens, let\\'s divide them by 2\\nA/2 + B/2 != c; where C is even, A/2 and B/2 can be odd or even \\nif we regroup all given evens by placing first evens with odd A/2 and then all evens with even B/2, then we satisfy condition for any A and B and any C in-between\\n2,4,6,8,10,12,14,16\\nA : 2,6,10,14,  B: 4,8,12,16\\n\\n3. There is intersting property for any A,B,C.\\nA+B !=2C, where A<C<B\\nif w increment A, B, C, then condition is still valid\\nA+1+B+1 != 2*(C+1)\\nA+B+2 != 2C +2\\nA+B!=C\\n\\n4. if we increment all items of  Odd group, then we can treat it as Even group. We only need to adjust group back afterwards by decrement \\n\\n\\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        int m = n/2 + n%2;\\n        int[] buf = new int[n];\\n        for(int i=1;i<=n;i+=2)\\n            buf[i/2] = i;\\n        for(int i=2;i<=n;i+=2)\\n            buf[m + i/2 -1] = i;\\n        //1,3,5,7,9,  2,4,6,8,10\\n        recOdd(buf,0,m-1);\\n        recEven(buf,m, n-1);\\n        return buf;\\n    }\\n    private void recOdd(int[] buf, int from, int to){\\n        if(from <0 || from>=to || to>=buf.length)\\n            return;\\n        for(int f=from;f<=to;f++)\\n            buf[f]++;\\n        recEven(buf,from, to);\\n        for(int f=from;f<=to;f++)\\n            buf[f]--;\\n        \\n    }\\n    private void recEven(int[] buf, int from, int to){\\n        if(from <0 || from>=to || to>=buf.length)\\n            return;\\n\\n        for(int i=from;i<=to;i++)\\n            buf[i]/=2;\\n\\n        int f = from, t = to;\\n        while(f<t){\\n            while(f < t && buf[f]%2==1) \\n                f++;\\n            while(f < t && buf[t]%2==0)\\n                t--;\\n            if(f < t){\\n                int temp = buf[f];\\n                buf[f]=buf[t];\\n                buf[t] = temp;\\n            }\\n\\n        }\\n        recOdd(buf, from, f+buf[f]%2-1);\\n        recEven(buf, f+buf[f]%2, to);\\n\\n        for(int i=from;i<=to;i++)\\n            buf[i]*=2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        int m = n/2 + n%2;\\n        int[] buf = new int[n];\\n        for(int i=1;i<=n;i+=2)\\n            buf[i/2] = i;\\n        for(int i=2;i<=n;i+=2)\\n            buf[m + i/2 -1] = i;\\n        //1,3,5,7,9,  2,4,6,8,10\\n        recOdd(buf,0,m-1);\\n        recEven(buf,m, n-1);\\n        return buf;\\n    }\\n    private void recOdd(int[] buf, int from, int to){\\n        if(from <0 || from>=to || to>=buf.length)\\n            return;\\n        for(int f=from;f<=to;f++)\\n            buf[f]++;\\n        recEven(buf,from, to);\\n        for(int f=from;f<=to;f++)\\n            buf[f]--;\\n        \\n    }\\n    private void recEven(int[] buf, int from, int to){\\n        if(from <0 || from>=to || to>=buf.length)\\n            return;\\n\\n        for(int i=from;i<=to;i++)\\n            buf[i]/=2;\\n\\n        int f = from, t = to;\\n        while(f<t){\\n            while(f < t && buf[f]%2==1) \\n                f++;\\n            while(f < t && buf[t]%2==0)\\n                t--;\\n            if(f < t){\\n                int temp = buf[f];\\n                buf[f]=buf[t];\\n                buf[t] = temp;\\n            }\\n\\n        }\\n        recOdd(buf, from, f+buf[f]%2-1);\\n        recEven(buf, f+buf[f]%2, to);\\n\\n        for(int i=from;i<=to;i++)\\n            buf[i]*=2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369728,
                "title": "is-2-1-4-3-5-a-valid-solution-for-n-5",
                "content": "I am confused as to why **2,1,4,3,5** is not a valid answer for n=5. Similarly, why 2,1,4,3,6,5 not a valid solution for n=6?",
                "solutionTags": [],
                "code": "I am confused as to why **2,1,4,3,5** is not a valid answer for n=5. Similarly, why 2,1,4,3,6,5 not a valid solution for n=6?",
                "codeTag": "Unknown"
            },
            {
                "id": 1369540,
                "title": "c-easy-to-understand-beautiful-array-fast-and-efficient",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> ans ;\\n        ans.push_back(1) ;\\n\\t\\tvector<int> temp ;\\n        while(ans.size() < n)\\n        {\\n            temp.clear();\\n            for(auto i:ans)\\n            {\\n                if(i*2 - 1 <= n)\\n                {\\n                    temp.push_back(i*2 - 1) ;\\n                }\\n            }\\n            for(auto i:ans)\\n            {\\n                if(i*2 <= n)\\n                {\\n                    temp.push_back(i*2) ;\\n                }\\n            }\\n            ans = temp ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> ans ;\\n        ans.push_back(1) ;\\n\\t\\tvector<int> temp ;\\n        while(ans.size() < n)\\n        {\\n            temp.clear();\\n            for(auto i:ans)\\n            {\\n                if(i*2 - 1 <= n)\\n                {\\n                    temp.push_back(i*2 - 1) ;\\n                }\\n            }\\n            for(auto i:ans)\\n            {\\n                if(i*2 <= n)\\n                {\\n                    temp.push_back(i*2) ;\\n                }\\n            }\\n            ans = temp ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369535,
                "title": "c-easy-to-understand-fast-and-efficient-solution",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n       vector<int> ans;\\n        ans.push_back(1);\\n        vector<int> temp;\\n        while(ans.size()<n)\\n        {\\n            temp.clear();\\n            for(auto i:ans)\\n            {\\n                if(2*i-1<=n)\\n                {\\n                    temp.push_back(2*i-1);\\n                }\\n            }\\n            for(auto i:ans)\\n            {\\n                if(2*i<=n)\\n                {\\n                    temp.push_back(2*i);\\n                }\\n            }\\n            ans=temp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n       vector<int> ans;\\n        ans.push_back(1);\\n        vector<int> temp;\\n        while(ans.size()<n)\\n        {\\n            temp.clear();\\n            for(auto i:ans)\\n            {\\n                if(2*i-1<=n)\\n                {\\n                    temp.push_back(2*i-1);\\n                }\\n            }\\n            for(auto i:ans)\\n            {\\n                if(2*i<=n)\\n                {\\n                    temp.push_back(2*i);\\n                }\\n            }\\n            ans=temp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369501,
                "title": "c-solution-o-n-solution-beautiful-array",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Beautiful Array.\\nMemory Usage: 7.2 MB, less than 74.91% of C++ online submissions for Beautiful Array.\\n*********************************\\nI took help from youtube because this is weirdest question on leetcode\\n\\n***********************************\\nvector<int> beautifulArray(int n) {\\n        vector<int>ans={1};  // our final/resultant array\\n        while(ans.size()<n)  // this loop will run until all the number are not generated till n\\n        {\\n           vector<int>res; //it is like a temparory array\\n\\t\\t   //for all the odd number \\n            for(auto &x : ans) \\n            {\\n              if(x*2-1<=n) res.push_back(x*2-1);\\n            }\\n\\t\\t\\t//for all the even number \\n            for(auto &x : ans)\\n            {\\n              if(x*2<=n) res.push_back(x*2);\\n            }\\n            ans=res;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Beautiful Array.\\nMemory Usage: 7.2 MB, less than 74.91% of C++ online submissions for Beautiful Array.\\n*********************************\\nI took help from youtube because this is weirdest question on leetcode\\n\\n***********************************\\nvector<int> beautifulArray(int n) {\\n        vector<int>ans={1};  // our final/resultant array\\n        while(ans.size()<n)  // this loop will run until all the number are not generated till n\\n        {\\n           vector<int>res; //it is like a temparory array\\n\\t\\t   //for all the odd number \\n            for(auto &x : ans) \\n            {\\n              if(x*2-1<=n) res.push_back(x*2-1);\\n            }\\n\\t\\t\\t//for all the even number \\n            for(auto &x : ans)\\n            {\\n              if(x*2<=n) res.push_back(x*2);\\n            }\\n            ans=res;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1369455,
                "title": "go-0ms-o-n-using-bit-reversal",
                "content": "This solution generates the exact same arrays on the test cases as the built-in solution (tested with n = 1000).\\n\\nI noticed that evens on one side and odds on the other is a good strategy, since the average of even and odd is a fraction so you only need to worry about the in-between numbers within the evens/odds sections.\\n\\nSimilarly, within the evens section you can have sub-sections of multiples-of-4 and not-multiples of-4, since averaging one of each will be an odd number (since non-multiple-of-4 + multiple-of-4 is non-multiple-of-4, and non-multiple-of-4 divided by 2 is odd).\\n\\nGenerating a sequence sorted by the ones place first, then the twos place etc can be done by reversing the bits of an iterator that counts up by one.  Reversing the bits can cause some numbers to be too big, this solution gets around that by generating all the numbers with the same number of (binary) digits and discarding the ones that are too big.\\n\\n```\\nimport \"math/bits\"\\n\\nfunc beautifulArray(n int) []int {\\n    out := make([]int, 0, n)\\n    blen := bits.Len16(uint16(n))\\n    twoPow := uint16(1 << blen)\\n    for i := uint16(0); i < twoPow; i++ {\\n        num := int(bits.Reverse16(i) >> (16-blen))\\n        if num < n {\\n            out = append(out, num + 1)\\n        }\\n    }\\n    return out\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport \"math/bits\"\\n\\nfunc beautifulArray(n int) []int {\\n    out := make([]int, 0, n)\\n    blen := bits.Len16(uint16(n))\\n    twoPow := uint16(1 << blen)\\n    for i := uint16(0); i < twoPow; i++ {\\n        num := int(bits.Reverse16(i) >> (16-blen))\\n        if num < n {\\n            out = append(out, num + 1)\\n        }\\n    }\\n    return out\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1369387,
                "title": "javascript-even-odd-enlarge-from-1-80ms-100",
                "content": "```\\nconst beautifulArray = (n) => {\\n    let res = [1];\\n    while (res.length < n) {\\n        let tmp = [];\\n        for (const x of res) {\\n            if (x * 2 - 1 <= n) tmp.push(x * 2 - 1);\\n        }\\n        for (const x of res) {\\n            if (x * 2 <= n) tmp.push(x * 2);\\n        }\\n        res = tmp;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst beautifulArray = (n) => {\\n    let res = [1];\\n    while (res.length < n) {\\n        let tmp = [];\\n        for (const x of res) {\\n            if (x * 2 - 1 <= n) tmp.push(x * 2 - 1);\\n        }\\n        for (const x of res) {\\n            if (x * 2 <= n) tmp.push(x * 2);\\n        }\\n        res = tmp;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1369381,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public int[] BeautifulArray(int n) {\\n        List<int> beautiful = new List<int>{1};\\n        while(beautiful.Count<n){\\n            List<int> temp = new List<int>();\\n            foreach(int i in beautiful){\\n                if((i*2-1)<=n) temp.Add((i*2-1));\\n            }\\n            foreach(int j in beautiful){\\n                if(2*j<=n) temp.Add(2*j);\\n            }\\n            beautiful=temp;\\n        }\\n        return beautiful.ToArray();\\n    }\\n}\\n  \\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] BeautifulArray(int n) {\\n        List<int> beautiful = new List<int>{1};\\n        while(beautiful.Count<n){\\n            List<int> temp = new List<int>();\\n            foreach(int i in beautiful){\\n                if((i*2-1)<=n) temp.Add((i*2-1));\\n            }\\n            foreach(int j in beautiful){\\n                if(2*j<=n) temp.Add(2*j);\\n            }\\n            beautiful=temp;\\n        }\\n        return beautiful.ToArray();\\n    }\\n}\\n  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369350,
                "title": "solution-based-on-inspection-and-oeis-org",
                "content": "Before I got this solution, my other solution spat out these output for n=1...10\\n![image](https://assets.leetcode.com/users/images/ce1c1fb7-edbf-427d-9d49-c9b321648c1a_1627526519.91102.png)\\nIf you look closely, you\\'ll notice that in this specific output, the answer for n is just the answer for n-1 with n inserted somewhere. Looking up the sequence of insert positions in 1-based indexing (1,2,2,4,2,...), you\\'ll find this sequence: https://oeis.org/A088371. Therefore, all that\\'s needed to be done is get beautifulArray(n-1), and insert n at a(n) position. Formula for a(n) is given in the link also\\n```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int a(int n) {\\n        if (dp[n] != -1) { return dp[n]; }\\n\\n        if (n == 1) { return 1; }\\n        if (n == 2) { return 2; }\\n\\n        if (n % 2 == 0) {\\n            dp[n] = n/2 + a(n / 2);\\n        }\\n\\n        else { \\n            dp[n] = a((n + 1) / 2); \\n        }\\n\\n        return dp[n];\\n    }\\n\\n    vector<int> beautifulArray(int n) {\\n        if (dp.size() == 0) {\\n            dp = vector<int>(n+1, -1);\\n        }\\n\\n        if (n == 1) {\\n            return { 1 };\\n        }\\n\\n        if (n == 2) {\\n            return { 1,2 };\\n        }\\n\\n        if (n == 3) {\\n            return { 1,3,2 };\\n        }\\n\\n        vector<int> res = beautifulArray(n - 1);\\n        int p = a(n) - 1;\\n        res.insert(res.begin() + p, n);\\n\\n        return res;\\n    }\\n};\\n```\\nSpace complexity: O(n)\\nTime complexity: I actually dont know, maybe the inserting part makes it O(n^2)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int a(int n) {\\n        if (dp[n] != -1) { return dp[n]; }\\n\\n        if (n == 1) { return 1; }\\n        if (n == 2) { return 2; }\\n\\n        if (n % 2 == 0) {\\n            dp[n] = n/2 + a(n / 2);\\n        }\\n\\n        else { \\n            dp[n] = a((n + 1) / 2); \\n        }\\n\\n        return dp[n];\\n    }\\n\\n    vector<int> beautifulArray(int n) {\\n        if (dp.size() == 0) {\\n            dp = vector<int>(n+1, -1);\\n        }\\n\\n        if (n == 1) {\\n            return { 1 };\\n        }\\n\\n        if (n == 2) {\\n            return { 1,2 };\\n        }\\n\\n        if (n == 3) {\\n            return { 1,3,2 };\\n        }\\n\\n        vector<int> res = beautifulArray(n - 1);\\n        int p = a(n) - 1;\\n        res.insert(res.begin() + p, n);\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369272,
                "title": "python3-recursion-recursive-solution",
                "content": "The key ideas are:\\n- The array can be formed by placing all even number in front of odd numbers, because  even and odd number cannot have a interger average. \\n- The \"Beauty\" of an array is invariant of any addition or multiplication by constants to each of its elements.\\n- An array of consecutive even numbers can be transformed into an array of consecutive integers by dividing each by 2 and the \"Beauty\" will not change.\\n- An array of consecutive odd numbers can be transformed into array of consecutive integers by adding one and dividing by 2, and the \"Beauty\" will not change.\\n\\n```\\n    def beautifulArray(self, n: int) -> List[int]:\\n        if n==1: return [1]\\n        \\n        even=[2*i for i in self.beautifulArray(n//2)]\\n        odd=[2*i-1 for i in self.beautifulArray(n-n//2)]\\n        \\n        return even+odd\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n    def beautifulArray(self, n: int) -> List[int]:\\n        if n==1: return [1]\\n        \\n        even=[2*i for i in self.beautifulArray(n//2)]\\n        odd=[2*i-1 for i in self.beautifulArray(n-n//2)]\\n        \\n        return even+odd\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1369262,
                "title": "beautiful-array-using-even-odd-indexes-approach",
                "content": "```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        def dfs(arr):\\n            if len(arr) <= 1:\\n                return arr\\n            even,odd = [],[]\\n            for i in range(len(arr)):\\n                if i & 1:\\n                    odd.append(arr[i])\\n                else:\\n                    even.append(arr[i])\\n            return dfs(odd) + dfs(even)\\n        return dfs(range(1,n+1))\\n```\\nif you put the permutation in order like 1,2,3,4,5,6,7 you will notice that for a center number, num[center] and num[center-x] and number[center+x] where x = 1,2,3,4,5...  satisfy the 2k = i + j. so you need to break them up somehow.\\none way is to separate them by even,odd index which break some of the 2k = i,j but not all of them. there are still problems in the subsequent even odd lists. so separate them out again into even odd index. keep doing this until one element remains and build it back up.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        def dfs(arr):\\n            if len(arr) <= 1:\\n                return arr\\n            even,odd = [],[]\\n            for i in range(len(arr)):\\n                if i & 1:\\n                    odd.append(arr[i])\\n                else:\\n                    even.append(arr[i])\\n            return dfs(odd) + dfs(even)\\n        return dfs(range(1,n+1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369252,
                "title": "quick-and-clean-python-solution-90-time",
                "content": "```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        if n==1: return [1]\\n        if n==2: return [1,2]\\n        if n==3: return [1,3,2]\\n        if n==4: return [1,3,2,4]\\n        \\n        #get a beautiful array the length of the odd integers\\n        odd_beaut = self.beautifulArray((n+1)//2)\\n        \\n        #map the array to the odds\\n        odds = [(2*i)-1 for i in odd_beaut]\\n        \\n        #create an even array\\n        evens = [i+1 for i in odds]\\n        \\n        result = odds+evens\\n        \\n        #may have to remove one if we did too many evens\\n        if n%2==1: result.remove(n+1)\\n        \\n        return result\\n            ```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        if n==1: return [1]\\n        if n==2: return [1,2]\\n        if n==3: return [1,3,2]\\n        if n==4: return [1,3,2,4]\\n        \\n        #get a beautiful array the length of the odd integers\\n        odd_beaut = self.beautifulArray((n+1)//2)\\n        \\n        #map the array to the odds\\n        odds = [(2*i)-1 for i in odd_beaut]\\n        \\n        #create an even array\\n        evens = [i+1 for i in odds]\\n        \\n        result = odds+evens\\n        \\n        #may have to remove one if we did too many evens\\n        if n%2==1: result.remove(n+1)\\n        \\n        return result\\n            ```",
                "codeTag": "Java"
            },
            {
                "id": 1369174,
                "title": "java-by-inductive-construction-with-explanation",
                "content": "Key observations:\\n1. If we have a solution that works for n integers, we can double every number and remain compliant with the rule: nums[i] + nums[j] <> nums[k] * 2.\\n1. Using the doubled solution, we can append a copy to the right in reverse order, and decrement every element of the copy by one, to get a valid solution of length 2n.  That is because both copies  still satisfy the above rule, and for any pairs that cross the midpoint, parity is different, making the sum odd.\\n1. If we have a solution of length n, we can construct a solution of length m where m < n by simply removing all elements that are greater than m.\\n\\nPutting the first 2 observations together, given any solution, we can construct a new solution of double the original length.  So just start with the solution for n = 1, which is [1], and repeatedly double its length until it is at least long enough.  If it is too long, use observation 3 to trim it to the desired length.\\n\\nFor example:\\n[2,1,4,3] --> [4,2,8,6] (doubling) --> [4,2,8,6,5,7,1,3] (copy, reverse, decrement, append)\\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        // Find the smallest power of 2 that is greater than or equal to n\\n        int x = 1;\\n        while (x < n) x += x;\\n        \\n        int[] answer = new int[x];\\n        \\n        // Populate the first position\\n        answer[0] = 1;\\n        int size = 1;\\n        \\n        // Now repeat: reverse and append, while doubling\\n        // Each iteration generates a solution that is twice as long as the previous step\\n        while (size * 2 <= x) {\\n            for (int i = 0; i < size; i++) {\\n                answer[i] += answer[i];\\n                answer[size * 2 - i - 1] = answer[i] - 1;\\n            }\\n            size += size;\\n        }\\n        if (x == n) return answer;\\n        \\n        // Create an answer array of the right length, discarding numbers that are too big\\n        int[] finalAnswer = new int[n];\\n        int j = 0;\\n        for (int i = 0; i < answer.length; i++) if (answer[i] <= n) finalAnswer[j++] = answer[i];\\n        \\n        return finalAnswer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        // Find the smallest power of 2 that is greater than or equal to n\\n        int x = 1;\\n        while (x < n) x += x;\\n        \\n        int[] answer = new int[x];\\n        \\n        // Populate the first position\\n        answer[0] = 1;\\n        int size = 1;\\n        \\n        // Now repeat: reverse and append, while doubling\\n        // Each iteration generates a solution that is twice as long as the previous step\\n        while (size * 2 <= x) {\\n            for (int i = 0; i < size; i++) {\\n                answer[i] += answer[i];\\n                answer[size * 2 - i - 1] = answer[i] - 1;\\n            }\\n            size += size;\\n        }\\n        if (x == n) return answer;\\n        \\n        // Create an answer array of the right length, discarding numbers that are too big\\n        int[] finalAnswer = new int[n];\\n        int j = 0;\\n        for (int i = 0; i < answer.length; i++) if (answer[i] <= n) finalAnswer[j++] = answer[i];\\n        \\n        return finalAnswer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369096,
                "title": "java-o-n-0ms-beats-100-divide-and-conquer-explained",
                "content": "### Problem Solving\\nWe can solve this question using one (generalized) key observation: for any permutation, **if you separate the numbers** such that all numbers on one side are the same MOD `m` (where `m` in `{2, 4, 8, ...}`, it is impossible for `arr[i] + arr[j] == 2 * arr[k]`.\\nE.g. #1\\n```\\n\\tarr = [1, 5, 3, 7, 2, 6, 4, 8]\\n\\t\\t= [1, 1, 1, 1, 0, 0, 0, 0] (MOD 2)\\n\\t\\t= [1, 1, 3, 3, 0, 0, 2, 2] (MOD 4)\\n```\\nE.g. #2\\n```\\n\\tarr = [1, 9, 5, 3, 11, 7, 2, 10, 6, 4, 8]\\n\\t\\t= [1, 1, 1, 1, 1 , 1, 0, 0 , 0, 0, 0] (MOD 2)\\n\\t\\t= [1, 1, 1, 3, 3 , 3, 2, 2 , 2, 0, 0] (MOD 4)\\n\\t\\t= [1, 1, 5, 3, 3 , 7, 2, 2 , 6, 4, 0] (MOD 8)\\n```\\nAs you can see, these permutations keep the numbers separated as described above, and you can check for yourself that if you take any two numbers that belong to different groups (for example, `9` and `3` in e.g. #2), none of the numbers inbetween them will break the requirement.\\nThis makes the problem suitable for a **divide and conquer** approach, where we separate numbers according to these rules at every level.\\n### Implementation\\n\\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        final int[] beauty = new int[n];\\n        fill(beauty, 0, n, 0, 1);\\n        return beauty;\\n    }\\n    \\n    private void fill(int[] arr, int lo, int hi, int start, int mod) {\\n        if(hi - lo == 1) { // base case\\n            arr[lo] = start + 1;\\n        } else { // divide and conquer\\n            final int mid = lo + (hi - lo + 1) / 2;\\n            fill(arr, lo, mid, start, mod << 1);\\n            fill(arr, mid, hi, start + mod, mod << 1); // (start + mod) to prevent overlap\\n        }\\n    }\\n    \\n\\t/* not part of the solution, but helpful for debugging. verify:\\n\\t\\t* no duplicates and within range --> is permutation of [1...n]\\n\\t\\t* arr[i] + arr[j] != 2 * arr[k] for all 0 <= i < k < j < n\\n\\t*/\\n    private boolean verify(int[] arr) {\\n        final Set<Integer> seen = new HashSet<>(arr.length);\\n        for(int i = 0; i < arr.length; i++) {\\n            if(arr[i] < 1 || arr[i] > arr.length || seen.contains(arr[i])) return false;\\n            seen.add(arr[i]);\\n            for(int k = i + 1; k < arr.length; k++)\\n                for(int j = k + 1; j < arr.length; j++)\\n                    if(arr[i] + arr[j] == arr[k] * 2) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\tarr = [1, 5, 3, 7, 2, 6, 4, 8]\\n\\t\\t= [1, 1, 1, 1, 0, 0, 0, 0] (MOD 2)\\n\\t\\t= [1, 1, 3, 3, 0, 0, 2, 2] (MOD 4)\\n```\n```\\n\\tarr = [1, 9, 5, 3, 11, 7, 2, 10, 6, 4, 8]\\n\\t\\t= [1, 1, 1, 1, 1 , 1, 0, 0 , 0, 0, 0] (MOD 2)\\n\\t\\t= [1, 1, 1, 3, 3 , 3, 2, 2 , 2, 0, 0] (MOD 4)\\n\\t\\t= [1, 1, 5, 3, 3 , 7, 2, 2 , 6, 4, 0] (MOD 8)\\n```\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        final int[] beauty = new int[n];\\n        fill(beauty, 0, n, 0, 1);\\n        return beauty;\\n    }\\n    \\n    private void fill(int[] arr, int lo, int hi, int start, int mod) {\\n        if(hi - lo == 1) { // base case\\n            arr[lo] = start + 1;\\n        } else { // divide and conquer\\n            final int mid = lo + (hi - lo + 1) / 2;\\n            fill(arr, lo, mid, start, mod << 1);\\n            fill(arr, mid, hi, start + mod, mod << 1); // (start + mod) to prevent overlap\\n        }\\n    }\\n    \\n\\t/* not part of the solution, but helpful for debugging. verify:\\n\\t\\t* no duplicates and within range --> is permutation of [1...n]\\n\\t\\t* arr[i] + arr[j] != 2 * arr[k] for all 0 <= i < k < j < n\\n\\t*/\\n    private boolean verify(int[] arr) {\\n        final Set<Integer> seen = new HashSet<>(arr.length);\\n        for(int i = 0; i < arr.length; i++) {\\n            if(arr[i] < 1 || arr[i] > arr.length || seen.contains(arr[i])) return false;\\n            seen.add(arr[i]);\\n            for(int k = i + 1; k < arr.length; k++)\\n                for(int j = k + 1; j < arr.length; j++)\\n                    if(arr[i] + arr[j] == arr[k] * 2) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369079,
                "title": "aging-s-rpr-solution",
                "content": "This solution is posted here by user@ Aging - https://leetcode.com/problems/beautiful-array/solution/192124\\n\\nI wanted to post it here in case anyone else found it useful, as i did:\\n\\nWe can reverse a number\\'s binary format bitwisely to get its reversed binary representation (RPR). For this question, 10 bits are enough, as N is always less than 1024. In this case, RPR(1) = 0b1000000000, RPR(2) = 0b0100000000, RPR(12) = 0b0011000000.\\n\\nIt could be proved that: for any i < j < k, if i + k = j * 2, then RPR(j) is either less than or larger than both RPR(i) and RPR(k), or in another word, RPR(j) can not be between RPR(i) and RPR(k).\\nProve:\\nConsider these four conditions:\\n\\ni, k is odd, j is even (e.g. 1+7=4*2). The first bit of RPR(i) and RPR(k) is 1, and the first bit of RPR(j) is 0, so RPR(j) is smaller than both RPR(i) and RPR(k).\\ni, k is even, j is odd (e.g. 2+4=3*2). The first bit of RPR(i) and RPR(k) is 0, and the first bit of RPR(j) is 1, so RPR(j) is larger than both RPR(i) and RPR(k).\\ni, k is odd, j is odd (e.g. 1+5=3*2). Define i1 = (i-1)/2, k1=(k-1)/2, j1 = (j-1)/2, then we have i1<j1<k1, and i1+k1=j1*2. i1, j1, k1 could be treated as new i, j, k.\\ni, k is even, j is even (e.g. 2+6=4*2). Define i1=i/2, k1=k/2, j1=j/2, then we have i1<j1<k1, and i1+k1=j1*2. i1, j1, k1 could be treated as new i, j, k.\\nFor case #3 and #4, it is reduced to the original proposition, and must be finally reduced to case #1 or #2, because i < j < k.\\nBased on this, the algorithm is simple: sort all the numbers for 1 to N by its RPR. The final array is a result.\\nTime complexity is O(N log N) and space complexity is O(N).\\n\\nThe code is like:\\n\\n```\\nclass Solution {\\npublic:\\n  int rev(int N) {\\n  int ret = 0;\\n  for (int i = 0; i <= 9; ++i)\\n  ret += ((N >> i) & 0x1) << (9 - i);\\n  return ret;\\n}\\n\\nvector<int> beautifulArray(int N) {\\n    vector<int> ans(N, 0);\\n    for (int i = 0; i < N; ++i) ans[i] = i + 1;\\n    sort(ans.begin(), ans.end(), [&](int i, int j){\\n        return rev(i) < rev(j);\\n    });\\n    \\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  int rev(int N) {\\n  int ret = 0;\\n  for (int i = 0; i <= 9; ++i)\\n  ret += ((N >> i) & 0x1) << (9 - i);\\n  return ret;\\n}\\n\\nvector<int> beautifulArray(int N) {\\n    vector<int> ans(N, 0);\\n    for (int i = 0; i < N; ++i) ans[i] = i + 1;\\n    sort(ans.begin(), ans.end(), [&](int i, int j){\\n        return rev(i) < rev(j);\\n    });\\n    \\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369076,
                "title": "ruby-recursion",
                "content": "```\\n# @param {Integer} n\\n# @return {Integer[]}\\ndef beautiful_array(n)\\n  @cache = {}\\n  solve(n)\\nend\\n\\ndef solve(n)\\n  return [1] if n == 1\\n  return @cache[n] if @cache[n]\\n  \\n  even_index = n/2\\n  odd_index = n - even_index\\n  even = solve(even_index)\\n  odd = solve(odd_index)\\n  even = even.map{|v| 2*v}\\n  odd = odd.map{|v| 2*v-1}\\n  @cache[n] = even + odd\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Recursion"
                ],
                "code": "```\\n# @param {Integer} n\\n# @return {Integer[]}\\ndef beautiful_array(n)\\n  @cache = {}\\n  solve(n)\\nend\\n\\ndef solve(n)\\n  return [1] if n == 1\\n  return @cache[n] if @cache[n]\\n  \\n  even_index = n/2\\n  odd_index = n - even_index\\n  even = solve(even_index)\\n  odd = solve(odd_index)\\n  even = even.map{|v| 2*v}\\n  odd = odd.map{|v| 2*v-1}\\n  @cache[n] = even + odd\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1369048,
                "title": "beautiful-array-python",
                "content": "The key thing to recognize is that a beautiful array is still beautiful if you double all the numbers in it. It\\'s also still beautiful if you double all the numbers and subtract one. Another thing to notice is that we can deal with even and odd numbers in the array separately, because the sum of even and odd is odd, and half an odd number is not a whole number. Recognizing these two facts, we can write a recursive function to find a beautiful array of size n given that we already know the beautiful array of half the size of n. (When n is even you can use n/2, when it\\'s odd you need n/2 rounded down and n/2 rounded up.)\\n\\nSo here\\'s my solution:\\n```\\nclass Solution:\\n    def __init__(self):\\n\\t\\t# Initiate a memo so we don\\'t calculate the same array twice\\n        self.memo = {1: [1]}\\n    \\n    def beautifulArray(self, n: int) -> List[int]:\\n        if n in self.memo:\\n            return self.memo[n]\\n        \\n\\t\\t# We can deal with even and odd numbers separately, since an even plus an odd equals an odd, and half an odd is not a whole number\\n        even = self.beautifulArray(n//2)\\n        even = [x*2 for x in even]\\n        \\n        odd = self.beautifulArray(n//2+n%2)\\n        odd = [(x*2)-1 for x in odd]\\n        \\n        self.memo[n] = even + odd\\n        print(self.memo)\\n        return self.memo[n]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n\\t\\t# Initiate a memo so we don\\'t calculate the same array twice\\n        self.memo = {1: [1]}\\n    \\n    def beautifulArray(self, n: int) -> List[int]:\\n        if n in self.memo:\\n            return self.memo[n]\\n        \\n\\t\\t# We can deal with even and odd numbers separately, since an even plus an odd equals an odd, and half an odd is not a whole number\\n        even = self.beautifulArray(n//2)\\n        even = [x*2 for x in even]\\n        \\n        odd = self.beautifulArray(n//2+n%2)\\n        odd = [(x*2)-1 for x in odd]\\n        \\n        self.memo[n] = even + odd\\n        print(self.memo)\\n        return self.memo[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369006,
                "title": "go-solution",
                "content": "Inspired by [this solution](https://leetcode.com/problems/beautiful-array/discuss/186679/Odd-%2B-Even-Pattern-O(N))\\n```\\nfunc beautifulArray(n int) []int {\\n\\tresult := []int{1}\\n\\tfor len(result) < n {\\n\\t\\ttemp := make([]int, 0, 2*len(result))\\n\\t\\tfor _, i := range result {\\n\\t\\t\\tif x := i*2 - 1; x <= n {\\n\\t\\t\\t\\ttemp = append(temp, x)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor _, i := range result {\\n\\t\\t\\tif x := i * 2; x <= n {\\n\\t\\t\\t\\ttemp = append(temp, x)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresult = temp\\n\\t}\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc beautifulArray(n int) []int {\\n\\tresult := []int{1}\\n\\tfor len(result) < n {\\n\\t\\ttemp := make([]int, 0, 2*len(result))\\n\\t\\tfor _, i := range result {\\n\\t\\t\\tif x := i*2 - 1; x <= n {\\n\\t\\t\\t\\ttemp = append(temp, x)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor _, i := range result {\\n\\t\\t\\tif x := i * 2; x <= n {\\n\\t\\t\\t\\ttemp = append(temp, x)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresult = temp\\n\\t}\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1368934,
                "title": "java-arraylist-easiest",
                "content": "```\\n  public int[] beautifulArray(int n) {\\n        \\n List<Integer> p= new ArrayList();\\n        p.add(1);\\n        int a=2;\\n        int k=n-1;\\n        while(k>0){\\n              List<Integer> q= new ArrayList();\\n        for(int i=0;i<p.size();i++){\\n            if(p.get(i)*2-1 <=a){\\n                q.add(p.get(i)*2-1);\\n            \\n        \\n            }\\n        }\\n           List<Integer> r= new ArrayList();\\n        \\n          for(int i=0;i<p.size();i++){\\n              \\n            if(p.get(i)*2<=a){\\n                r.add(p.get(i)*2);\\n            }\\n        }\\n         p.clear();\\n        \\n     for(int i=0;i<q.size();i++){\\n               p.add(q.get(i));\\n     }\\n       for(int i=0;i<r.size();i++){\\n               p.add(r.get(i));\\n     }   \\n        a++;\\n            k--;\\n        \\n        }\\n        \\nint arr[]=new int[p.size()];\\n        for(int i=0;i<p.size();i++){\\n            arr[i]=p.get(i);\\n        }\\n        return arr;\\n     \\n        \\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n  public int[] beautifulArray(int n) {\\n        \\n List<Integer> p= new ArrayList();\\n        p.add(1);\\n        int a=2;\\n        int k=n-1;\\n        while(k>0){\\n              List<Integer> q= new ArrayList();\\n        for(int i=0;i<p.size();i++){\\n            if(p.get(i)*2-1 <=a){\\n                q.add(p.get(i)*2-1);\\n            \\n        \\n            }\\n        }\\n           List<Integer> r= new ArrayList();\\n        \\n          for(int i=0;i<p.size();i++){\\n              \\n            if(p.get(i)*2<=a){\\n                r.add(p.get(i)*2);\\n            }\\n        }\\n         p.clear();\\n        \\n     for(int i=0;i<q.size();i++){\\n               p.add(q.get(i));\\n     }\\n       for(int i=0;i<r.size();i++){\\n               p.add(r.get(i));\\n     }   \\n        a++;\\n            k--;\\n        \\n        }\\n        \\nint arr[]=new int[p.size()];\\n        for(int i=0;i<p.size();i++){\\n            arr[i]=p.get(i);\\n        }\\n        return arr;\\n     \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1368874,
                "title": "python-explained-0-n-time",
                "content": "Consider\\nn=1 -> [1]\\nn=2 -> [1,2], [2,1]\\nn=3 -> [1,3,2], [2,3,1], [2,1,3]\\nn=4 -> [1,3,2,4], ....\\nn=5 -> [1,5,3,2,4]\\nn=6 -> [1,5,3,  2,6,4]\\n             -Odd--Even--\\nBy looking at the patterns, we can see that some valid sequences have Odd and Even number separated\\n\\nEach element of the current level is made by a combination of Odd and Even elements separated.\\n\\nOur problem let it be f(n) where f(x) gives the beautiful array\\n\\nThen each odd element -> 2*x-1   for x in f(n-1)\\nThen each even element -> 2x       for x in f(n-1)\\nProvided each resultant element is in the range of our current level i,e, 1<=2*x-1<n and 1<2*n<n\\n\\nThe sum of both the odd and even elements one after the other, gives our answer.\\n\\nTime complexity can be optimized to O(n) using memoization. Since this problem at each level just finds the individual elements without repeating intermediate steps (due to memo) so it is of linear time complexity.\\n\\n```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        @lru_cache(None)\\n        def helper(n):\\n            if n==1:\\n                return [1]\\n            odd = []\\n            for x in helper(n-1):\\n                if 2*x-1<=n:\\n                    odd.append(2*x-1)\\n            even = []\\n            for x in helper(n-1):\\n                if 2*x<=n:\\n                    even.append(2*x)\\n            return odd+even\\n        return helper(n)",
                "solutionTags": [
                    "Python",
                    "Memoization"
                ],
                "code": "Consider\\nn=1 -> [1]\\nn=2 -> [1,2], [2,1]\\nn=3 -> [1,3,2], [2,3,1], [2,1,3]\\nn=4 -> [1,3,2,4], ....\\nn=5 -> [1,5,3,2,4]\\nn=6 -> [1,5,3,  2,6,4]\\n             -Odd--Even--\\nBy looking at the patterns, we can see that some valid sequences have Odd and Even number separated\\n\\nEach element of the current level is made by a combination of Odd and Even elements separated.\\n\\nOur problem let it be f(n) where f(x) gives the beautiful array\\n\\nThen each odd element -> 2*x-1   for x in f(n-1)\\nThen each even element -> 2x       for x in f(n-1)\\nProvided each resultant element is in the range of our current level i,e, 1<=2*x-1<n and 1<2*n<n\\n\\nThe sum of both the odd and even elements one after the other, gives our answer.\\n\\nTime complexity can be optimized to O(n) using memoization. Since this problem at each level just finds the individual elements without repeating intermediate steps (due to memo) so it is of linear time complexity.\\n\\n```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        @lru_cache(None)\\n        def helper(n):\\n            if n==1:\\n                return [1]\\n            odd = []\\n            for x in helper(n-1):\\n                if 2*x-1<=n:\\n                    odd.append(2*x-1)\\n            even = []\\n            for x in helper(n-1):\\n                if 2*x<=n:\\n                    even.append(2*x)\\n            return odd+even\\n        return helper(n)",
                "codeTag": "Java"
            },
            {
                "id": 1368852,
                "title": "best-cpp-solution-o-n-beautiful-array",
                "content": "class Solution {\\npublic:\\n     vector<int> beautifulArray(int N) {\\n        vector<int> res = {1};\\n        while (res.size() < N) \\n        {\\n            vector<int> tmp;\\n            for (int i : res)\\n            {\\n                if (i * 2 - 1 <= N) tmp.push_back(i * 2 - 1);\\n            }\\n            for (int i : res)\\n            {\\n                if (i * 2 <= N) tmp.push_back(i * 2);\\n            }\\n            res = tmp;\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n     vector<int> beautifulArray(int N) {\\n        vector<int> res = {1}",
                "codeTag": "Java"
            },
            {
                "id": 1368782,
                "title": "odd-even-simple-pattern-code-with-proper-explanation-and-cases-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        // Logic is start from 1, now firstly firstly make all of them odd and then make all of them even\\n        // it means odd odd odd odd odd ........ even even even\\n        /// by using this method it never possible to get nums[k]*2=nums[i]+nums[j]\\n        // because \\n        \\n        // 1. Case 1: if you consider odd odd odd pair then odd + odd=even and odd*2=even, but they always have gap of 2 minimum.\\n        \\n        // Case 2: odd odd even:- here odd + even=odd, and odd*2= even, so even!=odd;\\n        \\n        // case 3: odd even even:- Same as case 2 , not possible;\\n        \\n        // case 4: even even even: - same as case 1, i.e., always have gap or diff of 2 minimum;\\n        \\n        vector<int>vec={1};\\n        while(vec.size()<n)\\n        {\\n            vector<int>temp;\\n             for(auto x: vec) if(x*2-1<=n) temp.push_back(x*2-1);\\n             for(auto x: vec) if(x*2<=n) temp.push_back(x*2);\\n            vec=temp;\\n        }\\n        \\n        return vec;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        // Logic is start from 1, now firstly firstly make all of them odd and then make all of them even\\n        // it means odd odd odd odd odd ........ even even even\\n        /// by using this method it never possible to get nums[k]*2=nums[i]+nums[j]\\n        // because \\n        \\n        // 1. Case 1: if you consider odd odd odd pair then odd + odd=even and odd*2=even, but they always have gap of 2 minimum.\\n        \\n        // Case 2: odd odd even:- here odd + even=odd, and odd*2= even, so even!=odd;\\n        \\n        // case 3: odd even even:- Same as case 2 , not possible;\\n        \\n        // case 4: even even even: - same as case 1, i.e., always have gap or diff of 2 minimum;\\n        \\n        vector<int>vec={1};\\n        while(vec.size()<n)\\n        {\\n            vector<int>temp;\\n             for(auto x: vec) if(x*2-1<=n) temp.push_back(x*2-1);\\n             for(auto x: vec) if(x*2<=n) temp.push_back(x*2);\\n            vec=temp;\\n        }\\n        \\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368680,
                "title": "o-n-2-solution-c",
                "content": "```\\nstruct ListNode {\\n        int val;\\n        ListNode *next;\\n        ListNode() : val(0), next(nullptr) {}\\n        ListNode(int x) : val(x), next(nullptr) {}\\n        ListNode(int x, ListNode *next) : val(x), next(next) {}\\n    };\\n    vector<int> beautifulArray(int n) {\\n        vector<vector<int>> p = {{1}, {1, 2}, {1, 3, 2}, {2, 1, 4, 3}, {3,1,2,5,4}, {1,5,3,2,6,4}};\\n        if (n <= 6) {\\n            return p[n-1];\\n        } else {\\n            ListNode* fun = new ListNode(1);\\n            auto it  = fun;\\n            for (int i = 1; i < 6; i++) {\\n                it->next = new ListNode(p[5][i]);\\n                it = it->next;\\n            }\\n            int cycles = 7;\\n            int loop = 8;\\n            int prevLoop = 4;\\n            while (cycles <= n) {\\n                if (cycles == loop) {\\n                    prevLoop = loop;\\n                    loop *= 2;\\n                }\\n                for (it = fun; it != nullptr; it = it->next) {\\n                    if (it->val+prevLoop == cycles) {\\n                        it->next = new ListNode(cycles, it->next);\\n                        break;\\n                    } else if (it->next == nullptr) {\\n                        it->next = new ListNode(cycles);\\n                        break;\\n                    }\\n                }\\n                cycles++;\\n            }\\n            vector<int> out;\\n            while (fun != NULL) {\\n                out.push_back(fun->val);\\n                fun = fun->next;\\n            }\\n            return out;\\n        }\\n    }\\n```\\n\\nI came up with this strange solution through pattern analysis, but I really dont understand why it works. Why does this recurrent pattern of multiples of 2 (4->8->16->32) show up, and why does it not seem to apply to the cases where n = 4 and 5 respectively? Somehow this seemingly inefficient solution also manages to achieve a respectable runtime of 4ms",
                "solutionTags": [],
                "code": "```\\nstruct ListNode {\\n        int val;\\n        ListNode *next;\\n        ListNode() : val(0), next(nullptr) {}\\n        ListNode(int x) : val(x), next(nullptr) {}\\n        ListNode(int x, ListNode *next) : val(x), next(next) {}\\n    };\\n    vector<int> beautifulArray(int n) {\\n        vector<vector<int>> p = {{1}, {1, 2}, {1, 3, 2}, {2, 1, 4, 3}, {3,1,2,5,4}, {1,5,3,2,6,4}};\\n        if (n <= 6) {\\n            return p[n-1];\\n        } else {\\n            ListNode* fun = new ListNode(1);\\n            auto it  = fun;\\n            for (int i = 1; i < 6; i++) {\\n                it->next = new ListNode(p[5][i]);\\n                it = it->next;\\n            }\\n            int cycles = 7;\\n            int loop = 8;\\n            int prevLoop = 4;\\n            while (cycles <= n) {\\n                if (cycles == loop) {\\n                    prevLoop = loop;\\n                    loop *= 2;\\n                }\\n                for (it = fun; it != nullptr; it = it->next) {\\n                    if (it->val+prevLoop == cycles) {\\n                        it->next = new ListNode(cycles, it->next);\\n                        break;\\n                    } else if (it->next == nullptr) {\\n                        it->next = new ListNode(cycles);\\n                        break;\\n                    }\\n                }\\n                cycles++;\\n            }\\n            vector<int> out;\\n            while (fun != NULL) {\\n                out.push_back(fun->val);\\n                fun = fun->next;\\n            }\\n            return out;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1564546,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1564927,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1565543,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1569730,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1729838,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1568403,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1567052,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1572545,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1569329,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1573243,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1564546,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1564927,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1565543,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1569730,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1729838,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1568403,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1567052,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1572545,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1569329,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1573243,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            }
        ]
    }
]