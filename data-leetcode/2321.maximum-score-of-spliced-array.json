[
    {
        "title": "Maximum Score Of Spliced Array",
        "question_content": "You are given two 0-indexed integer arrays nums1 and nums2, both of length n.\nYou can choose two integers left and right where 0 <= left <= right < n and swap the subarray nums1[left...right] with the subarray nums2[left...right].\n\n\tFor example, if nums1 = [1,2,3,4,5] and nums2 = [11,12,13,14,15] and you choose left = 1 and right = 2, nums1 becomes [1,12,13,4,5] and nums2 becomes [11,2,3,14,15].\n\nYou may choose to apply the mentioned operation once or not do anything.\nThe score of the arrays is the maximum of sum(nums1) and sum(nums2), where sum(arr) is the sum of all the elements in the array arr.\nReturn the maximum possible score.\nA subarray is a contiguous sequence of elements within an array. arr[left...right] denotes the subarray that contains the elements of nums between indices left and right (inclusive).\n&nbsp;\nExample 1:\n\nInput: nums1 = [60,60,60], nums2 = [10,90,10]\nOutput: 210\nExplanation: Choosing left = 1 and right = 1, we have nums1 = [60,90,60] and nums2 = [10,60,10].\nThe score is max(sum(nums1), sum(nums2)) = max(210, 80) = 210.\nExample 2:\n\nInput: nums1 = [20,40,20,70,30], nums2 = [50,20,50,40,20]\nOutput: 220\nExplanation: Choosing left = 3, right = 4, we have nums1 = [20,40,20,40,20] and nums2 = [50,20,50,70,30].\nThe score is max(sum(nums1), sum(nums2)) = max(140, 220) = 220.\n\nExample 3:\n\nInput: nums1 = [7,11,13], nums2 = [1,1,1]\nOutput: 31\nExplanation: We choose not to swap any subarray.\nThe score is max(sum(nums1), sum(nums2)) = max(31, 3) = 31.\n\n&nbsp;\nConstraints:\n\n\tn == nums1.length == nums2.length\n\t1 <= n <= 105\n\t1 <= nums1[i], nums2[i] <= 104",
        "solutions": [
            {
                "id": 2198138,
                "title": "kadane",
                "content": "We can either increase sum of nums1 or sum of num2\\nIf we want to increase sum of nums1, we will select subarray from i to j with maximum sum of nums2[i] - nums1[i];\\nIf we want to increase sum of nums2, we will select subarray from i to j with maximum sum of nums1[i] - nums2[i];\\n\\nTime Complexity -> **O(N)**\\nSpace Complexity -> **O(1)**\\n\\n```\\nclass Solution {\\n\\n    public int maximumsSplicedArray(int[] nums1, int[] nums2) {\\n        int ans = 0, sum1 = 0, sum2 = 0;\\n\\n        for (int i : nums1) sum1 += i;\\n        for (int i : nums2) sum2 += i;\\n\\n        ans = Math.max(sum1, sum2);\\n\\n        int first = 0, second = 0, max1 = 0, max2 = 0;\\n\\n        for (int i = 0; i < nums1.length; i++) {\\n            first += (nums2[i] - nums1[i]);\\n            second += (nums1[i] - nums2[i]);\\n            \\n            max1 = Math.max(max1, first);\\n            max2 = Math.max(max2, second);\\n            \\n            if (first < 0) first = 0;\\n            if (second < 0) second = 0;\\n        }\\n\\n        ans = Math.max(ans, sum1 + max1);\\n        ans = Math.max(ans, sum2 + max2);\\n\\n        return ans;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    public int maximumsSplicedArray(int[] nums1, int[] nums2) {\\n        int ans = 0, sum1 = 0, sum2 = 0;\\n\\n        for (int i : nums1) sum1 += i;\\n        for (int i : nums2) sum2 += i;\\n\\n        ans = Math.max(sum1, sum2);\\n\\n        int first = 0, second = 0, max1 = 0, max2 = 0;\\n\\n        for (int i = 0; i < nums1.length; i++) {\\n            first += (nums2[i] - nums1[i]);\\n            second += (nums1[i] - nums2[i]);\\n            \\n            max1 = Math.max(max1, first);\\n            max2 = Math.max(max2, second);\\n            \\n            if (first < 0) first = 0;\\n            if (second < 0) second = 0;\\n        }\\n\\n        ans = Math.max(ans, sum1 + max1);\\n        ans = Math.max(ans, sum2 + max2);\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198135,
                "title": "double-kadane",
                "content": "We can decide whether to increase the sum of the first array, or the second.\\n\\nSay, we try increasing `n1`. We can use Kadane to find largest sum continuous array, where each element is `n2[i] - n1[i]`.\\n\\n**C++**\\n```cpp\\nint kadane(vector<int>& n1, vector<int>& n2) {\\n    int sz = n1.size(), sum = 0, res = 0;\\n    for (int i = 0; i < sz; ++i) {\\n        sum = max(n2[i] - n1[i], sum + n2[i] - n1[i]);\\n        res = max(res, sum);\\n    }\\n    return res;\\n}\\nint maximumsSplicedArray(vector<int>& n1, vector<int>& n2) {\\n    return max(accumulate(begin(n1), end(n1), 0) + kadane(n1, n2),\\n               accumulate(begin(n2), end(n2), 0) + kadane(n2, n1));\\n}\\n```\\n\\nor we can do it in one pass.\\n\\n**C++**\\n```cpp\\nint maximumsSplicedArray(vector<int>& n1, vector<int>& n2) {\\n    int kd[2] = {}, res[2] = {}, sum[2] = {};\\n    for (int i = 0; i < n1.size(); ++i) {\\n        kd[0] = max(n2[i] - n1[i], kd[0] + n2[i] - n1[i]);\\n        res[0] = max(res[0], kd[0]);\\n        kd[1] = max(n1[i] - n2[i], kd[1] + n1[i] - n2[i]);\\n        res[1] = max(res[1], kd[1]);\\n        sum[0] += n1[i];\\n        sum[1] += n2[i];        \\n    }    \\n    return max(sum[0] + res[0], sum[1] + res[1]);\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint kadane(vector<int>& n1, vector<int>& n2) {\\n    int sz = n1.size(), sum = 0, res = 0;\\n    for (int i = 0; i < sz; ++i) {\\n        sum = max(n2[i] - n1[i], sum + n2[i] - n1[i]);\\n        res = max(res, sum);\\n    }\\n    return res;\\n}\\nint maximumsSplicedArray(vector<int>& n1, vector<int>& n2) {\\n    return max(accumulate(begin(n1), end(n1), 0) + kadane(n1, n2),\\n               accumulate(begin(n2), end(n2), 0) + kadane(n2, n1));\\n}\\n```\n```cpp\\nint maximumsSplicedArray(vector<int>& n1, vector<int>& n2) {\\n    int kd[2] = {}, res[2] = {}, sum[2] = {};\\n    for (int i = 0; i < n1.size(); ++i) {\\n        kd[0] = max(n2[i] - n1[i], kd[0] + n2[i] - n1[i]);\\n        res[0] = max(res[0], kd[0]);\\n        kd[1] = max(n1[i] - n2[i], kd[1] + n1[i] - n2[i]);\\n        res[1] = max(res[1], kd[1]);\\n        sum[0] += n1[i];\\n        sum[1] += n2[i];        \\n    }    \\n    return max(sum[0] + res[0], sum[1] + res[1]);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2198244,
                "title": "python-kadane-solution",
                "content": "# **Explanation**\\nmax(B\\') = sum(B) + kadane(A - B)\\nmax(A\\') = sum(A) + kadane(B - A)\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n\\n**Python**\\n```py\\n    def maximumsSplicedArray(self, A, B):\\n        def kadane(A, B):\\n            res = cur = 0\\n            for i in range(len(A)):\\n                cur = max(0, cur + A[i] - B[i])\\n                res = max(res, cur)\\n            return res + sum(B)\\n        return max(kadane(A, B), kadane(B, A))\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def maximumsSplicedArray(self, A, B):\\n        def kadane(A, B):\\n            res = cur = 0\\n            for i in range(len(A)):\\n                cur = max(0, cur + A[i] - B[i])\\n                res = max(res, cur)\\n            return res + sum(B)\\n        return max(kadane(A, B), kadane(B, A))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2199139,
                "title": "100-faster-most-detailed-solution-for-complete-dummies-o-n-kadane-s-single-loop",
                "content": "1st thing we have to do is to obviously find the sum of both the arrays.\\nLet them be sum1, sum2.\\nNow either of them will be greater than the other.\\nTo write a cleaner code and avoid confusion. We will make sum1 > sum2 if it isn\\'t by swapping (sum1,sum2) and (nums1[], nums2[])\\n\\nNow we have sum1>=sum2\\n\\n##### Observation:\\n```\\nsum(nums1\\')  = sum(nums1) + { sum(nums2[l...r]) - sum(nums1[l...r]) }\\nsum(nums2\\')  = sum(nums2) - { sum(nums2[l...r]) - sum(nums1[l...r]) }\\n```\\n\\nSo basically:\\n1. to make sum1 larger we maximize ```{ sum(nums2[l...r]) - sum(nums1[l...r]) }```\\n2. to make sum2 larger we minimize ```{ sum(nums2[l...r]) - sum(nums1[l...r]) }```<br>(NOTE: a very important point to consider since there may exist a negative sum array sum which upon subtraction from sum2 makes sum2 > sum1)\\n\\n#### Implementation:\\nWe account for both of the above possibilities and return the maximum of the two.\\nSo we can easily find the maximum/minimum subarray sum difference ie. ```{ sum(nums2[l...r]) - sum(nums1[l...r]) }```\\nusing Kadane\\'s algorithm in O(n) time\\n\\n#### Kadane\\'s algo logic(feel free to skip): \\n\\nThe basic logic of Kadane\\'s algorithm is that we maintain a variable (maxEndingHere/minEndingHere) denoting the maximum sum of any subarray ending at the current index(ie element at current index has to be included)\\n\\nAt each index we have 2 options: \\n1. include the curent element in, the subarray ending at the previous index\\n2. exlude the previous subarray and start a new subarray containing only the current element\\n\\nThis decision depends on our objective:\\n1. If objective is to minimize: <br> \\n```\\n///including the previous subarray is better than considering only the current element\\n///therefore include it\\nif(minEndingHere+currEle<=currEle){\\n\\tminEndingHere = minEndingHere+currEle;\\n}else{//>=currEle , including the previous subarray is worse than considering only the current element\\n//therefore dont include it\\n\\tminEndingHere = curEle\\n}\\n```\\nNow that you have understood the logic\\nAnother/Shorter way to write the code is:\\n```\\nminEndingHere += currEle\\nif(minEndingHere > currEle){\\n\\tminEndingHere = curEle\\n}\\n```\\n\\n#### CODE for the problem given: \\n```\\nclass Solution {\\n    public int maximumsSplicedArray(int[] nums1, int[] nums2) {\\n        int sum1=0, sum2=0, n=nums1.length;\\n        for(int num:nums1) sum1+=num;\\n        for(int num:nums2) sum2+=num;\\n        \\n        if(sum2>sum1){\\n            int temp = sum2;\\n            sum2 = sum1;\\n            sum1 = temp;\\n            int[] temparr = nums2;\\n            nums2 = nums1;\\n            nums1 = temparr;\\n        }\\n        \\n        //now sum1>=sum2\\n        \\n        //maxEndingHere denotes the maximum sum subarray ending at current index(ie. element at current index has to be included)\\n        //minEndingHere denotes the minimum sum subarray ending at current index\\n        int maxEndingHere, minEndingHere, maxSoFar, minSoFar, currEle;\\n        maxEndingHere=minEndingHere=maxSoFar=minSoFar=nums2[0]-nums1[0];\\n        \\n        for(int i=1;i<n;i++){\\n            currEle = nums2[i]-nums1[i];\\n            minEndingHere += currEle;\\n            maxEndingHere += currEle;\\n            \\n            if(maxEndingHere < currEle){\\n                maxEndingHere = currEle;\\n            }\\n            if(minEndingHere > currEle){\\n                minEndingHere = currEle;\\n            }\\n            \\n            maxSoFar = Math.max(maxEndingHere, maxSoFar);\\n            minSoFar = Math.min(minEndingHere, minSoFar);\\n        }\\n        \\n        //return the maximum of the 2 possibilities dicussed\\n        //also keep care that maxSoFar>=0 and maxSoFar<=0\\n        return Math.max(sum1+Math.max(maxSoFar,0), sum2-Math.min(0, minSoFar));\\n    }\\n}\\n\\n```\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nsum(nums1\\')  = sum(nums1) + { sum(nums2[l...r]) - sum(nums1[l...r]) }\\nsum(nums2\\')  = sum(nums2) - { sum(nums2[l...r]) - sum(nums1[l...r]) }\\n```\n```{ sum(nums2[l...r]) - sum(nums1[l...r]) }```\n```{ sum(nums2[l...r]) - sum(nums1[l...r]) }```\n```{ sum(nums2[l...r]) - sum(nums1[l...r]) }```\n```\\n///including the previous subarray is better than considering only the current element\\n///therefore include it\\nif(minEndingHere+currEle<=currEle){\\n\\tminEndingHere = minEndingHere+currEle;\\n}else{//>=currEle , including the previous subarray is worse than considering only the current element\\n//therefore dont include it\\n\\tminEndingHere = curEle\\n}\\n```\n```\\nminEndingHere += currEle\\nif(minEndingHere > currEle){\\n\\tminEndingHere = curEle\\n}\\n```\n```\\nclass Solution {\\n    public int maximumsSplicedArray(int[] nums1, int[] nums2) {\\n        int sum1=0, sum2=0, n=nums1.length;\\n        for(int num:nums1) sum1+=num;\\n        for(int num:nums2) sum2+=num;\\n        \\n        if(sum2>sum1){\\n            int temp = sum2;\\n            sum2 = sum1;\\n            sum1 = temp;\\n            int[] temparr = nums2;\\n            nums2 = nums1;\\n            nums1 = temparr;\\n        }\\n        \\n        //now sum1>=sum2\\n        \\n        //maxEndingHere denotes the maximum sum subarray ending at current index(ie. element at current index has to be included)\\n        //minEndingHere denotes the minimum sum subarray ending at current index\\n        int maxEndingHere, minEndingHere, maxSoFar, minSoFar, currEle;\\n        maxEndingHere=minEndingHere=maxSoFar=minSoFar=nums2[0]-nums1[0];\\n        \\n        for(int i=1;i<n;i++){\\n            currEle = nums2[i]-nums1[i];\\n            minEndingHere += currEle;\\n            maxEndingHere += currEle;\\n            \\n            if(maxEndingHere < currEle){\\n                maxEndingHere = currEle;\\n            }\\n            if(minEndingHere > currEle){\\n                minEndingHere = currEle;\\n            }\\n            \\n            maxSoFar = Math.max(maxEndingHere, maxSoFar);\\n            minSoFar = Math.min(minEndingHere, minSoFar);\\n        }\\n        \\n        //return the maximum of the 2 possibilities dicussed\\n        //also keep care that maxSoFar>=0 and maxSoFar<=0\\n        return Math.max(sum1+Math.max(maxSoFar,0), sum2-Math.min(0, minSoFar));\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198382,
                "title": "c-quick-kadane-solution-o-n",
                "content": "**Kadane Solution**\\n* We basically check for the maximum subarray `running sum` difference of first array compared to second array so as to swap.\\n\\n```cpp\\nint score(vector<int>& a, vector<int>& b) {\\n    int runningSum = 0, maxi = 0;\\n    int sum = accumulate(a.begin(), a.end(), 0);\\n\\n    for (int i = 0; i < a.size(); i++) {\\n        runningSum += b[i] - a[i];\\n        if (runningSum < 0)\\n            runningSum = 0;\\n        maxi = max(maxi, runningSum);\\n    }\\n\\n    return sum + maxi;\\n}\\n\\nint maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n    return max(score(nums1, nums2), score(nums2, nums1));\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint score(vector<int>& a, vector<int>& b) {\\n    int runningSum = 0, maxi = 0;\\n    int sum = accumulate(a.begin(), a.end(), 0);\\n\\n    for (int i = 0; i < a.size(); i++) {\\n        runningSum += b[i] - a[i];\\n        if (runningSum < 0)\\n            runningSum = 0;\\n        maxi = max(maxi, runningSum);\\n    }\\n\\n    return sum + maxi;\\n}\\n\\nint maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n    return max(score(nums1, nums2), score(nums2, nums1));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2198115,
                "title": "c-java-python3-modified-maximum-subarray-sum",
                "content": "\\n\\nCheckout: https://leetcode.com/problems/maximum-subarray/\\n* Find the 2 difference arrays of the given arrays and find the maximum subarray sum of them individually\\n* Add maximum subarray sum of difference arrays to sum of given arrays\\n* Return max\\n\\n**C++**:\\n```\\nint maxSubArray(vector<int>& nums) {\\n    int res = INT_MIN, m = 0;\\n    for (int x: nums) {\\n        m = max(x, m + x);\\n        res = max(res, m);\\n    }\\n    return res;\\n}\\nint maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n    int s1 = accumulate(nums1.begin(), nums1.end(), 0);\\n    int s2 = accumulate(nums2.begin(), nums2.end(), 0);\\n    vector<int> v1(nums1.size()), v2(nums1.size());\\n    for (int i = 0; i < nums1.size(); i++) {\\n        v1[i] = nums1[i] - nums2[i];\\n        v2[i] = nums2[i] - nums1[i];\\n    }\\n    return max(s1 + maxSubArray(v2), s2 + maxSubArray(v1));\\n}\\n```\\n\\n**Python3**:\\n```\\ndef maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n\\tdef maxSubArray(A: List[int]):\\n\\t\\tres, m = -inf, 0\\n\\t\\tfor i in A:\\n\\t\\t\\tm = max(i, m + i)\\n\\t\\t\\tres = max(res, m)\\n\\t\\treturn res\\n\\ts1, s2 = sum(nums1), sum(nums2)\\n\\tn1 = [x - y for x, y in zip(nums1,nums2)]\\n\\tn2 = [x - y for x, y in zip(nums2,nums1)]\\n\\treturn max(s1 + maxSubArray(n2), s2 + maxSubArray(n1))\\n```\\n\\n**Python3 - 2 lines**:\\n```\\ndef maximumsSplicedArray(self, A: List[int], B: List[int]) -> int:\\n\\tmaxSubArray = lambda A: max(accumulate(A, lambda a, c: max(c, c + a)))\\n\\treturn max(sum(A) + maxSubArray([x - y for x, y in zip(B,A)]), sum(B) + maxSubArray([x - y for x, y in zip(A,B)]))\\n```\\n\\n**Java**:\\n```\\npublic int maximumsSplicedArray(int[] nums1, int[] nums2) {\\n    int s1 = Arrays.stream(nums1).sum();\\n    int s2 = Arrays.stream(nums2).sum();\\n    int[] v1 = new int[nums1.length], v2 = new int[nums1.length];\\n    for (int i = 0; i < nums1.length; i++) {\\n        v1[i] = nums1[i] - nums2[i];\\n        v2[i] = nums2[i] - nums1[i];\\n    }\\n    return Math.max(s1 + maxSubArray(v2), s2 + maxSubArray(v1));\\n}\\nprivate int maxSubArray(int[] nums) {\\n    int res = Integer.MIN_VALUE, m = 0;\\n    for (int x: nums) {\\n        m = Math.max(x, m + x);\\n        res = Math.max(res, m);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint maxSubArray(vector<int>& nums) {\\n    int res = INT_MIN, m = 0;\\n    for (int x: nums) {\\n        m = max(x, m + x);\\n        res = max(res, m);\\n    }\\n    return res;\\n}\\nint maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n    int s1 = accumulate(nums1.begin(), nums1.end(), 0);\\n    int s2 = accumulate(nums2.begin(), nums2.end(), 0);\\n    vector<int> v1(nums1.size()), v2(nums1.size());\\n    for (int i = 0; i < nums1.size(); i++) {\\n        v1[i] = nums1[i] - nums2[i];\\n        v2[i] = nums2[i] - nums1[i];\\n    }\\n    return max(s1 + maxSubArray(v2), s2 + maxSubArray(v1));\\n}\\n```\n```\\ndef maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n\\tdef maxSubArray(A: List[int]):\\n\\t\\tres, m = -inf, 0\\n\\t\\tfor i in A:\\n\\t\\t\\tm = max(i, m + i)\\n\\t\\t\\tres = max(res, m)\\n\\t\\treturn res\\n\\ts1, s2 = sum(nums1), sum(nums2)\\n\\tn1 = [x - y for x, y in zip(nums1,nums2)]\\n\\tn2 = [x - y for x, y in zip(nums2,nums1)]\\n\\treturn max(s1 + maxSubArray(n2), s2 + maxSubArray(n1))\\n```\n```\\ndef maximumsSplicedArray(self, A: List[int], B: List[int]) -> int:\\n\\tmaxSubArray = lambda A: max(accumulate(A, lambda a, c: max(c, c + a)))\\n\\treturn max(sum(A) + maxSubArray([x - y for x, y in zip(B,A)]), sum(B) + maxSubArray([x - y for x, y in zip(A,B)]))\\n```\n```\\npublic int maximumsSplicedArray(int[] nums1, int[] nums2) {\\n    int s1 = Arrays.stream(nums1).sum();\\n    int s2 = Arrays.stream(nums2).sum();\\n    int[] v1 = new int[nums1.length], v2 = new int[nums1.length];\\n    for (int i = 0; i < nums1.length; i++) {\\n        v1[i] = nums1[i] - nums2[i];\\n        v2[i] = nums2[i] - nums1[i];\\n    }\\n    return Math.max(s1 + maxSubArray(v2), s2 + maxSubArray(v1));\\n}\\nprivate int maxSubArray(int[] nums) {\\n    int res = Integer.MIN_VALUE, m = 0;\\n    for (int x: nums) {\\n        m = Math.max(x, m + x);\\n        res = Math.max(res, m);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2198358,
                "title": "no-need-to-remember-any-algorithm",
                "content": "So the first idea which came in my mind during the contest is that, Let\\'s build nums1 as maximum and nums2 as maximum and get the maximum of nums1 and nums2.\\n\\nOk! That\\'s make sense but the problem is how can you make nums1 maximum and nums1 maximum with the help of other while swaping all the elements [left..right].\\n\\nSo let\\'s think :\\nnums1 = [a,b,c,d]\\nnums2 = [e,f,g,h]\\n\\nso when should you swap elements between [left..right] to make nums1 maximum?\\nonly when,\\n```\\nsum(nums1[left..right]) < sum(nums2[left..right])\\n```\\nWell, you got some point to think? Yes right, so what you\\'ll do with this range i.e. [left..right]. If you\\'re smart than you try to steal number from nums2 as much as possible right to do maximum nums1? So we\\'ll keep stretching this window from right side till \\n```\\nsum(nums1[left..right]) < sum(nums2[left..right])\\n```\\n*Ok? let\\'s note this point at somewhere.***let\\'s statement A**\\n\\n--\\n\\nNow you got two points [left, right] which increased the overall sum for nums1 ok?\\nJust do same for making nums2 as maximum.\\n```\\nclass Solution {\\npublic:\\n    int getMax(vector<int> &nums1, vector<int>& nums2) {\\n        int diff = 0, sum1 = 0, sum2 = 0, i=0;\\n        while(i<nums1.size()) {\\n            if(sum1>sum2) {\\n                sum1=sum2=0;\\n            } else {\\n                diff = max(diff, sum2-sum1);\\n                sum1+=nums1[i];\\n                sum2+=nums2[i];\\n                i++;\\n            }\\n        }\\n        return max(diff, sum2-sum1);\\n    }\\n    \\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int leftMax=getMax(nums1,nums2)+accumulate(nums1.begin(), nums1.end(),0), rightMax=getMax(nums2, nums1)+accumulate(nums2.begin(), nums2.end(),0);\\n        return max(leftMax,rightMax);\\n    }\\n};\\n```\\n\\n**Please upvote if it help you**\\n**Happy coding!**",
                "solutionTags": [],
                "code": "```\\nsum(nums1[left..right]) < sum(nums2[left..right])\\n```\n```\\nsum(nums1[left..right]) < sum(nums2[left..right])\\n```\n```\\nclass Solution {\\npublic:\\n    int getMax(vector<int> &nums1, vector<int>& nums2) {\\n        int diff = 0, sum1 = 0, sum2 = 0, i=0;\\n        while(i<nums1.size()) {\\n            if(sum1>sum2) {\\n                sum1=sum2=0;\\n            } else {\\n                diff = max(diff, sum2-sum1);\\n                sum1+=nums1[i];\\n                sum2+=nums2[i];\\n                i++;\\n            }\\n        }\\n        return max(diff, sum2-sum1);\\n    }\\n    \\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int leftMax=getMax(nums1,nums2)+accumulate(nums1.begin(), nums1.end(),0), rightMax=getMax(nums2, nums1)+accumulate(nums2.begin(), nums2.end(),0);\\n        return max(leftMax,rightMax);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2199275,
                "title": "o-n-double-kadane",
                "content": "Lets say **sumA is the sum of array nums1 and sumB is sum of array nums2.**\\n\\nThe fact we are only worried about change certain subarray, so first lets calculate the amout of improvement we can get after swapping each element, which is **nums1[i] - nums2[i]** (if we replace ith index of nums2 with nums1) and **nums2[i] - nums1[i]**, and we store both of these value in two seperate arrays lets say tempA and tempB, respectively.\\n\\nNow if we know the subarray with maximum sum in tempA, we can say that if change the particular subarray from array \\'A\\' to \\'B\\' we will increase our sum of \\'A\\' by the maximum sum, **lets say maximum subarray sum as maximumSubarraySumofTempA.**\\nSimlarly for maximum sum subarray in tempB array will be the maximum surplus sum into sum of array nums2 you can get by changing exactly 1 subarray from B to A, **lets say maximum subarray sum as maximumSubarraySumofTempB.**\\n\\n\\nWe will use Kadane twice for both array tempA and tempB, and return the maximum of **sumA + maximumSubarraySumofTempA or sumB + maximumSubarraySumofTempB.**\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        vector <int> tempA , tempB;\\n        int sumA = 0 , sumB = 0;\\n        for(int i = 0;i<nums1.size();i++) {\\n            sumA += nums1[i];\\n            tempA.push_back(nums2[i] - nums1[i]);\\n            sumB += nums2[i];\\n            tempB.push_back(nums1[i] - nums2[i]);\\n        }\\n        int maxDiffA = 0 , maxDiffB = 0;\\n        int sum = 0;\\n        for(int i : tempA) {\\n            sum += i;\\n            maxDiffA = max(sum , maxDiffA);\\n            sum = max(0 , sum);\\n        }\\n        sum = 0;\\n        for(int i : tempB) {\\n            sum += i;\\n            maxDiffB = max(sum , maxDiffB);\\n            sum = max(0 , sum);\\n        }\\n        return max(sumA + maxDiffA , sumB + maxDiffB);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        vector <int> tempA , tempB;\\n        int sumA = 0 , sumB = 0;\\n        for(int i = 0;i<nums1.size();i++) {\\n            sumA += nums1[i];\\n            tempA.push_back(nums2[i] - nums1[i]);\\n            sumB += nums2[i];\\n            tempB.push_back(nums1[i] - nums2[i]);\\n        }\\n        int maxDiffA = 0 , maxDiffB = 0;\\n        int sum = 0;\\n        for(int i : tempA) {\\n            sum += i;\\n            maxDiffA = max(sum , maxDiffA);\\n            sum = max(0 , sum);\\n        }\\n        sum = 0;\\n        for(int i : tempB) {\\n            sum += i;\\n            maxDiffB = max(sum , maxDiffB);\\n            sum = max(0 , sum);\\n        }\\n        return max(sumA + maxDiffA , sumB + maxDiffB);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2221996,
                "title": "easy-solution-explanation-kadane-s-algorithm",
                "content": "**Idea:**\\nIts simple, if we include subarray from num2 to nums1 then total sum of the nums1 will be **`(originalNums1Sum + nums2SubarraySum - nums1SubarraySum).`**\\noriginalNums1Sum is fixed, so we have to find **`max(nums2SubarraySum - nums1SubarraySum).`**\\nAnd same goes for nums2\\n\\n**Approach:**\\nFirst we will find the sum of the both arrays.\\nNow we will find num1 - num2 & nums2 - nums1.\\nWe will apply kadane\\'s algorithm on these two new aarays.\\nWe will find max sum subarray and replace it in original array.\\n***for nums1 new array => nums2 - nums1\\nfor nums2 new array => nums1 - nums2***\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int sum1 = 0, sum2 = 0;\\n        int n = nums1.size();\\n        \\n\\t\\t//find sum of both arrays\\n        for(int i=0; i<n; i++) sum1 += nums1[i], sum2 += nums2[i];\\n        \\n\\t\\t//Kadane algorithm on two new arrays\\n        int temp1 = 0, temp2 = 0;\\n        int first = 0, second = 0;\\n        \\n        for(int i=0; i<n; i++) {\\n\\t\\t\\t\\n\\t\\t\\t//First array\\n            temp1 += (nums2[i] - nums1[i]);\\n\\t\\t\\t//Second array\\n            temp2 += (nums1[i] - nums2[i]);\\n            \\n            first = max(temp1, first);\\n            second = max(temp2, second);\\n            \\n            if(temp1 < 0) temp1 = 0;\\n            if(temp2 < 0) temp2 = 0;\\n        }\\n        \\n\\t\\t//We find max sum subarray and replace it with another array\\n        return max(sum1 + first, sum2 + second);\\n    }\\n\\t\\n\\t//please upvote\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int sum1 = 0, sum2 = 0;\\n        int n = nums1.size();\\n        \\n\\t\\t//find sum of both arrays\\n        for(int i=0; i<n; i++) sum1 += nums1[i], sum2 += nums2[i];\\n        \\n\\t\\t//Kadane algorithm on two new arrays\\n        int temp1 = 0, temp2 = 0;\\n        int first = 0, second = 0;\\n        \\n        for(int i=0; i<n; i++) {\\n\\t\\t\\t\\n\\t\\t\\t//First array\\n            temp1 += (nums2[i] - nums1[i]);\\n\\t\\t\\t//Second array\\n            temp2 += (nums1[i] - nums2[i]);\\n            \\n            first = max(temp1, first);\\n            second = max(temp2, second);\\n            \\n            if(temp1 < 0) temp1 = 0;\\n            if(temp2 < 0) temp2 = 0;\\n        }\\n        \\n\\t\\t//We find max sum subarray and replace it with another array\\n        return max(sum1 + first, sum2 + second);\\n    }\\n\\t\\n\\t//please upvote\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2199344,
                "title": "c-greedy-approach-time-o-n-space-o-1-observation-and-explanation",
                "content": "# Solution\\n```C++\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        return max(MaxValOfA1(nums1,nums2), MaxValOfA1(nums2,nums1));\\n    }\\n    \\n    int MaxValOfA1(vector<int>& a1, vector<int>& a2) {\\n        int n = a1.size();\\n        int sum = 0;\\n        for(auto &i:a1) sum+=i;\\n        int L=0, R=0, max_inc=0;\\n\\t\\t//max_inc is maximum positive contribution of a1\\n        int acc1 = 0, acc2 =0;\\n        while(L<n && R<n) {\\n            acc1 += a1[R];\\n            acc2 += a2[R];\\n            max_inc = max(max_inc, acc2-acc1);\\n            if(acc1>=acc2) {\\n                L=R+1;\\n                R=L;\\n                acc1=0;\\n                acc2=0;\\n            } else {\\n                R=R+1;\\n            }\\n        }\\n        return sum + max_inc;\\n    }\\n};\\n```\\n\\n\\n# Explanation \\nThink about this test case\\na1 =  [50,20,50,40,20], sum1 = 180, \\na2 =  [20,40,20,70,30], sum2 = 180, \\nIn this case, \\nswap(a2[2..4] , a1[2..4]) and a1 will become a1\\' = [50,20,50,70,30]. \\nSo the sum of a1\\' is 220 is our solution.\\n\\nFor the problem , that is mean that we need to find subarray a2[L..R] - a1[L..R] = max_inc1 \\nsuch that sum1+max_inc1 is our solution. \\n\\nIf we can find L and R such that a2[L..R] - a1[L..R] = max_inc1 is maximum. \\nThen sum1+max_inc1 will become our solution when solution is happen in a1.\\n\\n`\\na1 =  [50,20,50,40,20], sum1 = 180, \\na2 =  [20,40,20,70,30], sum2 = 180, \\n`\\n\\n```[case L=0, R=0]```\\nBecause a2[0..0] - a1[0..0] <=0, so there is not any postive contribution for L=0 & R=0 after \\nswap(a1[L..R], a2[L..R]). By greedy approach , we need to dig the case L=1, R=1 in the next step.\\n\\n```[case L=1, R=1]```\\nBecause a2[0..0] - a1[0..0] > 0, so there is positive contribution a2[L..R]-a1[L..R] = 20 here. \\nThe next step for us is to keep going to dig the case L=1, R=2 and try to find better positive \\ncontroibution.  Currently, the best positive contribution is 20 until now.\\n\\n```[case L=1, R=2]```\\na2[1..2] - a1[1..2] = -10 (<=0), so this is a negative contribution here. \\nBy greedy approach, we need to dig case L=3, R=3\\n\\n```[case L=3, R=3]```\\na2[3..3] - a1[3..3] = 30 (>0), so this is a positive contribution 30 here. \\nThe previous maximum positive contribution is 20. \\nCurrently, the maximum postive contribution is 30 until now.\\nBy greedy apporach ,we need to dig L=3, R=4 to see if there any better positive contriution. \\n\\n```[case L=3, R=4]```\\na2[3..4] - a1[3..4] = 40  (>0), so this is a positive contribtion 40 here.\\nThe previous maximum positive contribution is 30. \\nBut currently, the maximum positive contribution is 40 until now.\\nBy greedy approach, we need to dig L=5,R=5 but these will out of the bound, so let the algorithm \\nfinish here.\\n\\nThus, the maximum positive contribution is 40 here, we named the variable  as max_inc1 here.\\nso \\'max_inc1=40\\' and sum of a1 = 180. 40+180 will be the answer of this problem when answer is \\nhappened on `a1`\\n\\nWe use greedy approach to find maximum positvie contriobution max_inc1 for a1.\\nWe use greedy approach to find maximum positvie contriobution max_inc2 for a2.\\n\\nThe we figure out sum of a1 + max_inc1. And then figure out sum of a2 + max_inc2. \\nFor this two values ,we return the maximal one. And it would become the answer. \\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        return max(MaxValOfA1(nums1,nums2), MaxValOfA1(nums2,nums1));\\n    }\\n    \\n    int MaxValOfA1(vector<int>& a1, vector<int>& a2) {\\n        int n = a1.size();\\n        int sum = 0;\\n        for(auto &i:a1) sum+=i;\\n        int L=0, R=0, max_inc=0;\\n\\t\\t//max_inc is maximum positive contribution of a1\\n        int acc1 = 0, acc2 =0;\\n        while(L<n && R<n) {\\n            acc1 += a1[R];\\n            acc2 += a2[R];\\n            max_inc = max(max_inc, acc2-acc1);\\n            if(acc1>=acc2) {\\n                L=R+1;\\n                R=L;\\n                acc1=0;\\n                acc2=0;\\n            } else {\\n                R=R+1;\\n            }\\n        }\\n        return sum + max_inc;\\n    }\\n};\\n```\n```[case L=0, R=0]```\n```[case L=1, R=1]```\n```[case L=1, R=2]```\n```[case L=3, R=3]```\n```[case L=3, R=4]```",
                "codeTag": "Java"
            },
            {
                "id": 2200310,
                "title": "recursion-memo-tabulation-o-1-space-solution",
                "content": "Let\\'s think recursively, \\nfor any index i, we will either choose a[i] or b[i] along with a variable say, j, that will denote the operation\\ncase 1 : When j = 0, it denotes there is no operation done\\ncase 2: When j = 1, it denotes one jump has been done\\ncase 3: When j = 2, it denotes two jumps has been done and no further jumps are possible.\\n\\nLet\\'s have a look at the code below,\\n\\n\"\"\"\\n\\n\\n\\tclass Solution:\\n\\t\\tdef maximumsSplicedArray(self, a: List[int], b: List[int]) -> int:\\n\\n\\t\\t\\tdef rec(i, j, a, b):\\n\\n\\t\\t\\t\\tif i >= n:\\n\\t\\t\\t\\t\\treturn 0\\n\\n\\t\\t\\t\\tif dp[i][j] != -1:\\n\\t\\t\\t\\t\\treturn dp[i][j]\\n\\n\\t\\t\\t\\tif j == 2:\\n\\t\\t\\t\\t\\tdp[i][j] = a[i] + rec(i + 1, j, a, b)\\n\\n\\t\\t\\t\\telif j == 1:\\n\\t\\t\\t\\t\\tdp[i][j] = max(a[i] + rec(i + 1, j + 1, a, b), b[i] + rec(i + 1, j, a, b))\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tdp[i][j] = max(a[i] + rec(i + 1, j, a, b), b[i] + rec(i + 1, j + 1, a, b))\\n\\n\\t\\t\\t\\treturn dp[i][j]\\n\\n\\t\\t\\tn = len(a)\\n\\t\\t\\t\\n\\t\\t\\tdp = [[-1 for _ in range(3)] for _ in range(n)]\\n\\t\\t\\tstart_from_a = rec(0, 0, a, b)\\n\\t\\t\\t\\n\\t\\t\\tdp = [[-1 for _ in range(3)] for _ in range(n)]\\n\\t\\t\\tstart_from_b = rec(0, 0, b, a)\\n\\n\\t\\t\\treturn max(start_from_a, start_from_b)\\n\\n\"\"\"\\nTime complexity = O(3 * n)\\nSpace complexity = O(3 * n) + stack space\\n\\nLet\\'s reduce the stack space by writing tabulation, using the recurrence above\\nThe tabulation code goes as\\n\\n\"\"\"\\n\\n\\tclass Solution:\\n\\t\\tdef maximumsSplicedArray(self, a: List[int], b: List[int]) -> int:\\n\\n\\t\\t\\tn = len(a)\\n\\n\\t\\t\\tdef C(a, b):\\n\\t\\t\\t\\tdp = [[0 for _ in range(3)] for _ in range(n + 1)]\\n\\n\\t\\t\\t\\tfor i in range(1, n + 1):\\n\\n\\t\\t\\t\\t\\tdp[i][2] = a[i - 1] + dp[i - 1][2]\\n\\t\\t\\t\\t\\tdp[i][1] = max(a[i - 1] + dp[i - 1][2], b[i - 1] + dp[i - 1][1])\\n\\t\\t\\t\\t\\tdp[i][0] = max(a[i - 1] + dp[i - 1][0], b[i - 1] + dp[i - 1][1])\\n\\n\\t\\t\\t\\treturn max(dp[n])\\n\\n\\t\\t\\tstart_from_a = C(a, b)\\n\\t\\t\\tstart_from_b = C(b, a)\\n\\n\\t\\t\\treturn max(start_from_a, start_from_b)\\n        \\n\\n\"\"\"\\n\\nWe can further reduce the space usage as dp[i] is only dependent on dp[i - 1]\\nThe code with O(1) complexity goes as below,\\n\"\"\"\\n\\n\\n\\tclass Solution:\\n\\t\\tdef maximumsSplicedArray(self, a: List[int], b: List[int]) -> int:\\n\\n\\t\\t\\tn = len(a)\\n\\n\\t\\t\\tdef C(a, b):\\n\\n\\t\\t\\t\\tx, y, z = 0, 0, 0\\n\\n\\t\\t\\t\\tfor i in range(n):\\n\\n\\t\\t\\t\\t\\tx = max(a[i] + x, b[i] + y)\\n\\t\\t\\t\\t\\ty = max(a[i] + z, b[i] + y)\\n\\t\\t\\t\\t\\tz = a[i] + z\\n\\n\\t\\t\\t\\treturn max(x, y, z)\\n\\n\\t\\t\\treturn max(C(a, b), C(b, a))\\n\"\"\"\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "Let\\'s think recursively, \\nfor any index i, we will either choose a[i] or b[i] along with a variable say, j, that will denote the operation\\ncase 1 : When j = 0, it denotes there is no operation done\\ncase 2: When j = 1, it denotes one jump has been done\\ncase 3: When j = 2, it denotes two jumps has been done and no further jumps are possible.\\n\\nLet\\'s have a look at the code below,\\n\\n\"\"\"\\n\\n\\n\\tclass Solution:\\n\\t\\tdef maximumsSplicedArray(self, a: List[int], b: List[int]) -> int:\\n\\n\\t\\t\\tdef rec(i, j, a, b):\\n\\n\\t\\t\\t\\tif i >= n:\\n\\t\\t\\t\\t\\treturn 0\\n\\n\\t\\t\\t\\tif dp[i][j] != -1:\\n\\t\\t\\t\\t\\treturn dp[i][j]\\n\\n\\t\\t\\t\\tif j == 2:\\n\\t\\t\\t\\t\\tdp[i][j] = a[i] + rec(i + 1, j, a, b)\\n\\n\\t\\t\\t\\telif j == 1:\\n\\t\\t\\t\\t\\tdp[i][j] = max(a[i] + rec(i + 1, j + 1, a, b), b[i] + rec(i + 1, j, a, b))\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tdp[i][j] = max(a[i] + rec(i + 1, j, a, b), b[i] + rec(i + 1, j + 1, a, b))\\n\\n\\t\\t\\t\\treturn dp[i][j]\\n\\n\\t\\t\\tn = len(a)\\n\\t\\t\\t\\n\\t\\t\\tdp = [[-1 for _ in range(3)] for _ in range(n)]\\n\\t\\t\\tstart_from_a = rec(0, 0, a, b)\\n\\t\\t\\t\\n\\t\\t\\tdp = [[-1 for _ in range(3)] for _ in range(n)]\\n\\t\\t\\tstart_from_b = rec(0, 0, b, a)\\n\\n\\t\\t\\treturn max(start_from_a, start_from_b)\\n\\n\"\"\"\\nTime complexity = O(3 * n)\\nSpace complexity = O(3 * n) + stack space\\n\\nLet\\'s reduce the stack space by writing tabulation, using the recurrence above\\nThe tabulation code goes as\\n\\n\"\"\"\\n\\n\\tclass Solution:\\n\\t\\tdef maximumsSplicedArray(self, a: List[int], b: List[int]) -> int:\\n\\n\\t\\t\\tn = len(a)\\n\\n\\t\\t\\tdef C(a, b):\\n\\t\\t\\t\\tdp = [[0 for _ in range(3)] for _ in range(n + 1)]\\n\\n\\t\\t\\t\\tfor i in range(1, n + 1):\\n\\n\\t\\t\\t\\t\\tdp[i][2] = a[i - 1] + dp[i - 1][2]\\n\\t\\t\\t\\t\\tdp[i][1] = max(a[i - 1] + dp[i - 1][2], b[i - 1] + dp[i - 1][1])\\n\\t\\t\\t\\t\\tdp[i][0] = max(a[i - 1] + dp[i - 1][0], b[i - 1] + dp[i - 1][1])\\n\\n\\t\\t\\t\\treturn max(dp[n])\\n\\n\\t\\t\\tstart_from_a = C(a, b)\\n\\t\\t\\tstart_from_b = C(b, a)\\n\\n\\t\\t\\treturn max(start_from_a, start_from_b)\\n        \\n\\n\"\"\"\\n\\nWe can further reduce the space usage as dp[i] is only dependent on dp[i - 1]\\nThe code with O(1) complexity goes as below,\\n\"\"\"\\n\\n\\n\\tclass Solution:\\n\\t\\tdef maximumsSplicedArray(self, a: List[int], b: List[int]) -> int:\\n\\n\\t\\t\\tn = len(a)\\n\\n\\t\\t\\tdef C(a, b):\\n\\n\\t\\t\\t\\tx, y, z = 0, 0, 0\\n\\n\\t\\t\\t\\tfor i in range(n):\\n\\n\\t\\t\\t\\t\\tx = max(a[i] + x, b[i] + y)\\n\\t\\t\\t\\t\\ty = max(a[i] + z, b[i] + y)\\n\\t\\t\\t\\t\\tz = a[i] + z\\n\\n\\t\\t\\t\\treturn max(x, y, z)\\n\\n\\t\\t\\treturn max(C(a, b), C(b, a))\\n\"\"\"\\n",
                "codeTag": "Java"
            },
            {
                "id": 2210425,
                "title": "dp-c-o-n",
                "content": "```\\nint solve(vector<int>& a, vector<int>& b, vector<vector<vector<int>>>& dp, int n, int i, bool st, bool end) {\\n\\tif (i == n)\\n\\t\\treturn 0;\\n\\tif (~dp[i][st][end])\\n\\t\\treturn dp[i][st][end];\\n\\tint best;\\n\\tif (st && end)\\n\\t\\tbest = a[i] + solve(a, b, dp, n, i + 1, st, end);\\n\\telse if (st) // st && !end\\n\\t\\tbest = max(b[i] + solve(a, b, dp, n, i + 1, st, end), a[i] + solve(a, b, dp, n, i + 1, st, true));\\n\\telse  // !st\\n\\t\\tbest = max(a[i] + solve(a, b, dp, n, i + 1, st, end), b[i] + solve(a, b, dp, n, i + 1, true, end));\\n\\treturn dp[i][st][end] = best;\\n}\\n\\nint maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n\\tint n = nums1.size();\\n\\tvector<vector<vector<int>>> dp(n, vector<vector<int>> (2, vector<int> (2, -1)));\\n\\tint op1 = solve(nums1, nums2, dp, n, 0, false, false);\\n\\tdp = vector<vector<vector<int>>> (n, vector<vector<int>> (2, vector<int> (2, -1)));\\n\\tint op2 = solve(nums2, nums1, dp, n, 0, false, false);\\n\\treturn max(op1, op2);\\n}\\n```\\nTime Complexity : **O(N)**\\nSpace Complexity: **O(N)**\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nint solve(vector<int>& a, vector<int>& b, vector<vector<vector<int>>>& dp, int n, int i, bool st, bool end) {\\n\\tif (i == n)\\n\\t\\treturn 0;\\n\\tif (~dp[i][st][end])\\n\\t\\treturn dp[i][st][end];\\n\\tint best;\\n\\tif (st && end)\\n\\t\\tbest = a[i] + solve(a, b, dp, n, i + 1, st, end);\\n\\telse if (st) // st && !end\\n\\t\\tbest = max(b[i] + solve(a, b, dp, n, i + 1, st, end), a[i] + solve(a, b, dp, n, i + 1, st, true));\\n\\telse  // !st\\n\\t\\tbest = max(a[i] + solve(a, b, dp, n, i + 1, st, end), b[i] + solve(a, b, dp, n, i + 1, true, end));\\n\\treturn dp[i][st][end] = best;\\n}\\n\\nint maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n\\tint n = nums1.size();\\n\\tvector<vector<vector<int>>> dp(n, vector<vector<int>> (2, vector<int> (2, -1)));\\n\\tint op1 = solve(nums1, nums2, dp, n, 0, false, false);\\n\\tdp = vector<vector<vector<int>>> (n, vector<vector<int>> (2, vector<int> (2, -1)));\\n\\tint op2 = solve(nums2, nums1, dp, n, 0, false, false);\\n\\treturn max(op1, op2);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2198859,
                "title": "try-both-the-way-and-return-the-max-simple-tricky-2-lines",
                "content": "Here\\'s the simple approach :\\n\\n```\\nclass Solution:\\n    def maximumsSplicedArray(self, A: List[int], B: List[int]) -> int:\\n        \\n        def kadane(A, B):\\n            sm = res = 0\\n            for r in range(len(A)):\\n                sm += B[r] - A[r]\\n                if sm < 0 : sm = 0\\n                res = max(sm, res)\\n            return sum(A) + res\\n        \\n        x = kadane(A, B)\\n        y = kadane(B, A)\\n        return max(x, y)\\n```\\n\\nFound out that if we swap A and B we get different scores which one should be consider?\\nso the tricky part is to try both the way and return the max.\\n```\\n        x = kadane(A, B)\\n        y = kadane(B, A)\\n        return max(x, y)\\n```\\n\\n* please upvote if it helps you",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumsSplicedArray(self, A: List[int], B: List[int]) -> int:\\n        \\n        def kadane(A, B):\\n            sm = res = 0\\n            for r in range(len(A)):\\n                sm += B[r] - A[r]\\n                if sm < 0 : sm = 0\\n                res = max(sm, res)\\n            return sum(A) + res\\n        \\n        x = kadane(A, B)\\n        y = kadane(B, A)\\n        return max(x, y)\\n```\n```\\n        x = kadane(A, B)\\n        y = kadane(B, A)\\n        return max(x, y)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198306,
                "title": "c-sliding-window",
                "content": "```\\nclass Solution {\\nprivate:\\n    #define ll long long\\n    ll solve(vector<int>& a, vector<int>& b)\\n    {\\n        int n=a.size();\\n        ll asum=0,bsum=0;\\n        \\n        for(auto i:a)\\n            asum+=i;     //sum of array1\\n        for(auto i:a)\\n            bsum+=i;     //sum of array2\\n        \\n        ll res=max(asum,bsum);\\n        \\n        ll start=0,end=0;\\n        ll sum1=0,sum2=0;\\n        \\n        //First check for array 1 which window to be replaced would me most beneficial\\n        while(end<n)\\n        {\\n            sum1+=a[end];\\n            sum2+=b[end];\\n\\t\\t\\t//when our current window sum1 of array1 is already greater than sum2 of same window of array 2 trace begin i.e start pointer\\n            while(start<=end && sum1>=sum2)     \\n            {\\n                sum1-=a[start];\\n                sum2-=b[start];\\n                ++start;\\n            }\\n            res=max(res,asum-sum1+sum2);\\n            ++end;\\n        }\\n        return res;\\n    }\\npublic:\\n    int maximumsSplicedArray(vector<int>& a, vector<int>& b) {\\n        return max(solve(a,b),solve(b,a));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    #define ll long long\\n    ll solve(vector<int>& a, vector<int>& b)\\n    {\\n        int n=a.size();\\n        ll asum=0,bsum=0;\\n        \\n        for(auto i:a)\\n            asum+=i;     //sum of array1\\n        for(auto i:a)\\n            bsum+=i;     //sum of array2\\n        \\n        ll res=max(asum,bsum);\\n        \\n        ll start=0,end=0;\\n        ll sum1=0,sum2=0;\\n        \\n        //First check for array 1 which window to be replaced would me most beneficial\\n        while(end<n)\\n        {\\n            sum1+=a[end];\\n            sum2+=b[end];\\n\\t\\t\\t//when our current window sum1 of array1 is already greater than sum2 of same window of array 2 trace begin i.e start pointer\\n            while(start<=end && sum1>=sum2)     \\n            {\\n                sum1-=a[start];\\n                sum2-=b[start];\\n                ++start;\\n            }\\n            res=max(res,asum-sum1+sum2);\\n            ++end;\\n        }\\n        return res;\\n    }\\npublic:\\n    int maximumsSplicedArray(vector<int>& a, vector<int>& b) {\\n        return max(solve(a,b),solve(b,a));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198267,
                "title": "compute-twice-kadane-algo-c",
                "content": "First find the maximum sum you can make if you swap a subarray from nums1 to nums2 , then find the max for swapping nums2 to nums1. Return the maximum of the two sums\\n\\n**Time Complexity : O(n)\\nSpace Complexity :O(1)**\\n ```\\nint n = nums1.size();\\n        int sum1 =0,sum2=0;\\n        for(int i = 0;i<n ; i++){\\n            sum1+= nums1[i];\\n            sum2+= nums2[i];\\n        }\\n        int maxi = 0;\\n        int cur = 0;\\n        for(int i =0;i<n;i++){\\n            \\n            if(l == -1)l = i;\\n            \\n            cur+= (nums1[i]-nums2[i]);\\n            maxi = max(cur,maxi);\\n            if(cur <= 0){\\n                cur = 0; \\n            }  \\n        }\\n  \\n        int x = sum2 + maxi;\\n        \\n         maxi = 0;\\n         cur = 0;\\n        for(int i =0;i<n;i++){\\n            \\n            if(l == -1)l = i;  \\n            cur+= (nums2[i]-nums1[i]);\\n            maxi = max(cur,maxi);\\n            if(cur <= 0){\\n                cur = 0; \\n            }        \\n        }\\n    \\n       int y = sum1+maxi;  \\n        return max(x,y);\\n```",
                "solutionTags": [],
                "code": "```\\nint n = nums1.size();\\n        int sum1 =0,sum2=0;\\n        for(int i = 0;i<n ; i++){\\n            sum1+= nums1[i];\\n            sum2+= nums2[i];\\n        }\\n        int maxi = 0;\\n        int cur = 0;\\n        for(int i =0;i<n;i++){\\n            \\n            if(l == -1)l = i;\\n            \\n            cur+= (nums1[i]-nums2[i]);\\n            maxi = max(cur,maxi);\\n            if(cur <= 0){\\n                cur = 0; \\n            }  \\n        }\\n  \\n        int x = sum2 + maxi;\\n        \\n         maxi = 0;\\n         cur = 0;\\n        for(int i =0;i<n;i++){\\n            \\n            if(l == -1)l = i;  \\n            cur+= (nums2[i]-nums1[i]);\\n            maxi = max(cur,maxi);\\n            if(cur <= 0){\\n                cur = 0; \\n            }        \\n        }\\n    \\n       int y = sum1+maxi;  \\n        return max(x,y);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2198155,
                "title": "c-easy-approach-subarray-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int s1 = accumulate(nums1.begin(), nums1.end(), 0),s2 = accumulate(nums2.begin(), nums2.end(), 0);\\n        int n = nums1.size(),maxi = 0,maxi1 = 0;\\n        \\n       \\n        int sum1 = 0,sum2 = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            sum1 += (nums2[i]-nums1[i]);\\n            if(sum1 < 0)sum1 = 0;\\n             maxi = max(maxi,sum1);\\n            \\n            sum2 += (nums1[i]-nums2[i]);\\n            if(sum2 < 0)sum2 = 0;\\n            maxi1 = max(maxi1,sum2);\\n        }\\n        \\n        return max(s1 + maxi , s2 + maxi1);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int s1 = accumulate(nums1.begin(), nums1.end(), 0),s2 = accumulate(nums2.begin(), nums2.end(), 0);\\n        int n = nums1.size(),maxi = 0,maxi1 = 0;\\n        \\n       \\n        int sum1 = 0,sum2 = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            sum1 += (nums2[i]-nums1[i]);\\n            if(sum1 < 0)sum1 = 0;\\n             maxi = max(maxi,sum1);\\n            \\n            sum2 += (nums1[i]-nums2[i]);\\n            if(sum2 < 0)sum2 = 0;\\n            maxi1 = max(maxi1,sum2);\\n        }\\n        \\n        return max(s1 + maxi , s2 + maxi1);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613317,
                "title": "c-kadane-algo",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> v1,v2;\\n        int sum1=0,sum2 = 0,ans1,ans2;\\n        for(int i = 00; i < nums1.size(); i++){\\n            sum1 += nums1[i];\\n            sum2 += nums2[i];\\n            v1.push_back(-nums1[i]+nums2[i]);\\n            v2.push_back(nums1[i]-nums2[i]);\\n        }\\n        int k = 0;\\n        ans1 = sum1;\\n        for(auto &i: v1){\\n            k += i;\\n            if(k<0)k=  0;\\n            ans1 = max(k+sum1,ans1);\\n        }\\n        k = 0;\\n        ans2 = sum2;    \\n        for(auto &i: v2){\\n            k += i;\\n            if(k<0)k=  0;\\n            ans2 = max(k+sum2,ans2);\\n        }\\n        return max(ans1,ans2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> v1,v2;\\n        int sum1=0,sum2 = 0,ans1,ans2;\\n        for(int i = 00; i < nums1.size(); i++){\\n            sum1 += nums1[i];\\n            sum2 += nums2[i];\\n            v1.push_back(-nums1[i]+nums2[i]);\\n            v2.push_back(nums1[i]-nums2[i]);\\n        }\\n        int k = 0;\\n        ans1 = sum1;\\n        for(auto &i: v1){\\n            k += i;\\n            if(k<0)k=  0;\\n            ans1 = max(k+sum1,ans1);\\n        }\\n        k = 0;\\n        ans2 = sum2;    \\n        for(auto &i: v2){\\n            k += i;\\n            if(k<0)k=  0;\\n            ans2 = max(k+sum2,ans2);\\n        }\\n        return max(ans1,ans2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319881,
                "title": "time-o-n-space-o-n-double-kadane-algorithm",
                "content": "````\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int i,n= nums1.size();\\n        int sum1 = 0, sum2 = 0;\\n        vector<int> v;\\n        for(i = 0; i < n; i++){\\n            sum1 += nums1[i];\\n            sum2 += nums2[i];\\n            v.push_back(nums1[i]-nums2[i]);\\n        }\\n        int ns=0,ps=0,mx=INT_MIN,mn=INT_MAX;\\n        for(i = 0; i < n; i++){\\n            ns += v[i];\\n            if(ns>0)ns = 0;\\n            if(ns<mn)mn = ns;\\n            \\n            ps += v[i];\\n            if(ps<0)ps = 0;\\n            if(ps>mx)mx = ps;\\n        }\\n        return max({sum1,sum2,sum1-mn,sum2+mx});\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int i,n= nums1.size();\\n        int sum1 = 0, sum2 = 0;\\n        vector<int> v;\\n        for(i = 0; i < n; i++){\\n            sum1 += nums1[i];\\n            sum2 += nums2[i];\\n            v.push_back(nums1[i]-nums2[i]);\\n        }\\n        int ns=0,ps=0,mx=INT_MIN,mn=INT_MAX;\\n        for(i = 0; i < n; i++){\\n            ns += v[i];\\n            if(ns>0)ns = 0;\\n            if(ns<mn)mn = ns;\\n            \\n            ps += v[i];\\n            if(ps<0)ps = 0;\\n            if(ps>mx)mx = ps;\\n        }\\n        return max({sum1,sum2,sum1-mn,sum2+mx});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2199509,
                "title": "2321-c-kadane-algorithm-easy-and-clean-solution",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int len=nums1.size();\\n        int maxi=0,cur=0;\\n        int sum1=0,sum2=0;\\n        for(auto i:nums1) sum1+=i;\\n        for(auto i:nums2) sum2+=i;\\n        int ans=max(sum1,sum2);\\n        \\n        for(int i=0;i<len;i++){\\n            cur+=nums2[i]-nums1[i];\\n            maxi=max(maxi,cur);\\n            if(cur<0)cur=0;\\n        }\\n        ans=max(ans,sum1+maxi);\\n        maxi=0;\\n        cur=0;\\n         for(int i=0;i<len;i++){\\n            cur+=nums1[i]-nums2[i];\\n            maxi=max(maxi,cur);\\n            if(cur<0)cur=0;\\n        }\\n        ans=max(ans,sum2+maxi);\\n        return ans;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int len=nums1.size();\\n        int maxi=0,cur=0;\\n        int sum1=0,sum2=0;\\n        for(auto i:nums1) sum1+=i;\\n        for(auto i:nums2) sum2+=i;\\n        int ans=max(sum1,sum2);\\n        \\n        for(int i=0;i<len;i++){\\n            cur+=nums2[i]-nums1[i];\\n            maxi=max(maxi,cur);\\n            if(cur<0)cur=0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3483508,
                "title": "o-n-c-solution-using-kadane-algorithm",
                "content": "# Intuition\\nHere intution comes to our mind is that maximum sum subarray sum and that can be achieved by **kadane algorithm**.\\n\\n# Approach\\nHere in we have to apply kadane on the difference array /vector created to find the maximum sum a subarray can generated .and then we add that maximum sum subarray with the with the sum generated with the original arrays\\n\\ns1= accumulate(all(v1),0);\\ns2= accumulate(all(v2),0);\\n\\nand v11, v12 are difference array created \\nwhere res is maximum sum subarray of v11.\\nand res1 is maximum sum subarray of v12.\\nwhere we have found that using kadane algo.\\n\\nSo, answer will be max(res+s1, res1+s2).\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n#define ll long long\\n    #define pb push_back\\n    #define pf push_front\\n    #define l \"\\\\n\"\\n    #define all(v) v.begin(),v.end()\\n    #define rall(v) v.rbegin(),v.rend()\\n    #define fn(i,a,b) for (int i = a; i < b; i++)\\n    #define fd(i,b,a) for(int i=b;i>=a;i--)\\n    #define yes cout<<\"YES\"<<l\\n    #define no  cout<<\"NO\"<<l\\n    #define fast ios_base::sync_with_stdio(0);cin.tie(0)\\n    vector<ll> sieve(int n) {int*arr = new int[n + 1](); vector<ll> vect; for (int i = 2; i <= n; i++)if (arr[i] == 0) {vect.push_back(i); for (int j = 2 * i; j <= n; j += i)arr[j] = 1;} return vect;}\\n    const ll mod= 1e9+9;\\n    const ll N= 1<<18;\\n\\n    int kdn(vector<int> &v,int n){\\n        int med= v[0],res=v[0];\\n        for(int i=1;i<n;i++){\\n            med= max(med+v[i],v[i]);\\n            res= max(res,med);\\n        }\\n        return res;\\n    }\\n    int maximumsSplicedArray(vector<int>& v1, vector<int>& v2) {\\n        ll n= v1.size();\\n         ll s1=0,s2=0;\\n      fn(i,0,n) s1+=v1[i];\\n      fn(i,0,n) s2+=v2[i];\\n      vector<ll> v11(n),v12(n);\\n      // Creating difference array\\n      fn(i,0,n){\\n        v11[i]= (v1[i]-v2[i])*(-1);\\n        v12[i]= (v2[i]-v1[i])*(-1);\\n      }\\n      ll p1= accumulate(all(v11),0);\\n      ll p2= accumulate(all(v12),0);\\n      // Applied Kadane on 1st created differnce vector\\n        ll res=v11[0],med=v11[0];\\n        fn(i,1,n){\\n            med= max(med+v11[i],v11[i]);\\n            res= max(res,med);\\n        }\\n        // Condition Applied to check wether longest subarray sum is negative  or else equal to diff array sum\\n        if(p1==res|| res<0) res=0;\\n       // Applied Kadane on 2nd created differnce vector\\n        ll res1= v12[0],med1= v12[0];\\n        fn(i,1,n){\\n            med1= max(med1+v12[i],v12[i]);\\n            res1= max(res1,med1);\\n        }\\n        // Condition Applied to check wether longest subarray sum is negative  or else equal to diff array sum\\n        if(p2==res1|| res1<0) res1=0;\\n\\n        return max(s1+res,s2+res1);\\n    }\\n};\\n//If found helpful Kindly Upvote\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n#define ll long long\\n    #define pb push_back\\n    #define pf push_front\\n    #define l \"\\\\n\"\\n    #define all(v) v.begin(),v.end()\\n    #define rall(v) v.rbegin(),v.rend()\\n    #define fn(i,a,b) for (int i = a; i < b; i++)\\n    #define fd(i,b,a) for(int i=b;i>=a;i--)\\n    #define yes cout<<\"YES\"<<l\\n    #define no  cout<<\"NO\"<<l\\n    #define fast ios_base::sync_with_stdio(0);cin.tie(0)\\n    vector<ll> sieve(int n) {int*arr = new int[n + 1](); vector<ll> vect; for (int i = 2; i <= n; i++)if (arr[i] == 0) {vect.push_back(i); for (int j = 2 * i; j <= n; j += i)arr[j] = 1;}",
                "codeTag": "C++"
            },
            {
                "id": 2238633,
                "title": "convert-to-max-subarray-problem-faster-than-87",
                "content": "According to the description of this problem, we need to find the max value of \\n```_sum1 + sum(num2[l:r])-sum(num1[l:r])```\\nor the max value of \\n```_sum2 + sum(num1[l:r]-sum(num2[l:r])),  0<=l<=r<=len(nums1)```\\n\\nWhich means repalcing the part of ```nums1[l:r]``` with ```nums2[l:r]``` and gets the sum value, or repalcing the part of ```nums2[l:r]``` with ```nums1[l:r]```. Please notice that ```l==r``` which means no replacement is allowed.\\n\\nConsidering\\\\_sum1 and \\\\_sum2 is fixed: ```sum(nums1), sum(nums2)```\\n\\nWe need to find the max value of ```sum(num2[l:r])-sum(num1[l:r])``` or ```sum(num1[l:r]-num2[l:r])```\\nif we define num3, ```num3[i] = num2[i]-num1[i], 0<=i<n```\\nand num4, ```num4[i] = num1[i]-num2[i], 0<=i<n```\\nwhat we need to find is the max subarray of num3, num4, which is an old question\\nhttps://en.wikipedia.org/wiki/Maximum_subarray_problem \\n\\nHere is how we implements the above description.\\n```\\nclass Solution:\\n    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n        n = len(nums1)\\n\\t\\tnums3 = [0]*n\\n\\t\\tnums4 = [0]*n\\n\\t\\tfor i in range(n):\\n\\t\\t\\tnums3[i] = nums1[i]-nums2[i]\\n\\t\\t\\tnums4[i] = nums2[i]-nums1[i]\\n\\t\\tmaxsubseq1 = maxsubseq2 = 0\\n\\t\\tv1 = v2 = 0 \\n\\t\\t# use kadane algorithm to solve this max subseq problem\\n\\t\\tfor i in range(n):\\n\\t\\t\\tmaxsubseq1 = max(maxsubseq1 + nums3[i], nums3[i])\\n\\t\\t\\tmaxsubseq2 = max(maxsubseq2 + nums4[i], nums4[i])\\n\\t\\t\\tv1 = max(v1, maxsubseq1)\\n\\t\\t\\tv2 = max(v2, maxsubseq2)\\n\\t\\t_sum1 = sum(nums1)\\n\\t\\t_sum2 = sum(nums2)\\n\\t\\treturn max(_sum1 + v2, _sum2 + v1)\\n```\\n\\nObviously, we can simplify it to one iteration to get better performance.\\n```\\nclass Solution:\\n    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n# simplify the whole process\\n        v1 = v2 = 0\\n        n = len(nums1)\\n        _sum1 = sum(nums1)\\n        _sum2 = sum(nums2)\\n        res = _sum1\\n        for i in range(n):\\n            v1 = max(v1 + nums1[i] - nums2[i], nums1[i] - nums2[i])\\n            v2 = max(v2 + nums2[i] - nums1[i], nums2[i] - nums1[i])\\n            res = max(_sum1 + v2, _sum2 + v1, res)\\n        return res\\n```\\nIf you like it, please upvote me.",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```_sum1 + sum(num2[l:r])-sum(num1[l:r])```\n```_sum2 + sum(num1[l:r]-sum(num2[l:r])),  0<=l<=r<=len(nums1)```\n```nums1[l:r]```\n```nums2[l:r]```\n```nums2[l:r]```\n```nums1[l:r]```\n```l==r```\n```sum(nums1), sum(nums2)```\n```sum(num2[l:r])-sum(num1[l:r])```\n```sum(num1[l:r]-num2[l:r])```\n```num3[i] = num2[i]-num1[i], 0<=i<n```\n```num4[i] = num1[i]-num2[i], 0<=i<n```\n```\\nclass Solution:\\n    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n        n = len(nums1)\\n\\t\\tnums3 = [0]*n\\n\\t\\tnums4 = [0]*n\\n\\t\\tfor i in range(n):\\n\\t\\t\\tnums3[i] = nums1[i]-nums2[i]\\n\\t\\t\\tnums4[i] = nums2[i]-nums1[i]\\n\\t\\tmaxsubseq1 = maxsubseq2 = 0\\n\\t\\tv1 = v2 = 0 \\n\\t\\t# use kadane algorithm to solve this max subseq problem\\n\\t\\tfor i in range(n):\\n\\t\\t\\tmaxsubseq1 = max(maxsubseq1 + nums3[i], nums3[i])\\n\\t\\t\\tmaxsubseq2 = max(maxsubseq2 + nums4[i], nums4[i])\\n\\t\\t\\tv1 = max(v1, maxsubseq1)\\n\\t\\t\\tv2 = max(v2, maxsubseq2)\\n\\t\\t_sum1 = sum(nums1)\\n\\t\\t_sum2 = sum(nums2)\\n\\t\\treturn max(_sum1 + v2, _sum2 + v1)\\n```\n```\\nclass Solution:\\n    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n# simplify the whole process\\n        v1 = v2 = 0\\n        n = len(nums1)\\n        _sum1 = sum(nums1)\\n        _sum2 = sum(nums2)\\n        res = _sum1\\n        for i in range(n):\\n            v1 = max(v1 + nums1[i] - nums2[i], nums1[i] - nums2[i])\\n            v2 = max(v2 + nums2[i] - nums1[i], nums2[i] - nums1[i])\\n            res = max(_sum1 + v2, _sum2 + v1, res)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2199313,
                "title": "easy-c-kadane-algorithm-well-explained",
                "content": "```\\n\\n// We are given two arrays. We need to return the maximized sum.\\n\\n// To maximize the sum of array, we can swap contigous subarrays to maximize the sum of one array. ie. final_max_sum = original_array_sum + extra_benefit.\\n\\n// Now extra_benefit can be calculated as -->\\n// we would make an vector and there we need to store bi - ai. And now when we have got a vector which contains our extra_benefit as answer, \\n// we apply kadane algo to the vector to find largest sum contigous subarray. So, extra_benefit = maximum sum contigous subarray. \\n// And now we can return final_max_sum = original_array_sum + extra_benefit.\\n\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        \\n    // <--------- Calculating sum of elements ------->\\n        long long sum1 = accumulate(nums1.begin(), nums1.end(), 0);\\n        long long sum2 = accumulate(nums2.begin(), nums2.end(), 0);\\n        \\n        vector<int> v(nums1.size(),0);\\n        vector<int> v1(nums1.size(),0);\\n        \\n    // <------------ Making difference/ extra_benefits vector --------->\\n        for(int i = 0; i < nums1.size(); i++){\\n            v[i] = nums2[i] - nums1[i];\\n        }\\n        for(int i = 0; i < nums2.size(); i++){\\n            v1[i] = nums1[i] - nums2[i];\\n        }\\n        \\n    // <---------- Applying kadane\\'s algo on both vectors to find maximum sum contigous subarray -------> \\n        int ans = 0, temp = 0;\\n        for(int i = 0; i < v.size(); i++){\\n            temp = max(v[i], temp+v[i]);\\n            ans = max(temp, ans);\\n        }\\n        temp = 0;\\n        int ans1 = 0;\\n        for(int i = 0; i < v.size(); i++){\\n            temp = max(v1[i], temp+v1[i]);\\n            ans1 = max(temp, ans1);\\n        }\\n        \\n        return max(sum1 + ans, sum2 + ans1);// return max(sum(A)+extra_benefits(A), sum(B)+extra_benefits(B) )\\n    }\\n};\\n```\\n\\n**Like it, if you do like the approach of solution and documentation, it do motivates!!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n// We are given two arrays. We need to return the maximized sum.\\n\\n// To maximize the sum of array, we can swap contigous subarrays to maximize the sum of one array. ie. final_max_sum = original_array_sum + extra_benefit.\\n\\n// Now extra_benefit can be calculated as -->\\n// we would make an vector and there we need to store bi - ai. And now when we have got a vector which contains our extra_benefit as answer, \\n// we apply kadane algo to the vector to find largest sum contigous subarray. So, extra_benefit = maximum sum contigous subarray. \\n// And now we can return final_max_sum = original_array_sum + extra_benefit.\\n\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        \\n    // <--------- Calculating sum of elements ------->\\n        long long sum1 = accumulate(nums1.begin(), nums1.end(), 0);\\n        long long sum2 = accumulate(nums2.begin(), nums2.end(), 0);\\n        \\n        vector<int> v(nums1.size(),0);\\n        vector<int> v1(nums1.size(),0);\\n        \\n    // <------------ Making difference/ extra_benefits vector --------->\\n        for(int i = 0; i < nums1.size(); i++){\\n            v[i] = nums2[i] - nums1[i];\\n        }\\n        for(int i = 0; i < nums2.size(); i++){\\n            v1[i] = nums1[i] - nums2[i];\\n        }\\n        \\n    // <---------- Applying kadane\\'s algo on both vectors to find maximum sum contigous subarray -------> \\n        int ans = 0, temp = 0;\\n        for(int i = 0; i < v.size(); i++){\\n            temp = max(v[i], temp+v[i]);\\n            ans = max(temp, ans);\\n        }\\n        temp = 0;\\n        int ans1 = 0;\\n        for(int i = 0; i < v.size(); i++){\\n            temp = max(v1[i], temp+v1[i]);\\n            ans1 = max(temp, ans1);\\n        }\\n        \\n        return max(sum1 + ans, sum2 + ans1);// return max(sum(A)+extra_benefits(A), sum(B)+extra_benefits(B) )\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2199242,
                "title": "using-kadane-algorithm-no-dp",
                "content": "```\\nPreRequisite : Kadane\\'s Algorithm\\n```\\n```\\nclass Solution {\\npublic:\\n// Kadane\\'s Algorithm\\n    int maxSubArraySum(vector<int>& a, int size)\\n    {\\n        int max_so_far = INT_MIN, max_ending_here = 0;\\n\\n        for (int i = 0; i < size; i++)\\n        {\\n            max_ending_here = max_ending_here + a[i];\\n            if (max_so_far < max_ending_here)\\n                max_so_far = max_ending_here;\\n\\n            if (max_ending_here < 0)\\n                max_ending_here = 0;\\n        }\\n        return max_so_far;\\n    }\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        int ans1= 0 , ans2 = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans1+=nums1[i];\\n            ans2+=nums2[i];\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n\\t\\t// Creating Difference vectors\\n            int p = nums2[i] - nums1[i];\\n            int q = nums1[i] - nums2[i];\\n            nums2[i] = p;\\n            nums1[i] = q;\\n        }\\n\\t\\t// Finding Maximum Subarray Sum in Difference Vectors\\n        int val1 = maxSubArraySum(nums2 , n);\\n        int val2 = maxSubArraySum(nums1 , n);\\n        if(val1 > 0)\\n            ans1+=val1;\\n        if(val2>0)\\n            ans2+=val2;\\n        return max(ans1 , ans2);\\n    }\\n};\\n```\\n```\\nTime Complexity : O(N)\\nSpace Complexity : O(1)\\n```\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nPreRequisite : Kadane\\'s Algorithm\\n```\n```\\nclass Solution {\\npublic:\\n// Kadane\\'s Algorithm\\n    int maxSubArraySum(vector<int>& a, int size)\\n    {\\n        int max_so_far = INT_MIN, max_ending_here = 0;\\n\\n        for (int i = 0; i < size; i++)\\n        {\\n            max_ending_here = max_ending_here + a[i];\\n            if (max_so_far < max_ending_here)\\n                max_so_far = max_ending_here;\\n\\n            if (max_ending_here < 0)\\n                max_ending_here = 0;\\n        }\\n        return max_so_far;\\n    }\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        int ans1= 0 , ans2 = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans1+=nums1[i];\\n            ans2+=nums2[i];\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n\\t\\t// Creating Difference vectors\\n            int p = nums2[i] - nums1[i];\\n            int q = nums1[i] - nums2[i];\\n            nums2[i] = p;\\n            nums1[i] = q;\\n        }\\n\\t\\t// Finding Maximum Subarray Sum in Difference Vectors\\n        int val1 = maxSubArraySum(nums2 , n);\\n        int val2 = maxSubArraySum(nums1 , n);\\n        if(val1 > 0)\\n            ans1+=val1;\\n        if(val2>0)\\n            ans2+=val2;\\n        return max(ans1 , ans2);\\n    }\\n};\\n```\n```\\nTime Complexity : O(N)\\nSpace Complexity : O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198273,
                "title": "recursive-solution-memoized-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[100001][3];\\n    int helper(vector<int> &v1, vector<int> &v2, int idx, int Swaps){\\n        if(idx == v1.size())    return 0;\\n        if(dp[idx][Swaps] != -1)    return dp[idx][Swaps];\\n        if(Swaps == 2){\\n            return dp[idx][Swaps] = max(v1[idx] + helper(v1, v2, idx + 1, Swaps), v2[idx] + helper(v2, v1, idx + 1, Swaps - 1));\\n        }else if(Swaps == 1){\\n            return dp[idx][Swaps] = max(v1[idx] + helper(v1, v2, idx + 1, Swaps), v2[idx] + helper(v2, v1, idx + 1, Swaps - 1));\\n        }else{\\n            return dp[idx][Swaps] = v1[idx] + helper(v1, v2, idx + 1, Swaps);\\n        }\\n    }\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        memset(dp, -1, sizeof(dp));\\n        int ans = helper(nums1, nums2, 0, 2);\\n        memset(dp, -1, sizeof(dp));\\n        return max(ans, helper(nums2, nums1, 0, 2));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[100001][3];\\n    int helper(vector<int> &v1, vector<int> &v2, int idx, int Swaps){\\n        if(idx == v1.size())    return 0;\\n        if(dp[idx][Swaps] != -1)    return dp[idx][Swaps];\\n        if(Swaps == 2){\\n            return dp[idx][Swaps] = max(v1[idx] + helper(v1, v2, idx + 1, Swaps), v2[idx] + helper(v2, v1, idx + 1, Swaps - 1));\\n        }else if(Swaps == 1){\\n            return dp[idx][Swaps] = max(v1[idx] + helper(v1, v2, idx + 1, Swaps), v2[idx] + helper(v2, v1, idx + 1, Swaps - 1));\\n        }else{\\n            return dp[idx][Swaps] = v1[idx] + helper(v1, v2, idx + 1, Swaps);\\n        }\\n    }\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        memset(dp, -1, sizeof(dp));\\n        int ans = helper(nums1, nums2, 0, 2);\\n        memset(dp, -1, sizeof(dp));\\n        return max(ans, helper(nums2, nums1, 0, 2));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198195,
                "title": "python-easy-to-understand-with-explanation-no-kadane",
                "content": "```\\nclass Solution:\\n    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n        # create a difference array between nums1 and nums2\\n        # idea: find two subarray(elements are contiguous) in the diff\\n        # one is the subarray that have the minimum negative sum\\n        # another one is the subarray that have the maximum positive sum\\n        # so there are four candidates for maximum score:\\n        # 1. original_sum1 \\n        # 2. original_sum \\n        # 3. original_sum1 - min_negative_sum\\n        # 4. original_sum2 + max_positive_sum\\n        \\n        original_sum1 = sum(nums1)\\n        original_sum2 = sum(nums2)\\n        diff = [num1 - num2 for num1, num2 in zip(nums1, nums2)]\\n        min_negative_sum = float(\\'inf\\')\\n        max_positive_sum = - float(\\'inf\\')\\n        cur_negative_sum = 0\\n        cur_positive_sum = 0\\n        \\n        for val in diff:\\n            cur_negative_sum += val\\n\\n            if cur_negative_sum > 0:\\n                cur_negative_sum = 0\\n            \\n            cur_positive_sum += val\\n            \\n            if cur_positive_sum < 0:\\n                cur_positive_sum = 0\\n                    \\n            min_negative_sum = min(min_negative_sum, cur_negative_sum)\\n            max_positive_sum = max(max_positive_sum, cur_positive_sum)\\n\\n        return max(original_sum1 - min_negative_sum, original_sum2 + max_positive_sum, original_sum2, original_sum1)\\n```\\n\\n**Feel free to ask if you have questions :)\\nPlease upvote if you find it helpful, many thanks!**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n        # create a difference array between nums1 and nums2\\n        # idea: find two subarray(elements are contiguous) in the diff\\n        # one is the subarray that have the minimum negative sum\\n        # another one is the subarray that have the maximum positive sum\\n        # so there are four candidates for maximum score:\\n        # 1. original_sum1 \\n        # 2. original_sum \\n        # 3. original_sum1 - min_negative_sum\\n        # 4. original_sum2 + max_positive_sum\\n        \\n        original_sum1 = sum(nums1)\\n        original_sum2 = sum(nums2)\\n        diff = [num1 - num2 for num1, num2 in zip(nums1, nums2)]\\n        min_negative_sum = float(\\'inf\\')\\n        max_positive_sum = - float(\\'inf\\')\\n        cur_negative_sum = 0\\n        cur_positive_sum = 0\\n        \\n        for val in diff:\\n            cur_negative_sum += val\\n\\n            if cur_negative_sum > 0:\\n                cur_negative_sum = 0\\n            \\n            cur_positive_sum += val\\n            \\n            if cur_positive_sum < 0:\\n                cur_positive_sum = 0\\n                    \\n            min_negative_sum = min(min_negative_sum, cur_negative_sum)\\n            max_positive_sum = max(max_positive_sum, cur_positive_sum)\\n\\n        return max(original_sum1 - min_negative_sum, original_sum2 + max_positive_sum, original_sum2, original_sum1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198128,
                "title": "using-kadane-algorithm-c",
                "content": "```\\nApproach : \\n         calculate sum of each arrays. \\n         calculate kadanes of both nums1  - nums2  and nums2 - nums1. \\n         return max(kadanes(nums2 -nums1) + sum1, kadanes(nums1 - nums2) + sum2) ; \\n\\n\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        long long sum1 = accumulate(nums1.begin(), nums1.end(),0); \\n        long long sum2 = accumulate(nums2.begin(), nums2.end(),0); \\n        vector<int> v(nums1.size(), 0) ; \\n        // bool ff ; \\n        vector<int> v1(nums1.size(),0) ; \\n        for(int i = 0 ; i < nums1.size(); i ++) {\\n            v[i] = nums2[i] - nums1[i]; \\n        }\\n   \\n        for(int i = 0 ; i < nums2.size(); i ++) {\\n             v1[i] = nums1[i] - nums2[i]; \\n        }\\n        \\n      \\n        int lo = 0 ; \\n        int gl = 0 ; \\n        for(int i = 0 ; i < v.size() ; i ++) {\\n               lo = max(v[i], lo + v[i]); \\n               gl = max(lo , gl) ; \\n        }\\n        \\n        int low = 0 ; \\n        int glo = 0 ; \\n        for(int i = 0 ; i < v.size() ; i ++) {\\n               low = max(v1[i], low + v1[i]); \\n               glo = max(low , glo) ; \\n        }\\n \\n        int mx = max(sum1 + gl, sum2 + glo );   \\n    \\n        return mx; \\n    } \\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nApproach : \\n         calculate sum of each arrays. \\n         calculate kadanes of both nums1  - nums2  and nums2 - nums1. \\n         return max(kadanes(nums2 -nums1) + sum1, kadanes(nums1 - nums2) + sum2) ; \\n\\n\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        long long sum1 = accumulate(nums1.begin(), nums1.end(),0); \\n        long long sum2 = accumulate(nums2.begin(), nums2.end(),0); \\n        vector<int> v(nums1.size(), 0) ; \\n        // bool ff ; \\n        vector<int> v1(nums1.size(),0) ; \\n        for(int i = 0 ; i < nums1.size(); i ++) {\\n            v[i] = nums2[i] - nums1[i]; \\n        }\\n   \\n        for(int i = 0 ; i < nums2.size(); i ++) {\\n             v1[i] = nums1[i] - nums2[i]; \\n        }\\n        \\n      \\n        int lo = 0 ; \\n        int gl = 0 ; \\n        for(int i = 0 ; i < v.size() ; i ++) {\\n               lo = max(v[i], lo + v[i]); \\n               gl = max(lo , gl) ; \\n        }\\n        \\n        int low = 0 ; \\n        int glo = 0 ; \\n        for(int i = 0 ; i < v.size() ; i ++) {\\n               low = max(v1[i], low + v1[i]); \\n               glo = max(low , glo) ; \\n        }\\n \\n        int mx = max(sum1 + gl, sum2 + glo );   \\n    \\n        return mx; \\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485371,
                "title": "c-kadane-s-algorithm-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int>v1, v2;\\n        int sum1=0, sum2=0;\\n        for(int i=0; i<nums1.size(); i++){\\n            sum1+=nums1[i];\\n            sum2+=nums2[i];\\n            v1.push_back(nums1[i]-nums2[i]);\\n            v2.push_back(nums2[i]-nums1[i]);\\n        }\\n        int s1=0, s2=0, c1=INT_MIN, c2=INT_MIN;\\n        for(int i=0; i<nums1.size(); i++){\\n            s1+=v1[i];\\n            c1=max(c1, s1);\\n            if(s1<0){\\n                s1=0;\\n            }\\n        }\\n        for(int i=0; i<nums1.size(); i++){\\n            s2+=v2[i];\\n            c2=max(c2, s2);\\n            if(s2<0){\\n                s2=0;\\n            }\\n        }\\n        return max(sum1+c2, sum2+c1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int>v1, v2;\\n        int sum1=0, sum2=0;\\n        for(int i=0; i<nums1.size(); i++){\\n            sum1+=nums1[i];\\n            sum2+=nums2[i];\\n            v1.push_back(nums1[i]-nums2[i]);\\n            v2.push_back(nums2[i]-nums1[i]);\\n        }\\n        int s1=0, s2=0, c1=INT_MIN, c2=INT_MIN;\\n        for(int i=0; i<nums1.size(); i++){\\n            s1+=v1[i];\\n            c1=max(c1, s1);\\n            if(s1<0){\\n                s1=0;\\n            }\\n        }\\n        for(int i=0; i<nums1.size(); i++){\\n            s2+=v2[i];\\n            c2=max(c2, s2);\\n            if(s2<0){\\n                s2=0;\\n            }\\n        }\\n        return max(sum1+c2, sum2+c1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109055,
                "title": "o-n-using-kadane-algo-c-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &a,vector<int> &b){\\n        int ans = 0, sum = 0;\\n        for(int i = 0; i < a.size(); i++){\\n            sum = sum + a[i]-b[i];\\n            if(sum<0)sum=0;\\n            sum = max(sum,a[i]-b[i]);\\n            ans = max(ans,sum);\\n        }\\n        return ans;\\n    }\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int sum1=0,sum2=0;\\n        for(int i = 0; i < nums1.size(); i++){\\n            sum1 += nums1[i];\\n            sum2 += nums2[i];\\n            \\n        }\\n        return max(sum1+solve(nums2,nums1),sum2+solve(nums1,nums2));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &a,vector<int> &b){\\n        int ans = 0, sum = 0;\\n        for(int i = 0; i < a.size(); i++){\\n            sum = sum + a[i]-b[i];\\n            if(sum<0)sum=0;\\n            sum = max(sum,a[i]-b[i]);\\n            ans = max(ans,sum);\\n        }\\n        return ans;\\n    }\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int sum1=0,sum2=0;\\n        for(int i = 0; i < nums1.size(); i++){\\n            sum1 += nums1[i];\\n            sum2 += nums2[i];\\n            \\n        }\\n        return max(sum1+solve(nums2,nums1),sum2+solve(nums1,nums2));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2656775,
                "title": "simple-o-n-solution-using-kadane",
                "content": "```\\nint maxSubArraySum(vector<int> a, int n)\\n    {\\n        int max_so_far = INT_MIN, max_ending_here = 0;\\n    \\n        for (int i = 0; i < n; i++) {\\n            max_ending_here = max_ending_here + a[i];\\n            if (max_so_far < max_ending_here)\\n                max_so_far = max_ending_here;\\n \\n            if (max_ending_here < 0)\\n                max_ending_here = 0;\\n        }\\n        return max_so_far;\\n    }\\n \\n    \\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size();\\n        int sum1=0,sum2=0;\\n        vector<int> v1(n),v2(n);\\n        for(int i=0; i<n; i++){\\n            sum1 += nums1[i];\\n            sum2 += nums2[i];\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            v1[i]=nums1[i]-nums2[i];\\n            v2[i]=nums2[i]-nums1[i];\\n        }\\n        \\n        \\n        int max1 = maxSubArraySum(v1, n);\\n        int max2 = maxSubArraySum(v2, n);\\n        \\n        \\n        return max(sum1+max2,sum2+max1);\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint maxSubArraySum(vector<int> a, int n)\\n    {\\n        int max_so_far = INT_MIN, max_ending_here = 0;\\n    \\n        for (int i = 0; i < n; i++) {\\n            max_ending_here = max_ending_here + a[i];\\n            if (max_so_far < max_ending_here)\\n                max_so_far = max_ending_here;\\n \\n            if (max_ending_here < 0)\\n                max_ending_here = 0;\\n        }\\n        return max_so_far;\\n    }\\n \\n    \\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size();\\n        int sum1=0,sum2=0;\\n        vector<int> v1(n),v2(n);\\n        for(int i=0; i<n; i++){\\n            sum1 += nums1[i];\\n            sum2 += nums2[i];\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            v1[i]=nums1[i]-nums2[i];\\n            v2[i]=nums2[i]-nums1[i];\\n        }\\n        \\n        \\n        int max1 = maxSubArraySum(v1, n);\\n        int max2 = maxSubArraySum(v2, n);\\n        \\n        \\n        return max(sum1+max2,sum2+max1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2651295,
                "title": "observation-and-kadane-s-algo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA simple observation can tell us that our answer \\n- can only be either array A or array B.\\n- we can just obtain the maxiumum sum of array by taking a part of the other array which has maximum increment to our present array.\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor a general solution we can suppose to make array A as our final answer array. To do this we need the part of array B which has largest increment possible to our our array A by swapping that subarray.\\nSuppose we choose from B index $$i$$ and $$j$$ that we decided to $$swap$$ in array A.\\nhence it is obvious that our new $$sum$$ will be\\n```js\\nans= sum(A) + sum(B[k]-A[k])(k->{i...j});\\n   \\n```\\n```\\nlet d=sum(B[k]-A[k])(k->{i...j});\\n\\n```\\nWe have to maximise d, in other words we need to find such i and j so that the sum of is maximum;\\n\\nWe can do that by  making a difference array D\\nwhere \\n``` \\nD[i]= B[i]-A[i];\\n```\\nNow we just need to find the subarray with maximum subarray sum.\\nwhich obviously can be done in $$O(n)$$ using `Kadane\\'s Algo`;\\nSame can be done for B and we have to take mazimum of both results\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```C++\\nclass Solution {\\npublic:\\nint maxSubarraySum(int a[],int n)\\n{\\n    int max_so_far = INT_MIN, max_ending_here = 0;\\n    for (int i = 0; i < n; i++)\\n    {\\n        max_ending_here = max_ending_here + a[i];\\n        if (max_so_far < max_ending_here)\\n            max_so_far = max_ending_here;\\n        if (max_ending_here < 0)\\n            max_ending_here = 0;\\n    }\\n    return max_so_far;\\n}\\n    int maximumsSplicedArray(vector<int>& a, vector<int>& b) {\\n        int n=a.size();\\n        int sumA=0,sumB=0;\\n          for (int i = 0;i < n;i++)\\n    {\\n     \\n        sumA += a[i];\\n    }\\n    for (int i = 0;i < n;i++)\\n    {\\n      \\n        sumB += b[i];\\n    }\\n    // swap a subarray  from a to b \\n    // such that a or b has maximum sum possible\\n\\n    // try to maximize the sum of a\\n    int ans=0;\\n    int diffA[n];\\n  int diffB[n];\\n  for(int i=0;i<n;i++)\\n  {\\n      diffA[i]=b[i]-a[i];\\n      diffB[i]=a[i]-b[i];\\n  }\\nans=max(sumA+maxSubarraySum(diffA,n),sumB+maxSubarraySum(diffB,n));\\nreturn ans;\\n\\n \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```js\\nans= sum(A) + sum(B[k]-A[k])(k->{i...j});\\n   \\n```\n```\\nlet d=sum(B[k]-A[k])(k->{i...j});\\n\\n```\n``` \\nD[i]= B[i]-A[i];\\n```\n```C++\\nclass Solution {\\npublic:\\nint maxSubarraySum(int a[],int n)\\n{\\n    int max_so_far = INT_MIN, max_ending_here = 0;\\n    for (int i = 0; i < n; i++)\\n    {\\n        max_ending_here = max_ending_here + a[i];\\n        if (max_so_far < max_ending_here)\\n            max_so_far = max_ending_here;\\n        if (max_ending_here < 0)\\n            max_ending_here = 0;\\n    }\\n    return max_so_far;\\n}\\n    int maximumsSplicedArray(vector<int>& a, vector<int>& b) {\\n        int n=a.size();\\n        int sumA=0,sumB=0;\\n          for (int i = 0;i < n;i++)\\n    {\\n     \\n        sumA += a[i];\\n    }\\n    for (int i = 0;i < n;i++)\\n    {\\n      \\n        sumB += b[i];\\n    }\\n    // swap a subarray  from a to b \\n    // such that a or b has maximum sum possible\\n\\n    // try to maximize the sum of a\\n    int ans=0;\\n    int diffA[n];\\n  int diffB[n];\\n  for(int i=0;i<n;i++)\\n  {\\n      diffA[i]=b[i]-a[i];\\n      diffB[i]=a[i]-b[i];\\n  }\\nans=max(sumA+maxSubarraySum(diffA,n),sumB+maxSubarraySum(diffB,n));\\nreturn ans;\\n\\n \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2553281,
                "title": "easy-solution-using-states-representation",
                "content": "Approach \\n\\nSuppose we want to maximise the sum(Arr1) by taking atmost one subarray from Arr2, now suppose we want to calculate maximum sum till ith index, what are the possible cases/state?\\n\\n1) state - 0 : Take Arr1[i] assuming that no subarray of Arr2 is taken.\\n2) state - 1 : Take Arr2[i] assuming that previously we are in state - 0/1. \\n3) state - 2: Take Arr1[i] assuming that previously we are in state - 1/2;\\n\\nUsing this We can form the dp relation\\n* \\tdp[n][0] = dp[n-1][0] + Arr1[n]; \\n* \\tdp[n][1] = max(dp[n-1][0] , dp[n-1][1]) + Arr2[n];\\n* \\tdp[n][2] = max(dp[n-1][2], dp[n-1][1]) + Arr1[n];\\n\\nAnd finally taking max(dp[n][0], dp[n][1], dp[n][2]) gives the  maximum sum of Arr1 by taking atmost one subarray.\\nSimilary we can do for the other array and return the maximum of both. \\n\\n```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        vector<vector<int>> dp(n,vector<int> (3,0));\\n        dp[0][0] = nums1[0];\\n        dp[0][1] = nums2[0];\\n        dp[0][2] = 0;\\n        for (int i = 1; i < n;i++) {\\n            dp[i][0] = dp[i-1][0] + nums1[i];\\n            dp[i][1] = max(dp[i-1][0], dp[i-1][1]) + nums2[i];\\n            dp[i][2] = max(dp[i-1][1], dp[i-1][2]) + nums1[i];\\n        }\\n        int ans = max(dp[n-1][0], max(dp[n-1][1], dp[n-1][2]));\\n        dp[0][0] = nums2[0];\\n        dp[0][1] = nums1[0];\\n        dp[0][2] = 0;\\n        for (int i = 1; i < n;i++) {\\n            dp[i][0] = dp[i-1][0] + nums2[i];\\n            dp[i][1] = max(dp[i-1][0], dp[i-1][1]) + nums1[i];\\n            dp[i][2] = max(dp[i-1][1], dp[i-1][2]) + nums2[i];\\n        }\\n        int ans1 = max(dp[n-1][0], max(dp[n-1][1], dp[n-1][2]));\\n        \\n        return max(ans1,ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        vector<vector<int>> dp(n,vector<int> (3,0));\\n        dp[0][0] = nums1[0];\\n        dp[0][1] = nums2[0];\\n        dp[0][2] = 0;\\n        for (int i = 1; i < n;i++) {\\n            dp[i][0] = dp[i-1][0] + nums1[i];\\n            dp[i][1] = max(dp[i-1][0], dp[i-1][1]) + nums2[i];\\n            dp[i][2] = max(dp[i-1][1], dp[i-1][2]) + nums1[i];\\n        }\\n        int ans = max(dp[n-1][0], max(dp[n-1][1], dp[n-1][2]));\\n        dp[0][0] = nums2[0];\\n        dp[0][1] = nums1[0];\\n        dp[0][2] = 0;\\n        for (int i = 1; i < n;i++) {\\n            dp[i][0] = dp[i-1][0] + nums2[i];\\n            dp[i][1] = max(dp[i-1][0], dp[i-1][1]) + nums1[i];\\n            dp[i][2] = max(dp[i-1][1], dp[i-1][2]) + nums2[i];\\n        }\\n        int ans1 = max(dp[n-1][0], max(dp[n-1][1], dp[n-1][2]));\\n        \\n        return max(ans1,ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2207830,
                "title": "dynamic-programming-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size();\\n        int dp[n+1][3];\\n        dp[0][0]=nums1[0];\\n        dp[0][1]=nums2[0];\\n        dp[0][2]=nums1[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            dp[i][0]=dp[i-1][0]+nums1[i];\\n            dp[i][1]=max(dp[i-1][0],dp[i-1][1])+nums2[i];\\n            dp[i][2]=max(dp[i-1][1],max(dp[i-1][2],dp[i-1][0]))+nums1[i];\\n        }\\n       int ans=dp[n-1][2];\\n         dp[0][0]=nums2[0];\\n        dp[0][1]=nums1[0];\\n        dp[0][2]=nums2[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            dp[i][0]=dp[i-1][0]+nums2[i];\\n            dp[i][1]=max(dp[i-1][0],dp[i-1][1])+nums1[i];\\n            dp[i][2]=max(dp[i-1][1],max(dp[i-1][2],dp[i-1][0]))+nums2[i];\\n        }\\n        return max(ans,dp[n-1][2]);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size();\\n        int dp[n+1][3];\\n        dp[0][0]=nums1[0];\\n        dp[0][1]=nums2[0];\\n        dp[0][2]=nums1[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            dp[i][0]=dp[i-1][0]+nums1[i];\\n            dp[i][1]=max(dp[i-1][0],dp[i-1][1])+nums2[i];\\n            dp[i][2]=max(dp[i-1][1],max(dp[i-1][2],dp[i-1][0]))+nums1[i];\\n        }\\n       int ans=dp[n-1][2];\\n         dp[0][0]=nums2[0];\\n        dp[0][1]=nums1[0];\\n        dp[0][2]=nums2[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            dp[i][0]=dp[i-1][0]+nums2[i];\\n            dp[i][1]=max(dp[i-1][0],dp[i-1][1])+nums1[i];\\n            dp[i][2]=max(dp[i-1][1],max(dp[i-1][2],dp[i-1][0]))+nums2[i];\\n        }\\n        return max(ans,dp[n-1][2]);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2200809,
                "title": "100-faster-python-double-kadane-explained",
                "content": "# Intuition\\nWe need to optimize a subarray swap either from arr1 into arr2, or arr2 into arr1, or not do a swap at all.\\n\\nThe idea is to iterate over both arrays - both have length `n`, so we can do it in one go.\\nWe will try to find a subarray to swap, that will `add` the biggest sum to the other array. We will maintain a running_sum for both options (`running_1`, `running_2`). If running_sum is bigger than 0 we will keep adding the difference between nums1[i] - nums2[i] (and the other way around), and check if it\\'s the best answer. If we go negative we start over from 0 to remove the \"negative weight\"\\n\\n# Implementation\\n\\n```\\nclass Solution:\\n    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n        n = len(nums1)\\n        best_1_into_2_swap, best_2_into_1_swap = 0, 0\\n        running_1, running_2 = 0, 0\\n        s1, s2 = 0, 0\\n        \\n        for i in range(n):\\n            s1 += nums1[i]\\n            s2 += nums2[i]\\n            running_1 = max(running_1 + (nums1[i] - nums2[i]), 0)\\n            running_2 = max(running_2 + (nums2[i] - nums1[i]), 0)\\n            best_1_into_2_swap = max(best_1_into_2_swap, running_1)\\n            best_2_into_1_swap = max(best_2_into_1_swap, running_2)\\n        \\n        return max(s1 + best_2_into_1_swap, s2 + best_1_into_2_swap)\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n        n = len(nums1)\\n        best_1_into_2_swap, best_2_into_1_swap = 0, 0\\n        running_1, running_2 = 0, 0\\n        s1, s2 = 0, 0\\n        \\n        for i in range(n):\\n            s1 += nums1[i]\\n            s2 += nums2[i]\\n            running_1 = max(running_1 + (nums1[i] - nums2[i]), 0)\\n            running_2 = max(running_2 + (nums2[i] - nums1[i]), 0)\\n            best_1_into_2_swap = max(best_1_into_2_swap, running_1)\\n            best_2_into_1_swap = max(best_2_into_1_swap, running_2)\\n        \\n        return max(s1 + best_2_into_1_swap, s2 + best_1_into_2_swap)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2199332,
                "title": "java-sliding-window-easy-to-understand",
                "content": "```\\nclass Solution {\\n    long solve(int[] nums1, int[] nums2, long sum1, long sum2)\\n    {\\n        long windowSum1 = 0, windowSum2 = 0;\\n        int low = 0, n = nums1.length;\\n        long mxSum = 0;\\n        for (int high = 0; high < n; high++)\\n        {\\n            windowSum1 += nums1[high];\\n            windowSum2 += nums2[high];\\n            while (windowSum1 > windowSum2 && low <= high)\\n            {\\n                windowSum1 -= nums1[low];\\n                windowSum2 -= nums2[low];\\n                low++;\\n            }\\n            //here always windowSum2 will be greater than windowSum1\\n            long newSum = sum1 - windowSum1 + windowSum2; //newSum of nums1\\n            mxSum = Math.max(mxSum, newSum);\\n        }\\n        return mxSum;\\n    }\\n    public int maximumsSplicedArray(int[] nums1, int[] nums2)\\n    {\\n        long sum1 = 0, sum2 = 0;\\n        for (int i = 0; i < nums1.length; i++) { sum1 = sum1 + nums1[i]; sum2 = sum2 + nums2[i]; }\\n        long case1 = solve(nums1, nums2, sum1, sum2); \\n        //fixing that a subarray from \\'1\\' will be replaced by \\'2\\' and newSum of nums1 will be considered\\n        \\n        long case2 = solve(nums2, nums1, sum2, sum1);\\n        //fixing that a subarray from \\'2\\' will be replaced by \\'1\\' and newSum of nums2 will be considered\\n        \\n        return (int)Math.max(case1, case2);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    long solve(int[] nums1, int[] nums2, long sum1, long sum2)\\n    {\\n        long windowSum1 = 0, windowSum2 = 0;\\n        int low = 0, n = nums1.length;\\n        long mxSum = 0;\\n        for (int high = 0; high < n; high++)\\n        {\\n            windowSum1 += nums1[high];\\n            windowSum2 += nums2[high];\\n            while (windowSum1 > windowSum2 && low <= high)\\n            {\\n                windowSum1 -= nums1[low];\\n                windowSum2 -= nums2[low];\\n                low++;\\n            }\\n            //here always windowSum2 will be greater than windowSum1\\n            long newSum = sum1 - windowSum1 + windowSum2; //newSum of nums1\\n            mxSum = Math.max(mxSum, newSum);\\n        }\\n        return mxSum;\\n    }\\n    public int maximumsSplicedArray(int[] nums1, int[] nums2)\\n    {\\n        long sum1 = 0, sum2 = 0;\\n        for (int i = 0; i < nums1.length; i++) { sum1 = sum1 + nums1[i]; sum2 = sum2 + nums2[i]; }\\n        long case1 = solve(nums1, nums2, sum1, sum2); \\n        //fixing that a subarray from \\'1\\' will be replaced by \\'2\\' and newSum of nums1 will be considered\\n        \\n        long case2 = solve(nums2, nums1, sum2, sum1);\\n        //fixing that a subarray from \\'2\\' will be replaced by \\'1\\' and newSum of nums2 will be considered\\n        \\n        return (int)Math.max(case1, case2);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198656,
                "title": "prefix-sum-solution",
                "content": "```class Solution {\\n    public int maximumsSplicedArray(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        int prefix1[] = new int[n+1];\\n        prefix1[0]= 0;\\n        for(int i=1;i<=n;i++)\\n            prefix1[i] = prefix1[i-1]+ nums1[i-1];\\n        \\n        int prefix2[] = new int[n+1];\\n        prefix2[0]= 0;\\n        for(int i=1;i<=n;i++)\\n            prefix2[i] = prefix2[i-1]+ nums2[i-1];\\n\\n        int minA =0,minB = 0;\\n        int diff1[] = new int[n+1];\\n        int diff2[] = new int[n+1];\\n        diff1[0] = prefix1[n];\\n        diff2[0] = prefix2[n];\\n \\n        for(int i=1;i<=n;i++){\\n\\n           int temp1 = prefix2[i]-prefix1[i];\\n            diff1[i]= prefix1[n]+temp1-minA;\\n            minA = Math.min(minA, temp1);\\n\\n            int temp2 = prefix1[i]-prefix2[i];\\n            diff2[i]= prefix2[n]+temp2-minB;\\n            minB = Math.min(minB, temp2);\\n\\n        }\\n\\n        int ans = 0;\\n        for(int i=0;i<=n;i++){\\n            ans = Math.max(ans,diff1[i]);\\n            ans = Math.max(ans,diff2[i]);\\n        }\\n \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```class Solution {\\n    public int maximumsSplicedArray(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        int prefix1[] = new int[n+1];\\n        prefix1[0]= 0;\\n        for(int i=1;i<=n;i++)\\n            prefix1[i] = prefix1[i-1]+ nums1[i-1];\\n        \\n        int prefix2[] = new int[n+1];\\n        prefix2[0]= 0;\\n        for(int i=1;i<=n;i++)\\n            prefix2[i] = prefix2[i-1]+ nums2[i-1];\\n\\n        int minA =0,minB = 0;\\n        int diff1[] = new int[n+1];\\n        int diff2[] = new int[n+1];\\n        diff1[0] = prefix1[n];\\n        diff2[0] = prefix2[n];\\n \\n        for(int i=1;i<=n;i++){\\n\\n           int temp1 = prefix2[i]-prefix1[i];\\n            diff1[i]= prefix1[n]+temp1-minA;\\n            minA = Math.min(minA, temp1);\\n\\n            int temp2 = prefix1[i]-prefix2[i];\\n            diff2[i]= prefix2[n]+temp2-minB;\\n            minB = Math.min(minB, temp2);\\n\\n        }\\n\\n        int ans = 0;\\n        for(int i=0;i<=n;i++){\\n            ans = Math.max(ans,diff1[i]);\\n            ans = Math.max(ans,diff2[i]);\\n        }\\n \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198542,
                "title": "python-easy-approach-both-time-memory-beats-100",
                "content": "Both Time & Memory beats 100% python solutions\\n```\\nclass Solution:\\n    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n        \\n        def max_subarray(A):\\n\\n            max_ending_here = max_so_far = A[0]\\n\\n            for x in A[1:]:\\n\\n                max_ending_here = max(x, max_ending_here + x)\\n\\n                max_so_far = max(max_so_far, max_ending_here)\\n\\n            return max_so_far        \\n        \\n        def min_subarray(A):\\n\\n            min_ending_here = min_so_far = A[0]\\n\\n            for x in A[1:]:\\n\\n                min_ending_here = min(x, min_ending_here + x)\\n\\n                min_so_far = min(min_so_far, min_ending_here)\\n\\n            return min_so_far        \\n        \\n        n = len(nums1)\\n        A = []\\n        s1 = sum(nums1)\\n        s2 = sum(nums2)\\n\\n        if s1 > s2:\\n            for i in range(n):\\n                A.append(nums2[i] - nums1[i])\\n            ans = max_subarray(A)\\n            ans2 = min_subarray(A)\\n            \\n            return max(s1 + ans, s1, s2 - ans2)\\n        else:\\n            for i in range(n):\\n                A.append(nums1[i] - nums2[i])\\n            ans = max_subarray(A)\\n            ans2 = min_subarray(A)\\n            \\n            return max(s2 + ans, s2, s1 - ans2)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n        \\n        def max_subarray(A):\\n\\n            max_ending_here = max_so_far = A[0]\\n\\n            for x in A[1:]:\\n\\n                max_ending_here = max(x, max_ending_here + x)\\n\\n                max_so_far = max(max_so_far, max_ending_here)\\n\\n            return max_so_far        \\n        \\n        def min_subarray(A):\\n\\n            min_ending_here = min_so_far = A[0]\\n\\n            for x in A[1:]:\\n\\n                min_ending_here = min(x, min_ending_here + x)\\n\\n                min_so_far = min(min_so_far, min_ending_here)\\n\\n            return min_so_far        \\n        \\n        n = len(nums1)\\n        A = []\\n        s1 = sum(nums1)\\n        s2 = sum(nums2)\\n\\n        if s1 > s2:\\n            for i in range(n):\\n                A.append(nums2[i] - nums1[i])\\n            ans = max_subarray(A)\\n            ans2 = min_subarray(A)\\n            \\n            return max(s1 + ans, s1, s2 - ans2)\\n        else:\\n            for i in range(n):\\n                A.append(nums1[i] - nums2[i])\\n            ans = max_subarray(A)\\n            ans2 = min_subarray(A)\\n            \\n            return max(s2 + ans, s2, s1 - ans2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198493,
                "title": "c-max-sum-subarray-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        vector<int> v1(n,0);\\n        vector<int> v2(n,0);\\n        for(int i=0;i<n;i++){\\n            v1[i] = nums1[i]-nums2[i];\\n            v2[i] = nums2[i]-nums1[i];\\n         }\\n        int sm1 = 0;\\n        int sm2 = 0;\\n        for(auto val:nums1) sm1+=val;\\n        for(auto val:nums2) sm2+=val;\\n        // max sum subarray for array where ith element is nums1[i]-nums2[i]\\n        int cursum1 = 0;\\n        int ans1 = 0;\\n        for(int i=0;i<n;i++){\\n            if(cursum1+v1[i]>=0){\\n                cursum1+=v1[i];\\n                ans1 = max(cursum1,ans1);\\n            }\\n            else{\\n                cursum1 = 0;\\n            }\\n        }\\n        int temp1= sm2+ans1;\\n        \\n        // max sum subarray for array where ith element is nums2[i]-nums1[i]\\n        int cursum2 = 0;\\n        int ans2 = 0;\\n        for(int i=0;i<n;i++){\\n            if(cursum2+v2[i]>=0){\\n                cursum2+=v2[i];\\n                ans2 = max(cursum2,ans2);\\n            }\\n            else{\\n                cursum2 = 0;\\n            }\\n        }\\n       \\n        int temp2 = sm1+ans2;\\n        \\n        // taking best \\n        return max(temp1,temp2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        vector<int> v1(n,0);\\n        vector<int> v2(n,0);\\n        for(int i=0;i<n;i++){\\n            v1[i] = nums1[i]-nums2[i];\\n            v2[i] = nums2[i]-nums1[i];\\n         }\\n        int sm1 = 0;\\n        int sm2 = 0;\\n        for(auto val:nums1) sm1+=val;\\n        for(auto val:nums2) sm2+=val;\\n        // max sum subarray for array where ith element is nums1[i]-nums2[i]\\n        int cursum1 = 0;\\n        int ans1 = 0;\\n        for(int i=0;i<n;i++){\\n            if(cursum1+v1[i]>=0){\\n                cursum1+=v1[i];\\n                ans1 = max(cursum1,ans1);\\n            }\\n            else{\\n                cursum1 = 0;\\n            }\\n        }\\n        int temp1= sm2+ans1;\\n        \\n        // max sum subarray for array where ith element is nums2[i]-nums1[i]\\n        int cursum2 = 0;\\n        int ans2 = 0;\\n        for(int i=0;i<n;i++){\\n            if(cursum2+v2[i]>=0){\\n                cursum2+=v2[i];\\n                ans2 = max(cursum2,ans2);\\n            }\\n            else{\\n                cursum2 = 0;\\n            }\\n        }\\n       \\n        int temp2 = sm1+ans2;\\n        \\n        // taking best \\n        return max(temp1,temp2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198484,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    \\n    public static int maximumsSplicedArray(int[] nums1, int[] nums2) {\\n        int sum1 = Arrays.stream(nums1).sum();\\n\\t\\tint sum2 = Arrays.stream(nums2).sum();\\n        return Math.max(helper(nums1, nums2) + sum1, helper(nums2, nums1) + sum2);\\n    }\\n\\t\\n\\tpublic static int helper(int[] nums1, int[] nums2) {\\n\\t\\tint cur = 0, max = 0;\\n\\t\\tfor (int i = 0; i < nums1.length; i++) {\\n            //we always swap when we reach to a new index\\n\\t\\t\\tint gain = nums2[i] - nums1[i];\\n\\t\\t\\tcur += gain;\\n            //if the current score is less than 0, we have no reason to keep it, so we reset current score to 0\\n\\t\\t\\tif (cur < 0)\\n\\t\\t\\t\\tcur = 0;\\n\\t\\t\\tmax = Math.max(max, cur);\\n\\t\\t}\\n\\t\\treturn max;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public static int maximumsSplicedArray(int[] nums1, int[] nums2) {\\n        int sum1 = Arrays.stream(nums1).sum();\\n\\t\\tint sum2 = Arrays.stream(nums2).sum();\\n        return Math.max(helper(nums1, nums2) + sum1, helper(nums2, nums1) + sum2);\\n    }\\n\\t\\n\\tpublic static int helper(int[] nums1, int[] nums2) {\\n\\t\\tint cur = 0, max = 0;\\n\\t\\tfor (int i = 0; i < nums1.length; i++) {\\n            //we always swap when we reach to a new index\\n\\t\\t\\tint gain = nums2[i] - nums1[i];\\n\\t\\t\\tcur += gain;\\n            //if the current score is less than 0, we have no reason to keep it, so we reset current score to 0\\n\\t\\t\\tif (cur < 0)\\n\\t\\t\\t\\tcur = 0;\\n\\t\\t\\tmax = Math.max(max, cur);\\n\\t\\t}\\n\\t\\treturn max;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198372,
                "title": "c-kadane-algo",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint help(vector<int>&nums1,vector<int>&nums2){\\n\\t\\t\\tint mx = 0;\\n\\t\\t\\tfor(int i=0,kad = 0;i<size(nums1);i++){\\n\\t\\t\\t\\tkad = max(kad+nums2[i]-nums1[i],nums2[i]-nums1[i]);\\n\\t\\t\\t\\tmx = max(kad,mx);\\n\\t\\t\\t}\\n\\t\\t\\treturn accumulate(begin(nums1),end(nums1),0) + mx;\\n\\t\\t}\\n\\n\\t\\tint maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n\\t\\t\\treturn max(help(nums1,nums2),help(nums2,nums1));\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint help(vector<int>&nums1,vector<int>&nums2){\\n\\t\\t\\tint mx = 0;\\n\\t\\t\\tfor(int i=0,kad = 0;i<size(nums1);i++){\\n\\t\\t\\t\\tkad = max(kad+nums2[i]-nums1[i],nums2[i]-nums1[i]);\\n\\t\\t\\t\\tmx = max(kad,mx);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2198318,
                "title": "c-use-maxsubarray",
                "content": "\\n\\t class Solution {\\n     \\n\\t  public:\\n      \\n\\t  int maxSubArray(vector<int>& nums) {\\n        int mx=0;\\n        int cur=0;\\n        for(int i=0;i<nums.size();i++){\\n            cur+=nums[i];\\n            mx=min(cur,mx);\\n            if(cur>0){\\n                cur=0;\\n            }\\n        }\\n        return mx;\\n    }\\n    \\n      int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int>v;\\n        long long sum1=0;\\n        long long sum2=0;\\n        for(int i=0;i<nums1.size();i++){\\n            int x = nums1[i]-nums2[i];\\n            v.push_back(x);\\n            sum1+=nums1[i];\\n            sum2+=nums2[i];\\n        }\\n      long long  ans =max(sum1,sum2);\\n       long long x =maxSubArray(v);\\n        for(int i=0;i<v.size();i++){\\n           v[i]*=-1;\\n         //   cout<<v[i]<<\" \";\\n        }\\n       long long y =maxSubArray(v);\\n           ans=max(ans,sum1+abs(x));\\n           ans=max(ans,sum2+abs(y));\\n        return ans;\\n      }\\n   \\n};",
                "solutionTags": [],
                "code": "class Solution {\\n     \\n\\t  public:\\n      \\n\\t  int maxSubArray(vector<int>& nums) {\\n        int mx=0;\\n        int cur=0;\\n        for(int i=0;i<nums.size();i++){\\n            cur+=nums[i];\\n            mx=min(cur,mx);\\n            if(cur>0){\\n                cur=0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2198221,
                "title": "c-kadane",
                "content": "```cpp\\nint maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        vector<int> v(n);\\n        for(int i=0; i<n; i++)\\n            v[i] = nums2[i] - nums1[i];\\n        \\n        int sum1 = 0; for(int i=0; i<n; i++) sum1 += nums1[i];\\n        int sum2 = 0; for(int i=0; i<n; i++) sum2 += nums2[i];\\n        \\n        int maxx = 0, curr = 0;\\n        for(int i=0; i<n; i++){\\n            curr += v[i];\\n            if(curr < 0) curr = 0;\\n            maxx = max(maxx, curr);\\n        }\\n        \\n        int minn = 0; curr = 0;\\n        for(int i=0; i<n; i++){\\n            curr -= v[i];\\n            if(curr < 0) curr = 0;\\n            minn = max(minn, curr);\\n        }\\n        return max(sum1 + maxx, sum2 + minn);\\n    }\\n\\t\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        vector<int> v(n);\\n        for(int i=0; i<n; i++)\\n            v[i] = nums2[i] - nums1[i];\\n        \\n        int sum1 = 0; for(int i=0; i<n; i++) sum1 += nums1[i];\\n        int sum2 = 0; for(int i=0; i<n; i++) sum2 += nums2[i];\\n        \\n        int maxx = 0, curr = 0;\\n        for(int i=0; i<n; i++){\\n            curr += v[i];\\n            if(curr < 0) curr = 0;\\n            maxx = max(maxx, curr);\\n        }\\n        \\n        int minn = 0; curr = 0;\\n        for(int i=0; i<n; i++){\\n            curr -= v[i];\\n            if(curr < 0) curr = 0;\\n            minn = max(minn, curr);\\n        }\\n        return max(sum1 + maxx, sum2 + minn);\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2198161,
                "title": "java-simple-o-n-solution-with-comments",
                "content": "1. find sum for both arrays\\n2. create two arrays of same size using diffs of both arrays\\n3. apply kadane\\'s (max subarray sum) and find max1 & max2 for both diff arrays \\n\\tKadane\\' algo Ex. https://leetcode.com/problems/maximum-subarray/\\n4. ans =  max(sum1+max1, sum2_max2)\\n```\\npublic int maximumsSplicedArray(int[] nums1, int[] nums2) {\\n        int sum1=0, sum2=0;\\n        //find sum for both arrays\\n        for(int i=0; i<nums1.length; i++) {\\n            sum1 += nums1[i];\\n            sum2 += nums2[i];\\n        }\\n        int[] d1 = new int[nums1.length];\\n        int[] d2 = new int[nums1.length];\\n        //get diff for both arrays\\n        for(int i=0; i<nums1.length; i++) {\\n            d1[i] = nums2[i]-nums1[i];\\n            d2[i] = nums1[i]-nums2[i];\\n        }\\n        //find the max diff for both arrays \\n        int maxD1=Math.max(0, d1[0]), maxD2=Math.max(0, d2[0]);\\n        for(int i=1; i<nums1.length; i++) {\\n            d1[i] = Math.max(d1[i], d1[i-1]+d1[i]);\\n            maxD1 = Math.max(maxD1, d1[i]);\\n            \\n            d2[i] = Math.max(d2[i], d2[i-1]+d2[i]);\\n            maxD2 = Math.max(maxD2, d2[i]);\\n        }\\n        sum1 = Math.max(sum1, sum1+maxD1);\\n        sum2 = Math.max(sum2, sum2+maxD2);\\n        return Math.max(sum1, sum2);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maximumsSplicedArray(int[] nums1, int[] nums2) {\\n        int sum1=0, sum2=0;\\n        //find sum for both arrays\\n        for(int i=0; i<nums1.length; i++) {\\n            sum1 += nums1[i];\\n            sum2 += nums2[i];\\n        }\\n        int[] d1 = new int[nums1.length];\\n        int[] d2 = new int[nums1.length];\\n        //get diff for both arrays\\n        for(int i=0; i<nums1.length; i++) {\\n            d1[i] = nums2[i]-nums1[i];\\n            d2[i] = nums1[i]-nums2[i];\\n        }\\n        //find the max diff for both arrays \\n        int maxD1=Math.max(0, d1[0]), maxD2=Math.max(0, d2[0]);\\n        for(int i=1; i<nums1.length; i++) {\\n            d1[i] = Math.max(d1[i], d1[i-1]+d1[i]);\\n            maxD1 = Math.max(maxD1, d1[i]);\\n            \\n            d2[i] = Math.max(d2[i], d2[i-1]+d2[i]);\\n            maxD2 = Math.max(maxD2, d2[i]);\\n        }\\n        sum1 = Math.max(sum1, sum1+maxD1);\\n        sum2 = Math.max(sum2, sum2+maxD2);\\n        return Math.max(sum1, sum2);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2198133,
                "title": "c-kadanes-on-difference-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int sz=nums1.size();\\n        int sum1=accumulate(begin(nums1),end(nums1),0),sum2=accumulate(begin(nums2),end(nums2),0);\\n        vector<int>diff;\\n        //if i put ith element of nums1 into nums2 then sum2 will increase by diff[i]\\n        for(int i=0;i<sz;i++)\\n            diff.push_back(nums1[i]-nums2[i]);\\n        int ans=0;\\n        // so to get max value of sum2 we have to find max sum of subarray in diff \\n        ans=find(diff,sum2);\\n        \\n        //if i put ith element of nums2 into nums1 then sum1 will increase by diff[i]\\n        for(auto & i:diff)\\n            i=-i;\\n        // so to get max value of sum1 we have to find max sum of subarray in diff \\n        ans=max(ans,find(diff,sum1));\\n        return ans;\\n        \\n    }\\n    //kadane algo on diff\\n    int find(vector<int>&diff,int tot){\\n        int maxPrevGain=0,maxGain=INT_MIN,r=0;\\n        int sz=diff.size();\\n        while(r<sz){\\n            maxPrevGain= max(diff[r],diff[r]+maxPrevGain);\\n            maxGain=max(maxGain,sum);\\n            r++;\\n        }  \\n        return tot+maxGain;\\n    }\\n};\\n```\\nDo UPVOTE if it helps )",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int sz=nums1.size();\\n        int sum1=accumulate(begin(nums1),end(nums1),0),sum2=accumulate(begin(nums2),end(nums2),0);\\n        vector<int>diff;\\n        //if i put ith element of nums1 into nums2 then sum2 will increase by diff[i]\\n        for(int i=0;i<sz;i++)\\n            diff.push_back(nums1[i]-nums2[i]);\\n        int ans=0;\\n        // so to get max value of sum2 we have to find max sum of subarray in diff \\n        ans=find(diff,sum2);\\n        \\n        //if i put ith element of nums2 into nums1 then sum1 will increase by diff[i]\\n        for(auto & i:diff)\\n            i=-i;\\n        // so to get max value of sum1 we have to find max sum of subarray in diff \\n        ans=max(ans,find(diff,sum1));\\n        return ans;\\n        \\n    }\\n    //kadane algo on diff\\n    int find(vector<int>&diff,int tot){\\n        int maxPrevGain=0,maxGain=INT_MIN,r=0;\\n        int sz=diff.size();\\n        while(r<sz){\\n            maxPrevGain= max(diff[r],diff[r]+maxPrevGain);\\n            maxGain=max(maxGain,sum);\\n            r++;\\n        }  \\n        return tot+maxGain;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848997,
                "title": "clear-solution-with-explanation",
                "content": "Find the difference between nums2 and nums1 and store it in temp1.\\nFind the maxSubarraySum of temp1. \\nThis maxSubarray is the part which we can take from nums2 and replace with same part of nums1 and it will increase the sum of nums1 by maxSubarraySum. \\nWe will find maxScore as max of sum1 and sum1 + maxSubarraySum. \\n\\nWe will process nums2 the same way and find the maxScore. \\n\\nTC: O(n), SC: O(n)\\nNote: You can make the SC O(1) by not creating temp1 and temp2 and directly using the difference but that would make the code a little complicated. \\n\\n```\\nclass Solution:\\n    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n        n = len(nums1)\\n        sum1 = sum(nums1)\\n        sum2 = sum(nums2)\\n        maxScore = -inf\\n        \\n        #Processing nums1: Replacing subarry of nums2 in nums1\\n        temp1 = [nums2[i]-nums1[i] for i in range(n)]\\n        maxSubarraySum = 0\\n        subarraySum = 0\\n        for n in temp1:\\n            subarraySum += n\\n            maxSubarraySum = max(maxSubarraySum, subarraySum)\\n            if subarraySum < 0:\\n                subarraySum = 0\\n        maxScore = max(sum1, sum1+maxSubarraySum)\\n        \\n        #Processing nums2: Replacing subarry of nums1 in nums2\\n        temp2 = [nums1[i]-nums2[i] for i in range(len(nums1))]\\n        maxSubarraySum = 0\\n        subarraySum = 0\\n        for n in temp2:\\n            subarraySum += n\\n            maxSubarraySum = max(maxSubarraySum, subarraySum)\\n            if subarraySum < 0:\\n                subarraySum = 0\\n        maxScore = max(maxScore, sum2+maxSubarraySum)\\n        \\n        return maxScore\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n        n = len(nums1)\\n        sum1 = sum(nums1)\\n        sum2 = sum(nums2)\\n        maxScore = -inf\\n        \\n        #Processing nums1: Replacing subarry of nums2 in nums1\\n        temp1 = [nums2[i]-nums1[i] for i in range(n)]\\n        maxSubarraySum = 0\\n        subarraySum = 0\\n        for n in temp1:\\n            subarraySum += n\\n            maxSubarraySum = max(maxSubarraySum, subarraySum)\\n            if subarraySum < 0:\\n                subarraySum = 0\\n        maxScore = max(sum1, sum1+maxSubarraySum)\\n        \\n        #Processing nums2: Replacing subarry of nums1 in nums2\\n        temp2 = [nums1[i]-nums2[i] for i in range(len(nums1))]\\n        maxSubarraySum = 0\\n        subarraySum = 0\\n        for n in temp2:\\n            subarraySum += n\\n            maxSubarraySum = max(maxSubarraySum, subarraySum)\\n            if subarraySum < 0:\\n                subarraySum = 0\\n        maxScore = max(maxScore, sum2+maxSubarraySum)\\n        \\n        return maxScore\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208702,
                "title": "crisp-n-clear-o-n-javascript-memory-66-66-meaningful-vars",
                "content": "Time Complexity: O(N)\\nSpace Complexity: O(1)\\n```\\nvar maximumsSplicedArray = function(nums1, nums2) {\\n\\tconst sumNums1 = nums1.reduce((acc, currentElement) => currentElement + acc);\\n\\tconst sumNums2 = nums2.reduce((acc, currentElement) => currentElement + acc);\\n\\tlet maxSum = 0;\\n\\tlet tempStoreNums1 = 0;\\n\\tlet tempStoreNums2 = 0;\\n\\tfor (let index = 0; index < nums1.length; index++) {\\n\\t\\ttempStoreNums1 += nums1[index];\\n\\t\\ttempStoreNums2 += nums2[index];\\n\\t\\tconst difference = tempStoreNums2 - tempStoreNums1;\\n\\t\\tif (difference < 0) {\\n\\t\\t\\ttempStoreNums2 = 0;\\n\\t\\t\\ttempStoreNums1 = 0;\\n\\t\\t}\\n\\t\\tif (maxSum < difference) {\\n\\t\\t\\tmaxSum = difference;\\n\\t\\t}\\n\\t}\\n\\n\\tconst maxSumOne = sumNums1 + maxSum;\\n\\n\\ttempStoreNums1 = 0;\\n\\ttempStoreNums2 = 0;\\n\\tmaxSum = 0;\\n\\tfor (let index = 0; index < nums1.length; index++) {\\n\\t\\ttempStoreNums1 += nums1[index];\\n\\t\\ttempStoreNums2 += nums2[index];\\n\\t\\tconst difference = tempStoreNums1 - tempStoreNums2;\\n\\t\\tif (difference < 0) {\\n\\t\\t\\ttempStoreNums2 = 0;\\n\\t\\t\\ttempStoreNums1 = 0;\\n\\t\\t}\\n\\t\\tif (maxSum < difference) {\\n\\t\\t\\tmaxSum = difference;\\n\\t\\t}\\n\\t}\\n\\tconst maxSumTwo = sumNums2 + maxSum;\\n\\treturn Math.max(maxSumTwo, maxSumOne);\\n};\\n\\n```\\n![image](https://assets.leetcode.com/users/images/e6d79fd0-6b0f-49c1-b638-81cabdad7d10_1676874857.9138792.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximumsSplicedArray = function(nums1, nums2) {\\n\\tconst sumNums1 = nums1.reduce((acc, currentElement) => currentElement + acc);\\n\\tconst sumNums2 = nums2.reduce((acc, currentElement) => currentElement + acc);\\n\\tlet maxSum = 0;\\n\\tlet tempStoreNums1 = 0;\\n\\tlet tempStoreNums2 = 0;\\n\\tfor (let index = 0; index < nums1.length; index++) {\\n\\t\\ttempStoreNums1 += nums1[index];\\n\\t\\ttempStoreNums2 += nums2[index];\\n\\t\\tconst difference = tempStoreNums2 - tempStoreNums1;\\n\\t\\tif (difference < 0) {\\n\\t\\t\\ttempStoreNums2 = 0;\\n\\t\\t\\ttempStoreNums1 = 0;\\n\\t\\t}\\n\\t\\tif (maxSum < difference) {\\n\\t\\t\\tmaxSum = difference;\\n\\t\\t}\\n\\t}\\n\\n\\tconst maxSumOne = sumNums1 + maxSum;\\n\\n\\ttempStoreNums1 = 0;\\n\\ttempStoreNums2 = 0;\\n\\tmaxSum = 0;\\n\\tfor (let index = 0; index < nums1.length; index++) {\\n\\t\\ttempStoreNums1 += nums1[index];\\n\\t\\ttempStoreNums2 += nums2[index];\\n\\t\\tconst difference = tempStoreNums1 - tempStoreNums2;\\n\\t\\tif (difference < 0) {\\n\\t\\t\\ttempStoreNums2 = 0;\\n\\t\\t\\ttempStoreNums1 = 0;\\n\\t\\t}\\n\\t\\tif (maxSum < difference) {\\n\\t\\t\\tmaxSum = difference;\\n\\t\\t}\\n\\t}\\n\\tconst maxSumTwo = sumNums2 + maxSum;\\n\\treturn Math.max(maxSumTwo, maxSumOne);\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2419228,
                "title": "c-sulotion-o-n-tc-o-1-sc",
                "content": "```\\nclass Solution {\\npublic:\\n    static int maximumsSplicedArray(const vector<int>& nums1, const vector<int>& nums2) {\\n        int c = 0, e = 0, h = 0;\\n        int a = 0, b = 0;\\n        for (int i = 0; i < size(nums1); ++i) {\\n            c += nums2[i] - nums1[i];\\n            e = max(e, c);\\n            h = max(h, -c);\\n            a = max(a, c + h);\\n            b = max(b, -c + e);\\n        }\\n        return max(accumulate(begin(nums1), end(nums1), 0) + a,\\n                   accumulate(begin(nums2), end(nums2), 0) + b);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    static int maximumsSplicedArray(const vector<int>& nums1, const vector<int>& nums2) {\\n        int c = 0, e = 0, h = 0;\\n        int a = 0, b = 0;\\n        for (int i = 0; i < size(nums1); ++i) {\\n            c += nums2[i] - nums1[i];\\n            e = max(e, c);\\n            h = max(h, -c);\\n            a = max(a, c + h);\\n            b = max(b, -c + e);\\n        }\\n        return max(accumulate(begin(nums1), end(nums1), 0) + a,\\n                   accumulate(begin(nums2), end(nums2), 0) + b);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2309514,
                "title": "java-using-kadanes-algo",
                "content": "\\n        \\n        int d1[]=new int[nums1.length+1];\\n        int d2[]=new int[nums1.length+1];\\n\\n        int sum2=0,sum1=0;;\\n        for(int i=0;i<d1.length-1;i++)\\n        {\\n            d1[i+1]=nums1[i]-nums2[i];\\n            d2[i+1]=nums2[i]-nums1[i];\\n            sum2+=nums2[i];\\n            sum1+=nums1[i];\\n        }\\n        int maxdiff2=0,maxdiff1=0;\\n        int dp1[]=new int[d1.length];\\n        int dp2[]=new int[d1.length];\\n\\n        for(int i=1;i<d1.length;i++)\\n        {\\n            if(d1[i]>dp1[i-1]+d1[i])\\n            {\\n                dp1[i]=d1[i];\\n            }\\n            else\\n            {\\n                dp1[i]=dp1[i-1]+d1[i];\\n            }\\n            maxdiff1=Math.max(maxdiff1,dp1[i]);\\n            //\\n            if(d2[i]>d2[i]+dp2[i-1])\\n            {\\n                dp2[i]=d2[i];\\n            }\\n            else\\n            {\\n                dp2[i]=dp2[i-1]+d2[i];\\n            }\\n            maxdiff2=Math.max(maxdiff2,dp2[i]);\\n            \\n            \\n        }\\n        int r1=maxdiff2+sum1;\\n        int r2=maxdiff1+sum2;\\n        return Math.max(r1,r2);\\n        \\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "\\n        \\n        int d1[]=new int[nums1.length+1];\\n        int d2[]=new int[nums1.length+1];\\n\\n        int sum2=0,sum1=0;;\\n        for(int i=0;i<d1.length-1;i++)\\n        {\\n            d1[i+1]=nums1[i]-nums2[i];\\n            d2[i+1]=nums2[i]-nums1[i];\\n            sum2+=nums2[i];\\n            sum1+=nums1[i];\\n        }\\n        int maxdiff2=0,maxdiff1=0;\\n        int dp1[]=new int[d1.length];\\n        int dp2[]=new int[d1.length];\\n\\n        for(int i=1;i<d1.length;i++)\\n        {\\n            if(d1[i]>dp1[i-1]+d1[i])\\n            {\\n                dp1[i]=d1[i];\\n            }\\n            else\\n            {\\n                dp1[i]=dp1[i-1]+d1[i];\\n            }\\n            maxdiff1=Math.max(maxdiff1,dp1[i]);\\n            //\\n            if(d2[i]>d2[i]+dp2[i-1])\\n            {\\n                dp2[i]=d2[i];\\n            }\\n            else\\n            {\\n                dp2[i]=dp2[i-1]+d2[i];\\n            }\\n            maxdiff2=Math.max(maxdiff2,dp2[i]);\\n            \\n            \\n        }\\n        int r1=maxdiff2+sum1;\\n        int r2=maxdiff1+sum2;\\n        return Math.max(r1,r2);\\n        \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2305766,
                "title": "c-easy-intuitive-kadane-s-solution-time-o-n-space-o-1",
                "content": "class Solution {\\npublic:\\n\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        int maxi1 = 0, maxi2 = 0;\\n        int curr1 = 0, curr2 = 0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            curr1 += nums1[i]-nums2[i];\\n            curr2 += nums2[i]-nums1[i];\\n            \\n            maxi1 = max(maxi1,curr1);\\n            maxi2 = max(maxi2,curr2);\\n            \\n            if(curr1<0)\\n                curr1 = 0;\\n            if(curr2<0)\\n                curr2 = 0;\\n        }\\n        \\n        int sum1 = 0;\\n        int sum2 = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum1 += nums1[i];\\n            sum2 += nums2[i];\\n        }\\n        \\n        return max(sum1+maxi2, sum2+maxi1);\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        int maxi1 = 0, maxi2 = 0;\\n        int curr1 = 0, curr2 = 0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            curr1 += nums1[i]-nums2[i];\\n            curr2 += nums2[i]-nums1[i];\\n            \\n            maxi1 = max(maxi1,curr1);\\n            maxi2 = max(maxi2,curr2);\\n            \\n            if(curr1<0)\\n                curr1 = 0;\\n            if(curr2<0)\\n                curr2 = 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2277780,
                "title": "kadane-s-way-spent-around-4-hours-will-try-to-explain-as-i-understood-it",
                "content": "So we have 2 arrays and question want us to return the max array (i.e the array which has the max. sum), inorder to get the max sum the question has given us two conditions \\n1) get the max sum subarray from the other array2 and replace it with yours array1.\\n2) OR do nothing incase array1 is already the max. one\\n\\n\\nwe\\'ve to take care of both the possibilties. So when we say we want  to replace the normal subarray with the max subarray it simply means adding the difference(by which the max subarray is greater) to the normal subarray and we have to do it for both the arrays.\\n\\n\\nso we took the diff vectors to save the diff1,diff2 for  v1-v2 (assuming v1 is greater ) and v2-v1(assuming v2 is greater ) arrays . once we have the diffs we can see the which is the largest sum of the subarray we can get (by kadane) and since it is the difference so we have to add it.\\n\\nsay x we got from the max subarray sum from diff1 and y we got from the max subarray sum from diff2.\\n\\nNow since x is obtained from v1-v2 so we have to add it to v2 to try to make it greater (in other words you can think that v1 already has x in it , moreover v2 is less by x so we\\'ve to add it) and same we need to do with y\\n\\nand then get the max between these two values.\\n\\n\\n\\n\\n```\\nint kad( vector<int> a)\\n{\\n    int n = a.size();\\n    int res = a[0];\\n    int temp = a[0];\\n    \\n    for(int i=1;i<n;i++)\\n    {\\n        \\n        temp = max(a[i],temp+a[i]);\\n        res = max(res, temp);\\n        \\n    }\\n return res;\\n}\\n\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& a, vector<int>& b) {\\n        int n = a.size();\\n        vector<int> diff1(n);\\n        vector<int> diff2(n);\\n        int sum1,sum2;\\n        sum1=sum2=0;\\n        for(int i =0;i<n;i++)\\n        {\\n            diff1[i] = a[i]-b[i];\\n            diff2[i] = b[i]-a[i];\\n            sum1+=a[i];\\n            sum2+=b[i];\\n        }\\n        int d1 = kad(diff1);\\n        int d2 = kad(diff2);\\n        return max(sum1+d2,sum2+d1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint kad( vector<int> a)\\n{\\n    int n = a.size();\\n    int res = a[0];\\n    int temp = a[0];\\n    \\n    for(int i=1;i<n;i++)\\n    {\\n        \\n        temp = max(a[i],temp+a[i]);\\n        res = max(res, temp);\\n        \\n    }\\n return res;\\n}\\n\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& a, vector<int>& b) {\\n        int n = a.size();\\n        vector<int> diff1(n);\\n        vector<int> diff2(n);\\n        int sum1,sum2;\\n        sum1=sum2=0;\\n        for(int i =0;i<n;i++)\\n        {\\n            diff1[i] = a[i]-b[i];\\n            diff2[i] = b[i]-a[i];\\n            sum1+=a[i];\\n            sum2+=b[i];\\n        }\\n        int d1 = kad(diff1);\\n        int d2 = kad(diff2);\\n        return max(sum1+d2,sum2+d1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2251399,
                "title": "kadane-algo-tc-o-n-sc-o-1",
                "content": "Simply traverse and find maximum sum of subarray difference using kadanes algorithm and add it to sum of nums array\\n**TC: O(n)\\nSC: O(1)**\\n```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int sum1=0,sum2=0,res1=0,curr1=0,res2=0,curr2=0;\\n        for(int i=0;i<nums1.size();++i){\\n            curr1+=nums2[i]-nums1[i];\\n            curr2+=nums1[i]-nums2[i];\\n            if(curr1<0) curr1=0;\\n            if(curr2<0) curr2=0;\\n            res1=max(res1,curr1);\\n            res2=max(res2,curr2);\\n            sum1+=nums1[i];\\n            sum2+=nums2[i];\\n        }\\n        return max(sum1+res1,sum2+res2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int sum1=0,sum2=0,res1=0,curr1=0,res2=0,curr2=0;\\n        for(int i=0;i<nums1.size();++i){\\n            curr1+=nums2[i]-nums1[i];\\n            curr2+=nums1[i]-nums2[i];\\n            if(curr1<0) curr1=0;\\n            if(curr2<0) curr2=0;\\n            res1=max(res1,curr1);\\n            res2=max(res2,curr2);\\n            sum1+=nums1[i];\\n            sum2+=nums2[i];\\n        }\\n        return max(sum1+res1,sum2+res2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2220351,
                "title": "maximum-subarray-in-diff-array",
                "content": "```\\n/*\\n    \\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510\\nA   \\u2502  20  40  20  70  30 \\u2502\\n    \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518\\n    \\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510\\nB   \\u2502  50  20  50  40  20 \\u2502\\n    \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518\\n    \\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510\\nB-A \\u2502 30 -20  30  -30 -10 \\u2502\\n    \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518\\n      \\u25A0\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u25A0\\n\\nFind maxsubarry in diff array like above, we can get maxsubarrysum which is 40, so we can get new nums1 by swapping [0...2]\\n*/\\n\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        // get maximum subarray with diff array A[i]-B[i]\\n        function<int(vector<int>&, vector<int>&)> maxSubDiffArray = [](vector<int>& A, vector<int>& B) {\\n            int N = A.size();\\n            int res = 0, cur = 0;\\n            for (int i = 0; i < N; i++) {\\n                int diff = A[i] - B[i];\\n                cur = max(cur + diff, 0);\\n                res = max(res, cur);\\n            }\\n            return res;\\n        };\\n        \\n        int chooseNums1 = accumulate(nums1.begin(), nums1.end(), 0) + maxSubDiffArray(nums2, nums1);\\n        int chooseNums2 = accumulate(nums2.begin(), nums2.end(), 0) + maxSubDiffArray(nums1, nums2);\\n        return max(chooseNums1, chooseNums2);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    \\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510\\nA   \\u2502  20  40  20  70  30 \\u2502\\n    \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518\\n    \\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510\\nB   \\u2502  50  20  50  40  20 \\u2502\\n    \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518\\n    \\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510\\nB-A \\u2502 30 -20  30  -30 -10 \\u2502\\n    \\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518\\n      \\u25A0\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u25A0\\n\\nFind maxsubarry in diff array like above, we can get maxsubarrysum which is 40, so we can get new nums1 by swapping [0...2]\\n*/\\n\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        // get maximum subarray with diff array A[i]-B[i]\\n        function<int(vector<int>&, vector<int>&)> maxSubDiffArray = [](vector<int>& A, vector<int>& B) {\\n            int N = A.size();\\n            int res = 0, cur = 0;\\n            for (int i = 0; i < N; i++) {\\n                int diff = A[i] - B[i];\\n                cur = max(cur + diff, 0);\\n                res = max(res, cur);\\n            }\\n            return res;\\n        };\\n        \\n        int chooseNums1 = accumulate(nums1.begin(), nums1.end(), 0) + maxSubDiffArray(nums2, nums1);\\n        int chooseNums2 = accumulate(nums2.begin(), nums2.end(), 0) + maxSubDiffArray(nums1, nums2);\\n        return max(chooseNums1, chooseNums2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219149,
                "title": "python-kidane-algorithm",
                "content": "```\\nclass Solution(object):\\n    def maximumsSplicedArray(self, A, B):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: int\\n        \"\"\"\\n        s1 = sum(A)\\n        s2 = sum(B)\\n\\n# Having four pointers to compare and store max value if swapping is done in both directions ie from array B to A and array A to B respectively\\n        \\n        curr_max_A_diff, curr_max_B_diff, sum_of_A_diff, sum_of_B_diff = 0, 0 , 0, 0\\n        \\n        for i in range(len(A)):\\n            \\n# The following 2 lines find the max value that can be generated in array A from bringing elements from array B\\n\\n            curr_max_A_diff = max(0, curr_max_A_diff + B[i] - A[i])\\n            sum_of_A_diff = max(sum_of_A_diff, curr_max_A_diff)\\n        \\n# The following 2 lines find the max value that can be generated in array B from bringing elements from array A         \\n            curr_max_B_diff = max(0, curr_max_B_diff + A[i] - B[i])\\n            sum_of_B_diff = max(sum_of_B_diff, curr_max_B_diff)\\n\\n# Return the array that generates the max score       \\n        return max(s1 + sum_of_A_diff, s2 + sum_of_B_diff )\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maximumsSplicedArray(self, A, B):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: int\\n        \"\"\"\\n        s1 = sum(A)\\n        s2 = sum(B)\\n\\n# Having four pointers to compare and store max value if swapping is done in both directions ie from array B to A and array A to B respectively\\n        \\n        curr_max_A_diff, curr_max_B_diff, sum_of_A_diff, sum_of_B_diff = 0, 0 , 0, 0\\n        \\n        for i in range(len(A)):\\n            \\n# The following 2 lines find the max value that can be generated in array A from bringing elements from array B\\n\\n            curr_max_A_diff = max(0, curr_max_A_diff + B[i] - A[i])\\n            sum_of_A_diff = max(sum_of_A_diff, curr_max_A_diff)\\n        \\n# The following 2 lines find the max value that can be generated in array B from bringing elements from array A         \\n            curr_max_B_diff = max(0, curr_max_B_diff + A[i] - B[i])\\n            sum_of_B_diff = max(sum_of_B_diff, curr_max_B_diff)\\n\\n# Return the array that generates the max score       \\n        return max(s1 + sum_of_A_diff, s2 + sum_of_B_diff )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2218204,
                "title": "kadane-solution-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        int sm1=0,sm2=0,ans;\\n        for(int i=0;i<n;i++){\\n            sm1 +=nums1[i];\\n            sm2 +=nums2[i];\\n        }\\n        \\n        int first=0,second=0,mx1=0,mx2=0;\\n        for(int i=0;i<n;i++){         // kadane s\\' algo to calculate maximum sum of subarray\\n            first += nums2[i] - nums1[i];\\n            second += nums1[i] - nums2[i];\\n            mx1 = max(mx1,first);\\n            mx2 = max(mx2,second);\\n            if(first < 0) first = 0;\\n            if(second < 0) second = 0;\\n        }\\n        \\n        ans = max(sm1+mx1,sm2+mx2);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        int sm1=0,sm2=0,ans;\\n        for(int i=0;i<n;i++){\\n            sm1 +=nums1[i];\\n            sm2 +=nums2[i];\\n        }\\n        \\n        int first=0,second=0,mx1=0,mx2=0;\\n        for(int i=0;i<n;i++){         // kadane s\\' algo to calculate maximum sum of subarray\\n            first += nums2[i] - nums1[i];\\n            second += nums1[i] - nums2[i];\\n            mx1 = max(mx1,first);\\n            mx2 = max(mx2,second);\\n            if(first < 0) first = 0;\\n            if(second < 0) second = 0;\\n        }\\n        \\n        ans = max(sm1+mx1,sm2+mx2);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2211639,
                "title": "javascript-kadane",
                "content": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar maximumsSplicedArray = function (nums1, nums2) {\\n  return Math.max(kadane(nums1, nums2), kadane(nums2, nums1));\\n};\\n\\nfunction kadane(numsOne, numsTwo) {\\n  let max = 0;\\n  let sum = 0;\\n  let bestSum = 0;\\n\\n  for (let i = 0; i < numsOne.length; i++) {\\n    sum += numsOne[i];\\n\\n    bestSum = Math.max(0, bestSum + numsTwo[i] - numsOne[i]);\\n    max = Math.max(max, bestSum);\\n  }\\n\\n  return sum + max;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar maximumsSplicedArray = function (nums1, nums2) {\\n  return Math.max(kadane(nums1, nums2), kadane(nums2, nums1));\\n};\\n\\nfunction kadane(numsOne, numsTwo) {\\n  let max = 0;\\n  let sum = 0;\\n  let bestSum = 0;\\n\\n  for (let i = 0; i < numsOne.length; i++) {\\n    sum += numsOne[i];\\n\\n    bestSum = Math.max(0, bestSum + numsTwo[i] - numsOne[i]);\\n    max = Math.max(max, bestSum);\\n  }\\n\\n  return sum + max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2201673,
                "title": "python-100-kadane-s-sliding-window-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n        def findSub(arr1,s1,arr2,res):\\n            right = 0\\n            benefit = 0\\n            while right < len(arr1):\\n                # calulate the benefit we can get if we swap the element in the right pointer\\n                diff = arr2[right] - arr1[right]\\n                benefit += diff\\n        \\n                # if the benefit is negative that means we need to undo the swaps we have made so far\\n                # by moving the left pointer \\n                # start over from the position of the pointers\\n                if benefit < 0:\\n                    benefit = 0\\n                res = max(res,s1+benefit)\\n                right += 1\\n            return res\\n        \\n        sum1 = sum(nums1)\\n        sum2 = sum(nums2)\\n        \\n        # Try to maximize the first array by swaping subarrays from the second array\\n        one_to_two = findSub(nums1,sum1,nums2,max(sum1,sum2))\\n\\t\\t\\n\\t\\t # Try to maximize the second array by swaping subarrays from the first array\\n        two_to_one = findSub(nums2,sum2,nums1,max(sum1,sum2))\\n        \\n        return max(one_to_two,two_to_one)\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n        def findSub(arr1,s1,arr2,res):\\n            right = 0\\n            benefit = 0\\n            while right < len(arr1):\\n                # calulate the benefit we can get if we swap the element in the right pointer\\n                diff = arr2[right] - arr1[right]\\n                benefit += diff\\n        \\n                # if the benefit is negative that means we need to undo the swaps we have made so far\\n                # by moving the left pointer \\n                # start over from the position of the pointers\\n                if benefit < 0:\\n                    benefit = 0\\n                res = max(res,s1+benefit)\\n                right += 1\\n            return res\\n        \\n        sum1 = sum(nums1)\\n        sum2 = sum(nums2)\\n        \\n        # Try to maximize the first array by swaping subarrays from the second array\\n        one_to_two = findSub(nums1,sum1,nums2,max(sum1,sum2))\\n\\t\\t\\n\\t\\t # Try to maximize the second array by swaping subarrays from the first array\\n        two_to_one = findSub(nums2,sum2,nums1,max(sum1,sum2))\\n        \\n        return max(one_to_two,two_to_one)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2200671,
                "title": "c-recursive-memoization-state-change",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[100001][3];\\n    int solve(vector<int>& nums1, vector<int>& nums2,int i,int n,int isContinue) {\\n        if(i>=n) {\\n            return 0;\\n        }\\n        \\n        if(dp[i][isContinue]!=-1) {\\n            return dp[i][isContinue];\\n        }\\n        \\n        int res=0;\\n        if(isContinue==0) {\\n            //we want to continue with 0 state and no swap\\n            int tempRes1 = nums1[i] + solve(nums1,nums2,i+1,n,isContinue);\\n            //we want to swap value,that\\'s why we take nums2[i] ,and In future we can\\'t change state to 0.\\n            int tempRes2 = nums2[i] + solve(nums1,nums2,i+1,n,isContinue+1);\\n            res=max(tempRes1,tempRes2);\\n        }\\n        else if(isContinue==1) {\\n            //This means, we alreay on the bus of swap, so further we can do continue or go norammly.\\n            int tempRes1 = nums2[i] + solve(nums1,nums2,i+1,n,isContinue);\\n            //when we go normally it means we can\\'t swap further.\\n            int tempRes2 = nums1[i] + solve(nums1,nums2,i+1,n,isContinue+1);\\n            res=max(tempRes1,tempRes2);\\n        }\\n        else {\\n            //isContinue=2 means go and get sum till end.\\n            int tempRes = nums1[i] + solve(nums1,nums2,i+1,n,isContinue);\\n            res=max(res,tempRes);\\n        }\\n        return dp[i][isContinue] = res;\\n    }\\n    \\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size();\\n        memset(dp,-1,sizeof(dp));\\n        int result1=solve(nums1,nums2,0,n,0);\\n        memset(dp,-1,sizeof(dp));\\n        int result2=solve(nums2,nums1,0,n,0);\\n        return max(result1,result2);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[100001][3];\\n    int solve(vector<int>& nums1, vector<int>& nums2,int i,int n,int isContinue) {\\n        if(i>=n) {\\n            return 0;\\n        }\\n        \\n        if(dp[i][isContinue]!=-1) {\\n            return dp[i][isContinue];\\n        }\\n        \\n        int res=0;\\n        if(isContinue==0) {\\n            //we want to continue with 0 state and no swap\\n            int tempRes1 = nums1[i] + solve(nums1,nums2,i+1,n,isContinue);\\n            //we want to swap value,that\\'s why we take nums2[i] ,and In future we can\\'t change state to 0.\\n            int tempRes2 = nums2[i] + solve(nums1,nums2,i+1,n,isContinue+1);\\n            res=max(tempRes1,tempRes2);\\n        }\\n        else if(isContinue==1) {\\n            //This means, we alreay on the bus of swap, so further we can do continue or go norammly.\\n            int tempRes1 = nums2[i] + solve(nums1,nums2,i+1,n,isContinue);\\n            //when we go normally it means we can\\'t swap further.\\n            int tempRes2 = nums1[i] + solve(nums1,nums2,i+1,n,isContinue+1);\\n            res=max(tempRes1,tempRes2);\\n        }\\n        else {\\n            //isContinue=2 means go and get sum till end.\\n            int tempRes = nums1[i] + solve(nums1,nums2,i+1,n,isContinue);\\n            res=max(res,tempRes);\\n        }\\n        return dp[i][isContinue] = res;\\n    }\\n    \\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size();\\n        memset(dp,-1,sizeof(dp));\\n        int result1=solve(nums1,nums2,0,n,0);\\n        memset(dp,-1,sizeof(dp));\\n        int result2=solve(nums2,nums1,0,n,0);\\n        return max(result1,result2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2200292,
                "title": "beginner-friendly-explanation",
                "content": "**First approach**\\n**O(n^2)**\\n![image](https://assets.leetcode.com/users/images/b61a6f63-2c26-4d92-a350-a3246dad11d6_1656240494.9661005.jpeg)\\n\\n```\\nclass Solution {\\n    public int maximumsSplicedArray(int[] nums1, int[] nums2) {\\n        int n=nums1.length;\\n        int[][] dp1=new int[n][n];\\n        dp1[0][0]=nums1[0];\\n        int[][] dp2=new int[n][n];\\n        for(int i=0;i<n;i++){\\n            dp1[i][i]=nums1[i];\\n            dp2[i][i]=nums2[i];\\n            for(int j=i+1;j<n;j++){\\n                dp1[i][j]=dp1[i][j-1]+nums1[j];\\n                dp2[i][j]=dp2[i][j-1]+nums2[j];\\n            }\\n        }\\n        int sum1=0,sum2=0;\\n        for(int i=0;i<n;i++){\\n            sum1+=nums1[i];\\n            sum2+=nums2[i];\\n        }\\n        int maxi=Math.max(sum1,sum2);\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n                int temp1=sum1-dp1[i][j]+dp2[i][j];\\n                int temp2=sum2-dp2[i][j]+dp1[i][j];\\n                maxi=Math.max(maxi,Math.max(temp1,temp2));\\n            }\\n        }\\n        return maxi;\\n    }\\n}\\n```\\n\\n**Memory limit exceeded**\\n____________________________________________________________________________________________________________________________\\n**Second approach optimized in space **\\n\\n![image](https://assets.leetcode.com/users/images/89bacd48-e44b-47ce-8db1-e887e500d20b_1656240574.674329.jpeg)\\n```\\nclass Solution {\\n    public int maximumsSplicedArray(int[] nums1, int[] nums2) {\\n        int n=nums1.length;\\n        int[][] dp=new int[n+1][n+1];\\n        for(int i=0;i<=n;i++){\\n            // dp[i-1][i]=nums1[i];\\n            // dp[i][i-1]=nums2[i];\\n            for(int j=i+1;j<=n;j++){\\n                dp[i][j]=dp[i][j-1]+nums1[j-1];\\n                dp[j][i]=dp[j-1][i]+nums2[j-1];\\n            }\\n        }\\n        int sum1=0,sum2=0;\\n        for(int i=0;i<n;i++){\\n            sum1+=nums1[i];\\n            sum2+=nums2[i];\\n        }\\n        int maxi=Math.max(sum1,sum2);\\n        for(int i=1;i<=n;i++){\\n            for(int j=i;j<=n;j++){\\n                int temp1=sum1-dp[i][j]+dp[j][i];\\n                int temp2=sum2-dp[j][i]+dp[i][j];\\n                maxi=Math.max(maxi,Math.max(temp1,temp2));\\n            }\\n        }\\n        return maxi;\\n    }\\n}\\n```\\n**Time limit exceeded as this was still in O(n^2) time complexity**\\n\\n____________________________________________________________________________________________________________________________\\n\\n**More optimized Use of Kadane\\'s Algorithm**\\n\\n![image](https://assets.leetcode.com/users/images/11eae1dd-b133-4409-84bd-452db9017465_1656240727.3183603.jpeg)\\n\\n\\n```\\nclass Solution {\\n    public int maxSubArray(int[] nums){\\n        int sum=0,max=nums[0];\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            max=Math.max(sum,max);\\n            if(sum<0)sum=0;\\n        }\\n        return max;\\n    }\\n    public int maximumsSplicedArray(int[] nums1, int[] nums2) {\\n        int n=nums1.length;\\n        int[] arr1=new int[n];\\n        int[] arr2=new int[n];\\n        int sum1=0,sum2=0;\\n        for(int i=0;i<n;i++){\\n            sum1+=nums1[i];\\n            sum2+=nums2[i];\\n            arr1[i]=nums1[i]-nums2[i];\\n            arr2[i]=nums2[i]-nums1[i];\\n        }\\n        int maxi=Math.max(sum1,sum2);\\n        \\n        return Math.max(maxSubArray(arr1)+sum2,maxSubArray(arr2)+sum1);\\n    }\\n}\\n\\n```\\n\\nHope you liked the process. If you have anything to add, most welcome.\\uD83D\\uDE03\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumsSplicedArray(int[] nums1, int[] nums2) {\\n        int n=nums1.length;\\n        int[][] dp1=new int[n][n];\\n        dp1[0][0]=nums1[0];\\n        int[][] dp2=new int[n][n];\\n        for(int i=0;i<n;i++){\\n            dp1[i][i]=nums1[i];\\n            dp2[i][i]=nums2[i];\\n            for(int j=i+1;j<n;j++){\\n                dp1[i][j]=dp1[i][j-1]+nums1[j];\\n                dp2[i][j]=dp2[i][j-1]+nums2[j];\\n            }\\n        }\\n        int sum1=0,sum2=0;\\n        for(int i=0;i<n;i++){\\n            sum1+=nums1[i];\\n            sum2+=nums2[i];\\n        }\\n        int maxi=Math.max(sum1,sum2);\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n                int temp1=sum1-dp1[i][j]+dp2[i][j];\\n                int temp2=sum2-dp2[i][j]+dp1[i][j];\\n                maxi=Math.max(maxi,Math.max(temp1,temp2));\\n            }\\n        }\\n        return maxi;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maximumsSplicedArray(int[] nums1, int[] nums2) {\\n        int n=nums1.length;\\n        int[][] dp=new int[n+1][n+1];\\n        for(int i=0;i<=n;i++){\\n            // dp[i-1][i]=nums1[i];\\n            // dp[i][i-1]=nums2[i];\\n            for(int j=i+1;j<=n;j++){\\n                dp[i][j]=dp[i][j-1]+nums1[j-1];\\n                dp[j][i]=dp[j-1][i]+nums2[j-1];\\n            }\\n        }\\n        int sum1=0,sum2=0;\\n        for(int i=0;i<n;i++){\\n            sum1+=nums1[i];\\n            sum2+=nums2[i];\\n        }\\n        int maxi=Math.max(sum1,sum2);\\n        for(int i=1;i<=n;i++){\\n            for(int j=i;j<=n;j++){\\n                int temp1=sum1-dp[i][j]+dp[j][i];\\n                int temp2=sum2-dp[j][i]+dp[i][j];\\n                maxi=Math.max(maxi,Math.max(temp1,temp2));\\n            }\\n        }\\n        return maxi;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxSubArray(int[] nums){\\n        int sum=0,max=nums[0];\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            max=Math.max(sum,max);\\n            if(sum<0)sum=0;\\n        }\\n        return max;\\n    }\\n    public int maximumsSplicedArray(int[] nums1, int[] nums2) {\\n        int n=nums1.length;\\n        int[] arr1=new int[n];\\n        int[] arr2=new int[n];\\n        int sum1=0,sum2=0;\\n        for(int i=0;i<n;i++){\\n            sum1+=nums1[i];\\n            sum2+=nums2[i];\\n            arr1[i]=nums1[i]-nums2[i];\\n            arr2[i]=nums2[i]-nums1[i];\\n        }\\n        int maxi=Math.max(sum1,sum2);\\n        \\n        return Math.max(maxSubArray(arr1)+sum2,maxSubArray(arr2)+sum1);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2199461,
                "title": "java-using-kadanes-algo",
                "content": "\\n\\n    class Solution {\\n    public int maximumsSplicedArray(int[] nums1, int[] nums2) {\\n        //taking diff nums1-nums2\\n        int n=nums1.length;\\n        int diff[]=new int[n];\\n        int sum1=0,sum2=0;\\n        for(int i=0;i<n;i++){\\n            diff[i]=nums1[i]-nums2[i];\\n            sum1+=nums1[i];\\n            sum2+=nums2[i];\\n        }\\n        int get1=kadanes(diff,n);\\n        int max=get1+sum2;\\n        //taking diff nums2-nums1\\n        for(int i=0;i<n;i++)diff[i]=-1*diff[i];\\n        \\n         int get2=kadanes(diff,n);\\n         int max1=get2+sum1;\\n        return Math.max(max,max1);\\n    }\\n    //applying kadanes algo\\n    public int kadanes(int arr[],int n){\\n        int prev=arr[0];\\n        int max=prev;\\n        for(int i=1;i<n;i++){\\n            prev=Math.max(arr[i],prev+arr[i]);\\n            max=Math.max(max,prev);\\n        }\\n        return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maximumsSplicedArray(int[] nums1, int[] nums2) {\\n        //taking diff nums1-nums2\\n        int n=nums1.length;\\n        int diff[]=new int[n];\\n        int sum1=0,sum2=0;\\n        for(int i=0;i<n;i++){\\n            diff[i]=nums1[i]-nums2[i];\\n            sum1+=nums1[i];\\n            sum2+=nums2[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2199447,
                "title": "kadane-algo-o-n-single-loop-c",
                "content": "Running kadanes for maximizing nums1 as well as nums2 together in a single loop.\\n\\n```\\n int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int s1=0,s2=0;\\n        int sum1=0,sum2=0,mxdiff1=0,mxdiff2=0; \\n        vector<int> v(nums1.size(),0),p(nums1.size(),0);\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n             s1+=nums1[i];\\n             s2+=nums2[i];\\n            // to maximize nums1\\n                v[i]=nums2[i]-nums1[i];\\n                sum1+=v[i];\\n                if(sum1<=v[i])\\n                    sum1=v[i];\\n                mxdiff1=max(sum1,mxdiff1);\\n           // to maximize nums2\\n                p[i]=nums1[i]-nums2[i];\\n                sum2+=p[i];\\n                if(sum2<=p[i])\\n                    sum2=p[i];\\n                mxdiff2=max(mxdiff2,sum2);\\n        }\\n        return max(max(s1,s1+mxdiff1),max(s2,s2+mxdiff2));\\n    }\\n};",
                "solutionTags": [],
                "code": "Running kadanes for maximizing nums1 as well as nums2 together in a single loop.\\n\\n```\\n int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int s1=0,s2=0;\\n        int sum1=0,sum2=0,mxdiff1=0,mxdiff2=0; \\n        vector<int> v(nums1.size(),0),p(nums1.size(),0);\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n             s1+=nums1[i];\\n             s2+=nums2[i];\\n            // to maximize nums1\\n                v[i]=nums2[i]-nums1[i];\\n                sum1+=v[i];\\n                if(sum1<=v[i])\\n                    sum1=v[i];\\n                mxdiff1=max(sum1,mxdiff1);\\n           // to maximize nums2\\n                p[i]=nums1[i]-nums2[i];\\n                sum2+=p[i];\\n                if(sum2<=p[i])\\n                    sum2=p[i];\\n                mxdiff2=max(mxdiff2,sum2);\\n        }\\n        return max(max(s1,s1+mxdiff1),max(s2,s2+mxdiff2));\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2199093,
                "title": "c-kadane",
                "content": "```\\n        public int MaximumsSplicedArray(int[] nums1, int[] nums2)\\n        {\\n            int n = nums1.Length;\\n            int[] diff1 = new int[n];//nums1[i] - nums2[i];\\n            int[] diff2 = new int[n];// nums2[i] - nums1[i];\\n            int sum1 = 0;\\n            int sum2 = 0;\\n            for (int i = 0; i < n; i++)\\n            {\\n                diff1[i] = nums1[i] - nums2[i];\\n                diff2[i] = nums2[i] - nums1[i];\\n                sum1 += nums1[i];\\n                sum2 += nums2[i];\\n            }\\n            int max1 = MaxSubArray(diff1);\\n            int max2 = MaxSubArray(diff2);\\n\\t\\t\\t//swap max1 to nums2 = sum2+max1, or swap max2 to nums1=sum1+max2\\n            return Math.Max(sum2+max1,sum1+max2);\\n        }\\n\\t\\t\\n\\t\\t//leetcode 53. Maximum Subarray, #Kadane\\n\\t\\tpublic int MaxSubArray(int[] nums)\\n        {\\n            int sum = 0;\\n            int max = int.MinValue; //if all negtive num ,return nums.Max()\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                sum += nums[i];\\n                max = Math.Max(max, sum);\\n                if (sum <= 0) sum = 0;\\n            }\\n            return max;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n        public int MaximumsSplicedArray(int[] nums1, int[] nums2)\\n        {\\n            int n = nums1.Length;\\n            int[] diff1 = new int[n];//nums1[i] - nums2[i];\\n            int[] diff2 = new int[n];// nums2[i] - nums1[i];\\n            int sum1 = 0;\\n            int sum2 = 0;\\n            for (int i = 0; i < n; i++)\\n            {\\n                diff1[i] = nums1[i] - nums2[i];\\n                diff2[i] = nums2[i] - nums1[i];\\n                sum1 += nums1[i];\\n                sum2 += nums2[i];\\n            }\\n            int max1 = MaxSubArray(diff1);\\n            int max2 = MaxSubArray(diff2);\\n\\t\\t\\t//swap max1 to nums2 = sum2+max1, or swap max2 to nums1=sum1+max2\\n            return Math.Max(sum2+max1,sum1+max2);\\n        }\\n\\t\\t\\n\\t\\t//leetcode 53. Maximum Subarray, #Kadane\\n\\t\\tpublic int MaxSubArray(int[] nums)\\n        {\\n            int sum = 0;\\n            int max = int.MinValue; //if all negtive num ,return nums.Max()\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                sum += nums[i];\\n                max = Math.Max(max, sum);\\n                if (sum <= 0) sum = 0;\\n            }\\n            return max;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2199074,
                "title": "kadanes-on-difference-array-with-description",
                "content": "**Intuition :**\\nWe can find the max sum subarray in nums2 that will increase sum of nums1 by max amount and vice versa.\\nThis can be done by applying kadanes on the difference array and finding the max difference by which a subarray of nums2[] can increase the sum of nums1[] and vice versa. After this we can choose the max of both.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int sum=nums[0];\\n        int current_sum=0;\\n        if(sum>0)current_sum=sum;\\n        for(int i=1;i<nums.size();i++){\\n            current_sum+=nums[i];\\n            if(current_sum>sum)sum=current_sum;\\n            if(current_sum<0)current_sum=0;\\n        }\\n        return sum;\\n    }\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int sum1=accumulate(nums1.begin(),nums1.end(),0);\\n        int sum2=accumulate(nums2.begin(),nums2.end(),0);\\n        for(int i=0;i<nums1.size();i++){\\n            int temp=nums1[i]-nums2[i];\\n            nums2[i]=temp;\\n            nums1[i]=-temp;\\n        }\\n        \\n        return max(sum1+maxSubArray(nums1),sum2+maxSubArray(nums2));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int sum=nums[0];\\n        int current_sum=0;\\n        if(sum>0)current_sum=sum;\\n        for(int i=1;i<nums.size();i++){\\n            current_sum+=nums[i];\\n            if(current_sum>sum)sum=current_sum;\\n            if(current_sum<0)current_sum=0;\\n        }\\n        return sum;\\n    }\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int sum1=accumulate(nums1.begin(),nums1.end(),0);\\n        int sum2=accumulate(nums2.begin(),nums2.end(),0);\\n        for(int i=0;i<nums1.size();i++){\\n            int temp=nums1[i]-nums2[i];\\n            nums2[i]=temp;\\n            nums1[i]=-temp;\\n        }\\n        \\n        return max(sum1+maxSubArray(nums1),sum2+maxSubArray(nums2));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2199070,
                "title": "my-intuitive-approach-help-in-reaching-solution",
                "content": "Me after solving this question for 1/2 hr.\\n![image](https://assets.leetcode.com/users/images/77e3aa21-060b-432e-92c1-4b844e4b64af_1656223820.5457609.png)\\n\\t\\t\\n\\n- according to question we need to maximise the sum of any array by changing the subarray of the any one array.\\n- I can make the array of difference b/w element of array *n1* and *n2*. \\n\\n**Here after this i got confused weather i need to take local optimal or global optimal for making any one array sum maximum.**\\n\\n- now wherever my *SUM* goes less than 0 it will make it 0 again before that i want compare with my maximum sum i can get from array.\\n- simlilary i have done for 2nd array just make the diff*-1 because we have take the *diff = num1 - num2*\\n\\nHere we got the solution\\n\\n\\n\\t\\tclass Solution {\\n\\n\\t\\tpublic:\\n\\n\\t\\tint maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n       \\n        int sum1 = 0;\\n        int sum2 = 0;\\n        vector<int> df(nums1.size(),0);\\n        \\n        for(int i = 0; i<df.size();i++){\\n            df[i] = nums1[i] - nums2[i];\\n            sum1 += nums1[i];\\n            sum2 += nums2[i];\\n        }\\n        int diff1 = 0;\\n        int df1 = 0;\\n        for(int num : df){\\n            df1 += num;\\n            diff1 = max(df1,diff1);\\n            if(df1 < 0){\\n                df1 = 0;\\n            }\\n        }\\n        \\n        int diff2 = 0;\\n        int df2 = 0;\\n        for(int num : df){\\n            df2 += -1*num;\\n            diff2 = max(df2,diff2);\\n            if(df2 < 0){\\n                df2 = 0;\\n            }\\n        }\\n        \\n        int x = diff2 + sum1;\\n        int y = diff1  + sum2;\\n        \\n        return max(x,y);\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n\\n\\t\\tpublic:\\n\\n\\t\\tint maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n       \\n        int sum1 = 0;\\n        int sum2 = 0;\\n        vector<int> df(nums1.size(),0);\\n        \\n        for(int i = 0; i<df.size();i++){\\n            df[i] = nums1[i] - nums2[i];\\n            sum1 += nums1[i];\\n            sum2 += nums2[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2198882,
                "title": "javascript-prefix-sum-178ms",
                "content": "```\\nconst preSum = (a) => { let pre = [0]; for (let i = 0; i < a.length; i++) { pre.push(pre[i] + a[i]); } return pre; };\\nconst subArraySum = (a, l, r) => a[r + 1] - a[l];\\n\\nconst maximumsSplicedArray = (a, b) => {\\n    let n = a.length, preA = preSum(a), preB = preSum(b), sumA = preA[n], sumB = preB[n], res = Math.max(preA[n], preB[n]), min = 0;\\n    for (let i = 0; i <= n; i++) {\\n        let rangeSumA = subArraySum(preA, 0, i - 1), rangeSumB = subArraySum(preB, 0, i - 1), diff = rangeSumB - rangeSumA;\\n        min = Math.min(min, diff);\\n        let sum = sumA - min + diff;\\n        res = Math.max(res, sum);\\n    }\\n    min = 0;\\n    for (let i = 0; i <= n; i++) {\\n        let rangeSumA = subArraySum(preA, 0, i - 1), rangeSumB = subArraySum(preB, 0, i - 1), diff = rangeSumA - rangeSumB;\\n        min = Math.min(min, diff);\\n        let sum = sumB - min + diff;\\n        res = Math.max(res, sum);\\n    }\\n    return res;\\n};\\n```\\nSolution 2: kadane max modification  141ms\\n```\\nconst maximumsSplicedArray = (a, b) => Math.max(Kadane_max(a, b), Kadane_max(b, a))\\n\\nconst sm = (a) => a.reduce(((x, y) => x + y), 0);\\nconst Kadane_max = (a, b) => {\\n    let res = 0, sum = 0, n = a.length;\\n    for (let i = 0; i < n; i++) {\\n        let e = a[i] - b[i];\\n        sum = Math.max(0, sum + e);\\n        res = Math.max(res, sum);\\n    }\\n    return res + sm(b);\\n};\\n```\\nSolution 3: use maxSubarray template https://leetcode.com/problems/maximum-subarray/   197ms\\n```\\nconst sm = (a) => a.reduce(((x, y) => x + y), 0);\\n\\nconst maximumsSplicedArray = (a, b) => {\\n    let n = a.length, d1 = [], d2 = [], sumA = sm(a), sumB = sm(b);\\n    for (let i = 0; i < n; i++) {\\n        d1.push(a[i] - b[i]);\\n        d2.push(b[i] - a[i]);\\n    }\\n    return Math.max(sumA + maxSubArray(d2), sumB + maxSubArray(d1));\\n};\\n\\nconst maxSubArray = (a) => {\\n    let n = a.length;\\n    let dp = Array(n).fill(0);\\n    dp[0] = a[0];\\n    for (let i = 1; i < n; i++) dp[i] = Math.max(dp[i - 1], 0) + a[i];\\n    return Math.max(...dp);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst preSum = (a) => { let pre = [0]; for (let i = 0; i < a.length; i++) { pre.push(pre[i] + a[i]); } return pre; };\\nconst subArraySum = (a, l, r) => a[r + 1] - a[l];\\n\\nconst maximumsSplicedArray = (a, b) => {\\n    let n = a.length, preA = preSum(a), preB = preSum(b), sumA = preA[n], sumB = preB[n], res = Math.max(preA[n], preB[n]), min = 0;\\n    for (let i = 0; i <= n; i++) {\\n        let rangeSumA = subArraySum(preA, 0, i - 1), rangeSumB = subArraySum(preB, 0, i - 1), diff = rangeSumB - rangeSumA;\\n        min = Math.min(min, diff);\\n        let sum = sumA - min + diff;\\n        res = Math.max(res, sum);\\n    }\\n    min = 0;\\n    for (let i = 0; i <= n; i++) {\\n        let rangeSumA = subArraySum(preA, 0, i - 1), rangeSumB = subArraySum(preB, 0, i - 1), diff = rangeSumA - rangeSumB;\\n        min = Math.min(min, diff);\\n        let sum = sumB - min + diff;\\n        res = Math.max(res, sum);\\n    }\\n    return res;\\n};\\n```\n```\\nconst maximumsSplicedArray = (a, b) => Math.max(Kadane_max(a, b), Kadane_max(b, a))\\n\\nconst sm = (a) => a.reduce(((x, y) => x + y), 0);\\nconst Kadane_max = (a, b) => {\\n    let res = 0, sum = 0, n = a.length;\\n    for (let i = 0; i < n; i++) {\\n        let e = a[i] - b[i];\\n        sum = Math.max(0, sum + e);\\n        res = Math.max(res, sum);\\n    }\\n    return res + sm(b);\\n};\\n```\n```\\nconst sm = (a) => a.reduce(((x, y) => x + y), 0);\\n\\nconst maximumsSplicedArray = (a, b) => {\\n    let n = a.length, d1 = [], d2 = [], sumA = sm(a), sumB = sm(b);\\n    for (let i = 0; i < n; i++) {\\n        d1.push(a[i] - b[i]);\\n        d2.push(b[i] - a[i]);\\n    }\\n    return Math.max(sumA + maxSubArray(d2), sumB + maxSubArray(d1));\\n};\\n\\nconst maxSubArray = (a) => {\\n    let n = a.length;\\n    let dp = Array(n).fill(0);\\n    dp[0] = a[0];\\n    for (let i = 1; i < n; i++) dp[i] = Math.max(dp[i - 1], 0) + a[i];\\n    return Math.max(...dp);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2198863,
                "title": "c-kadanes-algorithm-dp-easy",
                "content": "```\\nclass Solution {\\nprivate:\\n    int findSum(vector<int>& a){\\n        int n = a.size();\\n        \\n        int maxSum = 0, currSum = 0;\\n        for(int i = 0; i < n; ++i){\\n            currSum += a[i];\\n            maxSum = max(maxSum, currSum);\\n            \\n            if(currSum <= 0)\\n                currSum = 0;\\n        }\\n        \\n        return maxSum;\\n    }\\nprivate:\\n    int find(vector<int>& a, vector<int>& b){\\n        int n = a.size();\\n        \\n        vector<int> c;\\n        int sum = 0;\\n        for(int i = 0; i < n; ++i){\\n            sum += a[i];\\n            c.push_back(b[i] - a[i]);\\n        }\\n        \\n        int maxSum = findSum(c);\\n        int newSum = sum + maxSum;\\n        return newSum;\\n    }\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        \\n        int sum1 = 0, sum2 = 0;\\n        for(int i = 0; i < n; ++i)\\n            sum1 += nums1[i];\\n        for(int i = 0; i < n; ++i)\\n            sum2 += nums2[i];\\n        \\n        int ans = max(sum1, sum2);\\n        ans = max(find(nums1, nums2), find(nums2, nums1));\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int findSum(vector<int>& a){\\n        int n = a.size();\\n        \\n        int maxSum = 0, currSum = 0;\\n        for(int i = 0; i < n; ++i){\\n            currSum += a[i];\\n            maxSum = max(maxSum, currSum);\\n            \\n            if(currSum <= 0)\\n                currSum = 0;\\n        }\\n        \\n        return maxSum;\\n    }\\nprivate:\\n    int find(vector<int>& a, vector<int>& b){\\n        int n = a.size();\\n        \\n        vector<int> c;\\n        int sum = 0;\\n        for(int i = 0; i < n; ++i){\\n            sum += a[i];\\n            c.push_back(b[i] - a[i]);\\n        }\\n        \\n        int maxSum = findSum(c);\\n        int newSum = sum + maxSum;\\n        return newSum;\\n    }\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        \\n        int sum1 = 0, sum2 = 0;\\n        for(int i = 0; i < n; ++i)\\n            sum1 += nums1[i];\\n        for(int i = 0; i < n; ++i)\\n            sum2 += nums2[i];\\n        \\n        int ans = max(sum1, sum2);\\n        ans = max(find(nums1, nums2), find(nums2, nums1));\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198842,
                "title": "turn-or-no-turn-python-dp",
                "content": "Approach : \\n1. According to Q description we can switch btw arrays max 2 times. This observation can help in thinking of DP way.\\n2. DP state => (i,j,turn_cnt) where i is index, j is either 0 or 1 i.e nums1 or nums2 and turn_cn t is number of times we have switched btw arrays\\n3. Time complexity ==> O(6*n) ==> O(n)\\n\\n```\\nclass Solution:\\n    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n        A = list(zip(nums1,nums2))\\n        n = len(A)\\n        @lru_cache(maxsize=None)\\n        def dp(i,j,turn_cnt,n):\\n            if i==n:\\n                return 0\\n            res = dp(i+1,j,turn_cnt,n) + A[i][j]\\n            if turn_cnt<2:\\n                res = max(res,dp(i+1,1-j,turn_cnt+1,n) + A[i][1-j])\\n            return res \\n        return max(dp(0,0,0,n),dp(0,1,0,n))\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n        A = list(zip(nums1,nums2))\\n        n = len(A)\\n        @lru_cache(maxsize=None)\\n        def dp(i,j,turn_cnt,n):\\n            if i==n:\\n                return 0\\n            res = dp(i+1,j,turn_cnt,n) + A[i][j]\\n            if turn_cnt<2:\\n                res = max(res,dp(i+1,1-j,turn_cnt+1,n) + A[i][1-j])\\n            return res \\n        return max(dp(0,0,0,n),dp(0,1,0,n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198670,
                "title": "c-fastest-variation-of-max-subarraysum",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int maxSubArraySum(vector<int> a)\\n    {  int size=a.size();\\n       int max_so_far = a[0];\\n       int curr_max = a[0];\\n\\n       for (int i = 1; i < size; i++)\\n       {\\n            curr_max = max(a[i], curr_max+a[i]);\\n            max_so_far = max(max_so_far, curr_max);\\n       }\\n       return max_so_far;\\n    }\\n    \\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n     \\n        vector<int> veca(nums1.size());\\n        vector<int> vecb(nums1.size());\\n        \\n        int suma=0;\\n        int sumb=0;\\n        \\n        for(int i=0;i<nums1.size();i=i+1)\\n        {\\n            veca[i]=-nums1[i]+nums2[i];\\n            vecb[i]=nums1[i]-nums2[i];\\n            suma=suma+nums1[i];\\n            sumb=sumb+nums2[i];\\n        }\\n        \\n        int cala=maxSubArraySum(veca);\\n        int calb=maxSubArraySum(vecb);\\n        int res1=max(suma+cala,suma);\\n        int res2=max(sumb+calb,suma);\\n        return max(res1,res2);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int maxSubArraySum(vector<int> a)\\n    {  int size=a.size();\\n       int max_so_far = a[0];\\n       int curr_max = a[0];\\n\\n       for (int i = 1; i < size; i++)\\n       {\\n            curr_max = max(a[i], curr_max+a[i]);\\n            max_so_far = max(max_so_far, curr_max);\\n       }\\n       return max_so_far;\\n    }\\n    \\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n     \\n        vector<int> veca(nums1.size());\\n        vector<int> vecb(nums1.size());\\n        \\n        int suma=0;\\n        int sumb=0;\\n        \\n        for(int i=0;i<nums1.size();i=i+1)\\n        {\\n            veca[i]=-nums1[i]+nums2[i];\\n            vecb[i]=nums1[i]-nums2[i];\\n            suma=suma+nums1[i];\\n            sumb=sumb+nums2[i];\\n        }\\n        \\n        int cala=maxSubArraySum(veca);\\n        int calb=maxSubArraySum(vecb);\\n        int res1=max(suma+cala,suma);\\n        int res2=max(sumb+calb,suma);\\n        return max(res1,res2);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198514,
                "title": "doubt-can-we-use-ternary-search",
                "content": "For every index ```i```, can we apply a ternary search on index for ```l=0```, ```r=i```. to o find the left boundary of subarray. As per my intution, the function will be either concave upward or downward. Can the function have more than 1 point of (maximum/minimum) for each ```i```?\\n\\nI received a WA for this approach.\\nHere is my code:-\\n```\\nint maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size();\\n        vector<int>pre1(n,0);\\n        vector<int>pre2(n,0);\\n        pre1[0]=nums1[0];\\n        pre2[0]=nums2[0];\\n        for(int i=1;i<n;i++){\\n            pre1[i]=pre1[i-1]+nums1[i];\\n            pre2[i]=pre2[i-1]+nums2[i];\\n        }\\n        int maxval=max(pre1[n-1],pre2[n-1]);\\n        for(int i=0;i<n;i++){\\n            int l=0;\\n            int r=i;\\n            while(r-l>=3){\\n                int m1=l+(r-l)/3;\\n                int m2=r-(r-l)/3;\\n                int num1=pre1[n-1]-(pre1[i]-pre1[m1]+nums1[m1])+(pre2[i]-pre2[m1]+nums2[m1]);\\n                int num2=pre1[n-1]-(pre1[i]-pre1[m2]+nums1[m2])+(pre2[i]-pre2[m2]+nums2[m2]);\\n                if(num2>num1){\\n                    l=m1;\\n                }\\n                else{\\n                    r=m2;\\n                }\\n            }\\n            int ans=max(pre1[n-1]-(nums1[i])+(nums2[i]),pre1[n-1]-(pre1[i]-pre1[0]+nums1[0])+(pre2[i]-pre2[0]+nums2[0]));\\n            for(int j=l;j<=r;j++){\\n               ans=max(ans,pre1[n-1]-(pre1[i]-pre1[j]+nums1[j])+(pre2[i]-pre2[j]+nums2[j]));\\n            }\\n            maxval=max(ans,maxval);\\n        }\\n        for(int i=0;i<n;i++){\\n            int l=0;\\n            int r=i;\\n            while(r-l>=3){\\n                int m1=l+(r-l)/3;\\n                int m2=r-(r-l)/3;\\n                int num1=pre2[n-1]-(pre2[i]-pre2[m1]+nums2[m1])+(pre1[i]-pre1[m1]+nums1[m1]);\\n                int num2=pre2[n-1]-(pre2[i]-pre2[m2]+nums2[m2])+(pre1[i]-pre1[m2]+nums1[m2]);\\n                if(num2>num1){\\n                    l=m1;\\n                }\\n                else{\\n                    r=m2;\\n                }\\n            }\\n            int ans=max(pre2[n-1]-(nums2[i])+(nums1[i]),pre2[n-1]-(pre2[i]-pre2[0]+nums2[0])+(pre1[i]-pre1[0]+nums1[0]));\\n            for(int j=l;j<=r;j++){\\n               ans=max(ans,pre2[n-1]-(pre2[i]-pre2[j]+nums2[j])+(pre1[i]-pre1[j]+nums1[j]));\\n            }\\n            maxval=max(ans,maxval);\\n        }\\n        return maxval;\\n    } \\n\\t```\\n\\tPlease answer my query. :\\')",
                "solutionTags": [],
                "code": "```i```\n```l=0```\n```r=i```\n```i```\n```\\nint maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size();\\n        vector<int>pre1(n,0);\\n        vector<int>pre2(n,0);\\n        pre1[0]=nums1[0];\\n        pre2[0]=nums2[0];\\n        for(int i=1;i<n;i++){\\n            pre1[i]=pre1[i-1]+nums1[i];\\n            pre2[i]=pre2[i-1]+nums2[i];\\n        }\\n        int maxval=max(pre1[n-1],pre2[n-1]);\\n        for(int i=0;i<n;i++){\\n            int l=0;\\n            int r=i;\\n            while(r-l>=3){\\n                int m1=l+(r-l)/3;\\n                int m2=r-(r-l)/3;\\n                int num1=pre1[n-1]-(pre1[i]-pre1[m1]+nums1[m1])+(pre2[i]-pre2[m1]+nums2[m1]);\\n                int num2=pre1[n-1]-(pre1[i]-pre1[m2]+nums1[m2])+(pre2[i]-pre2[m2]+nums2[m2]);\\n                if(num2>num1){\\n                    l=m1;\\n                }\\n                else{\\n                    r=m2;\\n                }\\n            }\\n            int ans=max(pre1[n-1]-(nums1[i])+(nums2[i]),pre1[n-1]-(pre1[i]-pre1[0]+nums1[0])+(pre2[i]-pre2[0]+nums2[0]));\\n            for(int j=l;j<=r;j++){\\n               ans=max(ans,pre1[n-1]-(pre1[i]-pre1[j]+nums1[j])+(pre2[i]-pre2[j]+nums2[j]));\\n            }\\n            maxval=max(ans,maxval);\\n        }\\n        for(int i=0;i<n;i++){\\n            int l=0;\\n            int r=i;\\n            while(r-l>=3){\\n                int m1=l+(r-l)/3;\\n                int m2=r-(r-l)/3;\\n                int num1=pre2[n-1]-(pre2[i]-pre2[m1]+nums2[m1])+(pre1[i]-pre1[m1]+nums1[m1]);\\n                int num2=pre2[n-1]-(pre2[i]-pre2[m2]+nums2[m2])+(pre1[i]-pre1[m2]+nums1[m2]);\\n                if(num2>num1){\\n                    l=m1;\\n                }\\n                else{\\n                    r=m2;\\n                }\\n            }\\n            int ans=max(pre2[n-1]-(nums2[i])+(nums1[i]),pre2[n-1]-(pre2[i]-pre2[0]+nums2[0])+(pre1[i]-pre1[0]+nums1[0]));\\n            for(int j=l;j<=r;j++){\\n               ans=max(ans,pre2[n-1]-(pre2[i]-pre2[j]+nums2[j])+(pre1[i]-pre1[j]+nums1[j]));\\n            }\\n            maxval=max(ans,maxval);\\n        }\\n        return maxval;\\n    } \\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2198411,
                "title": "javascript-minimum-subarray",
                "content": "```js\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nconst maximumsSplicedArray = function (nums1, nums2) {\\n  const arr = nums1.map((num, index) => num - nums2[index])\\n  const arr2 = nums2.map((num, index) => num - nums1[index])\\n\\n  const minSubArray = function (nums) {\\n    let max = Infinity\\n    let currentMax = Infinity\\n    for (let i = 0; i < nums.length; i++) {\\n      currentMax = Math.min(\\n        currentMax + nums[i],\\n        nums[i],\\n      )\\n      max = Math.min(max, currentMax)\\n    }\\n    return max\\n  }\\n  const sum1 = nums1.reduce((a, b) => a + b)\\n  const sum2 = nums2.reduce((a, b) => a + b)\\n  const min = minSubArray(arr)\\n  const min2 = minSubArray(arr2)\\n  return Math.max(\\n    sum1,\\n    sum2,\\n    min < 0 ? sum1 + Math.abs(min) : sum1,\\n    min2 < 0 ? sum2 + Math.abs(min2) : sum2,\\n  )\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```js\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nconst maximumsSplicedArray = function (nums1, nums2) {\\n  const arr = nums1.map((num, index) => num - nums2[index])\\n  const arr2 = nums2.map((num, index) => num - nums1[index])\\n\\n  const minSubArray = function (nums) {\\n    let max = Infinity\\n    let currentMax = Infinity\\n    for (let i = 0; i < nums.length; i++) {\\n      currentMax = Math.min(\\n        currentMax + nums[i],\\n        nums[i],\\n      )\\n      max = Math.min(max, currentMax)\\n    }\\n    return max\\n  }\\n  const sum1 = nums1.reduce((a, b) => a + b)\\n  const sum2 = nums2.reduce((a, b) => a + b)\\n  const min = minSubArray(arr)\\n  const min2 = minSubArray(arr2)\\n  return Math.max(\\n    sum1,\\n    sum2,\\n    min < 0 ? sum1 + Math.abs(min) : sum1,\\n    min2 < 0 ? sum2 + Math.abs(min2) : sum2,\\n  )\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2198353,
                "title": "python-simple-solution-modified-subarray-sum-approach",
                "content": "```\\nclass Solution:\\n    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n        n = len(nums1)\\n        diff = [0]*n\\n        for i in range(n):\\n            diff[i] = nums1[i]-nums2[i]\\n        mpos,mneg,pos,neg = 0,0,0,0\\n        for i in range(n):\\n            pos += diff[i]\\n            if pos < 0:\\n                pos = 0\\n            neg += diff[i]\\n            if neg > 0:\\n                neg = 0\\n            mpos = max(pos,mpos)\\n            mneg = min(neg,mneg)\\n        return max(sum(nums1)-mneg,sum(nums2)+mpos)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n        n = len(nums1)\\n        diff = [0]*n\\n        for i in range(n):\\n            diff[i] = nums1[i]-nums2[i]\\n        mpos,mneg,pos,neg = 0,0,0,0\\n        for i in range(n):\\n            pos += diff[i]\\n            if pos < 0:\\n                pos = 0\\n            neg += diff[i]\\n            if neg > 0:\\n                neg = 0\\n            mpos = max(pos,mpos)\\n            mneg = min(neg,mneg)\\n        return max(sum(nums1)-mneg,sum(nums2)+mpos)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198287,
                "title": "c-no-kadanes",
                "content": ":Note that you can switch to another array at most 2 times. Just using that in a state of dp we can calulate easy recursive solution.\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[100005][2][3];\\n    vector <array<int, 2>> a;\\n    int f(int i, int which, int tot) {\\n      if (tot > 2) return -10000000;  \\n      if (i == a.size()) return 0;\\n      int &res = dp[i][which][tot];\\n      if (res != -1) {\\n        return res;\\n      }\\n      res = 0;\\n      res = max(res, a[i][which] + f(i + 1, which, tot));\\n      res = max(res, a[i][which^1] + f(i + 1, which^1, tot + 1));\\n      return res;\\n    }\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        memset(dp, -1, sizeof dp);\\n        for (int i = 0; i < nums1.size(); ++i) {\\n          a.push_back({nums1[i], nums2[i]});\\n        }\\n        return max(f(0, 0, 0), f(0, 1, 0));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[100005][2][3];\\n    vector <array<int, 2>> a;\\n    int f(int i, int which, int tot) {\\n      if (tot > 2) return -10000000;  \\n      if (i == a.size()) return 0;\\n      int &res = dp[i][which][tot];\\n      if (res != -1) {\\n        return res;\\n      }\\n      res = 0;\\n      res = max(res, a[i][which] + f(i + 1, which, tot));\\n      res = max(res, a[i][which^1] + f(i + 1, which^1, tot + 1));\\n      return res;\\n    }\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        memset(dp, -1, sizeof dp);\\n        for (int i = 0; i < nums1.size(); ++i) {\\n          a.push_back({nums1[i], nums2[i]});\\n        }\\n        return max(f(0, 0, 0), f(0, 1, 0));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198279,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int sum=0,count=0,ans=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {            \\n            sum+=nums[i];\\n            \\n            ans=max(ans,sum);\\n            if(sum<0)\\n            {\\n                sum=0;\\n            }\\n            \\n           \\n        }\\n        return ans;\\n    }\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        vector<int> v1=nums1;\\n        vector<int> v2=nums2;\\n        \\n        int n=nums1.size();\\n        \\n        int sum1=0,sum2=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            sum1+=nums1[i];\\n            sum2+=nums2[i];\\n            \\n            nums2[i]-=nums1[i];\\n        }\\n        \\n        \\n        int res1=sum1+maxSubArray(nums2);\\n        \\n        \\n        nums2=v2;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            nums1[i]-=nums2[i];\\n        }\\n        \\n        int res2=sum2+maxSubArray(nums1);\\n        \\n        return max(res1,res2);\\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int sum=0,count=0,ans=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {            \\n            sum+=nums[i];\\n            \\n            ans=max(ans,sum);\\n            if(sum<0)\\n            {\\n                sum=0;\\n            }\\n            \\n           \\n        }\\n        return ans;\\n    }\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        vector<int> v1=nums1;\\n        vector<int> v2=nums2;\\n        \\n        int n=nums1.size();\\n        \\n        int sum1=0,sum2=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            sum1+=nums1[i];\\n            sum2+=nums2[i];\\n            \\n            nums2[i]-=nums1[i];\\n        }\\n        \\n        \\n        int res1=sum1+maxSubArray(nums2);\\n        \\n        \\n        nums2=v2;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            nums1[i]-=nums2[i];\\n        }\\n        \\n        int res2=sum2+maxSubArray(nums1);\\n        \\n        return max(res1,res2);\\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198241,
                "title": "c-o-n-kadane",
                "content": "```C++\\nclass Solution {\\n    int helper(vector<int>& A, vector<int>& B) {\\n        int ma = 0, sum = accumulate(begin(A), end(A), 0), n = A.size();\\n        for(int i = 0, kadane = 0; i < n; i++) {\\n            kadane = max(kadane + B[i] - A[i], B[i] - A[i]);\\n            ma = max(ma, kadane);\\n        }\\n        return sum + ma;\\n    }\\npublic:\\n    int maximumsSplicedArray(vector<int>& A, vector<int>& B) {\\n        return max(helper(A, B), helper(B, A));\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\n    int helper(vector<int>& A, vector<int>& B) {\\n        int ma = 0, sum = accumulate(begin(A), end(A), 0), n = A.size();\\n        for(int i = 0, kadane = 0; i < n; i++) {\\n            kadane = max(kadane + B[i] - A[i], B[i] - A[i]);\\n            ma = max(ma, kadane);\\n        }\\n        return sum + ma;\\n    }\\npublic:\\n    int maximumsSplicedArray(vector<int>& A, vector<int>& B) {\\n        return max(helper(A, B), helper(B, A));\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198222,
                "title": "python-easy-solution-kadanes-algo-o-n-time-complexity",
                "content": "```\\nclass Solution:\\n    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n        diff = [0]*len(nums1)\\n        s1,s2=0,0\\n        for i in range(len(nums1)):\\n            diff[i] = nums1[i]-nums2[i] \\n            s1+=nums1[i]\\n            s2+=nums2[i]\\n        mneg,mpos,neg,pos = 0,0,0,0 \\n        for i in range(len(nums1)):\\n            neg+=diff[i]\\n            pos+=diff[i] \\n            if neg>0:\\n                neg = 0 \\n            if pos<0:\\n                pos = 0 \\n            mpos = max(pos,mpos)\\n            mneg = min(neg,mneg)\\n        return max(s1-mneg,s2+mpos)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n        diff = [0]*len(nums1)\\n        s1,s2=0,0\\n        for i in range(len(nums1)):\\n            diff[i] = nums1[i]-nums2[i] \\n            s1+=nums1[i]\\n            s2+=nums2[i]\\n        mneg,mpos,neg,pos = 0,0,0,0 \\n        for i in range(len(nums1)):\\n            neg+=diff[i]\\n            pos+=diff[i] \\n            if neg>0:\\n                neg = 0 \\n            if pos<0:\\n                pos = 0 \\n            mpos = max(pos,mpos)\\n            mneg = min(neg,mneg)\\n        return max(s1-mneg,s2+mpos)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198217,
                "title": "c-kadane-algorithm",
                "content": "```\\nint maxKadane(vector<int>& nums) {\\n        int sum=0,ans=INT_MIN;\\n        for(auto &x: nums){\\n            sum+=x;\\n            ans = max(ans,sum);\\n            if(sum < 0){\\n                sum = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n    int minKadane(vector<int>& nums) {\\n        int sum=0,ans=INT_MAX;\\n        for(auto &x: nums){\\n            sum+=x;\\n            ans = min(ans,sum);\\n            if(sum > 0){\\n                sum = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int>diff;\\n        int n = nums1.size(),sum1=0,sum2=0;\\n        for(int i=0;i<n;i++){\\n            diff.push_back(nums2[i]-nums1[i]);\\n            sum1 += nums1[i];\\n            sum2 += nums2[i];\\n        }\\n        int maxDiff = max(0,maxKadane(diff));\\n        int minDiff = min(0,minKadane(diff));\\n        return max(sum1+ maxDiff, sum2-minDiff);\\n        \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint maxKadane(vector<int>& nums) {\\n        int sum=0,ans=INT_MIN;\\n        for(auto &x: nums){\\n            sum+=x;\\n            ans = max(ans,sum);\\n            if(sum < 0){\\n                sum = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n    int minKadane(vector<int>& nums) {\\n        int sum=0,ans=INT_MAX;\\n        for(auto &x: nums){\\n            sum+=x;\\n            ans = min(ans,sum);\\n            if(sum > 0){\\n                sum = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int>diff;\\n        int n = nums1.size(),sum1=0,sum2=0;\\n        for(int i=0;i<n;i++){\\n            diff.push_back(nums2[i]-nums1[i]);\\n            sum1 += nums1[i];\\n            sum2 += nums2[i];\\n        }\\n        int maxDiff = max(0,maxKadane(diff));\\n        int minDiff = min(0,minKadane(diff));\\n        return max(sum1+ maxDiff, sum2-minDiff);\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2198158,
                "title": "c-easy-kadanes-dp",
                "content": "Just find diff of 2 arrays, find maximum sum subarray and add it to current sum of array\\ndo it twice each form nums1 and nums2\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    int helper(vector<int>&dp){\\n         int temp = dp[0];\\n        int mx = dp[0];\\n        for(int i = 1; i < dp.size();i++){\\n            temp += dp[i];\\n            if(temp < dp[i]){\\n                temp = dp[i];\\n            }\\n            mx = max(mx,temp);\\n        }\\n        return mx;\\n    }\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> dp(nums1.size(),0);\\n        int s1 = 0; // nums1 sum\\n        int s2 = 0; // nums2 sum\\n        for(int i = 0;i < nums1.size();i++){\\n            s1+=nums1[i];\\n            s2+=nums2[i];\\n            dp[i] = nums1[i] - nums2[i];\\n        }\\n       int mx1 = helper(dp);\\n        for(int i = 0; i < dp.size();i++){\\n            dp[i]*=-1;\\n        }\\n        int mx2 = helper(dp);\\n        if(mx1 > 0){\\n            s2+=mx1;\\n        }\\n        if(mx2 > 0){\\n            s1+=mx2;\\n        }\\n        return max(s1,s2);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    int helper(vector<int>&dp){\\n         int temp = dp[0];\\n        int mx = dp[0];\\n        for(int i = 1; i < dp.size();i++){\\n            temp += dp[i];\\n            if(temp < dp[i]){\\n                temp = dp[i];\\n            }\\n            mx = max(mx,temp);\\n        }\\n        return mx;\\n    }\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> dp(nums1.size(),0);\\n        int s1 = 0; // nums1 sum\\n        int s2 = 0; // nums2 sum\\n        for(int i = 0;i < nums1.size();i++){\\n            s1+=nums1[i];\\n            s2+=nums2[i];\\n            dp[i] = nums1[i] - nums2[i];\\n        }\\n       int mx1 = helper(dp);\\n        for(int i = 0; i < dp.size();i++){\\n            dp[i]*=-1;\\n        }\\n        int mx2 = helper(dp);\\n        if(mx1 > 0){\\n            s2+=mx1;\\n        }\\n        if(mx2 > 0){\\n            s1+=mx2;\\n        }\\n        return max(s1,s2);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198116,
                "title": "python-o-n-maximum-subarray",
                "content": "The question is the same as https://leetcode.com/problems/maximum-subarray, the only difference is: it applies on the difference between nums1 and nums2\\n\\n```python\\n    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n        # get maximum sub array of nums\\n        def maxSub(nums):\\n            cur = mx = nums[0]\\n            for num in nums[1:]:\\n                cur = max(num, cur + num)\\n                mx = max(mx, cur)\\n            return mx\\n        \\n        arr = [nums1[i]-nums2[i] for i in range(len(nums1))]\\n        arr2 = [nums2[i]-nums1[i] for i in range(len(nums1))]\\n        \\n        s1, s2 = sum(nums1), sum(nums2)\\n        return max(s1 + maxSub(arr2), s2 + maxSub(arr), s1, s2)\\n```\\n\\nor no additional memory:\\n\\n```python\\n    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n        N = len(nums1)\\n        mx = mn = nums1[0]-nums2[0]\\n        cur_mx, cur_mn = mx, mn\\n        for i in range(1, N):\\n            diff = nums1[i]-nums2[i]\\n            cur_mx = max(diff, cur_mx + diff)\\n            mx = max(mx, cur_mx)\\n            \\n            cur_mn = min(diff, cur_mn + diff)\\n            mn = min(mn, cur_mn)\\n            \\n        s1, s2 = sum(nums1), sum(nums2)\\n        return max(s1 - mn, s2 + mx, s1, s2)\\n```",
                "solutionTags": [],
                "code": "```python\\n    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n        # get maximum sub array of nums\\n        def maxSub(nums):\\n            cur = mx = nums[0]\\n            for num in nums[1:]:\\n                cur = max(num, cur + num)\\n                mx = max(mx, cur)\\n            return mx\\n        \\n        arr = [nums1[i]-nums2[i] for i in range(len(nums1))]\\n        arr2 = [nums2[i]-nums1[i] for i in range(len(nums1))]\\n        \\n        s1, s2 = sum(nums1), sum(nums2)\\n        return max(s1 + maxSub(arr2), s2 + maxSub(arr), s1, s2)\\n```\n```python\\n    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n        N = len(nums1)\\n        mx = mn = nums1[0]-nums2[0]\\n        cur_mx, cur_mn = mx, mn\\n        for i in range(1, N):\\n            diff = nums1[i]-nums2[i]\\n            cur_mx = max(diff, cur_mx + diff)\\n            mx = max(mx, cur_mx)\\n            \\n            cur_mn = min(diff, cur_mn + diff)\\n            mn = min(mn, cur_mn)\\n            \\n        s1, s2 = sum(nums1), sum(nums2)\\n        return max(s1 - mn, s2 + mx, s1, s2)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4068830,
                "title": "c-double-kadane-s-algorithm",
                "content": "**Code:-**\\n```\\nclass Solution \\n{\\n    public:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) \\n    {\\n\\t\\t//sum of the elements of nums1\\n        int sum1=accumulate(nums1.begin(),nums1.end(),0);\\n\\t\\t\\n\\t\\t//sum of the elements of nums2\\n        int sum2=accumulate(nums2.begin(),nums2.end(),0);\\n\\t\\t\\n        int sum=0,maxSum=0;\\n        int ans=max(sum1,sum2);\\n\\t\\t\\n\\t\\t//maximized array sum of nums1\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            sum+=nums2[i]-nums1[i];\\n            if(sum<0)\\n                sum=0;\\n            maxSum=max(maxSum,sum);\\n        }\\n        ans=max(ans,sum1+maxSum);\\n        sum=0,maxSum=0;\\n\\t\\t\\n\\t\\t//maximized array sum of nums2\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            sum+=nums1[i]-nums2[i];\\n            if(sum<0)\\n                sum=0;\\n            maxSum=max(maxSum,sum);\\n        }\\n        ans=max(ans,sum2+maxSum);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) \\n    {\\n\\t\\t//sum of the elements of nums1\\n        int sum1=accumulate(nums1.begin(),nums1.end(),0);\\n\\t\\t\\n\\t\\t//sum of the elements of nums2\\n        int sum2=accumulate(nums2.begin(),nums2.end(),0);\\n\\t\\t\\n        int sum=0,maxSum=0;\\n        int ans=max(sum1,sum2);\\n\\t\\t\\n\\t\\t//maximized array sum of nums1\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            sum+=nums2[i]-nums1[i];\\n            if(sum<0)\\n                sum=0;\\n            maxSum=max(maxSum,sum);\\n        }\\n        ans=max(ans,sum1+maxSum);\\n        sum=0,maxSum=0;\\n\\t\\t\\n\\t\\t//maximized array sum of nums2\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            sum+=nums1[i]-nums2[i];\\n            if(sum<0)\\n                sum=0;\\n            maxSum=max(maxSum,sum);\\n        }\\n        ans=max(ans,sum2+maxSum);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055695,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kadane(vector<int>arr)\\n    {\\n        int ans=INT_MIN;\\n        int cur=0;\\n        for (int i=0;i<arr.size();i++)\\n        {\\n            cur+=arr[i];\\n            if (cur>ans)\\n            {\\n                ans=cur;\\n            }\\n            if (cur<0)\\n            cur=0;\\n        }\\n        return ans;\\n    }\\n    int calculate(vector<int>&a,vector<int>&b)\\n    {\\n        vector<int>diff;\\n        for (int i=0;i<b.size();i++)\\n        {\\n            diff.push_back(b[i]-a[i]);\\n        }\\n        return kadane(diff);\\n    }\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        int sum1=0;\\n        int sum2=0;\\n        for (int i=0;i<nums1.size();i++)\\n        {\\n            sum1+=nums1[i];\\n            sum2+=nums2[i];\\n        }\\n        sum1+=calculate(nums1,nums2);\\n        sum2+=calculate(nums2,nums1);\\n        return max(sum1,sum2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kadane(vector<int>arr)\\n    {\\n        int ans=INT_MIN;\\n        int cur=0;\\n        for (int i=0;i<arr.size();i++)\\n        {\\n            cur+=arr[i];\\n            if (cur>ans)\\n            {\\n                ans=cur;\\n            }\\n            if (cur<0)\\n            cur=0;\\n        }\\n        return ans;\\n    }\\n    int calculate(vector<int>&a,vector<int>&b)\\n    {\\n        vector<int>diff;\\n        for (int i=0;i<b.size();i++)\\n        {\\n            diff.push_back(b[i]-a[i]);\\n        }\\n        return kadane(diff);\\n    }\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        int sum1=0;\\n        int sum2=0;\\n        for (int i=0;i<nums1.size();i++)\\n        {\\n            sum1+=nums1[i];\\n            sum2+=nums2[i];\\n        }\\n        sum1+=calculate(nums1,nums2);\\n        sum2+=calculate(nums2,nums1);\\n        return max(sum1,sum2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038938,
                "title": "dp-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int index,int t,vector<vector<int>>&dp,vector<int>&v1,vector<int>&v2){\\n        if(index>=v1.size()) return 0;\\n        if(dp[index][t]!=-1) return dp[index][t];\\n        if(t==0){\\n            int e1=max(v1[index]+solve(index+1,t,dp,v1,v2),v1[index]+solve(index+1,1,dp,v1,v2));\\n            dp[index][t]=e1;\\n        }\\n        if(t==1){\\n            int e2=max(v2[index]+solve(index+1,t,dp,v1,v2),v2[index]+solve(index+1,2,dp,v1,v2));\\n            dp[index][t]=e2;\\n        }\\n        if(t==2){\\n            int e2=v1[index]+solve(index+1,t,dp,v1,v2);\\n            dp[index][t]=e2;\\n        }\\n        return dp[index][t];\\n    }\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size();\\n        vector<vector<int>>dp1(n,vector<int>(3,-1));\\n        int k1=solve(0,0,dp1,nums1,nums2);\\n        vector<vector<int>>dp2(n,vector<int>(3,-1));\\n        int k2=solve(0,0,dp2,nums2,nums1);\\n        return max(k1,k2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int index,int t,vector<vector<int>>&dp,vector<int>&v1,vector<int>&v2){\\n        if(index>=v1.size()) return 0;\\n        if(dp[index][t]!=-1) return dp[index][t];\\n        if(t==0){\\n            int e1=max(v1[index]+solve(index+1,t,dp,v1,v2),v1[index]+solve(index+1,1,dp,v1,v2));\\n            dp[index][t]=e1;\\n        }\\n        if(t==1){\\n            int e2=max(v2[index]+solve(index+1,t,dp,v1,v2),v2[index]+solve(index+1,2,dp,v1,v2));\\n            dp[index][t]=e2;\\n        }\\n        if(t==2){\\n            int e2=v1[index]+solve(index+1,t,dp,v1,v2);\\n            dp[index][t]=e2;\\n        }\\n        return dp[index][t];\\n    }\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size();\\n        vector<vector<int>>dp1(n,vector<int>(3,-1));\\n        int k1=solve(0,0,dp1,nums1,nums2);\\n        vector<vector<int>>dp2(n,vector<int>(3,-1));\\n        int k2=solve(0,0,dp2,nums2,nums1);\\n        return max(k1,k2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972057,
                "title": "just-simple-dp-with-tracking-of-where-to-start-the-swap-and-end-the-swap-for-each-vector-separately",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n8*1e5\\n\\n- Space complexity:\\n2*1e5*4(can be reduced to order 1 but not necessary)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp1[100100][2][2];\\n    int dp2[100100][2][2];\\n    int rec1(int pos,int started,int ended,vector<int>&nums1,vector<int>&nums2){\\n        if(pos==nums1.size())return 0;\\n        int ans=0;\\n        if(dp1[pos][started][ended]!=-1)return dp1[pos][started][ended];\\n        if(started==0 && ended==0){\\n            ans=max(ans,nums1[pos]+rec1(pos+1,0,0,nums1,nums2));\\n            ans=max(ans,nums2[pos]+rec1(pos+1,1,0,nums1,nums2));\\n            ans=max(ans,nums2[pos]+rec1(pos+1,1,1,nums1,nums2));\\n        }else if(started==1 && ended==0){\\n            ans=max(ans,nums2[pos]+rec1(pos+1,1,0,nums1,nums2));\\n            ans=max(ans,nums2[pos]+rec1(pos+1,1,1,nums1,nums2));\\n        }else if(started==1&&ended==1){\\n            ans=max(ans,nums1[pos]+rec1(pos+1,1,1,nums1,nums2));\\n        }\\n        return dp1[pos][started][ended]=ans;\\n    }\\n    int rec2(int pos,int started,int ended,vector<int>&nums1,vector<int>&nums2){\\n        if(pos==nums2.size())return 0;\\n        int ans=0;\\n        if(dp2[pos][started][ended]!=-1)return dp2[pos][started][ended];\\n        if(started==0 && ended==0){\\n            ans=max(ans,nums2[pos]+rec2(pos+1,0,0,nums1,nums2));\\n            ans=max(ans,nums1[pos]+rec2(pos+1,1,0,nums1,nums2));\\n            ans=max(ans,nums1[pos]+rec2(pos+1,1,1,nums1,nums2));\\n        }else if(started==1 && ended==0){\\n            ans=max(ans,nums1[pos]+rec2(pos+1,1,0,nums1,nums2));\\n            ans=max(ans,nums1[pos]+rec2(pos+1,1,1,nums1,nums2));\\n        }else if(started==1&&ended==1){\\n            ans=max(ans,nums2[pos]+rec2(pos+1,1,1,nums1,nums2));\\n        }\\n        return dp2[pos][started][ended]=ans;\\n    }\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        memset(dp1,-1,sizeof(dp1));\\n        memset(dp2,-1,sizeof(dp2));\\n        return max(rec1(0,0,0,nums1,nums2),rec2(0,0,0,nums1,nums2));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp1[100100][2][2];\\n    int dp2[100100][2][2];\\n    int rec1(int pos,int started,int ended,vector<int>&nums1,vector<int>&nums2){\\n        if(pos==nums1.size())return 0;\\n        int ans=0;\\n        if(dp1[pos][started][ended]!=-1)return dp1[pos][started][ended];\\n        if(started==0 && ended==0){\\n            ans=max(ans,nums1[pos]+rec1(pos+1,0,0,nums1,nums2));\\n            ans=max(ans,nums2[pos]+rec1(pos+1,1,0,nums1,nums2));\\n            ans=max(ans,nums2[pos]+rec1(pos+1,1,1,nums1,nums2));\\n        }else if(started==1 && ended==0){\\n            ans=max(ans,nums2[pos]+rec1(pos+1,1,0,nums1,nums2));\\n            ans=max(ans,nums2[pos]+rec1(pos+1,1,1,nums1,nums2));\\n        }else if(started==1&&ended==1){\\n            ans=max(ans,nums1[pos]+rec1(pos+1,1,1,nums1,nums2));\\n        }\\n        return dp1[pos][started][ended]=ans;\\n    }\\n    int rec2(int pos,int started,int ended,vector<int>&nums1,vector<int>&nums2){\\n        if(pos==nums2.size())return 0;\\n        int ans=0;\\n        if(dp2[pos][started][ended]!=-1)return dp2[pos][started][ended];\\n        if(started==0 && ended==0){\\n            ans=max(ans,nums2[pos]+rec2(pos+1,0,0,nums1,nums2));\\n            ans=max(ans,nums1[pos]+rec2(pos+1,1,0,nums1,nums2));\\n            ans=max(ans,nums1[pos]+rec2(pos+1,1,1,nums1,nums2));\\n        }else if(started==1 && ended==0){\\n            ans=max(ans,nums1[pos]+rec2(pos+1,1,0,nums1,nums2));\\n            ans=max(ans,nums1[pos]+rec2(pos+1,1,1,nums1,nums2));\\n        }else if(started==1&&ended==1){\\n            ans=max(ans,nums2[pos]+rec2(pos+1,1,1,nums1,nums2));\\n        }\\n        return dp2[pos][started][ended]=ans;\\n    }\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        memset(dp1,-1,sizeof(dp1));\\n        memset(dp2,-1,sizeof(dp2));\\n        return max(rec1(0,0,0,nums1,nums2),rec2(0,0,0,nums1,nums2));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915269,
                "title": "c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        // Intution\\n        // The idea in here is really very simple. We will do two pass kadane\\'s algorithm to find the answer.\\n        // We will find the sum of both the arrays and then to change the subarray from i to j of nums1 with nums2 then we need to find the maximum subarray such that the difference is maximum and similarly the opposite way as well.\\n\\n        int sum1 = 0;\\n        int sum2 = 0;\\n\\n        for(auto num : nums1) sum1 += num;\\n        for(auto num : nums2) sum2 += num;\\n\\n        int first   = 0;\\n        int second  = 0;\\n\\n        int maxFirst  = 0;\\n        int maxSecond = 0;\\n\\n        int size = nums1.size();\\n\\n        for(int i = 0 ; i < size ; i++){\\n            first += (nums2[i] - nums1[i]);\\n            second += (nums1[i] - nums2[i]);\\n\\n            maxFirst = max(maxFirst, first);\\n            maxSecond = max(maxSecond, second);\\n\\n            if(first < 0) first = 0;\\n            if(second < 0) second = 0;\\n        }\\n\\n\\n        return max({maxFirst + sum1, maxSecond + sum2, sum1, sum2});\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        // Intution\\n        // The idea in here is really very simple. We will do two pass kadane\\'s algorithm to find the answer.\\n        // We will find the sum of both the arrays and then to change the subarray from i to j of nums1 with nums2 then we need to find the maximum subarray such that the difference is maximum and similarly the opposite way as well.\\n\\n        int sum1 = 0;\\n        int sum2 = 0;\\n\\n        for(auto num : nums1) sum1 += num;\\n        for(auto num : nums2) sum2 += num;\\n\\n        int first   = 0;\\n        int second  = 0;\\n\\n        int maxFirst  = 0;\\n        int maxSecond = 0;\\n\\n        int size = nums1.size();\\n\\n        for(int i = 0 ; i < size ; i++){\\n            first += (nums2[i] - nums1[i]);\\n            second += (nums1[i] - nums2[i]);\\n\\n            maxFirst = max(maxFirst, first);\\n            maxSecond = max(maxSecond, second);\\n\\n            if(first < 0) first = 0;\\n            if(second < 0) second = 0;\\n        }\\n\\n\\n        return max({maxFirst + sum1, maxSecond + sum2, sum1, sum2});\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3907160,
                "title": "simple-c-kadane-algorithm",
                "content": "HINT:find differences of elements in both arrays\\nand find minimum subarray sum \\n# Code\\n```\\nclass Solution {\\npublic:\\nint f(vector<int>&a,vector<int>&b){\\n    int s=0;\\n    for(auto it:a)s+=it;\\n    int mini=0,sum=0;\\n    for(int i=0;i<a.size();i++){\\n        int c=a[i]-b[i];\\n        sum+=c;\\n        if(sum>0)sum=0;\\n        mini=min(mini,sum);\\n    }\\n    return s-mini;\\n}\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n       int c=f(nums1,nums2);\\n       int d=f(nums2,nums1);\\n       return max(c,d);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint f(vector<int>&a,vector<int>&b){\\n    int s=0;\\n    for(auto it:a)s+=it;\\n    int mini=0,sum=0;\\n    for(int i=0;i<a.size();i++){\\n        int c=a[i]-b[i];\\n        sum+=c;\\n        if(sum>0)sum=0;\\n        mini=min(mini,sum);\\n    }\\n    return s-mini;\\n}\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n       int c=f(nums1,nums2);\\n       int d=f(nums2,nums1);\\n       return max(c,d);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3895994,
                "title": "easy-o-n-solution-using-kadane-s-algo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int kadane (vector<int>&v){\\n       int n = v.size();\\n       int cursum =0;\\n       int maxsum =0;\\n       for (auto it: v){\\n         cursum +=it;\\n         if(cursum<0) cursum =0;\\n         maxsum = max (maxsum, cursum);\\n\\n       }\\n       return maxsum;\\n   }\\n    \\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n       int n = nums1.size();\\n       // get a df array and get its max val \\n       int sum1 =0;\\n       int sum2 =0;\\n       for (auto it: nums1) sum1+=it;\\n       for (auto it: nums2) sum2 +=it;\\n       vector<int> diff(n);\\n       for (int i=0;i<n;i++){\\n           diff[i]= nums2[i]- nums1[i];\\n       }\\n       int val = kadane(diff);\\n       int ans =0;\\n       ans = max (ans, sum1+val);\\n       for(int i=0;i<n;i++)\\n        diff[i] *=-1;\\n        val = kadane(diff);\\n        ans = max (ans, sum2+val);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int kadane (vector<int>&v){\\n       int n = v.size();\\n       int cursum =0;\\n       int maxsum =0;\\n       for (auto it: v){\\n         cursum +=it;\\n         if(cursum<0) cursum =0;\\n         maxsum = max (maxsum, cursum);\\n\\n       }\\n       return maxsum;\\n   }\\n    \\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n       int n = nums1.size();\\n       // get a df array and get its max val \\n       int sum1 =0;\\n       int sum2 =0;\\n       for (auto it: nums1) sum1+=it;\\n       for (auto it: nums2) sum2 +=it;\\n       vector<int> diff(n);\\n       for (int i=0;i<n;i++){\\n           diff[i]= nums2[i]- nums1[i];\\n       }\\n       int val = kadane(diff);\\n       int ans =0;\\n       ans = max (ans, sum1+val);\\n       for(int i=0;i<n;i++)\\n        diff[i] *=-1;\\n        val = kadane(diff);\\n        ans = max (ans, sum2+val);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847443,
                "title": "c-kadane-s-algorithm-double-kadane-dp-beats-100-simplest-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nInstead of 4 loops i.e. o(4n), it can be done in 1 paas i.e. o(n).\\nFor understanding and clarity, different steps are done in separate loops.\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int i,j,n=nums1.size(),s1=0,s2=0,tmp1=0,tmp2=0,mx1=0,mx2=0;\\n        for(auto it:nums1) s1+=it;\\n        for(auto it:nums2) s2+=it;\\n        //cout<<s1<<\" \"<<s2<<endl;\\n        for(i=0;i<n;i++)\\n        {\\n            tmp1+=nums2[i]-nums1[i];\\n            mx1=max(mx1,tmp1);\\n            //cout<<tmp1<<endl;\\n            if(tmp1<0)\\n            tmp1=0;\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            tmp2+=nums1[i]-nums2[i];\\n            mx2=max(mx2,tmp2);\\n            //cout<<tmp2<<endl;\\n            if(tmp2<0)\\n            tmp2=0;\\n        }\\n        return max(s1+mx1,s2+mx2);        \\n    }\\n};\\n\\nUsing 1 loop :\\n\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int i,j,n=nums1.size(),s1=0,s2=0,tmp1=0,tmp2=0,mx1=0,mx2=0;\\n        for(i=0;i<n;i++)\\n        {\\n            s1+=nums1[i];\\n            s2+=nums2[i];\\n\\n            tmp1+=nums2[i]-nums1[i];\\n            mx1=max(mx1,tmp1);\\n            if(tmp1<0)\\n            tmp1=0;\\n            \\n            tmp2+=nums1[i]-nums2[i];\\n            mx2=max(mx2,tmp2);\\n            if(tmp2<0)\\n            tmp2=0;\\n        }\\n        return max(s1+mx1,s2+mx2);        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int i,j,n=nums1.size(),s1=0,s2=0,tmp1=0,tmp2=0,mx1=0,mx2=0;\\n        for(auto it:nums1) s1+=it;\\n        for(auto it:nums2) s2+=it;\\n        //cout<<s1<<\" \"<<s2<<endl;\\n        for(i=0;i<n;i++)\\n        {\\n            tmp1+=nums2[i]-nums1[i];\\n            mx1=max(mx1,tmp1);\\n            //cout<<tmp1<<endl;\\n            if(tmp1<0)\\n            tmp1=0;\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            tmp2+=nums1[i]-nums2[i];\\n            mx2=max(mx2,tmp2);\\n            //cout<<tmp2<<endl;\\n            if(tmp2<0)\\n            tmp2=0;\\n        }\\n        return max(s1+mx1,s2+mx2);        \\n    }\\n};\\n\\nUsing 1 loop :\\n\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int i,j,n=nums1.size(),s1=0,s2=0,tmp1=0,tmp2=0,mx1=0,mx2=0;\\n        for(i=0;i<n;i++)\\n        {\\n            s1+=nums1[i];\\n            s2+=nums2[i];\\n\\n            tmp1+=nums2[i]-nums1[i];\\n            mx1=max(mx1,tmp1);\\n            if(tmp1<0)\\n            tmp1=0;\\n            \\n            tmp2+=nums1[i]-nums2[i];\\n            mx2=max(mx2,tmp2);\\n            if(tmp2<0)\\n            tmp2=0;\\n        }\\n        return max(s1+mx1,s2+mx2);        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3826115,
                "title": "python-100-prefix-sum-approach",
                "content": "# Intuition\\nThe idea is that we want to have one array with the largest possible sum. WLOG, if we assume for a given test case that swapping a section of nums2 into nums1 and summing over the new nums1 gives the optimal solution, this section that we swap will be the section where the difference (nums2[left,right] - nums1[left,right]) is the largest. This is because this means nums1 will get the largest increase possible in value with this section.\\n\\nOnce we get this maximum difference sum, we can add it to the sum(nums1) to get the maximum score.\\n\\n# Approach\\nSince it is possible that the optimal solution involves swapping nums1 into nums2 or vice versa, in our solution we will track the largest increase possible moving a section from nums1 to nums2 and vice versa. \\n\\nThis involves finding the maximum subarray sum for (nums2[left,right] - nums1[left,right]) and (nums1[left,right] - nums2[left,right]), which is another DP problem. This can be achieved by tracking a prefix sum that resets to 0 if it goes negative. Once we get these two values, our answer will be the maximum between (sum(nums1) + max increase swapping from nums2 to nums1) and (sum(nums2)+max increase swapping from nums1 to nums2).\\n\\n# Complexity\\n- Time complexity:\\nO(n) single pass\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n        fsum, ssum = 0, 0\\n        pc, nc = 0, 0 # all-time maxes. this is for n1-n2 and n2-n1 respectively\\n        cpc, cnc = 0, 0 # current values\\n        for i in range(len(nums1)):\\n            ssum += nums2[i]\\n            fsum += nums1[i]\\n            if (nums2[i]-nums1[i] + cnc) < 0:\\n                cnc = 0\\n            else:\\n                cnc += nums2[i]-nums1[i]\\n                nc = max(nc, cnc)\\n            if (nums1[i]-nums2[i] + cpc) < 0:\\n                cpc = 0\\n            else:\\n                cpc += nums1[i] - nums2[i]\\n                pc = max(pc, cpc)\\n        return max(fsum+nc, ssum+pc)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n        fsum, ssum = 0, 0\\n        pc, nc = 0, 0 # all-time maxes. this is for n1-n2 and n2-n1 respectively\\n        cpc, cnc = 0, 0 # current values\\n        for i in range(len(nums1)):\\n            ssum += nums2[i]\\n            fsum += nums1[i]\\n            if (nums2[i]-nums1[i] + cnc) < 0:\\n                cnc = 0\\n            else:\\n                cnc += nums2[i]-nums1[i]\\n                nc = max(nc, cnc)\\n            if (nums1[i]-nums2[i] + cpc) < 0:\\n                cpc = 0\\n            else:\\n                cpc += nums1[i] - nums2[i]\\n                pc = max(pc, cpc)\\n        return max(fsum+nc, ssum+pc)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764044,
                "title": "c-python-max-subarray-sum-solution-with-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/96170a05-6e26-4ee2-8edd-cb0e54d3d5ac_1689335358.3878765.png)\\ntc is O(n), sc is O(1)\\n### python\\n```python\\nclass Solution:\\n    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n\\t\\t\\n\\t\\t# solve(arr1, arr2) return max subarray sum > 0 of diff array of arr1 and arr2\\n        def solve(arr1, arr2):\\n            max_ = 0\\n            cur = 0\\n            for v1, v2 in zip(arr1, arr2):\\n                v = v1 - v2\\n                cur = cur + v if cur + v > v else v\\n                if cur > max_: max_ = cur\\n            return max_ \\n\\t\\t\\t\\n\\t\\t# sum of nums1 - subarray sum of nums1 + take a subarray from nums2\\n\\t\\t# or sum of nums2 - subarray sum of nums2 + take a subarray from nums1\\n        return max(sum(nums1) + solve(nums2, nums1), sum(nums2) + solve(nums1, nums2))\\n```\\n\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        auto solve = [] (vector<int>& arr1, vector<int>& arr2) -> int {\\n            int max = 0;\\n            int cur = 0;\\n            for (int i = 0, v; i < arr1.size(); i++) {\\n                v = arr1[i] - arr2[i];\\n                cur = cur + v > v ? cur + v: v;\\n                if (cur > max) max = cur;\\n            }\\n            return max;\\n        };\\n        return max(accumulate(nums1.begin(), nums1.end(), 0) + solve(nums2, nums1), accumulate(nums2.begin(), nums2.end(), 0) + solve(nums1, nums2));\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n\\t\\t\\n\\t\\t# solve(arr1, arr2) return max subarray sum > 0 of diff array of arr1 and arr2\\n        def solve(arr1, arr2):\\n            max_ = 0\\n            cur = 0\\n            for v1, v2 in zip(arr1, arr2):\\n                v = v1 - v2\\n                cur = cur + v if cur + v > v else v\\n                if cur > max_: max_ = cur\\n            return max_ \\n\\t\\t\\t\\n\\t\\t# sum of nums1 - subarray sum of nums1 + take a subarray from nums2\\n\\t\\t# or sum of nums2 - subarray sum of nums2 + take a subarray from nums1\\n        return max(sum(nums1) + solve(nums2, nums1), sum(nums2) + solve(nums1, nums2))\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        auto solve = [] (vector<int>& arr1, vector<int>& arr2) -> int {\\n            int max = 0;\\n            int cur = 0;\\n            for (int i = 0, v; i < arr1.size(); i++) {\\n                v = arr1[i] - arr2[i];\\n                cur = cur + v > v ? cur + v: v;\\n                if (cur > max) max = cur;\\n            }\\n            return max;\\n        };\\n        return max(accumulate(nums1.begin(), nums1.end(), 0) + solve(nums2, nums1), accumulate(nums2.begin(), nums2.end(), 0) + solve(nums1, nums2));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753291,
                "title": "concise-dynamic-programming-solution-with-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n * @lc app=leetcode id=2321 lang=cpp\\n *\\n * [2321] Maximum Score Of Spliced Array\\n */\\n\\n// @lc code=start\\n#include <vector>\\nusing namespace std;\\nclass Solution {\\n   public:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        /* DP\\n        Def:\\n            dp[0][i]: the maximum sum of `nums1` with subarray ending at nums1[i] (nums1[?:i]) swapped with `nums2`\\n            dp[1][i]: the maximum sum of `nums2` with subarray ending at nums2[i] (nums2[?:i]) swapped with `nums1`\\n        Transition:\\n            sum_1, sum_2\\n            dp[0][i] = (nums2[i] - nums1[i]) + max(sum_1,      # start a new subarray\\n                                                   dp[0][i-1]) # continuously the subarray\\n            dp[1][i] = (nums1[i] - nums2[i]) + max(sum_2,      # start a new subarray\\n                                                   dp[1][i-1]) # continuously the subarray\\n        */\\n        int dp[2];\\n        auto sum_1 = dp[0] = accumulate(nums1.begin(), nums1.end(), 0);\\n        auto sum_2 = dp[1] = accumulate(nums2.begin(), nums2.end(), 0);\\n        int max_score = max(sum_1, sum_2);\\n\\n        for (int i = 0; i < nums1.size() ; ++i){\\n            auto tmp_0 = (nums2[i] - nums1[i]) + max(sum_1, dp[0]);\\n            auto tmp_1 = (nums1[i] - nums2[i]) + max(sum_2, dp[1]);\\n            dp[0] = tmp_0;\\n            dp[1] = tmp_1;\\n            max_score = max(max_score, max(dp[0], dp[1]));\\n        }\\n\\n        return max_score;\\n    }\\n};\\n// @lc code=end\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\n/*\\n * @lc app=leetcode id=2321 lang=cpp\\n *\\n * [2321] Maximum Score Of Spliced Array\\n */\\n\\n// @lc code=start\\n#include <vector>\\nusing namespace std;\\nclass Solution {\\n   public:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        /* DP\\n        Def:\\n            dp[0][i]: the maximum sum of `nums1` with subarray ending at nums1[i] (nums1[?:i]) swapped with `nums2`\\n            dp[1][i]: the maximum sum of `nums2` with subarray ending at nums2[i] (nums2[?:i]) swapped with `nums1`\\n        Transition:\\n            sum_1, sum_2\\n            dp[0][i] = (nums2[i] - nums1[i]) + max(sum_1,      # start a new subarray\\n                                                   dp[0][i-1]) # continuously the subarray\\n            dp[1][i] = (nums1[i] - nums2[i]) + max(sum_2,      # start a new subarray\\n                                                   dp[1][i-1]) # continuously the subarray\\n        */\\n        int dp[2];\\n        auto sum_1 = dp[0] = accumulate(nums1.begin(), nums1.end(), 0);\\n        auto sum_2 = dp[1] = accumulate(nums2.begin(), nums2.end(), 0);\\n        int max_score = max(sum_1, sum_2);\\n\\n        for (int i = 0; i < nums1.size() ; ++i){\\n            auto tmp_0 = (nums2[i] - nums1[i]) + max(sum_1, dp[0]);\\n            auto tmp_1 = (nums1[i] - nums2[i]) + max(sum_2, dp[1]);\\n            dp[0] = tmp_0;\\n            dp[1] = tmp_1;\\n            max_score = max(max_score, max(dp[0], dp[1]));\\n        }\\n\\n        return max_score;\\n    }\\n};\\n// @lc code=end\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3742183,
                "title": "using-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n int fun(int i,int taken,vector<int>&v,vector<int>&v1,int total,vector<vector<int>>&dp){\\n     if(i>=v.size()) return 0;\\n     if(dp[i][taken]!=-1) return dp[i][taken];\\n     int ans=0;\\n     if(taken==0){\\n     ans=max(fun(i+1,taken,v,v1,total,dp),v1[i]-v[i]+fun(i+1,taken+1,v,v1,total,dp));\\n     }\\n     else if(taken==1){\\n      ans=max(fun(i+1,taken+1,v,v1,total,dp),v1[i]-v[i]+fun(i+1,taken,v,v1,total,dp));\\n     }\\n     return dp[i][taken]=ans;\\n     \\n }\\nint maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int total=0,total1=0,n=nums1.size();\\n        vector<vector<int>>dp(n,vector<int>(3,-1));\\n\\n        for(int i=0;i<nums1.size();i++) total+=nums1[i],total1+=nums2[i];\\n\\n        vector<vector<int>>dp1(n,vector<int>(3,-1));\\n      \\n       int val= fun(0,0,nums1,nums2,total,dp);\\n       int val1= fun(0,0,nums2,nums1,total1,dp1);\\n        return max(total+val,total1+val1);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n int fun(int i,int taken,vector<int>&v,vector<int>&v1,int total,vector<vector<int>>&dp){\\n     if(i>=v.size()) return 0;\\n     if(dp[i][taken]!=-1) return dp[i][taken];\\n     int ans=0;\\n     if(taken==0){\\n     ans=max(fun(i+1,taken,v,v1,total,dp),v1[i]-v[i]+fun(i+1,taken+1,v,v1,total,dp));\\n     }\\n     else if(taken==1){\\n      ans=max(fun(i+1,taken+1,v,v1,total,dp),v1[i]-v[i]+fun(i+1,taken,v,v1,total,dp));\\n     }\\n     return dp[i][taken]=ans;\\n     \\n }\\nint maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int total=0,total1=0,n=nums1.size();\\n        vector<vector<int>>dp(n,vector<int>(3,-1));\\n\\n        for(int i=0;i<nums1.size();i++) total+=nums1[i],total1+=nums2[i];\\n\\n        vector<vector<int>>dp1(n,vector<int>(3,-1));\\n      \\n       int val= fun(0,0,nums1,nums2,total,dp);\\n       int val1= fun(0,0,nums2,nums1,total1,dp1);\\n        return max(total+val,total1+val1);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610258,
                "title": "swift-clean-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSweepLine\\nHighLevel Idea: Say after swapped, sum in nums1 was changed into **nums1Sum + diff**, then sum in num2 will be **nums2Sum - diff**.\\n\\nNow we only need to do is: find 2 subarrays from nums1 such that compared to nums2, it could have a maxDiff, and minDiff\\n\\nThen the final result will be max(sum1 + maxDiff, sum2 - minDiff)\\n\\n# Complexity\\n- Time complexity: ON\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O1\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func maximumsSplicedArray(_ nums1: [Int], _ nums2: [Int]) -> Int {\\n        let n = nums1.count\\n        let sum1 = nums1.reduce(0, +)\\n        let sum2 = nums2.reduce(0, +)\\n        if sum1 < sum2 {\\n            return maximumsSplicedArray(nums2, nums1)\\n        }\\n        var maxCur = 0\\n        var minCur = 0\\n        var maxGlobal = 0\\n        var minGlobal = 0\\n\\n        for i in 0..<n {\\n            var curDiff = nums2[i] - nums1[i]\\n            maxCur = maxCur > 0 ? maxCur + curDiff : curDiff\\n            minCur = minCur < 0 ? minCur + curDiff : curDiff\\n\\n            maxGlobal = max(maxCur, maxGlobal)\\n            minGlobal = min(minCur, minGlobal)\\n        }\\n\\n        return max(sum1 + maxGlobal, sum2 - minGlobal)\\n    }\\n}\\n",
                "solutionTags": [
                    "Swift"
                ],
                "code": "class Solution {\\n    func maximumsSplicedArray(_ nums1: [Int], _ nums2: [Int]) -> Int {\\n        let n = nums1.count\\n        let sum1 = nums1.reduce(0, +)\\n        let sum2 = nums2.reduce(0, +)\\n        if sum1 < sum2 {\\n            return maximumsSplicedArray(nums2, nums1)\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3610257,
                "title": "swift-clean-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSweepLine\\nHighLevel Idea: Say after swapped, sum in nums1 was changed into **nums1Sum + diff**, then sum in num2 will be **nums2Sum - diff**.\\n\\nNow we only need to do is: find 2 subarrays from nums1 such that compared to nums2, it could have a maxDiff, and minDiff\\n\\nThen the final result will be max(sum1 + maxDiff, sum2 - minDiff)\\n\\n# Complexity\\n- Time complexity: ON\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O1\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func maximumsSplicedArray(_ nums1: [Int], _ nums2: [Int]) -> Int {\\n        let n = nums1.count\\n        let sum1 = nums1.reduce(0, +)\\n        let sum2 = nums2.reduce(0, +)\\n        if sum1 < sum2 {\\n            return maximumsSplicedArray(nums2, nums1)\\n        }\\n        var maxCur = 0\\n        var minCur = 0\\n        var maxGlobal = 0\\n        var minGlobal = 0\\n\\n        for i in 0..<n {\\n            var curDiff = nums2[i] - nums1[i]\\n            maxCur = maxCur > 0 ? maxCur + curDiff : curDiff\\n            minCur = minCur < 0 ? minCur + curDiff : curDiff\\n\\n            maxGlobal = max(maxCur, maxGlobal)\\n            minGlobal = min(minCur, minGlobal)\\n        }\\n\\n        return max(sum1 + maxGlobal, sum2 - minGlobal)\\n    }\\n}\\n",
                "solutionTags": [
                    "Swift"
                ],
                "code": "class Solution {\\n    func maximumsSplicedArray(_ nums1: [Int], _ nums2: [Int]) -> Int {\\n        let n = nums1.count\\n        let sum1 = nums1.reduce(0, +)\\n        let sum2 = nums2.reduce(0, +)\\n        if sum1 < sum2 {\\n            return maximumsSplicedArray(nums2, nums1)\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3604358,
                "title": "double-kadane-s-algo",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int> &nums1, vector<int> &nums2)\\n{\\n    int sum1 = accumulate(nums1.begin(), nums1.end(), 0);\\n    int sum2 = accumulate(nums2.begin(), nums2.end(), 0);\\n    int n = nums1.size();\\n    vector<int> diff1(n, 0), diff2(n, 0);\\n\\n    for (int i = 0; i < nums1.size(); i++)\\n    {\\n        diff2[i] = nums1[i] - nums2[i];\\n        diff1[i] = nums2[i] - nums1[i];\\n    }\\n\\n    int sum = 0;\\n    int mx = 0;\\n\\n    for (int i = 0; i < n; i++)\\n    {\\n        sum += diff1[i];\\n        mx = max(mx, sum);\\n        if (sum < 0)\\n        {\\n            sum = 0;\\n        }\\n    }\\n\\n    int ans = max(sum1, sum2);\\n    ans = max(ans, sum1 + mx);\\n\\n    mx = 0;\\n    sum = 0;\\n\\n    for (int i = 0; i < n; i++)\\n    {\\n        sum += diff2[i];\\n        mx = max(mx, sum);\\n        if (sum < 0)\\n        {\\n            sum = 0;\\n        }\\n    }\\n    ans = max(ans, sum2 + mx);\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int> &nums1, vector<int> &nums2)\\n{\\n    int sum1 = accumulate(nums1.begin(), nums1.end(), 0);\\n    int sum2 = accumulate(nums2.begin(), nums2.end(), 0);\\n    int n = nums1.size();\\n    vector<int> diff1(n, 0), diff2(n, 0);\\n\\n    for (int i = 0; i < nums1.size(); i++)\\n    {\\n        diff2[i] = nums1[i] - nums2[i];\\n        diff1[i] = nums2[i] - nums1[i];\\n    }\\n\\n    int sum = 0;\\n    int mx = 0;\\n\\n    for (int i = 0; i < n; i++)\\n    {\\n        sum += diff1[i];\\n        mx = max(mx, sum);\\n        if (sum < 0)\\n        {\\n            sum = 0;\\n        }\\n    }\\n\\n    int ans = max(sum1, sum2);\\n    ans = max(ans, sum1 + mx);\\n\\n    mx = 0;\\n    sum = 0;\\n\\n    for (int i = 0; i < n; i++)\\n    {\\n        sum += diff2[i];\\n        mx = max(mx, sum);\\n        if (sum < 0)\\n        {\\n            sum = 0;\\n        }\\n    }\\n    ans = max(ans, sum2 + mx);\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544297,
                "title": "c-easy-solution-kadane",
                "content": "# Complexity\\n- Time complexity:\\n O(N)\\n\\n- Space complexity:\\n O(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaximumsSplicedArray(int[] nums1, int[] nums2) {\\n        int sum1 = 0;\\n        int sum2 = 0;\\n        int curSum1 = 0;\\n        int maxSum1 = 0;\\n        int curSum2 = 0;\\n        int maxSum2 = 0;        \\n\\n\\n        for(int i =0; i<nums1.Length; i++)\\n        {\\n            curSum1 += (nums2[i] - nums1[i]);\\n            curSum2 += (nums1[i] - nums2[i]);\\n\\n            maxSum1 = Math.Max(maxSum1, curSum1);\\n            maxSum2 = Math.Max(maxSum2, curSum2);\\n\\n            if (curSum1 < 0) curSum1 = 0;\\n            if (curSum2 < 0) curSum2 = 0;\\n\\n            sum1 += nums1[i];\\n            sum2 += nums2[i];\\n        }\\n\\n        sum1 = sum1 + maxSum1; \\n        sum2 = sum2 + maxSum2;\\n\\n        return Math.Max(sum1, sum2);  \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaximumsSplicedArray(int[] nums1, int[] nums2) {\\n        int sum1 = 0;\\n        int sum2 = 0;\\n        int curSum1 = 0;\\n        int maxSum1 = 0;\\n        int curSum2 = 0;\\n        int maxSum2 = 0;        \\n\\n\\n        for(int i =0; i<nums1.Length; i++)\\n        {\\n            curSum1 += (nums2[i] - nums1[i]);\\n            curSum2 += (nums1[i] - nums2[i]);\\n\\n            maxSum1 = Math.Max(maxSum1, curSum1);\\n            maxSum2 = Math.Max(maxSum2, curSum2);\\n\\n            if (curSum1 < 0) curSum1 = 0;\\n            if (curSum2 < 0) curSum2 = 0;\\n\\n            sum1 += nums1[i];\\n            sum2 += nums2[i];\\n        }\\n\\n        sum1 = sum1 + maxSum1; \\n        sum2 = sum2 + maxSum2;\\n\\n        return Math.Max(sum1, sum2);  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528700,
                "title": "java-super-simple-o-n-beats-98",
                "content": "class Solution {\\n    \\n    int findMaxInc(int[] nums1, int[] nums2) {\\n        int sum = 0;\\n        int max = 0;\\n        for (int i = 0; i < nums1.length; i++) {\\n            sum += nums2[i] - nums1[i];\\n            if (sum <= 0) { sum = 0; }\\n            else if (sum > max) { max = sum; }\\n        }\\n        return max;\\n    }\\n    \\n    int sum(int[] nums) {\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) sum += nums[i];\\n        return sum;\\n    }\\n    \\n    public int maximumsSplicedArray(int[] nums1, int[] nums2) {\\n        return Math.max(sum(nums1) + findMaxInc(nums1, nums2), sum(nums2) + findMaxInc(nums2, nums1));\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    int findMaxInc(int[] nums1, int[] nums2) {\\n        int sum = 0;\\n        int max = 0;\\n        for (int i = 0; i < nums1.length; i++) {\\n            sum += nums2[i] - nums1[i];\\n            if (sum <= 0) { sum = 0; }",
                "codeTag": "Java"
            },
            {
                "id": 3523897,
                "title": "python3-very-simple-to-understand-kadane-algo-longest-sum-subarray",
                "content": "# Intuition\\n![Screenshot 2023-05-14 at 6.55.16 PM.png](https://assets.leetcode.com/users/images/41fa9524-865b-4d0f-9197-ebeee1cb6a24_1684079082.0600815.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind the largest diff that can be substracted from one array and added to another one using Kadane Algorithm to find longest sum subarray, do it both ways. Finally compare these 2 cases sum with original array sums\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRun Kadane Algo, to find largest diff you can find to cut from nums2 and add in nums1. After we have done this, we would just compare it with original sums. Similarly run Kadane Algo, to find largest diff you can find to cut from nums1 and add in nums2 and repeat the process\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n        n = len(nums1)\\n        nums1_sum = sum(nums1)\\n        nums2_sum = sum(nums2)\\n\\n        final_ans = max(nums1_sum, nums2_sum)\\n\\n        max_diff = 0\\n        max_left, max_right = -1, -1\\n\\n        curr_left, curr_right = 0, 0\\n        curr_diff = 0\\n\\n        while(curr_right < n):\\n            curr_diff += (nums2[curr_right] - nums1[curr_right])\\n            if curr_diff <=0 :\\n                curr_diff = 0\\n                curr_left = curr_right+1\\n            else:\\n                if curr_diff > max_diff:\\n                    max_diff = curr_diff\\n                    max_left = curr_left\\n                    max_right = curr_right\\n            curr_right += 1\\n        \\n        if max_left != -1:\\n            # print(\\'1\\', max_diff, max_left, max_right)\\n            this1_sum = nums1_sum + max_diff\\n            this2_sum = nums2_sum - max_diff\\n            final_ans = max(final_ans, this1_sum, this2_sum)\\n        \\n\\n        max_diff = 0\\n        max_left, max_right = -1, -1\\n\\n        curr_left, curr_right = 0, 0\\n        curr_diff = 0\\n\\n        while(curr_right < n):\\n            curr_diff += (nums1[curr_right] - nums2[curr_right])\\n            if curr_diff <=0 :\\n                curr_diff = 0\\n                curr_left = curr_right+1\\n            else:\\n                if curr_diff > max_diff:\\n                    max_diff = curr_diff\\n                    max_left = curr_left\\n                    max_right = curr_right\\n            curr_right += 1\\n        \\n        if max_left != -1:\\n            # print(\\'2\\', max_diff, max_left, max_right)\\n            this1_sum = nums1_sum - max_diff\\n            this2_sum = nums2_sum + max_diff\\n            final_ans = max(final_ans, this1_sum, this2_sum)\\n        \\n        return final_ans\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n        n = len(nums1)\\n        nums1_sum = sum(nums1)\\n        nums2_sum = sum(nums2)\\n\\n        final_ans = max(nums1_sum, nums2_sum)\\n\\n        max_diff = 0\\n        max_left, max_right = -1, -1\\n\\n        curr_left, curr_right = 0, 0\\n        curr_diff = 0\\n\\n        while(curr_right < n):\\n            curr_diff += (nums2[curr_right] - nums1[curr_right])\\n            if curr_diff <=0 :\\n                curr_diff = 0\\n                curr_left = curr_right+1\\n            else:\\n                if curr_diff > max_diff:\\n                    max_diff = curr_diff\\n                    max_left = curr_left\\n                    max_right = curr_right\\n            curr_right += 1\\n        \\n        if max_left != -1:\\n            # print(\\'1\\', max_diff, max_left, max_right)\\n            this1_sum = nums1_sum + max_diff\\n            this2_sum = nums2_sum - max_diff\\n            final_ans = max(final_ans, this1_sum, this2_sum)\\n        \\n\\n        max_diff = 0\\n        max_left, max_right = -1, -1\\n\\n        curr_left, curr_right = 0, 0\\n        curr_diff = 0\\n\\n        while(curr_right < n):\\n            curr_diff += (nums1[curr_right] - nums2[curr_right])\\n            if curr_diff <=0 :\\n                curr_diff = 0\\n                curr_left = curr_right+1\\n            else:\\n                if curr_diff > max_diff:\\n                    max_diff = curr_diff\\n                    max_left = curr_left\\n                    max_right = curr_right\\n            curr_right += 1\\n        \\n        if max_left != -1:\\n            # print(\\'2\\', max_diff, max_left, max_right)\\n            this1_sum = nums1_sum - max_diff\\n            this2_sum = nums2_sum + max_diff\\n            final_ans = max(final_ans, this1_sum, this2_sum)\\n        \\n        return final_ans\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493171,
                "title": "o-n-simple-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int func(vector<int>& first, vector<int>& second)\\n    {\\n        int n=first.size();\\n        vector<int>left(n,0);\\n        vector<int>right(n,0);\\n        int sum=0;\\n        for(auto it:first)sum+=it;\\n        left[0]=max(0,second[0]-first[0]);\\n        for(int i=1;i<n;i++){\\n            if(second[i]-first[i]+left[i-1]>0)\\n            {\\n                left[i]=second[i]-first[i]+left[i-1];\\n            }\\n        }\\n        right[n-1]=max(0,second[n-1]-first[n-1]);\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(second[i]-first[i]+right[i+1]>0)\\n            {\\n                right[i]=second[i]-first[i]+right[i+1];\\n            }\\n        }\\n        int extra=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int back=0;\\n            int front=0;\\n            if(i-1>=0)back=left[i-1];\\n            if(i+1<n)front=right[i+1];\\n            extra=max(extra,second[i]-first[i]+front+back);\\n        }\\n        return sum+extra;\\n    }\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int ans=max(func(nums1,nums2),func(nums2,nums1));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int func(vector<int>& first, vector<int>& second)\\n    {\\n        int n=first.size();\\n        vector<int>left(n,0);\\n        vector<int>right(n,0);\\n        int sum=0;\\n        for(auto it:first)sum+=it;\\n        left[0]=max(0,second[0]-first[0]);\\n        for(int i=1;i<n;i++){\\n            if(second[i]-first[i]+left[i-1]>0)\\n            {\\n                left[i]=second[i]-first[i]+left[i-1];\\n            }\\n        }\\n        right[n-1]=max(0,second[n-1]-first[n-1]);\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(second[i]-first[i]+right[i+1]>0)\\n            {\\n                right[i]=second[i]-first[i]+right[i+1];\\n            }\\n        }\\n        int extra=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int back=0;\\n            int front=0;\\n            if(i-1>=0)back=left[i-1];\\n            if(i+1<n)front=right[i+1];\\n            extra=max(extra,second[i]-first[i]+front+back);\\n        }\\n        return sum+extra;\\n    }\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int ans=max(func(nums1,nums2),func(nums2,nums1));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469559,
                "title": "c-trivial-o-n-sln-medium-problem-actually",
                "content": "```\\n    int solve(vector<int>& nums1, vector<int>& nums2) {\\n        int ans = 0;\\n        for (int i = 0, sum = 0, minSum = INT_MAX; i < size(nums1); ++i) {\\n            sum += nums2[i] - nums1[i];\\n            minSum = min(sum, minSum);\\n            ans = max(ans, sum - minSum);\\n        }\\n        return accumulate(cbegin(nums1), cend(nums1), 0) + ans;\\n    } \\n\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        return max(solve(nums1, nums2), solve(nums2, nums1));\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    int solve(vector<int>& nums1, vector<int>& nums2) {\\n        int ans = 0;\\n        for (int i = 0, sum = 0, minSum = INT_MAX; i < size(nums1); ++i) {\\n            sum += nums2[i] - nums1[i];\\n            minSum = min(sum, minSum);\\n            ans = max(ans, sum - minSum);\\n        }\\n        return accumulate(cbegin(nums1), cend(nums1), 0) + ans;\\n    } \\n\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        return max(solve(nums1, nums2), solve(nums2, nums1));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3445166,
                "title": "image-explanation-brute-force-better-optimized",
                "content": "\\n\\n# Approach\\n**Brute Force Approach: Time=O(n^3), space= O(1)**\\n<!-- Describe your approach to solving the problem. -->\\n![image.png](https://assets.leetcode.com/users/images/c39e6add-e629-4f62-a4e2-7779471743f9_1682193731.4129095.png)\\n**Better Approach: Time= O(n^2), Space= O(n)**\\n![image.png](https://assets.leetcode.com/users/images/e7a0773d-f772-49cd-bffe-e42cb56af98b_1682193750.4190025.png)\\n**Developing the Optimized approach:**\\n![image.png](https://assets.leetcode.com/users/images/e8460419-edb8-4423-8f9d-d8ee72292777_1682193807.7134604.png)\\n\\n![image.png](https://assets.leetcode.com/users/images/910dbff3-bf9a-4027-91d5-50b6bdc0d616_1682193870.9164088.png)\\n![image.png](https://assets.leetcode.com/users/images/3bf948f1-15b7-449e-878e-041ed83c8a97_1682193892.8515418.png)\\n**The Optimized Approach: Time= O(n), Space= O(1)**\\n![image.png](https://assets.leetcode.com/users/images/cfb5edb7-37ac-4a57-a644-c97d6391f39d_1682193916.7902792.png)\\n**Example by simluation of the algorithm:**\\n![image.png](https://assets.leetcode.com/users/images/1e1b458b-7710-4799-a7c3-48f477a7e18e_1682193941.8641715.png)\\n![image.png](https://assets.leetcode.com/users/images/fd29bd97-9668-41b5-926a-a1fcd6a1e93e_1682194058.5349054.png)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n**Please **UPVOTE** if you have liked my explanation.\\nThank You for reading this.**\\n# Complexity\\n- Time complexity: O(n), n= size of nums1\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n**Brute Force Code:**\\n```\\nclass Solution {\\npublic:\\n    //BRUTE FORCE--Time Complexity= O(n^3), space= O(1)\\n    int sumRange(int i, int j, vector<int> &nums){\\n        int sum=0;\\n        for(int k=i;k<=j;k++)   sum+= nums[k];\\n        return sum;\\n    }\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int maxScore= 0, n= nums1.size(), sum1=0, sum2= 0;\\n\\n        sum1= sumRange(0, n-1, nums1); sum2= sumRange(0,n-1,nums2);\\n        maxScore= max(sum1, sum2);\\n        for(int i=0;i<n;i++){//O(n)\\n            for(int j=i;j<n;j++){//O(n)\\n                // index i to j are to be swapped\\n                int rangeSum1= sumRange(i, j, nums1);//O(n)\\n                int rangeSum2= sumRange(i, j, nums2);//O(n)\\n                maxScore= max(maxScore, max(sum1-rangeSum1+rangeSum2, sum2-rangeSum2+rangeSum1));\\n            }\\n        }\\n        return maxScore;\\n    }\\n};\\n```\\n**Better Approach Code:**\\n```\\nclass Solution {\\npublic:\\n    //Better: remove sumRange() and replace it with prefixSum of num1, num2\\n    //Time= O(n^2), space= O(n) for maintaining prefix sum of nums1, nums2\\n    void CalculatePrefixSum(vector<int>&nums, vector<int>&prefSum){\\n        prefSum[0]= nums[0];\\n        for(int i=1;i<nums.size();i++) prefSum[i]= prefSum[i-1]+nums[i];\\n    }\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int maxScore= 0, n= nums1.size(), sum1=0, sum2= 0;\\n        vector<int> prefSum1(n,0), prefSum2(n,0);\\n        CalculatePrefixSum(nums1, prefSum1); CalculatePrefixSum(nums2, prefSum2);\\n\\n        maxScore= max(prefSum1[n-1], prefSum2[n-1]);\\n        for(int i=0;i<n;i++){//O(n)\\n            for(int j=i;j<n;j++){//O(n)\\n                // index i to j are to be swapped\\n                int sum1= 0;\\n                int sum2= 0;\\n                int r1=0, r2= 0;\\n                if(i-1>=0){\\n                    r1= prefSum1[j]-prefSum1[i-1];\\n                    r2= prefSum2[j]-prefSum2[i-1];\\n                }\\n                sum1= prefSum1[n-1]-r1+ r2; //O(1)\\n                sum2= prefSum2[n-1]-r2+ r1; //O(1)\\n\\n                maxScore= max(maxScore, max(sum1, sum2));\\n            }\\n        }\\n        return maxScore;\\n    }\\n};\\n```\\n**Optimized Approach Code:**\\n```\\nclass Solution {\\npublic:\\n    //OPTIMIZED: Time=O(n), space= O(1)\\n    int findMaxScore(vector<int>&v1, int sum1, vector<int>&v2, int sum2){\\n        int rangeSum1=0, rangeSum2=0, n=v1.size();\\n        cout<<sum1<<\" \"<<sum2;\\n        int maxScore=max(sum1, sum2); //largest sum can also involve no swapping at all,that possibility is also counted in here\\n        for(int i=0;i<n;i++){\\n            rangeSum1+= v1[i]; rangeSum2+= v2[i];\\n            if(rangeSum1<rangeSum2){\\n                maxScore= max(maxScore, sum1+(rangeSum2- rangeSum1));\\n            }\\n            else{\\n                rangeSum1= 0, rangeSum2= 0;\\n            }\\n        }\\n        return maxScore;\\n    }\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int maxScore= 0, n= nums1.size(), sum1=0, sum2= 0;\\n        sum1= accumulate(nums1.begin(), nums1.end(), 0);\\n        sum2= accumulate(nums2.begin(), nums2.end(), 0);\\n       \\n        return max(findMaxScore(nums2, sum2, nums1, sum1), findMaxScore(nums1, sum1, nums2, sum2));\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //BRUTE FORCE--Time Complexity= O(n^3), space= O(1)\\n    int sumRange(int i, int j, vector<int> &nums){\\n        int sum=0;\\n        for(int k=i;k<=j;k++)   sum+= nums[k];\\n        return sum;\\n    }\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int maxScore= 0, n= nums1.size(), sum1=0, sum2= 0;\\n\\n        sum1= sumRange(0, n-1, nums1); sum2= sumRange(0,n-1,nums2);\\n        maxScore= max(sum1, sum2);\\n        for(int i=0;i<n;i++){//O(n)\\n            for(int j=i;j<n;j++){//O(n)\\n                // index i to j are to be swapped\\n                int rangeSum1= sumRange(i, j, nums1);//O(n)\\n                int rangeSum2= sumRange(i, j, nums2);//O(n)\\n                maxScore= max(maxScore, max(sum1-rangeSum1+rangeSum2, sum2-rangeSum2+rangeSum1));\\n            }\\n        }\\n        return maxScore;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    //Better: remove sumRange() and replace it with prefixSum of num1, num2\\n    //Time= O(n^2), space= O(n) for maintaining prefix sum of nums1, nums2\\n    void CalculatePrefixSum(vector<int>&nums, vector<int>&prefSum){\\n        prefSum[0]= nums[0];\\n        for(int i=1;i<nums.size();i++) prefSum[i]= prefSum[i-1]+nums[i];\\n    }\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int maxScore= 0, n= nums1.size(), sum1=0, sum2= 0;\\n        vector<int> prefSum1(n,0), prefSum2(n,0);\\n        CalculatePrefixSum(nums1, prefSum1); CalculatePrefixSum(nums2, prefSum2);\\n\\n        maxScore= max(prefSum1[n-1], prefSum2[n-1]);\\n        for(int i=0;i<n;i++){//O(n)\\n            for(int j=i;j<n;j++){//O(n)\\n                // index i to j are to be swapped\\n                int sum1= 0;\\n                int sum2= 0;\\n                int r1=0, r2= 0;\\n                if(i-1>=0){\\n                    r1= prefSum1[j]-prefSum1[i-1];\\n                    r2= prefSum2[j]-prefSum2[i-1];\\n                }\\n                sum1= prefSum1[n-1]-r1+ r2; //O(1)\\n                sum2= prefSum2[n-1]-r2+ r1; //O(1)\\n\\n                maxScore= max(maxScore, max(sum1, sum2));\\n            }\\n        }\\n        return maxScore;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    //OPTIMIZED: Time=O(n), space= O(1)\\n    int findMaxScore(vector<int>&v1, int sum1, vector<int>&v2, int sum2){\\n        int rangeSum1=0, rangeSum2=0, n=v1.size();\\n        cout<<sum1<<\" \"<<sum2;\\n        int maxScore=max(sum1, sum2); //largest sum can also involve no swapping at all,that possibility is also counted in here\\n        for(int i=0;i<n;i++){\\n            rangeSum1+= v1[i]; rangeSum2+= v2[i];\\n            if(rangeSum1<rangeSum2){\\n                maxScore= max(maxScore, sum1+(rangeSum2- rangeSum1));\\n            }\\n            else{\\n                rangeSum1= 0, rangeSum2= 0;\\n            }\\n        }\\n        return maxScore;\\n    }\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int maxScore= 0, n= nums1.size(), sum1=0, sum2= 0;\\n        sum1= accumulate(nums1.begin(), nums1.end(), 0);\\n        sum2= accumulate(nums2.begin(), nums2.end(), 0);\\n       \\n        return max(findMaxScore(nums2, sum2, nums1, sum1), findMaxScore(nums1, sum1, nums2, sum2));\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3440708,
                "title": "simple-and-fast-c-solution-t-c-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust thought of greedy approach and kadane algorithm\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int sum1=0;\\n        int sum2=0;\\n       for(auto i:nums1){\\n           sum1+=i;\\n       } \\n       for(auto i:nums2){\\n           sum2+=i;\\n       }\\n          int max_sum = max(sum1,sum2);\\n       \\n           int i = 0;\\n           int sum = sum1;int sum3 =sum1;\\n           while(i<nums1.size()){\\n               if(nums2[i]>nums1[i]){\\n                   sum3-=nums1[i];sum-=nums1[i];\\n                   sum3+=nums2[i];sum+=nums2[i];\\n                   max_sum =max(max_sum,max(sum,sum3));\\n               }else{\\n                   sum3 = sum1;\\n                   sum+=nums2[i];sum-=nums1[i];\\n                   if(sum<sum1)sum=sum1;\\n               }\\n               i++;\\n           }\\n           i = 0;\\n           sum = sum2;sum3 =sum2;\\n           while(i<nums2.size()){\\n               if(nums1[i]>nums2[i]){\\n                   sum3-=nums2[i]; sum-=nums2[i];\\n                   sum3+=nums1[i];sum+=nums1[i];\\n                   max_sum =max(max_sum,max(sum,sum3));\\n               }else{\\n                   sum3 = sum2;\\n                   sum+=nums1[i]; sum-=nums2[i];\\n                   if(sum<sum2)sum=sum2;\\n               }\\n               i++;\\n           }\\n       \\n       return max_sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int sum1=0;\\n        int sum2=0;\\n       for(auto i:nums1){\\n           sum1+=i;\\n       } \\n       for(auto i:nums2){\\n           sum2+=i;\\n       }\\n          int max_sum = max(sum1,sum2);\\n       \\n           int i = 0;\\n           int sum = sum1;int sum3 =sum1;\\n           while(i<nums1.size()){\\n               if(nums2[i]>nums1[i]){\\n                   sum3-=nums1[i];sum-=nums1[i];\\n                   sum3+=nums2[i];sum+=nums2[i];\\n                   max_sum =max(max_sum,max(sum,sum3));\\n               }else{\\n                   sum3 = sum1;\\n                   sum+=nums2[i];sum-=nums1[i];\\n                   if(sum<sum1)sum=sum1;\\n               }\\n               i++;\\n           }\\n           i = 0;\\n           sum = sum2;sum3 =sum2;\\n           while(i<nums2.size()){\\n               if(nums1[i]>nums2[i]){\\n                   sum3-=nums2[i]; sum-=nums2[i];\\n                   sum3+=nums1[i];sum+=nums1[i];\\n                   max_sum =max(max_sum,max(sum,sum3));\\n               }else{\\n                   sum3 = sum2;\\n                   sum+=nums1[i]; sum-=nums2[i];\\n                   if(sum<sum2)sum=sum2;\\n               }\\n               i++;\\n           }\\n       \\n       return max_sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416908,
                "title": "java-kadane-easy-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//final_nums1 = sum(nums1) + (nums2[l : r] - nums1[l : r]);\\n//final_nums2 = sum(nums2) + (nums1[1 : r] - nums2[l : r]);\\n//ans = Math.max(final_nums1, final_nums2);\\n//?max()\\n\\nclass Solution {\\n    public int maximumsSplicedArray(int[] nums1, int[] nums2) {\\n        int[] gap1_2 = new int[nums1.length];\\n        int[] gap2_1 = new int[nums2.length];\\n        int sum1 = 0;\\n        int sum2 = 0;\\n        for(int i = 0; i < nums1.length; i++){\\n            gap1_2[i] = nums1[i] - nums2[i];\\n            gap2_1[i] = nums2[i] - nums1[i];\\n            sum1 += nums1[i];\\n            sum2 += nums2[i];\\n        }\\n\\n        int gap1 = 0;\\n        int gap2 = 0;\\n        int max1 = 0;\\n        int max2 = 0;\\n        for(int i = 0; i < nums1.length; i++){\\n            if(gap1 < 0){\\n                gap1 = gap1_2[i];\\n            }\\n            else{\\n                gap1 = gap1 + gap1_2[i];\\n            }\\n            if(gap2 < 0){\\n                gap2 = gap2_1[i];\\n            }\\n            else{\\n                gap2 = gap2 + gap2_1[i];\\n            }\\n            max1 = Math.max(max1, gap1);\\n            max2 = Math.max(max2, gap2);\\n        }\\n        return (Math.max(sum1+max2, sum2+max1));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//final_nums1 = sum(nums1) + (nums2[l : r] - nums1[l : r]);\\n//final_nums2 = sum(nums2) + (nums1[1 : r] - nums2[l : r]);\\n//ans = Math.max(final_nums1, final_nums2);\\n//?max()\\n\\nclass Solution {\\n    public int maximumsSplicedArray(int[] nums1, int[] nums2) {\\n        int[] gap1_2 = new int[nums1.length];\\n        int[] gap2_1 = new int[nums2.length];\\n        int sum1 = 0;\\n        int sum2 = 0;\\n        for(int i = 0; i < nums1.length; i++){\\n            gap1_2[i] = nums1[i] - nums2[i];\\n            gap2_1[i] = nums2[i] - nums1[i];\\n            sum1 += nums1[i];\\n            sum2 += nums2[i];\\n        }\\n\\n        int gap1 = 0;\\n        int gap2 = 0;\\n        int max1 = 0;\\n        int max2 = 0;\\n        for(int i = 0; i < nums1.length; i++){\\n            if(gap1 < 0){\\n                gap1 = gap1_2[i];\\n            }\\n            else{\\n                gap1 = gap1 + gap1_2[i];\\n            }\\n            if(gap2 < 0){\\n                gap2 = gap2_1[i];\\n            }\\n            else{\\n                gap2 = gap2 + gap2_1[i];\\n            }\\n            max1 = Math.max(max1, gap1);\\n            max2 = Math.max(max2, gap2);\\n        }\\n        return (Math.max(sum1+max2, sum2+max1));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416136,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size() ;\\n        int sum1 = accumulate(nums1.begin(), nums1.end(), 0) ;\\n        int sum2 = accumulate(nums2.begin(), nums2.end(), 0) ;\\n        vector<int>diff(n) ;\\n        for(int i = 0; i < n; i++)\\n            diff[i] = nums1[i] - nums2[i] ;\\n        int maximum = 0 ;\\n        int preSum = 0;\\n        for(int i = 0; i < n; i++){\\n            preSum += diff[i] ;\\n            if(preSum < 0)\\n                preSum = 0 ;\\n            maximum = max(maximum, preSum) ;\\n        }\\n        int ret = sum2 + maximum ;\\n        \\n        for(int i = 0; i < n; i++)\\n            diff[i] = nums2[i] - nums1[i] ;\\n        maximum = 0 ;\\n        preSum = 0;\\n        for(int i = 0; i < n; i++){\\n            preSum += diff[i] ;\\n            if(preSum < 0)\\n                preSum = 0 ;\\n            maximum = max(maximum, preSum) ;\\n        }\\n        ret = max(ret, sum1 + maximum) ;\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size() ;\\n        int sum1 = accumulate(nums1.begin(), nums1.end(), 0) ;\\n        int sum2 = accumulate(nums2.begin(), nums2.end(), 0) ;\\n        vector<int>diff(n) ;\\n        for(int i = 0; i < n; i++)\\n            diff[i] = nums1[i] - nums2[i] ;\\n        int maximum = 0 ;\\n        int preSum = 0;\\n        for(int i = 0; i < n; i++){\\n            preSum += diff[i] ;\\n            if(preSum < 0)\\n                preSum = 0 ;\\n            maximum = max(maximum, preSum) ;\\n        }\\n        int ret = sum2 + maximum ;\\n        \\n        for(int i = 0; i < n; i++)\\n            diff[i] = nums2[i] - nums1[i] ;\\n        maximum = 0 ;\\n        preSum = 0;\\n        for(int i = 0; i < n; i++){\\n            preSum += diff[i] ;\\n            if(preSum < 0)\\n                preSum = 0 ;\\n            maximum = max(maximum, preSum) ;\\n        }\\n        ret = max(ret, sum1 + maximum) ;\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238969,
                "title": "dp-simple-state",
                "content": "<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nez states \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndef s(nums1,nums2):\\n    n=len(nums1)\\n    dp=[[0,0,0] for i in range(n)]\\n    #no swap has swapped already will swap now\\n    dp[0]=[nums1[0],nums2[0],nums2[0]]\\n    for i in range(1,n):\\n        dp[i][0]=dp[i-1][0]+nums1[i]\\n        dp[i][1]=max(dp[i-1][1],dp[i-1][2])+nums1[i]\\n        dp[i][2]=max(dp[i-1][0],dp[i-1][2])+nums2[i]\\n    return dp\\nclass Solution:\\n    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n        dp1=s(nums1,nums2)\\n        dp2=s(nums2,nums1)\\n        return max(max(dp1[-1]),max(dp2[-1]))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef s(nums1,nums2):\\n    n=len(nums1)\\n    dp=[[0,0,0] for i in range(n)]\\n    #no swap has swapped already will swap now\\n    dp[0]=[nums1[0],nums2[0],nums2[0]]\\n    for i in range(1,n):\\n        dp[i][0]=dp[i-1][0]+nums1[i]\\n        dp[i][1]=max(dp[i-1][1],dp[i-1][2])+nums1[i]\\n        dp[i][2]=max(dp[i-1][0],dp[i-1][2])+nums2[i]\\n    return dp\\nclass Solution:\\n    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n        dp1=s(nums1,nums2)\\n        dp2=s(nums2,nums1)\\n        return max(max(dp1[-1]),max(dp2[-1]))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207050,
                "title": "python-simple-kadane",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def kadane(self,nums):\\n        max_sum_so_far, max_ending_here = nums[0], nums[0]\\n\\n        for i in nums[1:]:\\n            max_ending_here = max(max_ending_here+i,i)\\n            max_sum_so_far = max(max_sum_so_far,max_ending_here)\\n\\n        return max_sum_so_far\\n\\n    def maximumsSplicedArray(self, nums1, nums2):\\n        res1, res2 = [i-j for i,j in zip(nums1,nums2)], [j-i for i,j in zip(nums1,nums2)]\\n        return max(sum(nums1) + self.kadane(res2),sum(nums2) + self.kadane(res1))\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kadane(self,nums):\\n        max_sum_so_far, max_ending_here = nums[0], nums[0]\\n\\n        for i in nums[1:]:\\n            max_ending_here = max(max_ending_here+i,i)\\n            max_sum_so_far = max(max_sum_so_far,max_ending_here)\\n\\n        return max_sum_so_far\\n\\n    def maximumsSplicedArray(self, nums1, nums2):\\n        res1, res2 = [i-j for i,j in zip(nums1,nums2)], [j-i for i,j in zip(nums1,nums2)]\\n        return max(sum(nums1) + self.kadane(res2),sum(nums2) + self.kadane(res1))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3195087,
                "title": "easy-o-1-space-solution",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMax(vector<int>& nums1,vector<int>& nums2,int sum1,int sum2){\\n        int n=nums1.size();\\n        int ans=0;\\n        int r=0;\\n        while(r<n){\\n            int tmp1=0,tmp2=0;\\n            while(r<n && tmp1<=tmp2){\\n                tmp1+=nums1[r];\\n                tmp2+=nums2[r];\\n                ans=max(ans,sum1-tmp1+tmp2);\\n                r++;\\n            }\\n        }\\n        return ans;\\n    }\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size();\\n        int sum1=0,sum2=0;\\n        for(int i=0;i<n;i++){\\n            sum1+=nums1[i];\\n            sum2+=nums2[i];\\n        }\\n        int ans=max(sum1,sum2);\\n        return max({ans,getMax(nums1,nums2,sum1,sum2),getMax(nums2,nums1,sum2,sum1)});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMax(vector<int>& nums1,vector<int>& nums2,int sum1,int sum2){\\n        int n=nums1.size();\\n        int ans=0;\\n        int r=0;\\n        while(r<n){\\n            int tmp1=0,tmp2=0;\\n            while(r<n && tmp1<=tmp2){\\n                tmp1+=nums1[r];\\n                tmp2+=nums2[r];\\n                ans=max(ans,sum1-tmp1+tmp2);\\n                r++;\\n            }\\n        }\\n        return ans;\\n    }\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size();\\n        int sum1=0,sum2=0;\\n        for(int i=0;i<n;i++){\\n            sum1+=nums1[i];\\n            sum2+=nums2[i];\\n        }\\n        int ans=max(sum1,sum2);\\n        return max({ans,getMax(nums1,nums2,sum1,sum2),getMax(nums2,nums1,sum2,sum1)});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3128508,
                "title": "with-explanation-clean-kadane-algorithm-c-a",
                "content": "# Intuition\\n## Requirement: `find max(sum(arr1), sum(arr2))` after swapping subarray\\n\\nDenote arr1\\' as arr1 after swapping, and arr2\\' as arr2 after swapping\\n### Observation: After swapping, sum(arr1\\') = sum(arr1) + sum(`swapped Subarray2`) - sum(`swapped Subarray1`)\\n\\n### Therefore, the question is asking: `max(sum(arr1\\'), sum(arr2\\'))`\\n=> max(`sum(arr1) + sum(swapped Subarray2) - sum(swapped Subarray1)`, \\n`sum(arr2) - sum(swapped Subarray2) + sum(swapped Subarray1)`)\\n\\n### Notice sum(arr1) and sum(arr2) is fixed after we do a precompute, which we could denote as x1, x2. Then we get:\\n=> max(`x1 + sum(swapped Subarray2) - sum(swapped Subarray1)`, `x2 - sum(swapped Subarray2) + sum(swapped Subarray1)`)\\nDenote delta = `sum(swapped Subarray2) - sum(swapped Subarray1)`\\n=> We get: max(`x1 + delta`, `x2 - delta`)\\n\\n### So how should we get delta? Since we want to get max for answer\\n- for adding x1, we want to find the largest delta\\n- for adding x2, we want to find the smallest delta\\n\\n### Since delta = sum(swapped Subarray2) - sum(swapped Subarray1)\\n=> delta = `arr2[left:right]` - `arr1[left:right]`\\n=> delta = `arr2[left]` - `arr1[left]` + ... + `arr2[right]` - `arr1[right]`\\nIf we create a difference array which equal arr2[i] - arr1[i] for index i\\n=> delta = `diff[left:right]`\\n\\n### By using Kadane algorithm, we could quickly find the largest and smallest delta\\n\\n# As a result, max(`x1 + delta`, `x2 - delta`) could be find using the following algorithm\\n1. Precompute sum of arr1 and arr2 \\n2. Create a diff array, where index i = `arr2[i]` - `arr1[i]`\\n3. Use Kadane algorithm to find largest and smallest subarray for diff array\\n4. return max(`sum(arr1) + max(delta)`, `sum(arr2) - min(delta)`) \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> diff(nums1.size(), 0);\\n        int sum1(0), sum2(0), posMax(0), posMin(0), tmpMax(0), tmpMin(0);\\n        for (int i = 0; i < nums1.size(); ++i){\\n            diff[i] = nums2[i] - nums1[i];\\n            sum1 += nums1[i];\\n            sum2 += nums2[i];\\n        }\\n\\n        for (int i = 0; i < nums1.size(); ++i){\\n            tmpMax = max(0, tmpMax + diff[i]);\\n            tmpMin = min(0, tmpMin + diff[i]);\\n            posMax = max(posMax, tmpMax);\\n            posMin = min(tmpMin, posMin);\\n        }\\n\\n        return max(abs(sum1 + posMax), abs(sum2 - posMin));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int> diff(nums1.size(), 0);\\n        int sum1(0), sum2(0), posMax(0), posMin(0), tmpMax(0), tmpMin(0);\\n        for (int i = 0; i < nums1.size(); ++i){\\n            diff[i] = nums2[i] - nums1[i];\\n            sum1 += nums1[i];\\n            sum2 += nums2[i];\\n        }\\n\\n        for (int i = 0; i < nums1.size(); ++i){\\n            tmpMax = max(0, tmpMax + diff[i]);\\n            tmpMin = min(0, tmpMin + diff[i]);\\n            posMax = max(posMax, tmpMax);\\n            posMin = min(tmpMin, posMin);\\n        }\\n\\n        return max(abs(sum1 + posMax), abs(sum2 - posMin));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3123208,
                "title": "c-fast-kadane-algo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& nums1, vector<int>& nums2)\\n    {\\n        int n=nums1.size();\\n        vector<int> diff(n);\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            diff[i]=nums2[i]-nums1[i];\\n            sum+=nums1[i];\\n        }\\n\\n        int maxi=0;\\n        int sum1=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum1=max(sum1+diff[i],diff[i]);\\n            maxi=max(maxi,sum1);\\n        }\\n        return sum+maxi;\\n    }\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        return max(solve(nums1,nums2),solve(nums2,nums1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& nums1, vector<int>& nums2)\\n    {\\n        int n=nums1.size();\\n        vector<int> diff(n);\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            diff[i]=nums2[i]-nums1[i];\\n            sum+=nums1[i];\\n        }\\n\\n        int maxi=0;\\n        int sum1=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum1=max(sum1+diff[i],diff[i]);\\n            maxi=max(maxi,sum1);\\n        }\\n        return sum+maxi;\\n    }\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        return max(solve(nums1,nums2),solve(nums2,nums1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3064673,
                "title": "96-17-faster-kadane-c-simple-clean-short",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n\\n    ll kadne(vector<ll>&container,ll n){\\n        ll sum=0,answer=INT_MIN;\\n        for(ll i=0;i<n;i++){\\n            sum+=container[i];\\n            answer=max(answer,sum);\\n            if(sum<0){\\n                sum=0;\\n            }\\n        }\\n        return answer;\\n    }\\n\\n    ll solve(vector<int>&nums1,vector<int>&nums2,ll n){\\n        vector<ll>container(n,0);\\n        for(ll i=0;i<n;i++){\\n            container[i]=nums2[i]-nums1[i];\\n        }\\n        return max((ll)0,kadne(container,n));\\n    }\\n\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        ll n=nums1.size(),total1=0,total2=0;\\n        for(ll i=0;i<n;i++){\\n            total1+=nums1[i];total2+=nums2[i];\\n        } \\n        ll diff1=solve(nums1,nums2,n),diff2=solve(nums2,nums1,n);\\n        return max(total1+diff1,total2+diff2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n\\n    ll kadne(vector<ll>&container,ll n){\\n        ll sum=0,answer=INT_MIN;\\n        for(ll i=0;i<n;i++){\\n            sum+=container[i];\\n            answer=max(answer,sum);\\n            if(sum<0){\\n                sum=0;\\n            }\\n        }\\n        return answer;\\n    }\\n\\n    ll solve(vector<int>&nums1,vector<int>&nums2,ll n){\\n        vector<ll>container(n,0);\\n        for(ll i=0;i<n;i++){\\n            container[i]=nums2[i]-nums1[i];\\n        }\\n        return max((ll)0,kadne(container,n));\\n    }\\n\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        ll n=nums1.size(),total1=0,total2=0;\\n        for(ll i=0;i<n;i++){\\n            total1+=nums1[i];total2+=nums2[i];\\n        } \\n        ll diff1=solve(nums1,nums2,n),diff2=solve(nums2,nums1,n);\\n        return max(total1+diff1,total2+diff2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2976902,
                "title": "java-simple-readable-code-o-n-with-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumsSplicedArray(int[] nums1, int[] nums2) {\\n        int sum1=0,sum2=0;\\n        for(int i=0;i<nums1.length;i++){\\n            sum1+=nums1[i];\\n            sum2+=nums2[i];\\n        }\\n        int leftMax=getMaxDiff(nums1,nums2)+sum1;\\n        int rightMax=getMaxDiff(nums2,nums1)+sum2;\\n        return Math.max(leftMax,rightMax);\\n    }\\n    int getMaxDiff(int[] arr1, int[] arr2){\\n        int diff=0,sum1=0,sum2=0,n=arr1.length;\\n        for(int i=0;i<n;i++){\\n            sum1+=arr1[i];\\n            sum2+=arr2[i];\\n            if(sum1>sum2){\\n                sum1=sum2=0;\\n            }\\n            else diff=Math.max(sum2-sum1,diff);\\n        }\\n        return diff;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumsSplicedArray(int[] nums1, int[] nums2) {\\n        int sum1=0,sum2=0;\\n        for(int i=0;i<nums1.length;i++){\\n            sum1+=nums1[i];\\n            sum2+=nums2[i];\\n        }\\n        int leftMax=getMaxDiff(nums1,nums2)+sum1;\\n        int rightMax=getMaxDiff(nums2,nums1)+sum2;\\n        return Math.max(leftMax,rightMax);\\n    }\\n    int getMaxDiff(int[] arr1, int[] arr2){\\n        int diff=0,sum1=0,sum2=0,n=arr1.length;\\n        for(int i=0;i<n;i++){\\n            sum1+=arr1[i];\\n            sum2+=arr2[i];\\n            if(sum1>sum2){\\n                sum1=sum2=0;\\n            }\\n            else diff=Math.max(sum2-sum1,diff);\\n        }\\n        return diff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2917296,
                "title": "o-n-o-n-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nModified 53.maximum-sum-subarray\\n\\n# Approach\\n\\n\\nDynamic Programming\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumsSplicedArray(int[] nums1, int[] nums2) {\\n        int len = nums1.length;\\n        int [][] diff = new int[len][2];\\n        int sum1 = 0, sum2 = 0;\\n        for(int i = 0; i < len; i ++) {\\n            diff[i][0] = nums2[i] - nums1[i];\\n            diff[i][1] = - diff[i][0];\\n            sum1 += nums1[i];\\n            sum2 += nums2[i];\\n        }\\n        int [][] dp = new int[len][2];\\n        int tmp1 = Integer.MIN_VALUE;\\n        int tmp2 =  Integer.MIN_VALUE;\\n        dp[0][0] = Math.max(0, diff[0][0]);\\n        dp[0][1] = Math.max(0, diff[0][1]);\\n        for(int i = 1; i < len; i++) {\\n            dp[i][0] = Math.max(dp[i - 1][0] + diff[i][0], 0);\\n            dp[i][1] = Math.max(dp[i - 1][1] + diff[i][1], 0);\\n            tmp1 = Math.max(tmp1, dp[i][0]);\\n            tmp2 = Math.max(tmp2, dp[i][1]);\\n        }\\n        sum1 = Math.max(sum1, sum1 + tmp1);\\n        sum2 = Math.max(sum2, sum2 + tmp2);\\n        return Math.max(sum1, sum2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumsSplicedArray(int[] nums1, int[] nums2) {\\n        int len = nums1.length;\\n        int [][] diff = new int[len][2];\\n        int sum1 = 0, sum2 = 0;\\n        for(int i = 0; i < len; i ++) {\\n            diff[i][0] = nums2[i] - nums1[i];\\n            diff[i][1] = - diff[i][0];\\n            sum1 += nums1[i];\\n            sum2 += nums2[i];\\n        }\\n        int [][] dp = new int[len][2];\\n        int tmp1 = Integer.MIN_VALUE;\\n        int tmp2 =  Integer.MIN_VALUE;\\n        dp[0][0] = Math.max(0, diff[0][0]);\\n        dp[0][1] = Math.max(0, diff[0][1]);\\n        for(int i = 1; i < len; i++) {\\n            dp[i][0] = Math.max(dp[i - 1][0] + diff[i][0], 0);\\n            dp[i][1] = Math.max(dp[i - 1][1] + diff[i][1], 0);\\n            tmp1 = Math.max(tmp1, dp[i][0]);\\n            tmp2 = Math.max(tmp2, dp[i][1]);\\n        }\\n        sum1 = Math.max(sum1, sum1 + tmp1);\\n        sum2 = Math.max(sum2, sum2 + tmp2);\\n        return Math.max(sum1, sum2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2909780,
                "title": "python-2x-dp-memo",
                "content": "```\\nclass Solution:\\n    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n        ps1=[0]\\n        for x in nums1:ps1.append(ps1[-1]+x)\\n        ps2=[0]\\n        for x in nums2:ps2.append(ps2[-1]+x)\\n        @cache\\n        def dp1(i,f1):\\n            if i >= len(nums1):return 0\\n            if f1==1:return max(nums1[i]+dp1(i+1,0),nums2[i]+dp1(i+1,f1))\\n            elif f1==-1:return max(nums1[i]+dp1(i+1,f1),nums2[i]+dp1(i+1,1))\\n            return ps1[-1]-ps1[i]\\n        @cache\\n        def dp2(i,f1):\\n            if i >= len(nums1):return 0\\n            if f1==1:return max(nums2[i]+dp2(i+1,0),nums1[i]+dp2(i+1,f1))\\n            elif f1==-1:return max(nums1[i]+dp2(i+1,1),nums2[i]+dp2(i+1,f1))\\n            return ps2[-1]-ps2[i]\\n        return max(dp1(0,-1),dp2(0,-1))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n        ps1=[0]\\n        for x in nums1:ps1.append(ps1[-1]+x)\\n        ps2=[0]\\n        for x in nums2:ps2.append(ps2[-1]+x)\\n        @cache\\n        def dp1(i,f1):\\n            if i >= len(nums1):return 0\\n            if f1==1:return max(nums1[i]+dp1(i+1,0),nums2[i]+dp1(i+1,f1))\\n            elif f1==-1:return max(nums1[i]+dp1(i+1,f1),nums2[i]+dp1(i+1,1))\\n            return ps1[-1]-ps1[i]\\n        @cache\\n        def dp2(i,f1):\\n            if i >= len(nums1):return 0\\n            if f1==1:return max(nums2[i]+dp2(i+1,0),nums1[i]+dp2(i+1,f1))\\n            elif f1==-1:return max(nums1[i]+dp2(i+1,1),nums2[i]+dp2(i+1,f1))\\n            return ps2[-1]-ps2[i]\\n        return max(dp1(0,-1),dp2(0,-1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814697,
                "title": "c-tricky-solution-dp-tabultion",
                "content": "\\n![image](https://assets.leetcode.com/users/images/bc5f0104-4614-43ef-be06-8f3079b02da7_1668448476.5432253.png)\\nTC: O(N)\\nSC:O(N * 3)\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& nums1,vector<int>& nums2){\\n        \\n        int n=nums1.size();\\n        vector<vector<int>>dp(n+1,vector<int>(3));\\n        dp[0][0]=dp[0][1]=dp[0][2]=0;\\n        \\n        for(int i=1;i<=n;i++){\\n            \\n            //no transition yet so use nums1 array and taking \\n            // previous sum from dp[i-1]\\n            dp[i][0] =  dp[i-1][0] + nums1[i-1];\\n            \\n            //transition from nums1 to nums2 or nums2 to nums2,so take\\n            // nums2 array\\n            dp[i][1] = max(dp[i-1][0],dp[i-1][1]) + nums2[i-1];\\n            \\n            //transition to nums1 to nums2  again or nums2 to nums2 \\n            dp[i][2] = max(dp[i-1][1],dp[i-1][2]) + nums1[i-1];\\n        }\\n        return max({dp[n][0],dp[n][1],dp[n][2]});\\n    }\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        \\n\\n        return max(solve(nums1,nums2),solve(nums2,nums1));\\n    }\\n};\\n\\n// dp[i][0] -> (0 means no transition) \\n//     represent total sum till index \"i\" when the current index is taken\\n//     from  nums1\\n\\n// dp[i][1] - > (1 means transition from nums1 to nums2)\\n//     repreents total sum till ndex \"i\" when the current index is taken from nums2\\n    \\n// dp[i][2] -> (2 represent transition from nums1 to nums2 )\\n//         repreents total sum till ndex \"i\" when the current index is \\n//         taken from nums1\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& nums1,vector<int>& nums2){\\n        \\n        int n=nums1.size();\\n        vector<vector<int>>dp(n+1,vector<int>(3));\\n        dp[0][0]=dp[0][1]=dp[0][2]=0;\\n        \\n        for(int i=1;i<=n;i++){\\n            \\n            //no transition yet so use nums1 array and taking \\n            // previous sum from dp[i-1]\\n            dp[i][0] =  dp[i-1][0] + nums1[i-1];\\n            \\n            //transition from nums1 to nums2 or nums2 to nums2,so take\\n            // nums2 array\\n            dp[i][1] = max(dp[i-1][0],dp[i-1][1]) + nums2[i-1];\\n            \\n            //transition to nums1 to nums2  again or nums2 to nums2 \\n            dp[i][2] = max(dp[i-1][1],dp[i-1][2]) + nums1[i-1];\\n        }\\n        return max({dp[n][0],dp[n][1],dp[n][2]});\\n    }\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        \\n\\n        return max(solve(nums1,nums2),solve(nums2,nums1));\\n    }\\n};\\n\\n// dp[i][0] -> (0 means no transition) \\n//     represent total sum till index \"i\" when the current index is taken\\n//     from  nums1\\n\\n// dp[i][1] - > (1 means transition from nums1 to nums2)\\n//     repreents total sum till ndex \"i\" when the current index is taken from nums2\\n    \\n// dp[i][2] -> (2 represent transition from nums1 to nums2 )\\n//         repreents total sum till ndex \"i\" when the current index is \\n//         taken from nums1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2801518,
                "title": "c-kadane-s-algo-readable-code",
                "content": "# Intuition\\n\\n\\n# Approach\\nKadane\\'s algorithm\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n    int n = nums1.size();\\n    int sum1 = nums1[0];\\n    int sum2 = nums2[0];\\n    int ans = INT_MIN;\\n    int cs = 0;\\n    // vector<int> dp1,dp2;\\n    // dp1[0] = nums1[0];\\n    // dp2[0] = nums2[0];\\n    for(int i = 1;i<n;i++){\\n     sum1 += nums1[i];\\n     sum2+= nums2[i];\\n \\n    }\\n    for(int i = 0;i<n;i++){\\n        cs = max(cs + nums1[i]-nums2[i],nums1[i]-nums2[i]);\\n        ans = max(sum2+cs,ans);\\n    }\\n     int ans2 = INT_MIN;\\n     int cs2 = 0;\\n     for(int i = 0;i<n;i++){\\n        cs2 = max(cs2 + nums2[i]-nums1[i],nums2[i]-nums1[i]);\\n        ans2 = max(sum1+cs2,ans2);\\n    }\\n    \\n    return max(ans,ans2);\\n    \\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n    int n = nums1.size();\\n    int sum1 = nums1[0];\\n    int sum2 = nums2[0];\\n    int ans = INT_MIN;\\n    int cs = 0;\\n    // vector<int> dp1,dp2;\\n    // dp1[0] = nums1[0];\\n    // dp2[0] = nums2[0];\\n    for(int i = 1;i<n;i++){\\n     sum1 += nums1[i];\\n     sum2+= nums2[i];\\n \\n    }\\n    for(int i = 0;i<n;i++){\\n        cs = max(cs + nums1[i]-nums2[i],nums1[i]-nums2[i]);\\n        ans = max(sum2+cs,ans);\\n    }\\n     int ans2 = INT_MIN;\\n     int cs2 = 0;\\n     for(int i = 0;i<n;i++){\\n        cs2 = max(cs2 + nums2[i]-nums1[i],nums2[i]-nums1[i]);\\n        ans2 = max(sum1+cs2,ans2);\\n    }\\n    \\n    return max(ans,ans2);\\n    \\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2798127,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        auto solve = [&](vector<int>& n1, vector<int>& n2) {\\n            int res = 0, mx = 0, cur = 0;\\n            \\n            for(int i = 0; i < n1.size(); i++) {\\n                res += n1[i];\\n                cur = max(0, cur - n1[i] + n2[i]);\\n                mx = max(mx, cur);\\n            }\\n            \\n            return res + mx;\\n        };\\n        \\n        return max(solve(nums1, nums2), solve(nums2, nums1));\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        auto solve = [&](vector<int>& n1, vector<int>& n2) {\\n            int res = 0, mx = 0, cur = 0;\\n            \\n            for(int i = 0; i < n1.size(); i++) {\\n                res += n1[i];\\n                cur = max(0, cur - n1[i] + n2[i]);\\n                mx = max(mx, cur);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2764266,
                "title": "greedy-sc-o-1-solution-fully-explained-python",
                "content": "**Intuition**\\noperation can only be applied once\\nit must be applied on a subarray\\nthere are n*(n+1)/2 subarrays\\nyou want to choose the one which gives the biggest increase in sum\\nbiggest increase in sum should be found for both nums1 or nums2\\n\\n**Solution**\\nCreate a difference array\\n```\\ndiff1 = [nums2[i] - nums1[i] for i in range(n)]\\ndiff2 = [nums1[i] - nums2[i] for i in range(n)]\\n```\\nYou want to find the max sum (positive) subarray in diff, because the max sum represents the biggest increase in sum (after the swapping is done).\\nYou can actually do this without creating diff array (read code below).\\n\\n**Time: O(n)\\nSpace: O(1)**\\n```\\ndef maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n    n = len(nums1)\\n\\n    def maxSumSubarray(sign):\\n        max_sum = c_sum = 0\\n        i = -1\\n        for j in range(n):\\n            c_sum += sign*(nums2[j] - nums1[j])\\n            if c_sum <= 0:\\n                i = j\\n                c_sum = 0\\n            max_sum = max(max_sum, c_sum)\\n        return max_sum\\n\\n    increaseNums1 = maxSumSubarray(1)\\n    increaseNums2 = maxSumSubarray(-1)\\n\\n    return max(sum(nums1) + increaseNums1, sum(nums2) + increaseNums2)\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\ndiff1 = [nums2[i] - nums1[i] for i in range(n)]\\ndiff2 = [nums1[i] - nums2[i] for i in range(n)]\\n```\n```\\ndef maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n    n = len(nums1)\\n\\n    def maxSumSubarray(sign):\\n        max_sum = c_sum = 0\\n        i = -1\\n        for j in range(n):\\n            c_sum += sign*(nums2[j] - nums1[j])\\n            if c_sum <= 0:\\n                i = j\\n                c_sum = 0\\n            max_sum = max(max_sum, c_sum)\\n        return max_sum\\n\\n    increaseNums1 = maxSumSubarray(1)\\n    increaseNums2 = maxSumSubarray(-1)\\n\\n    return max(sum(nums1) + increaseNums1, sum(nums2) + increaseNums2)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2761410,
                "title": "max-subarray-over-the-element-wise-differences-of-two-arrays",
                "content": "### Idea: max subarray (Kadane\\'s algo) over the diff array, O(n):\\nthe swap of a subarray will increase the sum of array A by sum(diffs)\\n\\n```\\n// Idea: max subarray (Kadane\\'s algo) over the diff array, O(n):\\n// the swap of a subarray will increase the sum of array A by sum(diffs)\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int64_t sumA = accumulate(nums1.begin(), nums1.end(), (int64_t)0);\\n        int64_t sumB = accumulate(nums2.begin(), nums2.end(), (int64_t)0);\\n        \\n        return max(sumA + maxSubArrayOfDiffs(nums1, nums2), \\n                   sumB + maxSubArrayOfDiffs(nums2, nums1));\\n    }\\n    // use b\\'s elements to replace a\\'s.\\n    static int64_t maxSubArrayOfDiffs(\\n        const vector<int>& a, \\n        const vector<int>& b) {\\n        // greedy algo\\n        int64_t s = b[0] - a[0];\\n        int64_t maxSs = s;\\n        for (int i = 1; i < a.size(); ++i) {\\n            s = max(s + b[i] - a[i], int64_t(b[i] - a[i]));\\n            maxSs = max(maxSs, s);\\n        }\\n        return maxSs;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// Idea: max subarray (Kadane\\'s algo) over the diff array, O(n):\\n// the swap of a subarray will increase the sum of array A by sum(diffs)\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int64_t sumA = accumulate(nums1.begin(), nums1.end(), (int64_t)0);\\n        int64_t sumB = accumulate(nums2.begin(), nums2.end(), (int64_t)0);\\n        \\n        return max(sumA + maxSubArrayOfDiffs(nums1, nums2), \\n                   sumB + maxSubArrayOfDiffs(nums2, nums1));\\n    }\\n    // use b\\'s elements to replace a\\'s.\\n    static int64_t maxSubArrayOfDiffs(\\n        const vector<int>& a, \\n        const vector<int>& b) {\\n        // greedy algo\\n        int64_t s = b[0] - a[0];\\n        int64_t maxSs = s;\\n        for (int i = 1; i < a.size(); ++i) {\\n            s = max(s + b[i] - a[i], int64_t(b[i] - a[i]));\\n            maxSs = max(maxSs, s);\\n        }\\n        return maxSs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758304,
                "title": "java-solutions",
                "content": "```\\nclass Solution {\\n    public int maximumsSplicedArray(int[] nums1, int[] nums2) {\\n        int sum1=0, sum2=0, n=nums1.length;\\n        for(int num:nums1) sum1+=num;\\n        for(int num:nums2) sum2+=num;\\n        \\n        if(sum2>sum1){\\n            int temp = sum2;\\n            sum2 = sum1;\\n            sum1 = temp;\\n            int[] temparr = nums2;\\n            nums2 = nums1;\\n            nums1 = temparr;\\n        }\\n        \\n        //now sum1>=sum2\\n        \\n        //maxEndingHere denotes the maximum sum subarray ending at current index(ie. element at current index has to be included)\\n        //minEndingHere denotes the minimum sum subarray ending at current index\\n        int maxEndingHere, minEndingHere, maxSoFar, minSoFar, currEle;\\n        maxEndingHere=minEndingHere=maxSoFar=minSoFar=nums2[0]-nums1[0];\\n        \\n        for(int i=1;i<n;i++){\\n            currEle = nums2[i]-nums1[i];\\n            minEndingHere += currEle;\\n            maxEndingHere += currEle;\\n            \\n            if(maxEndingHere < currEle){\\n                maxEndingHere = currEle;\\n            }\\n            if(minEndingHere > currEle){\\n                minEndingHere = currEle;\\n            }\\n            \\n            maxSoFar = Math.max(maxEndingHere, maxSoFar);\\n            minSoFar = Math.min(minEndingHere, minSoFar);\\n        }\\n        \\n        //return the maximum of the 2 possibilities dicussed\\n        //also keep care that maxSoFar>=0 and maxSoFar<=0\\n        return Math.max(sum1+Math.max(maxSoFar,0), sum2-Math.min(0, minSoFar));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximumsSplicedArray(int[] nums1, int[] nums2) {\\n        int sum1=0, sum2=0, n=nums1.length;\\n        for(int num:nums1) sum1+=num;\\n        for(int num:nums2) sum2+=num;\\n        \\n        if(sum2>sum1){\\n            int temp = sum2;\\n            sum2 = sum1;\\n            sum1 = temp;\\n            int[] temparr = nums2;\\n            nums2 = nums1;\\n            nums1 = temparr;\\n        }\\n        \\n        //now sum1>=sum2\\n        \\n        //maxEndingHere denotes the maximum sum subarray ending at current index(ie. element at current index has to be included)\\n        //minEndingHere denotes the minimum sum subarray ending at current index\\n        int maxEndingHere, minEndingHere, maxSoFar, minSoFar, currEle;\\n        maxEndingHere=minEndingHere=maxSoFar=minSoFar=nums2[0]-nums1[0];\\n        \\n        for(int i=1;i<n;i++){\\n            currEle = nums2[i]-nums1[i];\\n            minEndingHere += currEle;\\n            maxEndingHere += currEle;\\n            \\n            if(maxEndingHere < currEle){\\n                maxEndingHere = currEle;\\n            }\\n            if(minEndingHere > currEle){\\n                minEndingHere = currEle;\\n            }\\n            \\n            maxSoFar = Math.max(maxEndingHere, maxSoFar);\\n            minSoFar = Math.min(minEndingHere, minSoFar);\\n        }\\n        \\n        //return the maximum of the 2 possibilities dicussed\\n        //also keep care that maxSoFar>=0 and maxSoFar<=0\\n        return Math.max(sum1+Math.max(maxSoFar,0), sum2-Math.min(0, minSoFar));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2750912,
                "title": "java-time-o-n-space-o-n-math-kadane-dp",
                "content": "```\\nclass Solution {\\n    public int maximumsSplicedArray(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        int[] d1 = new int[n], d2 = new int[n];\\n        int md1 = 0, cur1 = 0, md2 = 0, cur2 = 0, s1 = 0, s2 = 0;\\n        for(int i=0;i<n;i++){\\n            s1 += nums1[i];\\n            s2 += nums2[i];\\n            d1[i] = nums1[i] - nums2[i];\\n            d2[i] = nums2[i] - nums1[i];\\n            cur1 += d1[i];\\n            cur2 += d2[i];\\n            if(cur1<0) cur1 = 0;\\n            if(cur2<0) cur2 = 0;\\n            md1 = Math.max(md1, cur1);\\n            md2 = Math.max(md2, cur2);\\n        } \\n        return Math.max(s1 + md2, s2 + md1);\\n    }\\n}\\n\\n\\n\\n// 1, 2, 3, 4, 5\\n\\n//11,12,13,14,15\\n\\n//prefix\\n//1, 3, 6, 10, 15\\n//11, 23, 36, 50, 65\\n\\n//Approach 1: O(n^2), double nested loop + prefixsum\\n//enumerate i,j\\n//Math.max(sum1 + prefix2(j+1,i) - prefix1(j+1, i), sum2 + prefix1(j+1, i) - prefix2(j+1, i))\\n\\n\\n\\n//Approach 2\\n//maximum subarray sum, O(n)\\n\\n\\n```class Solution {\\n    public int maximumsSplicedArray(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        int[] d1 = new int[n], d2 = new int[n];\\n        int md1 = 0, cur1 = 0, md2 = 0, cur2 = 0, s1 = 0, s2 = 0;\\n        for(int i=0;i<n;i++){\\n            s1 += nums1[i];\\n            s2 += nums2[i];\\n            d1[i] = nums1[i] - nums2[i];\\n            d2[i] = nums2[i] - nums1[i];\\n            cur1 += d1[i];\\n            cur2 += d2[i];\\n            if(cur1<0) cur1 = 0;\\n            if(cur2<0) cur2 = 0;\\n            md1 = Math.max(md1, cur1);\\n            md2 = Math.max(md2, cur2);\\n        } \\n        return Math.max(s1 + md2, s2 + md1);\\n    }\\n}\\n\\n\\n\\n// 1, 2, 3, 4, 5\\n\\n//11,12,13,14,15\\n\\n//prefix\\n//1, 3, 6, 10, 15\\n//11, 23, 36, 50, 65\\n\\n//Approach 1: O(n^2), double nested loop + prefixsum\\n//enumerate i,j\\n//Math.max(sum1 + prefix2(j+1,i) - prefix1(j+1, i), sum2 + prefix1(j+1, i) - prefix2(j+1, i))\\n\\n\\n\\n//Approach 2\\n//maximum subarray sum, O(n)\\n\\n",
                "solutionTags": [
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumsSplicedArray(int[] nums1, int[] nums2) {\\n        int n = nums1.length;\\n        int[] d1 = new int[n], d2 = new int[n];\\n        int md1 = 0, cur1 = 0, md2 = 0, cur2 = 0, s1 = 0, s2 = 0;\\n        for(int i=0;i<n;i++){\\n            s1 += nums1[i];\\n            s2 += nums2[i];\\n            d1[i] = nums1[i] - nums2[i];\\n            d2[i] = nums2[i] - nums1[i];\\n            cur1 += d1[i];\\n            cur2 += d2[i];\\n            if(cur1<0) cur1 = 0;\\n            if(cur2<0) cur2 = 0;\\n            md1 = Math.max(md1, cur1);\\n            md2 = Math.max(md2, cur2);\\n        } \\n        return Math.max(s1 + md2, s2 + md1);\\n    }\\n}\\n\\n\\n\\n// 1, 2, 3, 4, 5\\n\\n//11,12,13,14,15\\n\\n//prefix\\n//1, 3, 6, 10, 15\\n//11, 23, 36, 50, 65\\n\\n//Approach 1: O(n^2), double nested loop + prefixsum\\n//enumerate i,j\\n//Math.max(sum1 + prefix2(j+1,i) - prefix1(j+1, i), sum2 + prefix1(j+1, i) - prefix2(j+1, i))\\n\\n\\n\\n//Approach 2\\n//maximum subarray sum, O(n)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2749270,
                "title": "easy-explanation-java-o-n-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst finding the diff between similar index value in both arrays and  also finding the max of it. We make the value =0, when the diff hits less than zero .This results in us finding the max continuous diff that can occur in the two arrays.\\n\\nWhile subtracting this (max diff) with sum of the arrays we find the max sum after replacing the subarray.\\n\\nLets say max diff=50 & 30 in arrays (20,40,20,70,30) and (10,10,50,40,20) we can write 30 as 50(in arr2)-20(in arr1), also 50 as [20-10+40-10+20-50+70-40+30-20]-->20,40,... in arr1 and 10,10,... in arr2 while subtracting this with respective sums we automatically get the ans.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumsSplicedArray(int[] nums1, int[] nums2) {\\n        int sum1=0,sum2=0;\\n        int len=nums1.length;\\n        for(int i=0;i<len;i++)  {sum1+=nums1[i];sum2+=nums2[i];}\\n        \\n        int ans=Math.max(sum1,sum2);\\n\\n        int firstArray=0,secondArray=0,max1=Integer.MIN_VALUE,max2=Integer.MIN_VALUE;\\n\\n        for(int i=0;i<len;i++){\\n            firstArray+=(nums2[i]-nums1[i]);\\n            secondArray+=(nums1[i]-nums2[i]);\\n\\n            max1=Math.max(max1,firstArray);\\n            max2=Math.max(max2,secondArray);\\n\\n            if(firstArray<0)    firstArray=0;\\n            if(secondArray<0)   secondArray=0;\\n        }\\n\\n        ans=Math.max(ans,sum1+max1);\\n        ans=Math.max(ans,sum2+max2);\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumsSplicedArray(int[] nums1, int[] nums2) {\\n        int sum1=0,sum2=0;\\n        int len=nums1.length;\\n        for(int i=0;i<len;i++)  {sum1+=nums1[i];sum2+=nums2[i];}\\n        \\n        int ans=Math.max(sum1,sum2);\\n\\n        int firstArray=0,secondArray=0,max1=Integer.MIN_VALUE,max2=Integer.MIN_VALUE;\\n\\n        for(int i=0;i<len;i++){\\n            firstArray+=(nums2[i]-nums1[i]);\\n            secondArray+=(nums1[i]-nums2[i]);\\n\\n            max1=Math.max(max1,firstArray);\\n            max2=Math.max(max2,secondArray);\\n\\n            if(firstArray<0)    firstArray=0;\\n            if(secondArray<0)   secondArray=0;\\n        }\\n\\n        ans=Math.max(ans,sum1+max1);\\n        ans=Math.max(ans,sum2+max2);\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739586,
                "title": "java-max-sub-array-problem",
                "content": "we first get sum of nums1 and nums2. then check if we can further increase their sums. in order to do that try to find out hte max sub array of diff of nums1 and nums2\\n```\\n    public int maximumsSplicedArray(int[] nums1, int[] nums2) {\\n        if (nums1==null||nums2==null||nums1.length<0||nums2.length<0||nums1.length!=nums2.length) {\\n            return -1;\\n        }\\n        if (nums1.length==0||nums2.length==0) {\\n            return 0;\\n        }\\n        int size=nums1.length,s1=0,s2=0;\\n        int[] diff1=new int[size],diff2=new int[size];\\n        for (int i=0;i<size;++i) {\\n            s1+=nums1[i];\\n            s2+=nums2[i];\\n            diff1[i]=nums1[i]-nums2[i];\\n            diff2[i]=nums2[i]-nums1[i];\\n        }\\n        return Math.max(s1+maxsum(diff2), s2+maxsum(diff1));\\n    }\\n\\n    private int maxsum(int[] diff) {\\n        int maxv=diff[0];\\n        for (int i=1;i<diff.length;++i) {\\n            if (diff[i-1]>0) {\\n                diff[i]+=diff[i-1];\\n            }\\n            maxv=Math.max(maxv,diff[i]);\\n        }\\n        return maxv;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int maximumsSplicedArray(int[] nums1, int[] nums2) {\\n        if (nums1==null||nums2==null||nums1.length<0||nums2.length<0||nums1.length!=nums2.length) {\\n            return -1;\\n        }\\n        if (nums1.length==0||nums2.length==0) {\\n            return 0;\\n        }\\n        int size=nums1.length,s1=0,s2=0;\\n        int[] diff1=new int[size],diff2=new int[size];\\n        for (int i=0;i<size;++i) {\\n            s1+=nums1[i];\\n            s2+=nums2[i];\\n            diff1[i]=nums1[i]-nums2[i];\\n            diff2[i]=nums2[i]-nums1[i];\\n        }\\n        return Math.max(s1+maxsum(diff2), s2+maxsum(diff1));\\n    }\\n\\n    private int maxsum(int[] diff) {\\n        int maxv=diff[0];\\n        for (int i=1;i<diff.length;++i) {\\n            if (diff[i-1]>0) {\\n                diff[i]+=diff[i-1];\\n            }\\n            maxv=Math.max(maxv,diff[i]);\\n        }\\n        return maxv;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2738449,
                "title": "easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n      int n=nums1.size();\\n      int s1=accumulate(nums1.begin(),nums1.end(),0);\\n      int s2=accumulate(nums2.begin(),nums2.end(),0);\\n      int maxi1=0,maxi2=0;\\n      int first=0,second=0;\\n      for(int i=0;i<n;i++)\\n      {\\n          first+=nums2[i]-nums1[i];\\n          second+=nums1[i]-nums2[i];\\n          maxi1=max(maxi1,first);\\n          maxi2=max(maxi2,second);\\n          if(first<0)\\n          {\\n              first=0;\\n          }\\n          if(second<0)\\n          {\\n              second=0;\\n          }\\n      }\\n        return max(maxi1+s1,maxi2+s2);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n      int n=nums1.size();\\n      int s1=accumulate(nums1.begin(),nums1.end(),0);\\n      int s2=accumulate(nums2.begin(),nums2.end(),0);\\n      int maxi1=0,maxi2=0;\\n      int first=0,second=0;\\n      for(int i=0;i<n;i++)\\n      {\\n          first+=nums2[i]-nums1[i];\\n          second+=nums1[i]-nums2[i];\\n          maxi1=max(maxi1,first);\\n          maxi2=max(maxi2,second);\\n          if(first<0)\\n          {\\n              first=0;\\n          }\\n          if(second<0)\\n          {\\n              second=0;\\n          }\\n      }\\n        return max(maxi1+s1,maxi2+s2);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2710213,
                "title": "kadane-python-o-n",
                "content": "\\tclass Solution:\\n\\t\\tdef maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n\\t\\t\\ts1 = sum(nums1)\\n\\t\\t\\ts2 = sum(nums2)\\n\\n\\t\\t\\tmaxi1=0\\n\\t\\t\\tmaxi2=0\\n\\t\\t\\tsum1=0\\n\\t\\t\\tsum2=0\\n\\n\\t\\t\\tfor i in range(len(nums1)):\\n\\t\\t\\t\\tsum1+=(nums1[i]-nums2[i])\\n\\t\\t\\t\\tsum2+=(nums2[i]-nums1[i])\\n\\t\\t\\t\\tmaxi1=max(maxi1,sum1)\\n\\t\\t\\t\\tmaxi2=max(maxi2,sum2)\\n\\t\\t\\t\\tif(sum1<0):\\n\\t\\t\\t\\t\\tsum1=0\\n\\t\\t\\t\\tif(sum2<0):\\n\\t\\t\\t\\t\\tsum2=0\\n\\n\\t\\t\\treturn max(s2+maxi1,s1+maxi2)\\n\\t\\t\\t\\n**Please Upvote**",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n\\t\\t\\ts1 = sum(nums1)\\n\\t\\t\\ts2 = sum(nums2)\\n\\n\\t\\t\\tmaxi1=0\\n\\t\\t\\tmaxi2=0\\n\\t\\t\\tsum1=0\\n\\t\\t\\tsum2=0\\n\\n\\t\\t\\tfor i in range(len(nums1)):\\n\\t\\t\\t\\tsum1+=(nums1[i]-nums2[i])\\n\\t\\t\\t\\tsum2+=(nums2[i]-nums1[i])\\n\\t\\t\\t\\tmaxi1=max(maxi1,sum1)\\n\\t\\t\\t\\tmaxi2=max(maxi2,sum2)\\n\\t\\t\\t\\tif(sum1<0):\\n\\t\\t\\t\\t\\tsum1=0\\n\\t\\t\\t\\tif(sum2<0):\\n\\t\\t\\t\\t\\tsum2=0\\n\\n\\t\\t\\treturn max(s2+maxi1,s1+maxi2)\\n\\t\\t\\t\\n**Please Upvote**",
                "codeTag": "Java"
            },
            {
                "id": 2672689,
                "title": "scala-solution",
                "content": "```\\n  def maximumsSplicedArray(nums1: Array[Int], nums2: Array[Int]): Int =\\n    nums1.sum + help(nums1, nums2) max nums2.sum + help(nums2, nums1)\\n\\n  def help(nums1: Array[Int], nums2: Array[Int]):Int =\\n    nums1.indices.scanLeft(0)((sum, i) => (sum + nums2(i) - nums1(i)) max (nums2(i) - nums1(i))).max\\n\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\n  def maximumsSplicedArray(nums1: Array[Int], nums2: Array[Int]): Int =\\n    nums1.sum + help(nums1, nums2) max nums2.sum + help(nums2, nums1)\\n\\n  def help(nums1: Array[Int], nums2: Array[Int]):Int =\\n    nums1.indices.scanLeft(0)((sum, i) => (sum + nums2(i) - nums1(i)) max (nums2(i) - nums1(i))).max\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2671833,
                "title": "c-kadens-algo",
                "content": "```\\nclass Solution {\\npublic:\\n    int replace(vector<int>& nums1, vector<int>& nums2,int sum1,int sum2){\\n        int n=nums1.size(),sum=0,ans=0;\\n        for(int i=0;i<n;i++){\\n            sum+=(nums2[i]-nums1[i]);\\n            ans=max(ans,sum);\\n            if(sum<0){\\n                sum=0;\\n            }\\n        }\\n        return ans+sum1;\\n    }\\n    \\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int sum1=accumulate(nums1.begin(),nums1.end(),0);\\n        int sum2=accumulate(nums2.begin(),nums2.end(),0);\\n        return max(replace(nums1,nums2,sum1,sum2),replace(nums2,nums1,sum2,sum1));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int replace(vector<int>& nums1, vector<int>& nums2,int sum1,int sum2){\\n        int n=nums1.size(),sum=0,ans=0;\\n        for(int i=0;i<n;i++){\\n            sum+=(nums2[i]-nums1[i]);\\n            ans=max(ans,sum);\\n            if(sum<0){\\n                sum=0;\\n            }\\n        }\\n        return ans+sum1;\\n    }\\n    \\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int sum1=accumulate(nums1.begin(),nums1.end(),0);\\n        int sum2=accumulate(nums2.begin(),nums2.end(),0);\\n        return max(replace(nums1,nums2,sum1,sum2),replace(nums2,nums1,sum2,sum1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2669991,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    \\n    int help(vector<int>& a, vector<int> &b)\\n    {\\n        int sum, cur_max = 0, maxi = 0;\\n        \\n        sum = accumulate(a.begin(),a.end(),0);\\n        \\n        for(int i=0; i<a.size(); i++)\\n        {\\n            cur_max += b[i] - a[i];\\n            \\n            if(cur_max < 0)\\n            {\\n                cur_max = 0;\\n            }\\n            \\n            maxi = max(cur_max,maxi);\\n        }\\n        \\n        return maxi + sum;\\n    }\\n    \\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2)\\n    {\\n        return max(help(nums1,nums2),help(nums2,nums1));\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int help(vector<int>& a, vector<int> &b)\\n    {\\n        int sum, cur_max = 0, maxi = 0;\\n        \\n        sum = accumulate(a.begin(),a.end(),0);\\n        \\n        for(int i=0; i<a.size(); i++)\\n        {\\n            cur_max += b[i] - a[i];\\n            \\n            if(cur_max < 0)\\n            {\\n                cur_max = 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2668335,
                "title": "java-use-prefix-sum-without-dp",
                "content": "```\\nclass Solution {\\n    public int maximumsSplicedArray(int[] nums1, int[] nums2) {\\n        int[] pre1 = new int[nums1.length + 1];\\n        int[] pre2 = new int[nums2.length + 1];\\n        // calculate two prefix sum\\n        for (int i = 1; i < pre1.length; i++) {\\n            pre1[i] = pre1[i - 1] + nums1[i - 1];\\n            pre2[i] = pre2[i - 1] + nums2[i - 1];\\n        }\\n        // find the larget prefix sum diff range for two arrays. \\n        int[] c1 = compare(nums1, nums2, pre1, pre2, true);\\n        int[] c2 = compare(nums1, nums2, pre1, pre2, false);\\n        \\n        // recalculate the result based on the ranges.\\n        int a = pre1[pre1.length - 1];\\n        int b = pre2[pre2.length - 1];\\n        if (c1[0] >= 0) {\\n            int l = c1[0];\\n            int r = c1[1];\\n            a = Math.max(a, pre1[l] + (pre2[r + 1] - pre2[l]) + (pre1[pre1.length - 1] - pre1[r + 1]));\\n            b = Math.max(b, pre2[l] + (pre1[r + 1] - pre1[l]) + (pre2[pre1.length - 1] - pre2[r + 1]));\\n        }\\n        if (c2[0] >= 0) {\\n            int l = c2[0];\\n            int r = c2[1];\\n            a = Math.max(a, pre1[l] + (pre2[r + 1] - pre2[l]) + (pre1[pre1.length - 1] - pre1[r + 1]));\\n            b = Math.max(b, pre2[l] + (pre1[r + 1] - pre1[l]) + (pre2[pre1.length - 1] - pre2[r + 1]));\\n        }\\n        return Math.max(a, b);\\n    }\\n    \\n    int[] compare(int[] nums1, int[] nums2, int[] pre1, int[] pre2, boolean swap) {\\n        int l = 0;\\n        int max = 0;\\n        int s = -1;\\n        int e = -1;\\n        for (int r = 0; r < nums1.length; r++) {\\n            int p1 = pre1[r + 1] - pre1[l];\\n            int p2 = pre2[r + 1] - pre2[l];\\n            int k = swap ? p1 - p2 : p2 - p1;\\n            if (k < 0) {\\n                l = r + 1;\\n            }\\n            if (k > max) {\\n                max = k;\\n                s = l;\\n                e = r;\\n            }\\n        }\\n        return new int[]{s,e};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximumsSplicedArray(int[] nums1, int[] nums2) {\\n        int[] pre1 = new int[nums1.length + 1];\\n        int[] pre2 = new int[nums2.length + 1];\\n        // calculate two prefix sum\\n        for (int i = 1; i < pre1.length; i++) {\\n            pre1[i] = pre1[i - 1] + nums1[i - 1];\\n            pre2[i] = pre2[i - 1] + nums2[i - 1];\\n        }\\n        // find the larget prefix sum diff range for two arrays. \\n        int[] c1 = compare(nums1, nums2, pre1, pre2, true);\\n        int[] c2 = compare(nums1, nums2, pre1, pre2, false);\\n        \\n        // recalculate the result based on the ranges.\\n        int a = pre1[pre1.length - 1];\\n        int b = pre2[pre2.length - 1];\\n        if (c1[0] >= 0) {\\n            int l = c1[0];\\n            int r = c1[1];\\n            a = Math.max(a, pre1[l] + (pre2[r + 1] - pre2[l]) + (pre1[pre1.length - 1] - pre1[r + 1]));\\n            b = Math.max(b, pre2[l] + (pre1[r + 1] - pre1[l]) + (pre2[pre1.length - 1] - pre2[r + 1]));\\n        }\\n        if (c2[0] >= 0) {\\n            int l = c2[0];\\n            int r = c2[1];\\n            a = Math.max(a, pre1[l] + (pre2[r + 1] - pre2[l]) + (pre1[pre1.length - 1] - pre1[r + 1]));\\n            b = Math.max(b, pre2[l] + (pre1[r + 1] - pre1[l]) + (pre2[pre1.length - 1] - pre2[r + 1]));\\n        }\\n        return Math.max(a, b);\\n    }\\n    \\n    int[] compare(int[] nums1, int[] nums2, int[] pre1, int[] pre2, boolean swap) {\\n        int l = 0;\\n        int max = 0;\\n        int s = -1;\\n        int e = -1;\\n        for (int r = 0; r < nums1.length; r++) {\\n            int p1 = pre1[r + 1] - pre1[l];\\n            int p2 = pre2[r + 1] - pre2[l];\\n            int k = swap ? p1 - p2 : p2 - p1;\\n            if (k < 0) {\\n                l = r + 1;\\n            }\\n            if (k > max) {\\n                max = k;\\n                s = l;\\n                e = r;\\n            }\\n        }\\n        return new int[]{s,e};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2656526,
                "title": "java-easy-to-understand-easy-dp",
                "content": "```\\nclass Solution {\\n    public int maximumsSplicedArray(int[] nums1, int[] nums2) {\\n    int sum1=0;\\n        int sum2=0;\\n        for(int i=0;i<nums1.length;i++)\\n        {\\n            sum1+=nums1[i];\\n            sum2+=nums2[i];\\n        }\\n        \\n    return Math.max(maxReplacement(nums1,nums2)+sum1,maxReplacement(nums2,nums1)+sum2);\\n    }\\n    \\n    public int maxReplacement(int []nums1,int[] nums2)\\n    {\\n        // aim to maximize nums1\\n        //maximize num1 by replacinging with nums2 \\n        int n=nums1.length;\\n        int max=0;\\n        int []dp=new int[n];\\n        dp[n-1]=  nums2[n-1]-nums1[n-1];\\n        max=Math.max(dp[n-1],max);\\n        for(int i=n-2;i>=0;i--) // we make each idx work as left and expand till we get maximum replacement sum\\n        {\\n            dp[i]=Math.max(nums2[i]-nums1[i]+dp[i+1],nums2[i]-nums1[i]);\\n            max=Math.max(max,dp[i]);\\n        }\\n    \\n        \\n        return max;\\n        \\n    }\\n    \\n    \\n    \\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumsSplicedArray(int[] nums1, int[] nums2) {\\n    int sum1=0;\\n        int sum2=0;\\n        for(int i=0;i<nums1.length;i++)\\n        {\\n            sum1+=nums1[i];\\n            sum2+=nums2[i];\\n        }\\n        \\n    return Math.max(maxReplacement(nums1,nums2)+sum1,maxReplacement(nums2,nums1)+sum2);\\n    }\\n    \\n    public int maxReplacement(int []nums1,int[] nums2)\\n    {\\n        // aim to maximize nums1\\n        //maximize num1 by replacinging with nums2 \\n        int n=nums1.length;\\n        int max=0;\\n        int []dp=new int[n];\\n        dp[n-1]=  nums2[n-1]-nums1[n-1];\\n        max=Math.max(dp[n-1],max);\\n        for(int i=n-2;i>=0;i--) // we make each idx work as left and expand till we get maximum replacement sum\\n        {\\n            dp[i]=Math.max(nums2[i]-nums1[i]+dp[i+1],nums2[i]-nums1[i]);\\n            max=Math.max(max,dp[i]);\\n        }\\n    \\n        \\n        return max;\\n        \\n    }\\n    \\n    \\n    \\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647139,
                "title": "python-solution-fatser-98",
                "content": "\\n\\n\\tclass Solution:\\n    def maximumsSplicedArray(self, A, B):\\n        def kadane(A, B):\\n            res = cur = 0\\n            for i in range(len(A)):\\n                cur = max(0, cur + A[i] - B[i])\\n                res = max(res, cur)\\n            return res + sum(B)\\n        return max(kadane(A, B), kadane(B, A))",
                "solutionTags": [],
                "code": "\\n\\n\\tclass Solution:\\n    def maximumsSplicedArray(self, A, B):\\n        def kadane(A, B):\\n            res = cur = 0\\n            for i in range(len(A)):\\n                cur = max(0, cur + A[i] - B[i])\\n                res = max(res, cur)\\n            return res + sum(B)\\n        return max(kadane(A, B), kadane(B, A))",
                "codeTag": "Java"
            },
            {
                "id": 2644823,
                "title": "golang-kadane",
                "content": "```go\\nfunc maximumsSplicedArray(n1, n2 []int) int {\\n    kd, res, sum := [2]int{}, [2]int{}, [2]int{}\\n    for i := 0; i < len(n1); i++ {\\n        kd[0] = max(n2[i] - n1[i], kd[0] + n2[i] - n1[i])\\n        res[0] = max(res[0], kd[0])\\n        kd[1] = max(n1[i] - n2[i], kd[1] + n1[i] - n2[i])\\n        res[1] = max(res[1], kd[1])\\n        sum[0] += n1[i]\\n        sum[1] += n2[i]\\n    }    \\n    return max(sum[0] + res[0], sum[1] + res[1])\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc maximumsSplicedArray(n1, n2 []int) int {\\n    kd, res, sum := [2]int{}, [2]int{}, [2]int{}\\n    for i := 0; i < len(n1); i++ {\\n        kd[0] = max(n2[i] - n1[i], kd[0] + n2[i] - n1[i])\\n        res[0] = max(res[0], kd[0])\\n        kd[1] = max(n1[i] - n2[i], kd[1] + n1[i] - n2[i])\\n        res[1] = max(res[1], kd[1])\\n        sum[0] += n1[i]\\n        sum[1] += n2[i]\\n    }    \\n    return max(sum[0] + res[0], sum[1] + res[1])\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2619370,
                "title": "maximum-score-of-spliced-array-easy-understanding-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int mx1 = 0,mx2 = 0,sum1=0,sum2=0;\\n        int curr1 = 0,curr2=0;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            sum1 += nums1[i];\\n            sum2 += nums2[i];\\n         \\n            curr1 += nums1[i] - nums2[i];\\n            curr2 += nums2[i] - nums1[i];\\n            if(curr1<0)\\n            {\\n                curr1 = 0;\\n            }\\n            \\n            if(curr2<0)\\n            {\\n                curr2 = 0;\\n            }\\n            \\n            mx1 = max(mx1,curr1);\\n            mx2 = max(mx2,curr2);\\n        }\\n        \\n        return max(sum1+mx2,sum2+mx1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int mx1 = 0,mx2 = 0,sum1=0,sum2=0;\\n        int curr1 = 0,curr2=0;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            sum1 += nums1[i];\\n            sum2 += nums2[i];\\n         \\n            curr1 += nums1[i] - nums2[i];\\n            curr2 += nums2[i] - nums1[i];\\n            if(curr1<0)\\n            {\\n                curr1 = 0;\\n            }\\n            \\n            if(curr2<0)\\n            {\\n                curr2 = 0;\\n            }\\n            \\n            mx1 = max(mx1,curr1);\\n            mx2 = max(mx2,curr2);\\n        }\\n        \\n        return max(sum1+mx2,sum2+mx1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2563925,
                "title": "2-times-kadane-solution-100-fast-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int fun(vector<int> nums1, vector<int> nums2){\\n        int n = nums1.size();\\n        for(int i=0;i<n;i++) nums2[i] -= nums1[i];\\n        int mx = 0, sum = 0;\\n        int l = 0, r = -1, bestl = -1, bestr = -1;\\n        for(int i=0;i<n;i++){\\n            sum += nums2[i];\\n            if(sum>mx) {\\n                mx = sum;\\n                bestl = l;\\n                bestr = i;\\n            }\\n            if(sum<0) {\\n                sum = 0;\\n                l = i+1;\\n                r = -1;\\n            }\\n        }\\n        sum = 0;\\n        for(int &k:nums1) sum += k;\\n        if(bestr==-1) return sum;\\n        for(int i=bestl;i<=bestr;i++) sum -= nums1[i];\\n        for(int i=bestl;i<=bestr;i++){\\n            nums2[i] += nums1[i];\\n            sum += nums2[i];\\n        }\\n        return sum;\\n    }\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        return max(fun(nums1,nums2),fun(nums2,nums1));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun(vector<int> nums1, vector<int> nums2){\\n        int n = nums1.size();\\n        for(int i=0;i<n;i++) nums2[i] -= nums1[i];\\n        int mx = 0, sum = 0;\\n        int l = 0, r = -1, bestl = -1, bestr = -1;\\n        for(int i=0;i<n;i++){\\n            sum += nums2[i];\\n            if(sum>mx) {\\n                mx = sum;\\n                bestl = l;\\n                bestr = i;\\n            }\\n            if(sum<0) {\\n                sum = 0;\\n                l = i+1;\\n                r = -1;\\n            }\\n        }\\n        sum = 0;\\n        for(int &k:nums1) sum += k;\\n        if(bestr==-1) return sum;\\n        for(int i=bestl;i<=bestr;i++) sum -= nums1[i];\\n        for(int i=bestl;i<=bestr;i++){\\n            nums2[i] += nums1[i];\\n            sum += nums2[i];\\n        }\\n        return sum;\\n    }\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        return max(fun(nums1,nums2),fun(nums2,nums1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2543529,
                "title": "python-easy-sol-using-kadane-s-algo",
                "content": "```\\nclass Solution:\\n    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n        diff = list(map(lambda x:x[0]-x[1], zip(nums1, nums2)))\\n        \\n        def kadane(arr):\\n            res = max(arr)\\n            if res<=0:\\n                return res\\n            t = 0\\n            for v in arr:\\n                if t+v>0:\\n                    t += v\\n                    res = max(res,t)\\n                else:\\n                    t = 0\\n            return res\\n        \\n        s1, s2 = sum(nums1), sum(nums2)\\n        ad1 = (kadane(diff))\\n        ad2 = (kadane(list(map(lambda x:-x,diff))))\\n        return max(s2+ad1, s1+ad2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n        diff = list(map(lambda x:x[0]-x[1], zip(nums1, nums2)))\\n        \\n        def kadane(arr):\\n            res = max(arr)\\n            if res<=0:\\n                return res\\n            t = 0\\n            for v in arr:\\n                if t+v>0:\\n                    t += v\\n                    res = max(res,t)\\n                else:\\n                    t = 0\\n            return res\\n        \\n        s1, s2 = sum(nums1), sum(nums2)\\n        ad1 = (kadane(diff))\\n        ad2 = (kadane(list(map(lambda x:-x,diff))))\\n        return max(s2+ad1, s1+ad2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2506905,
                "title": "kadanes-alogrithm-python-easy-to-understand-detailed-explation",
                "content": "```\\nclass Solution:\\n    def maximumsSplicedArray(self, arr1: List[int], arr2: List[int]) -> int:\\n        \"\"\"\\n        [10, 90, 10]\\n        [60, 60, 60]       \\n        \\n        Case1:\\n            Arr1 - Arr2 => diff = [-50, 30, -50]\\n            \\n            By Applying Kaden\\'s algorithm \\n            \\n            max diff = 30\\n\\n            sum can be either = 60 + 90 + 60 + 30\\n        \\n        -------- or --------\\n        \\n        Case2:\\n            Arr1 - Arr2 => diff = [50, -30, 50]\\n            max diff = 50\\n\\n            sum = 10 + 90 + 10 + 50\\n\\n\\n        ans = max(Case1, Case2)\\n        \\n        returns max sum of ar1 assuming we are replacing elements of ar1 with ar2\\n        \\n        \"\"\"\\n        \\n        def max_diff(arr1, arr2):\\n            n = len(arr1)\\n            diff = [arr1[i] - arr2[i] for i in range(n)]\\n            maxDiff = float(\"-inf\")\\n            currSum = 0\\n            for i in range(n):\\n                currSum += diff[i]\\n                maxDiff = max(maxDiff, currSum)\\n                currSum = max(0, currSum)\\n            return maxDiff\\n        sum1 = sum(arr1)\\n        sum2 = sum(arr2)\\n        return max(sum1 + max_diff(arr2, arr1), sum2 + max_diff(arr1, arr2))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumsSplicedArray(self, arr1: List[int], arr2: List[int]) -> int:\\n        \"\"\"\\n        [10, 90, 10]\\n        [60, 60, 60]       \\n        \\n        Case1:\\n            Arr1 - Arr2 => diff = [-50, 30, -50]\\n            \\n            By Applying Kaden\\'s algorithm \\n            \\n            max diff = 30\\n\\n            sum can be either = 60 + 90 + 60 + 30\\n        \\n        -------- or --------\\n        \\n        Case2:\\n            Arr1 - Arr2 => diff = [50, -30, 50]\\n            max diff = 50\\n\\n            sum = 10 + 90 + 10 + 50\\n\\n\\n        ans = max(Case1, Case2)\\n        \\n        returns max sum of ar1 assuming we are replacing elements of ar1 with ar2\\n        \\n        \"\"\"\\n        \\n        def max_diff(arr1, arr2):\\n            n = len(arr1)\\n            diff = [arr1[i] - arr2[i] for i in range(n)]\\n            maxDiff = float(\"-inf\")\\n            currSum = 0\\n            for i in range(n):\\n                currSum += diff[i]\\n                maxDiff = max(maxDiff, currSum)\\n                currSum = max(0, currSum)\\n            return maxDiff\\n        sum1 = sum(arr1)\\n        sum2 = sum(arr2)\\n        return max(sum1 + max_diff(arr2, arr1), sum2 + max_diff(arr1, arr2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484953,
                "title": "python-dp-o-n-o-1-space-6lines",
                "content": "```\\nclass Solution(object):\\n    def maximumsSplicedArray(self, nums1, nums2):\\n        n,sum1,sum2=len(nums1),sum(nums1),sum(nums2)\\n        \\n        # current_min and current_max: min and max sum_subarray ends at position i.\\n        current_min=sub_min=current_max=sub_max=nums1[0]-nums2[0]\\n        for i in range(1,n):\\n            current_max=max(nums1[i]-nums2[i],current_max+nums1[i]-nums2[i])\\n            sub_max=max(current_max,sub_max)\\n            current_min=min(nums1[i]-nums2[i],current_min+nums1[i]-nums2[i])\\n            sub_min=min(current_min,sub_min)\\n        return max(sum1-sub_min, sum2+sub_max)\\n        \\n        \\n            \\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maximumsSplicedArray(self, nums1, nums2):\\n        n,sum1,sum2=len(nums1),sum(nums1),sum(nums2)\\n        \\n        # current_min and current_max: min and max sum_subarray ends at position i.\\n        current_min=sub_min=current_max=sub_max=nums1[0]-nums2[0]\\n        for i in range(1,n):\\n            current_max=max(nums1[i]-nums2[i],current_max+nums1[i]-nums2[i])\\n            sub_max=max(current_max,sub_max)\\n            current_min=min(nums1[i]-nums2[i],current_min+nums1[i]-nums2[i])\\n            sub_min=min(current_min,sub_min)\\n        return max(sum1-sub_min, sum2+sub_max)\\n        \\n        \\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2465884,
                "title": "java-one-for-loop-to-calculate-gain-difference-between-arrays",
                "content": "We don\\'t need to calculate twice with largest gain between 2 arrays. We can calculate once and use min for opposite comparison between nums2 and nums1 (Calculate from nums1 point)\\n \\n ```\\n class Solution {\\n    public int maximumsSplicedArray(int[] nums1, int[] nums2) {\\n        int N = nums1.length, s1 = nums1[0], s2 = nums2[0];\\n        int[] gain = new int[N];\\n        gain[0] = nums2[0] - nums1[0];        \\n        for (int i = 1; i < N; i++) {\\n            gain[i] = gain[i - 1] + nums2[i] - nums1[i];\\n            s1 += nums1[i];\\n            s2 += nums2[i];\\n        }\\n        \\n        int min = 0, maxGain = Integer.MIN_VALUE;\\n        for (int i = 0; i < N; i++) {\\n            maxGain = Math.max(maxGain, gain[i] - min);\\n            min = Math.min(min, gain[i]);\\n        }\\n        \\n        int max = 0, minGain = Integer.MAX_VALUE;\\n        for (int i = 0; i < N; i++) {\\n            minGain = Math.min(minGain, gain[i] - max);\\n            max = Math.max(max, gain[i]);\\n        }\\n        \\n        return Math.max(Math.max(s1 + maxGain, s2 - minGain), Math.max(s1, s2));\\n    }\\n}\\n ```",
                "solutionTags": [],
                "code": "```\\n class Solution {\\n    public int maximumsSplicedArray(int[] nums1, int[] nums2) {\\n        int N = nums1.length, s1 = nums1[0], s2 = nums2[0];\\n        int[] gain = new int[N];\\n        gain[0] = nums2[0] - nums1[0];        \\n        for (int i = 1; i < N; i++) {\\n            gain[i] = gain[i - 1] + nums2[i] - nums1[i];\\n            s1 += nums1[i];\\n            s2 += nums2[i];\\n        }\\n        \\n        int min = 0, maxGain = Integer.MIN_VALUE;\\n        for (int i = 0; i < N; i++) {\\n            maxGain = Math.max(maxGain, gain[i] - min);\\n            min = Math.min(min, gain[i]);\\n        }\\n        \\n        int max = 0, minGain = Integer.MAX_VALUE;\\n        for (int i = 0; i < N; i++) {\\n            minGain = Math.min(minGain, gain[i] - max);\\n            max = Math.max(max, gain[i]);\\n        }\\n        \\n        return Math.max(Math.max(s1 + maxGain, s2 - minGain), Math.max(s1, s2));\\n    }\\n}\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2452783,
                "title": "greedy",
                "content": "first we have to find the sum of all the elemnts of nums1 and nums2;\\ni.e sum1=sum(nums1),  sum2=sum(nums2).\\nthen find the max   b/w   sum1  and sum2     fsum=max(sum1,sum2).\\n\\nnow we will do the swaping of contigious subarray of nums1 and nums2 and will find out which swaping is givingus max value either of nums1 or nums2.\\nthen we will compare this max value , which we have got after swaping,  with fsum and whosover will we maximum that will be our final ans.\\nbut there will be n*(n-1)/2 contigiuos subarray possible of the array of the length n;\\nso our code will run in O(n^2) time complexity but for n=10^5 this algo is not permissible; \\n\\nbut we can optimize this algo to O(n) as follow;\\n// after the swapping of any contigious subarray of nums1 (starting from index l to r) with contigious subarray (with same l and r) of nums2 our sum1 and sum2 will be changed to as as given below.\\nsum1=sum(nums1)-nums1[l......r]+nums2[l......r]\\nsum2=sum(nums1)-nums2[l......r]+nums1[l......r]\\n\\n Now modify it\\n sum1=sum(nums1)+ (  nums2[l......r]-nums1[l......r]) .\\n sum2=sum(nums1)-     (  nums2[l......r]-nums1[l......r]).\\n Now if we find  two set of l and r for which  expression (  nums2[l......r]-nums1[l......r]); is maximized and minimized respectively then we will add the maximum value of expression in sum 1 and  subtract  minimum value of expression from sum2  and then we will find which one is max . this new max value will we compared with prev max which we have got without any swapping.\\n and whosover will be maximum that will our final ans;\\n for finding the max and min ;\\n here we will initialise two vector  dp1 and dp2 of the type interger of the length n+1 with all initial value eqaul to 0;\\n and we will find the value of each index.\\n here value of ith  of dp1 and dp2 index will be sum of all the elements staring from 0th index to ith index of nums1 and  nums2 respectively;\\n Now we can write \\n nums1[l....r]=dp1[r]-dp1[l-1];\\n nums2[l....r]=dp2[r]-dp2[l-1];\\n Now  (  nums2[l......r]-nums1[l......r])=  dp2[r]-dp2[l-1]-(dp1[r]-dp1[l-1]);\\n \\n                                                             (dp2[r]-dp1[r])-(dp2[l-1]-dp1[l-1])\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  \\n\\t\\t\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  \\n\\t\\nNow if we for a new vector such that  newvector[i]=dp2[i]-dp1[i];\\n\\tand we find the two value such tha 2nd value appear after the first value and their diffrence is maximum then \\n\\tthis diff will the maxvalue of the expression  (  nums2[l......r]-nums1[l......r]);\\n\\tsame goes for minvalue;\\n\\n\\t\\t\\t\\t\\t\\n\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\n```\\nclass Solution {\\npublic:\\n  Solution(){\\n    std::ios_base::sync_with_stdio(false);\\n    std::cin.tie(nullptr);\\n  }\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n      int n=nums1.size();\\n      vector<long long>sum1;\\n       vector<long long>sum2;\\n      sum1.push_back(0);\\n      sum2.push_back(0);\\n      int i;\\n      for( i=0;i<n;i++){\\n        sum1.push_back(sum1.back()+nums1[i]);\\n        sum2.push_back(sum2.back()+nums2[i]);\\n                          }\\n      long long  fsum1=sum1[n];\\n      long long  fsum2=sum2[n];\\n      \\n      long long fans=max(fsum1,fsum2);\\n      \\n      for(int i=0;i<=n;i++){\\n        sum2[i]=sum2[i]-sum1[i];\\n        \\n                            }\\n     \\n      \\n      long long _maxdiff=INT_MIN,_min=0LL,_mindiff=INT_MAX,_max=0LL;\\n      \\n      for( i=1;i<=n;i++){\\n        if(sum2[i]-_min>_maxdiff)\\n            _maxdiff=sum2[i]-_min;\\n        \\n        if(_min>sum2[i])\\n                _min=sum2[i];\\n        \\n        if(sum2[i]-_max<_mindiff)\\n                   _mindiff=sum2[i]-_max;\\n        \\n        if(_max<sum2[i])\\n                  _max=sum2[i];\\n                               \\n                         }\\n      \\n      \\n     \\n      \\n      fans=max(fans,max(fsum2-_mindiff,fsum1+_maxdiff));\\n      \\n      \\n      return fans;\\n        \\n    }\\n};\\n```\\n\\t\\t\\t\\t\\t\\'\\'\\'\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  \\n \\n",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  Solution(){\\n    std::ios_base::sync_with_stdio(false);\\n    std::cin.tie(nullptr);\\n  }\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n      int n=nums1.size();\\n      vector<long long>sum1;\\n       vector<long long>sum2;\\n      sum1.push_back(0);\\n      sum2.push_back(0);\\n      int i;\\n      for( i=0;i<n;i++){\\n        sum1.push_back(sum1.back()+nums1[i]);\\n        sum2.push_back(sum2.back()+nums2[i]);\\n                          }\\n      long long  fsum1=sum1[n];\\n      long long  fsum2=sum2[n];\\n      \\n      long long fans=max(fsum1,fsum2);\\n      \\n      for(int i=0;i<=n;i++){\\n        sum2[i]=sum2[i]-sum1[i];\\n        \\n                            }\\n     \\n      \\n      long long _maxdiff=INT_MIN,_min=0LL,_mindiff=INT_MAX,_max=0LL;\\n      \\n      for( i=1;i<=n;i++){\\n        if(sum2[i]-_min>_maxdiff)\\n            _maxdiff=sum2[i]-_min;\\n        \\n        if(_min>sum2[i])\\n                _min=sum2[i];\\n        \\n        if(sum2[i]-_max<_mindiff)\\n                   _mindiff=sum2[i]-_max;\\n        \\n        if(_max<sum2[i])\\n                  _max=sum2[i];\\n                               \\n                         }\\n      \\n      \\n     \\n      \\n      fans=max(fans,max(fsum2-_mindiff,fsum1+_maxdiff));\\n      \\n      \\n      return fans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2450655,
                "title": "kadane-s-algo",
                "content": "```\\nclass Solution {\\npublic:\\nint helper(vector<int> &ar1,vector<int> &ar2){\\n    // returns max sum of ar1 assuming we are replacing elements of ar1 with ar2\\n    int n=ar1.size(),defaultSum=0;\\n    for(auto it:ar1) defaultSum+=it;\\n    vector<int> dif(n,0);\\n    for(int i=0;i<n;i++) dif[i]=ar2[i]-ar1[i];\\n    int sum=0,maxSum=dif[0];\\n    for(auto it:dif){\\n        sum+=it;\\n        maxSum=max(sum,maxSum);\\n        sum=max(0,sum);\\n    }\\n    return defaultSum+max(0,maxSum);\\n}\\n\\nint maximumsSplicedArray(vector<int>& ar1, vector<int>& ar2){\\n    return max(helper(ar1,ar2),helper(ar2,ar1));\\n}\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint helper(vector<int> &ar1,vector<int> &ar2){\\n    // returns max sum of ar1 assuming we are replacing elements of ar1 with ar2\\n    int n=ar1.size(),defaultSum=0;\\n    for(auto it:ar1) defaultSum+=it;\\n    vector<int> dif(n,0);\\n    for(int i=0;i<n;i++) dif[i]=ar2[i]-ar1[i];\\n    int sum=0,maxSum=dif[0];\\n    for(auto it:dif){\\n        sum+=it;\\n        maxSum=max(sum,maxSum);\\n        sum=max(0,sum);\\n    }\\n    return defaultSum+max(0,maxSum);\\n}\\n\\nint maximumsSplicedArray(vector<int>& ar1, vector<int>& ar2){\\n    return max(helper(ar1,ar2),helper(ar2,ar1));\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2449881,
                "title": "easy-understanding-c-solution",
                "content": "Read through the comments in the code.\\n```\\nclass Solution {\\npublic:\\n    int kadanes(vector<int> &v)\\n    {\\n        int i = 0, n = v.size(), prev_max = 0, curr_max, ans = 0;\\n        \\n        for(; i < n; i++)\\n        {\\n            curr_max = max(v[i], prev_max + v[i]);\\n            prev_max = curr_max;\\n            ans = max(ans, curr_max);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        // if we want to swap any part of the array then it must yield optimum that is max result\\n        // so let\\'s say we swapped [l..r] of nums1 with nums2 to make max num2 sum\\n        // so in order for that to work the new part [l..r] of nums2 must be greater than prev part [l..r]\\n        // That means the diff of new part and prev part [l..r] must be greater than zero\\n        // now we know that if the diff is greater than zero then we can swap, but in order to be max the diff should be max thus kadanes algo comes into play\\n        // we find the max diff that is replacable for both nums1 and nums2\\n        vector<int> diff1, diff2;\\n        int sum1 = 0, sum2 = 0;\\n        \\n        for(int i=0; i<nums1.size(); i++)\\n        {\\n            sum1 += nums1[i];\\n            sum2 += nums2[i];\\n            diff1.push_back(nums2[i] - nums1[i]);            \\n            diff2.push_back(nums1[i] - nums2[i]);\\n        }\\n        \\n        int ans = max(sum1 + kadanes(diff1), sum2 + kadanes(diff2));\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nPlease upvote if it helps ;)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kadanes(vector<int> &v)\\n    {\\n        int i = 0, n = v.size(), prev_max = 0, curr_max, ans = 0;\\n        \\n        for(; i < n; i++)\\n        {\\n            curr_max = max(v[i], prev_max + v[i]);\\n            prev_max = curr_max;\\n            ans = max(ans, curr_max);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        // if we want to swap any part of the array then it must yield optimum that is max result\\n        // so let\\'s say we swapped [l..r] of nums1 with nums2 to make max num2 sum\\n        // so in order for that to work the new part [l..r] of nums2 must be greater than prev part [l..r]\\n        // That means the diff of new part and prev part [l..r] must be greater than zero\\n        // now we know that if the diff is greater than zero then we can swap, but in order to be max the diff should be max thus kadanes algo comes into play\\n        // we find the max diff that is replacable for both nums1 and nums2\\n        vector<int> diff1, diff2;\\n        int sum1 = 0, sum2 = 0;\\n        \\n        for(int i=0; i<nums1.size(); i++)\\n        {\\n            sum1 += nums1[i];\\n            sum2 += nums2[i];\\n            diff1.push_back(nums2[i] - nums1[i]);            \\n            diff2.push_back(nums1[i] - nums2[i]);\\n        }\\n        \\n        int ans = max(sum1 + kadanes(diff1), sum2 + kadanes(diff2));\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2442419,
                "title": "simplest-python-solution",
                "content": "```\\nclass Solution:\\n    def fun(self,nums1,nums2):\\n        s = sum(nums1)\\n        x = [j-i for i,j in zip(nums1,nums2)]\\n        mxcur = 0\\n        mxtillnow = 0\\n        for i in x:\\n            mxcur += i \\n            mxtillnow = max(mxtillnow,mxcur)\\n            mxcur=max(0,mxcur)\\n        return s + mxtillnow\\n    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n        return max(self.fun(nums1,nums2),self.fun(nums2,nums1))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def fun(self,nums1,nums2):\\n        s = sum(nums1)\\n        x = [j-i for i,j in zip(nums1,nums2)]\\n        mxcur = 0\\n        mxtillnow = 0\\n        for i in x:\\n            mxcur += i \\n            mxtillnow = max(mxtillnow,mxcur)\\n            mxcur=max(0,mxcur)\\n        return s + mxtillnow\\n    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n        return max(self.fun(nums1,nums2),self.fun(nums2,nums1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2437882,
                "title": "short-python",
                "content": "```\\nclass Solution:\\n    def maximumsSplicedArray(self, nums1, nums2):\\n        d1 = [b - a for a, b in zip(nums1, nums2)]\\n        d2 = [a - b for a, b in zip(nums1, nums2)]\\n\\n        def d(diff):\\n            mn, mx, ps = 0, 0, 0\\n            for k in diff:\\n                ps += k\\n                mx = max(mx, ps - mn)\\n                mn = min(mn, ps)\\n            return mx\\n\\n        return max(sum(nums1) + d(d1), sum(nums2) + d(d2))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumsSplicedArray(self, nums1, nums2):\\n        d1 = [b - a for a, b in zip(nums1, nums2)]\\n        d2 = [a - b for a, b in zip(nums1, nums2)]\\n\\n        def d(diff):\\n            mn, mx, ps = 0, 0, 0\\n            for k in diff:\\n                ps += k\\n                mx = max(mx, ps - mn)\\n                mn = min(mn, ps)\\n            return mx\\n\\n        return max(sum(nums1) + d(d1), sum(nums2) + d(d2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2405675,
                "title": "simple-kadane-o-n-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int>num;\\n        vector<int>num1;\\n        int sum1=0;\\n        int sum2=0;\\n        for(int i=0;i<nums1.size();i++){\\n            sum1+=nums1[i];\\n            sum2+=nums2[i];\\n        }\\n        for(int i=0;i<nums1.size();i++){\\n            num.push_back(nums2[i]-nums1[i]);\\n            num1.push_back(nums1[i]-nums2[i]);\\n        }\\n        long long maxSoFar=INT_MIN;\\n        long long currentSum=0;\\n        \\n        for(int i=0;i<num.size();i++){\\n            currentSum+=num[i];\\n            maxSoFar=max(maxSoFar,currentSum);\\n            if(currentSum<0){\\n                currentSum=0;\\n            }\\n        }\\n        if(maxSoFar>0)sum1+=maxSoFar;\\n        maxSoFar=INT_MIN;\\n        currentSum=0;\\n        \\n        for(int i=0;i<num1.size();i++){\\n            currentSum+=num1[i];\\n            maxSoFar=max(maxSoFar,currentSum);\\n            if(currentSum<0){\\n                currentSum=0;\\n            }\\n        }\\n        if(maxSoFar>0)sum2+=maxSoFar;\\n        \\n        return max(sum1,sum2);\\n     \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        vector<int>num;\\n        vector<int>num1;\\n        int sum1=0;\\n        int sum2=0;\\n        for(int i=0;i<nums1.size();i++){\\n            sum1+=nums1[i];\\n            sum2+=nums2[i];\\n        }\\n        for(int i=0;i<nums1.size();i++){\\n            num.push_back(nums2[i]-nums1[i]);\\n            num1.push_back(nums1[i]-nums2[i]);\\n        }\\n        long long maxSoFar=INT_MIN;\\n        long long currentSum=0;\\n        \\n        for(int i=0;i<num.size();i++){\\n            currentSum+=num[i];\\n            maxSoFar=max(maxSoFar,currentSum);\\n            if(currentSum<0){\\n                currentSum=0;\\n            }\\n        }\\n        if(maxSoFar>0)sum1+=maxSoFar;\\n        maxSoFar=INT_MIN;\\n        currentSum=0;\\n        \\n        for(int i=0;i<num1.size();i++){\\n            currentSum+=num1[i];\\n            maxSoFar=max(maxSoFar,currentSum);\\n            if(currentSum<0){\\n                currentSum=0;\\n            }\\n        }\\n        if(maxSoFar>0)sum2+=maxSoFar;\\n        \\n        return max(sum1,sum2);\\n     \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2383211,
                "title": "simple-kadane",
                "content": "```\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        int S1 = 0;\\n        int S2 = 0;\\n\\n        int b1 = 0;\\n        int c1 = 0;\\n\\n        int b2 = 0;\\n        int c2 = 0;\\n\\n        for(int i = 0; i < n; ++i){\\n            S1 += nums1[i];\\n            S2 += nums2[i];\\n            \\n            int q = nums1[i] - nums2[i];\\n\\n            c1 = std::max(0, q + c1);\\n            b1 = std::max(b1, c1);\\n\\n            c2 = std::max(0, -q + c2);\\n            b2 = std::max(b2, c2);\\n        }\\n\\n        int mx = std::max(S1, S2);\\n        mx = std::max({mx, S1 + b2, S2 + b1});\\n\\n        return mx;\\n    }\\n```\\t\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size();\\n        int S1 = 0;\\n        int S2 = 0;\\n\\n        int b1 = 0;\\n        int c1 = 0;\\n\\n        int b2 = 0;\\n        int c2 = 0;\\n\\n        for(int i = 0; i < n; ++i){\\n            S1 += nums1[i];\\n            S2 += nums2[i];\\n            \\n            int q = nums1[i] - nums2[i];\\n\\n            c1 = std::max(0, q + c1);\\n            b1 = std::max(b1, c1);\\n\\n            c2 = std::max(0, -q + c2);\\n            b2 = std::max(b2, c2);\\n        }\\n\\n        int mx = std::max(S1, S2);\\n        mx = std::max({mx, S1 + b2, S2 + b1});\\n\\n        return mx;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2363497,
                "title": "c-o-n-kadane",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int s1 = 0, s2 = 0;\\n\\t\\tfor (int &x: nums1) s1 += x;\\n\\t\\tfor (int &x: nums2) s2 += x;\\n\\t\\tint n = nums1.size();\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tnums2[i] -= nums1[i]; \\n\\t\\t}\\n\\t\\t\\n\\t\\tauto getMaxSubarray = [](vector<int> &nums) {\\n\\t\\t\\tint mx = 0, prev = 0;\\n\\t\\t\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\t\\t\\tint cur = nums[i] + prev;\\n\\t\\t\\t\\tmx = max(mx, cur);\\n\\t\\t\\t\\tprev = max(cur, 0);\\n\\t\\t\\t}\\n\\t\\t\\treturn mx;\\n\\t\\t};\\n\\t\\t\\n\\t\\tint ans = s1 + getMaxSubarray(nums2);\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tnums2[i] += nums1[i];\\n\\t\\t\\tnums1[i] -= nums2[i];\\n\\t\\t}\\n\\t\\tans = max(ans, s2 + getMaxSubarray(nums1));\\n\\t\\treturn ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int s1 = 0, s2 = 0;\\n\\t\\tfor (int &x: nums1) s1 += x;\\n\\t\\tfor (int &x: nums2) s2 += x;\\n\\t\\tint n = nums1.size();\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tnums2[i] -= nums1[i]; \\n\\t\\t}\\n\\t\\t\\n\\t\\tauto getMaxSubarray = [](vector<int> &nums) {\\n\\t\\t\\tint mx = 0, prev = 0;\\n\\t\\t\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\t\\t\\tint cur = nums[i] + prev;\\n\\t\\t\\t\\tmx = max(mx, cur);\\n\\t\\t\\t\\tprev = max(cur, 0);\\n\\t\\t\\t}\\n\\t\\t\\treturn mx;\\n\\t\\t};\\n\\t\\t\\n\\t\\tint ans = s1 + getMaxSubarray(nums2);\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tnums2[i] += nums1[i];\\n\\t\\t\\tnums1[i] -= nums2[i];\\n\\t\\t}\\n\\t\\tans = max(ans, s2 + getMaxSubarray(nums1));\\n\\t\\treturn ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2305528,
                "title": "c-easy-to-understand-maximum-sum-of-subarray",
                "content": "```\\nclass Solution {\\npublic:\\n//Kadane\\'s Algo to find maximum subarray sum\\n    int maxSubArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int sum=0;\\n        int maxi=nums[0];\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=nums[i];\\n            maxi=max(maxi,sum);\\n            if(sum<0)\\n                sum=0;\\n            \\n        }\\n        return maxi;\\n    }\\n\\t//this function considers nums1 to hold the greater sum as result\\n    int solve(vector<int>& nums1, vector<int>& nums2,int n,int sum,vector<int>&diff)\\n    {\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            diff[i]=nums2[i]-nums1[i];\\n        }\\n        int maxi=maxSubArray(diff);\\n\\t\\t//if the maximum of the subarray is negative...for ex: all the nos. in diff are negative then maxi will be the element which is least negative\\n        if(maxi<0)\\n            return sum;\\n\\t\\t\\t\\n        return sum+maxi;\\n        \\n    }\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size();\\n        vector<int>diff(n);\\n        int sum1=0,sum2=0;\\n        for(int i:nums1)\\n            sum1+=i;\\n        for(int i:nums2)\\n            sum2+=i;\\n\\t\\t//calling solve with nums1 as 1st vector\\n        int a=solve(nums1,nums2,n,sum1,diff);\\n\\t\\t//calling solve with nums2 as 1st vector\\n        int b=solve(nums2,nums1,n,sum2,diff);\\n\\t\\t\\n        return max(a,b);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n//Kadane\\'s Algo to find maximum subarray sum\\n    int maxSubArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int sum=0;\\n        int maxi=nums[0];\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=nums[i];\\n            maxi=max(maxi,sum);\\n            if(sum<0)\\n                sum=0;\\n            \\n        }\\n        return maxi;\\n    }\\n\\t//this function considers nums1 to hold the greater sum as result\\n    int solve(vector<int>& nums1, vector<int>& nums2,int n,int sum,vector<int>&diff)\\n    {\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            diff[i]=nums2[i]-nums1[i];\\n        }\\n        int maxi=maxSubArray(diff);\\n\\t\\t//if the maximum of the subarray is negative...for ex: all the nos. in diff are negative then maxi will be the element which is least negative\\n        if(maxi<0)\\n            return sum;\\n\\t\\t\\t\\n        return sum+maxi;\\n        \\n    }\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size();\\n        vector<int>diff(n);\\n        int sum1=0,sum2=0;\\n        for(int i:nums1)\\n            sum1+=i;\\n        for(int i:nums2)\\n            sum2+=i;\\n\\t\\t//calling solve with nums1 as 1st vector\\n        int a=solve(nums1,nums2,n,sum1,diff);\\n\\t\\t//calling solve with nums2 as 1st vector\\n        int b=solve(nums2,nums1,n,sum2,diff);\\n\\t\\t\\n        return max(a,b);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2264024,
                "title": "simple-sliding-window-two-pointer-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int> &nums1,vector<int> &nums2){\\n        vector<int> p1,p2;\\n        int val=0;\\n        for(auto x:nums1){\\n            val+=x;\\n            p1.push_back(val);\\n        }\\n        \\n        val=0;\\n        for(auto x:nums2){\\n            val+=x;\\n            p2.push_back(val);\\n        }\\n        vector<vector<int>> sub;\\n        int val1=0,val2=0;\\n        int s=0;\\n        for(int e=0;e<nums1.size();e++){\\n            val1+=nums1[e];\\n            val2+=nums2[e];\\n            while(val1>val2){\\n                val1-=nums1[s];\\n                val2-=nums2[s];\\n                s++;\\n            }\\n            if(val1<val2){\\n                sub.push_back({s,e});\\n            }\\n        }\\n        int ans=0;\\n        for(auto x:sub){\\n            int st=x[0],en=x[1];\\n            int a1=(st-1>=0? p1[st-1]:0)+(p1[nums1.size()-1]-(en>=0 ?p1[en]:0));\\n            int a2=p2[en]-(st>0?p2[st-1]:0);\\n            ans=max(ans,a1+a2);\\n        }\\n        ans=max(ans,p1[nums1.size()-1]);\\n        return ans;\\n    }\\n    \\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int a1=solve(nums1,nums2);\\n        int a2=solve(nums2,nums1);\\n\\n        return max(a1,a2);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int> &nums1,vector<int> &nums2){\\n        vector<int> p1,p2;\\n        int val=0;\\n        for(auto x:nums1){\\n            val+=x;\\n            p1.push_back(val);\\n        }\\n        \\n        val=0;\\n        for(auto x:nums2){\\n            val+=x;\\n            p2.push_back(val);\\n        }\\n        vector<vector<int>> sub;\\n        int val1=0,val2=0;\\n        int s=0;\\n        for(int e=0;e<nums1.size();e++){\\n            val1+=nums1[e];\\n            val2+=nums2[e];\\n            while(val1>val2){\\n                val1-=nums1[s];\\n                val2-=nums2[s];\\n                s++;\\n            }\\n            if(val1<val2){\\n                sub.push_back({s,e});\\n            }\\n        }\\n        int ans=0;\\n        for(auto x:sub){\\n            int st=x[0],en=x[1];\\n            int a1=(st-1>=0? p1[st-1]:0)+(p1[nums1.size()-1]-(en>=0 ?p1[en]:0));\\n            int a2=p2[en]-(st>0?p2[st-1]:0);\\n            ans=max(ans,a1+a2);\\n        }\\n        ans=max(ans,p1[nums1.size()-1]);\\n        return ans;\\n    }\\n    \\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int a1=solve(nums1,nums2);\\n        int a2=solve(nums2,nums1);\\n\\n        return max(a1,a2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2262373,
                "title": "dp-soln-c-o-n",
                "content": "Below is the my simple DP solution: with explanation-`\\n\\nfor every index we will have three states:\\nState 0 represents we are continuing the same array\\nState 1 represents we are taking values from opposite array to swap\\nState 2 reqpresents we have taken subarray from opposite array and now continuing the original array.\\n\\nFinally the answer is maximum of all values calculated for both arrays.\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int n = (int)nums1.size();\\n        vector<vector<int> > dp1(n + 1, vector<int>(3, 0));\\n        vector<vector<int> > dp2(n + 1, vector<int>(3, 0));\\n        for (int i = 1 ; i <= n ; i++)\\n        {\\n            // For 1st array with subarray from 2nd array\\n            dp1[i][0] = dp1[i - 1][0] + nums1[i - 1];\\n            dp1[i][1] = max(dp1[i - 1][1], dp1[i - 1][0]) + nums2[i - 1];\\n            dp1[i][2] = max(dp1[i - 1][1], dp1[i - 1][2]) + nums1[i - 1];\\n            \\n            // For 2nd array with subarray from 1st array\\n            dp2[i][0] = dp2[i - 1][0] + nums2[i - 1];\\n            dp2[i][1] = max(dp2[i - 1][1], dp2[i - 1][0]) + nums1[i - 1];\\n            dp2[i][2] = max(dp2[i - 1][1], dp2[i - 1][2]) + nums2[i - 1];\\n        }\\n        return max({dp1[n][0], dp1[n][1], dp1[n][2], dp2[n][0], dp2[n][1], dp2[n][2]});\\n    }\\n};\\n```\\n\\nTime Complexity : O(N)\\nSpace Complexity : O(N) approx\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int n = (int)nums1.size();\\n        vector<vector<int> > dp1(n + 1, vector<int>(3, 0));\\n        vector<vector<int> > dp2(n + 1, vector<int>(3, 0));\\n        for (int i = 1 ; i <= n ; i++)\\n        {\\n            // For 1st array with subarray from 2nd array\\n            dp1[i][0] = dp1[i - 1][0] + nums1[i - 1];\\n            dp1[i][1] = max(dp1[i - 1][1], dp1[i - 1][0]) + nums2[i - 1];\\n            dp1[i][2] = max(dp1[i - 1][1], dp1[i - 1][2]) + nums1[i - 1];\\n            \\n            // For 2nd array with subarray from 1st array\\n            dp2[i][0] = dp2[i - 1][0] + nums2[i - 1];\\n            dp2[i][1] = max(dp2[i - 1][1], dp2[i - 1][0]) + nums1[i - 1];\\n            dp2[i][2] = max(dp2[i - 1][1], dp2[i - 1][2]) + nums2[i - 1];\\n        }\\n        return max({dp1[n][0], dp1[n][1], dp1[n][2], dp2[n][0], dp2[n][1], dp2[n][2]});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2252945,
                "title": "java-solution",
                "content": "class Solution {\\n    \\n    public int maxsubarray(int[] a)\\n\\t{\\n\\t\\tint size = a.length;\\n        int max_so_far = Integer.MIN_VALUE, max_ending_here = 0;\\n  \\n        for (int i = 0; i < size; i++)\\n        {\\n            max_ending_here = max_ending_here + a[i];\\n            if (max_so_far < max_ending_here)\\n                max_so_far = max_ending_here;\\n            if (max_ending_here < 0)\\n                max_ending_here = 0;\\n        }\\n        return max_so_far;\\n\\t}\\n    \\n    public int maximumsSplicedArray(int[] nums1, int[] nums2) {int sum1=0;int sum2=0;\\n\\t\\tint[] A=new int[nums1.length];\\n\\t\\tint[] B=new int[nums1.length];\\n\\t\\t\\n\\t\\tfor(int i=0;i<A.length;i++)\\n\\t\\t{\\n\\t\\t\\tA[i]=nums1[i]-nums2[i];\\n\\t\\t\\tB[i]=nums2[i]-nums1[i];\\n\\t\\t\\tsum1=sum1+nums1[i];\\n\\t\\t\\tsum2=sum2+nums2[i];\\n\\t\\t}\\n\\t\\t\\n\\t\\tint m=maxsubarray(A);\\n        int n=maxsubarray(B);\\n     \\n        int max=Math.max(sum1+n,sum2+m);\\n        return max;\\n        \\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    public int maxsubarray(int[] a)\\n\\t{\\n\\t\\tint size = a.length;\\n        int max_so_far = Integer.MIN_VALUE, max_ending_here = 0;\\n  \\n        for (int i = 0; i < size; i++)\\n        {\\n            max_ending_here = max_ending_here + a[i];\\n            if (max_so_far < max_ending_here)\\n                max_so_far = max_ending_here;\\n            if (max_ending_here < 0)\\n                max_ending_here = 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2250297,
                "title": "simple-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int ans=0,n=nums1.size();\\n        int sum1=0,sum2=0,cnt1=0,cnt2=0,ans1=0,ans2=0;\\n        for(auto x:nums1) sum1+=x;\\n        for(auto x:nums2) sum2+=x;\\n        for(int i=0;i<n;i++){\\n             cnt2 += nums1[i] - nums2[i];\\n             cnt1 += nums2[i] - nums1[i];\\n            ans1 = max(ans1,cnt1);\\n            ans2 = max(ans2,cnt2);\\n            if(cnt1<0) cnt1=0;\\n            if(cnt2<0) cnt2=0;\\n        }\\n        return max(sum1+ans1,sum2+ans2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int ans=0,n=nums1.size();\\n        int sum1=0,sum2=0,cnt1=0,cnt2=0,ans1=0,ans2=0;\\n        for(auto x:nums1) sum1+=x;\\n        for(auto x:nums2) sum2+=x;\\n        for(int i=0;i<n;i++){\\n             cnt2 += nums1[i] - nums2[i];\\n             cnt1 += nums2[i] - nums1[i];\\n            ans1 = max(ans1,cnt1);\\n            ans2 = max(ans2,cnt2);\\n            if(cnt1<0) cnt1=0;\\n            if(cnt2<0) cnt2=0;\\n        }\\n        return max(sum1+ans1,sum2+ans2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2239120,
                "title": "clear-python-recursive-solution-o-n-kadane",
                "content": "\\tclass Solution:\\n\\t\\tdef maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n\\t\\t\\ta = self.compute(nums1, nums2)\\n\\t\\t\\tb = self.compute(nums2, nums1)\\n\\t\\t\\treturn max(a, b, sum(nums1), sum(nums2))\\n\\n\\t\\tdef compute(self, A, B):\\n\\t\\t\\tN = len(A)\\n\\t\\t\\tD = [y-x for x,y in zip(A,B)]\\n\\t\\t\\tSD = [0] + list(accumulate(D))\\n\\n\\t\\t\\t@cache\\n\\t\\t\\tdef f(i) -> int: # Returns start index for maximum subarray that ends at i\\n\\t\\t\\t\\tif i == 0:\\n\\t\\t\\t\\t\\treturn 0\\n\\n\\t\\t\\t\\tk = f(i-1)\\n\\t\\t\\t\\tif D[i] > SD[i+1] - SD[k]:\\n\\t\\t\\t\\t\\treturn i\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn k\\n\\n\\n\\t\\t\\ti,j,ma = max([(i:=f(j), j, SD[j+1] - SD[i]) for j in range(N)], \\n\\t\\t\\t\\t\\t\\t key=lambda x: x[2])\\n\\n\\n\\t\\t\\treturn sum(A) + ma\\n\\n",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n\\t\\t\\ta = self.compute(nums1, nums2)\\n\\t\\t\\tb = self.compute(nums2, nums1)\\n\\t\\t\\treturn max(a, b, sum(nums1), sum(nums2))\\n\\n\\t\\tdef compute(self, A, B):\\n\\t\\t\\tN = len(A)\\n\\t\\t\\tD = [y-x for x,y in zip(A,B)]\\n\\t\\t\\tSD = [0] + list(accumulate(D))\\n\\n\\t\\t\\t@cache\\n\\t\\t\\tdef f(i) -> int: # Returns start index for maximum subarray that ends at i\\n\\t\\t\\t\\tif i == 0:\\n\\t\\t\\t\\t\\treturn 0\\n\\n\\t\\t\\t\\tk = f(i-1)\\n\\t\\t\\t\\tif D[i] > SD[i+1] - SD[k]:\\n\\t\\t\\t\\t\\treturn i\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn k\\n\\n\\n\\t\\t\\ti,j,ma = max([(i:=f(j), j, SD[j+1] - SD[i]) for j in range(N)], \\n\\t\\t\\t\\t\\t\\t key=lambda x: x[2])\\n\\n\\n\\t\\t\\treturn sum(A) + ma\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 2235367,
                "title": "concise-implementation-with-python-faster-than-88",
                "content": "```\\nclass Solution:\\n    def find_max_subarray(self, nums):\\n        left, right = 0, 0\\n        j = 0\\n        for i in range(len(nums)):\\n            if i > 0 and nums[i-1] > 0:\\n                nums[i] += nums[i-1]\\n            else:\\n                j = i\\n            if nums[i] > nums[right]:\\n                left, right = j, i\\n        return left, right\\n            \\n    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n        l1, r1 = self.find_max_subarray([x - y for x, y in zip(nums1, nums2)])\\n        l2, r2 = self.find_max_subarray([y - x for x, y in zip(nums1, nums2)])\\n        s1, s2 = 0, 0\\n        for i in range(len(nums1)):\\n            s1 += nums1[i] if l1 <= i <= r1 else nums2[i]\\n            s2 += nums2[i] if l2 <= i <= r2 else nums1[i]\\n        return max(s1, s2)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def find_max_subarray(self, nums):\\n        left, right = 0, 0\\n        j = 0\\n        for i in range(len(nums)):\\n            if i > 0 and nums[i-1] > 0:\\n                nums[i] += nums[i-1]\\n            else:\\n                j = i\\n            if nums[i] > nums[right]:\\n                left, right = j, i\\n        return left, right\\n            \\n    def maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n        l1, r1 = self.find_max_subarray([x - y for x, y in zip(nums1, nums2)])\\n        l2, r2 = self.find_max_subarray([y - x for x, y in zip(nums1, nums2)])\\n        s1, s2 = 0, 0\\n        for i in range(len(nums1)):\\n            s1 += nums1[i] if l1 <= i <= r1 else nums2[i]\\n            s2 += nums2[i] if l2 <= i <= r2 else nums1[i]\\n        return max(s1, s2)",
                "codeTag": "Java"
            },
            {
                "id": 2232375,
                "title": "python3-with-explanation",
                "content": "```\\ndef maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n        # equivalent of finding left and right where max(sum(nums1[left:right+1])-sum(nums2[left:right+1])) or max(sum(nums2[left:right+1])-sum(nums1[left:right+1])) \\n        x = sum(nums2) + self.change(nums1, nums2)\\n        y = sum(nums1) + self.change(nums2, nums1)\\n        return max(x, y)\\n        \\n    # this function finds the max(sum(nums1[left:right+1])-sum(nums2[left:right+1]))\\n    def change(self, nums1: List[int], nums2: List[int]) -> int:\\n        l = len(nums1)\\n        nums = [0]*l\\n        for i in range(l):\\n            nums[i] = nums1[i] - nums2[i]\\n        dp = [0]*l\\n        for i in range(l):\\n            dp[i] = dp[i-1] + nums[i]\\n            if dp[i]<=0:\\n                dp[i] = 0\\n        return max(dp)",
                "solutionTags": [],
                "code": "```\\ndef maximumsSplicedArray(self, nums1: List[int], nums2: List[int]) -> int:\\n        # equivalent of finding left and right where max(sum(nums1[left:right+1])-sum(nums2[left:right+1])) or max(sum(nums2[left:right+1])-sum(nums1[left:right+1])) \\n        x = sum(nums2) + self.change(nums1, nums2)\\n        y = sum(nums1) + self.change(nums2, nums1)\\n        return max(x, y)\\n        \\n    # this function finds the max(sum(nums1[left:right+1])-sum(nums2[left:right+1]))\\n    def change(self, nums1: List[int], nums2: List[int]) -> int:\\n        l = len(nums1)\\n        nums = [0]*l\\n        for i in range(l):\\n            nums[i] = nums1[i] - nums2[i]\\n        dp = [0]*l\\n        for i in range(l):\\n            dp[i] = dp[i-1] + nums[i]\\n            if dp[i]<=0:\\n                dp[i] = 0\\n        return max(dp)",
                "codeTag": "Python3"
            },
            {
                "id": 2231058,
                "title": "c-solution",
                "content": "```\\n public int MaximumsSplicedArray(int[] nums1, int[] nums2)\\n        {\\n            var n = nums1.Length;\\n\\n            var total1 = 0;\\n            var total2 = 0;\\n\\n            for (var i = 0; i < n; i++)\\n            {\\n                total1 += nums1[i];\\n                total2 += nums2[i];\\n            }\\n\\n            var sum1 = nums1[0];\\n            var sum2 = nums2[0];\\n            var maxScore = Math.Max(sum1, sum2);\\n\\n            var prefixDiff1 = sum1 - sum2;\\n            var prefixDiff2 = sum2 - sum1;\\n\\n            for (var i = 1; i < n; i++)\\n            {\\n                sum1 += nums1[i];\\n                sum2 += nums2[i];\\n\\n                var maxCurrentScore = Math.Max(total2 - sum2 + sum1 + prefixDiff2,\\n                                               total1 - sum1 + sum2 + prefixDiff1);\\n\\n                maxScore = Math.Max(maxScore, maxCurrentScore);\\n\\n                prefixDiff1 = Math.Max(prefixDiff1, sum1 - sum2);\\n                prefixDiff2 = Math.Max(prefixDiff2, sum2 - sum1);\\n            }\\n\\n            return maxScore;\\n        }\\n\\n\\t\\t\\t```",
                "solutionTags": [],
                "code": "```\\n public int MaximumsSplicedArray(int[] nums1, int[] nums2)\\n        {\\n            var n = nums1.Length;\\n\\n            var total1 = 0;\\n            var total2 = 0;\\n\\n            for (var i = 0; i < n; i++)\\n            {\\n                total1 += nums1[i];\\n                total2 += nums2[i];\\n            }\\n\\n            var sum1 = nums1[0];\\n            var sum2 = nums2[0];\\n            var maxScore = Math.Max(sum1, sum2);\\n\\n            var prefixDiff1 = sum1 - sum2;\\n            var prefixDiff2 = sum2 - sum1;\\n\\n            for (var i = 1; i < n; i++)\\n            {\\n                sum1 += nums1[i];\\n                sum2 += nums2[i];\\n\\n                var maxCurrentScore = Math.Max(total2 - sum2 + sum1 + prefixDiff2,\\n                                               total1 - sum1 + sum2 + prefixDiff1);\\n\\n                maxScore = Math.Max(maxScore, maxCurrentScore);\\n\\n                prefixDiff1 = Math.Max(prefixDiff1, sum1 - sum2);\\n                prefixDiff2 = Math.Max(prefixDiff2, sum2 - sum1);\\n            }\\n\\n            return maxScore;\\n        }\\n\\n\\t\\t\\t```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1795300,
                "content": [
                    {
                        "username": "Finesse",
                        "content": "Make a third array that shows the profit of swapping each index of the arrays (`profits[i] = nums2[i] - nums1[i]`). Use [the Kadane's algorithm](https://en.wikipedia.org/wiki/Maximum_subarray_problem#Empty_subarrays_admitted) to find its best subarray (i.e. the maximum profit). You can use an iterator instead of the third array because the Kaden's algorithm takes only 1 pass.\n\nThis is much easier to comprehend and implement than what the official tips suggest."
                    },
                    {
                        "username": "itsyaswanth",
                        "content": "Given 2 arrays nums1,nums2. We are asked to perform an operation to replace a part of nums1 with nums2 and return the max sum subarray that can be formed.\\n![image](https://assets.leetcode.com/users/images/426b9a1b-194b-4e22-849a-6ad83db98d79_1656309494.0796635.jpeg)\\n![image](https://assets.leetcode.com/users/images/823811fa-abc6-4353-8092-83a91ee8535a_1656309502.3118556.jpeg)\\n\\n"
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "O(N^2) will give TLE so dont waste time like me :( \\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int sum1 = nums1[0] , sum2 = nums2[0] ;\\n        vector<int> pre1;\\n        vector<int> pre2;\\n        pre1.push_back(sum1);\\n        pre2.push_back(sum2);\\n        for(int i=1; i<nums1.size(); i++){\\n            sum1+=nums1[i];\\n            sum2+=nums2[i];\\n            pre1.push_back(sum1);\\n            pre2.push_back(sum2);\\n        }\\n        // sum l to r is pre1[r] - pre1[l-1]\\n        int ans = max(sum1,sum2);\\n        // sum1 + (nums2[l,r] - nums1[l,r])\\n        // sum1 + (pre2[r]-pre2[l-1]-(pre1[r]-pre1[l-1]))\\n        for(int i=0; i<nums1.size(); i++){\\n            ans = max({ans,sum1-pre1[i]+pre2[i],sum2+pre1[i]-pre2[i]});\\n        }\\n        for(int l=1; l<nums1.size(); l++){\\n            for(int r=l; r<nums1.size(); r++){\\n                ans = max({ans,(sum1+(pre2[r]-pre2[l-1])-(pre1[r]-pre1[l-1])),(sum2+(pre1[r]-pre1[l-1])-(pre2[r]-pre2[l-1]))});\\n            }\\n        }\\n        return ans ;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "AV2606",
                        "content": "isnt the score of nums1=[20,40,20,70,30] and nums2=[50,20,50,40,20] 240 instead of 220?\\nwe can choose left=0 and right=2 and get [50,40,50,70,30]=>50+40+50+70+30=240"
                    },
                    {
                        "username": "AmaanRizvi",
                        "content": "As the question says maximum \"subarray\" that means you have to swap all the elements from left to right i.e(you need to completely swap [20,40,20] with [50,20,50] which will give you nums1=[50,20,50,70,30] which is again 220 \\n"
                    }
                ]
            },
            {
                "id": 1576951,
                "content": [
                    {
                        "username": "Finesse",
                        "content": "Make a third array that shows the profit of swapping each index of the arrays (`profits[i] = nums2[i] - nums1[i]`). Use [the Kadane's algorithm](https://en.wikipedia.org/wiki/Maximum_subarray_problem#Empty_subarrays_admitted) to find its best subarray (i.e. the maximum profit). You can use an iterator instead of the third array because the Kaden's algorithm takes only 1 pass.\n\nThis is much easier to comprehend and implement than what the official tips suggest."
                    },
                    {
                        "username": "itsyaswanth",
                        "content": "Given 2 arrays nums1,nums2. We are asked to perform an operation to replace a part of nums1 with nums2 and return the max sum subarray that can be formed.\\n![image](https://assets.leetcode.com/users/images/426b9a1b-194b-4e22-849a-6ad83db98d79_1656309494.0796635.jpeg)\\n![image](https://assets.leetcode.com/users/images/823811fa-abc6-4353-8092-83a91ee8535a_1656309502.3118556.jpeg)\\n\\n"
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "O(N^2) will give TLE so dont waste time like me :( \\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int sum1 = nums1[0] , sum2 = nums2[0] ;\\n        vector<int> pre1;\\n        vector<int> pre2;\\n        pre1.push_back(sum1);\\n        pre2.push_back(sum2);\\n        for(int i=1; i<nums1.size(); i++){\\n            sum1+=nums1[i];\\n            sum2+=nums2[i];\\n            pre1.push_back(sum1);\\n            pre2.push_back(sum2);\\n        }\\n        // sum l to r is pre1[r] - pre1[l-1]\\n        int ans = max(sum1,sum2);\\n        // sum1 + (nums2[l,r] - nums1[l,r])\\n        // sum1 + (pre2[r]-pre2[l-1]-(pre1[r]-pre1[l-1]))\\n        for(int i=0; i<nums1.size(); i++){\\n            ans = max({ans,sum1-pre1[i]+pre2[i],sum2+pre1[i]-pre2[i]});\\n        }\\n        for(int l=1; l<nums1.size(); l++){\\n            for(int r=l; r<nums1.size(); r++){\\n                ans = max({ans,(sum1+(pre2[r]-pre2[l-1])-(pre1[r]-pre1[l-1])),(sum2+(pre1[r]-pre1[l-1])-(pre2[r]-pre2[l-1]))});\\n            }\\n        }\\n        return ans ;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "AV2606",
                        "content": "isnt the score of nums1=[20,40,20,70,30] and nums2=[50,20,50,40,20] 240 instead of 220?\\nwe can choose left=0 and right=2 and get [50,40,50,70,30]=>50+40+50+70+30=240"
                    },
                    {
                        "username": "AmaanRizvi",
                        "content": "As the question says maximum \"subarray\" that means you have to swap all the elements from left to right i.e(you need to completely swap [20,40,20] with [50,20,50] which will give you nums1=[50,20,50,70,30] which is again 220 \\n"
                    }
                ]
            },
            {
                "id": 2017664,
                "content": [
                    {
                        "username": "Finesse",
                        "content": "Make a third array that shows the profit of swapping each index of the arrays (`profits[i] = nums2[i] - nums1[i]`). Use [the Kadane's algorithm](https://en.wikipedia.org/wiki/Maximum_subarray_problem#Empty_subarrays_admitted) to find its best subarray (i.e. the maximum profit). You can use an iterator instead of the third array because the Kaden's algorithm takes only 1 pass.\n\nThis is much easier to comprehend and implement than what the official tips suggest."
                    },
                    {
                        "username": "itsyaswanth",
                        "content": "Given 2 arrays nums1,nums2. We are asked to perform an operation to replace a part of nums1 with nums2 and return the max sum subarray that can be formed.\\n![image](https://assets.leetcode.com/users/images/426b9a1b-194b-4e22-849a-6ad83db98d79_1656309494.0796635.jpeg)\\n![image](https://assets.leetcode.com/users/images/823811fa-abc6-4353-8092-83a91ee8535a_1656309502.3118556.jpeg)\\n\\n"
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "O(N^2) will give TLE so dont waste time like me :( \\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int sum1 = nums1[0] , sum2 = nums2[0] ;\\n        vector<int> pre1;\\n        vector<int> pre2;\\n        pre1.push_back(sum1);\\n        pre2.push_back(sum2);\\n        for(int i=1; i<nums1.size(); i++){\\n            sum1+=nums1[i];\\n            sum2+=nums2[i];\\n            pre1.push_back(sum1);\\n            pre2.push_back(sum2);\\n        }\\n        // sum l to r is pre1[r] - pre1[l-1]\\n        int ans = max(sum1,sum2);\\n        // sum1 + (nums2[l,r] - nums1[l,r])\\n        // sum1 + (pre2[r]-pre2[l-1]-(pre1[r]-pre1[l-1]))\\n        for(int i=0; i<nums1.size(); i++){\\n            ans = max({ans,sum1-pre1[i]+pre2[i],sum2+pre1[i]-pre2[i]});\\n        }\\n        for(int l=1; l<nums1.size(); l++){\\n            for(int r=l; r<nums1.size(); r++){\\n                ans = max({ans,(sum1+(pre2[r]-pre2[l-1])-(pre1[r]-pre1[l-1])),(sum2+(pre1[r]-pre1[l-1])-(pre2[r]-pre2[l-1]))});\\n            }\\n        }\\n        return ans ;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "AV2606",
                        "content": "isnt the score of nums1=[20,40,20,70,30] and nums2=[50,20,50,40,20] 240 instead of 220?\\nwe can choose left=0 and right=2 and get [50,40,50,70,30]=>50+40+50+70+30=240"
                    },
                    {
                        "username": "AmaanRizvi",
                        "content": "As the question says maximum \"subarray\" that means you have to swap all the elements from left to right i.e(you need to completely swap [20,40,20] with [50,20,50] which will give you nums1=[50,20,50,70,30] which is again 220 \\n"
                    }
                ]
            },
            {
                "id": 1958631,
                "content": [
                    {
                        "username": "Finesse",
                        "content": "Make a third array that shows the profit of swapping each index of the arrays (`profits[i] = nums2[i] - nums1[i]`). Use [the Kadane's algorithm](https://en.wikipedia.org/wiki/Maximum_subarray_problem#Empty_subarrays_admitted) to find its best subarray (i.e. the maximum profit). You can use an iterator instead of the third array because the Kaden's algorithm takes only 1 pass.\n\nThis is much easier to comprehend and implement than what the official tips suggest."
                    },
                    {
                        "username": "itsyaswanth",
                        "content": "Given 2 arrays nums1,nums2. We are asked to perform an operation to replace a part of nums1 with nums2 and return the max sum subarray that can be formed.\\n![image](https://assets.leetcode.com/users/images/426b9a1b-194b-4e22-849a-6ad83db98d79_1656309494.0796635.jpeg)\\n![image](https://assets.leetcode.com/users/images/823811fa-abc6-4353-8092-83a91ee8535a_1656309502.3118556.jpeg)\\n\\n"
                    },
                    {
                        "username": "Ayush_Agarwal_2003",
                        "content": "O(N^2) will give TLE so dont waste time like me :( \\nclass Solution {\\npublic:\\n    int maximumsSplicedArray(vector<int>& nums1, vector<int>& nums2) {\\n        int sum1 = nums1[0] , sum2 = nums2[0] ;\\n        vector<int> pre1;\\n        vector<int> pre2;\\n        pre1.push_back(sum1);\\n        pre2.push_back(sum2);\\n        for(int i=1; i<nums1.size(); i++){\\n            sum1+=nums1[i];\\n            sum2+=nums2[i];\\n            pre1.push_back(sum1);\\n            pre2.push_back(sum2);\\n        }\\n        // sum l to r is pre1[r] - pre1[l-1]\\n        int ans = max(sum1,sum2);\\n        // sum1 + (nums2[l,r] - nums1[l,r])\\n        // sum1 + (pre2[r]-pre2[l-1]-(pre1[r]-pre1[l-1]))\\n        for(int i=0; i<nums1.size(); i++){\\n            ans = max({ans,sum1-pre1[i]+pre2[i],sum2+pre1[i]-pre2[i]});\\n        }\\n        for(int l=1; l<nums1.size(); l++){\\n            for(int r=l; r<nums1.size(); r++){\\n                ans = max({ans,(sum1+(pre2[r]-pre2[l-1])-(pre1[r]-pre1[l-1])),(sum2+(pre1[r]-pre1[l-1])-(pre2[r]-pre2[l-1]))});\\n            }\\n        }\\n        return ans ;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "AV2606",
                        "content": "isnt the score of nums1=[20,40,20,70,30] and nums2=[50,20,50,40,20] 240 instead of 220?\\nwe can choose left=0 and right=2 and get [50,40,50,70,30]=>50+40+50+70+30=240"
                    },
                    {
                        "username": "AmaanRizvi",
                        "content": "As the question says maximum \"subarray\" that means you have to swap all the elements from left to right i.e(you need to completely swap [20,40,20] with [50,20,50] which will give you nums1=[50,20,50,70,30] which is again 220 \\n"
                    }
                ]
            }
        ]
    }
]