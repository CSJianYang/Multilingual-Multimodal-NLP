[
    {
        "title": "Maximum Enemy Forts That Can Be Captured",
        "question_content": "You are given a 0-indexed integer array forts of length n representing the positions of several forts. forts[i] can be -1, 0, or 1 where:\n\n\t-1 represents there is no fort at the ith position.\n\t0 indicates there is an enemy fort at the ith position.\n\t1 indicates the fort at the ith the position is under your command.\n\nNow you have decided to move your army from one of your forts at position i to an empty position j such that:\n\n\t0 <= i, j <= n - 1\n\tThe army travels over enemy forts only. Formally, for all k where min(i,j) < k < max(i,j), forts[k] == 0.\n\nWhile moving the army, all the enemy forts that come in the way are captured.\nReturn the maximum number of enemy forts that can be captured. In case it is impossible to move your army, or you do not have any fort under your command, return 0.\n&nbsp;\nExample 1:\n\nInput: forts = [1,0,0,-1,0,0,0,0,1]\nOutput: 4\nExplanation:\n- Moving the army from position 0 to position 3 captures 2 enemy forts, at 1 and 2.\n- Moving the army from position 8 to position 3 captures 4 enemy forts.\nSince 4 is the maximum number of enemy forts that can be captured, we return 4.\n\nExample 2:\n\nInput: forts = [0,0,1,-1]\nOutput: 0\nExplanation: Since no enemy fort can be captured, 0 is returned.\n\n&nbsp;\nConstraints:\n\n\t1 <= forts.length <= 1000\n\t-1 <= forts[i] <= 1",
        "solutions": [
            {
                "id": 2947175,
                "title": "one-pass",
                "content": "Basically, we need to count zeros between the opposite non-zero elements (`1` and `-1`, or `-1` or `1`).\\n**C++**\\n```cpp\\nint captureForts(vector<int>& forts) {\\n    int res = 0;\\n    for (int i = 0, j = 0; i < forts.size(); ++i)\\n        if (forts[i] != 0) {\\n            if (forts[j] == -forts[i])\\n                res = max(res, i - j - 1);\\n            j = i;\\n        }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint captureForts(vector<int>& forts) {\\n    int res = 0;\\n    for (int i = 0, j = 0; i < forts.size(); ++i)\\n        if (forts[i] != 0) {\\n            if (forts[j] == -forts[i])\\n                res = max(res, i - j - 1);\\n            j = i;\\n        }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2946519,
                "title": "c-java-python3-scan-one-pass",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/3ffc910c12ff8c84890fb15351216a0fa85dc3ac) for solutions of biweekly 94. \\n\\n**Intuition**\\nEffectively, this problem can be translated into \"finding the number of 0\\'s between a 1 and a -1\". \\n**Implementation**\\n**C++**\\n```\\nclass Solution {\\npublic: \\n    int captureForts(vector<int>& forts) {\\n        int ans = 0; \\n        for (int i = 0, ii = 0; i < forts.size(); ++i) \\n            if (forts[i]) {\\n                if (forts[ii] == -forts[i]) ans = max(ans, i-ii-1); \\n                ii = i; \\n            }\\n        return ans; \\n    }\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n\\tpublic int captureForts(int[] forts) {\\n\\t\\tint ans = 0; \\n\\t\\tfor (int i = 0, ii = 0; i < forts.length; ++i) \\n\\t\\t\\tif (forts[i] != 0) {\\n\\t\\t\\t\\tif (forts[ii] == -forts[i]) ans = Math.max(ans, i-ii-1); \\n\\t\\t\\t\\tii = i; \\n\\t\\t\\t}\\n\\t\\treturn ans; \\n\\t}\\n}\\n```\\n**Python3**\\n```\\nclass Solution: \\n    def captureForts(self, forts: List[int]) -> int:\\n        ans = ii = 0 \\n        for i, x in enumerate(forts): \\n            if x: \\n                if forts[ii] == -x: ans = max(ans, i-ii-1)\\n                ii = i \\n        return ans \\n```\\n**Complexity**\\nTime `O(N)`\\nSpace `O(1)`",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    int captureForts(vector<int>& forts) {\\n        int ans = 0; \\n        for (int i = 0, ii = 0; i < forts.size(); ++i) \\n            if (forts[i]) {\\n                if (forts[ii] == -forts[i]) ans = max(ans, i-ii-1); \\n                ii = i; \\n            }\\n        return ans; \\n    }\\n};\\n```\n```\\nclass Solution {\\n\\tpublic int captureForts(int[] forts) {\\n\\t\\tint ans = 0; \\n\\t\\tfor (int i = 0, ii = 0; i < forts.length; ++i) \\n\\t\\t\\tif (forts[i] != 0) {\\n\\t\\t\\t\\tif (forts[ii] == -forts[i]) ans = Math.max(ans, i-ii-1); \\n\\t\\t\\t\\tii = i; \\n\\t\\t\\t}\\n\\t\\treturn ans; \\n\\t}\\n}\\n```\n```\\nclass Solution: \\n    def captureForts(self, forts: List[int]) -> int:\\n        ans = ii = 0 \\n        for i, x in enumerate(forts): \\n            if x: \\n                if forts[ii] == -x: ans = max(ans, i-ii-1)\\n                ii = i \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946493,
                "title": "python-attack-from-one-or-two-sides",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\n\\n**Python #1.** We should try attacking from both sides, starting at 1 and finishing at -1, with all intermediate entries being 0.\\n```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        \\n       \\n        def attack(forts):\\n            m, c = 0, -1\\n        \\n            for f in forts:\\n                if   f == 1 : c = 0                # start attack\\n                elif f == 0 : c += c >= 0          # count forts\\n                else        : c, m = -1, max(c,m)  # stop attack\\n\\n            return m\\n        \\n        return max(attack(forts), attack(forts[::-1]))\\n```\\n\\n**Python #2.** One-pass using memoization of indices for non-zero values.\\n```\\nclass Solution: \\n    def captureForts(self, forts: List[int]) -> int:\\n        m = j = 0 \\n        for i, f in enumerate(forts): \\n            if f != 0:\\n                if forts[j] == -f: \\n                    m = max(m, i-j-1)\\n                j = i \\n        return m \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        \\n       \\n        def attack(forts):\\n            m, c = 0, -1\\n        \\n            for f in forts:\\n                if   f == 1 : c = 0                # start attack\\n                elif f == 0 : c += c >= 0          # count forts\\n                else        : c, m = -1, max(c,m)  # stop attack\\n\\n            return m\\n        \\n        return max(attack(forts), attack(forts[::-1]))\\n```\n```\\nclass Solution: \\n    def captureForts(self, forts: List[int]) -> int:\\n        m = j = 0 \\n        for i, f in enumerate(forts): \\n            if f != 0:\\n                if forts[j] == -f: \\n                    m = max(m, i-j-1)\\n                j = i \\n        return m \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946793,
                "title": "simple-c-optimal-solution-o-n-0ms-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\nPLS LIKE THE SOLUTION\\nTry to give a comment\\n```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int result = 0, x = 0; \\n        for (int j = 0; j < forts.size(); j++) {\\n            if (forts[j]) {\\n                if (forts[x] == -forts[j]) result = max(result, j - x - 1); \\n                x = j; \\n            }\\n        }\\n        return result; \\n    }\\n};\\nPLS LIKE THE SOLUTION\\nTry to give a comment\\n// 0,0,1,-1\\n// 1,0,0,-1,0,0,0,0,1\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int result = 0, x = 0; \\n        for (int j = 0; j < forts.size(); j++) {\\n            if (forts[j]) {\\n                if (forts[x] == -forts[j]) result = max(result, j - x - 1); \\n                x = j; \\n            }\\n        }\\n        return result; \\n    }\\n};\\nPLS LIKE THE SOLUTION\\nTry to give a comment\\n// 0,0,1,-1\\n// 1,0,0,-1,0,0,0,0,1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947771,
                "title": "c-with-o-n-solution-very-simple-and-easy-to-understand-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int ans = 0;\\n        int i = -1, j = 0, f = 0;\\n        while(j < forts.size()){\\n            if(forts[j] == 1) {\\n                if(f == -1){\\n                    ans = max(ans, j-i-1);\\n                }\\n                f = 1; i = j;\\n            }else if(forts[j] == -1){\\n                if(f == 1){\\n                    ans = max(ans, j-i-1);\\n                }\\n                f = -1; i = j;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int ans = 0;\\n        int i = -1, j = 0, f = 0;\\n        while(j < forts.size()){\\n            if(forts[j] == 1) {\\n                if(f == -1){\\n                    ans = max(ans, j-i-1);\\n                }\\n                f = 1; i = j;\\n            }else if(forts[j] == -1){\\n                if(f == 1){\\n                    ans = max(ans, j-i-1);\\n                }\\n                f = -1; i = j;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946489,
                "title": "easy-cpp-solution",
                "content": "```\\npublic:\\n    int count = 0, ans = 0;\\n    int captureForts(vector<int>& forts) {\\n        helper(forts);\\n        reverse(forts.begin(), forts.end());\\n        helper(forts);\\n        return ans;\\n        \\n    }\\n    void helper(vector<int> &forts) {\\n        bool found1 = false;\\n        for(auto fort: forts) {\\n            if(fort == 1) {\\n                count = 0;\\n                found1 = true;\\n            } else if(fort == 0 && found1) {\\n                count++;\\n            } else if(fort == -1 && found1) {\\n                ans = max(ans, count);\\n                found1 = false;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\npublic:\\n    int count = 0, ans = 0;\\n    int captureForts(vector<int>& forts) {\\n        helper(forts);\\n        reverse(forts.begin(), forts.end());\\n        helper(forts);\\n        return ans;\\n        \\n    }\\n    void helper(vector<int> &forts) {\\n        bool found1 = false;\\n        for(auto fort: forts) {\\n            if(fort == 1) {\\n                count = 0;\\n                found1 = true;\\n            } else if(fort == 0 && found1) {\\n                count++;\\n            } else if(fort == -1 && found1) {\\n                ans = max(ans, count);\\n                found1 = false;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2946736,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int n = forts.size(), ans = 0;\\n        for(int i=0; i<n; i++) {\\n            if(forts[i] == 1) {\\n                int cnt = 0;\\n                int j = i-1;\\n                while(j >= 0) {\\n                    if(forts[j] == 0) cnt++;\\n                    else if(forts[j] == -1) {\\n                        ans = max(ans, cnt);\\n                        break;\\n                    }\\n                    else if(forts[j] == 1) break;\\n                    j--;\\n                }\\n                cnt = 0;\\n                j = i+1;\\n                while(j < n) {\\n                    if(forts[j] == 0) cnt++;\\n                    else if(forts[j] == -1) {\\n                        ans = max(ans, cnt);\\n                        break;\\n                    }\\n                    else if(forts[j] == 1) break;\\n                    j++;\\n                }\\n            }\\n        }\\n        return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int n = forts.size(), ans = 0;\\n        for(int i=0; i<n; i++) {\\n            if(forts[i] == 1) {\\n                int cnt = 0;\\n                int j = i-1;\\n                while(j >= 0) {\\n                    if(forts[j] == 0) cnt++;\\n                    else if(forts[j] == -1) {\\n                        ans = max(ans, cnt);\\n                        break;\\n                    }\\n                    else if(forts[j] == 1) break;\\n                    j--;\\n                }\\n                cnt = 0;\\n                j = i+1;\\n                while(j < n) {\\n                    if(forts[j] == 0) cnt++;\\n                    else if(forts[j] == -1) {\\n                        ans = max(ans, cnt);\\n                        break;\\n                    }\\n                    else if(forts[j] == 1) break;\\n                    j++;\\n                }\\n            }\\n        }\\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946674,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution(object):\\n    def captureForts(self, forts):\\n        def solve(arr):\\n            max_ = 0\\n            count, flag = 0, False\\n            for num in arr:\\n                if num == 1: \\n                    count, flag = 0, True\\n                elif num == -1: \\n                    max_, count, flag = max(max_, count), 0, False\\n                else: \\n                    if flag: count += 1\\n            return max_\\n        return max(solve(forts), solve(forts[::-1]))\\n```\\n**UpVote**, if you like it **:)**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def captureForts(self, forts):\\n        def solve(arr):\\n            max_ = 0\\n            count, flag = 0, False\\n            for num in arr:\\n                if num == 1: \\n                    count, flag = 0, True\\n                elif num == -1: \\n                    max_, count, flag = max(max_, count), 0, False\\n                else: \\n                    if flag: count += 1\\n            return max_\\n        return max(solve(forts), solve(forts[::-1]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946537,
                "title": "o-n-time",
                "content": "+ Our answer lies b/w every consecutive `[1, -1]` && `[-1,1]` pairs.\\n# C++\\n    int captureForts(vector<int>& forts) {\\n        int n = size(forts) , res = 0;\\n        \\n        //Precompute count of zeroes before every index\\n        vector<int> count(n);\\n        for(int i = 1; i < n; ++i)\\n            if(forts[i - 1] == 0) count[i] = count[i - 1] + 1 ;\\n            else count[i] = count[i - 1];\\n        \\n        function<void(int, int)> captured = [&](int l, int r){\\n            for(int i = 0, last = -1;i < n; ++i){\\n                // found `l` => set `last` pointer\\n                if(forts[i] == l) last = i;\\n            \\n                // Condition 1 : [found `r`]\\n                // Condition 2 : [`last` pointer is pointing to valid index] && \\n                // Condition 3 : [Mandatory count of zeroes b/w [last, i]] == [Real count of zeroes b/w them using prefix array]\\n                // If above case fullfills ,then we have a valid [l, r] pair => update result...\\n                \\n                if(forts[i] == r && last >= 0 && count[i] - count[last] == i - last - 1)\\n                    res = max(res, i - last - 1);\\n           }\\n        };\\n        \\n        //get maximum among all  pairs of [1,-1] & [-1, 1]\\n        captured(1, -1);\\n        captured(-1, 1);\\n        \\n        return res;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "+ Our answer lies b/w every consecutive `[1, -1]` && `[-1,1]` pairs.\\n# C++\\n    int captureForts(vector<int>& forts) {\\n        int n = size(forts) , res = 0;\\n        \\n        //Precompute count of zeroes before every index\\n        vector<int> count(n);\\n        for(int i = 1; i < n; ++i)\\n            if(forts[i - 1] == 0) count[i] = count[i - 1] + 1 ;\\n            else count[i] = count[i - 1];\\n        \\n        function<void(int, int)> captured = [&](int l, int r){\\n            for(int i = 0, last = -1;i < n; ++i){\\n                // found `l` => set `last` pointer\\n                if(forts[i] == l) last = i;\\n            \\n                // Condition 1 : [found `r`]\\n                // Condition 2 : [`last` pointer is pointing to valid index] && \\n                // Condition 3 : [Mandatory count of zeroes b/w [last, i]] == [Real count of zeroes b/w them using prefix array]\\n                // If above case fullfills ,then we have a valid [l, r] pair => update result...\\n                \\n                if(forts[i] == r && last >= 0 && count[i] - count[last] == i - last - 1)\\n                    res = max(res, i - last - 1);\\n           }\\n        };\\n        \\n        //get maximum among all  pairs of [1,-1] & [-1, 1]\\n        captured(1, -1);\\n        captured(-1, 1);\\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2946475,
                "title": "easy-java-solution",
                "content": "\\n```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int max = 0,n = forts.length;\\n        for (int i = 0; i < n; i++) {\\n            if(forts[i]==1) {\\n                for (int j = i+1; j <n; j++) {\\n                    if(forts[j]==-1){\\n                        max=Math.max(max,j-i-1);\\n                        break;\\n                    }else if(forts[j]==1){\\n                        break;\\n                    }\\n                }\\n            }else if(forts[i]==-1){\\n                for (int j = i+1; j <n; j++) {\\n                    if(forts[j]==1){\\n                        max=Math.max(max,j-i-1);\\n                        break;\\n                    }else if(forts[j]==-1){\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int max = 0,n = forts.length;\\n        for (int i = 0; i < n; i++) {\\n            if(forts[i]==1) {\\n                for (int j = i+1; j <n; j++) {\\n                    if(forts[j]==-1){\\n                        max=Math.max(max,j-i-1);\\n                        break;\\n                    }else if(forts[j]==1){\\n                        break;\\n                    }\\n                }\\n            }else if(forts[i]==-1){\\n                for (int j = i+1; j <n; j++) {\\n                    if(forts[j]==1){\\n                        max=Math.max(max,j-i-1);\\n                        break;\\n                    }else if(forts[j]==-1){\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2950438,
                "title": "c-left-right-search-comments-added-easy-for-beginner",
                "content": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) \\n    {\\n        int cnt=0;\\n        int mx=0;\\n        \\n        // check for every index\\n        for(int i=0;i<forts.size();i++)\\n        {\\n            // if it is mine fort\\n            if(forts[i]==1)\\n            {\\n                // now I\\'ll try to move my army(1) to left and right \\\\\\n                //and try to move it from enemines fort(0) to an empty fort(-1)\\n                // move to left\\n                for(int j=i-1;j>=0;j--)\\n                {\\n                    if(forts[j]==0)\\n                    {\\n                        cnt++;\\n                    }\\n                    else if(forts[j]==-1)\\n                    {\\n                        mx = max(mx,cnt);\\n                        cnt=0;\\n                        break;\\n                    }\\n\\t\\t\\t\\t\\t// 1 to 1 is not possible so just break\\n                    else\\n                    {\\n                        break;\\n                    }\\n                }\\n                \\n                \\n                // move to right\\n                cnt=0;\\n                for(int j=i+1;j<forts.size();j++)\\n                {\\n                    if(forts[j]==0)\\n                    {\\n                        cnt++;\\n                    }\\n                    else if(forts[j]==-1)\\n                    {\\n                        mx = max(mx,cnt);\\n                        cnt=0;\\n                        break;\\n                    }\\n\\t\\t\\t\\t\\t// 1 to 1 is not possible so just break\\n                    else\\n                    {\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n\\n\\n// path will be 1 to -1\\n// it can lie between mid to left or mid to right\\n// left <- mid -> right\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) \\n    {\\n        int cnt=0;\\n        int mx=0;\\n        \\n        // check for every index\\n        for(int i=0;i<forts.size();i++)\\n        {\\n            // if it is mine fort\\n            if(forts[i]==1)\\n            {\\n                // now I\\'ll try to move my army(1) to left and right \\\\\\n                //and try to move it from enemines fort(0) to an empty fort(-1)\\n                // move to left\\n                for(int j=i-1;j>=0;j--)\\n                {\\n                    if(forts[j]==0)\\n                    {\\n                        cnt++;\\n                    }\\n                    else if(forts[j]==-1)\\n                    {\\n                        mx = max(mx,cnt);\\n                        cnt=0;\\n                        break;\\n                    }\\n\\t\\t\\t\\t\\t// 1 to 1 is not possible so just break\\n                    else\\n                    {\\n                        break;\\n                    }\\n                }\\n                \\n                \\n                // move to right\\n                cnt=0;\\n                for(int j=i+1;j<forts.size();j++)\\n                {\\n                    if(forts[j]==0)\\n                    {\\n                        cnt++;\\n                    }\\n                    else if(forts[j]==-1)\\n                    {\\n                        mx = max(mx,cnt);\\n                        cnt=0;\\n                        break;\\n                    }\\n\\t\\t\\t\\t\\t// 1 to 1 is not possible so just break\\n                    else\\n                    {\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n\\n\\n// path will be 1 to -1\\n// it can lie between mid to left or mid to right\\n// left <- mid -> right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946860,
                "title": "c-count-back-and-forward",
                "content": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int ans=0;\\n        for(int i=0;i<forts.size();i++){\\n            if(forts[i]==1){\\n                int back=0,next=0;\\n                int j=i-1;\\n                while(j>=0 && forts[j]==0){\\n                    j--;\\n                    back+=1;\\n                }\\n                if((j>=0 && forts[j]!=-1) || j<0) back = 0;\\n                j=i+1;\\n                while(j<forts.size() && forts[j]==0){\\n                    j++;\\n                    next+=1;\\n                }\\n                if((j<forts.size() && forts[j]!=-1) || j>=forts.size()) next = 0;\\n                ans = max(ans,max(back,next));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int ans=0;\\n        for(int i=0;i<forts.size();i++){\\n            if(forts[i]==1){\\n                int back=0,next=0;\\n                int j=i-1;\\n                while(j>=0 && forts[j]==0){\\n                    j--;\\n                    back+=1;\\n                }\\n                if((j>=0 && forts[j]!=-1) || j<0) back = 0;\\n                j=i+1;\\n                while(j<forts.size() && forts[j]==0){\\n                    j++;\\n                    next+=1;\\n                }\\n                if((j<forts.size() && forts[j]!=-1) || j>=forts.size()) next = 0;\\n                ans = max(ans,max(back,next));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3003390,
                "title": "js-simple-solution-with-two-pointers",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDeclare `max` and `prev` variable.\\n\\nLoop over the array, if current turget isn\\'t `0` and both points aren\\'t the same then check the max distance between.\\n\\nMake the current pointer the prev pointer.\\n\\n```\\nvar captureForts = function(forts) {\\n    let max = 0, prev = 0;\\n    forts.forEach((fort, idx) => {\\n        if (fort) {\\n            if (forts[prev] &&  fort != forts[prev]) {\\n                max = Math.max(max, (idx - prev - 1))\\n            }\\n            prev = idx;\\n        }\\n    })\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nvar captureForts = function(forts) {\\n    let max = 0, prev = 0;\\n    forts.forEach((fort, idx) => {\\n        if (fort) {\\n            if (forts[prev] &&  fort != forts[prev]) {\\n                max = Math.max(max, (idx - prev - 1))\\n            }\\n            prev = idx;\\n        }\\n    })\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2947389,
                "title": "python-3-2-6-lines-w-explanation-and-example-t-m-29-ms-13-8-mb",
                "content": "Here\\'s the plan:\\n- First, we build a list of tuples with `itertools.groupby`. First element of each pair is the integer of the group(-1,0,or 1), and the second element is the length of the string.\\n1. Second, we iterate through this list checking for whether `{grp[i-1][0], grp[i+1][0]} == {-1,1}`. If so, then `grp[i][0]==0`, and `grp[i][1]` must be a potential answer.\\n- Third we check whether the `grp[i-1][0]` and `grp[i+1][0]` are 1 and -1 by whether their product is -1.\\n- Fourth, we return the maximum.\\n```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n\\n        grp = [(k,len(list(g))) for k,g in groupby(forts)]\\n\\n           ans = 0                          #  Example: forts = [  1,    0,0,    -1,  0,0,0,0,  1]\\n                                            #                      |      |       |      |      |\\n        for i in range(1,len(grp)-1):       #             grp = [(1,1), (0,*2*),(-1,1),(0,*4*), (1,1)]        \\n            if grp[i-1][0]*grp[i+1][0]==-1: #                     |______________||_____________|| \\n                ans = max(ans,grp[i][1])                                                                            #                       ans  = max(2, 4)\\n\\n        return ans                          #                       return 4\\n```\\n[https://leetcode.com/problems/maximum-enemy-forts-that-can-be-captured/submissions/864957033/](http://)\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).\\n\\nBelow is the two-liner. I couldn\\'t quite pull of a one-liner, maybe someone else? I promise an upvote :).\\n\\n```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n\\n        grp = [(k,len(list(g))) for k,g in groupby(forts)]\\n        return  max([grp[i][1] for i in range(1,len(grp)-1) \\n               if grp[i-1][0]*grp[i+1][0]==-1], default = 0)\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n\\n        grp = [(k,len(list(g))) for k,g in groupby(forts)]\\n\\n           ans = 0                          #  Example: forts = [  1,    0,0,    -1,  0,0,0,0,  1]\\n                                            #                      |      |       |      |      |\\n        for i in range(1,len(grp)-1):       #             grp = [(1,1), (0,*2*),(-1,1),(0,*4*), (1,1)]        \\n            if grp[i-1][0]*grp[i+1][0]==-1: #                     |______________||_____________|| \\n                ans = max(ans,grp[i][1])                                                                            #                       ans  = max(2, 4)\\n\\n        return ans                          #                       return 4\\n```\n```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n\\n        grp = [(k,len(list(g))) for k,g in groupby(forts)]\\n        return  max([grp[i][1] for i in range(1,len(grp)-1) \\n               if grp[i-1][0]*grp[i+1][0]==-1], default = 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946512,
                "title": "javascript-using-regular-expression-with-explaination",
                "content": "```\\n// [1, 0, 0, -1, 0, 0, 0, 1]\\nvar captureForts = function (forts) {\\n  // add 1 to each forts[i] to make regexp match easy\\n  // [2, 1, 1, 0, 1, 1, 1, 2]\\n  forts = forts.map((e) => e - -1).join(\"\");\\n\\n  // Matches 2 1...1 0\\n  const front = forts.match(/2(1+)0/g) || [];\\n\\n  // Matches 0 1...1 2 (same as front but in reverse direction)\\n  const back = forts.match(/0(1+)2/g) || [];\\n\\n  // remove 0 and 2 so only number of 1 (empty place) remains\\n  // [4,5] => [ 2, 3 ]\\n  const res = [...front, ...back].map((e) => e.length - 2);\\n\\n  // return max of \\'res\\'\\n  return res.length ? Math.max(...res) : 0;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// [1, 0, 0, -1, 0, 0, 0, 1]\\nvar captureForts = function (forts) {\\n  // add 1 to each forts[i] to make regexp match easy\\n  // [2, 1, 1, 0, 1, 1, 1, 2]\\n  forts = forts.map((e) => e - -1).join(\"\");\\n\\n  // Matches 2 1...1 0\\n  const front = forts.match(/2(1+)0/g) || [];\\n\\n  // Matches 0 1...1 2 (same as front but in reverse direction)\\n  const back = forts.match(/0(1+)2/g) || [];\\n\\n  // remove 0 and 2 so only number of 1 (empty place) remains\\n  // [4,5] => [ 2, 3 ]\\n  const res = [...front, ...back].map((e) => e.length - 2);\\n\\n  // return max of \\'res\\'\\n  return res.length ? Math.max(...res) : 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3227337,
                "title": "detailed-java-code-with-explanation",
                "content": "The logic here is to find the largest string of zeros between -1 and 1(or 1 and -1). \\n\\nSo, at **a non-zero fort**, we do the following:\\nIf the cumulative sum was non-zero(i.e we already found a non-zero fort before), update the cumulative sum with current value and check if it is zero or not. \\nIf it\\'s zero, it means we have found a string of zeros between -1 and 1.\\nSo now compare our result with current count of zeros, update the result with max count.\\n\\nIrrespective of the fact that cumulative sum is zero or not, we need to reset the cumulative sum and count with 0, to starting counting enemy forts in the next iteration.\\n\\nAt a **zero fort**(i.e enemy fort), do the following:\\nCheck if non-zero fort was already found, if yes, then increase the current count of zero forts.\\n\\nThe following code with comments will make the above logic clear:\\n\\n```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        \\n        int sum = 0;// for  calculating cumulative sum\\n        int ret = 0; // for returning the max string of zeros between -1 and 1\\n        int count = 0; // for counting and comparing string of zeros\\n        \\n\\n        for(int i = 0 ; i < forts.length ; i++){\\n            \\n            if(forts[i] != 0) // counting starts and ends at non-zero fort\\n            {\\n  \\n                sum += forts[i]; // s counts the cumulative sum from the last non-zero fort\\n                if(sum == 0) \\n                    ret = Math.max(ret, count);// if s = 0, it means we are either at start or end, hence compare\\n                \\n                sum = forts[i];//cumulative sum resets to current value\\n                count = 0;//count resets at non-zero fort value\\n                \\n            }\\n            \\n            else\\n            {\\n                if(sum != 0)\\n                count++; //count if we already encountered a non-zero fort         \\n                \\n            }\\n        }   \\n        return ret;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        \\n        int sum = 0;// for  calculating cumulative sum\\n        int ret = 0; // for returning the max string of zeros between -1 and 1\\n        int count = 0; // for counting and comparing string of zeros\\n        \\n\\n        for(int i = 0 ; i < forts.length ; i++){\\n            \\n            if(forts[i] != 0) // counting starts and ends at non-zero fort\\n            {\\n  \\n                sum += forts[i]; // s counts the cumulative sum from the last non-zero fort\\n                if(sum == 0) \\n                    ret = Math.max(ret, count);// if s = 0, it means we are either at start or end, hence compare\\n                \\n                sum = forts[i];//cumulative sum resets to current value\\n                count = 0;//count resets at non-zero fort value\\n                \\n            }\\n            \\n            else\\n            {\\n                if(sum != 0)\\n                count++; //count if we already encountered a non-zero fort         \\n                \\n            }\\n        }   \\n        return ret;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3189103,
                "title": "python-easy-solution-beats-91",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        i = 0 \\n        j = i +1\\n        c = 0\\n        l = [0]\\n        while i < len(forts) and j < len(forts):\\n            if forts[i] == 1:\\n                while forts[j] == 0 and j < len(forts)-1:\\n                    c += 1\\n                    j += 1\\n                if forts[j] == 1:\\n                    c = 0\\n                if forts[j] != -1 :\\n                    c = 0\\n                l.append(c)\\n                c = 0\\n                i = j \\n                j = i + 1\\n            elif forts[i] == -1: \\n                while forts[j] == 0 and j < len(forts)-1:\\n                    c += 1\\n                    j += 1\\n                if forts[j] == -1:\\n                    c = 0\\n                if forts[j] != 1:\\n                    c = 0\\n                l.append(c)\\n                c = 0\\n                i = j\\n                j = i + 1\\n            else:\\n                i += 1\\n                j = i+1\\n        print(l)\\n        return max(l)\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        i = 0 \\n        j = i +1\\n        c = 0\\n        l = [0]\\n        while i < len(forts) and j < len(forts):\\n            if forts[i] == 1:\\n                while forts[j] == 0 and j < len(forts)-1:\\n                    c += 1\\n                    j += 1\\n                if forts[j] == 1:\\n                    c = 0\\n                if forts[j] != -1 :\\n                    c = 0\\n                l.append(c)\\n                c = 0\\n                i = j \\n                j = i + 1\\n            elif forts[i] == -1: \\n                while forts[j] == 0 and j < len(forts)-1:\\n                    c += 1\\n                    j += 1\\n                if forts[j] == -1:\\n                    c = 0\\n                if forts[j] != 1:\\n                    c = 0\\n                l.append(c)\\n                c = 0\\n                i = j\\n                j = i + 1\\n            else:\\n                i += 1\\n                j = i+1\\n        print(l)\\n        return max(l)\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3023962,
                "title": "java-easy-solution-100-faster-0-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n    int ans = 0;\\n    for (int i = 0, j = 0; i < forts.length; ++i)\\n        if (forts[i] != 0) {\\n            if (forts[j] !=0 && forts[i] != forts[j])\\n                ans = Math.max(ans, i - j - 1);\\n            j = i;\\n        }\\n    return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n    int ans = 0;\\n    for (int i = 0, j = 0; i < forts.length; ++i)\\n        if (forts[i] != 0) {\\n            if (forts[j] !=0 && forts[i] != forts[j])\\n                ans = Math.max(ans, i - j - 1);\\n            j = i;\\n        }\\n    return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2964353,
                "title": "100-0ms-3-lines-easy-explained-proof",
                "content": "# upvote pls\\n\\n# calculate max distance btw 1 to -1 & viceversa  \\n<!-- Describe your approach to solving the problem. -->\\n![image.png](https://assets.leetcode.com/users/images/dd6f5126-b23c-4eba-8b6e-b6af71b82d8e_1672252185.2736433.png)\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n    public int captureForts(int[] f) {\\n        int r=0,j=0;\\n        for(int i=0;i<f.length;i++){\\n            if(f[i]!=0){\\n                if(f[j]==-f[i]) r=Math.max(r,i-j-1);\\n                j=i;\\n            }\\n        }return r;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    public int captureForts(int[] f) {\\n        int r=0,j=0;\\n        for(int i=0;i<f.length;i++){\\n            if(f[i]!=0){\\n                if(f[j]==-f[i]) r=Math.max(r,i-j-1);\\n                j=i;\\n            }\\n        }return r;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2958413,
                "title": "o-n-easy-and-simple-c-100-fast",
                "content": "# Intuition\\nJust used brute force approach and done some checks and found answer in single traversal.\\n\\n# Approach\\nBrute force\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int n = forts.size();\\n        int index = -1;\\n        int val = 0;\\n\\n        for(int i = 0 ; i < n ; i++){\\n            if(forts[i] == 1 or forts[i] == -1){\\n                index = i;\\n                val = forts[i];\\n                break;\\n            }\\n        }\\n        if( index == -1) return 0; // if not found any empty fort or captured fort\\n\\n        int ans = 0;\\n        int cnt = 0;\\n        for( int i = index + 1 ; i < n ; i++ ){\\n            val += forts[i];\\n            cnt++;\\n            if(val == 0){\\n                ans = max(ans,cnt);\\n                cnt = 0;\\n                val = forts[i];\\n            }else if(val == -2 or val == 2){\\n                val = forts[i];\\n                cnt = 0;\\n            }\\n            \\n        }\\n        if(ans == 0) return 0; // [0,-1,0,-1,-1,0] if not written this condition then code will return -1 for this testcase\\n        return ans-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int n = forts.size();\\n        int index = -1;\\n        int val = 0;\\n\\n        for(int i = 0 ; i < n ; i++){\\n            if(forts[i] == 1 or forts[i] == -1){\\n                index = i;\\n                val = forts[i];\\n                break;\\n            }\\n        }\\n        if( index == -1) return 0; // if not found any empty fort or captured fort\\n\\n        int ans = 0;\\n        int cnt = 0;\\n        for( int i = index + 1 ; i < n ; i++ ){\\n            val += forts[i];\\n            cnt++;\\n            if(val == 0){\\n                ans = max(ans,cnt);\\n                cnt = 0;\\n                val = forts[i];\\n            }else if(val == -2 or val == 2){\\n                val = forts[i];\\n                cnt = 0;\\n            }\\n            \\n        }\\n        if(ans == 0) return 0; // [0,-1,0,-1,-1,0] if not written this condition then code will return -1 for this testcase\\n        return ans-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949190,
                "title": "easy-0ms-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. We have to count maximum trailing zeros such that they are bounded by -1 or 1 \\n2. If zeroes are bounded by 1 in starting , ending should be by -1 .\\n3.   -1 0 0 0 1 or 1 0 0 0 -1 \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.  Start counting whever zeroes are encountered and store the starting element -1 or 1 .\\n2. Update maximum answer when element other than 0 is encountered only if the starting and ending elements are different. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& nums) \\n    {\\n        int mx = 0 , cur_max = 0 , prev ; \\n        bool flag = false ; \\n        for(int i =1;i<nums.size();i++)\\n        {\\n            if(nums[i]==0 && nums[i-1]!=0)\\n            {\\n                flag = true ; \\n                prev = nums[i-1];\\n            }\\n            if(nums[i]!=0)\\n            {\\n                if(nums[i]!=prev && flag)\\n                mx = max(mx,cur_max);\\n                flag = false ;  \\n                cur_max = 0 ; \\n            }\\n            if(flag)cur_max++ ; \\n        }\\n        return mx ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& nums) \\n    {\\n        int mx = 0 , cur_max = 0 , prev ; \\n        bool flag = false ; \\n        for(int i =1;i<nums.size();i++)\\n        {\\n            if(nums[i]==0 && nums[i-1]!=0)\\n            {\\n                flag = true ; \\n                prev = nums[i-1];\\n            }\\n            if(nums[i]!=0)\\n            {\\n                if(nums[i]!=prev && flag)\\n                mx = max(mx,cur_max);\\n                flag = false ;  \\n                cur_max = 0 ; \\n            }\\n            if(flag)cur_max++ ; \\n        }\\n        return mx ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948933,
                "title": "super-easy-c-o-n-o-1-solution",
                "content": "# *Upvote if you understood the solution and ask doubts in comments.*\\n# Intuition\\nWe can move our army from 1 to -1. So, if we know the index of 1\\'s and -1\\'s , we can easily know the number of zeroes between them by simply taking the absolute difference of their indexes.\\n\\n# Approach\\nWe\\'ll take 2 variables that will store the last Fort\\'s value i.e, either 1 or -1 and its index.\\nIf we are currently on -1, then we need prev fort\\'s value to be 1 and if we are on 1, then we need prev fort\\'s value to be -1.So, the answer will be max of prev. ans or absolute diff. of prev fort\\'s index and curr index. \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        stack<pair<int,int>> st;\\n        int ans = 0 , n = forts.size();\\n        for(int i=0 ; i<n ; i++){\\n            if(forts[i] != 0){\\n                if(st.empty())\\n                    st.push({forts[i],i});\\n                else{\\n                    if((forts[i] == 1 && st.top().first == -1) || (forts[i] == -1 && st.top().first == 1))\\n                        ans = max(ans,i-st.top().second-1);\\n                    st.push({forts[i],i});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        stack<pair<int,int>> st;\\n        int ans = 0 , n = forts.size();\\n        for(int i=0 ; i<n ; i++){\\n            if(forts[i] != 0){\\n                if(st.empty())\\n                    st.push({forts[i],i});\\n                else{\\n                    if((forts[i] == 1 && st.top().first == -1) || (forts[i] == -1 && st.top().first == 1))\\n                        ans = max(ans,i-st.top().second-1);\\n                    st.push({forts[i],i});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946832,
                "title": "o-n-time-100-faster",
                "content": "##### UPVOTES ARE APPRECIATED!!!\\n\\n# Approach\\nYou should keep the record of -1 or 1 everytime you pass through it,\\nbecause you want to keep the max score possible between -1 and 1.\\n\\ne.g.  [1,0,0,1,0,-1,0,0,0,1]\\n\\nOne score is **1** from 3rd index to 5th, and second is **3** from 5th index to 9th which is the max one.\\n\\n# Code\\n```\\npublic int captureForts(int[] forts) {\\n        int n = forts.length;\\n\\n        int count = 0, maxCount = 0;\\n        int lastSeen = 0;\\n\\n        for(int i=0; i<n; i++){\\n            if(forts[i] == -1){\\n                if(i==0 || lastSeen == 1){\\n                    maxCount = Math.max(count, maxCount);\\n                }\\n                count = 0;\\n                lastSeen = -1;\\n            }\\n\\n            else if(forts[i] == 1){\\n                if(i == 0 || lastSeen == -1){\\n                    maxCount = Math.max(count, maxCount);\\n                }\\n                count = 0;\\n                lastSeen = 1;\\n            }\\n            \\n            else if(forts[i] == 0) {\\n                count++;\\n            }\\n        }\\n        return maxCount;\\n    }\\n```\\n\\nAny doubts related to this approach??\\nYou can ask them in comments.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int captureForts(int[] forts) {\\n        int n = forts.length;\\n\\n        int count = 0, maxCount = 0;\\n        int lastSeen = 0;\\n\\n        for(int i=0; i<n; i++){\\n            if(forts[i] == -1){\\n                if(i==0 || lastSeen == 1){\\n                    maxCount = Math.max(count, maxCount);\\n                }\\n                count = 0;\\n                lastSeen = -1;\\n            }\\n\\n            else if(forts[i] == 1){\\n                if(i == 0 || lastSeen == -1){\\n                    maxCount = Math.max(count, maxCount);\\n                }\\n                count = 0;\\n                lastSeen = 1;\\n            }\\n            \\n            else if(forts[i] == 0) {\\n                count++;\\n            }\\n        }\\n        return maxCount;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2946769,
                "title": "java-brute-force",
                "content": "# Please Upvote :D\\n\\n``` java []\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int ans = 0, max = 0;\\n        int n = forts.length;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (forts[i] == 1) {\\n                int count = 0;\\n                for (int j = i + 1; j < n; j++) {\\n                    if (forts[j] == 0) count++;\\n                    else if (forts[j] == 1) break;\\n                    else {\\n                        max = Math.max(max, count);\\n                        break;\\n                    }\\n                }\\n\\n                count = 0;\\n                for (int j = i - 1; j >= 0; j--) {\\n                    if (forts[j] == 0) count++;\\n                    else if (forts[j] == 1) break;\\n                    else {\\n                        max = Math.max(max, count);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int ans = 0, max = 0;\\n        int n = forts.length;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (forts[i] == 1) {\\n                int count = 0;\\n                for (int j = i + 1; j < n; j++) {\\n                    if (forts[j] == 0) count++;\\n                    else if (forts[j] == 1) break;\\n                    else {\\n                        max = Math.max(max, count);\\n                        break;\\n                    }\\n                }\\n\\n                count = 0;\\n                for (int j = i - 1; j >= 0; j--) {\\n                    if (forts[j] == 0) count++;\\n                    else if (forts[j] == 1) break;\\n                    else {\\n                        max = Math.max(max, count);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946676,
                "title": "c-o-n-easy-solution-brute-force",
                "content": "**Idea :-**\\n-> checking all forts.\\n-> If that fort is of ours, then moving both left and right sides until we reach end or any non-empty fort and updating the max answer.\\n\\n**TC :- O(N) \\nSC :- O(1)**\\n\\nThank You..!\\n\\n```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& f) {\\n        int mx = 0;                                // final max answer\\n        int n = f.size();\\n        for(int i = 0; i < n; i++){           // checking all the forts\\n            int j = i;\\n            if(f[j] == 1){                          // If the port is ours\\n                int k = j;\\n                j++;\\n                int c = 0;                   \\n                while(j < n and f[j] == 0){                  // moving right till end or non-empty fort\\n                    c++;\\n                    j++;\\n                }\\n                if(j < n and f[j] == -1)                       // if we reach enemies fort \\n                    mx = max(mx,c);\\n                int d = 0;\\n                k--;\\n                while(k >= 0 and f[k] == 0){             // similarly moving left side\\n                    k--;\\n                    d++;\\n                }\\n                if(k >= 0 and f[k] == -1)                   // similarly if we stop at enemies fort\\n                    mx = max(mx,d);\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& f) {\\n        int mx = 0;                                // final max answer\\n        int n = f.size();\\n        for(int i = 0; i < n; i++){           // checking all the forts\\n            int j = i;\\n            if(f[j] == 1){                          // If the port is ours\\n                int k = j;\\n                j++;\\n                int c = 0;                   \\n                while(j < n and f[j] == 0){                  // moving right till end or non-empty fort\\n                    c++;\\n                    j++;\\n                }\\n                if(j < n and f[j] == -1)                       // if we reach enemies fort \\n                    mx = max(mx,c);\\n                int d = 0;\\n                k--;\\n                while(k >= 0 and f[k] == 0){             // similarly moving left side\\n                    k--;\\n                    d++;\\n                }\\n                if(k >= 0 and f[k] == -1)                   // similarly if we stop at enemies fort\\n                    mx = max(mx,d);\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946487,
                "title": "capture-fort-from-left-and-right",
                "content": "```\\n// Attack from left and right and return maximum of forts captured from both sides\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        return Math.max(captureFromLeft(forts), captureFromRight(forts));\\n    }\\n    \\n    int captureFromLeft(int[] f) {\\n        int ans = 0;\\n        int n = f.length;\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(f[i] == 1) {\\n                for(int j = i+1; j < n; j++) {\\n                    if(f[j] == 1) break;\\n                    if(f[j] == -1){\\n                         ans = Math.max(j-i-1, ans);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int captureFromRight(int[] f) {\\n        int ans = 0;\\n        int n = f.length;\\n        \\n        for(int i = n-1; i >= 0; i--) {\\n            if(f[i] == 1) {\\n                for(int j = i-1; j >= 0; j--) {\\n                    if(f[j] == 1) break;\\n                    if(f[j] == -1) {\\n                        ans = Math.max(i-j-1, ans);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Attack from left and right and return maximum of forts captured from both sides\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        return Math.max(captureFromLeft(forts), captureFromRight(forts));\\n    }\\n    \\n    int captureFromLeft(int[] f) {\\n        int ans = 0;\\n        int n = f.length;\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(f[i] == 1) {\\n                for(int j = i+1; j < n; j++) {\\n                    if(f[j] == 1) break;\\n                    if(f[j] == -1){\\n                         ans = Math.max(j-i-1, ans);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int captureFromRight(int[] f) {\\n        int ans = 0;\\n        int n = f.length;\\n        \\n        for(int i = n-1; i >= 0; i--) {\\n            if(f[i] == 1) {\\n                for(int j = i-1; j >= 0; j--) {\\n                    if(f[j] == 1) break;\\n                    if(f[j] == -1) {\\n                        ans = Math.max(i-j-1, ans);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3304699,
                "title": "easy-solution-beginner-friendly-sliding-window-with-comments",
                "content": "\\n````\\nint i=0, j=0, ans = 0;\\n        int n = forts.size();\\n        \\n        if(n==0 or n==1)\\n            return 0;\\n        \\n        while(j<n){\\n          \\n          if(forts[i] == 0) //if encounter 0 move i\\n              i++;\\n            \\n          if((forts[j] == -1 and forts[i] == 1) or (forts[j] == 1 and forts[i] == -1)) {\\n              ans = max(ans, j-i-1);   //we do j-i-1 because we want the count of 0\\'s between 1 and -1 and vice versa\\n              i = j;  //then we update our i\\n          }\\n            \\n           if(forts[i] == forts[j])  //for cases where we have 0\\'s between 1 and 1 or -1 and -1 \\n               i = j;\\n            \\n            j++;\\n        }\\n        return ans;\\n\\t\\t\\n\\t\\t**Time Complexity- ** O(n)\\n\\t\\t**Space Complexity-** O(1)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "\\n````\\nint i=0, j=0, ans = 0;\\n        int n = forts.size();\\n        \\n        if(n==0 or n==1)\\n            return 0;\\n        \\n        while(j<n){\\n          \\n          if(forts[i] == 0) //if encounter 0 move i\\n              i++;\\n            \\n          if((forts[j] == -1 and forts[i] == 1) or (forts[j] == 1 and forts[i] == -1)) {\\n              ans = max(ans, j-i-1);   //we do j-i-1 because we want the count of 0\\'s between 1 and -1 and vice versa\\n              i = j;  //then we update our i\\n          }\\n            \\n           if(forts[i] == forts[j])  //for cases where we have 0\\'s between 1 and 1 or -1 and -1 \\n               i = j;\\n            \\n            j++;\\n        }\\n        return ans;\\n\\t\\t\\n\\t\\t**Time Complexity- ** O(n)\\n\\t\\t**Space Complexity-** O(1)",
                "codeTag": "Unknown"
            },
            {
                "id": 3283391,
                "title": "python-2-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    2 pointer\\n    move left pointer to right when right is not zero\\n    update max result when length of left to right window size > result\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n        n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        res, i = 0, 0\\n        for j in range(len(forts)):\\n            if forts[j]:\\n                if forts[j] == - forts[i]:\\n                    res = max(res,j-i-1)\\n                i = j\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        res, i = 0, 0\\n        for j in range(len(forts)):\\n            if forts[j]:\\n                if forts[j] == - forts[i]:\\n                    res = max(res,j-i-1)\\n                i = j\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148214,
                "title": "c-clear-o-n-solution",
                "content": "# Intuition\\nWe need to find the longest sequence between the closest NO_FORT and MY_FORT elements.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe can scan the array looking for NO_FORT and MY_FORT elements. To calculate the sequence length we need 2 indexes: previous and current.\\nPossible pairs:\\nNO_FORT vs NO_FORT - BAD\\nNO_FORT vs MY_FORT - GOOD\\nMY_FORT vs NO_FORT - GOOD\\nMY_FORT vs MY_FORT - BAD\\nSo we just need to find the max length for GOOD pairs.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    const int NO_FORT = -1;\\n    const int ENEMY = 0;\\n    const int MY_FORT = 1;\\n\\n    public int CaptureForts(int[] forts) {\\n        int max = 0;\\n        int previous = -1; // index of previous NO_FORT or MY_FORT \\n        for (int i=0; i<forts.Length; i++) {\\n            if (forts[i] == NO_FORT || forts[i] == MY_FORT) {\\n                if (previous >= 0 && forts[i] != forts[previous]) \\n                    max = Math.Max(i - previous - 1, max);            \\n                previous = i;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    const int NO_FORT = -1;\\n    const int ENEMY = 0;\\n    const int MY_FORT = 1;\\n\\n    public int CaptureForts(int[] forts) {\\n        int max = 0;\\n        int previous = -1; // index of previous NO_FORT or MY_FORT \\n        for (int i=0; i<forts.Length; i++) {\\n            if (forts[i] == NO_FORT || forts[i] == MY_FORT) {\\n                if (previous >= 0 && forts[i] != forts[previous]) \\n                    max = Math.Max(i - previous - 1, max);            \\n                previous = i;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3062238,
                "title": "very-simple-cpp-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        vector<int>cmd;\\n        vector<int>arm;\\n        int start_1=-1,start_m1=-1;\\n        int ans=-1;\\n        for(int i=0;i<forts.size();i++)\\n        {\\n            if(forts[i]==1)\\n            {\\n                if(start_m1!=-1)\\n                {\\n                    ans=max(ans,i-start_m1-1);\\n                    start_m1=-1;\\n                }\\n                start_1=i;\\n            }\\n            else if(forts[i]==-1)\\n            {\\n                if(start_1!=-1)\\n                {\\n                    ans=max(ans,i-start_1-1);\\n                    start_1=-1;\\n                }\\n                start_m1=i;\\n            }\\n            \\n        }\\n        if(ans==-1)return 0;\\n        return ans;\\n    }\\n};\\n```\\n---\\n\\n**please upvote if helpful**",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        vector<int>cmd;\\n        vector<int>arm;\\n        int start_1=-1,start_m1=-1;\\n        int ans=-1;\\n        for(int i=0;i<forts.size();i++)\\n        {\\n            if(forts[i]==1)\\n            {\\n                if(start_m1!=-1)\\n                {\\n                    ans=max(ans,i-start_m1-1);\\n                    start_m1=-1;\\n                }\\n                start_1=i;\\n            }\\n            else if(forts[i]==-1)\\n            {\\n                if(start_1!=-1)\\n                {\\n                    ans=max(ans,i-start_1-1);\\n                    start_1=-1;\\n                }\\n                start_m1=i;\\n            }\\n            \\n        }\\n        if(ans==-1)return 0;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3008028,
                "title": "python-all-out-army-attack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCheck 2 possible army movements - Forward and Backward\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRaise flag True when encounter 1 and set count to zero\\nWhen flag True and station is 0 then increment count by 1\\nIf flag False append the count to out list and set count to zero\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        if 1 not in forts or -1 not in forts: return 0\\n        out1 = [] # movement forward\\n        flag = False\\n        count1 = 0\\n        for i in range(len(forts)):\\n            if forts[i] == 1:\\n                flag = True\\n                count1 = 0\\n            elif forts[i] == -1:\\n                flag = False\\n                out1.append(count1)\\n                count1 = 0\\n            elif flag and forts[i] == 0:\\n                count1+=1\\n                \\n        fla = False\\n        out2=[]\\n        count2=0\\n        for i in range(len(forts)-1, -1, -1): # movement backward\\n            if forts[i] == 1:\\n                fla = True\\n                count2 = 0\\n            elif forts[i] == -1:\\n                fla = False\\n                out2.append(count2)\\n                count2 = 0\\n            elif fla and forts[i] == 0:\\n                \\n                count2+=1\\n        \\n        out1+=out2\\n        return max(out1)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        if 1 not in forts or -1 not in forts: return 0\\n        out1 = [] # movement forward\\n        flag = False\\n        count1 = 0\\n        for i in range(len(forts)):\\n            if forts[i] == 1:\\n                flag = True\\n                count1 = 0\\n            elif forts[i] == -1:\\n                flag = False\\n                out1.append(count1)\\n                count1 = 0\\n            elif flag and forts[i] == 0:\\n                count1+=1\\n                \\n        fla = False\\n        out2=[]\\n        count2=0\\n        for i in range(len(forts)-1, -1, -1): # movement backward\\n            if forts[i] == 1:\\n                fla = True\\n                count2 = 0\\n            elif forts[i] == -1:\\n                fla = False\\n                out2.append(count2)\\n                count2 = 0\\n            elif fla and forts[i] == 0:\\n                \\n                count2+=1\\n        \\n        out1+=out2\\n        return max(out1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2966800,
                "title": "best-approach-in-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int[]nums=forts;\\n        int max=0;\\n        int m=0;\\n        int c=0;\\n        boolean fl=false;\\n        boolean f=false;\\n        for(int i=0;i<forts.length;i++){\\n            if(nums[i]==1){\\n                if(fl){\\n                    max=c;\\n                   m=Math.max(m,max);\\n                   fl=false;\\n                }\\n                \\n                c=0;\\n                f=true;\\n                \\n            }\\n            else if(nums[i]==0){\\n                c++;\\n            }\\n            else if(nums[i]==-1){\\n               if(f){\\n                   max=c;\\n                   m=Math.max(m,max);\\n                   f=false;\\n               }\\n                c=0;\\n                fl=true;\\n                \\n            }\\n        }\\n        return m;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int[]nums=forts;\\n        int max=0;\\n        int m=0;\\n        int c=0;\\n        boolean fl=false;\\n        boolean f=false;\\n        for(int i=0;i<forts.length;i++){\\n            if(nums[i]==1){\\n                if(fl){\\n                    max=c;\\n                   m=Math.max(m,max);\\n                   fl=false;\\n                }\\n                \\n                c=0;\\n                f=true;\\n                \\n            }\\n            else if(nums[i]==0){\\n                c++;\\n            }\\n            else if(nums[i]==-1){\\n               if(f){\\n                   max=c;\\n                   m=Math.max(m,max);\\n                   f=false;\\n               }\\n                c=0;\\n                fl=true;\\n                \\n            }\\n        }\\n        return m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958448,
                "title": "python-o-n",
                "content": "# Approach\\n- So basically we just have to calculate the number of maximum continuous zerows between -1 and 1.\\n- first we will find the first non zero element.\\n- now we will start iteration through the array while calculating max zeros between 1 and -1.\\n- every time we will find a zero we will count it and if we find 1/-1 then our previous element should be different from current element.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        indx = 0\\n        count = 0\\n        prev = 0\\n        ans = 0\\n        for i in range(len(forts)):\\n            if forts[i]!=0:\\n                prev = forts[i]\\n                indx = i\\n                break\\n                \\n        for i in range(indx+1, len(forts)):\\n            if forts[i] == 0:\\n                count += 1\\n            else:\\n                if (forts[i] == 1 and prev == -1) or (forts[i] == -1 and prev == 1):\\n                    ans = max(ans, count)\\n                    count = 0\\n                    prev = forts[i]\\n                else:\\n                    count = 0\\n        \\n        return ans\\n            \\n```\\n---------------------\\n**Upvote the post if you find it helpful.\\nHappy coding.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        indx = 0\\n        count = 0\\n        prev = 0\\n        ans = 0\\n        for i in range(len(forts)):\\n            if forts[i]!=0:\\n                prev = forts[i]\\n                indx = i\\n                break\\n                \\n        for i in range(indx+1, len(forts)):\\n            if forts[i] == 0:\\n                count += 1\\n            else:\\n                if (forts[i] == 1 and prev == -1) or (forts[i] == -1 and prev == 1):\\n                    ans = max(ans, count)\\n                    count = 0\\n                    prev = forts[i]\\n                else:\\n                    count = 0\\n        \\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2951255,
                "title": "easy-solution-on-python-using-two-pointer-technique",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        i=0\\n        j=i+1\\n        size=len(forts)\\n        capture = []\\n\\n        while(j!=size):\\n            if(forts[j] == 0):\\n                j=j+1\\n            elif(forts[i]*forts[j] == -1):\\n                capture.append((j-i)-1)\\n                i = j\\n                j =j+1\\n            else:\\n                i = j\\n                j=j+1\\n        print(capture)\\n        \\n        if(capture == []):\\n            return 0\\n        else:\\n            return max(capture)\\n \\n\\n                    \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        i=0\\n        j=i+1\\n        size=len(forts)\\n        capture = []\\n\\n        while(j!=size):\\n            if(forts[j] == 0):\\n                j=j+1\\n            elif(forts[i]*forts[j] == -1):\\n                capture.append((j-i)-1)\\n                i = j\\n                j =j+1\\n            else:\\n                i = j\\n                j=j+1\\n        print(capture)\\n        \\n        if(capture == []):\\n            return 0\\n        else:\\n            return max(capture)\\n \\n\\n                    \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2950648,
                "title": "rust-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn capture_forts(forts: Vec<i32>) -> i32 {\\n        let (mut result, mut counter, mut prev_fort) = (0, 0, 0);\\n        for &x in &forts {\\n            match x {\\n                0 => counter += 1,\\n                _ => {\\n                    if prev_fort == -x {\\n                        result = result.max(counter);\\n                    }\\n                    counter = 0;\\n                    prev_fort = x;\\n                }\\n            }\\n        }\\n        result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Counting",
                    "Iterator"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn capture_forts(forts: Vec<i32>) -> i32 {\\n        let (mut result, mut counter, mut prev_fort) = (0, 0, 0);\\n        for &x in &forts {\\n            match x {\\n                0 => counter += 1,\\n                _ => {\\n                    if prev_fort == -x {\\n                        result = result.max(counter);\\n                    }\\n                    counter = 0;\\n                    prev_fort = x;\\n                }\\n            }\\n        }\\n        result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2947594,
                "title": "java-longest-continuous-zero-between-1-and-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind longest continuous zero between 1 and -1.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind longest continuous zero with two pointer.\\n\\n```\\n|0000...000|\\n\\n|: 1 or -1 ==> forts[i] == -forts[j]\\n``` \\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int captureForts(int[] forts) {\\n    final int n = forts.length;\\n    int result = 0;\\n    for (int i = 0, j = 0; i < n; i++) {\\n      if (forts[i] != 0) {\\n        if (forts[i] == -forts[j]) {\\n          result = Math.max(result, i - j - 1);\\n        }\\n        j = i;\\n      }\\n    }\\n\\n    return result;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n|0000...000|\\n\\n|: 1 or -1 ==> forts[i] == -forts[j]\\n```\n```\\nclass Solution {\\n  public int captureForts(int[] forts) {\\n    final int n = forts.length;\\n    int result = 0;\\n    for (int i = 0, j = 0; i < n; i++) {\\n      if (forts[i] != 0) {\\n        if (forts[i] == -forts[j]) {\\n          result = Math.max(result, i - j - 1);\\n        }\\n        j = i;\\n      }\\n    }\\n\\n    return result;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947308,
                "title": "c-easy-straightforward-code-clean-code",
                "content": "![image](https://assets.leetcode.com/users/images/cb44456e-8f8a-4354-9eaa-91880c8b9af9_1671914450.67461.png)\\n\\n\\n**T->O(n^2) && S->O(1)**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint captureForts(vector<int>& f) {\\n\\t\\t\\t\\tint n=f.size();\\n\\t\\t\\t\\tint ans=0;\\n\\t\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\t\\tif(f[i]==-1){\\n\\t\\t\\t\\t\\t\\tint l=i;\\n\\t\\t\\t\\t\\t\\tint r=i;\\n\\t\\t\\t\\t\\t\\twhile(r++){\\n\\t\\t\\t\\t\\t\\t\\tif(r>=n || f[r]==-1){\\n\\t\\t\\t\\t\\t\\t\\t\\tr=i;\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tif(f[r]==1) break;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\twhile(true){\\n\\t\\t\\t\\t\\t\\t\\tl--;\\n\\t\\t\\t\\t\\t\\t\\tif(l<0 || f[l]==-1){\\n\\t\\t\\t\\t\\t\\t\\t\\tl=i;\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tif(f[l]==1) break;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tans=max(ans,max(i-l-1,r-i-1));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint captureForts(vector<int>& f) {\\n\\t\\t\\t\\tint n=f.size();\\n\\t\\t\\t\\tint ans=0;\\n\\t\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\t\\tif(f[i]==-1){\\n\\t\\t\\t\\t\\t\\tint l=i;\\n\\t\\t\\t\\t\\t\\tint r=i;\\n\\t\\t\\t\\t\\t\\twhile(r++){\\n\\t\\t\\t\\t\\t\\t\\tif(r>=n || f[r]==-1){\\n\\t\\t\\t\\t\\t\\t\\t\\tr=i;\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2947096,
                "title": "c-most-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int n=forts.size();\\n        int maxi=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(forts[i]==1)\\n            {\\n                int j=i+1;\\n                while(j<n)\\n                {\\n                    if(forts[j]==-1)\\n                    {\\n                        maxi=max(maxi,j-i-1);\\n                        break;\\n                    }\\n                    if(forts[j]==1)\\n                        break;\\n                    j++;\\n                }\\n            }\\n            if(forts[i]==-1)\\n            {\\n                int j=i+1;\\n                while(j<n)\\n                {\\n                    if(forts[j]==1)\\n                    {\\n                        maxi=max(maxi,j-i-1);\\n                        break;\\n                    }\\n                    if(forts[j]==-1)\\n                        break;\\n                    j++;\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int n=forts.size();\\n        int maxi=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(forts[i]==1)\\n            {\\n                int j=i+1;\\n                while(j<n)\\n                {\\n                    if(forts[j]==-1)\\n                    {\\n                        maxi=max(maxi,j-i-1);\\n                        break;\\n                    }\\n                    if(forts[j]==1)\\n                        break;\\n                    j++;\\n                }\\n            }\\n            if(forts[i]==-1)\\n            {\\n                int j=i+1;\\n                while(j<n)\\n                {\\n                    if(forts[j]==1)\\n                    {\\n                        maxi=max(maxi,j-i-1);\\n                        break;\\n                    }\\n                    if(forts[j]==-1)\\n                        break;\\n                    j++;\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947057,
                "title": "python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        lol=0\\n        for i in range(len(forts)):\\n            for j in range(len(forts)):\\n                \\n                if not i==j and (forts[j]==1 or forts[i]==1) and  (forts[j]==-1 or forts[i]==-1):\\n                    if i>j and len(set(forts[j+1:i]))==1 and forts[j+1:i][0]==0:\\n                        lol=max(lol,len(forts[j+1:i]))\\n                        \\n                    if  i<j and len(set(forts[j+1:i]))==1 and forts[j+1:i][0]==0:\\n                        lol=max(lol,len(forts[j+1:i]))\\n                        \\n        return lol\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        lol=0\\n        for i in range(len(forts)):\\n            for j in range(len(forts)):\\n                \\n                if not i==j and (forts[j]==1 or forts[i]==1) and  (forts[j]==-1 or forts[i]==-1):\\n                    if i>j and len(set(forts[j+1:i]))==1 and forts[j+1:i][0]==0:\\n                        lol=max(lol,len(forts[j+1:i]))\\n                        \\n                    if  i<j and len(set(forts[j+1:i]))==1 and forts[j+1:i][0]==0:\\n                        lol=max(lol,len(forts[j+1:i]))\\n                        \\n        return lol\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947024,
                "title": "easy-and-understandable-code-c",
                "content": "Leetcode Contest - 24-12-2022\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int n=forts.size();\\n        int res=0;\\n        \\n        vector<int> ans;\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            if(forts[i]==1 || forts[i]==-1){\\n                ans.push_back(i);\\n            }\\n        }\\n        if(ans.size()>0){\\n            for(int i=0;i<ans.size()-1;i++){\\n                if((forts[ans[i]]*forts[ans[i+1]])==-1){\\n                    res=max(res,abs(ans[i+1]-ans[i])-1);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int n=forts.size();\\n        int res=0;\\n        \\n        vector<int> ans;\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            if(forts[i]==1 || forts[i]==-1){\\n                ans.push_back(i);\\n            }\\n        }\\n        if(ans.size()>0){\\n            for(int i=0;i<ans.size()-1;i++){\\n                if((forts[ans[i]]*forts[ans[i+1]])==-1){\\n                    res=max(res,abs(ans[i+1]-ans[i])-1);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946851,
                "title": "python-accepted",
                "content": "```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        \\n       \\n        def attack(forts):\\n            m, c = 0, -1\\n        \\n            for f in forts:\\n                if   f == 1 : c = 0                # start attack\\n                elif f == 0 : c += c >= 0          # count forts\\n                else        : c, m = -1, max(c,m)  # stop attack\\n\\n            return m\\n        \\n        return max(attack(forts), attack(forts[::-1]))\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        \\n       \\n        def attack(forts):\\n            m, c = 0, -1\\n        \\n            for f in forts:\\n                if   f == 1 : c = 0                # start attack\\n                elif f == 0 : c += c >= 0          # count forts\\n                else        : c, m = -1, max(c,m)  # stop attack\\n\\n            return m\\n        \\n        return max(attack(forts), attack(forts[::-1]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946829,
                "title": "java-o-n-time-o-1-space-efficient-solution-easy-to-understand",
                "content": "#if u like it kindly upvote it motivates me to post more precise solutions in future thanks\\n\\n# Complexity\\n- Time complexity:\\n   O(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int c=0;\\n        int max=0;\\n        boolean one=false;\\n        boolean minus=false;\\n        for(int i:forts){\\n            if((one||minus)&&i==0){\\n                c++;\\n            }\\n            if(i==-1 &&one){\\n                max=Math.max(max,c);\\n                c=0;\\n                one=false;\\n                minus=true;\\n            }\\n            if(i==1 &&minus){\\n                max=Math.max(max,c);\\n                c=0;\\n                one=true;\\n                minus=false;\\n            }\\n            if(minus &&i==-1||one &&i==1){\\n                c=0;\\n            }\\n             if(i==1){\\n                one=true;\\n            }\\n            if(i==-1){\\n                minus=true;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int c=0;\\n        int max=0;\\n        boolean one=false;\\n        boolean minus=false;\\n        for(int i:forts){\\n            if((one||minus)&&i==0){\\n                c++;\\n            }\\n            if(i==-1 &&one){\\n                max=Math.max(max,c);\\n                c=0;\\n                one=false;\\n                minus=true;\\n            }\\n            if(i==1 &&minus){\\n                max=Math.max(max,c);\\n                c=0;\\n                one=true;\\n                minus=false;\\n            }\\n            if(minus &&i==-1||one &&i==1){\\n                c=0;\\n            }\\n             if(i==1){\\n                one=true;\\n            }\\n            if(i==-1){\\n                minus=true;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946728,
                "title": "c-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMax difference between -1 and 1.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n Just Calculate The max difference between two consecutive -1 and 1.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    \\u0398(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    \\u0398(1) \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int ans=0;\\n        int temp=0;\\n        int next=0;\\n        for(int i=0;i<forts.size();i++)\\n        {\\n            if(forts[i]==next)\\n               {\\n                   ans=max(ans,temp);\\n               }\\n            if(forts[i]==1)\\n               {\\n                   next=-1;\\n                   temp=0;\\n               }\\n            else if(forts[i]==-1)\\n            {\\n                next=1;\\n                temp=0;\\n            } \\n            else{\\n                if(next!=0) \\n                    temp++; \\n            } \\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int ans=0;\\n        int temp=0;\\n        int next=0;\\n        for(int i=0;i<forts.size();i++)\\n        {\\n            if(forts[i]==next)\\n               {\\n                   ans=max(ans,temp);\\n               }\\n            if(forts[i]==1)\\n               {\\n                   next=-1;\\n                   temp=0;\\n               }\\n            else if(forts[i]==-1)\\n            {\\n                next=1;\\n                temp=0;\\n            } \\n            else{\\n                if(next!=0) \\n                    temp++; \\n            } \\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946656,
                "title": "o-n-with-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe care about zeros between -1 and 1 only. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHave a stack of -1,0,1. When we get 1, we count the number of zeros before we get to -1. The same applies for -1: we count the number of zeros before we get to 1. For 0, we just add to end of stack\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int ans=0;\\n        vector<int> sk;\\n        for (auto &x : forts){\\n            if (x==1){\\n                int cnt=0;\\n                while (sk.size() && sk.back() == 0){\\n                    sk.pop_back();\\n                    cnt++;\\n                }\\n                if (sk.size() && sk.back() == -1) ans=max(ans,cnt);\\n                sk = {1};\\n            }\\n            else if (x==-1){\\n                int cnt=0;\\n                while (sk.size() && sk.back()==0){\\n                    sk.pop_back();\\n                    cnt++;\\n                }\\n                if (sk.size() && sk.back() == 1) ans = max(ans, cnt);\\n                sk={-1};\\n            }\\n            else sk.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int ans=0;\\n        vector<int> sk;\\n        for (auto &x : forts){\\n            if (x==1){\\n                int cnt=0;\\n                while (sk.size() && sk.back() == 0){\\n                    sk.pop_back();\\n                    cnt++;\\n                }\\n                if (sk.size() && sk.back() == -1) ans=max(ans,cnt);\\n                sk = {1};\\n            }\\n            else if (x==-1){\\n                int cnt=0;\\n                while (sk.size() && sk.back()==0){\\n                    sk.pop_back();\\n                    cnt++;\\n                }\\n                if (sk.size() && sk.back() == 1) ans = max(ans, cnt);\\n                sk={-1};\\n            }\\n            else sk.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946569,
                "title": "easy-solution-o-n-c",
                "content": "# Intuition\\nThe goal of our algorithm is to stock every \\'1\\' and \\'-1\\' in a vector with their coordinate \\'i\\'.\\n\\n# Approach\\n\\nIt will be a lot easier to calculate the distance between two \\'1\\' and \\'-1\\'\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        vector<pair<int,int>> v; //Here we\\'re stocking all \\'-1\\' and \\'1\\' with their coordinate\\n        for (int i=0; i<forts.size(); i++) {\\n            if (forts[i]==1 || forts[i]==-1)\\n                v.push_back({i, forts[i]});\\n        }\\n        if (v.size()<=1)\\n            return 0;\\n        int distMax=0;\\n        for (int i=0; i<v.size()-1; i++) { //We\\'re calculating the difference between two \\'1\\' and \\'-1\\'\\n            if (v[i].second==-v[i+1].second) { //Verification if they are close of each other in our vector\\n                distMax=max(distMax,abs(v[i].first-v[i+1].first)-1); //We\\'re calculating the absolute distance\\n            }\\n        }\\n        return distMax;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        vector<pair<int,int>> v; //Here we\\'re stocking all \\'-1\\' and \\'1\\' with their coordinate\\n        for (int i=0; i<forts.size(); i++) {\\n            if (forts[i]==1 || forts[i]==-1)\\n                v.push_back({i, forts[i]});\\n        }\\n        if (v.size()<=1)\\n            return 0;\\n        int distMax=0;\\n        for (int i=0; i<v.size()-1; i++) { //We\\'re calculating the difference between two \\'1\\' and \\'-1\\'\\n            if (v[i].second==-v[i+1].second) { //Verification if they are close of each other in our vector\\n                distMax=max(distMax,abs(v[i].first-v[i+1].first)-1); //We\\'re calculating the absolute distance\\n            }\\n        }\\n        return distMax;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946567,
                "title": "100-fastest-easy-simple-c-solution",
                "content": "## Code\\n```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int ans=0;\\n        int n=forts.size();\\n        for (int i=0; i<n; i++){\\n            if (forts[i]==1){\\n                i++;\\n                int curr=0;\\n                while (i<n && forts[i]==0){\\n                    curr++;\\n                    i++;\\n                }\\n                if (i<n && forts[i]==-1)ans= max(ans,curr);\\n                i--;\\n            }\\n            if (forts[i]==-1){\\n                i++;\\n                int curr=0;\\n                while (i<n && forts[i]==0){\\n                    curr++;\\n                    i++;\\n                }\\n                if (i<n && forts[i]==1)ans= max(ans,curr);\\n                i--;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```\\n## Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int ans=0;\\n        int n=forts.size();\\n        for (int i=0; i<n; i++){\\n            if (forts[i]==1){\\n                i++;\\n                int curr=0;\\n                while (i<n && forts[i]==0){\\n                    curr++;\\n                    i++;\\n                }\\n                if (i<n && forts[i]==-1)ans= max(ans,curr);\\n                i--;\\n            }\\n            if (forts[i]==-1){\\n                i++;\\n                int curr=0;\\n                while (i<n && forts[i]==0){\\n                    curr++;\\n                    i++;\\n                }\\n                if (i<n && forts[i]==1)ans= max(ans,curr);\\n                i--;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946544,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:O(N*N)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& f) {\\n        int ans=0;\\n        for(int i=0; i<f.size(); i++){\\n            int cnt=0;\\n            for(int j=i+1; j<f.size(); j++){\\n                if(f[i]==1 && f[j]==-1){\\n                    ans=max(ans, cnt);\\n                }\\n                if(f[i]==-1 && f[j]==1){\\n                    ans=max(ans, cnt);\\n                }\\n                if(f[j]!=0){break;}\\n                cnt++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& f) {\\n        int ans=0;\\n        for(int i=0; i<f.size(); i++){\\n            int cnt=0;\\n            for(int j=i+1; j<f.size(); j++){\\n                if(f[i]==1 && f[j]==-1){\\n                    ans=max(ans, cnt);\\n                }\\n                if(f[i]==-1 && f[j]==1){\\n                    ans=max(ans, cnt);\\n                }\\n                if(f[j]!=0){break;}\\n                cnt++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946524,
                "title": "beats-100-java-solution-o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int enemy=0,max=0;\\n        int count=0,flag=0;\\n        for(int i=0;i<forts.length;i++){\\n            if(forts[i]==1){\\n                if(flag==1)count=0;\\n                flag=1;\\n                \\n            }\\n            if(forts[i]==0 && flag==1)count++;\\n            if(forts[i]==-1){\\n                max=Math.max(max,count);\\n                count=0;\\n                flag=0;\\n            }\\n        }\\n        count=0;\\n        flag=0;\\n        for(int i=forts.length-1;i>=0;i--){\\n            if(forts[i]==1){\\n                if(flag==1)count=0;\\n                flag=1;\\n                \\n            }\\n            if(forts[i]==0 && flag==1)count++;\\n            if(forts[i]==-1){\\n                max=Math.max(max,count);\\n                count=0;\\n                flag=0;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int enemy=0,max=0;\\n        int count=0,flag=0;\\n        for(int i=0;i<forts.length;i++){\\n            if(forts[i]==1){\\n                if(flag==1)count=0;\\n                flag=1;\\n                \\n            }\\n            if(forts[i]==0 && flag==1)count++;\\n            if(forts[i]==-1){\\n                max=Math.max(max,count);\\n                count=0;\\n                flag=0;\\n            }\\n        }\\n        count=0;\\n        flag=0;\\n        for(int i=forts.length-1;i>=0;i--){\\n            if(forts[i]==1){\\n                if(flag==1)count=0;\\n                flag=1;\\n                \\n            }\\n            if(forts[i]==0 && flag==1)count++;\\n            if(forts[i]==-1){\\n                max=Math.max(max,count);\\n                count=0;\\n                flag=0;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946522,
                "title": "java-solution-easy-approach-o-n-time-beats-100",
                "content": "```java\\nclass Solution {\\n    public int captureForts(int[] a) {\\n        int n = a.length;\\n    \\n        List<Integer> list = new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]!=0)\\n             list.add(i);   \\n        }\\n        int max=0;\\n        for(int i=0;i<list.size()-1;i++)\\n        {\\n            if(a[list.get(i)]==-1*a[list.get(i+1)])\\n                max=Math.max(max,list.get(i+1)-list.get(i)-1);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int captureForts(int[] a) {\\n        int n = a.length;\\n    \\n        List<Integer> list = new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]!=0)\\n             list.add(i);   \\n        }\\n        int max=0;\\n        for(int i=0;i<list.size()-1;i++)\\n        {\\n            if(a[list.get(i)]==-1*a[list.get(i+1)])\\n                max=Math.max(max,list.get(i+1)-list.get(i)-1);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946521,
                "title": "c-explanation-simple",
                "content": "### Code\\n```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int ans = 0;\\n        for(int i = 0; i < forts.size(); i++) {\\n            if(forts[i] == 0 or forts[i] == -1) continue;  \\n            for(int j = i + 1; j < forts.size(); j++) {\\n                if(forts[j] == 1) break;\\n                if(forts[j] == -1) {\\n                    ans = max(ans, j - i - 1);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        \\n        for(int i = forts.size() - 1; i >= 0 ; i--) {\\n            if(forts[i] == 0 or forts[i] == -1) continue;  \\n            for(int j = i - 1; j >= 0; j--) {\\n                if(forts[j] == 1) break;\\n                if(forts[j] == -1) {\\n                    ans = max(ans, i - j - 1);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int ans = 0;\\n        for(int i = 0; i < forts.size(); i++) {\\n            if(forts[i] == 0 or forts[i] == -1) continue;  \\n            for(int j = i + 1; j < forts.size(); j++) {\\n                if(forts[j] == 1) break;\\n                if(forts[j] == -1) {\\n                    ans = max(ans, j - i - 1);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        \\n        for(int i = forts.size() - 1; i >= 0 ; i--) {\\n            if(forts[i] == 0 or forts[i] == -1) continue;  \\n            for(int j = i - 1; j >= 0; j--) {\\n                if(forts[j] == 1) break;\\n                if(forts[j] == -1) {\\n                    ans = max(ans, i - j - 1);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946498,
                "title": "python-3-check-left-and-right",
                "content": "```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        res = 0\\n        \\n        for i in range(len(forts)):\\n            if forts[i] == 1:\\n                curr = i\\n                \\n                for l in range(i - 1, -1, -1):\\n                    if forts[l] == 1:\\n                        break\\n                    if forts[l] == -1:\\n                        res = max(res, curr - l)\\n                        break\\n                \\n                for r in range(i + 1, len(forts)):\\n                    if forts[r] == 1:\\n                        break\\n                    if forts[r] == -1:\\n                        res = max(res, r - curr)\\n                        break\\n        \\n        return res - 1 if res else 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        res = 0\\n        \\n        for i in range(len(forts)):\\n            if forts[i] == 1:\\n                curr = i\\n                \\n                for l in range(i - 1, -1, -1):\\n                    if forts[l] == 1:\\n                        break\\n                    if forts[l] == -1:\\n                        res = max(res, curr - l)\\n                        break\\n                \\n                for r in range(i + 1, len(forts)):\\n                    if forts[r] == 1:\\n                        break\\n                    if forts[r] == -1:\\n                        res = max(res, r - curr)\\n                        break\\n        \\n        return res - 1 if res else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946495,
                "title": "c-two-pointers",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int ans = 0, n = size(forts);\\n        for (int i = 0, j; i < n; ) {\\n            if (forts[i] == 0) {\\n                for (j = i; j < n && forts[j] == 0; j++);\\n                if (i > 0 && j < n && (forts[i-1] + forts[j] == 0))\\n                    ans = max(ans, j-i);\\n                i = j;\\n            } else i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int ans = 0, n = size(forts);\\n        for (int i = 0, j; i < n; ) {\\n            if (forts[i] == 0) {\\n                for (j = i; j < n && forts[j] == 0; j++);\\n                if (i > 0 && j < n && (forts[i-1] + forts[j] == 0))\\n                    ans = max(ans, j-i);\\n                i = j;\\n            } else i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4096434,
                "title": "py-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def captureForts(self, forts):\\n        \"\"\"\\n        :type forts: List[int]\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        \\n        for i in range(len(forts)):\\n            if forts[i] == 1:\\n                curr = i\\n                \\n                for l in range(i - 1, -1, -1):\\n                    if forts[l] == 1:\\n                        break\\n                    if forts[l] == -1:\\n                        res = max(res, curr - l)\\n                        break\\n                \\n                for r in range(i + 1, len(forts)):\\n                    if forts[r] == 1:\\n                        break\\n                    if forts[r] == -1:\\n                        res = max(res, r - curr)\\n                        break\\n        \\n        return res - 1 if res else 0\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def captureForts(self, forts):\\n        \"\"\"\\n        :type forts: List[int]\\n        :rtype: int\\n        \"\"\"\\n        res = 0\\n        \\n        for i in range(len(forts)):\\n            if forts[i] == 1:\\n                curr = i\\n                \\n                for l in range(i - 1, -1, -1):\\n                    if forts[l] == 1:\\n                        break\\n                    if forts[l] == -1:\\n                        res = max(res, curr - l)\\n                        break\\n                \\n                for r in range(i + 1, len(forts)):\\n                    if forts[r] == 1:\\n                        break\\n                    if forts[r] == -1:\\n                        res = max(res, r - curr)\\n                        break\\n        \\n        return res - 1 if res else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4094319,
                "title": "an-alternative-approach-regex-beats-91-runtime-atm",
                "content": "# Intuition\\nThis problem is about pattern searching, so regex should work.\\nNot the best solution, just trying something different.\\n\\n# Approach\\nFirst convert the list into a string, then find zeros bounded by 1 and -1:\\n1. \"10+-1\"\\n2. \"-10+1\"\\n\\nPlace a negative lookback \"?<!-\" before rule #1 to make sure the first entry is not \"-1\".\\nThen, use a lookahead assertion \"?=\" to enable overlapping.\\nFinally, apply len() and max() on all matches to get the answer.\\n\\nThis approach is more comprehensible and good at matching, it doesn\\'t run fast though.\\n\\n# Complexity\\n- Time complexity:\\nO(n)~O(n^2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        cap = re.findall(\\'(?=((?<!-)10+-1|-10+1))\\', \\'\\'.join(str(x) for x in forts))\\n        return len(max(cap, key=len, default=0)) -3 if cap else 0\\n```",
                "solutionTags": [
                    "Python3",
                    "String Matching"
                ],
                "code": "```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        cap = re.findall(\\'(?=((?<!-)10+-1|-10+1))\\', \\'\\'.join(str(x) for x in forts))\\n        return len(max(cap, key=len, default=0)) -3 if cap else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073405,
                "title": "easy-cpp-solution-beginner-frienldy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- For each of the element with value 1 check on both the front and back side for the nearest available -1. Keep track of maximum number of 0 in between.\\n- Return the max number of zeros in between.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int check(vector<int>& forts, int ind){\\n        int b = 0, f = 0;\\n        int sz = forts.size();\\n        int i=ind+1;\\n        while(i < sz && forts[i] == 0){\\n          i++;\\n          f++;\\n        }\\n        if(i == sz || i < sz && forts[i] != -1) f = 0;\\n        i = ind-1;\\n        while(i >= 0 && forts[i] == 0){\\n          b++;\\n          i--;\\n        }\\n        if(i == -1 || i >= 0 && forts[i] != -1) b = 0;\\n        return max(b, f);\\n    }\\n    int captureForts(vector<int>& forts) {\\n        int maxsz = 0;\\n        \\n        for(int i=0; i<forts.size(); i++){\\n          if(forts[i] == 1){\\n            maxsz = max(maxsz, check(forts, i));\\n          }\\n        }\\n\\n        return maxsz;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int check(vector<int>& forts, int ind){\\n        int b = 0, f = 0;\\n        int sz = forts.size();\\n        int i=ind+1;\\n        while(i < sz && forts[i] == 0){\\n          i++;\\n          f++;\\n        }\\n        if(i == sz || i < sz && forts[i] != -1) f = 0;\\n        i = ind-1;\\n        while(i >= 0 && forts[i] == 0){\\n          b++;\\n          i--;\\n        }\\n        if(i == -1 || i >= 0 && forts[i] != -1) b = 0;\\n        return max(b, f);\\n    }\\n    int captureForts(vector<int>& forts) {\\n        int maxsz = 0;\\n        \\n        for(int i=0; i<forts.size(); i++){\\n          if(forts[i] == 1){\\n            maxsz = max(maxsz, check(forts, i));\\n          }\\n        }\\n\\n        return maxsz;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068872,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        temp = forts[::-1]\\n        res = [0]\\n        i, j = 0, 0\\n        \\n        while i < len(forts) - 1:\\n            c = 0\\n            if forts[i] == 1:\\n                f = True\\n                for j in range(i+1, len(forts)) :\\n                    if forts[j] == 1:\\n                        f = False\\n                        break\\n                    elif forts[j] == -1:                         \\n                        break\\n                if forts[j] == -1 and f:\\n                    c = abs(j - i) - 1\\n                    res += [c]\\n\\n\\n            if temp[i] == 1:\\n                f = True\\n                for j in range(i+1, len(temp)) :\\n                    if temp[j] == 1:\\n                        f = False\\n                        break\\n                    elif temp[j] == -1:\\n                        break\\n                if temp[j] == -1 and f:\\n                    c = abs(j - i) - 1\\n                    res += [c]\\n\\n            i += 1\\n        return max(res)\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        temp = forts[::-1]\\n        res = [0]\\n        i, j = 0, 0\\n        \\n        while i < len(forts) - 1:\\n            c = 0\\n            if forts[i] == 1:\\n                f = True\\n                for j in range(i+1, len(forts)) :\\n                    if forts[j] == 1:\\n                        f = False\\n                        break\\n                    elif forts[j] == -1:                         \\n                        break\\n                if forts[j] == -1 and f:\\n                    c = abs(j - i) - 1\\n                    res += [c]\\n\\n\\n            if temp[i] == 1:\\n                f = True\\n                for j in range(i+1, len(temp)) :\\n                    if temp[j] == 1:\\n                        f = False\\n                        break\\n                    elif temp[j] == -1:\\n                        break\\n                if temp[j] == -1 and f:\\n                    c = abs(j - i) - 1\\n                    res += [c]\\n\\n            i += 1\\n        return max(res)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058084,
                "title": "easy-python-solution-two-pointer-approach",
                "content": "**Basically, logic is very simple I am moving the j pointer and the point where ( j != 0 ) i am just checking whether value at the i pointer which is at last non zero element is equal to value at j or not if it is not equal to value at j then i am storing length ( j-i-1 )  in max function and assigning that j pointer now to i and start moving j again.**\\n\\n*Here\\'s a step-by-step explanation of the code:*\\n\\ni, ans, and res are initialized to -1, 0, and 0, respectively.\\n\\nThe code iterates through the elements of the input list forts using a loop.\\n\\nWithin the loop:\\n\\nIf an element in the forts list is not 0 and i is less than 0 (indicating it hasn\\'t been initialized or set yet), i is updated to the current index.\\n\\nIf the current element in forts is not equal to the element at the index i and not equal to 0:\\n\\nThe variable ans is calculated as the difference between the current index j and the previous index i, minus 1.\\ni is updated to the current index j.\\nres is updated to the maximum value between res and ans.\\nIf the current element in forts is equal to the element at the index i, i is updated to the current index j.\\n\\nFinally, the method returns the maximum difference between indices (res), where the elements are not equal to 0\\n\\n\\n\\n\\t\\n        i=-1; ans=0; res=0\\n        \\n        for j in range(len(forts)):\\n            if forts[j] != 0 and i<0:\\n                i=j\\n            \\n            if forts[j] != forts[i] and forts[j] !=0 :\\n                ans = j-i-1\\n                i=j\\n                res=max(res,ans)\\n                \\n            elif forts[j]==forts[i]:\\n                i=j\\n             \\n        return res\\n\\t\\t\\n\\t\\t\\n\\t\\tDon\\'t forget to upvote......................",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "**Basically, logic is very simple I am moving the j pointer and the point where ( j != 0 ) i am just checking whether value at the i pointer which is at last non zero element is equal to value at j or not if it is not equal to value at j then i am storing length ( j-i-1 )  in max function and assigning that j pointer now to i and start moving j again.**\\n\\n*Here\\'s a step-by-step explanation of the code:*\\n\\ni, ans, and res are initialized to -1, 0, and 0, respectively.\\n\\nThe code iterates through the elements of the input list forts using a loop.\\n\\nWithin the loop:\\n\\nIf an element in the forts list is not 0 and i is less than 0 (indicating it hasn\\'t been initialized or set yet), i is updated to the current index.\\n\\nIf the current element in forts is not equal to the element at the index i and not equal to 0:\\n\\nThe variable ans is calculated as the difference between the current index j and the previous index i, minus 1.\\ni is updated to the current index j.\\nres is updated to the maximum value between res and ans.\\nIf the current element in forts is equal to the element at the index i, i is updated to the current index j.\\n\\nFinally, the method returns the maximum difference between indices (res), where the elements are not equal to 0\\n\\n\\n\\n\\t\\n        i=-1; ans=0; res=0\\n        \\n        for j in range(len(forts)):\\n            if forts[j] != 0 and i<0:\\n                i=j\\n            \\n            if forts[j] != forts[i] and forts[j] !=0 :\\n                ans = j-i-1\\n                i=j\\n                res=max(res,ans)\\n                \\n            elif forts[j]==forts[i]:\\n                i=j\\n             \\n        return res\\n\\t\\t\\n\\t\\t\\n\\t\\tDon\\'t forget to upvote......................",
                "codeTag": "Unknown"
            },
            {
                "id": 4016262,
                "title": "python",
                "content": "# Code\\n```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        count = 0\\n        Output = 0\\n        curr = None\\n\\n        for i in forts:\\n            if i == 1:\\n                if count != 0:\\n                    if curr == -1:\\n                        if count > Output:\\n                            Output = count\\n                        count = 0\\n                    else:\\n                        count = 0\\n                curr = 1\\n            elif i == -1:\\n                if count != 0:\\n                    if curr == 1:\\n                        if count > Output:\\n                            Output = count\\n                        count = 0\\n                    else:\\n                        count = 0\\n                curr = -1\\n            elif i == 0:\\n                count = count + 1\\n        \\n        return Output\\n\\n        # 20230908\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        count = 0\\n        Output = 0\\n        curr = None\\n\\n        for i in forts:\\n            if i == 1:\\n                if count != 0:\\n                    if curr == -1:\\n                        if count > Output:\\n                            Output = count\\n                        count = 0\\n                    else:\\n                        count = 0\\n                curr = 1\\n            elif i == -1:\\n                if count != 0:\\n                    if curr == 1:\\n                        if count > Output:\\n                            Output = count\\n                        count = 0\\n                    else:\\n                        count = 0\\n                curr = -1\\n            elif i == 0:\\n                count = count + 1\\n        \\n        return Output\\n\\n        # 20230908\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003146,
                "title": "easy-to-understand-python3-solution-tc-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        l = 0\\n\\n        for i in range(len(forts)):\\n            if forts[i] != 0:\\n                l = i\\n                break\\n        \\n        maxforts = 0\\n\\n        while l < len(forts)-1:\\n            count = 0\\n            r = l + 1\\n\\n            while r < len(forts)-1 and forts[r] == 0:\\n                count += 1\\n                r += 1\\n            \\n            if forts[l] == 1 and forts[r] == -1:\\n                maxforts = max(maxforts, count)\\n                \\n            if forts[l] == -1 and forts[r] == 1:\\n                maxforts = max(maxforts, count)\\n            \\n            l = r\\n        \\n        return maxforts\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        l = 0\\n\\n        for i in range(len(forts)):\\n            if forts[i] != 0:\\n                l = i\\n                break\\n        \\n        maxforts = 0\\n\\n        while l < len(forts)-1:\\n            count = 0\\n            r = l + 1\\n\\n            while r < len(forts)-1 and forts[r] == 0:\\n                count += 1\\n                r += 1\\n            \\n            if forts[l] == 1 and forts[r] == -1:\\n                maxforts = max(maxforts, count)\\n                \\n            if forts[l] == -1 and forts[r] == 1:\\n                maxforts = max(maxforts, count)\\n            \\n            l = r\\n        \\n        return maxforts\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002065,
                "title": "easy-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        if 1 not in forts or -1 not in forts: return 0\\n        out1 = []\\n        flag = False\\n        count1 = 0\\n        i=0\\n        fla = False\\n        out2=[]\\n        count2=0\\n        j=len(forts)-1\\n        while(i<len(forts) and j>-1):\\n            if forts[i] == 1:\\n                flag = True\\n                count1 = 0\\n            elif forts[i] == -1:\\n                flag = False\\n                out1.append(count1)\\n                count1 = 0\\n            elif flag and forts[i] == 0:\\n                count1+=1\\n            if forts[j] == 1:\\n                fla = True\\n                count2 = 0\\n            elif forts[j] == -1:\\n                fla = False\\n                out2.append(count2)\\n                count2 = 0\\n            elif fla and forts[j] == 0:\\n                count2+=1\\n            i+=1\\n            j-=1\\n        \\n        out1+=out2\\n        return max(out1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        if 1 not in forts or -1 not in forts: return 0\\n        out1 = []\\n        flag = False\\n        count1 = 0\\n        i=0\\n        fla = False\\n        out2=[]\\n        count2=0\\n        j=len(forts)-1\\n        while(i<len(forts) and j>-1):\\n            if forts[i] == 1:\\n                flag = True\\n                count1 = 0\\n            elif forts[i] == -1:\\n                flag = False\\n                out1.append(count1)\\n                count1 = 0\\n            elif flag and forts[i] == 0:\\n                count1+=1\\n            if forts[j] == 1:\\n                fla = True\\n                count2 = 0\\n            elif forts[j] == -1:\\n                fla = False\\n                out2.append(count2)\\n                count2 = 0\\n            elif fla and forts[j] == 0:\\n                count2+=1\\n            i+=1\\n            j-=1\\n        \\n        out1+=out2\\n        return max(out1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3993767,
                "title": "basic-java-soln-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int s=-1,e=-1,ans=0;\\n        for(int i=0;i<forts.length;i++){\\n            if(forts[i]==1||forts[i]==-1){\\n                if(s==-1)\\n                    s=i;\\n                else\\n                    if(forts[s]==-forts[i])\\n                        e=i;\\n                    else\\n                        s=i;\\n            }\\n            if(s>=0&&e>=0){\\n                int c=0;\\n                for(int j=s;j<e;j++){\\n                    if(forts[j]==0)\\n                        c++;\\n                }\\n                s=e;\\n                i=s;\\n                e=-1;\\n                ans=Math.max(ans,c);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int s=-1,e=-1,ans=0;\\n        for(int i=0;i<forts.length;i++){\\n            if(forts[i]==1||forts[i]==-1){\\n                if(s==-1)\\n                    s=i;\\n                else\\n                    if(forts[s]==-forts[i])\\n                        e=i;\\n                    else\\n                        s=i;\\n            }\\n            if(s>=0&&e>=0){\\n                int c=0;\\n                for(int j=s;j<e;j++){\\n                    if(forts[j]==0)\\n                        c++;\\n                }\\n                s=e;\\n                i=s;\\n                e=-1;\\n                ans=Math.max(ans,c);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991845,
                "title": "c-two-pointers-100-beats",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int left = 0, right = forts.size()-1, leftCount = 0, rightCount = 0, result = 0;\\n        bool leftFlag = false, rightFlag = false;\\n\\n        auto countCaptured = [&forts = std::as_const(forts)] (int i, int &count, int &result, bool &flag) -> void {\\n            if(forts[i] == 1) count = 0, flag = true;\\n            else if(forts[i] == -1) result = std::max(result, count), flag = false;\\n            else if(forts[i] == 0 && flag) ++count;\\n        };\\n\\n        while(left < forts.size() && right >= 0)\\n        {\\n            countCaptured(left++, leftCount, result, leftFlag);\\n            countCaptured(right--, rightCount, result, rightFlag);\\n        }\\n\\n        while(left < forts.size()) countCaptured(left++, leftCount, result, leftFlag);\\n        while(right >= 0) countCaptured(right--, rightCount, result, rightFlag);\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int left = 0, right = forts.size()-1, leftCount = 0, rightCount = 0, result = 0;\\n        bool leftFlag = false, rightFlag = false;\\n\\n        auto countCaptured = [&forts = std::as_const(forts)] (int i, int &count, int &result, bool &flag) -> void {\\n            if(forts[i] == 1) count = 0, flag = true;\\n            else if(forts[i] == -1) result = std::max(result, count), flag = false;\\n            else if(forts[i] == 0 && flag) ++count;\\n        };\\n\\n        while(left < forts.size() && right >= 0)\\n        {\\n            countCaptured(left++, leftCount, result, leftFlag);\\n            countCaptured(right--, rightCount, result, rightFlag);\\n        }\\n\\n        while(left < forts.size()) countCaptured(left++, leftCount, result, leftFlag);\\n        while(right >= 0) countCaptured(right--, rightCount, result, rightFlag);\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989204,
                "title": "java-one-pass",
                "content": "```\\nclass Solution {\\n    public int captureForts(int[] f) {\\n        int i = 0;\\n        int max = 0;\\n        while (i < f.length) {\\n            if (f[i] != 0) {\\n                int t = f[i];\\n                int ans = 0;\\n                i++;\\n                while (i < f.length && f[i] == 0) {\\n                    ans++;\\n                    i++;\\n                }\\n                if (i < f.length && f[i] == -t) {\\n                    max = Math.max(max, ans);\\n                }\\n            } else {\\n                i++;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int captureForts(int[] f) {\\n        int i = 0;\\n        int max = 0;\\n        while (i < f.length) {\\n            if (f[i] != 0) {\\n                int t = f[i];\\n                int ans = 0;\\n                i++;\\n                while (i < f.length && f[i] == 0) {\\n                    ans++;\\n                    i++;\\n                }\\n                if (i < f.length && f[i] == -t) {\\n                    max = Math.max(max, ans);\\n                }\\n            } else {\\n                i++;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3932911,
                "title": "c-one-pass-beats-100-0ms",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int m = 0;\\n        int c = 0;\\n        int last = 0;\\n        for(int i = 0; i < forts.size(); ++i) {\\n            if(forts[i] != 0) {\\n                if(last == -forts[i]) {\\n                    m = max(m, c);\\n                }\\n                last = forts[i];\\n                c = 0;\\n            } else if (last != 0) {\\n                ++c;\\n            }\\n        }\\n\\n        return m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int m = 0;\\n        int c = 0;\\n        int last = 0;\\n        for(int i = 0; i < forts.size(); ++i) {\\n            if(forts[i] != 0) {\\n                if(last == -forts[i]) {\\n                    m = max(m, c);\\n                }\\n                last = forts[i];\\n                c = 0;\\n            } else if (last != 0) {\\n                ++c;\\n            }\\n        }\\n\\n        return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924508,
                "title": "o-n-one-pass-counter-of-largest-link",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe solution requires us to find the largest possible \\'0\\' links between a \\'-1\\' and a \\'1\\'. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can do a one pass while checking if the current position is part of a link, or if a link should be opened/closed.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        largest_link = 0\\n        current_link = 0\\n        from_fort = False\\n        from_space = False\\n        for fort in forts:\\n            if fort == 1: # @fort\\n                if from_space:\\n                    if largest_link < current_link:\\n                        largest_link = current_link\\n                    from_space = False\\n                current_link = 0\\n                from_fort = True\\n            if fort == -1: # @space\\n                if from_fort:\\n                    if largest_link < current_link:\\n                        largest_link = current_link\\n                    from_fort = False\\n                current_link = 0\\n                from_space = True\\n            if fort == 0 and (from_fort or from_space):\\n                current_link = current_link + 1\\n        return largest_link\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        largest_link = 0\\n        current_link = 0\\n        from_fort = False\\n        from_space = False\\n        for fort in forts:\\n            if fort == 1: # @fort\\n                if from_space:\\n                    if largest_link < current_link:\\n                        largest_link = current_link\\n                    from_space = False\\n                current_link = 0\\n                from_fort = True\\n            if fort == -1: # @space\\n                if from_fort:\\n                    if largest_link < current_link:\\n                        largest_link = current_link\\n                    from_fort = False\\n                current_link = 0\\n                from_space = True\\n            if fort == 0 and (from_fort or from_space):\\n                current_link = current_link + 1\\n        return largest_link\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920723,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxEnemyFort(vector<int>& forts){\\n        int max_captured=0, found=0, i=0, j=forts.size()-1, captured = 0;\\n        while(i <= j){\\n            if(forts[i]==1){\\n                found=1;\\n                captured = 0;\\n            }\\n            else if(found and !forts[i]) captured++;\\n            else if(found and forts[i]){\\n                if(max_captured < captured) max_captured = captured;\\n                captured = 0;\\n                found = 0;\\n            }\\n            i++;\\n        }\\n        return max_captured;\\n    }\\n\\n    void reversed(vector<int>& forts){\\n        int i=0, j=forts.size()-1;\\n        while(i<=j) swap(forts[i++], forts[j--]);\\n    }\\n\\n    int captureForts(vector<int>& forts) {\\n        int max_captured = maxEnemyFort(forts);\\n        reversed(forts);\\n        int new_max = maxEnemyFort(forts);\\n        if(new_max > max_captured) return new_max;\\n        return max_captured;\\n    }\\n};\\n```\\n# first solution\\n```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int max_captured=0;\\n        int left=0, right=0, i=0, j=forts.size()-1;\\n        int left_captured = 0, right_captured =0;\\n        while(i <= j){\\n            if(forts[i]==1){\\n                left=1;\\n                left_captured = 0;\\n            }\\n            else if(left and forts[i]==0) left_captured++;\\n            else if(left and forts[i]==-1){\\n                if(max_captured < left_captured) max_captured = left_captured;\\n                left_captured = 0;\\n                left = 0;\\n            }\\n            i++;\\n        }\\n        i=0;\\n        while(i <= j){\\n            if(forts[j]==1){\\n                right=1;\\n                right_captured=0;\\n            }\\n            else if(right and forts[j]==0) right_captured++;\\n            else if(right and forts[j]==-1){\\n                if(max_captured < right_captured) max_captured = right_captured;\\n                right_captured = 0;\\n                right = 0;\\n            }\\n            j--;\\n        }\\n        return max_captured;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxEnemyFort(vector<int>& forts){\\n        int max_captured=0, found=0, i=0, j=forts.size()-1, captured = 0;\\n        while(i <= j){\\n            if(forts[i]==1){\\n                found=1;\\n                captured = 0;\\n            }\\n            else if(found and !forts[i]) captured++;\\n            else if(found and forts[i]){\\n                if(max_captured < captured) max_captured = captured;\\n                captured = 0;\\n                found = 0;\\n            }\\n            i++;\\n        }\\n        return max_captured;\\n    }\\n\\n    void reversed(vector<int>& forts){\\n        int i=0, j=forts.size()-1;\\n        while(i<=j) swap(forts[i++], forts[j--]);\\n    }\\n\\n    int captureForts(vector<int>& forts) {\\n        int max_captured = maxEnemyFort(forts);\\n        reversed(forts);\\n        int new_max = maxEnemyFort(forts);\\n        if(new_max > max_captured) return new_max;\\n        return max_captured;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int max_captured=0;\\n        int left=0, right=0, i=0, j=forts.size()-1;\\n        int left_captured = 0, right_captured =0;\\n        while(i <= j){\\n            if(forts[i]==1){\\n                left=1;\\n                left_captured = 0;\\n            }\\n            else if(left and forts[i]==0) left_captured++;\\n            else if(left and forts[i]==-1){\\n                if(max_captured < left_captured) max_captured = left_captured;\\n                left_captured = 0;\\n                left = 0;\\n            }\\n            i++;\\n        }\\n        i=0;\\n        while(i <= j){\\n            if(forts[j]==1){\\n                right=1;\\n                right_captured=0;\\n            }\\n            else if(right and forts[j]==0) right_captured++;\\n            else if(right and forts[j]==-1){\\n                if(max_captured < right_captured) max_captured = right_captured;\\n                right_captured = 0;\\n                right = 0;\\n            }\\n            j--;\\n        }\\n        return max_captured;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3891247,
                "title": "c-solution-0ms-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint max_forts_captured(vector<int>& forts,int k){\\n    int i = k-1,j = k+1;\\n    int max1 = 0,max2 = 0;\\n    while(i>=0){\\n        if(forts[i] == -1 || forts[i] == 1){\\n             if(forts[i] == -1) max1 = abs(k-i)-1;\\n             break;\\n        }\\n        i--;\\n    }\\n    while(j < forts.size()){\\n        if(forts[j] == -1  || forts[j] == 1){\\n            if(forts[j] == -1) max2 = abs(j-k)-1;\\n            break;\\n        }\\n        j++;\\n    }\\n    return max(max1,max2);\\n}\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n      int max = 0;\\n      for(int i = 0; i < forts.size(); i++){\\n         if(forts[i] == 1){\\n             int k = max_forts_captured(forts,i);\\n             if(k > max){\\n                 max = k;\\n             }\\n         }\\n      } \\n      return max; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nint max_forts_captured(vector<int>& forts,int k){\\n    int i = k-1,j = k+1;\\n    int max1 = 0,max2 = 0;\\n    while(i>=0){\\n        if(forts[i] == -1 || forts[i] == 1){\\n             if(forts[i] == -1) max1 = abs(k-i)-1;\\n             break;\\n        }\\n        i--;\\n    }\\n    while(j < forts.size()){\\n        if(forts[j] == -1  || forts[j] == 1){\\n            if(forts[j] == -1) max2 = abs(j-k)-1;\\n            break;\\n        }\\n        j++;\\n    }\\n    return max(max1,max2);\\n}\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n      int max = 0;\\n      for(int i = 0; i < forts.size(); i++){\\n         if(forts[i] == 1){\\n             int k = max_forts_captured(forts,i);\\n             if(k > max){\\n                 max = k;\\n             }\\n         }\\n      } \\n      return max; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889336,
                "title": "top-solution-using-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int ans=0;\\n        int n=forts.size();\\n        for (int i=0; i<n; i++){\\n            if (forts[i]==1){\\n                i++;\\n                int curr=0;\\n                while (i<n && forts[i]==0){\\n                    curr++;\\n                    i++;\\n                }\\n                if (i<n && forts[i]==-1)ans= max(ans,curr);\\n                i--;\\n            }\\n            if (forts[i]==-1){\\n                i++;\\n                int curr=0;\\n                while (i<n && forts[i]==0){\\n                    curr++;\\n                    i++;\\n                }\\n                if (i<n && forts[i]==1)ans= max(ans,curr);\\n                i--;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int ans=0;\\n        int n=forts.size();\\n        for (int i=0; i<n; i++){\\n            if (forts[i]==1){\\n                i++;\\n                int curr=0;\\n                while (i<n && forts[i]==0){\\n                    curr++;\\n                    i++;\\n                }\\n                if (i<n && forts[i]==-1)ans= max(ans,curr);\\n                i--;\\n            }\\n            if (forts[i]==-1){\\n                i++;\\n                int curr=0;\\n                while (i<n && forts[i]==0){\\n                    curr++;\\n                    i++;\\n                }\\n                if (i<n && forts[i]==1)ans= max(ans,curr);\\n                i--;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880908,
                "title": "easy-solution-nnn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int captureForts(int[] f) {\\n        int maxleft = 0, maxright = -10000, cnt = -10000;\\n\\n        for (int i = 0; i < f.length; i++) {\\n            if (f[i] == 1) {\\n                cnt = 0;\\n            } else if (f[i] == 0) {\\n                cnt++;\\n                \\n            } else {\\n                maxleft = Math.max(cnt, maxleft); \\n                cnt = -10000;\\n            }\\n        }\\n        cnt = -10000;\\n        for (int i = f.length - 1; i >= 0; i--) {\\n            if (f[i] == 1) {\\n                cnt = 0;\\n            } else if (f[i] == 0) {\\n                cnt++;\\n                \\n            }else{\\n                maxright = Math.max(cnt, maxright); \\n                cnt = -10000;\\n            }\\n        }\\n\\n        return Math.max(maxleft, maxright);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int captureForts(int[] f) {\\n        int maxleft = 0, maxright = -10000, cnt = -10000;\\n\\n        for (int i = 0; i < f.length; i++) {\\n            if (f[i] == 1) {\\n                cnt = 0;\\n            } else if (f[i] == 0) {\\n                cnt++;\\n                \\n            } else {\\n                maxleft = Math.max(cnt, maxleft); \\n                cnt = -10000;\\n            }\\n        }\\n        cnt = -10000;\\n        for (int i = f.length - 1; i >= 0; i--) {\\n            if (f[i] == 1) {\\n                cnt = 0;\\n            } else if (f[i] == 0) {\\n                cnt++;\\n                \\n            }else{\\n                maxright = Math.max(cnt, maxright); \\n                cnt = -10000;\\n            }\\n        }\\n\\n        return Math.max(maxleft, maxright);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879686,
                "title": "java-0ms-beats-100-00",
                "content": "# Intuition & Approach\\n- 2-pointer strategy\\n- move left to right, looking for -1 0... 1 or 1 0... -1\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n\\n        // -1 no fort; 0 enemy fort; 1 friendly fort.\\n        // we can look for -1 0 0 0 0 0 0  1\\n        //              or  1 0 0 0 0 0 0 -1\\n\\n        final int ENEMY_FORT = 0;\\n\\n        int maxEnemyForts = 0;  // what we\\'ll return\\n\\n        for (int start = 0; start < forts.length; ++start) {\\n\\n            int curVal = forts[start];\\n\\n            if (curVal != ENEMY_FORT) {\\n                int end = start + 1;\\n                for ( ; end < forts.length; ++end) {\\n                    if (forts[end] != ENEMY_FORT) {\\n                        int curEnemyForts = end - start - 1;\\n                        if (curEnemyForts > 0) {  // there is at least one enemy fort\\n                            // now check for correct other end\\n                            if (forts[end] == -1 * curVal) {\\n                                maxEnemyForts = Math.max(maxEnemyForts, curEnemyForts);\\n                            }\\n                        }\\n                        break;\\n                    }\\n                }\\n                start = end - 1;\\n            }\\n        }\\n\\n        return maxEnemyForts;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n\\n        // -1 no fort; 0 enemy fort; 1 friendly fort.\\n        // we can look for -1 0 0 0 0 0 0  1\\n        //              or  1 0 0 0 0 0 0 -1\\n\\n        final int ENEMY_FORT = 0;\\n\\n        int maxEnemyForts = 0;  // what we\\'ll return\\n\\n        for (int start = 0; start < forts.length; ++start) {\\n\\n            int curVal = forts[start];\\n\\n            if (curVal != ENEMY_FORT) {\\n                int end = start + 1;\\n                for ( ; end < forts.length; ++end) {\\n                    if (forts[end] != ENEMY_FORT) {\\n                        int curEnemyForts = end - start - 1;\\n                        if (curEnemyForts > 0) {  // there is at least one enemy fort\\n                            // now check for correct other end\\n                            if (forts[end] == -1 * curVal) {\\n                                maxEnemyForts = Math.max(maxEnemyForts, curEnemyForts);\\n                            }\\n                        }\\n                        break;\\n                    }\\n                }\\n                start = end - 1;\\n            }\\n        }\\n\\n        return maxEnemyForts;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869447,
                "title": "go-two-pointers-time-complexity-o-n-and-space-complexity-o-1",
                "content": "# Intuition\\nThe main idea of the task is to find the value `1` in the array and from it to get to the value `-1`.\\nFor example: `[1,0,0,0,-1] ` or `[-1,0,0,0,1]`\\n\\nIt turns out that we are interested in the positions of two values, these are `-1` and `1`.\\nThe distance between these two values will be the amount to capture.\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nfunc captureForts(forts []int) int {\\n  maxCaptured := 0 \\n  prevFort := len(forts) - 1\\n\\n  for i := 0; i < len(forts); i++ {\\n    if forts[i] == 0 {\\n      continue\\n    }\\n\\n    if forts[i] != forts[prevFort] {\\n      captured := i - prevFort - 1\\n\\n      if captured > maxCaptured {\\n        maxCaptured = captured\\n      }\\n    } \\n\\n    prevFort = i\\n  }\\n\\n  return maxCaptured\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nfunc captureForts(forts []int) int {\\n  maxCaptured := 0 \\n  prevFort := len(forts) - 1\\n\\n  for i := 0; i < len(forts); i++ {\\n    if forts[i] == 0 {\\n      continue\\n    }\\n\\n    if forts[i] != forts[prevFort] {\\n      captured := i - prevFort - 1\\n\\n      if captured > maxCaptured {\\n        maxCaptured = captured\\n      }\\n    } \\n\\n    prevFort = i\\n  }\\n\\n  return maxCaptured\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3850805,
                "title": "swift-short-o-n-time-o-1-space-with-explanation",
                "content": "# Explanation\\nThis solution generates the result in one pass through the input array `forts`. \\n\\nThe idea is that we need only count forts after we see a `1` or a `-1`. We keep track of whether it was a `1` or `-1`.\\n\\nWhen `fort` is zero and `start` is non-zero we count the forts we see in `numForts`. In the code this is handle in the `case 0` clause of the `switch`.\\n\\nWhen we see a non-fort, that is `fort != 0`, we compare it to `start`. If `fort` has the opposite sign to `start` it means this would be a valid move for the army and we update `maxForts`. \\n\\n> **Note**\\n> If start is `1` and the fort value is `-1` it is the army moving forward through the array, and vice versa. Otherwise, it is an invalid move and we ignore the count.\\n\\nWe reset the `numForts` count when we see a non-fort, irrespective of whether the move is valid or not. \\n\\nThe non-fort logic is contained in the `default` clause of the `switch`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    func captureForts(_ forts: [Int]) -> Int {\\n        var start = 0, numForts = 0, maxForts = 0\\n        for fort in forts {\\n            switch fort {\\n            case 0:\\n                if start != 0 { numForts += 1}\\n            default:\\n                if start == -fort { maxForts = max(maxForts, numForts) }\\n                numForts = 0\\n                start = fort\\n            }\\n        }\\n        return maxForts\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func captureForts(_ forts: [Int]) -> Int {\\n        var start = 0, numForts = 0, maxForts = 0\\n        for fort in forts {\\n            switch fort {\\n            case 0:\\n                if start != 0 { numForts += 1}\\n            default:\\n                if start == -fort { maxForts = max(maxForts, numForts) }\\n                numForts = 0\\n                start = fort\\n            }\\n        }\\n        return maxForts\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835011,
                "title": "easy-java-solution-100-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int max=0;\\n        int count=0;\\n        int index=0;\\n        for(int i=0; i<forts.length; i++)\\n        {\\n            if(forts[0]==0)\\n            {\\n                while(i<forts.length-1&&forts[i]==0)\\n                {\\n                    i++;\\n                }\\n                index=i;\\n                break;\\n            }\\n        }\\n        int start=forts[index];\\n        for(int i=index; i<forts.length; i++)\\n        {\\n            if(forts[i]==1 || forts[i]==-1)\\n            {\\n                if((start==1 && forts[i]==-1)||(start==-1 && forts[i]==1))\\n                {\\n                     max=Integer.max(count,max);\\n                     start=forts[i];\\n                \\n\\n                }\\n               count=0;\\n            }\\n            else if(forts[i]==0)\\n            {\\n                count++;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int max=0;\\n        int count=0;\\n        int index=0;\\n        for(int i=0; i<forts.length; i++)\\n        {\\n            if(forts[0]==0)\\n            {\\n                while(i<forts.length-1&&forts[i]==0)\\n                {\\n                    i++;\\n                }\\n                index=i;\\n                break;\\n            }\\n        }\\n        int start=forts[index];\\n        for(int i=index; i<forts.length; i++)\\n        {\\n            if(forts[i]==1 || forts[i]==-1)\\n            {\\n                if((start==1 && forts[i]==-1)||(start==-1 && forts[i]==1))\\n                {\\n                     max=Integer.max(count,max);\\n                     start=forts[i];\\n                \\n\\n                }\\n               count=0;\\n            }\\n            else if(forts[i]==0)\\n            {\\n                count++;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811649,
                "title": "optimized-solution-using-just-1-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction captureForts(forts: number[]): number {\\n    let checkFromHere: (number | boolean)[] = [1, false];\\n    let allForts: number[] = [0];\\n    let countFort: number = 0;\\n    for(let i: number = 0; i < forts.length; i++){\\n        if(checkFromHere[1]){\\n            if(forts[i] === 0) countFort++;\\n            else{\\n                if(forts[i] === -checkFromHere[0]){\\n                    allForts.push(countFort);\\n                    checkFromHere[0] = forts[i];\\n                    countFort = 0;\\n                }\\n                else{\\n                    checkFromHere[0] = forts[i];\\n                    countFort = 0;\\n                }\\n            }\\n        }\\n        else{\\n            if(forts[i] !== 0){\\n                checkFromHere[0] = forts[i];\\n                checkFromHere[1] = true;\\n            }\\n        }\\n    }\\n    return Math.max(...allForts);\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction captureForts(forts: number[]): number {\\n    let checkFromHere: (number | boolean)[] = [1, false];\\n    let allForts: number[] = [0];\\n    let countFort: number = 0;\\n    for(let i: number = 0; i < forts.length; i++){\\n        if(checkFromHere[1]){\\n            if(forts[i] === 0) countFort++;\\n            else{\\n                if(forts[i] === -checkFromHere[0]){\\n                    allForts.push(countFort);\\n                    checkFromHere[0] = forts[i];\\n                    countFort = 0;\\n                }\\n                else{\\n                    checkFromHere[0] = forts[i];\\n                    countFort = 0;\\n                }\\n            }\\n        }\\n        else{\\n            if(forts[i] !== 0){\\n                checkFromHere[0] = forts[i];\\n                checkFromHere[1] = true;\\n            }\\n        }\\n    }\\n    return Math.max(...allForts);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3811644,
                "title": "optimized-solution-using-just-1-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction captureForts(forts: number[]): number {\\n    let checkFromHere: (number | boolean)[] = [1, false];\\n    let allForts: number[] = [0];\\n    let countFort: number = 0;\\n    for(let i: number = 0; i < forts.length; i++){\\n        if(checkFromHere[1]){\\n            if(forts[i] === 0) countFort++;\\n            else{\\n                if(forts[i] === -checkFromHere[0]){\\n                    allForts.push(countFort);\\n                    checkFromHere[0] = forts[i];\\n                    countFort = 0;\\n                }\\n                else{\\n                    checkFromHere[0] = forts[i];\\n                    countFort = 0;\\n                }\\n            }\\n        }\\n        else{\\n            checkFromHere[0] = forts[i];\\n            checkFromHere[1] = true;\\n        }\\n    }\\n    return Math.max(...allForts);\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction captureForts(forts: number[]): number {\\n    let checkFromHere: (number | boolean)[] = [1, false];\\n    let allForts: number[] = [0];\\n    let countFort: number = 0;\\n    for(let i: number = 0; i < forts.length; i++){\\n        if(checkFromHere[1]){\\n            if(forts[i] === 0) countFort++;\\n            else{\\n                if(forts[i] === -checkFromHere[0]){\\n                    allForts.push(countFort);\\n                    checkFromHere[0] = forts[i];\\n                    countFort = 0;\\n                }\\n                else{\\n                    checkFromHere[0] = forts[i];\\n                    countFort = 0;\\n                }\\n            }\\n        }\\n        else{\\n            checkFromHere[0] = forts[i];\\n            checkFromHere[1] = true;\\n        }\\n    }\\n    return Math.max(...allForts);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3800799,
                "title": "simple-kotlin-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    fun captureForts(forts: IntArray): Int {\\n        var departureFort = 0\\n        var currentCapturedForts = 0\\n        var maxCapturedForts = 0\\n\\n        for (fort in forts) {\\n            if (fort == 1 || fort == -1) {\\n                // Check if departureFort is different from the current fort (1 + (-1) = 0)\\n                if (departureFort + fort == 0)\\n                    maxCapturedForts = Math.max(maxCapturedForts, currentCapturedForts)\\n\\n                departureFort = fort\\n                currentCapturedForts = 0\\n            } else currentCapturedForts++\\n        }\\n\\n        return maxCapturedForts\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun captureForts(forts: IntArray): Int {\\n        var departureFort = 0\\n        var currentCapturedForts = 0\\n        var maxCapturedForts = 0\\n\\n        for (fort in forts) {\\n            if (fort == 1 || fort == -1) {\\n                // Check if departureFort is different from the current fort (1 + (-1) = 0)\\n                if (departureFort + fort == 0)\\n                    maxCapturedForts = Math.max(maxCapturedForts, currentCapturedForts)\\n\\n                departureFort = fort\\n                currentCapturedForts = 0\\n            } else currentCapturedForts++\\n        }\\n\\n        return maxCapturedForts\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789411,
                "title": "javascript-easy-solution-o-n-time-complexity-and-o-1-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} forts\\n * @return {number}\\n */\\nvar captureForts = function(forts) {\\n    let count = 0;\\n    let prev = [-1,-1]; // prev[0] denoting type of fort\\n                        // prev[1] denoting index of last non enemy fort\\n    for(let i=0; i<forts.length; i++) {\\n        if(forts[i] == 1 || forts[i] == -1) {\\n            if(prev[0] != forts[i] && prev[1] != -1) {\\n                count = Math.max(i-prev[1]-1, count);\\n            }\\n            prev[0] = forts[i];\\n            prev[1] = i;\\n        }\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} forts\\n * @return {number}\\n */\\nvar captureForts = function(forts) {\\n    let count = 0;\\n    let prev = [-1,-1]; // prev[0] denoting type of fort\\n                        // prev[1] denoting index of last non enemy fort\\n    for(let i=0; i<forts.length; i++) {\\n        if(forts[i] == 1 || forts[i] == -1) {\\n            if(prev[0] != forts[i] && prev[1] != -1) {\\n                count = Math.max(i-prev[1]-1, count);\\n            }\\n            prev[0] = forts[i];\\n            prev[1] = i;\\n        }\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3772515,
                "title": "100-0ms-easy-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int currentCount = 0;\\n        int maxCount = 0;\\n        boolean isOne = false;\\n        boolean isMinus = false;\\n\\n        for (int i : forts) {\\n            if ((isOne || isMinus) && i == 0) {     \\n                currentCount++;\\n            }\\n            if (i == -1 && isOne) {\\n                maxCount = Math.max(maxCount, currentCount);\\n                currentCount = 0;\\n                isOne = false;\\n                isMinus = true;\\n            }\\n            if (i == 1 && isMinus) {\\n                maxCount = Math.max(maxCount, currentCount);\\n                currentCount = 0;\\n                isOne = true;\\n                isMinus = false;\\n            }\\n            if ((isMinus && i == -1) || (isOne && i == 1)) {\\n                currentCount = 0;\\n            }\\n            if (i == 1) {\\n                isOne = true;\\n            }\\n            if (i == -1) {\\n                isMinus = true;\\n            }\\n        }\\n        return maxCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int currentCount = 0;\\n        int maxCount = 0;\\n        boolean isOne = false;\\n        boolean isMinus = false;\\n\\n        for (int i : forts) {\\n            if ((isOne || isMinus) && i == 0) {     \\n                currentCount++;\\n            }\\n            if (i == -1 && isOne) {\\n                maxCount = Math.max(maxCount, currentCount);\\n                currentCount = 0;\\n                isOne = false;\\n                isMinus = true;\\n            }\\n            if (i == 1 && isMinus) {\\n                maxCount = Math.max(maxCount, currentCount);\\n                currentCount = 0;\\n                isOne = true;\\n                isMinus = false;\\n            }\\n            if ((isMinus && i == -1) || (isOne && i == 1)) {\\n                currentCount = 0;\\n            }\\n            if (i == 1) {\\n                isOne = true;\\n            }\\n            if (i == -1) {\\n                isMinus = true;\\n            }\\n        }\\n        return maxCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768759,
                "title": "beats-90-in-runtime-python-solution",
                "content": "First traverse the list from start. Then reverse the array so that to know in which  movement enemy captures the best\\n\\nflag is used to only increment capture when it is True\\n\\nWe are calculating seperate maxs for the start as well as end\\nmaxs refer to the original maximum from the array\\nmaxs1 refer to the original maximum after it is reversed\\n\\nThen return the max out of maxs and maxs1\\n\\nIt seems bit complicated because i have done this according to my logic. But if u dry run it, it is simple \\n\\n\\n```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        capture=0\\n        maxs=0\\n        flag=False\\n        for i in forts:\\n            if i==1:\\n                flag=True\\n                capture=0\\n            elif i==-1:\\n                maxs=max(maxs,capture)\\n                capture=0\\n                flag=False\\n            else:\\n                if flag:\\n                 capture+=1\\n        forts[:]=forts[::-1]\\n        capture=0\\n        maxs1=0\\n        for i in forts:\\n            if i==1:\\n                flag=True\\n                capture=0\\n            elif i==-1:\\n                maxs1=max(maxs1,capture)\\n                capture=0\\n                flag=False\\n            else:\\n                if flag:\\n                 capture+=1\\n        return max(maxs,maxs1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        capture=0\\n        maxs=0\\n        flag=False\\n        for i in forts:\\n            if i==1:\\n                flag=True\\n                capture=0\\n            elif i==-1:\\n                maxs=max(maxs,capture)\\n                capture=0\\n                flag=False\\n            else:\\n                if flag:\\n                 capture+=1\\n        forts[:]=forts[::-1]\\n        capture=0\\n        maxs1=0\\n        for i in forts:\\n            if i==1:\\n                flag=True\\n                capture=0\\n            elif i==-1:\\n                maxs1=max(maxs1,capture)\\n                capture=0\\n                flag=False\\n            else:\\n                if flag:\\n                 capture+=1\\n        return max(maxs,maxs1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754272,
                "title": "100-faster-ans-super-easy-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int sum=0;\\n        int max =0;\\n        int count =0;\\n\\n        for(int i=0; i<forts.length; i++){\\n            if(forts[i] != 0){\\n                sum += forts[i];\\n                if(sum ==0)\\n                max = Math.max(max, count);\\n\\n                sum = forts[i];\\n                count =0;\\n            }\\n            else{\\n                if(sum != 0){\\n                    count++;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int sum=0;\\n        int max =0;\\n        int count =0;\\n\\n        for(int i=0; i<forts.length; i++){\\n            if(forts[i] != 0){\\n                sum += forts[i];\\n                if(sum ==0)\\n                max = Math.max(max, count);\\n\\n                sum = forts[i];\\n                count =0;\\n            }\\n            else{\\n                if(sum != 0){\\n                    count++;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745539,
                "title": "fast-c-single-pass-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int i=0;\\n        while(i<forts.size() && forts[i]==0){\\n            i++;\\n        }if(i>=forts.size())return 0;\\n        int currentElement=forts[i];\\n        int count=0;\\n        int ans=0;\\n        while(i<forts.size()){\\n            if(forts[i]==0){\\n                count++;\\n            }else{\\n                if(forts[i]==-currentElement){\\n                    ans=max(ans,count);count=0;\\n                    currentElement=-1*currentElement;\\n                }else{\\n                    count=0;\\n                }\\n            }i++;\\n        }return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int i=0;\\n        while(i<forts.size() && forts[i]==0){\\n            i++;\\n        }if(i>=forts.size())return 0;\\n        int currentElement=forts[i];\\n        int count=0;\\n        int ans=0;\\n        while(i<forts.size()){\\n            if(forts[i]==0){\\n                count++;\\n            }else{\\n                if(forts[i]==-currentElement){\\n                    ans=max(ans,count);count=0;\\n                    currentElement=-1*currentElement;\\n                }else{\\n                    count=0;\\n                }\\n            }i++;\\n        }return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745380,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n     int max=0;\\n     int j=0;\\n     for(int i=0;i<forts.length;i++)\\n      {\\n         if(forts[i]!=0)\\n         {\\n             if(forts[j]==-forts[i])\\n                 max=Math.max(max,i-j-1);\\n                 j=i;\\n         }\\n      }\\n     return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n     int max=0;\\n     int j=0;\\n     for(int i=0;i<forts.length;i++)\\n      {\\n         if(forts[i]!=0)\\n         {\\n             if(forts[j]==-forts[i])\\n                 max=Math.max(max,i-j-1);\\n                 j=i;\\n         }\\n      }\\n     return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734305,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} forts\\n * @return {number}\\n */\\nvar captureForts = function(forts) {\\n    let sum = 0;\\n    let max = 0; \\n    let count = 0;\\n    for(let i = 0 ; i < forts.length ; i++){\\n        if(forts[i] != 0){\\n            sum += forts[i]; // sum forts\\n            if(sum == 0) max = Math.max(max, count);\\n            sum = forts[i];\\n            count = 0;\\n        } else {\\n            if(sum != 0)\\n            count++;     \\n        }\\n    }   \\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} forts\\n * @return {number}\\n */\\nvar captureForts = function(forts) {\\n    let sum = 0;\\n    let max = 0; \\n    let count = 0;\\n    for(let i = 0 ; i < forts.length ; i++){\\n        if(forts[i] != 0){\\n            sum += forts[i]; // sum forts\\n            if(sum == 0) max = Math.max(max, count);\\n            sum = forts[i];\\n            count = 0;\\n        } else {\\n            if(sum != 0)\\n            count++;     \\n        }\\n    }   \\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3733761,
                "title": "java-easy-to-understand-simplest-o-1-no-collections-used",
                "content": "# Approach\\nJust traverse the array linearly. If you encounter zero then increase the length by one. If you encounter 1 or -1 for the first time then set `first` variable to it, and when you encounter 1 or -1 again check that current non-zero is opposite to what we store in `first` variable or not. If it\\'s opposie then it means we found a length of zeros between 1 and -1 and store it in max if it maximum otherwise reset the counter and reset the `first` variable.\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int first = forts[0];\\n        int max = 0;\\n        int zerolen = 0;\\n        for(int i=1; i<forts.length; i++) {\\n            if(forts[i]==0){\\n                zerolen++;\\n            } else {\\n                if(first + forts[i] == 0) {\\n                    if(zerolen>max) max=zerolen;\\n                }\\n                zerolen = 0;\\n                first = forts[i];\\n            }\\n            // else if(forts[i]==1) {\\n            //     if(first==-1) {\\n            //         if(zerolen>max) max=zerolen;\\n            //     } \\n            //     zerolen = 0;\\n            //     first = 1;\\n            // }\\n            // else {\\n            //     if(first==1) {\\n            //         if(zerolen>max) max=zerolen;\\n            //     }\\n            //     zerolen = 0;\\n            //     first = -1;\\n            // }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int first = forts[0];\\n        int max = 0;\\n        int zerolen = 0;\\n        for(int i=1; i<forts.length; i++) {\\n            if(forts[i]==0){\\n                zerolen++;\\n            } else {\\n                if(first + forts[i] == 0) {\\n                    if(zerolen>max) max=zerolen;\\n                }\\n                zerolen = 0;\\n                first = forts[i];\\n            }\\n            // else if(forts[i]==1) {\\n            //     if(first==-1) {\\n            //         if(zerolen>max) max=zerolen;\\n            //     } \\n            //     zerolen = 0;\\n            //     first = 1;\\n            // }\\n            // else {\\n            //     if(first==1) {\\n            //         if(zerolen>max) max=zerolen;\\n            //     }\\n            //     zerolen = 0;\\n            //     first = -1;\\n            // }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3733126,
                "title": "c-o-n-linear-traversal",
                "content": "# Intuition\\nStore the count of consecutive 0\\'s, and return the maximum count as per required condition.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n\\n        int s = 0, n = forts.size(), mx = INT_MAX, mn = INT_MIN;\\n        vector<int> v;\\n        bool flag = false;\\n\\n        for(int i=0;i<n;++i){\\n            if(forts[i]==1 || forts[i]==-1){\\n                if(s!=0) v.push_back(s);\\n                forts[i]==1 ? v.push_back(mx) : v.push_back(mn);\\n                s = 0;\\n            }\\n            else{\\n                s++;\\n                if(!flag) flag = true;\\n            }\\n        }\\n        if(s!=0) v.push_back(s);\\n\\n        if(!flag) return 0;\\n        \\n        int ans = 0;\\n        for(int i=1;i<v.size()-1;++i){\\n            if(v[i]!=mx && ((v[i-1]==mn && v[i+1]==mx) || (v[i+1]==mn && v[i-1]==mx))){   \\n                ans = max(ans, v[i]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n\\n        int s = 0, n = forts.size(), mx = INT_MAX, mn = INT_MIN;\\n        vector<int> v;\\n        bool flag = false;\\n\\n        for(int i=0;i<n;++i){\\n            if(forts[i]==1 || forts[i]==-1){\\n                if(s!=0) v.push_back(s);\\n                forts[i]==1 ? v.push_back(mx) : v.push_back(mn);\\n                s = 0;\\n            }\\n            else{\\n                s++;\\n                if(!flag) flag = true;\\n            }\\n        }\\n        if(s!=0) v.push_back(s);\\n\\n        if(!flag) return 0;\\n        \\n        int ans = 0;\\n        for(int i=1;i<v.size()-1;++i){\\n            if(v[i]!=mx && ((v[i-1]==mn && v[i+1]==mx) || (v[i+1]==mn && v[i-1]==mx))){   \\n                ans = max(ans, v[i]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3726289,
                "title": "important-question-implementation-in-c",
                "content": "```\\nclass Solution {\\npublic: \\n    int captureForts(vector<int>& forts) {\\n        int ans = 0; \\n        for (int i = 0, j = 0; i < forts.size(); i++) \\n            if (forts[i]!=0) {\\n                if (forts[j] == -forts[i])\\n                    ans = max(ans, i-j-1); \\n                j = i; \\n            }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    int captureForts(vector<int>& forts) {\\n        int ans = 0; \\n        for (int i = 0, j = 0; i < forts.size(); i++) \\n            if (forts[i]!=0) {\\n                if (forts[j] == -forts[i])\\n                    ans = max(ans, i-j-1); \\n                j = i; \\n            }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711666,
                "title": "java-solution-2-pointers",
                "content": "# Intuition\\n2 pointers search\\n\\n# Approach\\nIn the hypothesis we travel one army from a 1 to a -1, and check the numbers of 0 between them, but this can happen from left to right, or from right to left. Because of this, I chose 2 pointers, one that will calculate the asked sequences from index 0 to last index, and one pointer that will loop the other way around. Since i move the pointers at the same time, 1 by one, I use them in the same loop, to save time, to make the problem linear. The same cheks that i do for one index, I\\'m also doing for the other. I count one sequence if and only if it start with 1, and end with -1 (and count only the 0s between them).\\n\\n# Complexity\\n- Time complexity:\\nO(n) - linear  (I don\\'t know why, but beats only 10%)\\n\\n- Space complexity:\\nO(1)  - no extra memory (beats 92%)\\n\\n# Code\\n```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int totalCaptures = 0;\\n\\n        int left = 0, right = forts.length - 1;\\n\\n        // 1 sequence starts from 1 and ends in -1\\n        // if the sequence doesn\\'t end in -1, we don\\'t count it\\n\\n        int leftSeq = -1, rightSeq = -1;\\n        while (left < forts.length && right >= 0) {\\n            if (forts[left] == 1)\\n                leftSeq = 0;            // we are at the start of a POSSIBLE sequence\\n            if (forts[right] == 1)\\n                rightSeq = 0;           //we have to check both ways\\n\\n            if (forts[left] == 0) {     // enemy position\\n                if (leftSeq != -1)      // then we are in the middle of a sequence\\n                    leftSeq++;\\n            }\\n\\n            if (forts[right] == 0) {     // enemy position\\n                if (rightSeq != -1)      // then we are in the middle of a sequence\\n                    rightSeq++;\\n            }\\n\\n            if (forts[left] == -1 && leftSeq != -1)       //  this is the end of a sequence (a \\'good\\' army travel)\\n            {\\n                totalCaptures = Math.max(totalCaptures, leftSeq);\\n                leftSeq = -1;            // we reset the count, and start it again at the next friendly fort (aka 1)\\n            }\\n\\n            if (forts[right] == -1 && rightSeq != -1) {\\n                totalCaptures = Math.max(totalCaptures, rightSeq);\\n                rightSeq = -1;\\n            }\\n\\n            left++;\\n            right--;\\n        }\\n\\n        return totalCaptures;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int totalCaptures = 0;\\n\\n        int left = 0, right = forts.length - 1;\\n\\n        // 1 sequence starts from 1 and ends in -1\\n        // if the sequence doesn\\'t end in -1, we don\\'t count it\\n\\n        int leftSeq = -1, rightSeq = -1;\\n        while (left < forts.length && right >= 0) {\\n            if (forts[left] == 1)\\n                leftSeq = 0;            // we are at the start of a POSSIBLE sequence\\n            if (forts[right] == 1)\\n                rightSeq = 0;           //we have to check both ways\\n\\n            if (forts[left] == 0) {     // enemy position\\n                if (leftSeq != -1)      // then we are in the middle of a sequence\\n                    leftSeq++;\\n            }\\n\\n            if (forts[right] == 0) {     // enemy position\\n                if (rightSeq != -1)      // then we are in the middle of a sequence\\n                    rightSeq++;\\n            }\\n\\n            if (forts[left] == -1 && leftSeq != -1)       //  this is the end of a sequence (a \\'good\\' army travel)\\n            {\\n                totalCaptures = Math.max(totalCaptures, leftSeq);\\n                leftSeq = -1;            // we reset the count, and start it again at the next friendly fort (aka 1)\\n            }\\n\\n            if (forts[right] == -1 && rightSeq != -1) {\\n                totalCaptures = Math.max(totalCaptures, rightSeq);\\n                rightSeq = -1;\\n            }\\n\\n            left++;\\n            right--;\\n        }\\n\\n        return totalCaptures;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710283,
                "title": "simple-js-ts-solution-checking-for-sequence-of-0-s",
                "content": "Whenever a 1 is encountered, start checking for zero\\'s and keep a count of them. Do this going both directions, so once with the supplied array `forts` and then calling `Array.prototype.reverse()` on that and comparing the max result of the two.\\n\\n# Code\\n```\\nconst captureForts = (forts: number[]): number => {\\n\\n    const checkForts = (fortArray: number[]): number => {\\n        \\n        let maxForts = 0;\\n\\n        // move forward in the forts and capture the max sequence of\\n        // zero\\'s that exist between a 1 and -1.\\n        for(let i = 0; i < forts.length; i++) {\\n            if(forts[i] === 1) {\\n                let placeholder = i;\\n                let fortsFound = 0;\\n                i++;\\n                while(forts[i] === 0) {\\n                    fortsFound++;\\n                    i++;\\n                }\\n                if(forts[i] === -1) {\\n                    maxForts = Math.max(maxForts, fortsFound);\\n                }\\n                // go back to our placeholder\\n                i = placeholder;\\n            }\\n        }\\n\\n        return maxForts;\\n    };\\n\\n    // need to check the array going both directions so just\\n    // pass it in directly as-is and then reverse it before passing it in\\n    return Math.max(...[checkForts(forts), checkForts(forts.reverse())])\\n    \\n};\\n```\\nSee more `TypeScript`/`JavaScript` (and other language) LeetCode solutions at https://github.com/jasonmauss/LeetCode",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nconst captureForts = (forts: number[]): number => {\\n\\n    const checkForts = (fortArray: number[]): number => {\\n        \\n        let maxForts = 0;\\n\\n        // move forward in the forts and capture the max sequence of\\n        // zero\\'s that exist between a 1 and -1.\\n        for(let i = 0; i < forts.length; i++) {\\n            if(forts[i] === 1) {\\n                let placeholder = i;\\n                let fortsFound = 0;\\n                i++;\\n                while(forts[i] === 0) {\\n                    fortsFound++;\\n                    i++;\\n                }\\n                if(forts[i] === -1) {\\n                    maxForts = Math.max(maxForts, fortsFound);\\n                }\\n                // go back to our placeholder\\n                i = placeholder;\\n            }\\n        }\\n\\n        return maxForts;\\n    };\\n\\n    // need to check the array going both directions so just\\n    // pass it in directly as-is and then reverse it before passing it in\\n    return Math.max(...[checkForts(forts), checkForts(forts.reverse())])\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3688158,
                "title": "one-pass-solution-with-easy-explanation-100-beats",
                "content": "# **100 % Beats, 1ms**\\n# Intuition\\nWe just have to find `max` of no.of zeros between every -1 and 1 as well as 1 and -1.\\n\\n# Approach\\n- We are having a `max` variable which will hold the max no of zeros after complete traversal.\\n- We have a `start` boolean which will say that we have ***encountered an -1 or 1 before coming to current position***.(simply we have started counting zeros..)\\n- Similarly we are having `stval`(start value), stores whether we started with -1 or 1...it is used to stop at end of opposite of `stval`.\\n  i.e. if `stval=1` when we encounter -1,have to update `max`, countofzeros(`c`)\\n     else if `stval =-1` when we encounter 1 , update `max` and `c`\\n- If we have not started(start =false), and then we encounterd 1 or -1 then we have to start the count zeros until we reach the opposite.\\n- We have *started already* and *encountered zero* means we count that one\\n-  Case when we started suppose with `stval = 1 `and while passing , we have came by **1 again** before the opposite(-1), we have to make count `c` to 0 as they are invalid forts (similarly incase of `stval = -1`)\\n# Complexity\\n- Time complexity:$$O(n)$$ \\n\\n- Space complexity:$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int max  = 0;boolean start = false;int c =0;int stval=2;\\n       for(int i : forts)\\n       {\\n           if(!start && (i==1 || i== -1)){\\n                start = true;\\n                stval = i;\\n           }\\n          else if(start && i==0) c++;\\n          else if(start && i== -1*stval)//reached opposite gather zeros\\n           {\\n               max  = Math.max(max,c);\\n               stval = i;//new start has to be done\\n               c =0;//renew the count\\n           }\\n           else if(start && i== stval) c=0;\\n       }\\n       return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int max  = 0;boolean start = false;int c =0;int stval=2;\\n       for(int i : forts)\\n       {\\n           if(!start && (i==1 || i== -1)){\\n                start = true;\\n                stval = i;\\n           }\\n          else if(start && i==0) c++;\\n          else if(start && i== -1*stval)//reached opposite gather zeros\\n           {\\n               max  = Math.max(max,c);\\n               stval = i;//new start has to be done\\n               c =0;//renew the count\\n           }\\n           else if(start && i== stval) c=0;\\n       }\\n       return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683001,
                "title": "java-code-explained-in-code-itself-1000-beginner-friendly-upvote-if-it-s-helpful",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n![upvote.png](https://assets.leetcode.com/users/images/bd1bc432-37da-4d5b-96b8-838271114baf_1687741291.7757037.png)\\n\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n       // int count=0;\\n       int ans=0;\\n      int n=forts.length;\\n      for(int i=0;i<n;i++){ // got the current position of my index\\n          if(forts[i]==1){\\n              int count=0;\\n              // moving to left part of current position \\n              for(int j=i-1;j>=0;j--){\\n                  if(forts[j]==0){ // if moving to left found 0 so increase the count variable\\n                      count++;\\n                  } else if(forts[j]==-1){ // as soon as we encounter the -1 empty fort store the count value to ans and break coz we dont want to search now\\n                      ans=Math.max(ans,count);\\n                      break;\\n                      \\n                  } else{ // this is a condition where the next index just before current position is -1 which means no captured forts\\n                      break;\\n                  }\\n              }\\n              count=0; \\n              for(int j=i+1;j<n;j++){ // same searching for right part from current position of index doing same for right part\\n                   if(forts[j]==0){\\n                      count++;\\n                  } else if(forts[j]==-1){\\n                      ans=Math.max(ans,count); // here we took the max of left and right count variables\\n                      break;\\n                      \\n                  } else{\\n                      break;\\n                  }\\n              }\\n\\n\\n          }\\n      }\\n      return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n       // int count=0;\\n       int ans=0;\\n      int n=forts.length;\\n      for(int i=0;i<n;i++){ // got the current position of my index\\n          if(forts[i]==1){\\n              int count=0;\\n              // moving to left part of current position \\n              for(int j=i-1;j>=0;j--){\\n                  if(forts[j]==0){ // if moving to left found 0 so increase the count variable\\n                      count++;\\n                  } else if(forts[j]==-1){ // as soon as we encounter the -1 empty fort store the count value to ans and break coz we dont want to search now\\n                      ans=Math.max(ans,count);\\n                      break;\\n                      \\n                  } else{ // this is a condition where the next index just before current position is -1 which means no captured forts\\n                      break;\\n                  }\\n              }\\n              count=0; \\n              for(int j=i+1;j<n;j++){ // same searching for right part from current position of index doing same for right part\\n                   if(forts[j]==0){\\n                      count++;\\n                  } else if(forts[j]==-1){\\n                      ans=Math.max(ans,count); // here we took the max of left and right count variables\\n                      break;\\n                      \\n                  } else{\\n                      break;\\n                  }\\n              }\\n\\n\\n          }\\n      }\\n      return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651833,
                "title": "very-easy-jebasraja",
                "content": "# Intuition:KARUNYA UNIVERSITY:ACCENTURE\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int captureForts(int[] forts) \\n    {\\n        \\n        int previousone=0;\\nint previousminusone=0;\\nint zero=0;\\nint finalanswer=0;\\n\\nfor (int i = 0; i < forts.length; i++) \\n{\\n   \\n  if (forts[i]==1) \\n  {   \\n      if (previousminusone==-1) \\n      {\\n        if (zero>finalanswer) \\n        {\\n            finalanswer=zero;  \\n        }\\n      } \\n      previousone=1;\\n      previousminusone=0;\\n      zero=0;\\n  }\\n  \\n  else if (forts[i]==-1) \\n  { \\n    if (previousone==1) \\n    {\\n      if (zero>finalanswer) \\n      {\\n          finalanswer=zero;\\n      }  \\n    }    \\n    previousminusone=-1;\\n    previousone=0;\\n    zero=0;\\n  }\\n\\n  else\\n  {\\n    if (previousone==1) \\n    {\\n         zero++;\\n    }\\n    else if (previousminusone==-1) \\n    {\\n      zero++;\\n    } \\n    \\n  }\\n   \\n\\n}\\n\\n//System.out.println(finalanswer);\\n\\nreturn finalanswer;\\n\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int captureForts(int[] forts) \\n    {\\n        \\n        int previousone=0;\\nint previousminusone=0;\\nint zero=0;\\nint finalanswer=0;\\n\\nfor (int i = 0; i < forts.length; i++) \\n{\\n   \\n  if (forts[i]==1) \\n  {   \\n      if (previousminusone==-1) \\n      {\\n        if (zero>finalanswer) \\n        {\\n            finalanswer=zero;  \\n        }\\n      } \\n      previousone=1;\\n      previousminusone=0;\\n      zero=0;\\n  }\\n  \\n  else if (forts[i]==-1) \\n  { \\n    if (previousone==1) \\n    {\\n      if (zero>finalanswer) \\n      {\\n          finalanswer=zero;\\n      }  \\n    }    \\n    previousminusone=-1;\\n    previousone=0;\\n    zero=0;\\n  }\\n\\n  else\\n  {\\n    if (previousone==1) \\n    {\\n         zero++;\\n    }\\n    else if (previousminusone==-1) \\n    {\\n      zero++;\\n    } \\n    \\n  }\\n   \\n\\n}\\n\\n//System.out.println(finalanswer);\\n\\nreturn finalanswer;\\n\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642442,
                "title": "simple-solution-java",
                "content": "# Code\\n```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int num = forts.length;\\n        int left = 0;\\n        int right = 0;\\n        int lastFound = 0;\\n        int max = 0;\\n\\n        while (right < num)\\n        {\\n            if (forts[right] != 0)\\n            {\\n                if (lastFound !=0 && lastFound != forts[right])\\n                {\\n                    max = Math.max(max, right-left-1);\\n                }\\n                lastFound = forts[right];\\n                left = right;\\n            }\\n            right++;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int num = forts.length;\\n        int left = 0;\\n        int right = 0;\\n        int lastFound = 0;\\n        int max = 0;\\n\\n        while (right < num)\\n        {\\n            if (forts[right] != 0)\\n            {\\n                if (lastFound !=0 && lastFound != forts[right])\\n                {\\n                    max = Math.max(max, right-left-1);\\n                }\\n                lastFound = forts[right];\\n                left = right;\\n            }\\n            right++;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638689,
                "title": "c-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    private const int emptySpot = 0;\\n    private const int enemyFort = -1;\\n    private const int myFort = 1; \\n    \\n    public int CaptureForts(int[] forts) {\\n        int maxCaptures = 0, noOfEmptySpots = 0, prev = 0;\\n        for(int i = 0; i < forts.Length; i++) {\\n            if(forts[i] == emptySpot) {\\n                noOfEmptySpots++;\\n                continue;\\n            } \\n            if(prev + forts[i] == 0) {\\n                maxCaptures = Math.Max(maxCaptures, noOfEmptySpots);\\n            }\\n          \\n            prev = forts[i];\\n            noOfEmptySpots = 0;\\n        }\\n\\n        return maxCaptures;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    private const int emptySpot = 0;\\n    private const int enemyFort = -1;\\n    private const int myFort = 1; \\n    \\n    public int CaptureForts(int[] forts) {\\n        int maxCaptures = 0, noOfEmptySpots = 0, prev = 0;\\n        for(int i = 0; i < forts.Length; i++) {\\n            if(forts[i] == emptySpot) {\\n                noOfEmptySpots++;\\n                continue;\\n            } \\n            if(prev + forts[i] == 0) {\\n                maxCaptures = Math.Max(maxCaptures, noOfEmptySpots);\\n            }\\n          \\n            prev = forts[i];\\n            noOfEmptySpots = 0;\\n        }\\n\\n        return maxCaptures;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3635788,
                "title": "easiest-java-solution-two-pointer",
                "content": "# Complexity -\\n- ## Runtime : O(n)\\n- ## Spacetime : O(1) \\n\\n# Code\\n```\\nclass Solution {\\n    public static int captureForts(int[] forts) {\\n        int MaxLength = Integer.MIN_VALUE ;\\n        int i = GetOnePos(forts) ;\\n        if(i != -1) {\\n            int j = i + 1;\\n            while (j < forts.length) {\\n                if (forts[j] == -forts[i]) {\\n                    MaxLength = Math.max(MaxLength, j - i - 1);\\n                    i = j;\\n                }\\n                else if(forts[j] == forts[i])\\n                    i = j ;\\n                j++;\\n            }\\n        }\\n        return (MaxLength == Integer.MIN_VALUE) ? 0 : MaxLength ;\\n    }\\n    private static int GetOnePos(int[] forts){\\n        for (int i = 0 ; i < forts.length ; i ++){\\n            if(forts[i] == 1 || forts[i] == -1)\\n                return i ;\\n        }\\n        return -1 ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public static int captureForts(int[] forts) {\\n        int MaxLength = Integer.MIN_VALUE ;\\n        int i = GetOnePos(forts) ;\\n        if(i != -1) {\\n            int j = i + 1;\\n            while (j < forts.length) {\\n                if (forts[j] == -forts[i]) {\\n                    MaxLength = Math.max(MaxLength, j - i - 1);\\n                    i = j;\\n                }\\n                else if(forts[j] == forts[i])\\n                    i = j ;\\n                j++;\\n            }\\n        }\\n        return (MaxLength == Integer.MIN_VALUE) ? 0 : MaxLength ;\\n    }\\n    private static int GetOnePos(int[] forts){\\n        for (int i = 0 ; i < forts.length ; i ++){\\n            if(forts[i] == 1 || forts[i] == -1)\\n                return i ;\\n        }\\n        return -1 ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619740,
                "title": "trivial-c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        auto result = 0, counter = 0, mode = 0;\\n        for (const auto& fort : forts)\\n            if (fort != 0) {\\n                if (mode) {\\n                    if (mode != fort)\\n                        result = max(result, counter);\\n                    counter = 0;\\n                }\\n                mode = fort;\\n            } else if (mode) ++counter;\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        auto result = 0, counter = 0, mode = 0;\\n        for (const auto& fort : forts)\\n            if (fort != 0) {\\n                if (mode) {\\n                    if (mode != fort)\\n                        result = max(result, counter);\\n                    counter = 0;\\n                }\\n                mode = fort;\\n            } else if (mode) ++counter;\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589666,
                "title": "java-simple-o-n-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int max = 0;\\n        int count = -1;\\n        for (int i=0; i<forts.length; i++) {\\n            if (count == -1 && forts[i] == 1) count = 0;\\n            else if (count >= 0 && forts[i] == 0) count++;\\n            else if (count >= 0 && forts[i] == 1) {\\n                i--;\\n                count = -1;\\n            }\\n            else if (forts[i] == -1) {\\n                if (count > 0) max = Math.max(max, count);\\n                count = -1;\\n            }\\n        }\\n\\n        count = -1;\\n        for (int i=forts.length-1; i>=0; i--) {\\n            if (count == -1 && forts[i] == 1) count = 0;\\n            else if (count >= 0 && forts[i] == 0) count++;\\n            else if (count >= 0 && forts[i] == 1) {\\n                i++;\\n                count = -1;\\n            }\\n            else if (forts[i] == -1) {\\n                if (count > 0) max = Math.max(max, count);\\n                count = -1;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int max = 0;\\n        int count = -1;\\n        for (int i=0; i<forts.length; i++) {\\n            if (count == -1 && forts[i] == 1) count = 0;\\n            else if (count >= 0 && forts[i] == 0) count++;\\n            else if (count >= 0 && forts[i] == 1) {\\n                i--;\\n                count = -1;\\n            }\\n            else if (forts[i] == -1) {\\n                if (count > 0) max = Math.max(max, count);\\n                count = -1;\\n            }\\n        }\\n\\n        count = -1;\\n        for (int i=forts.length-1; i>=0; i--) {\\n            if (count == -1 && forts[i] == 1) count = 0;\\n            else if (count >= 0 && forts[i] == 0) count++;\\n            else if (count >= 0 && forts[i] == 1) {\\n                i++;\\n                count = -1;\\n            }\\n            else if (forts[i] == -1) {\\n                if (count > 0) max = Math.max(max, count);\\n                count = -1;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555615,
                "title": "simple",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int result = 0, x = 0; \\n        for (int j = 0; j < forts.size(); j++) {\\n            if (forts[j]==1 || forts[j]==-1) {\\n                if (forts[x] == -forts[j]) result = max(result, j - x - 1); \\n                x = j; \\n            }\\n        }\\n        return result; \\n    }\\n};\\n```\\nUP vote!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int result = 0, x = 0; \\n        for (int j = 0; j < forts.size(); j++) {\\n            if (forts[j]==1 || forts[j]==-1) {\\n                if (forts[x] == -forts[j]) result = max(result, j - x - 1); \\n                x = j; \\n            }\\n        }\\n        return result; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3533032,
                "title": "python-sliding-window-o-n",
                "content": "Every time you see `-1` or `1` you start counting `0` from scratch.\\nEvery time you end up in the case when `[start] in (-1, 1) and [end] in (-1,1) and [start] != [end]` (e.g. `-1 ...1` or `1 ... -1`) you find max number of `0` between the previous two.\\n\\nThis is shrinking `sliding window`/`2 pointer`.\\n`O(N)` time\\n`O(1)` space\\n\\nBeginner friendly version:\\n```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        max_len = 0\\n        start = 0\\n        for end in range(len(forts)):\\n            if forts[end] != 0 and forts[start] != 0 and forts[start] != forts[end]:\\n                max_len = max(max_len, end - start - 1)\\n            if forts[end] != 0:\\n                start = end\\n        return max_len\\n```\\nPy specific tricks:\\n```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        max_len = 0\\n        start = 0\\n        for end in range(len(forts)):\\n            if forts[end]:\\n                if forts[start] == -forts[end]:\\n                    max_len = max(max_len, end - start - 1)\\n                start = end\\n        return max_len\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        max_len = 0\\n        start = 0\\n        for end in range(len(forts)):\\n            if forts[end] != 0 and forts[start] != 0 and forts[start] != forts[end]:\\n                max_len = max(max_len, end - start - 1)\\n            if forts[end] != 0:\\n                start = end\\n        return max_len\\n```\n```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        max_len = 0\\n        start = 0\\n        for end in range(len(forts)):\\n            if forts[end]:\\n                if forts[start] == -forts[end]:\\n                    max_len = max(max_len, end - start - 1)\\n                start = end\\n        return max_len\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531105,
                "title": "java-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int max = 0;\\n        \\n        int i = 0;\\n        int j = forts.length - 1;\\n        \\n        while(i < forts.length && forts[i] == 0) {\\n            i++;\\n        }\\n        \\n        if(i >= forts.length - 1) {\\n            return 0;\\n        }\\n        \\n        while(j >= 0 && forts[j] == 0) {\\n            j--;\\n        }\\n        \\n        int n = forts[i];\\n        int countEnemyForts = 0;\\n        i++;\\n        while (i <= j) {\\n            if(forts[i] == 0) {\\n                countEnemyForts++;\\n            } else if(forts[i] == -n) {\\n                max = Math.max(max, countEnemyForts);\\n                countEnemyForts = 0;\\n                n = -n;\\n            } else {\\n                countEnemyForts = 0;\\n            }\\n            i++;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int max = 0;\\n        \\n        int i = 0;\\n        int j = forts.length - 1;\\n        \\n        while(i < forts.length && forts[i] == 0) {\\n            i++;\\n        }\\n        \\n        if(i >= forts.length - 1) {\\n            return 0;\\n        }\\n        \\n        while(j >= 0 && forts[j] == 0) {\\n            j--;\\n        }\\n        \\n        int n = forts[i];\\n        int countEnemyForts = 0;\\n        i++;\\n        while (i <= j) {\\n            if(forts[i] == 0) {\\n                countEnemyForts++;\\n            } else if(forts[i] == -n) {\\n                max = Math.max(max, countEnemyForts);\\n                countEnemyForts = 0;\\n                n = -n;\\n            } else {\\n                countEnemyForts = 0;\\n            }\\n            i++;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516539,
                "title": "easy-solution-explanation-beats-100-0ms-c-c",
                "content": "# Approach\\nJUST count the number of 0\\'s between -1 and 1\\nand return the maximum sequence count;\\n\\n# Complexity\\n- Time complexity:\\n**O(n)**\\n\\n- Space complexity:\\n**O(1)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int startflag=0,count=0,maxcount=0;\\n        for(int x:forts){\\n            if(abs(startflag)){\\n                if(x==1){\\n                    if(startflag==1){\\n                        count=0;\\n                        continue;\\n                    }\\n                    else if(startflag==-1){\\n                        if(count>maxcount){ \\n                            maxcount=count;\\n                            }\\n                        count=0;\\n                        startflag=1;\\n                    }\\n                }\\n                else if(x==-1){\\n                    if(startflag==-1){\\n                        count=0;\\n                        continue;\\n                    }\\n                    else if(startflag==1){\\n                        if(count>maxcount){ \\n                            maxcount=count;\\n                        }\\n                        count=0;\\n                        startflag=-1;\\n                    }\\n                }\\n                else{\\n                    count++;\\n                }\\n            }\\n            else if(abs(x)){\\n                startflag=x;\\n            }\\n        }\\n        return maxcount;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int startflag=0,count=0,maxcount=0;\\n        for(int x:forts){\\n            if(abs(startflag)){\\n                if(x==1){\\n                    if(startflag==1){\\n                        count=0;\\n                        continue;\\n                    }\\n                    else if(startflag==-1){\\n                        if(count>maxcount){ \\n                            maxcount=count;\\n                            }\\n                        count=0;\\n                        startflag=1;\\n                    }\\n                }\\n                else if(x==-1){\\n                    if(startflag==-1){\\n                        count=0;\\n                        continue;\\n                    }\\n                    else if(startflag==1){\\n                        if(count>maxcount){ \\n                            maxcount=count;\\n                        }\\n                        count=0;\\n                        startflag=-1;\\n                    }\\n                }\\n                else{\\n                    count++;\\n                }\\n            }\\n            else if(abs(x)){\\n                startflag=x;\\n            }\\n        }\\n        return maxcount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507584,
                "title": "java-simple-solution-no-two-pointers-counting",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public int captureForts(int[] forts) {\\n        int prev = -2;\\n        int maxCapturedForts = 0;\\n        int currentCapturedForts = 0;\\n        for (int fort : forts) {\\n            if ((fort == 1 || fort == -1) && prev == fort) {\\n                currentCapturedForts = 0;\\n            } else if ((fort == 1 || fort == -1) && prev != -2) {\\n                maxCapturedForts = Math.max(maxCapturedForts, currentCapturedForts);\\n                currentCapturedForts = 0;\\n                prev = fort;\\n            } else if (fort == 0) {\\n                currentCapturedForts++;\\n            } else {\\n                prev = fort;\\n                currentCapturedForts = 0;\\n            }\\n        }\\n\\n        return maxCapturedForts;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int captureForts(int[] forts) {\\n        int prev = -2;\\n        int maxCapturedForts = 0;\\n        int currentCapturedForts = 0;\\n        for (int fort : forts) {\\n            if ((fort == 1 || fort == -1) && prev == fort) {\\n                currentCapturedForts = 0;\\n            } else if ((fort == 1 || fort == -1) && prev != -2) {\\n                maxCapturedForts = Math.max(maxCapturedForts, currentCapturedForts);\\n                currentCapturedForts = 0;\\n                prev = fort;\\n            } else if (fort == 0) {\\n                currentCapturedForts++;\\n            } else {\\n                prev = fort;\\n                currentCapturedForts = 0;\\n            }\\n        }\\n\\n        return maxCapturedForts;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495475,
                "title": "c-left-and-right-pointer-one-pass-o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int n = forts.size();\\n        int left=-5,right=-5,cnt=0,maxi=0;\\n        for(int i=0; i<n; i++){\\n            if(left==-5 && (forts[i]==1 || forts[i]==-1)){\\n                left=i;\\n            }\\n            else if(forts[i]==0){\\n                cnt++;\\n                continue;\\n            }\\n            if(forts[i]!=0 && (forts[left] == forts[i])){\\n                left=i;\\n            }\\n            if(forts[i]!=0 && (forts[left] != forts[i])){\\n                right=i;\\n                if(cnt>0)\\n                    maxi = max(maxi, right-left-1);\\n                left=i;\\n                cnt=0;\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int n = forts.size();\\n        int left=-5,right=-5,cnt=0,maxi=0;\\n        for(int i=0; i<n; i++){\\n            if(left==-5 && (forts[i]==1 || forts[i]==-1)){\\n                left=i;\\n            }\\n            else if(forts[i]==0){\\n                cnt++;\\n                continue;\\n            }\\n            if(forts[i]!=0 && (forts[left] == forts[i])){\\n                left=i;\\n            }\\n            if(forts[i]!=0 && (forts[left] != forts[i])){\\n                right=i;\\n                if(cnt>0)\\n                    maxi = max(maxi, right-left-1);\\n                left=i;\\n                cnt=0;\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486032,
                "title": "easy-to-understand-java",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        \\n        int indexOfMyCommand = 0;\\n        int indexOfEnemy = 0;\\n        int out = 0;\\n       \\n        boolean ex1 = false;\\n        boolean ex2 = false;\\n         \\n        for(int i =0; i<forts.length; i++){\\n            if(forts[i]==1){\\n                indexOfMyCommand = i;\\n                ex1 = true; \\n            }            \\n            if(forts[i]== -1){\\n                indexOfEnemy = i;\\n                ex2 = true;\\n            }\\n            if(ex1 && ex2){\\n                out = Math.max(out,Math.abs(indexOfMyCommand - indexOfEnemy)-1);\\n                ex1= false;\\n                ex2 = false;\\n                i--;\\n            }   \\n        }\\n        return out;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        \\n        int indexOfMyCommand = 0;\\n        int indexOfEnemy = 0;\\n        int out = 0;\\n       \\n        boolean ex1 = false;\\n        boolean ex2 = false;\\n         \\n        for(int i =0; i<forts.length; i++){\\n            if(forts[i]==1){\\n                indexOfMyCommand = i;\\n                ex1 = true; \\n            }            \\n            if(forts[i]== -1){\\n                indexOfEnemy = i;\\n                ex2 = true;\\n            }\\n            if(ex1 && ex2){\\n                out = Math.max(out,Math.abs(indexOfMyCommand - indexOfEnemy)-1);\\n                ex1= false;\\n                ex2 = false;\\n                i--;\\n            }   \\n        }\\n        return out;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3482919,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int sol = 0; int j = 0;\\n        for(int i = 0; i < forts.size(); i++){\\n            if(forts[i]==1||forts[i]==-1){\\n                if(forts[i]== -forts[j])sol = max(sol,i-j-1);\\n                j = i;\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int sol = 0; int j = 0;\\n        for(int i = 0; i < forts.size(); i++){\\n            if(forts[i]==1||forts[i]==-1){\\n                if(forts[i]== -forts[j])sol = max(sol,i-j-1);\\n                j = i;\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3482462,
                "title": "clean-and-simple-solution-spiderman-approved",
                "content": "\\n# Complexity\\n- Time complexity: O(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n log n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n\\n        maxForts = 0\\n\\n        for i in [1, -1]:\\n\\n            capturedForts = 0\\n            isMyFortPassed = 0\\n\\n            for fort in forts[::i]:\\n\\n                if fort == 1:\\n                    if not isMyFortPassed:\\n                        isMyFortPassed = 1\\n                    else:\\n                        capturedForts = 0\\n\\n                if fort == 0 and isMyFortPassed:\\n                        capturedForts += 1\\n                \\n                if fort == -1:\\n\\n                    if capturedForts > maxForts:\\n                        maxForts = capturedForts\\n\\n                    capturedForts = 0\\n                    isMyFortPassed = 0\\n\\n        return maxForts\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n\\n        maxForts = 0\\n\\n        for i in [1, -1]:\\n\\n            capturedForts = 0\\n            isMyFortPassed = 0\\n\\n            for fort in forts[::i]:\\n\\n                if fort == 1:\\n                    if not isMyFortPassed:\\n                        isMyFortPassed = 1\\n                    else:\\n                        capturedForts = 0\\n\\n                if fort == 0 and isMyFortPassed:\\n                        capturedForts += 1\\n                \\n                if fort == -1:\\n\\n                    if capturedForts > maxForts:\\n                        maxForts = capturedForts\\n\\n                    capturedForts = 0\\n                    isMyFortPassed = 0\\n\\n        return maxForts\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442983,
                "title": "java-solution-time-complexity-o-n-space-complexity-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n  - O(n)\\n\\n- Space complexity:\\n  - O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        \\n        int max = 0;\\n\\n        int notEmpty = 0;\\n        for (int i = 0; i < forts.length; i++) {\\n            if (forts[i] != 0) {\\n                if (forts[i] == forts[notEmpty] * -1) {\\n                    int d = i - notEmpty - 1;\\n                    max = Math.max(max, d);\\n                }\\n                notEmpty = i;\\n            }\\n        }\\n\\n\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        \\n        int max = 0;\\n\\n        int notEmpty = 0;\\n        for (int i = 0; i < forts.length; i++) {\\n            if (forts[i] != 0) {\\n                if (forts[i] == forts[notEmpty] * -1) {\\n                    int d = i - notEmpty - 1;\\n                    max = Math.max(max, d);\\n                }\\n                notEmpty = i;\\n            }\\n        }\\n\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3428209,
                "title": "two-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nfind every consecutive zeros, then check whether the boudary positions\\' product equals -1, i.e., forts[left]*forts[right]==-1\\n\\n# Code\\n```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int n = forts.length;\\n        int res = 0;\\n        int l = 0, r = 0;\\n        \\n        while(l<n){\\n            if (forts[l]!=0)\\n                l++;\\n            else{\\n                r = l;\\n                while(r<n && forts[r]==0)\\n                    r++;\\n                if (l>0 && r<n && forts[l-1]*forts[r]==-1){\\n                    res = Math.max(res, r-l);\\n                }\\n                l = r;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int n = forts.length;\\n        int res = 0;\\n        int l = 0, r = 0;\\n        \\n        while(l<n){\\n            if (forts[l]!=0)\\n                l++;\\n            else{\\n                r = l;\\n                while(r<n && forts[r]==0)\\n                    r++;\\n                if (l>0 && r<n && forts[l-1]*forts[r]==-1){\\n                    res = Math.max(res, r-l);\\n                }\\n                l = r;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427494,
                "title": "javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} forts\\n * @return {number}\\n */\\nvar captureForts = function(forts)\\n{\\n    //in short we have find the number of elements between -1 and 1 \\n  \\n  let sum = 0; // for calculating cumulative sum\\n  let ret = 0; // for returning the max string of zeros between -1 and 1\\n  let count = 0; // for counting and comparing string of zeros\\n  \\n  for (let i = 0; i < forts.length; i++) {\\n    if (forts[i] !== 0) { // counting starts and ends at non-zero fort\\n      sum += forts[i]; // s counts the cumulative sum from the last non-zero fort\\n      if (sum === 0) {\\n        ret = Math.max(ret, count); // if s = 0, it means we are either at start or end, hence compare\\n      }\\n      sum = forts[i]; // cumulative sum resets to current value\\n      count = 0; // count resets at non-zero fort value\\n    } else {\\n      if (sum !== 0) {\\n        count++; // count if we already encountered a non-zero fort         \\n      }\\n    }\\n  }   \\n  return ret;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} forts\\n * @return {number}\\n */\\nvar captureForts = function(forts)\\n{\\n    //in short we have find the number of elements between -1 and 1 \\n  \\n  let sum = 0; // for calculating cumulative sum\\n  let ret = 0; // for returning the max string of zeros between -1 and 1\\n  let count = 0; // for counting and comparing string of zeros\\n  \\n  for (let i = 0; i < forts.length; i++) {\\n    if (forts[i] !== 0) { // counting starts and ends at non-zero fort\\n      sum += forts[i]; // s counts the cumulative sum from the last non-zero fort\\n      if (sum === 0) {\\n        ret = Math.max(ret, count); // if s = 0, it means we are either at start or end, hence compare\\n      }\\n      sum = forts[i]; // cumulative sum resets to current value\\n      count = 0; // count resets at non-zero fort value\\n    } else {\\n      if (sum !== 0) {\\n        count++; // count if we already encountered a non-zero fort         \\n      }\\n    }\\n  }   \\n  return ret;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3414799,
                "title": "simple-and-easy",
                "content": "# Intuition\\n\\n\\n# Approach\\n\\n# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int a=0,ans=0;\\n        for(int i=0;i<forts.size();i++){\\n            if(forts[i]==1){\\n                for(int j=i+1;j<forts.size();j++){\\n                    if(forts[j]==0){\\n                        a++;\\n                    }\\n                    else if(forts[j]==-1&&a==j-i-1){\\n                        ans=max(ans,a);\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n            }\\n            a=0;\\n        }\\n        a=0;\\n        for(int i=forts.size()-1;i>=0;i--){\\n            if(forts[i]==1){\\n                for(int j=i-1;j>=0;j--){\\n                    if(forts[j]==0){\\n                        a++;\\n                    }\\n                    else if(forts[j]==-1&&a==i-j-1){\\n                        ans=max(ans,a);\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n            }\\n            a=0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int a=0,ans=0;\\n        for(int i=0;i<forts.size();i++){\\n            if(forts[i]==1){\\n                for(int j=i+1;j<forts.size();j++){\\n                    if(forts[j]==0){\\n                        a++;\\n                    }\\n                    else if(forts[j]==-1&&a==j-i-1){\\n                        ans=max(ans,a);\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n            }\\n            a=0;\\n        }\\n        a=0;\\n        for(int i=forts.size()-1;i>=0;i--){\\n            if(forts[i]==1){\\n                for(int j=i-1;j>=0;j--){\\n                    if(forts[j]==0){\\n                        a++;\\n                    }\\n                    else if(forts[j]==-1&&a==i-j-1){\\n                        ans=max(ans,a);\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n            }\\n            a=0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384445,
                "title": "easy-approach-with-solution-in-c",
                "content": "# Intuition\\nYou can travel over(not on) enemy fortress(0) only.\\nThus, objective is to find the maximum contagious 0\\'s between -1 & 1 or 1 & -1. \\n\\n# Approach\\nUse 2 pointers i & j, where j is always i+1, when a non-zero digit(-1 or 1) is encountered at ith index, traverse using pointer j and keep a count of 0\\'s in some variable(say c) unless another non-zero digit is encountered.\\n\\nif non-zero number at ith index is 1, then after traversal non-zero number at jth index should be -1 and vice-versa, otherwise count of 0\\'s(c)=0.  \\n\\nMax funtion can be used. But in this case I made use of ternary operator(res=res>c?res:c) to find maximum contagious 0\\'s.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n# Code\\n```\\nint captureForts(int* forts, int fortsSize)\\n{\\n    int i=0,c=0,j=0,res=0;\\n    while(i<fortsSize-1)\\n    {\\n        if(forts[i]==-1)\\n        {\\n            c=0;\\n            j=i+1;\\n            while(forts[j]==0 && j<fortsSize-1)\\n            {\\n                c++;\\n                j++;\\n            }\\n            if(forts[j]!=1)\\n            {\\n                c=0;\\n            }\\n            \\n            res=res>c?res:c;\\n            i=j;\\n        }\\n        else if(forts[i]==1)\\n        {\\n            c=0;\\n            j=i+1;\\n            while(forts[j]==0 && j<fortsSize-1)\\n            {\\n                c++;\\n                j++;\\n            }\\n            if(forts[j]!=-1)\\n            {\\n                c=0;\\n            }\\n            res=res>c?res:c;\\n            i=j;\\n        }\\n        else\\n        {\\n            i++;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint captureForts(int* forts, int fortsSize)\\n{\\n    int i=0,c=0,j=0,res=0;\\n    while(i<fortsSize-1)\\n    {\\n        if(forts[i]==-1)\\n        {\\n            c=0;\\n            j=i+1;\\n            while(forts[j]==0 && j<fortsSize-1)\\n            {\\n                c++;\\n                j++;\\n            }\\n            if(forts[j]!=1)\\n            {\\n                c=0;\\n            }\\n            \\n            res=res>c?res:c;\\n            i=j;\\n        }\\n        else if(forts[i]==1)\\n        {\\n            c=0;\\n            j=i+1;\\n            while(forts[j]==0 && j<fortsSize-1)\\n            {\\n                c++;\\n                j++;\\n            }\\n            if(forts[j]!=-1)\\n            {\\n                c=0;\\n            }\\n            res=res>c?res:c;\\n            i=j;\\n        }\\n        else\\n        {\\n            i++;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3379923,
                "title": "python-solution",
                "content": "\\n```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n\\n        start = [] \\n        for i,n in enumerate(forts):\\n            if n == 1 : \\n                start.append(i) \\n                \\n        ans = 0 \\n        for s in start:\\n            tmp = 0 \\n            nxt = s+1 \\n            while nxt <= len(forts)-1: \\n                if forts[nxt] == 0 : \\n                    tmp +=1 \\n                if forts[nxt] == -1 : \\n                    ans = max(ans,tmp)\\n                    break\\n                if forts[nxt]==1:\\n                    break\\n                nxt+=1 \\n            nxt = s-1 \\n            tmp = 0 \\n            while nxt >=0: \\n                if forts[nxt] == 0 : \\n                    tmp +=1 \\n                if forts[nxt] == -1 : \\n                    ans = max(ans,tmp)\\n                    break\\n                if forts[nxt]==1:\\n                    break\\n                nxt-=1 \\n\\n        return ans\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n\\n        start = [] \\n        for i,n in enumerate(forts):\\n            if n == 1 : \\n                start.append(i) \\n                \\n        ans = 0 \\n        for s in start:\\n            tmp = 0 \\n            nxt = s+1 \\n            while nxt <= len(forts)-1: \\n                if forts[nxt] == 0 : \\n                    tmp +=1 \\n                if forts[nxt] == -1 : \\n                    ans = max(ans,tmp)\\n                    break\\n                if forts[nxt]==1:\\n                    break\\n                nxt+=1 \\n            nxt = s-1 \\n            tmp = 0 \\n            while nxt >=0: \\n                if forts[nxt] == 0 : \\n                    tmp +=1 \\n                if forts[nxt] == -1 : \\n                    ans = max(ans,tmp)\\n                    break\\n                if forts[nxt]==1:\\n                    break\\n                nxt-=1 \\n\\n        return ans\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373854,
                "title": "brute-force-c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int res=0,c=0,sum=0;\\n        for(int i=0;i<forts.size();i++){\\n            sum +=forts[i];\\n            if(sum==0){\\n                res=max(res,c);\\n                c=0;\\n                sum=forts[i];\\n            }\\n            else if(sum<-1 || sum>1){\\n                c=0;\\n                sum=forts[i];\\n            }\\n            if(sum!=0 && forts[i]==0)\\n                c++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nPLEASE UPVOTE! :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int res=0,c=0,sum=0;\\n        for(int i=0;i<forts.size();i++){\\n            sum +=forts[i];\\n            if(sum==0){\\n                res=max(res,c);\\n                c=0;\\n                sum=forts[i];\\n            }\\n            else if(sum<-1 || sum>1){\\n                c=0;\\n                sum=forts[i];\\n            }\\n            if(sum!=0 && forts[i]==0)\\n                c++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364663,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int n=forts.size();\\n        int ans=0,count=0;\\n        for(int i=0;i<n;i++){\\n            if(forts[i]==1){\\n                for(int j=i-1;j>=0;j--){\\n                    if(forts[j]==0)     count+=1;\\n                    else if(forts[j]==-1){\\n                        ans=max(count,ans);\\n                        count=0;\\n                        break;\\n                    }\\n                    else    break;\\n                }\\n                count=0;\\n                for(int j=i+1;j<n;j++){\\n                    if(forts[j]==0) count+=1;\\n                    else if(forts[j]==-1){\\n                        ans=max(ans,count);\\n                        count=0;\\n                        break;\\n                    }\\n                    else    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int n=forts.size();\\n        int ans=0,count=0;\\n        for(int i=0;i<n;i++){\\n            if(forts[i]==1){\\n                for(int j=i-1;j>=0;j--){\\n                    if(forts[j]==0)     count+=1;\\n                    else if(forts[j]==-1){\\n                        ans=max(count,ans);\\n                        count=0;\\n                        break;\\n                    }\\n                    else    break;\\n                }\\n                count=0;\\n                for(int j=i+1;j<n;j++){\\n                    if(forts[j]==0) count+=1;\\n                    else if(forts[j]==-1){\\n                        ans=max(ans,count);\\n                        count=0;\\n                        break;\\n                    }\\n                    else    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363875,
                "title": "o-n-time-javascript",
                "content": "If encountered 1 and the last encounter of 1 or -1 was -1, calculate this distance. If encountered -1 and the last encounter of 1 or -1 was 1, calculate this distance. Reset the last encounter whenever encounter 1 or -1.\\n\\n\\n\\n# Code\\n```\\n/**\\n * @param {number[]} forts\\n * @return {number}\\n */\\nvar captureForts = function(forts) {\\n    let start;\\n    let from = 0;\\n    let max = 0;\\n    for (let i = 0; i < forts.length; i++) {\\n        if (forts[i] === 1) {\\n            if (from === -1) {\\n                let captured = i - start - 1;\\n                if (captured > max) {\\n                    max = captured;\\n                }\\n            }\\n            start = i;\\n            from = 1;\\n        }\\n        if (forts[i] === -1) {\\n            if (from === 1) {\\n                let captured = i - start - 1;\\n                if (captured > max) {\\n                    max = captured;\\n                }\\n            }\\n            start = i;\\n            from = -1;\\n        }\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} forts\\n * @return {number}\\n */\\nvar captureForts = function(forts) {\\n    let start;\\n    let from = 0;\\n    let max = 0;\\n    for (let i = 0; i < forts.length; i++) {\\n        if (forts[i] === 1) {\\n            if (from === -1) {\\n                let captured = i - start - 1;\\n                if (captured > max) {\\n                    max = captured;\\n                }\\n            }\\n            start = i;\\n            from = 1;\\n        }\\n        if (forts[i] === -1) {\\n            if (from === 1) {\\n                let captured = i - start - 1;\\n                if (captured > max) {\\n                    max = captured;\\n                }\\n            }\\n            start = i;\\n            from = -1;\\n        }\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3359119,
                "title": "best-easy-solution-for-this-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int count=0;\\n        int sum=0;\\n        int ret=0;\\n\\n        for(int i=0;i<forts.length;i++){\\n            if(forts[i]!=0){\\n                sum=sum+forts[i];\\n                if(sum==0)\\n                    ret=Math.max(ret,count);\\n                sum=forts[i];\\n                count=0;\\n            }\\n                else{\\n                    if(sum!=0){\\n                        count++;\\n                    }\\n                }\\n                 \\n            \\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int count=0;\\n        int sum=0;\\n        int ret=0;\\n\\n        for(int i=0;i<forts.length;i++){\\n            if(forts[i]!=0){\\n                sum=sum+forts[i];\\n                if(sum==0)\\n                    ret=Math.max(ret,count);\\n                sum=forts[i];\\n                count=0;\\n            }\\n                else{\\n                    if(sum!=0){\\n                        count++;\\n                    }\\n                }\\n                 \\n            \\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350832,
                "title": "easy-and-unique-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint getleft(vector<int>&v,int x){\\n    int c = 0;\\n\\n    for(int i = x;i>=0;i--){\\n\\n        if(v[i]==0)c++;\\n       else  if(v[i]==1)c=0;\\n        else if(v[i]==-1){\\n            return c;\\n        }\\n    }\\n    return 0;\\n}\\nint getright(vector<int>&v,int x){\\n\\n    int c = 0;\\n    for(int i = x;i<v.size();i++){\\n\\n        if(v[i]==0)c++;\\n        else if(v[i]==1)c=0;\\n        else if(v[i]==-1) return c;\\n    }\\n    return 0;\\n}\\n    int captureForts(vector<int>& forts) {\\n        int n = forts.size();\\n\\n        int i = 0;\\n        int maxi = 0;\\n        while(i<n){\\n\\n            if(forts[i]==1){\\n\\n                int x = getleft(forts,i-1);\\n                int y = getright(forts,i+1);\\n\\n                maxi = max(maxi,max(x,y));\\n            }\\n            i++;\\n        }\\n        return maxi;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint getleft(vector<int>&v,int x){\\n    int c = 0;\\n\\n    for(int i = x;i>=0;i--){\\n\\n        if(v[i]==0)c++;\\n       else  if(v[i]==1)c=0;\\n        else if(v[i]==-1){\\n            return c;\\n        }\\n    }\\n    return 0;\\n}\\nint getright(vector<int>&v,int x){\\n\\n    int c = 0;\\n    for(int i = x;i<v.size();i++){\\n\\n        if(v[i]==0)c++;\\n        else if(v[i]==1)c=0;\\n        else if(v[i]==-1) return c;\\n    }\\n    return 0;\\n}\\n    int captureForts(vector<int>& forts) {\\n        int n = forts.size();\\n\\n        int i = 0;\\n        int maxi = 0;\\n        while(i<n){\\n\\n            if(forts[i]==1){\\n\\n                int x = getleft(forts,i-1);\\n                int y = getright(forts,i+1);\\n\\n                maxi = max(maxi,max(x,y));\\n            }\\n            i++;\\n        }\\n        return maxi;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350640,
                "title": "o-n-soultion-beginner-friendly",
                "content": "# Intuition\\n# Approach\\n\\n# Complexity\\n- Time complexity:O(N)\\n- Space complexity: O(1)\\n# Code\\n```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int max=0;\\n        int i=0;\\n        boolean f=false;\\n        int res=0;\\n                //FORWARD\\n        while(i<forts.length){\\n            if(forts[i]==1){\\n                if(f==false)  {res = 0;  f=true;}\\n                else    {res=0;     f=true;}\\n            }\\n            else if(forts[i]==0&&f==true){\\n                res++;\\n            }\\n            else if(forts[i]==-1){\\n                if(f==true)\\n                    max=Math.max(max,res);\\n                f=false;\\n            }\\n            i++;\\n        }\\n        i--;\\n        f=false;\\n        res=0;\\n          //BACKWARD\\n         while(i>=0){\\n            if(forts[i]==1){\\n                if(f==false)  {res = 0;  f=true;}\\n                else    {res=0;     f=true;}\\n            }\\n            else if(forts[i]==0&&f==true){\\n                res++;\\n            }\\n            else if(forts[i]==-1){\\n                if(f==true)\\n                    max=Math.max(max,res);\\n                f=false;\\n            }\\n            i--;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int max=0;\\n        int i=0;\\n        boolean f=false;\\n        int res=0;\\n                //FORWARD\\n        while(i<forts.length){\\n            if(forts[i]==1){\\n                if(f==false)  {res = 0;  f=true;}\\n                else    {res=0;     f=true;}\\n            }\\n            else if(forts[i]==0&&f==true){\\n                res++;\\n            }\\n            else if(forts[i]==-1){\\n                if(f==true)\\n                    max=Math.max(max,res);\\n                f=false;\\n            }\\n            i++;\\n        }\\n        i--;\\n        f=false;\\n        res=0;\\n          //BACKWARD\\n         while(i>=0){\\n            if(forts[i]==1){\\n                if(f==false)  {res = 0;  f=true;}\\n                else    {res=0;     f=true;}\\n            }\\n            else if(forts[i]==0&&f==true){\\n                res++;\\n            }\\n            else if(forts[i]==-1){\\n                if(f==true)\\n                    max=Math.max(max,res);\\n                f=false;\\n            }\\n            i--;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349342,
                "title": "super-easy-python-approach-please-upvote-if-you-like-my-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n\\n        count = 0\\n        ans = 0\\n        for i in range(len(forts)):\\n            if forts[i] == forts[i-1]:\\n                count += 1\\n            else:\\n                if (forts[i-1] == 0 and i - count - 1 >= 0 and \\n                    ((forts[i] == 1 and forts[i-count-1] == -1) or \\n                    (forts[i] == -1 and forts[i-count-1] == 1))):\\n                    ans = max(ans, count)\\n                count = 1  # reset count for new sequence\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n\\n        count = 0\\n        ans = 0\\n        for i in range(len(forts)):\\n            if forts[i] == forts[i-1]:\\n                count += 1\\n            else:\\n                if (forts[i-1] == 0 and i - count - 1 >= 0 and \\n                    ((forts[i] == 1 and forts[i-count-1] == -1) or \\n                    (forts[i] == -1 and forts[i-count-1] == 1))):\\n                    ans = max(ans, count)\\n                count = 1  # reset count for new sequence\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347236,
                "title": "c-faster-easy-to-understand",
                "content": "* ***Traversal***\\n\\n* ***Time Complexity :- O(N * N)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int maxi = 0;\\n        \\n        // traverse over the array\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] == 1)\\n            {\\n                // go on left of i\\n                \\n                int j = i - 1;\\n                \\n                int count = 0;\\n                \\n                while(j >= 0 && nums[j] == 0)\\n                {\\n                    count++;\\n                    \\n                    j--;\\n                }\\n                \\n                // update maxi\\n                \\n                if(j >= 0 && nums[j] == -1)\\n                {\\n                    maxi = max(maxi, count);\\n                }\\n                \\n                // go on right of i\\n                \\n                count = 0;\\n                \\n                j = i + 1;\\n                \\n                while(j < n && nums[j] == 0)\\n                {\\n                    count++;\\n                    \\n                    j++;\\n                }\\n                \\n                // update maxi\\n                \\n                if(j < n && nums[j] == -1)\\n                {\\n                    maxi = max(maxi, count);\\n                }\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int maxi = 0;\\n        \\n        // traverse over the array\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] == 1)\\n            {\\n                // go on left of i\\n                \\n                int j = i - 1;\\n                \\n                int count = 0;\\n                \\n                while(j >= 0 && nums[j] == 0)\\n                {\\n                    count++;\\n                    \\n                    j--;\\n                }\\n                \\n                // update maxi\\n                \\n                if(j >= 0 && nums[j] == -1)\\n                {\\n                    maxi = max(maxi, count);\\n                }\\n                \\n                // go on right of i\\n                \\n                count = 0;\\n                \\n                j = i + 1;\\n                \\n                while(j < n && nums[j] == 0)\\n                {\\n                    count++;\\n                    \\n                    j++;\\n                }\\n                \\n                // update maxi\\n                \\n                if(j < n && nums[j] == -1)\\n                {\\n                    maxi = max(maxi, count);\\n                }\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346956,
                "title": "c",
                "content": "```C []\\nint captureForts(const int * const forts, const int fortsLen){\\n\\tint maxCaptured = 0;\\n\\n\\tfor (int i = 0; i < fortsLen; i += 1){\\n\\t\\tif (!( 1 == forts[i] )){\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tint j;\\n\\n\\t\\tj = i - 1;\\n\\t\\twhile (j >= 0 && 0 == forts[j]){\\n\\t\\t\\tj -= 1;\\n\\t\\t}\\n\\t\\tif (j >= 0 && -1 == forts[j]){\\n\\t\\t\\tconst int zeroCnt = i - (j + 1);\\n\\t\\t\\tif (zeroCnt > maxCaptured){\\n\\t\\t\\t\\tmaxCaptured = zeroCnt;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tj = i + 1;\\n\\t\\twhile (j < fortsLen && 0 == forts[j]){\\n\\t\\t\\tj += 1;\\n\\t\\t}\\n\\t\\tif (j < fortsLen && -1 == forts[j]){\\n\\t\\t\\tconst int zeroCnt = j - (i + 1);\\n\\t\\t\\tif (zeroCnt > maxCaptured){\\n\\t\\t\\t\\tmaxCaptured = zeroCnt;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn maxCaptured;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C []\\nint captureForts(const int * const forts, const int fortsLen){\\n\\tint maxCaptured = 0;\\n\\n\\tfor (int i = 0; i < fortsLen; i += 1){\\n\\t\\tif (!( 1 == forts[i] )){\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\tint j;\\n\\n\\t\\tj = i - 1;\\n\\t\\twhile (j >= 0 && 0 == forts[j]){\\n\\t\\t\\tj -= 1;\\n\\t\\t}\\n\\t\\tif (j >= 0 && -1 == forts[j]){\\n\\t\\t\\tconst int zeroCnt = i - (j + 1);\\n\\t\\t\\tif (zeroCnt > maxCaptured){\\n\\t\\t\\t\\tmaxCaptured = zeroCnt;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tj = i + 1;\\n\\t\\twhile (j < fortsLen && 0 == forts[j]){\\n\\t\\t\\tj += 1;\\n\\t\\t}\\n\\t\\tif (j < fortsLen && -1 == forts[j]){\\n\\t\\t\\tconst int zeroCnt = j - (i + 1);\\n\\t\\t\\tif (zeroCnt > maxCaptured){\\n\\t\\t\\t\\tmaxCaptured = zeroCnt;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn maxCaptured;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3332852,
                "title": "clean-and-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& f)\\n    {\\n        int i=0;\\n        int res=0;\\n        for(int j=0;j<f.size();j++)\\n        {\\n            if(f[j])\\n            {\\n                if(f[j]==-f[i])\\n                res=max(res,j-i-1);\\n                i=j;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& f)\\n    {\\n        int i=0;\\n        int res=0;\\n        for(int j=0;j<f.size();j++)\\n        {\\n            if(f[j])\\n            {\\n                if(f[j]==-f[i])\\n                res=max(res,j-i-1);\\n                i=j;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329289,
                "title": "java-c-both-easy-solution",
                "content": "**Java Solution : - **\\n```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int total = 0;\\n        for (int i = 0; i < forts.length; i++) {\\n            if (forts[i] == 1) {\\n                int leftFort = findL(forts, i-1);\\n                int rFort = findR(forts, i+1);\\n                total = Math.max(total, Math.max(leftFort, rFort));\\n            }\\n        }\\n        return total;\\n    }\\n    private int findL(int[] forts, int i) {\\n        int cap = 0;\\n        while (i >= 0) {\\n            if (forts[i] == 1) return 0;\\n            if (forts[i] == -1) return cap;\\n            if (forts[i--] == 0) cap++;\\n        }\\n        return 0;\\n    }\\n    private int findR(int[] forts, int i) {\\n        int cap = 0;\\n        while (i <= forts.length-1) {\\n            if (forts[i] == 1) return 0;\\n            if (forts[i] == -1) return cap;\\n            if (forts[i++] == 0) cap++;\\n        }\\n        return 0;\\n    }\\n}\\n```\\n**C++ solution**\\n```\\nclass Solution {\\npublic:\\n    int findL(vector<int>& forts, int i) {\\n        int cap = 0;\\n        while (i >= 0) {\\n            if (forts[i] == 1) return 0;\\n            if (forts[i] == -1) return cap;\\n            if (forts[i--] == 0) cap++;\\n        }\\n        return 0;\\n    }\\n    int findR(vector<int>& forts, int i) {\\n        int cap = 0;\\n        while (i <= forts.size() - 1) {\\n            if (forts[i] == 1) return 0;\\n            if (forts[i] == -1) return cap;\\n            if (forts[i++] == 0) cap++;\\n        }\\n        return 0;\\n    }\\n    int captureForts(vector<int>& forts) {\\n        int total = 0;\\n        for (int i = 0; i < forts.size(); i++) {\\n            if (forts[i] == 1) {\\n                int leftFort = findL(forts, i-1);\\n                int rFort = findR(forts, i+1);\\n                total = max(total, max(leftFort, rFort));\\n            }\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int total = 0;\\n        for (int i = 0; i < forts.length; i++) {\\n            if (forts[i] == 1) {\\n                int leftFort = findL(forts, i-1);\\n                int rFort = findR(forts, i+1);\\n                total = Math.max(total, Math.max(leftFort, rFort));\\n            }\\n        }\\n        return total;\\n    }\\n    private int findL(int[] forts, int i) {\\n        int cap = 0;\\n        while (i >= 0) {\\n            if (forts[i] == 1) return 0;\\n            if (forts[i] == -1) return cap;\\n            if (forts[i--] == 0) cap++;\\n        }\\n        return 0;\\n    }\\n    private int findR(int[] forts, int i) {\\n        int cap = 0;\\n        while (i <= forts.length-1) {\\n            if (forts[i] == 1) return 0;\\n            if (forts[i] == -1) return cap;\\n            if (forts[i++] == 0) cap++;\\n        }\\n        return 0;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int findL(vector<int>& forts, int i) {\\n        int cap = 0;\\n        while (i >= 0) {\\n            if (forts[i] == 1) return 0;\\n            if (forts[i] == -1) return cap;\\n            if (forts[i--] == 0) cap++;\\n        }\\n        return 0;\\n    }\\n    int findR(vector<int>& forts, int i) {\\n        int cap = 0;\\n        while (i <= forts.size() - 1) {\\n            if (forts[i] == 1) return 0;\\n            if (forts[i] == -1) return cap;\\n            if (forts[i++] == 0) cap++;\\n        }\\n        return 0;\\n    }\\n    int captureForts(vector<int>& forts) {\\n        int total = 0;\\n        for (int i = 0; i < forts.size(); i++) {\\n            if (forts[i] == 1) {\\n                int leftFort = findL(forts, i-1);\\n                int rFort = findR(forts, i+1);\\n                total = max(total, max(leftFort, rFort));\\n            }\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324643,
                "title": "100-fast-java-logical-easy-with-comments",
                "content": "```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int n=forts.length;\\n//      this is the answer to be returned\\n        int ans=0;\\n//      used to check if path is between an empty and filled port or visa versa\\n        int validIndex=0;\\n//      store the curr max enemy forts between the valid path \\n        int currMaxZero=0;\\n//      Removing the trailing enemy forts because they are useless and will result in failure of the algorithm\\n        int start=0;\\n        while(start<n && forts[start]==0){\\n            start++;\\n        }\\n//      if all are enemy forts then return 0;\\n        if(start==n){return 0;}\\n//      Setting first non zero value to be the valid start index\\n        validIndex=forts[start];\\n        for(int i=start+1;i<n;i++){\\n//            if current fort is enemy count it\\n            if(forts[i]==0){\\n                currMaxZero++;\\n            }\\n            validIndex+=forts[i];\\n//          case 1 - if the path is valid then set the curr Max Zeroes to ans \\n            if(validIndex==0){\\n                ans=Math.max(ans,currMaxZero);\\n                validIndex=forts[i];\\n                currMaxZero=0;\\n            }\\n//          case 2 - if the path is not valid then set the curr max zeros to 0 because we will not count these zeroes\\n            else if(validIndex>1 || validIndex<-1){\\n                validIndex=forts[i];\\n                currMaxZero=0;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int n=forts.length;\\n//      this is the answer to be returned\\n        int ans=0;\\n//      used to check if path is between an empty and filled port or visa versa\\n        int validIndex=0;\\n//      store the curr max enemy forts between the valid path \\n        int currMaxZero=0;\\n//      Removing the trailing enemy forts because they are useless and will result in failure of the algorithm\\n        int start=0;\\n        while(start<n && forts[start]==0){\\n            start++;\\n        }\\n//      if all are enemy forts then return 0;\\n        if(start==n){return 0;}\\n//      Setting first non zero value to be the valid start index\\n        validIndex=forts[start];\\n        for(int i=start+1;i<n;i++){\\n//            if current fort is enemy count it\\n            if(forts[i]==0){\\n                currMaxZero++;\\n            }\\n            validIndex+=forts[i];\\n//          case 1 - if the path is valid then set the curr Max Zeroes to ans \\n            if(validIndex==0){\\n                ans=Math.max(ans,currMaxZero);\\n                validIndex=forts[i];\\n                currMaxZero=0;\\n            }\\n//          case 2 - if the path is not valid then set the curr max zeros to 0 because we will not count these zeroes\\n            else if(validIndex>1 || validIndex<-1){\\n                validIndex=forts[i];\\n                currMaxZero=0;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3307303,
                "title": "easy-python-solution-with-sliding-windows",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        ans = 0\\n        l , r  = 0 , 1\\n        while r < len(forts):\\n            if forts[l] == 1:\\n                if forts[r] == -1:\\n                    ans = max(ans , abs(r-l)-1)\\n                    print(ans , l , r)\\n                    l = r\\n                    r += 1\\n                elif forts[r] == 0:\\n                    r += 1\\n                else:\\n                    l = r\\n                    r += 1\\n            \\n            elif forts[l] == -1:\\n                if forts[r] == 1:\\n                    ans = max(ans , abs(r-l)-1)\\n                    \\n                    l = r\\n                    r += 1\\n                elif forts[r] == 0:\\n                    r += 1\\n                else:\\n                    l = r\\n                    r += 1\\n            else:\\n                l = r\\n                r += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        ans = 0\\n        l , r  = 0 , 1\\n        while r < len(forts):\\n            if forts[l] == 1:\\n                if forts[r] == -1:\\n                    ans = max(ans , abs(r-l)-1)\\n                    print(ans , l , r)\\n                    l = r\\n                    r += 1\\n                elif forts[r] == 0:\\n                    r += 1\\n                else:\\n                    l = r\\n                    r += 1\\n            \\n            elif forts[l] == -1:\\n                if forts[r] == 1:\\n                    ans = max(ans , abs(r-l)-1)\\n                    \\n                    l = r\\n                    r += 1\\n                elif forts[r] == 0:\\n                    r += 1\\n                else:\\n                    l = r\\n                    r += 1\\n            else:\\n                l = r\\n                r += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306084,
                "title": "100-beat-c-solution-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n         \\n         int i=0;\\n         int n=forts.size();\\n         int ans=0;\\n         while(i<n){\\n\\n             if(forts[i]==1){\\n                 int j=i-1;\\n                 while(j>=0 &&forts[j]==0){\\n                       j--;\\n                 }\\n                 if(j>=0 && forts[j]==-1){\\n                     ans=max(ans,i-j-1);\\n                 }\\n\\n               int k=i+1;\\n               while(k<n && forts[k]==0){\\n                    k++;\\n               }\\n               if(k<n && forts[k]==-1){\\n                   ans=max(ans,k-i-1);\\n               }\\n       \\n               i=k;\\n             }\\n             else \\n              i++;\\n\\n         }\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n         \\n         int i=0;\\n         int n=forts.size();\\n         int ans=0;\\n         while(i<n){\\n\\n             if(forts[i]==1){\\n                 int j=i-1;\\n                 while(j>=0 &&forts[j]==0){\\n                       j--;\\n                 }\\n                 if(j>=0 && forts[j]==-1){\\n                     ans=max(ans,i-j-1);\\n                 }\\n\\n               int k=i+1;\\n               while(k<n && forts[k]==0){\\n                    k++;\\n               }\\n               if(k<n && forts[k]==-1){\\n                   ans=max(ans,k-i-1);\\n               }\\n       \\n               i=k;\\n             }\\n             else \\n              i++;\\n\\n         }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288670,
                "title": "maximum-forts-capture",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int n = forts.size();\\n        int ans = 0;\\n        for(int i = 0; i < n; i++){\\n            if(forts[i] == 1){\\n                int cnt = 0;\\n                for(int j = i-1; j >= 0; j--){\\n                    if(forts[j] == 0){\\n                        cnt++;\\n                    }\\n                    else if(forts[j] == -1){\\n                        ans = max(ans, cnt);\\n                        cnt = 0;\\n                        break;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n                cnt = 0;\\n                for(int j = i+1; j<n; j++){\\n                    if(forts[j] == 0){\\n                        cnt++;\\n                    }\\n                    else if(forts[j] == -1){\\n                        ans = max(ans, cnt);\\n                        cnt = 0;\\n                        break;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int n = forts.size();\\n        int ans = 0;\\n        for(int i = 0; i < n; i++){\\n            if(forts[i] == 1){\\n                int cnt = 0;\\n                for(int j = i-1; j >= 0; j--){\\n                    if(forts[j] == 0){\\n                        cnt++;\\n                    }\\n                    else if(forts[j] == -1){\\n                        ans = max(ans, cnt);\\n                        cnt = 0;\\n                        break;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n                cnt = 0;\\n                for(int j = i+1; j<n; j++){\\n                    if(forts[j] == 0){\\n                        cnt++;\\n                    }\\n                    else if(forts[j] == -1){\\n                        ans = max(ans, cnt);\\n                        cnt = 0;\\n                        break;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272884,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int len = forts.length;\\n        int count = 0;\\n        int index= -1;\\n        int indexValue = -2;\\n\\n        for(int i =0; i < len; i++){\\n            if(forts[i] == 1){\\n               if(index !=-1 && indexValue == -1){\\n                    count = Math.max(count, Math.abs(i- index -1));\\n                }\\n                index = i;\\n                indexValue = forts[i];\\n            }else if(forts[i] == -1){\\n               if(index !=-1 && indexValue == 1){\\n                    count = Math.max(count, Math.abs(i- index -1));\\n                }\\n                index = i;\\n                indexValue = forts[i];\\n            }\\n        }\\n       return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int len = forts.length;\\n        int count = 0;\\n        int index= -1;\\n        int indexValue = -2;\\n\\n        for(int i =0; i < len; i++){\\n            if(forts[i] == 1){\\n               if(index !=-1 && indexValue == -1){\\n                    count = Math.max(count, Math.abs(i- index -1));\\n                }\\n                index = i;\\n                indexValue = forts[i];\\n            }else if(forts[i] == -1){\\n               if(index !=-1 && indexValue == 1){\\n                    count = Math.max(count, Math.abs(i- index -1));\\n                }\\n                index = i;\\n                indexValue = forts[i];\\n            }\\n        }\\n       return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271352,
                "title": "java-kotlin-100-faster-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nKeep finding the interval between -1 to 1 in the array and find the maximum 0s in it\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTwo pointer solution: define the pointer prev to record the previous -1 or 1 position, for loop by using another pointer i, if forts[prev] != 0 and forts[i] != 0 then check if forts[prev] and forts[i] are 1 and -1, if yes then update the 0s in prev and i interval, then update prev pointer to i\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    fun captureForts(forts: IntArray): Int {\\n        var prev: Int = -1\\n        var total = 0\\n        for(i in forts.indices){\\n            if(forts[i] != 0 && prev == -1){\\n                prev = i\\n                continue\\n            }\\n            if(forts[i] != 0 && prev != -1 ){\\n                if(forts[i] + forts[prev] == 0){\\n                    //only check 0s between -1 and 1\\n                    total = Math.max(total, i - prev + 1 - 2)\\n                }\\n                prev = i\\n            }\\n        }\\n        return total\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Kotlin",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    fun captureForts(forts: IntArray): Int {\\n        var prev: Int = -1\\n        var total = 0\\n        for(i in forts.indices){\\n            if(forts[i] != 0 && prev == -1){\\n                prev = i\\n                continue\\n            }\\n            if(forts[i] != 0 && prev != -1 ){\\n                if(forts[i] + forts[prev] == 0){\\n                    //only check 0s between -1 and 1\\n                    total = Math.max(total, i - prev + 1 - 2)\\n                }\\n                prev = i\\n            }\\n        }\\n        return total\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270218,
                "title": "c-solution-annoying-problem-but-oh-well",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int max=0;\\n        int cur=0;\\n        bool emptyfound=false;\\n        bool armyfound=false; \\n        int armyindex=-1;\\n        int emptyindex=-1;\\n        for (int i=0; i<forts.size(); i++)\\n        {\\n            if (forts[i]==-1)\\n            {\\n                emptyfound=true;\\n                emptyindex=i;\\n            }\\n            if (forts[i]==1)\\n            {\\n                armyfound=true;\\n                armyindex=i;\\n            }\\n            if (emptyfound && armyfound)\\n            {\\n                int start=emptyindex;\\n                int end=armyindex;\\n                if (armyindex<emptyindex)\\n                {\\n                    start=armyindex;\\n                    end=emptyindex;\\n                }\\n                for (int j=start; j<end; j++)\\n                {\\n                    if (forts[j]==0)\\n                    {\\n                        cur++;\\n                    }\\n                }\\n                if (cur > max)\\n                {\\n                    max=cur;\\n                }\\n                cur =0; \\n                emptyfound=false;\\n                armyfound=false; \\n\\n                 if (forts[i]==-1)\\n                {\\n                emptyfound=true;\\n                emptyindex=i;\\n                }\\n                if (forts[i]==1)\\n                {\\n                armyfound=true;\\n                armyindex=i;\\n                }\\n\\n            }\\n          \\n\\n        }\\n        return max; \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int max=0;\\n        int cur=0;\\n        bool emptyfound=false;\\n        bool armyfound=false; \\n        int armyindex=-1;\\n        int emptyindex=-1;\\n        for (int i=0; i<forts.size(); i++)\\n        {\\n            if (forts[i]==-1)\\n            {\\n                emptyfound=true;\\n                emptyindex=i;\\n            }\\n            if (forts[i]==1)\\n            {\\n                armyfound=true;\\n                armyindex=i;\\n            }\\n            if (emptyfound && armyfound)\\n            {\\n                int start=emptyindex;\\n                int end=armyindex;\\n                if (armyindex<emptyindex)\\n                {\\n                    start=armyindex;\\n                    end=emptyindex;\\n                }\\n                for (int j=start; j<end; j++)\\n                {\\n                    if (forts[j]==0)\\n                    {\\n                        cur++;\\n                    }\\n                }\\n                if (cur > max)\\n                {\\n                    max=cur;\\n                }\\n                cur =0; \\n                emptyfound=false;\\n                armyfound=false; \\n\\n                 if (forts[i]==-1)\\n                {\\n                emptyfound=true;\\n                emptyindex=i;\\n                }\\n                if (forts[i]==1)\\n                {\\n                armyfound=true;\\n                armyindex=i;\\n                }\\n\\n            }\\n          \\n\\n        }\\n        return max; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259024,
                "title": "easy-c-solution-two-pointers-o-1-space",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n         int n=forts.size();\\n         int cnt=0;\\n         int maxi=0;\\n        for(int i=0;i<n;i++){\\n            if(forts[i]==1){\\n\\n                //move left\\n                for(int j=i-1;j>=0;j--){\\n                    if(forts[j]==0){\\n                        cnt++;\\n                    }\\n                    else if(forts[j]==-1){\\n                        maxi=max(maxi,cnt);\\n                        cnt=0;\\n                        break;\\n                    }\\n                    else break; //1 to 1\\n                }\\n\\n                cnt=0;\\n                //move right\\n                 for(int j=i+1;j<forts.size();j++){\\n                    if(forts[j]==0){\\n                        cnt++;\\n                    }\\n                    else if(forts[j]==-1){\\n                        maxi=max(maxi,cnt);\\n                        cnt=0;\\n                        break;\\n                    }\\n                    else break; //1 to 1\\n                }\\n\\n            }\\n        }\\n        return maxi;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n         int n=forts.size();\\n         int cnt=0;\\n         int maxi=0;\\n        for(int i=0;i<n;i++){\\n            if(forts[i]==1){\\n\\n                //move left\\n                for(int j=i-1;j>=0;j--){\\n                    if(forts[j]==0){\\n                        cnt++;\\n                    }\\n                    else if(forts[j]==-1){\\n                        maxi=max(maxi,cnt);\\n                        cnt=0;\\n                        break;\\n                    }\\n                    else break; //1 to 1\\n                }\\n\\n                cnt=0;\\n                //move right\\n                 for(int j=i+1;j<forts.size();j++){\\n                    if(forts[j]==0){\\n                        cnt++;\\n                    }\\n                    else if(forts[j]==-1){\\n                        maxi=max(maxi,cnt);\\n                        cnt=0;\\n                        break;\\n                    }\\n                    else break; //1 to 1\\n                }\\n\\n            }\\n        }\\n        return maxi;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237587,
                "title": "the-easyest-code-with-0-33-ms-speed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        forts.append(2)\\n        cnt = 0\\n        res = 0\\n        for i in range(len(forts) - 1):\\n            if forts[i] == 1:\\n                z = i + 1\\n                cnt = 0\\n                while forts[z] == 0:\\n                    cnt += 1\\n                    z += 1\\n                    if forts[z] == -1:\\n                        if cnt > res:\\n                            res = cnt\\n            elif forts[i] == -1:\\n                z = i + 1\\n                cnt = 0\\n                while forts[z] == 0:\\n                    cnt += 1\\n                    z += 1\\n                    if forts[z] == 1:\\n                        if cnt > res:\\n                            res = cnt\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        forts.append(2)\\n        cnt = 0\\n        res = 0\\n        for i in range(len(forts) - 1):\\n            if forts[i] == 1:\\n                z = i + 1\\n                cnt = 0\\n                while forts[z] == 0:\\n                    cnt += 1\\n                    z += 1\\n                    if forts[z] == -1:\\n                        if cnt > res:\\n                            res = cnt\\n            elif forts[i] == -1:\\n                z = i + 1\\n                cnt = 0\\n                while forts[z] == 0:\\n                    cnt += 1\\n                    z += 1\\n                    if forts[z] == 1:\\n                        if cnt > res:\\n                            res = cnt\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237126,
                "title": "simple-one-loop-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n[1, 0, 0, -1, 0, 0, 1]\\n\\nTo make the problem simpler it can be rephrased as the maximum distance between each valid pair of 1 and -1. Since we are interested only in the number of inbetween positions we subtract 1 from this distance.\\n\\ndistance = Math.abs(pos1 - posMinus1) - 1 \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe have to loop through the array and calculate the distance between each pairs of 1 and -1. But we need to decide which pairs are valid. \\n\\n[1, 0, 0, -1] is a valid pair subarray\\n[1, 0, 0, -1, 0, 0, -1] is not a valid pair subarray (each value between the closing 1 and -1 must be a zero, the army cannot cross a fort to get to a fort behind it)\\n[-1, 0, 0, 1, 0, 0, 1] is also not a valid pair subarray\\n\\nTo solve this a variable containing the previous passed fort is used (int prev), which can be 0, -1 or 1 depending on the previously passed fort\\nEach time a fort (1 or -1) is passed the value of prev is changed.\\n\\nWhen we get to a fort we check if our pair is valid (if the previously passed fort was not of the same type, and if the positions are in bounds) and then calculate the distance. \\nif the calculated distance is larger than the current result, we set the result to the current distance.\\n\\n \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int result = 0;\\n        int tmp = 0;\\n        \\n        int prev = 0;\\n\\n        int pos1 = -1;\\n        int posMinus1 = -1;\\n\\n        for(int i = 0; i < forts.length; i++){\\n            if(forts[i] == 1){\\n                pos1 = i;\\n                if(posMinus1 != -1 && prev == -1){\\n                    tmp = Math.abs(pos1 - posMinus1) - 1;\\n                }\\n                prev = 1;\\n\\n                if(tmp > result){\\n                    result = tmp;\\n                }\\n            }else if(forts[i] == -1){\\n                posMinus1 = i;\\n                if(pos1 != -1 && prev == 1){\\n                    tmp = Math.abs(pos1 - posMinus1) - 1;\\n                }\\n                prev = -1;\\n\\n                if(tmp > result){\\n                    result = tmp;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int result = 0;\\n        int tmp = 0;\\n        \\n        int prev = 0;\\n\\n        int pos1 = -1;\\n        int posMinus1 = -1;\\n\\n        for(int i = 0; i < forts.length; i++){\\n            if(forts[i] == 1){\\n                pos1 = i;\\n                if(posMinus1 != -1 && prev == -1){\\n                    tmp = Math.abs(pos1 - posMinus1) - 1;\\n                }\\n                prev = 1;\\n\\n                if(tmp > result){\\n                    result = tmp;\\n                }\\n            }else if(forts[i] == -1){\\n                posMinus1 = i;\\n                if(pos1 != -1 && prev == 1){\\n                    tmp = Math.abs(pos1 - posMinus1) - 1;\\n                }\\n                prev = -1;\\n\\n                if(tmp > result){\\n                    result = tmp;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3191725,
                "title": "easy-to-understand-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int isPrevOwned = 0;\\n        int max=0;\\n        int count=0;\\n\\n        for(int i=0;i<forts.length;i++){\\n            if(forts[i] == 0) count++;\\n            else{\\n                if(forts[i] == -1 ){\\n                    if(isPrevOwned == 1)\\n                        max = Math.max(max,count);\\n                    isPrevOwned = -1;\\n                    count=0;\\n                }\\n                else{\\n                    if(isPrevOwned == -1)\\n                        max = Math.max(max,count);\\n                   isPrevOwned = 1; \\n                   count=0;\\n                }\\n            }\\n        }\\n\\n        return max;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int isPrevOwned = 0;\\n        int max=0;\\n        int count=0;\\n\\n        for(int i=0;i<forts.length;i++){\\n            if(forts[i] == 0) count++;\\n            else{\\n                if(forts[i] == -1 ){\\n                    if(isPrevOwned == 1)\\n                        max = Math.max(max,count);\\n                    isPrevOwned = -1;\\n                    count=0;\\n                }\\n                else{\\n                    if(isPrevOwned == -1)\\n                        max = Math.max(max,count);\\n                   isPrevOwned = 1; \\n                   count=0;\\n                }\\n            }\\n        }\\n\\n        return max;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3189034,
                "title": "simple-kotlin-solution-for-beginners",
                "content": "```\\nclass Solution {\\n    fun captureForts(forts: IntArray): Int {\\n        val n = forts.size\\n        var (j, result) = arrayOf(0, 0)\\n        for (i in 0..n-1) {\\n            if (forts[i] != 0) {\\n                if (forts[i] == -forts[j]) result = maxOf(result, i-j-1)\\n                j = i\\n            }\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun captureForts(forts: IntArray): Int {\\n        val n = forts.size\\n        var (j, result) = arrayOf(0, 0)\\n        for (i in 0..n-1) {\\n            if (forts[i] != 0) {\\n                if (forts[i] == -forts[j]) result = maxOf(result, i-j-1)\\n                j = i\\n            }\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3184961,
                "title": "java-2-pointers-explained",
                "content": "**Idea:**\\n* Use 2 pointers left and right to keep track of unequal, non-zero items\\n* When such items are found, the number of zeroes between them are the number of forts available to capture\\n* Find max such forts\\n>**T/S:** O(n)/O(1), where n = size(forts)\\n```\\npublic int captureForts(int[] forts) {\\n\\tvar n = forts.length;\\n\\tif (n < 3)\\n\\t\\treturn 0;\\n\\n\\tvar maxForts = 0;\\n\\tfor (int left = 0, right = 1; right < n; right++)\\n\\t\\tif (forts[right] != 0) {\\n\\t\\t\\tif (forts[left] == -forts[right])\\n\\t\\t\\t\\tmaxForts = Math.max(maxForts, right - left - 1);\\n\\t\\t\\tleft = right;\\n\\t\\t}\\n\\n\\treturn maxForts;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int captureForts(int[] forts) {\\n\\tvar n = forts.length;\\n\\tif (n < 3)\\n\\t\\treturn 0;\\n\\n\\tvar maxForts = 0;\\n\\tfor (int left = 0, right = 1; right < n; right++)\\n\\t\\tif (forts[right] != 0) {\\n\\t\\t\\tif (forts[left] == -forts[right])\\n\\t\\t\\t\\tmaxForts = Math.max(maxForts, right - left - 1);\\n\\t\\t\\tleft = right;\\n\\t\\t}\\n\\n\\treturn maxForts;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3177374,
                "title": "optimal-solution-beats-100-python-c-java-python3-c-c",
                "content": "\\n```Java []\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int maxCapture = 0, n = forts.length;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (forts[i] == 1) {\\n                int currMax = 0;\\n                i++;\\n                while (i < n && forts[i] == 0) {\\n                    currMax++;\\n                    i++;\\n                }\\n                if (i < n && forts[i] == -1) maxCapture = Math.max(maxCapture, currMax);\\n                i--;\\n            }\\n            else if (forts[i] == -1) {\\n                int currMax = 0;\\n                i++;\\n                while (i < n && forts[i] == 0) {\\n                    currMax++;\\n                    i++;\\n                }\\n                if (i < n && forts[i] == 1) maxCapture = Math.max(maxCapture, currMax);\\n                i--;\\n            }\\n        }\\n\\n        return maxCapture;\\n    }\\n}\\n// Time complexity: O(n)\\n// Space complexity: O(1)\\n```\\n```python []\\nclass Solution(object):\\n    def captureForts(self, forts):\\n        maxCapture, n = 0, len(forts)\\n\\n        for i in range(0, n):\\n            if forts[i] == 1:\\n                currMax = 0\\n                i += 1\\n                while i < n and forts[i] == 0:\\n                    currMax += 1\\n                    i += 1\\n\\n                if i < n and forts[i] == -1:\\n                    maxCapture = max(currMax, maxCapture)\\n                i -= 1\\n\\n            elif forts[i] == -1:\\n                currMax = 0\\n                i += 1\\n                while i < n and forts[i] == 0:\\n                    currMax += 1\\n                    i += 1\\n                \\n                if i < n and forts[i] == 1:\\n                    maxCapture = max(currMax, maxCapture)\\n                i -= 1\\n        \\n        return maxCapture\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int maxCapture = 0, n = forts.size();\\n\\n        for (int i = 0; i < n; i++) {\\n            if (forts[i] == 1) {\\n                int currMax = 0;\\n                i++;\\n                while (i < n && forts[i] == 0) {\\n                    currMax++;\\n                    i++;\\n                }\\n                if (i < n && forts[i] == -1) maxCapture = max(maxCapture, currMax);\\n                i--;\\n            }\\n            else if (forts[i] == -1) {\\n                int currMax = 0;\\n                i++;\\n                while (i < n && forts[i] == 0) {\\n                    currMax++;\\n                    i++;\\n                }\\n                if (i < n && forts[i] == 1) maxCapture = max(maxCapture, currMax);\\n                i--;\\n            }\\n        }\\n\\n        return maxCapture;\\n    }\\n};\\n// Time complexity: O(n)\\n// Space complexity: O(1)\\n```\\n```C []\\nint captureForts(int* forts, int fortsSize){\\n    int maxCapture = 0;\\n    for (int i = 0; i < fortsSize; i++) {\\n        if (forts[i] == 1) {\\n            int currMax = 0;\\n            i++;\\n            while (i < fortsSize && forts[i] == 0) {\\n                currMax++;\\n                i++;\\n            }\\n            if (i < fortsSize && forts[i] == -1) {\\n                if (maxCapture < currMax) maxCapture = currMax;\\n            }\\n            i--;\\n        }\\n        else if (forts[i] == -1) {\\n            int currMax = 0;\\n            i++;\\n            while (i < fortsSize && forts[i] == 0) {\\n                currMax++;\\n                i++;\\n            }\\n            if (i < fortsSize && forts[i] == 1) {\\n                if (maxCapture < currMax) maxCapture = currMax;\\n            }\\n            i--;\\n        }\\n    }\\n    return maxCapture;\\n}\\n```\\n```python 3[]\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        maxCapture, n = 0, len(forts)\\n\\n        for i in range(0, n):\\n            if forts[i] == 1:\\n                currMax = 0\\n                i += 1\\n                while i < n and forts[i] == 0:\\n                    currMax += 1\\n                    i += 1\\n\\n                if i < n and forts[i] == -1:\\n                    maxCapture = max(currMax, maxCapture)\\n                i -= 1\\n\\n            elif forts[i] == -1:\\n                currMax = 0\\n                i += 1\\n                while i < n and forts[i] == 0:\\n                    currMax += 1\\n                    i += 1\\n                \\n                if i < n and forts[i] == 1:\\n                    maxCapture = max(currMax, maxCapture)\\n                i -= 1\\n        \\n        return maxCapture\\n```\\n```C# []\\npublic class Solution {\\n    public int CaptureForts(int[] forts) {\\n        int maxCapture = 0, n = forts.Length;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (forts[i] == 1) {\\n                int index = i + 1, currMax = 0;\\n                while (index < n && forts[index] == 0) {\\n                    currMax++;\\n                    index++;\\n                }\\n                if (index < n && forts[index] == -1) {\\n                    if (maxCapture < currMax) maxCapture = currMax;\\n                }\\n            }\\n            else if (forts[i] == -1) {\\n                int index = i + 1, currMax = 0;\\n                while (index < n && forts[index] == 0) {\\n                    currMax++;\\n                    index++;\\n                }\\n                if (index < n && forts[index] == 1) {\\n                    if (maxCapture < currMax) maxCapture = currMax;\\n                }\\n            }\\n        }\\n        \\n        return maxCapture;\\n    }\\n}\\n```\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\nPlease Upvote! ->->->\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C#"
                ],
                "code": "```Java []\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int maxCapture = 0, n = forts.length;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (forts[i] == 1) {\\n                int currMax = 0;\\n                i++;\\n                while (i < n && forts[i] == 0) {\\n                    currMax++;\\n                    i++;\\n                }\\n                if (i < n && forts[i] == -1) maxCapture = Math.max(maxCapture, currMax);\\n                i--;\\n            }\\n            else if (forts[i] == -1) {\\n                int currMax = 0;\\n                i++;\\n                while (i < n && forts[i] == 0) {\\n                    currMax++;\\n                    i++;\\n                }\\n                if (i < n && forts[i] == 1) maxCapture = Math.max(maxCapture, currMax);\\n                i--;\\n            }\\n        }\\n\\n        return maxCapture;\\n    }\\n}\\n// Time complexity: O(n)\\n// Space complexity: O(1)\\n```\n```python []\\nclass Solution(object):\\n    def captureForts(self, forts):\\n        maxCapture, n = 0, len(forts)\\n\\n        for i in range(0, n):\\n            if forts[i] == 1:\\n                currMax = 0\\n                i += 1\\n                while i < n and forts[i] == 0:\\n                    currMax += 1\\n                    i += 1\\n\\n                if i < n and forts[i] == -1:\\n                    maxCapture = max(currMax, maxCapture)\\n                i -= 1\\n\\n            elif forts[i] == -1:\\n                currMax = 0\\n                i += 1\\n                while i < n and forts[i] == 0:\\n                    currMax += 1\\n                    i += 1\\n                \\n                if i < n and forts[i] == 1:\\n                    maxCapture = max(currMax, maxCapture)\\n                i -= 1\\n        \\n        return maxCapture\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int maxCapture = 0, n = forts.size();\\n\\n        for (int i = 0; i < n; i++) {\\n            if (forts[i] == 1) {\\n                int currMax = 0;\\n                i++;\\n                while (i < n && forts[i] == 0) {\\n                    currMax++;\\n                    i++;\\n                }\\n                if (i < n && forts[i] == -1) maxCapture = max(maxCapture, currMax);\\n                i--;\\n            }\\n            else if (forts[i] == -1) {\\n                int currMax = 0;\\n                i++;\\n                while (i < n && forts[i] == 0) {\\n                    currMax++;\\n                    i++;\\n                }\\n                if (i < n && forts[i] == 1) maxCapture = max(maxCapture, currMax);\\n                i--;\\n            }\\n        }\\n\\n        return maxCapture;\\n    }\\n};\\n// Time complexity: O(n)\\n// Space complexity: O(1)\\n```\n```C []\\nint captureForts(int* forts, int fortsSize){\\n    int maxCapture = 0;\\n    for (int i = 0; i < fortsSize; i++) {\\n        if (forts[i] == 1) {\\n            int currMax = 0;\\n            i++;\\n            while (i < fortsSize && forts[i] == 0) {\\n                currMax++;\\n                i++;\\n            }\\n            if (i < fortsSize && forts[i] == -1) {\\n                if (maxCapture < currMax) maxCapture = currMax;\\n            }\\n            i--;\\n        }\\n        else if (forts[i] == -1) {\\n            int currMax = 0;\\n            i++;\\n            while (i < fortsSize && forts[i] == 0) {\\n                currMax++;\\n                i++;\\n            }\\n            if (i < fortsSize && forts[i] == 1) {\\n                if (maxCapture < currMax) maxCapture = currMax;\\n            }\\n            i--;\\n        }\\n    }\\n    return maxCapture;\\n}\\n```\n```python 3[]\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        maxCapture, n = 0, len(forts)\\n\\n        for i in range(0, n):\\n            if forts[i] == 1:\\n                currMax = 0\\n                i += 1\\n                while i < n and forts[i] == 0:\\n                    currMax += 1\\n                    i += 1\\n\\n                if i < n and forts[i] == -1:\\n                    maxCapture = max(currMax, maxCapture)\\n                i -= 1\\n\\n            elif forts[i] == -1:\\n                currMax = 0\\n                i += 1\\n                while i < n and forts[i] == 0:\\n                    currMax += 1\\n                    i += 1\\n                \\n                if i < n and forts[i] == 1:\\n                    maxCapture = max(currMax, maxCapture)\\n                i -= 1\\n        \\n        return maxCapture\\n```\n```C# []\\npublic class Solution {\\n    public int CaptureForts(int[] forts) {\\n        int maxCapture = 0, n = forts.Length;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (forts[i] == 1) {\\n                int index = i + 1, currMax = 0;\\n                while (index < n && forts[index] == 0) {\\n                    currMax++;\\n                    index++;\\n                }\\n                if (index < n && forts[index] == -1) {\\n                    if (maxCapture < currMax) maxCapture = currMax;\\n                }\\n            }\\n            else if (forts[i] == -1) {\\n                int index = i + 1, currMax = 0;\\n                while (index < n && forts[index] == 0) {\\n                    currMax++;\\n                    index++;\\n                }\\n                if (index < n && forts[index] == 1) {\\n                    if (maxCapture < currMax) maxCapture = currMax;\\n                }\\n            }\\n        }\\n        \\n        return maxCapture;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176999,
                "title": "easy-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int pos=-1;\\n        int neg=-1;\\n        int maxi=0;\\n        for(int i=0;i<forts.length;++i){\\n            if(forts[i]==1){\\n                pos=i;\\n            }\\n            else if(forts[i]==-1){\\n                neg=i;\\n            }\\n            if(pos>-1 && neg>-1){\\n                maxi=Math.max(maxi,Math.abs(pos-neg)-1);\\n                if(pos<neg){\\n                    pos=-1;\\n                    }\\n                else if(pos>neg){\\n                    neg=-1;\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int pos=-1;\\n        int neg=-1;\\n        int maxi=0;\\n        for(int i=0;i<forts.length;++i){\\n            if(forts[i]==1){\\n                pos=i;\\n            }\\n            else if(forts[i]==-1){\\n                neg=i;\\n            }\\n            if(pos>-1 && neg>-1){\\n                maxi=Math.max(maxi,Math.abs(pos-neg)-1);\\n                if(pos<neg){\\n                    pos=-1;\\n                    }\\n                else if(pos>neg){\\n                    neg=-1;\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176445,
                "title": "explained-question-in-1-line-simple-code-c-o-n",
                "content": "\\n# Approach\\n###### The question simply tells to find the number of zeroes between two non-zero digits (either between -1 to 1 OR 1 to -1).\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int ans=0;\\n        int n = forts.size();\\n//keep 2 pointers i & j\\n        for(int i=0,j=0; j<n; j++)\\n        {\\n        //forts[j] is a non-zero digit\\n            if(forts[j]!=0){\\n//check forts[i] & forts[j] is two different non-zero digits or not\\n                if(forts[i] == -forts[j])\\n                {\\n//every time keep track of maximum.\\n                    ans = max(ans, j-i-1);\\n                }\\n//move i to the position of j. \\n                i = j;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int ans=0;\\n        int n = forts.size();\\n//keep 2 pointers i & j\\n        for(int i=0,j=0; j<n; j++)\\n        {\\n        //forts[j] is a non-zero digit\\n            if(forts[j]!=0){\\n//check forts[i] & forts[j] is two different non-zero digits or not\\n                if(forts[i] == -forts[j])\\n                {\\n//every time keep track of maximum.\\n                    ans = max(ans, j-i-1);\\n                }\\n//move i to the position of j. \\n                i = j;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3168319,
                "title": "best-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        #count 0s between 1 and -1\\n        #for every idx , if 1, go through array until reaches -1 and cnt 0s passed.        Compare 0s to a global variable. if you encounter a 1 before -1, break.\\n        #same but vice versa for -1\\n\\n        maxCnt = 0\\n\\n        for i in range(len(forts)-1):\\n\\n            if forts[i] == 1:\\n\\n                cnt = 0\\n                j=i+1\\n\\n                while forts[j]!=-1 and forts[j]!= 1 and j<len(forts)-1:\\n                    cnt+=1\\n                    j+=1\\n\\n                if forts[j] == -1:\\n                    if cnt > maxCnt:\\n                        maxCnt = cnt\\n            \\n            if forts[i] == -1:\\n\\n                cnt = 0\\n                j=i+1\\n\\n                while forts[j]!=-1 and forts[j]!= 1 and j<len(forts)-1:\\n                    cnt+=1\\n                    j+=1\\n\\n                if forts[j] == 1:\\n                    if cnt > maxCnt:\\n                        maxCnt = cnt\\n            \\n            \\n\\n        return maxCnt\\n                \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        #count 0s between 1 and -1\\n        #for every idx , if 1, go through array until reaches -1 and cnt 0s passed.        Compare 0s to a global variable. if you encounter a 1 before -1, break.\\n        #same but vice versa for -1\\n\\n        maxCnt = 0\\n\\n        for i in range(len(forts)-1):\\n\\n            if forts[i] == 1:\\n\\n                cnt = 0\\n                j=i+1\\n\\n                while forts[j]!=-1 and forts[j]!= 1 and j<len(forts)-1:\\n                    cnt+=1\\n                    j+=1\\n\\n                if forts[j] == -1:\\n                    if cnt > maxCnt:\\n                        maxCnt = cnt\\n            \\n            if forts[i] == -1:\\n\\n                cnt = 0\\n                j=i+1\\n\\n                while forts[j]!=-1 and forts[j]!= 1 and j<len(forts)-1:\\n                    cnt+=1\\n                    j+=1\\n\\n                if forts[j] == 1:\\n                    if cnt > maxCnt:\\n                        maxCnt = cnt\\n            \\n            \\n\\n        return maxCnt\\n                \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163802,
                "title": "python3-o-n-simple",
                "content": "```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        def helper(forts):\\n            res = zeros = 0\\n            prev = -1\\n            for i,el in enumerate(forts):\\n                if el == 1: \\n                    prev = i\\n                    zeros = 0\\n                if el == 0 and prev != -1: zeros += 1\\n                if el == -1:\\n                    res = max(res,zeros)\\n                    zeros = 0\\n                    prev = -1\\n            return res\\n        return max(helper(forts),helper(forts[::-1]))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        def helper(forts):\\n            res = zeros = 0\\n            prev = -1\\n            for i,el in enumerate(forts):\\n                if el == 1: \\n                    prev = i\\n                    zeros = 0\\n                if el == 0 and prev != -1: zeros += 1\\n                if el == -1:\\n                    res = max(res,zeros)\\n                    zeros = 0\\n                    prev = -1\\n            return res\\n        return max(helper(forts),helper(forts[::-1]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3150335,
                "title": "simplistic-java-solution",
                "content": "Quite a simple solution, just uses if else statements and a for loop. Runtime is consistently 0ms. Memory is wildly inconsistent, sometimes it beats 95% of solutions and sometimes only 20%. I bet someone will eventually find a better or cooler solution if they haven\\'t already.\\n\\n# Code\\n```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int consecZeroes = 0; //consecutive zeroes\\n        int mostConsecZeroes = 0; //most consecutive zeroes\\n\\n        for (int i = 1; i < forts.length; i++){ //starts from 1 to avoid index errors\\n            if (forts[i] == 0){\\n                consecZeroes++; //if 0, consec zeroes goes up\\n            }\\n            else {\\n                if (forts[i-consecZeroes-1] == forts[i]*-1){ //Checks to see if the zeroes are \"sandwiched\" between a 1 and a -1\\n                    mostConsecZeroes = Math.max(consecZeroes, mostConsecZeroes);\\n                }\\n                consecZeroes = 0; //resets the counter upon hitting 1 or -1, since that means the zeroes are no longer consecutive\\n            }\\n        }\\n        return mostConsecZeroes;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int consecZeroes = 0; //consecutive zeroes\\n        int mostConsecZeroes = 0; //most consecutive zeroes\\n\\n        for (int i = 1; i < forts.length; i++){ //starts from 1 to avoid index errors\\n            if (forts[i] == 0){\\n                consecZeroes++; //if 0, consec zeroes goes up\\n            }\\n            else {\\n                if (forts[i-consecZeroes-1] == forts[i]*-1){ //Checks to see if the zeroes are \"sandwiched\" between a 1 and a -1\\n                    mostConsecZeroes = Math.max(consecZeroes, mostConsecZeroes);\\n                }\\n                consecZeroes = 0; //resets the counter upon hitting 1 or -1, since that means the zeroes are no longer consecutive\\n            }\\n        }\\n        return mostConsecZeroes;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145917,
                "title": "java-faster-than-100",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int count=0,j=0;\\n        for(int i=0;i<forts.length;)\\n        {\\n            if(forts[i]==1)\\n            {\\n                i++;\\n                while(i<forts.length && forts[i]==0)\\n                {\\n                    j++;\\n                    i++;\\n                }\\n                if(i<forts.length && forts[i]==-1)\\n                {\\n                    count=Math.max(count,j);\\n                }\\n                j=0;\\n            }\\n            else if(forts[i]==-1)\\n            {\\n                i++;\\n                while(i<forts.length && forts[i]==0)\\n                {\\n                    j++;\\n                    i++;\\n                }\\n                if(i<forts.length && forts[i]==1)\\n                {\\n                    count=Math.max(count,j);\\n                }\\n                j=0;\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int captureForts(int[] forts) {\\n        int count=0,j=0;\\n        for(int i=0;i<forts.length;)\\n        {\\n            if(forts[i]==1)\\n            {\\n                i++;\\n                while(i<forts.length && forts[i]==0)\\n                {\\n                    j++;\\n                    i++;\\n                }\\n                if(i<forts.length && forts[i]==-1)\\n                {\\n                    count=Math.max(count,j);\\n                }\\n                j=0;\\n            }\\n            else if(forts[i]==-1)\\n            {\\n                i++;\\n                while(i<forts.length && forts[i]==0)\\n                {\\n                    j++;\\n                    i++;\\n                }\\n                if(i<forts.length && forts[i]==1)\\n                {\\n                    count=Math.max(count,j);\\n                }\\n                j=0;\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3134044,
                "title": "c-2-ptrs",
                "content": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int l = 0, res = 0;\\n        for (int i = l + 1; i < forts.size(); ++i) {\\n            if (forts[i]) {\\n                if (forts[l] * forts[i] < 0) {\\n                    res = max(res, i - l - 1);\\n                }\\n                l = i;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int l = 0, res = 0;\\n        for (int i = l + 1; i < forts.size(); ++i) {\\n            if (forts[i]) {\\n                if (forts[l] * forts[i] < 0) {\\n                    res = max(res, i - l - 1);\\n                }\\n                l = i;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3133945,
                "title": "o-n-solution-beats-99-3-in-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nyou only have to count the zero\\'s if they occur between 1 and -1.\\nso, when you encounter 1 or -1, check if you have already traversed\\na -1 or 1.\\n\\nIf yes, update your result variable with Maximum value. Otherwise, do nothing.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} forts\\n * @return {number}\\n */\\nvar captureForts = function(forts) {\\n\\n    let count = 0;\\n    let result = 0;\\n    let a = false;\\n    let b = false;\\n    for(let i = 0; i < forts.length; i++) {\\n        if(forts[i] === 1) {\\n            if(b) {\\n                result = Math.max(result, count);\\n            }\\n            a = true;\\n            b = false;\\n            count = 0;\\n        } else if (forts[i] === -1) {\\n            if(a) {\\n                result = Math.max(result, count);\\n            }\\n                count = 0;\\n                a = false;\\n                b = true;\\n        } else {\\n            count++;\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} forts\\n * @return {number}\\n */\\nvar captureForts = function(forts) {\\n\\n    let count = 0;\\n    let result = 0;\\n    let a = false;\\n    let b = false;\\n    for(let i = 0; i < forts.length; i++) {\\n        if(forts[i] === 1) {\\n            if(b) {\\n                result = Math.max(result, count);\\n            }\\n            a = true;\\n            b = false;\\n            count = 0;\\n        } else if (forts[i] === -1) {\\n            if(a) {\\n                result = Math.max(result, count);\\n            }\\n                count = 0;\\n                a = false;\\n                b = true;\\n        } else {\\n            count++;\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3131066,
                "title": "simple-single-iteration-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n\\n        n = len(forts)\\n        i = 0\\n        x = False\\n        y = False\\n        ans = 0\\n        temp = 0\\n\\n        while i < n:\\n            if forts[i] == 1:\\n                if y:\\n                    ans = max(ans , temp)\\n                    y = False\\n                    x = True\\n                else:\\n                    x = True\\n                temp = 0\\n            elif forts[i] == -1:\\n                if x:\\n                    ans = max(ans , temp)\\n                    x = False\\n                    y = True\\n                else:\\n                    y = True\\n                temp = 0\\n            else:\\n                temp += 1\\n            i += 1\\n        \\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n\\n        n = len(forts)\\n        i = 0\\n        x = False\\n        y = False\\n        ans = 0\\n        temp = 0\\n\\n        while i < n:\\n            if forts[i] == 1:\\n                if y:\\n                    ans = max(ans , temp)\\n                    y = False\\n                    x = True\\n                else:\\n                    x = True\\n                temp = 0\\n            elif forts[i] == -1:\\n                if x:\\n                    ans = max(ans , temp)\\n                    x = False\\n                    y = True\\n                else:\\n                    y = True\\n                temp = 0\\n            else:\\n                temp += 1\\n            i += 1\\n        \\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3129069,
                "title": "swift-one-liner",
                "content": "**One-Liner, terse (accepted answer)**\\n```\\nclass Solution {\\n    func captureForts(_ forts: [Int]) -> Int {\\n        forts.enumerated().reduce((0, (0,0))) {a,b in (max(a.0,-b.1*a.1.1*(b.0-a.1.0-1)),b.1==0 ? a.1:b)}.0\\n    }\\n}\\n```\\n\\n---\\n\\n**One-Liner approach, expanded and annotated (accepted answer)**\\n```\\nclass Solution {\\n    func captureForts(_ forts: [Int]) -> Int {\\n        forts.enumerated()\\n            .filter { tuple in tuple.element != 0 }\\n            .reduce((\\n                result: 0, \\n                prev: (offset: 0, element: 0)\\n            )) { data, tuple in\\n                let (offset, element) = tuple\\n                var newResult = 0\\n                if element == -1 * data.prev.element {\\n                    newResult = offset - data.prev.offset - 1\\n                }\\n                return (\\n                    result: max(data.result, newResult),\\n                    prev: tuple\\n                )\\n            }.result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func captureForts(_ forts: [Int]) -> Int {\\n        forts.enumerated().reduce((0, (0,0))) {a,b in (max(a.0,-b.1*a.1.1*(b.0-a.1.0-1)),b.1==0 ? a.1:b)}.0\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func captureForts(_ forts: [Int]) -> Int {\\n        forts.enumerated()\\n            .filter { tuple in tuple.element != 0 }\\n            .reduce((\\n                result: 0, \\n                prev: (offset: 0, element: 0)\\n            )) { data, tuple in\\n                let (offset, element) = tuple\\n                var newResult = 0\\n                if element == -1 * data.prev.element {\\n                    newResult = offset - data.prev.offset - 1\\n                }\\n                return (\\n                    result: max(data.result, newResult),\\n                    prev: tuple\\n                )\\n            }.result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3127897,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) \\n    {\\n        int cnt=0;\\n        int mx=0;\\n        \\n        for(int i=0;i<forts.size();i++)\\n        {\\n            if(forts[i]==1)\\n            {\\n                \\n                for(int j=i-1;j>=0;j--)\\n                {\\n                    if(forts[j]==0)\\n                    {\\n                        cnt++;\\n                    }\\n                    else if(forts[j]==-1)\\n                    {\\n                        mx = max(mx,cnt);\\n                        cnt=0;\\n                        break;\\n                    }\\n                    else\\n                    {\\n                        break;\\n                    }\\n                }\\n                \\n                \\n                cnt=0;\\n                for(int j=i+1;j<forts.size();j++)\\n                {\\n                    if(forts[j]==0)\\n                    {\\n                        cnt++;\\n                    }\\n                    else if(forts[j]==-1)\\n                    {\\n                        mx = max(mx,cnt);\\n                        cnt=0;\\n                        break;\\n                    }\\n                    else\\n                    {\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) \\n    {\\n        int cnt=0;\\n        int mx=0;\\n        \\n        for(int i=0;i<forts.size();i++)\\n        {\\n            if(forts[i]==1)\\n            {\\n                \\n                for(int j=i-1;j>=0;j--)\\n                {\\n                    if(forts[j]==0)\\n                    {\\n                        cnt++;\\n                    }\\n                    else if(forts[j]==-1)\\n                    {\\n                        mx = max(mx,cnt);\\n                        cnt=0;\\n                        break;\\n                    }\\n                    else\\n                    {\\n                        break;\\n                    }\\n                }\\n                \\n                \\n                cnt=0;\\n                for(int j=i+1;j<forts.size();j++)\\n                {\\n                    if(forts[j]==0)\\n                    {\\n                        cnt++;\\n                    }\\n                    else if(forts[j]==-1)\\n                    {\\n                        mx = max(mx,cnt);\\n                        cnt=0;\\n                        break;\\n                    }\\n                    else\\n                    {\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118950,
                "title": "rust",
                "content": "```\\nimpl Solution {\\n    pub fn capture_forts(forts: Vec<i32>) -> i32 {\\n        let (mut pre, mut cnt, mut res) = (0,0,0);\\n        for x in forts{\\n            match x{\\n                0 => cnt += 1,\\n                _ => {\\n                    if x == -pre {\\n                        res = res.max(cnt);\\n                    }\\n                    cnt = 0;\\n                    pre = x;\\n                }\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn capture_forts(forts: Vec<i32>) -> i32 {\\n        let (mut pre, mut cnt, mut res) = (0,0,0);\\n        for x in forts{\\n            match x{\\n                0 => cnt += 1,\\n                _ => {\\n                    if x == -pre {\\n                        res = res.max(cnt);\\n                    }\\n                    cnt = 0;\\n                    pre = x;\\n                }\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3117077,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func captureForts(_ forts: [Int]) -> Int {\\n\\n        var res = 0\\n\\n        func go(_ frts: [Int]) {\\n            var buf = -1\\n\\n            for f in frts {\\n                switch (buf, f) {\\n                case (_, 1): buf = 0\\n                case (0..., 0): buf += 1\\n                default: res = max(res, buf); buf = -1\\n                }\\n            }\\n        }\\n\\n        go(forts)\\n        go(forts.reversed())\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func captureForts(_ forts: [Int]) -> Int {\\n\\n        var res = 0\\n\\n        func go(_ frts: [Int]) {\\n            var buf = -1\\n\\n            for f in frts {\\n                switch (buf, f) {\\n                case (_, 1): buf = 0\\n                case (0..., 0): buf += 1\\n                default: res = max(res, buf); buf = -1\\n                }\\n            }\\n        }\\n\\n        go(forts)\\n        go(forts.reversed())\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116440,
                "title": "python-count-the-number-of-zeros-between-two-opposite-1s",
                "content": "We can move on two directions. Thus, just need to count the number of 0s between two opposite 1s.\\n\\n```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        zeros, ans, priv, count = 0, 0, None, False\\n        for f in forts:\\n            if f == 0 and count:\\n                zeros += 1\\n            \\n            if f != 0:\\n                count = True\\n                if priv and f != priv:\\n                    if zeros > ans:\\n                        ans = zeros\\n                zeros = 0\\n                priv = f\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def captureForts(self, forts: List[int]) -> int:\\n        zeros, ans, priv, count = 0, 0, None, False\\n        for f in forts:\\n            if f == 0 and count:\\n                zeros += 1\\n            \\n            if f != 0:\\n                count = True\\n                if priv and f != priv:\\n                    if zeros > ans:\\n                        ans = zeros\\n                zeros = 0\\n                priv = f\\n        return ans\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1727158,
                "content": [
                    {
                        "username": "b1ron",
                        "content": "The description alone makes this a medium. "
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Dude you deserve more upvotes."
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "**For those having trouble understanding the description:**\\n\\nThe army must move from their own fort, designated as the #1,  to an empty fort, designated as #-1. In the process of this movement, any enemy forts, designated as #0, can be captured. You must count the maximum number of enemy forts captured  while moving from your own fort(1) to an empty fort(-1).\\n\\nIf you capture 8 enemy forts, but reach the end of the array, having never landed at an empty fort(-1), your captures are invalid and the result is 0. Once you land at an empty fort(-1), your army is finished with those captures, and must start a new collection to proceed in the current direction.\\n\\nHope that helps. It\\'s a fun problem, but  poorly worded."
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Thanks buddy for the explanation."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Problem description is too complicated. We just need to find the maximum contiguous zeroes between 1 and -1 or between -1 and 1. We can use a variation of Kadane's algorithm."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "This is the most annoying problem I have ever solved in a contest."
                    },
                    {
                        "username": "withrvr",
                        "content": "## Problem description is too complicated.\n- We just need to find the maximum contiguous zeroes\n- between 1 & -1 ... or ... -1 & 1.\n"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "See in order to move your army you must have a fort under your command. So take a look at the first example forts = [1,0,0,-1,0,0,0,0,1] here you can move from index = 0 to index = 3. In this traversal you will capture two enemy forts and land your army at such a place where you are having no fort. So travelling from that index = 3 will not be possible because the army needs a fort under their command to proceed further. Now take a look at the last index = 8 from there you can take your army to the index = 3 in that traversal you will be capturing 4 forts that is greater than 2 forts. So you have to return the maximum number of forts that you can capture.\\nI hope you have got the idea."
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "To me , this doesn\\'t seem to be an easy question , more like a medium at the least."
                    },
                    {
                        "username": "anubhaaa",
                        "content": "Where are the tags for this question."
                    },
                    {
                        "username": "no-username",
                        "content": "`1,-1,0,0,0,-1,0,-1,0,0,0,0,0,0,0,0,-1,-1,1,1` \\n\\nWhat should be result in above case? 3 or 8?"
                    },
                    {
                        "username": "NitishKumarVerma",
                        "content": "the ans will be 0, as the army can move only for enemy fort( i.e.) and should start from 1 and end at -1. "
                    },
                    {
                        "username": "_srahul_",
                        "content": "It would 0, as we\\'re asked to return maximum number of enemies forts conquered from -1(empty fort) to 1(one of our fort).\\nShortly maximum no. of 0\\'s , between -1 and 1.\\nProblem statement is pretty complicated, I can agree upon that.\\nBy the way, here is my code just in case you\\'re looking for one:\\nhttps://leetcode.com/problems/maximum-enemy-forts-that-can-be-captured/solutions/2946832/o-n-time-100-faster/?orderBy=most_votes"
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "Problem description has a typo in example 1.\\n\\n\"- Moving the army from position 8 to position 3 captures 4 enemy forts.\"\\nThe 8 and the 3 are reversed. It should be.\\n\"- Moving the army from position 3 to position 8 captures 4 enemy forts.\""
                    },
                    {
                        "username": "Mike_2233",
                        "content": "[-1,-1,0,1,0,0,1,-1,1,0] - expected:1 \\n\\nWrong test case answer. You can 100% see its to, from index 3 - 6 we have 2 forts that can be captured. Why does leetcode have wrong testcases?\\n"
                    },
                    {
                        "username": "arkdev9",
                        "content": "You cannot have your own fort in the way I believe. Though this is not mentioned as a constraint in the problem. Poorly worded."
                    }
                ]
            },
            {
                "id": 1728141,
                "content": [
                    {
                        "username": "b1ron",
                        "content": "The description alone makes this a medium. "
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Dude you deserve more upvotes."
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "**For those having trouble understanding the description:**\\n\\nThe army must move from their own fort, designated as the #1,  to an empty fort, designated as #-1. In the process of this movement, any enemy forts, designated as #0, can be captured. You must count the maximum number of enemy forts captured  while moving from your own fort(1) to an empty fort(-1).\\n\\nIf you capture 8 enemy forts, but reach the end of the array, having never landed at an empty fort(-1), your captures are invalid and the result is 0. Once you land at an empty fort(-1), your army is finished with those captures, and must start a new collection to proceed in the current direction.\\n\\nHope that helps. It\\'s a fun problem, but  poorly worded."
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Thanks buddy for the explanation."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Problem description is too complicated. We just need to find the maximum contiguous zeroes between 1 and -1 or between -1 and 1. We can use a variation of Kadane's algorithm."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "This is the most annoying problem I have ever solved in a contest."
                    },
                    {
                        "username": "withrvr",
                        "content": "## Problem description is too complicated.\n- We just need to find the maximum contiguous zeroes\n- between 1 & -1 ... or ... -1 & 1.\n"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "See in order to move your army you must have a fort under your command. So take a look at the first example forts = [1,0,0,-1,0,0,0,0,1] here you can move from index = 0 to index = 3. In this traversal you will capture two enemy forts and land your army at such a place where you are having no fort. So travelling from that index = 3 will not be possible because the army needs a fort under their command to proceed further. Now take a look at the last index = 8 from there you can take your army to the index = 3 in that traversal you will be capturing 4 forts that is greater than 2 forts. So you have to return the maximum number of forts that you can capture.\\nI hope you have got the idea."
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "To me , this doesn\\'t seem to be an easy question , more like a medium at the least."
                    },
                    {
                        "username": "anubhaaa",
                        "content": "Where are the tags for this question."
                    },
                    {
                        "username": "no-username",
                        "content": "`1,-1,0,0,0,-1,0,-1,0,0,0,0,0,0,0,0,-1,-1,1,1` \\n\\nWhat should be result in above case? 3 or 8?"
                    },
                    {
                        "username": "NitishKumarVerma",
                        "content": "the ans will be 0, as the army can move only for enemy fort( i.e.) and should start from 1 and end at -1. "
                    },
                    {
                        "username": "_srahul_",
                        "content": "It would 0, as we\\'re asked to return maximum number of enemies forts conquered from -1(empty fort) to 1(one of our fort).\\nShortly maximum no. of 0\\'s , between -1 and 1.\\nProblem statement is pretty complicated, I can agree upon that.\\nBy the way, here is my code just in case you\\'re looking for one:\\nhttps://leetcode.com/problems/maximum-enemy-forts-that-can-be-captured/solutions/2946832/o-n-time-100-faster/?orderBy=most_votes"
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "Problem description has a typo in example 1.\\n\\n\"- Moving the army from position 8 to position 3 captures 4 enemy forts.\"\\nThe 8 and the 3 are reversed. It should be.\\n\"- Moving the army from position 3 to position 8 captures 4 enemy forts.\""
                    },
                    {
                        "username": "Mike_2233",
                        "content": "[-1,-1,0,1,0,0,1,-1,1,0] - expected:1 \\n\\nWrong test case answer. You can 100% see its to, from index 3 - 6 we have 2 forts that can be captured. Why does leetcode have wrong testcases?\\n"
                    },
                    {
                        "username": "arkdev9",
                        "content": "You cannot have your own fort in the way I believe. Though this is not mentioned as a constraint in the problem. Poorly worded."
                    }
                ]
            },
            {
                "id": 1727139,
                "content": [
                    {
                        "username": "b1ron",
                        "content": "The description alone makes this a medium. "
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Dude you deserve more upvotes."
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "**For those having trouble understanding the description:**\\n\\nThe army must move from their own fort, designated as the #1,  to an empty fort, designated as #-1. In the process of this movement, any enemy forts, designated as #0, can be captured. You must count the maximum number of enemy forts captured  while moving from your own fort(1) to an empty fort(-1).\\n\\nIf you capture 8 enemy forts, but reach the end of the array, having never landed at an empty fort(-1), your captures are invalid and the result is 0. Once you land at an empty fort(-1), your army is finished with those captures, and must start a new collection to proceed in the current direction.\\n\\nHope that helps. It\\'s a fun problem, but  poorly worded."
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Thanks buddy for the explanation."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Problem description is too complicated. We just need to find the maximum contiguous zeroes between 1 and -1 or between -1 and 1. We can use a variation of Kadane's algorithm."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "This is the most annoying problem I have ever solved in a contest."
                    },
                    {
                        "username": "withrvr",
                        "content": "## Problem description is too complicated.\n- We just need to find the maximum contiguous zeroes\n- between 1 & -1 ... or ... -1 & 1.\n"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "See in order to move your army you must have a fort under your command. So take a look at the first example forts = [1,0,0,-1,0,0,0,0,1] here you can move from index = 0 to index = 3. In this traversal you will capture two enemy forts and land your army at such a place where you are having no fort. So travelling from that index = 3 will not be possible because the army needs a fort under their command to proceed further. Now take a look at the last index = 8 from there you can take your army to the index = 3 in that traversal you will be capturing 4 forts that is greater than 2 forts. So you have to return the maximum number of forts that you can capture.\\nI hope you have got the idea."
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "To me , this doesn\\'t seem to be an easy question , more like a medium at the least."
                    },
                    {
                        "username": "anubhaaa",
                        "content": "Where are the tags for this question."
                    },
                    {
                        "username": "no-username",
                        "content": "`1,-1,0,0,0,-1,0,-1,0,0,0,0,0,0,0,0,-1,-1,1,1` \\n\\nWhat should be result in above case? 3 or 8?"
                    },
                    {
                        "username": "NitishKumarVerma",
                        "content": "the ans will be 0, as the army can move only for enemy fort( i.e.) and should start from 1 and end at -1. "
                    },
                    {
                        "username": "_srahul_",
                        "content": "It would 0, as we\\'re asked to return maximum number of enemies forts conquered from -1(empty fort) to 1(one of our fort).\\nShortly maximum no. of 0\\'s , between -1 and 1.\\nProblem statement is pretty complicated, I can agree upon that.\\nBy the way, here is my code just in case you\\'re looking for one:\\nhttps://leetcode.com/problems/maximum-enemy-forts-that-can-be-captured/solutions/2946832/o-n-time-100-faster/?orderBy=most_votes"
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "Problem description has a typo in example 1.\\n\\n\"- Moving the army from position 8 to position 3 captures 4 enemy forts.\"\\nThe 8 and the 3 are reversed. It should be.\\n\"- Moving the army from position 3 to position 8 captures 4 enemy forts.\""
                    },
                    {
                        "username": "Mike_2233",
                        "content": "[-1,-1,0,1,0,0,1,-1,1,0] - expected:1 \\n\\nWrong test case answer. You can 100% see its to, from index 3 - 6 we have 2 forts that can be captured. Why does leetcode have wrong testcases?\\n"
                    },
                    {
                        "username": "arkdev9",
                        "content": "You cannot have your own fort in the way I believe. Though this is not mentioned as a constraint in the problem. Poorly worded."
                    }
                ]
            },
            {
                "id": 1743422,
                "content": [
                    {
                        "username": "b1ron",
                        "content": "The description alone makes this a medium. "
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Dude you deserve more upvotes."
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "**For those having trouble understanding the description:**\\n\\nThe army must move from their own fort, designated as the #1,  to an empty fort, designated as #-1. In the process of this movement, any enemy forts, designated as #0, can be captured. You must count the maximum number of enemy forts captured  while moving from your own fort(1) to an empty fort(-1).\\n\\nIf you capture 8 enemy forts, but reach the end of the array, having never landed at an empty fort(-1), your captures are invalid and the result is 0. Once you land at an empty fort(-1), your army is finished with those captures, and must start a new collection to proceed in the current direction.\\n\\nHope that helps. It\\'s a fun problem, but  poorly worded."
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Thanks buddy for the explanation."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Problem description is too complicated. We just need to find the maximum contiguous zeroes between 1 and -1 or between -1 and 1. We can use a variation of Kadane's algorithm."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "This is the most annoying problem I have ever solved in a contest."
                    },
                    {
                        "username": "withrvr",
                        "content": "## Problem description is too complicated.\n- We just need to find the maximum contiguous zeroes\n- between 1 & -1 ... or ... -1 & 1.\n"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "See in order to move your army you must have a fort under your command. So take a look at the first example forts = [1,0,0,-1,0,0,0,0,1] here you can move from index = 0 to index = 3. In this traversal you will capture two enemy forts and land your army at such a place where you are having no fort. So travelling from that index = 3 will not be possible because the army needs a fort under their command to proceed further. Now take a look at the last index = 8 from there you can take your army to the index = 3 in that traversal you will be capturing 4 forts that is greater than 2 forts. So you have to return the maximum number of forts that you can capture.\\nI hope you have got the idea."
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "To me , this doesn\\'t seem to be an easy question , more like a medium at the least."
                    },
                    {
                        "username": "anubhaaa",
                        "content": "Where are the tags for this question."
                    },
                    {
                        "username": "no-username",
                        "content": "`1,-1,0,0,0,-1,0,-1,0,0,0,0,0,0,0,0,-1,-1,1,1` \\n\\nWhat should be result in above case? 3 or 8?"
                    },
                    {
                        "username": "NitishKumarVerma",
                        "content": "the ans will be 0, as the army can move only for enemy fort( i.e.) and should start from 1 and end at -1. "
                    },
                    {
                        "username": "_srahul_",
                        "content": "It would 0, as we\\'re asked to return maximum number of enemies forts conquered from -1(empty fort) to 1(one of our fort).\\nShortly maximum no. of 0\\'s , between -1 and 1.\\nProblem statement is pretty complicated, I can agree upon that.\\nBy the way, here is my code just in case you\\'re looking for one:\\nhttps://leetcode.com/problems/maximum-enemy-forts-that-can-be-captured/solutions/2946832/o-n-time-100-faster/?orderBy=most_votes"
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "Problem description has a typo in example 1.\\n\\n\"- Moving the army from position 8 to position 3 captures 4 enemy forts.\"\\nThe 8 and the 3 are reversed. It should be.\\n\"- Moving the army from position 3 to position 8 captures 4 enemy forts.\""
                    },
                    {
                        "username": "Mike_2233",
                        "content": "[-1,-1,0,1,0,0,1,-1,1,0] - expected:1 \\n\\nWrong test case answer. You can 100% see its to, from index 3 - 6 we have 2 forts that can be captured. Why does leetcode have wrong testcases?\\n"
                    },
                    {
                        "username": "arkdev9",
                        "content": "You cannot have your own fort in the way I believe. Though this is not mentioned as a constraint in the problem. Poorly worded."
                    }
                ]
            },
            {
                "id": 1728098,
                "content": [
                    {
                        "username": "b1ron",
                        "content": "The description alone makes this a medium. "
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Dude you deserve more upvotes."
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "**For those having trouble understanding the description:**\\n\\nThe army must move from their own fort, designated as the #1,  to an empty fort, designated as #-1. In the process of this movement, any enemy forts, designated as #0, can be captured. You must count the maximum number of enemy forts captured  while moving from your own fort(1) to an empty fort(-1).\\n\\nIf you capture 8 enemy forts, but reach the end of the array, having never landed at an empty fort(-1), your captures are invalid and the result is 0. Once you land at an empty fort(-1), your army is finished with those captures, and must start a new collection to proceed in the current direction.\\n\\nHope that helps. It\\'s a fun problem, but  poorly worded."
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Thanks buddy for the explanation."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Problem description is too complicated. We just need to find the maximum contiguous zeroes between 1 and -1 or between -1 and 1. We can use a variation of Kadane's algorithm."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "This is the most annoying problem I have ever solved in a contest."
                    },
                    {
                        "username": "withrvr",
                        "content": "## Problem description is too complicated.\n- We just need to find the maximum contiguous zeroes\n- between 1 & -1 ... or ... -1 & 1.\n"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "See in order to move your army you must have a fort under your command. So take a look at the first example forts = [1,0,0,-1,0,0,0,0,1] here you can move from index = 0 to index = 3. In this traversal you will capture two enemy forts and land your army at such a place where you are having no fort. So travelling from that index = 3 will not be possible because the army needs a fort under their command to proceed further. Now take a look at the last index = 8 from there you can take your army to the index = 3 in that traversal you will be capturing 4 forts that is greater than 2 forts. So you have to return the maximum number of forts that you can capture.\\nI hope you have got the idea."
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "To me , this doesn\\'t seem to be an easy question , more like a medium at the least."
                    },
                    {
                        "username": "anubhaaa",
                        "content": "Where are the tags for this question."
                    },
                    {
                        "username": "no-username",
                        "content": "`1,-1,0,0,0,-1,0,-1,0,0,0,0,0,0,0,0,-1,-1,1,1` \\n\\nWhat should be result in above case? 3 or 8?"
                    },
                    {
                        "username": "NitishKumarVerma",
                        "content": "the ans will be 0, as the army can move only for enemy fort( i.e.) and should start from 1 and end at -1. "
                    },
                    {
                        "username": "_srahul_",
                        "content": "It would 0, as we\\'re asked to return maximum number of enemies forts conquered from -1(empty fort) to 1(one of our fort).\\nShortly maximum no. of 0\\'s , between -1 and 1.\\nProblem statement is pretty complicated, I can agree upon that.\\nBy the way, here is my code just in case you\\'re looking for one:\\nhttps://leetcode.com/problems/maximum-enemy-forts-that-can-be-captured/solutions/2946832/o-n-time-100-faster/?orderBy=most_votes"
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "Problem description has a typo in example 1.\\n\\n\"- Moving the army from position 8 to position 3 captures 4 enemy forts.\"\\nThe 8 and the 3 are reversed. It should be.\\n\"- Moving the army from position 3 to position 8 captures 4 enemy forts.\""
                    },
                    {
                        "username": "Mike_2233",
                        "content": "[-1,-1,0,1,0,0,1,-1,1,0] - expected:1 \\n\\nWrong test case answer. You can 100% see its to, from index 3 - 6 we have 2 forts that can be captured. Why does leetcode have wrong testcases?\\n"
                    },
                    {
                        "username": "arkdev9",
                        "content": "You cannot have your own fort in the way I believe. Though this is not mentioned as a constraint in the problem. Poorly worded."
                    }
                ]
            },
            {
                "id": 1790451,
                "content": [
                    {
                        "username": "b1ron",
                        "content": "The description alone makes this a medium. "
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Dude you deserve more upvotes."
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "**For those having trouble understanding the description:**\\n\\nThe army must move from their own fort, designated as the #1,  to an empty fort, designated as #-1. In the process of this movement, any enemy forts, designated as #0, can be captured. You must count the maximum number of enemy forts captured  while moving from your own fort(1) to an empty fort(-1).\\n\\nIf you capture 8 enemy forts, but reach the end of the array, having never landed at an empty fort(-1), your captures are invalid and the result is 0. Once you land at an empty fort(-1), your army is finished with those captures, and must start a new collection to proceed in the current direction.\\n\\nHope that helps. It\\'s a fun problem, but  poorly worded."
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Thanks buddy for the explanation."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Problem description is too complicated. We just need to find the maximum contiguous zeroes between 1 and -1 or between -1 and 1. We can use a variation of Kadane's algorithm."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "This is the most annoying problem I have ever solved in a contest."
                    },
                    {
                        "username": "withrvr",
                        "content": "## Problem description is too complicated.\n- We just need to find the maximum contiguous zeroes\n- between 1 & -1 ... or ... -1 & 1.\n"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "See in order to move your army you must have a fort under your command. So take a look at the first example forts = [1,0,0,-1,0,0,0,0,1] here you can move from index = 0 to index = 3. In this traversal you will capture two enemy forts and land your army at such a place where you are having no fort. So travelling from that index = 3 will not be possible because the army needs a fort under their command to proceed further. Now take a look at the last index = 8 from there you can take your army to the index = 3 in that traversal you will be capturing 4 forts that is greater than 2 forts. So you have to return the maximum number of forts that you can capture.\\nI hope you have got the idea."
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "To me , this doesn\\'t seem to be an easy question , more like a medium at the least."
                    },
                    {
                        "username": "anubhaaa",
                        "content": "Where are the tags for this question."
                    },
                    {
                        "username": "no-username",
                        "content": "`1,-1,0,0,0,-1,0,-1,0,0,0,0,0,0,0,0,-1,-1,1,1` \\n\\nWhat should be result in above case? 3 or 8?"
                    },
                    {
                        "username": "NitishKumarVerma",
                        "content": "the ans will be 0, as the army can move only for enemy fort( i.e.) and should start from 1 and end at -1. "
                    },
                    {
                        "username": "_srahul_",
                        "content": "It would 0, as we\\'re asked to return maximum number of enemies forts conquered from -1(empty fort) to 1(one of our fort).\\nShortly maximum no. of 0\\'s , between -1 and 1.\\nProblem statement is pretty complicated, I can agree upon that.\\nBy the way, here is my code just in case you\\'re looking for one:\\nhttps://leetcode.com/problems/maximum-enemy-forts-that-can-be-captured/solutions/2946832/o-n-time-100-faster/?orderBy=most_votes"
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "Problem description has a typo in example 1.\\n\\n\"- Moving the army from position 8 to position 3 captures 4 enemy forts.\"\\nThe 8 and the 3 are reversed. It should be.\\n\"- Moving the army from position 3 to position 8 captures 4 enemy forts.\""
                    },
                    {
                        "username": "Mike_2233",
                        "content": "[-1,-1,0,1,0,0,1,-1,1,0] - expected:1 \\n\\nWrong test case answer. You can 100% see its to, from index 3 - 6 we have 2 forts that can be captured. Why does leetcode have wrong testcases?\\n"
                    },
                    {
                        "username": "arkdev9",
                        "content": "You cannot have your own fort in the way I believe. Though this is not mentioned as a constraint in the problem. Poorly worded."
                    }
                ]
            },
            {
                "id": 1726991,
                "content": [
                    {
                        "username": "b1ron",
                        "content": "The description alone makes this a medium. "
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Dude you deserve more upvotes."
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "**For those having trouble understanding the description:**\\n\\nThe army must move from their own fort, designated as the #1,  to an empty fort, designated as #-1. In the process of this movement, any enemy forts, designated as #0, can be captured. You must count the maximum number of enemy forts captured  while moving from your own fort(1) to an empty fort(-1).\\n\\nIf you capture 8 enemy forts, but reach the end of the array, having never landed at an empty fort(-1), your captures are invalid and the result is 0. Once you land at an empty fort(-1), your army is finished with those captures, and must start a new collection to proceed in the current direction.\\n\\nHope that helps. It\\'s a fun problem, but  poorly worded."
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Thanks buddy for the explanation."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Problem description is too complicated. We just need to find the maximum contiguous zeroes between 1 and -1 or between -1 and 1. We can use a variation of Kadane's algorithm."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "This is the most annoying problem I have ever solved in a contest."
                    },
                    {
                        "username": "withrvr",
                        "content": "## Problem description is too complicated.\n- We just need to find the maximum contiguous zeroes\n- between 1 & -1 ... or ... -1 & 1.\n"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "See in order to move your army you must have a fort under your command. So take a look at the first example forts = [1,0,0,-1,0,0,0,0,1] here you can move from index = 0 to index = 3. In this traversal you will capture two enemy forts and land your army at such a place where you are having no fort. So travelling from that index = 3 will not be possible because the army needs a fort under their command to proceed further. Now take a look at the last index = 8 from there you can take your army to the index = 3 in that traversal you will be capturing 4 forts that is greater than 2 forts. So you have to return the maximum number of forts that you can capture.\\nI hope you have got the idea."
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "To me , this doesn\\'t seem to be an easy question , more like a medium at the least."
                    },
                    {
                        "username": "anubhaaa",
                        "content": "Where are the tags for this question."
                    },
                    {
                        "username": "no-username",
                        "content": "`1,-1,0,0,0,-1,0,-1,0,0,0,0,0,0,0,0,-1,-1,1,1` \\n\\nWhat should be result in above case? 3 or 8?"
                    },
                    {
                        "username": "NitishKumarVerma",
                        "content": "the ans will be 0, as the army can move only for enemy fort( i.e.) and should start from 1 and end at -1. "
                    },
                    {
                        "username": "_srahul_",
                        "content": "It would 0, as we\\'re asked to return maximum number of enemies forts conquered from -1(empty fort) to 1(one of our fort).\\nShortly maximum no. of 0\\'s , between -1 and 1.\\nProblem statement is pretty complicated, I can agree upon that.\\nBy the way, here is my code just in case you\\'re looking for one:\\nhttps://leetcode.com/problems/maximum-enemy-forts-that-can-be-captured/solutions/2946832/o-n-time-100-faster/?orderBy=most_votes"
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "Problem description has a typo in example 1.\\n\\n\"- Moving the army from position 8 to position 3 captures 4 enemy forts.\"\\nThe 8 and the 3 are reversed. It should be.\\n\"- Moving the army from position 3 to position 8 captures 4 enemy forts.\""
                    },
                    {
                        "username": "Mike_2233",
                        "content": "[-1,-1,0,1,0,0,1,-1,1,0] - expected:1 \\n\\nWrong test case answer. You can 100% see its to, from index 3 - 6 we have 2 forts that can be captured. Why does leetcode have wrong testcases?\\n"
                    },
                    {
                        "username": "arkdev9",
                        "content": "You cannot have your own fort in the way I believe. Though this is not mentioned as a constraint in the problem. Poorly worded."
                    }
                ]
            },
            {
                "id": 1726863,
                "content": [
                    {
                        "username": "b1ron",
                        "content": "The description alone makes this a medium. "
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Dude you deserve more upvotes."
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "**For those having trouble understanding the description:**\\n\\nThe army must move from their own fort, designated as the #1,  to an empty fort, designated as #-1. In the process of this movement, any enemy forts, designated as #0, can be captured. You must count the maximum number of enemy forts captured  while moving from your own fort(1) to an empty fort(-1).\\n\\nIf you capture 8 enemy forts, but reach the end of the array, having never landed at an empty fort(-1), your captures are invalid and the result is 0. Once you land at an empty fort(-1), your army is finished with those captures, and must start a new collection to proceed in the current direction.\\n\\nHope that helps. It\\'s a fun problem, but  poorly worded."
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Thanks buddy for the explanation."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Problem description is too complicated. We just need to find the maximum contiguous zeroes between 1 and -1 or between -1 and 1. We can use a variation of Kadane's algorithm."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "This is the most annoying problem I have ever solved in a contest."
                    },
                    {
                        "username": "withrvr",
                        "content": "## Problem description is too complicated.\n- We just need to find the maximum contiguous zeroes\n- between 1 & -1 ... or ... -1 & 1.\n"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "See in order to move your army you must have a fort under your command. So take a look at the first example forts = [1,0,0,-1,0,0,0,0,1] here you can move from index = 0 to index = 3. In this traversal you will capture two enemy forts and land your army at such a place where you are having no fort. So travelling from that index = 3 will not be possible because the army needs a fort under their command to proceed further. Now take a look at the last index = 8 from there you can take your army to the index = 3 in that traversal you will be capturing 4 forts that is greater than 2 forts. So you have to return the maximum number of forts that you can capture.\\nI hope you have got the idea."
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "To me , this doesn\\'t seem to be an easy question , more like a medium at the least."
                    },
                    {
                        "username": "anubhaaa",
                        "content": "Where are the tags for this question."
                    },
                    {
                        "username": "no-username",
                        "content": "`1,-1,0,0,0,-1,0,-1,0,0,0,0,0,0,0,0,-1,-1,1,1` \\n\\nWhat should be result in above case? 3 or 8?"
                    },
                    {
                        "username": "NitishKumarVerma",
                        "content": "the ans will be 0, as the army can move only for enemy fort( i.e.) and should start from 1 and end at -1. "
                    },
                    {
                        "username": "_srahul_",
                        "content": "It would 0, as we\\'re asked to return maximum number of enemies forts conquered from -1(empty fort) to 1(one of our fort).\\nShortly maximum no. of 0\\'s , between -1 and 1.\\nProblem statement is pretty complicated, I can agree upon that.\\nBy the way, here is my code just in case you\\'re looking for one:\\nhttps://leetcode.com/problems/maximum-enemy-forts-that-can-be-captured/solutions/2946832/o-n-time-100-faster/?orderBy=most_votes"
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "Problem description has a typo in example 1.\\n\\n\"- Moving the army from position 8 to position 3 captures 4 enemy forts.\"\\nThe 8 and the 3 are reversed. It should be.\\n\"- Moving the army from position 3 to position 8 captures 4 enemy forts.\""
                    },
                    {
                        "username": "Mike_2233",
                        "content": "[-1,-1,0,1,0,0,1,-1,1,0] - expected:1 \\n\\nWrong test case answer. You can 100% see its to, from index 3 - 6 we have 2 forts that can be captured. Why does leetcode have wrong testcases?\\n"
                    },
                    {
                        "username": "arkdev9",
                        "content": "You cannot have your own fort in the way I believe. Though this is not mentioned as a constraint in the problem. Poorly worded."
                    }
                ]
            },
            {
                "id": 2033497,
                "content": [
                    {
                        "username": "b1ron",
                        "content": "The description alone makes this a medium. "
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Dude you deserve more upvotes."
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "**For those having trouble understanding the description:**\\n\\nThe army must move from their own fort, designated as the #1,  to an empty fort, designated as #-1. In the process of this movement, any enemy forts, designated as #0, can be captured. You must count the maximum number of enemy forts captured  while moving from your own fort(1) to an empty fort(-1).\\n\\nIf you capture 8 enemy forts, but reach the end of the array, having never landed at an empty fort(-1), your captures are invalid and the result is 0. Once you land at an empty fort(-1), your army is finished with those captures, and must start a new collection to proceed in the current direction.\\n\\nHope that helps. It\\'s a fun problem, but  poorly worded."
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Thanks buddy for the explanation."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Problem description is too complicated. We just need to find the maximum contiguous zeroes between 1 and -1 or between -1 and 1. We can use a variation of Kadane's algorithm."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "This is the most annoying problem I have ever solved in a contest."
                    },
                    {
                        "username": "withrvr",
                        "content": "## Problem description is too complicated.\n- We just need to find the maximum contiguous zeroes\n- between 1 & -1 ... or ... -1 & 1.\n"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "See in order to move your army you must have a fort under your command. So take a look at the first example forts = [1,0,0,-1,0,0,0,0,1] here you can move from index = 0 to index = 3. In this traversal you will capture two enemy forts and land your army at such a place where you are having no fort. So travelling from that index = 3 will not be possible because the army needs a fort under their command to proceed further. Now take a look at the last index = 8 from there you can take your army to the index = 3 in that traversal you will be capturing 4 forts that is greater than 2 forts. So you have to return the maximum number of forts that you can capture.\\nI hope you have got the idea."
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "To me , this doesn\\'t seem to be an easy question , more like a medium at the least."
                    },
                    {
                        "username": "anubhaaa",
                        "content": "Where are the tags for this question."
                    },
                    {
                        "username": "no-username",
                        "content": "`1,-1,0,0,0,-1,0,-1,0,0,0,0,0,0,0,0,-1,-1,1,1` \\n\\nWhat should be result in above case? 3 or 8?"
                    },
                    {
                        "username": "NitishKumarVerma",
                        "content": "the ans will be 0, as the army can move only for enemy fort( i.e.) and should start from 1 and end at -1. "
                    },
                    {
                        "username": "_srahul_",
                        "content": "It would 0, as we\\'re asked to return maximum number of enemies forts conquered from -1(empty fort) to 1(one of our fort).\\nShortly maximum no. of 0\\'s , between -1 and 1.\\nProblem statement is pretty complicated, I can agree upon that.\\nBy the way, here is my code just in case you\\'re looking for one:\\nhttps://leetcode.com/problems/maximum-enemy-forts-that-can-be-captured/solutions/2946832/o-n-time-100-faster/?orderBy=most_votes"
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "Problem description has a typo in example 1.\\n\\n\"- Moving the army from position 8 to position 3 captures 4 enemy forts.\"\\nThe 8 and the 3 are reversed. It should be.\\n\"- Moving the army from position 3 to position 8 captures 4 enemy forts.\""
                    },
                    {
                        "username": "Mike_2233",
                        "content": "[-1,-1,0,1,0,0,1,-1,1,0] - expected:1 \\n\\nWrong test case answer. You can 100% see its to, from index 3 - 6 we have 2 forts that can be captured. Why does leetcode have wrong testcases?\\n"
                    },
                    {
                        "username": "arkdev9",
                        "content": "You cannot have your own fort in the way I believe. Though this is not mentioned as a constraint in the problem. Poorly worded."
                    }
                ]
            },
            {
                "id": 2031627,
                "content": [
                    {
                        "username": "b1ron",
                        "content": "The description alone makes this a medium. "
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Dude you deserve more upvotes."
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "**For those having trouble understanding the description:**\\n\\nThe army must move from their own fort, designated as the #1,  to an empty fort, designated as #-1. In the process of this movement, any enemy forts, designated as #0, can be captured. You must count the maximum number of enemy forts captured  while moving from your own fort(1) to an empty fort(-1).\\n\\nIf you capture 8 enemy forts, but reach the end of the array, having never landed at an empty fort(-1), your captures are invalid and the result is 0. Once you land at an empty fort(-1), your army is finished with those captures, and must start a new collection to proceed in the current direction.\\n\\nHope that helps. It\\'s a fun problem, but  poorly worded."
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Thanks buddy for the explanation."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Problem description is too complicated. We just need to find the maximum contiguous zeroes between 1 and -1 or between -1 and 1. We can use a variation of Kadane's algorithm."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "This is the most annoying problem I have ever solved in a contest."
                    },
                    {
                        "username": "withrvr",
                        "content": "## Problem description is too complicated.\n- We just need to find the maximum contiguous zeroes\n- between 1 & -1 ... or ... -1 & 1.\n"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "See in order to move your army you must have a fort under your command. So take a look at the first example forts = [1,0,0,-1,0,0,0,0,1] here you can move from index = 0 to index = 3. In this traversal you will capture two enemy forts and land your army at such a place where you are having no fort. So travelling from that index = 3 will not be possible because the army needs a fort under their command to proceed further. Now take a look at the last index = 8 from there you can take your army to the index = 3 in that traversal you will be capturing 4 forts that is greater than 2 forts. So you have to return the maximum number of forts that you can capture.\\nI hope you have got the idea."
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "To me , this doesn\\'t seem to be an easy question , more like a medium at the least."
                    },
                    {
                        "username": "anubhaaa",
                        "content": "Where are the tags for this question."
                    },
                    {
                        "username": "no-username",
                        "content": "`1,-1,0,0,0,-1,0,-1,0,0,0,0,0,0,0,0,-1,-1,1,1` \\n\\nWhat should be result in above case? 3 or 8?"
                    },
                    {
                        "username": "NitishKumarVerma",
                        "content": "the ans will be 0, as the army can move only for enemy fort( i.e.) and should start from 1 and end at -1. "
                    },
                    {
                        "username": "_srahul_",
                        "content": "It would 0, as we\\'re asked to return maximum number of enemies forts conquered from -1(empty fort) to 1(one of our fort).\\nShortly maximum no. of 0\\'s , between -1 and 1.\\nProblem statement is pretty complicated, I can agree upon that.\\nBy the way, here is my code just in case you\\'re looking for one:\\nhttps://leetcode.com/problems/maximum-enemy-forts-that-can-be-captured/solutions/2946832/o-n-time-100-faster/?orderBy=most_votes"
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "Problem description has a typo in example 1.\\n\\n\"- Moving the army from position 8 to position 3 captures 4 enemy forts.\"\\nThe 8 and the 3 are reversed. It should be.\\n\"- Moving the army from position 3 to position 8 captures 4 enemy forts.\""
                    },
                    {
                        "username": "Mike_2233",
                        "content": "[-1,-1,0,1,0,0,1,-1,1,0] - expected:1 \\n\\nWrong test case answer. You can 100% see its to, from index 3 - 6 we have 2 forts that can be captured. Why does leetcode have wrong testcases?\\n"
                    },
                    {
                        "username": "arkdev9",
                        "content": "You cannot have your own fort in the way I believe. Though this is not mentioned as a constraint in the problem. Poorly worded."
                    }
                ]
            },
            {
                "id": 1727158,
                "content": [
                    {
                        "username": "b1ron",
                        "content": "The description alone makes this a medium. "
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Dude you deserve more upvotes."
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "**For those having trouble understanding the description:**\\n\\nThe army must move from their own fort, designated as the #1,  to an empty fort, designated as #-1. In the process of this movement, any enemy forts, designated as #0, can be captured. You must count the maximum number of enemy forts captured  while moving from your own fort(1) to an empty fort(-1).\\n\\nIf you capture 8 enemy forts, but reach the end of the array, having never landed at an empty fort(-1), your captures are invalid and the result is 0. Once you land at an empty fort(-1), your army is finished with those captures, and must start a new collection to proceed in the current direction.\\n\\nHope that helps. It\\'s a fun problem, but  poorly worded."
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Thanks buddy for the explanation."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Problem description is too complicated. We just need to find the maximum contiguous zeroes between 1 and -1 or between -1 and 1. We can use a variation of Kadane's algorithm."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "This is the most annoying problem I have ever solved in a contest."
                    },
                    {
                        "username": "withrvr",
                        "content": "## Problem description is too complicated.\n- We just need to find the maximum contiguous zeroes\n- between 1 & -1 ... or ... -1 & 1.\n"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "See in order to move your army you must have a fort under your command. So take a look at the first example forts = [1,0,0,-1,0,0,0,0,1] here you can move from index = 0 to index = 3. In this traversal you will capture two enemy forts and land your army at such a place where you are having no fort. So travelling from that index = 3 will not be possible because the army needs a fort under their command to proceed further. Now take a look at the last index = 8 from there you can take your army to the index = 3 in that traversal you will be capturing 4 forts that is greater than 2 forts. So you have to return the maximum number of forts that you can capture.\\nI hope you have got the idea."
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "To me , this doesn\\'t seem to be an easy question , more like a medium at the least."
                    },
                    {
                        "username": "anubhaaa",
                        "content": "Where are the tags for this question."
                    },
                    {
                        "username": "no-username",
                        "content": "`1,-1,0,0,0,-1,0,-1,0,0,0,0,0,0,0,0,-1,-1,1,1` \\n\\nWhat should be result in above case? 3 or 8?"
                    },
                    {
                        "username": "NitishKumarVerma",
                        "content": "the ans will be 0, as the army can move only for enemy fort( i.e.) and should start from 1 and end at -1. "
                    },
                    {
                        "username": "_srahul_",
                        "content": "It would 0, as we\\'re asked to return maximum number of enemies forts conquered from -1(empty fort) to 1(one of our fort).\\nShortly maximum no. of 0\\'s , between -1 and 1.\\nProblem statement is pretty complicated, I can agree upon that.\\nBy the way, here is my code just in case you\\'re looking for one:\\nhttps://leetcode.com/problems/maximum-enemy-forts-that-can-be-captured/solutions/2946832/o-n-time-100-faster/?orderBy=most_votes"
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "Problem description has a typo in example 1.\\n\\n\"- Moving the army from position 8 to position 3 captures 4 enemy forts.\"\\nThe 8 and the 3 are reversed. It should be.\\n\"- Moving the army from position 3 to position 8 captures 4 enemy forts.\""
                    },
                    {
                        "username": "Mike_2233",
                        "content": "[-1,-1,0,1,0,0,1,-1,1,0] - expected:1 \\n\\nWrong test case answer. You can 100% see its to, from index 3 - 6 we have 2 forts that can be captured. Why does leetcode have wrong testcases?\\n"
                    },
                    {
                        "username": "arkdev9",
                        "content": "You cannot have your own fort in the way I believe. Though this is not mentioned as a constraint in the problem. Poorly worded."
                    }
                ]
            },
            {
                "id": 1728141,
                "content": [
                    {
                        "username": "b1ron",
                        "content": "The description alone makes this a medium. "
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Dude you deserve more upvotes."
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "**For those having trouble understanding the description:**\\n\\nThe army must move from their own fort, designated as the #1,  to an empty fort, designated as #-1. In the process of this movement, any enemy forts, designated as #0, can be captured. You must count the maximum number of enemy forts captured  while moving from your own fort(1) to an empty fort(-1).\\n\\nIf you capture 8 enemy forts, but reach the end of the array, having never landed at an empty fort(-1), your captures are invalid and the result is 0. Once you land at an empty fort(-1), your army is finished with those captures, and must start a new collection to proceed in the current direction.\\n\\nHope that helps. It\\'s a fun problem, but  poorly worded."
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Thanks buddy for the explanation."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Problem description is too complicated. We just need to find the maximum contiguous zeroes between 1 and -1 or between -1 and 1. We can use a variation of Kadane's algorithm."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "This is the most annoying problem I have ever solved in a contest."
                    },
                    {
                        "username": "withrvr",
                        "content": "## Problem description is too complicated.\n- We just need to find the maximum contiguous zeroes\n- between 1 & -1 ... or ... -1 & 1.\n"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "See in order to move your army you must have a fort under your command. So take a look at the first example forts = [1,0,0,-1,0,0,0,0,1] here you can move from index = 0 to index = 3. In this traversal you will capture two enemy forts and land your army at such a place where you are having no fort. So travelling from that index = 3 will not be possible because the army needs a fort under their command to proceed further. Now take a look at the last index = 8 from there you can take your army to the index = 3 in that traversal you will be capturing 4 forts that is greater than 2 forts. So you have to return the maximum number of forts that you can capture.\\nI hope you have got the idea."
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "To me , this doesn\\'t seem to be an easy question , more like a medium at the least."
                    },
                    {
                        "username": "anubhaaa",
                        "content": "Where are the tags for this question."
                    },
                    {
                        "username": "no-username",
                        "content": "`1,-1,0,0,0,-1,0,-1,0,0,0,0,0,0,0,0,-1,-1,1,1` \\n\\nWhat should be result in above case? 3 or 8?"
                    },
                    {
                        "username": "NitishKumarVerma",
                        "content": "the ans will be 0, as the army can move only for enemy fort( i.e.) and should start from 1 and end at -1. "
                    },
                    {
                        "username": "_srahul_",
                        "content": "It would 0, as we\\'re asked to return maximum number of enemies forts conquered from -1(empty fort) to 1(one of our fort).\\nShortly maximum no. of 0\\'s , between -1 and 1.\\nProblem statement is pretty complicated, I can agree upon that.\\nBy the way, here is my code just in case you\\'re looking for one:\\nhttps://leetcode.com/problems/maximum-enemy-forts-that-can-be-captured/solutions/2946832/o-n-time-100-faster/?orderBy=most_votes"
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "Problem description has a typo in example 1.\\n\\n\"- Moving the army from position 8 to position 3 captures 4 enemy forts.\"\\nThe 8 and the 3 are reversed. It should be.\\n\"- Moving the army from position 3 to position 8 captures 4 enemy forts.\""
                    },
                    {
                        "username": "Mike_2233",
                        "content": "[-1,-1,0,1,0,0,1,-1,1,0] - expected:1 \\n\\nWrong test case answer. You can 100% see its to, from index 3 - 6 we have 2 forts that can be captured. Why does leetcode have wrong testcases?\\n"
                    },
                    {
                        "username": "arkdev9",
                        "content": "You cannot have your own fort in the way I believe. Though this is not mentioned as a constraint in the problem. Poorly worded."
                    }
                ]
            },
            {
                "id": 1727139,
                "content": [
                    {
                        "username": "b1ron",
                        "content": "The description alone makes this a medium. "
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Dude you deserve more upvotes."
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "**For those having trouble understanding the description:**\\n\\nThe army must move from their own fort, designated as the #1,  to an empty fort, designated as #-1. In the process of this movement, any enemy forts, designated as #0, can be captured. You must count the maximum number of enemy forts captured  while moving from your own fort(1) to an empty fort(-1).\\n\\nIf you capture 8 enemy forts, but reach the end of the array, having never landed at an empty fort(-1), your captures are invalid and the result is 0. Once you land at an empty fort(-1), your army is finished with those captures, and must start a new collection to proceed in the current direction.\\n\\nHope that helps. It\\'s a fun problem, but  poorly worded."
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Thanks buddy for the explanation."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Problem description is too complicated. We just need to find the maximum contiguous zeroes between 1 and -1 or between -1 and 1. We can use a variation of Kadane's algorithm."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "This is the most annoying problem I have ever solved in a contest."
                    },
                    {
                        "username": "withrvr",
                        "content": "## Problem description is too complicated.\n- We just need to find the maximum contiguous zeroes\n- between 1 & -1 ... or ... -1 & 1.\n"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "See in order to move your army you must have a fort under your command. So take a look at the first example forts = [1,0,0,-1,0,0,0,0,1] here you can move from index = 0 to index = 3. In this traversal you will capture two enemy forts and land your army at such a place where you are having no fort. So travelling from that index = 3 will not be possible because the army needs a fort under their command to proceed further. Now take a look at the last index = 8 from there you can take your army to the index = 3 in that traversal you will be capturing 4 forts that is greater than 2 forts. So you have to return the maximum number of forts that you can capture.\\nI hope you have got the idea."
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "To me , this doesn\\'t seem to be an easy question , more like a medium at the least."
                    },
                    {
                        "username": "anubhaaa",
                        "content": "Where are the tags for this question."
                    },
                    {
                        "username": "no-username",
                        "content": "`1,-1,0,0,0,-1,0,-1,0,0,0,0,0,0,0,0,-1,-1,1,1` \\n\\nWhat should be result in above case? 3 or 8?"
                    },
                    {
                        "username": "NitishKumarVerma",
                        "content": "the ans will be 0, as the army can move only for enemy fort( i.e.) and should start from 1 and end at -1. "
                    },
                    {
                        "username": "_srahul_",
                        "content": "It would 0, as we\\'re asked to return maximum number of enemies forts conquered from -1(empty fort) to 1(one of our fort).\\nShortly maximum no. of 0\\'s , between -1 and 1.\\nProblem statement is pretty complicated, I can agree upon that.\\nBy the way, here is my code just in case you\\'re looking for one:\\nhttps://leetcode.com/problems/maximum-enemy-forts-that-can-be-captured/solutions/2946832/o-n-time-100-faster/?orderBy=most_votes"
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "Problem description has a typo in example 1.\\n\\n\"- Moving the army from position 8 to position 3 captures 4 enemy forts.\"\\nThe 8 and the 3 are reversed. It should be.\\n\"- Moving the army from position 3 to position 8 captures 4 enemy forts.\""
                    },
                    {
                        "username": "Mike_2233",
                        "content": "[-1,-1,0,1,0,0,1,-1,1,0] - expected:1 \\n\\nWrong test case answer. You can 100% see its to, from index 3 - 6 we have 2 forts that can be captured. Why does leetcode have wrong testcases?\\n"
                    },
                    {
                        "username": "arkdev9",
                        "content": "You cannot have your own fort in the way I believe. Though this is not mentioned as a constraint in the problem. Poorly worded."
                    }
                ]
            },
            {
                "id": 1743422,
                "content": [
                    {
                        "username": "b1ron",
                        "content": "The description alone makes this a medium. "
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Dude you deserve more upvotes."
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "**For those having trouble understanding the description:**\\n\\nThe army must move from their own fort, designated as the #1,  to an empty fort, designated as #-1. In the process of this movement, any enemy forts, designated as #0, can be captured. You must count the maximum number of enemy forts captured  while moving from your own fort(1) to an empty fort(-1).\\n\\nIf you capture 8 enemy forts, but reach the end of the array, having never landed at an empty fort(-1), your captures are invalid and the result is 0. Once you land at an empty fort(-1), your army is finished with those captures, and must start a new collection to proceed in the current direction.\\n\\nHope that helps. It\\'s a fun problem, but  poorly worded."
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Thanks buddy for the explanation."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Problem description is too complicated. We just need to find the maximum contiguous zeroes between 1 and -1 or between -1 and 1. We can use a variation of Kadane's algorithm."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "This is the most annoying problem I have ever solved in a contest."
                    },
                    {
                        "username": "withrvr",
                        "content": "## Problem description is too complicated.\n- We just need to find the maximum contiguous zeroes\n- between 1 & -1 ... or ... -1 & 1.\n"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "See in order to move your army you must have a fort under your command. So take a look at the first example forts = [1,0,0,-1,0,0,0,0,1] here you can move from index = 0 to index = 3. In this traversal you will capture two enemy forts and land your army at such a place where you are having no fort. So travelling from that index = 3 will not be possible because the army needs a fort under their command to proceed further. Now take a look at the last index = 8 from there you can take your army to the index = 3 in that traversal you will be capturing 4 forts that is greater than 2 forts. So you have to return the maximum number of forts that you can capture.\\nI hope you have got the idea."
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "To me , this doesn\\'t seem to be an easy question , more like a medium at the least."
                    },
                    {
                        "username": "anubhaaa",
                        "content": "Where are the tags for this question."
                    },
                    {
                        "username": "no-username",
                        "content": "`1,-1,0,0,0,-1,0,-1,0,0,0,0,0,0,0,0,-1,-1,1,1` \\n\\nWhat should be result in above case? 3 or 8?"
                    },
                    {
                        "username": "NitishKumarVerma",
                        "content": "the ans will be 0, as the army can move only for enemy fort( i.e.) and should start from 1 and end at -1. "
                    },
                    {
                        "username": "_srahul_",
                        "content": "It would 0, as we\\'re asked to return maximum number of enemies forts conquered from -1(empty fort) to 1(one of our fort).\\nShortly maximum no. of 0\\'s , between -1 and 1.\\nProblem statement is pretty complicated, I can agree upon that.\\nBy the way, here is my code just in case you\\'re looking for one:\\nhttps://leetcode.com/problems/maximum-enemy-forts-that-can-be-captured/solutions/2946832/o-n-time-100-faster/?orderBy=most_votes"
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "Problem description has a typo in example 1.\\n\\n\"- Moving the army from position 8 to position 3 captures 4 enemy forts.\"\\nThe 8 and the 3 are reversed. It should be.\\n\"- Moving the army from position 3 to position 8 captures 4 enemy forts.\""
                    },
                    {
                        "username": "Mike_2233",
                        "content": "[-1,-1,0,1,0,0,1,-1,1,0] - expected:1 \\n\\nWrong test case answer. You can 100% see its to, from index 3 - 6 we have 2 forts that can be captured. Why does leetcode have wrong testcases?\\n"
                    },
                    {
                        "username": "arkdev9",
                        "content": "You cannot have your own fort in the way I believe. Though this is not mentioned as a constraint in the problem. Poorly worded."
                    }
                ]
            },
            {
                "id": 1728098,
                "content": [
                    {
                        "username": "b1ron",
                        "content": "The description alone makes this a medium. "
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Dude you deserve more upvotes."
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "**For those having trouble understanding the description:**\\n\\nThe army must move from their own fort, designated as the #1,  to an empty fort, designated as #-1. In the process of this movement, any enemy forts, designated as #0, can be captured. You must count the maximum number of enemy forts captured  while moving from your own fort(1) to an empty fort(-1).\\n\\nIf you capture 8 enemy forts, but reach the end of the array, having never landed at an empty fort(-1), your captures are invalid and the result is 0. Once you land at an empty fort(-1), your army is finished with those captures, and must start a new collection to proceed in the current direction.\\n\\nHope that helps. It\\'s a fun problem, but  poorly worded."
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Thanks buddy for the explanation."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Problem description is too complicated. We just need to find the maximum contiguous zeroes between 1 and -1 or between -1 and 1. We can use a variation of Kadane's algorithm."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "This is the most annoying problem I have ever solved in a contest."
                    },
                    {
                        "username": "withrvr",
                        "content": "## Problem description is too complicated.\n- We just need to find the maximum contiguous zeroes\n- between 1 & -1 ... or ... -1 & 1.\n"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "See in order to move your army you must have a fort under your command. So take a look at the first example forts = [1,0,0,-1,0,0,0,0,1] here you can move from index = 0 to index = 3. In this traversal you will capture two enemy forts and land your army at such a place where you are having no fort. So travelling from that index = 3 will not be possible because the army needs a fort under their command to proceed further. Now take a look at the last index = 8 from there you can take your army to the index = 3 in that traversal you will be capturing 4 forts that is greater than 2 forts. So you have to return the maximum number of forts that you can capture.\\nI hope you have got the idea."
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "To me , this doesn\\'t seem to be an easy question , more like a medium at the least."
                    },
                    {
                        "username": "anubhaaa",
                        "content": "Where are the tags for this question."
                    },
                    {
                        "username": "no-username",
                        "content": "`1,-1,0,0,0,-1,0,-1,0,0,0,0,0,0,0,0,-1,-1,1,1` \\n\\nWhat should be result in above case? 3 or 8?"
                    },
                    {
                        "username": "NitishKumarVerma",
                        "content": "the ans will be 0, as the army can move only for enemy fort( i.e.) and should start from 1 and end at -1. "
                    },
                    {
                        "username": "_srahul_",
                        "content": "It would 0, as we\\'re asked to return maximum number of enemies forts conquered from -1(empty fort) to 1(one of our fort).\\nShortly maximum no. of 0\\'s , between -1 and 1.\\nProblem statement is pretty complicated, I can agree upon that.\\nBy the way, here is my code just in case you\\'re looking for one:\\nhttps://leetcode.com/problems/maximum-enemy-forts-that-can-be-captured/solutions/2946832/o-n-time-100-faster/?orderBy=most_votes"
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "Problem description has a typo in example 1.\\n\\n\"- Moving the army from position 8 to position 3 captures 4 enemy forts.\"\\nThe 8 and the 3 are reversed. It should be.\\n\"- Moving the army from position 3 to position 8 captures 4 enemy forts.\""
                    },
                    {
                        "username": "Mike_2233",
                        "content": "[-1,-1,0,1,0,0,1,-1,1,0] - expected:1 \\n\\nWrong test case answer. You can 100% see its to, from index 3 - 6 we have 2 forts that can be captured. Why does leetcode have wrong testcases?\\n"
                    },
                    {
                        "username": "arkdev9",
                        "content": "You cannot have your own fort in the way I believe. Though this is not mentioned as a constraint in the problem. Poorly worded."
                    }
                ]
            },
            {
                "id": 1790451,
                "content": [
                    {
                        "username": "b1ron",
                        "content": "The description alone makes this a medium. "
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Dude you deserve more upvotes."
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "**For those having trouble understanding the description:**\\n\\nThe army must move from their own fort, designated as the #1,  to an empty fort, designated as #-1. In the process of this movement, any enemy forts, designated as #0, can be captured. You must count the maximum number of enemy forts captured  while moving from your own fort(1) to an empty fort(-1).\\n\\nIf you capture 8 enemy forts, but reach the end of the array, having never landed at an empty fort(-1), your captures are invalid and the result is 0. Once you land at an empty fort(-1), your army is finished with those captures, and must start a new collection to proceed in the current direction.\\n\\nHope that helps. It\\'s a fun problem, but  poorly worded."
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Thanks buddy for the explanation."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Problem description is too complicated. We just need to find the maximum contiguous zeroes between 1 and -1 or between -1 and 1. We can use a variation of Kadane's algorithm."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "This is the most annoying problem I have ever solved in a contest."
                    },
                    {
                        "username": "withrvr",
                        "content": "## Problem description is too complicated.\n- We just need to find the maximum contiguous zeroes\n- between 1 & -1 ... or ... -1 & 1.\n"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "See in order to move your army you must have a fort under your command. So take a look at the first example forts = [1,0,0,-1,0,0,0,0,1] here you can move from index = 0 to index = 3. In this traversal you will capture two enemy forts and land your army at such a place where you are having no fort. So travelling from that index = 3 will not be possible because the army needs a fort under their command to proceed further. Now take a look at the last index = 8 from there you can take your army to the index = 3 in that traversal you will be capturing 4 forts that is greater than 2 forts. So you have to return the maximum number of forts that you can capture.\\nI hope you have got the idea."
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "To me , this doesn\\'t seem to be an easy question , more like a medium at the least."
                    },
                    {
                        "username": "anubhaaa",
                        "content": "Where are the tags for this question."
                    },
                    {
                        "username": "no-username",
                        "content": "`1,-1,0,0,0,-1,0,-1,0,0,0,0,0,0,0,0,-1,-1,1,1` \\n\\nWhat should be result in above case? 3 or 8?"
                    },
                    {
                        "username": "NitishKumarVerma",
                        "content": "the ans will be 0, as the army can move only for enemy fort( i.e.) and should start from 1 and end at -1. "
                    },
                    {
                        "username": "_srahul_",
                        "content": "It would 0, as we\\'re asked to return maximum number of enemies forts conquered from -1(empty fort) to 1(one of our fort).\\nShortly maximum no. of 0\\'s , between -1 and 1.\\nProblem statement is pretty complicated, I can agree upon that.\\nBy the way, here is my code just in case you\\'re looking for one:\\nhttps://leetcode.com/problems/maximum-enemy-forts-that-can-be-captured/solutions/2946832/o-n-time-100-faster/?orderBy=most_votes"
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "Problem description has a typo in example 1.\\n\\n\"- Moving the army from position 8 to position 3 captures 4 enemy forts.\"\\nThe 8 and the 3 are reversed. It should be.\\n\"- Moving the army from position 3 to position 8 captures 4 enemy forts.\""
                    },
                    {
                        "username": "Mike_2233",
                        "content": "[-1,-1,0,1,0,0,1,-1,1,0] - expected:1 \\n\\nWrong test case answer. You can 100% see its to, from index 3 - 6 we have 2 forts that can be captured. Why does leetcode have wrong testcases?\\n"
                    },
                    {
                        "username": "arkdev9",
                        "content": "You cannot have your own fort in the way I believe. Though this is not mentioned as a constraint in the problem. Poorly worded."
                    }
                ]
            },
            {
                "id": 1726991,
                "content": [
                    {
                        "username": "b1ron",
                        "content": "The description alone makes this a medium. "
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Dude you deserve more upvotes."
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "**For those having trouble understanding the description:**\\n\\nThe army must move from their own fort, designated as the #1,  to an empty fort, designated as #-1. In the process of this movement, any enemy forts, designated as #0, can be captured. You must count the maximum number of enemy forts captured  while moving from your own fort(1) to an empty fort(-1).\\n\\nIf you capture 8 enemy forts, but reach the end of the array, having never landed at an empty fort(-1), your captures are invalid and the result is 0. Once you land at an empty fort(-1), your army is finished with those captures, and must start a new collection to proceed in the current direction.\\n\\nHope that helps. It\\'s a fun problem, but  poorly worded."
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Thanks buddy for the explanation."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Problem description is too complicated. We just need to find the maximum contiguous zeroes between 1 and -1 or between -1 and 1. We can use a variation of Kadane's algorithm."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "This is the most annoying problem I have ever solved in a contest."
                    },
                    {
                        "username": "withrvr",
                        "content": "## Problem description is too complicated.\n- We just need to find the maximum contiguous zeroes\n- between 1 & -1 ... or ... -1 & 1.\n"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "See in order to move your army you must have a fort under your command. So take a look at the first example forts = [1,0,0,-1,0,0,0,0,1] here you can move from index = 0 to index = 3. In this traversal you will capture two enemy forts and land your army at such a place where you are having no fort. So travelling from that index = 3 will not be possible because the army needs a fort under their command to proceed further. Now take a look at the last index = 8 from there you can take your army to the index = 3 in that traversal you will be capturing 4 forts that is greater than 2 forts. So you have to return the maximum number of forts that you can capture.\\nI hope you have got the idea."
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "To me , this doesn\\'t seem to be an easy question , more like a medium at the least."
                    },
                    {
                        "username": "anubhaaa",
                        "content": "Where are the tags for this question."
                    },
                    {
                        "username": "no-username",
                        "content": "`1,-1,0,0,0,-1,0,-1,0,0,0,0,0,0,0,0,-1,-1,1,1` \\n\\nWhat should be result in above case? 3 or 8?"
                    },
                    {
                        "username": "NitishKumarVerma",
                        "content": "the ans will be 0, as the army can move only for enemy fort( i.e.) and should start from 1 and end at -1. "
                    },
                    {
                        "username": "_srahul_",
                        "content": "It would 0, as we\\'re asked to return maximum number of enemies forts conquered from -1(empty fort) to 1(one of our fort).\\nShortly maximum no. of 0\\'s , between -1 and 1.\\nProblem statement is pretty complicated, I can agree upon that.\\nBy the way, here is my code just in case you\\'re looking for one:\\nhttps://leetcode.com/problems/maximum-enemy-forts-that-can-be-captured/solutions/2946832/o-n-time-100-faster/?orderBy=most_votes"
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "Problem description has a typo in example 1.\\n\\n\"- Moving the army from position 8 to position 3 captures 4 enemy forts.\"\\nThe 8 and the 3 are reversed. It should be.\\n\"- Moving the army from position 3 to position 8 captures 4 enemy forts.\""
                    },
                    {
                        "username": "Mike_2233",
                        "content": "[-1,-1,0,1,0,0,1,-1,1,0] - expected:1 \\n\\nWrong test case answer. You can 100% see its to, from index 3 - 6 we have 2 forts that can be captured. Why does leetcode have wrong testcases?\\n"
                    },
                    {
                        "username": "arkdev9",
                        "content": "You cannot have your own fort in the way I believe. Though this is not mentioned as a constraint in the problem. Poorly worded."
                    }
                ]
            },
            {
                "id": 1726863,
                "content": [
                    {
                        "username": "b1ron",
                        "content": "The description alone makes this a medium. "
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Dude you deserve more upvotes."
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "**For those having trouble understanding the description:**\\n\\nThe army must move from their own fort, designated as the #1,  to an empty fort, designated as #-1. In the process of this movement, any enemy forts, designated as #0, can be captured. You must count the maximum number of enemy forts captured  while moving from your own fort(1) to an empty fort(-1).\\n\\nIf you capture 8 enemy forts, but reach the end of the array, having never landed at an empty fort(-1), your captures are invalid and the result is 0. Once you land at an empty fort(-1), your army is finished with those captures, and must start a new collection to proceed in the current direction.\\n\\nHope that helps. It\\'s a fun problem, but  poorly worded."
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Thanks buddy for the explanation."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Problem description is too complicated. We just need to find the maximum contiguous zeroes between 1 and -1 or between -1 and 1. We can use a variation of Kadane's algorithm."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "This is the most annoying problem I have ever solved in a contest."
                    },
                    {
                        "username": "withrvr",
                        "content": "## Problem description is too complicated.\n- We just need to find the maximum contiguous zeroes\n- between 1 & -1 ... or ... -1 & 1.\n"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "See in order to move your army you must have a fort under your command. So take a look at the first example forts = [1,0,0,-1,0,0,0,0,1] here you can move from index = 0 to index = 3. In this traversal you will capture two enemy forts and land your army at such a place where you are having no fort. So travelling from that index = 3 will not be possible because the army needs a fort under their command to proceed further. Now take a look at the last index = 8 from there you can take your army to the index = 3 in that traversal you will be capturing 4 forts that is greater than 2 forts. So you have to return the maximum number of forts that you can capture.\\nI hope you have got the idea."
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "To me , this doesn\\'t seem to be an easy question , more like a medium at the least."
                    },
                    {
                        "username": "anubhaaa",
                        "content": "Where are the tags for this question."
                    },
                    {
                        "username": "no-username",
                        "content": "`1,-1,0,0,0,-1,0,-1,0,0,0,0,0,0,0,0,-1,-1,1,1` \\n\\nWhat should be result in above case? 3 or 8?"
                    },
                    {
                        "username": "NitishKumarVerma",
                        "content": "the ans will be 0, as the army can move only for enemy fort( i.e.) and should start from 1 and end at -1. "
                    },
                    {
                        "username": "_srahul_",
                        "content": "It would 0, as we\\'re asked to return maximum number of enemies forts conquered from -1(empty fort) to 1(one of our fort).\\nShortly maximum no. of 0\\'s , between -1 and 1.\\nProblem statement is pretty complicated, I can agree upon that.\\nBy the way, here is my code just in case you\\'re looking for one:\\nhttps://leetcode.com/problems/maximum-enemy-forts-that-can-be-captured/solutions/2946832/o-n-time-100-faster/?orderBy=most_votes"
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "Problem description has a typo in example 1.\\n\\n\"- Moving the army from position 8 to position 3 captures 4 enemy forts.\"\\nThe 8 and the 3 are reversed. It should be.\\n\"- Moving the army from position 3 to position 8 captures 4 enemy forts.\""
                    },
                    {
                        "username": "Mike_2233",
                        "content": "[-1,-1,0,1,0,0,1,-1,1,0] - expected:1 \\n\\nWrong test case answer. You can 100% see its to, from index 3 - 6 we have 2 forts that can be captured. Why does leetcode have wrong testcases?\\n"
                    },
                    {
                        "username": "arkdev9",
                        "content": "You cannot have your own fort in the way I believe. Though this is not mentioned as a constraint in the problem. Poorly worded."
                    }
                ]
            },
            {
                "id": 2033497,
                "content": [
                    {
                        "username": "b1ron",
                        "content": "The description alone makes this a medium. "
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Dude you deserve more upvotes."
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "**For those having trouble understanding the description:**\\n\\nThe army must move from their own fort, designated as the #1,  to an empty fort, designated as #-1. In the process of this movement, any enemy forts, designated as #0, can be captured. You must count the maximum number of enemy forts captured  while moving from your own fort(1) to an empty fort(-1).\\n\\nIf you capture 8 enemy forts, but reach the end of the array, having never landed at an empty fort(-1), your captures are invalid and the result is 0. Once you land at an empty fort(-1), your army is finished with those captures, and must start a new collection to proceed in the current direction.\\n\\nHope that helps. It\\'s a fun problem, but  poorly worded."
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Thanks buddy for the explanation."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Problem description is too complicated. We just need to find the maximum contiguous zeroes between 1 and -1 or between -1 and 1. We can use a variation of Kadane's algorithm."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "This is the most annoying problem I have ever solved in a contest."
                    },
                    {
                        "username": "withrvr",
                        "content": "## Problem description is too complicated.\n- We just need to find the maximum contiguous zeroes\n- between 1 & -1 ... or ... -1 & 1.\n"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "See in order to move your army you must have a fort under your command. So take a look at the first example forts = [1,0,0,-1,0,0,0,0,1] here you can move from index = 0 to index = 3. In this traversal you will capture two enemy forts and land your army at such a place where you are having no fort. So travelling from that index = 3 will not be possible because the army needs a fort under their command to proceed further. Now take a look at the last index = 8 from there you can take your army to the index = 3 in that traversal you will be capturing 4 forts that is greater than 2 forts. So you have to return the maximum number of forts that you can capture.\\nI hope you have got the idea."
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "To me , this doesn\\'t seem to be an easy question , more like a medium at the least."
                    },
                    {
                        "username": "anubhaaa",
                        "content": "Where are the tags for this question."
                    },
                    {
                        "username": "no-username",
                        "content": "`1,-1,0,0,0,-1,0,-1,0,0,0,0,0,0,0,0,-1,-1,1,1` \\n\\nWhat should be result in above case? 3 or 8?"
                    },
                    {
                        "username": "NitishKumarVerma",
                        "content": "the ans will be 0, as the army can move only for enemy fort( i.e.) and should start from 1 and end at -1. "
                    },
                    {
                        "username": "_srahul_",
                        "content": "It would 0, as we\\'re asked to return maximum number of enemies forts conquered from -1(empty fort) to 1(one of our fort).\\nShortly maximum no. of 0\\'s , between -1 and 1.\\nProblem statement is pretty complicated, I can agree upon that.\\nBy the way, here is my code just in case you\\'re looking for one:\\nhttps://leetcode.com/problems/maximum-enemy-forts-that-can-be-captured/solutions/2946832/o-n-time-100-faster/?orderBy=most_votes"
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "Problem description has a typo in example 1.\\n\\n\"- Moving the army from position 8 to position 3 captures 4 enemy forts.\"\\nThe 8 and the 3 are reversed. It should be.\\n\"- Moving the army from position 3 to position 8 captures 4 enemy forts.\""
                    },
                    {
                        "username": "Mike_2233",
                        "content": "[-1,-1,0,1,0,0,1,-1,1,0] - expected:1 \\n\\nWrong test case answer. You can 100% see its to, from index 3 - 6 we have 2 forts that can be captured. Why does leetcode have wrong testcases?\\n"
                    },
                    {
                        "username": "arkdev9",
                        "content": "You cannot have your own fort in the way I believe. Though this is not mentioned as a constraint in the problem. Poorly worded."
                    }
                ]
            },
            {
                "id": 2031627,
                "content": [
                    {
                        "username": "b1ron",
                        "content": "The description alone makes this a medium. "
                    },
                    {
                        "username": "ajaxWin",
                        "content": "Dude you deserve more upvotes."
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "**For those having trouble understanding the description:**\\n\\nThe army must move from their own fort, designated as the #1,  to an empty fort, designated as #-1. In the process of this movement, any enemy forts, designated as #0, can be captured. You must count the maximum number of enemy forts captured  while moving from your own fort(1) to an empty fort(-1).\\n\\nIf you capture 8 enemy forts, but reach the end of the array, having never landed at an empty fort(-1), your captures are invalid and the result is 0. Once you land at an empty fort(-1), your army is finished with those captures, and must start a new collection to proceed in the current direction.\\n\\nHope that helps. It\\'s a fun problem, but  poorly worded."
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Thanks buddy for the explanation."
                    },
                    {
                        "username": "aryonbe",
                        "content": "Problem description is too complicated. We just need to find the maximum contiguous zeroes between 1 and -1 or between -1 and 1. We can use a variation of Kadane's algorithm."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "This is the most annoying problem I have ever solved in a contest."
                    },
                    {
                        "username": "withrvr",
                        "content": "## Problem description is too complicated.\n- We just need to find the maximum contiguous zeroes\n- between 1 & -1 ... or ... -1 & 1.\n"
                    },
                    {
                        "username": "rishavranjan1821",
                        "content": "See in order to move your army you must have a fort under your command. So take a look at the first example forts = [1,0,0,-1,0,0,0,0,1] here you can move from index = 0 to index = 3. In this traversal you will capture two enemy forts and land your army at such a place where you are having no fort. So travelling from that index = 3 will not be possible because the army needs a fort under their command to proceed further. Now take a look at the last index = 8 from there you can take your army to the index = 3 in that traversal you will be capturing 4 forts that is greater than 2 forts. So you have to return the maximum number of forts that you can capture.\\nI hope you have got the idea."
                    },
                    {
                        "username": "Anmol_Soni",
                        "content": "To me , this doesn\\'t seem to be an easy question , more like a medium at the least."
                    },
                    {
                        "username": "anubhaaa",
                        "content": "Where are the tags for this question."
                    },
                    {
                        "username": "no-username",
                        "content": "`1,-1,0,0,0,-1,0,-1,0,0,0,0,0,0,0,0,-1,-1,1,1` \\n\\nWhat should be result in above case? 3 or 8?"
                    },
                    {
                        "username": "NitishKumarVerma",
                        "content": "the ans will be 0, as the army can move only for enemy fort( i.e.) and should start from 1 and end at -1. "
                    },
                    {
                        "username": "_srahul_",
                        "content": "It would 0, as we\\'re asked to return maximum number of enemies forts conquered from -1(empty fort) to 1(one of our fort).\\nShortly maximum no. of 0\\'s , between -1 and 1.\\nProblem statement is pretty complicated, I can agree upon that.\\nBy the way, here is my code just in case you\\'re looking for one:\\nhttps://leetcode.com/problems/maximum-enemy-forts-that-can-be-captured/solutions/2946832/o-n-time-100-faster/?orderBy=most_votes"
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "Problem description has a typo in example 1.\\n\\n\"- Moving the army from position 8 to position 3 captures 4 enemy forts.\"\\nThe 8 and the 3 are reversed. It should be.\\n\"- Moving the army from position 3 to position 8 captures 4 enemy forts.\""
                    },
                    {
                        "username": "Mike_2233",
                        "content": "[-1,-1,0,1,0,0,1,-1,1,0] - expected:1 \\n\\nWrong test case answer. You can 100% see its to, from index 3 - 6 we have 2 forts that can be captured. Why does leetcode have wrong testcases?\\n"
                    },
                    {
                        "username": "arkdev9",
                        "content": "You cannot have your own fort in the way I believe. Though this is not mentioned as a constraint in the problem. Poorly worded."
                    }
                ]
            }
        ]
    }
]