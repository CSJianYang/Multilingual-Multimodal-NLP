[
    {
        "title": "Find Good Days to Rob the Bank",
        "question_content": "You and a gang of thieves are planning on robbing a bank. You are given a 0-indexed integer array security, where security[i] is the number of guards on duty on the ith day. The days are numbered starting from 0. You are also given an integer time.\nThe ith day is a good day to rob the bank if:\n\n\tThere are at least time days before and after the ith day,\n\tThe number of guards at the bank for the time days before i are non-increasing, and\n\tThe number of guards at the bank for the time days after i are non-decreasing.\n\nMore formally, this means day i is a good day to rob the bank if and only if security[i - time] >= security[i - time + 1] >= ... >= security[i] <= ... <= security[i + time - 1] <= security[i + time].\nReturn a list of all days (0-indexed) that are good days to rob the bank. The order that the days are returned in does not matter.\n&nbsp;\nExample 1:\n\nInput: security = [5,3,3,3,5,6,2], time = 2\nOutput: [2,3]\nExplanation:\nOn day 2, we have security[0] >= security[1] >= security[2] <= security[3] <= security[4].\nOn day 3, we have security[1] >= security[2] >= security[3] <= security[4] <= security[5].\nNo other days satisfy this condition, so days 2 and 3 are the only good days to rob the bank.\n\nExample 2:\n\nInput: security = [1,1,1,1,1], time = 0\nOutput: [0,1,2,3,4]\nExplanation:\nSince time equals 0, every day is a good day to rob the bank, so return every day.\n\nExample 3:\n\nInput: security = [1,2,3,4,5,6], time = 2\nOutput: []\nExplanation:\nNo day has 2 days before it that have a non-increasing number of guards.\nThus, no day is a good day to rob the bank, so return an empty list.\n\n&nbsp;\nConstraints:\n\n\t1 <= security.length <= 105\n\t0 <= security[i], time <= 105",
        "solutions": [
            {
                "id": 1623329,
                "title": "c-prefix-suffix-array-with-explanation",
                "content": "**Explanation:-**\\n1. For every index we will find number of ```previous elements``` that follows this pattern ```security[i - time] >= security[i - time + 1]```  and it\\'s easy to find you can see in the code and we store this info in ```prefix array```.\\n2.  For every index we will find number of ``` elements that are ahead of current element``` which follows this pattern ```security[i + time - 1] <= security[i + time]```  and it\\'s easy to find you can see in the code and we store this info in ```suffix array```.\\n3.  To find ```good days``` just traverse the array and check this condition ```pre[i]-1>=time && suf[i]-1>=time```.\\n4.  **Note:-** I am subtracting 1 in above line because i have included current element in ```cnt```.\\n5.  If you want, you can avoid to use ```prefix array``` and can calculate when you are calculating answer.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& s, int time) {\\n        int size=s.size(),cnt=1;\\n        vector<int>pre(size,0),suf(size,0);\\n        pre[0]=1;\\n        for(int i=1;i<size;i++){\\n            if(s[i]<=s[i-1])\\n                cnt++;\\n            else\\n                cnt=1;\\n             pre[i]=cnt;\\n        }\\n        suf[size-1]=1;cnt=1;\\n        for(int i=size-2;i>=0;i--){\\n            if(s[i]<=s[i+1])\\n                cnt++;\\n            else\\n                cnt=1;\\n            suf[i]=cnt; \\n        }\\n        vector<int>ans;\\n        for(int i=0;i<size;i++)\\n            if(pre[i]-1>=time && suf[i]-1>=time)\\n                ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```\\n\\n**As people are asking about intuition behind this,so i am adding the same here.**\\n1. Let\\'s say i am looking at index =2 and time =2 so to be a good day it should follow this pattern ```security[0] >= security[1] >= security[2] <= security[3] <= security[4]```.\\n2. So i thought for i=3  to be a good day it should follow ```security[1] >= security[2] >= security[3] <= security[4] <= security[5]```\\n3. So you can see above we are recalculating ```security[1] >= security[2] >= security[3] <= security[4] ``` this. so i got the intuition that if for every ```index``` ,if i store the ```cnt``` of previous elements and ```cnt``` of ahead elements  that follow this pattern then i can know in ```O(1)``` whether this day is good or not.\\nThis is what i thought during contest.\\nI hope it will help.\\n\\n\\nDo **UPVOTE** if it helps:)",
                "solutionTags": [
                    "C"
                ],
                "code": "```previous elements```\n```security[i - time] >= security[i - time + 1]```\n```prefix array```\n``` elements that are ahead of current element```\n```security[i + time - 1] <= security[i + time]```\n```suffix array```\n```good days```\n```pre[i]-1>=time && suf[i]-1>=time```\n```cnt```\n```prefix array```\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& s, int time) {\\n        int size=s.size(),cnt=1;\\n        vector<int>pre(size,0),suf(size,0);\\n        pre[0]=1;\\n        for(int i=1;i<size;i++){\\n            if(s[i]<=s[i-1])\\n                cnt++;\\n            else\\n                cnt=1;\\n             pre[i]=cnt;\\n        }\\n        suf[size-1]=1;cnt=1;\\n        for(int i=size-2;i>=0;i--){\\n            if(s[i]<=s[i+1])\\n                cnt++;\\n            else\\n                cnt=1;\\n            suf[i]=cnt; \\n        }\\n        vector<int>ans;\\n        for(int i=0;i<size;i++)\\n            if(pre[i]-1>=time && suf[i]-1>=time)\\n                ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```\n```security[0] >= security[1] >= security[2] <= security[3] <= security[4]```\n```security[1] >= security[2] >= security[3] <= security[4] <= security[5]```\n```security[1] >= security[2] >= security[3] <= security[4] ```\n```index```\n```cnt```\n```cnt```\n```O(1)```",
                "codeTag": "Java"
            },
            {
                "id": 1623415,
                "title": "python-explanation-with-pictures-prefix-sum",
                "content": "For each day, we get the largest number of non-increasing days on its left (inclusive), and the largest number of non-decreasing days on its right (inclusive).\\n![image](https://assets.leetcode.com/users/images/5bf21c72-3bea-4eaa-a348-3bd04d78b0ce_1639238926.3916717.png)\\n\\nBuild `lft` for days on the left.\\n![image](https://assets.leetcode.com/users/images/324fde2a-b12f-41f6-a9db-1c71e6cb9315_1639238926.3997068.png)\\n![image](https://assets.leetcode.com/users/images/b808a1f1-b0c2-42bf-a973-875e688543f1_1639238926.418414.png)\\n\\nday[3] <= day[2], so lft[3] (1-indexed) is day[2] + 1.\\n![image](https://assets.leetcode.com/users/images/de61ecb6-e317-4eee-821f-0aa3746a8e6e_1639238926.3962533.png)\\n\\nSince day[4] > day[2], lft[4] = 1.\\n![image](https://assets.leetcode.com/users/images/a94ee074-9152-47bd-b1d5-bdbe0cf57f07_1639238926.4542453.png)\\n\\nSimilarily, we build the right prefix (or left suffix) array.\\n![image](https://assets.leetcode.com/users/images/a13678ed-2ec1-427f-8cec-8df03eb81168_1639440010.506081.png)\\n\\n\\nFinally, we iterate over all days, if a day has more than `time + 1` non-inc days on its left and `time + 1` non-dec days on its right, its a good day and we add it to the answer. \\n![image](https://assets.leetcode.com/users/images/50df72cc-aa58-40e7-8399-e26ccc54a162_1639440035.532295.png)\\n\\n\\n```\\ndef goodDaysToRobBank(self, A: List[int], t: int) -> List[int]:\\n        if t == 0: return list(range(len(A)))\\n        lft, rgt, n = [1], [1], len(A)\\n        \\n        # Build non-increasing on the left side (inclusive).\\n        curr = 1\\n        for i in range(1, n):\\n            if A[i] <= A[i - 1]: curr += 1\\n            else: curr = 1\\n            lft.append(curr)\\n        \\n        # Build non-decreasing on the right side (inclusive).\\n        curr = 1\\n        for i in range(n - 2, -1, -1):\\n            if A[i] <= A[i + 1]: curr += 1\\n            else: curr = 1\\n            rgt.append(curr)\\n        rgt.reverse()\\n        \\n        return [i for i in range(n) if lft[i] >= t + 1 and rgt[i] >= t + 1]\\n```",
                "solutionTags": [],
                "code": "```\\ndef goodDaysToRobBank(self, A: List[int], t: int) -> List[int]:\\n        if t == 0: return list(range(len(A)))\\n        lft, rgt, n = [1], [1], len(A)\\n        \\n        # Build non-increasing on the left side (inclusive).\\n        curr = 1\\n        for i in range(1, n):\\n            if A[i] <= A[i - 1]: curr += 1\\n            else: curr = 1\\n            lft.append(curr)\\n        \\n        # Build non-decreasing on the right side (inclusive).\\n        curr = 1\\n        for i in range(n - 2, -1, -1):\\n            if A[i] <= A[i + 1]: curr += 1\\n            else: curr = 1\\n            rgt.append(curr)\\n        rgt.reverse()\\n        \\n        return [i for i in range(n) if lft[i] >= t + 1 and rgt[i] >= t + 1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1623335,
                "title": "c-o-n-prefix-suffix",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int> &a, int time) {\\n        int n=a.size();\\n        \\n        vector<int> left(n,0), right(n,0);\\n        \\n        for(int i=1;i<n;i++){\\n            if(a[i]<=a[i-1]){\\n                left[i]=1+left[i-1]; // count of elements from [0,i-1] >= a[i]\\n            }\\n        }\\n        \\n        for(int i=n-2;i>=0;i--){\\n            if(a[i]<=a[i+1]){\\n                right[i]=1+right[i+1]; // count of elements from [i+1,n-1] >= a[i]\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        for(int i=time;i<n-time;i++){\\n            if(left[i]>=time && right[i]>=time) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int> &a, int time) {\\n        int n=a.size();\\n        \\n        vector<int> left(n,0), right(n,0);\\n        \\n        for(int i=1;i<n;i++){\\n            if(a[i]<=a[i-1]){\\n                left[i]=1+left[i-1]; // count of elements from [0,i-1] >= a[i]\\n            }\\n        }\\n        \\n        for(int i=n-2;i>=0;i--){\\n            if(a[i]<=a[i+1]){\\n                right[i]=1+right[i+1]; // count of elements from [i+1,n-1] >= a[i]\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        for(int i=time;i<n-time;i++){\\n            if(left[i]>=time && right[i]>=time) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623435,
                "title": "o-n-java-solution-easy-understanding",
                "content": "We will construct two arrays:\\nnonincrease will store the consecutive non-increase count until current index\\nnondecrease will store the consecutive non-decrease count until curernt index\\nThen we find index whose nonincrease count and nondecrease count are both larger than time.\\n\\n```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int[] nonincrease = new int[security.length];\\n        for(int i = 1; i < security.length - time; i++){\\n            if(security[i]>security[i-1]){\\n                nonincrease[i] = 0;\\n            } else {\\n                nonincrease[i] = nonincrease[i-1] + 1;\\n            }\\n        }\\n\\n        int[] nondecrease = new int[security.length];\\n        for(int i = security.length - 2; i >= time; i--) {\\n            if(security[i] > security[i + 1]){\\n                nondecrease[i] = 0;\\n            } else {\\n                nondecrease[i] = nondecrease[i + 1] + 1;\\n            }\\n        }\\n\\n        ArrayList<Integer> result = new ArrayList<>();\\n        for(int i = time; i < security.length - time; i++) {\\n            if(nonincrease[i] >= time && nondecrease[i] >= time) {\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int[] nonincrease = new int[security.length];\\n        for(int i = 1; i < security.length - time; i++){\\n            if(security[i]>security[i-1]){\\n                nonincrease[i] = 0;\\n            } else {\\n                nonincrease[i] = nonincrease[i-1] + 1;\\n            }\\n        }\\n\\n        int[] nondecrease = new int[security.length];\\n        for(int i = security.length - 2; i >= time; i--) {\\n            if(security[i] > security[i + 1]){\\n                nondecrease[i] = 0;\\n            } else {\\n                nondecrease[i] = nondecrease[i + 1] + 1;\\n            }\\n        }\\n\\n        ArrayList<Integer> result = new ArrayList<>();\\n        for(int i = time; i < security.length - time; i++) {\\n            if(nonincrease[i] >= time && nondecrease[i] >= time) {\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623321,
                "title": "python-short-dp-solution-explained",
                "content": "Let `dp(i, dr)` be the maximum length of decreasing sentence, ending with element `i` and going from left or right, depending on `dr = 1` or `dr = -1`.\\n\\nIn the end we check if we have both answers for left and right more or equal than `T`.\\n\\n\\n#### Complexity\\nIt is `O(n)` for time and space\\n\\n#### Code\\n```python\\nclass Solution:\\n    def goodDaysToRobBank(self, s, T):\\n        n = len(s)\\n        \\n        @lru_cache(None)\\n        def dp(i, dr):\\n            if 0 <= i+dr < n and s[i + dr] >= s[i]: return dp(i + dr, dr) + 1\\n            return 0\\n        \\n        return [i for i in range(n) if dp(i, 1) >= T and dp(i, -1) >= T]\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def goodDaysToRobBank(self, s, T):\\n        n = len(s)\\n        \\n        @lru_cache(None)\\n        def dp(i, dr):\\n            if 0 <= i+dr < n and s[i + dr] >= s[i]: return dp(i + dr, dr) + 1\\n            return 0\\n        \\n        return [i for i in range(n) if dp(i, 1) >= T and dp(i, -1) >= T]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1900530,
                "title": "o-1-space-complexity-two-pointers",
                "content": "Algorithm:-\\n1.Place two pointers p1 and p2 at 1 and time steps ahead of p1.\\n2.check non-increasing and non-decreasing condition for p1 and p2 respectively. If condition is satisfied increment by 1 else reduce to 0.\\n3.check if p1 and p2 both are greater than equal to time. If True then append the index to result.\\nnums=[5,4,4,3,3,4,5,7,8]  , time=3\\n![image](https://assets.leetcode.com/users/images/7cfdb68f-2e45-4670-95bc-d4738f6247c4_1648732411.1373506.jpeg)\\n```\\nclass Solution:\\n    def goodDaysToRobBank(self, nums: List[int], time: int) -> List[int]:  \\n        n=len(nums)\\n        if time==0:return range(n)\\n        res=[]\\n        p1,p2=0,0\\n        for i in range(1,n-time):\\n            p1+=1 if nums[i-1]>=nums[i] else -p1\\n            p2+=1 if nums[i+time-1]<=nums[i+time] else -p2\\n            \\n            if p1>=time and p2>=time:res.append(i)\\n        return res\\n```\\nTime Complexity- O(N)\\nSpace Complexity-O(1)   (Ignoring the space required for result.\\n",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, nums: List[int], time: int) -> List[int]:  \\n        n=len(nums)\\n        if time==0:return range(n)\\n        res=[]\\n        p1,p2=0,0\\n        for i in range(1,n-time):\\n            p1+=1 if nums[i-1]>=nums[i] else -p1\\n            p2+=1 if nums[i+time-1]<=nums[i+time] else -p2\\n            \\n            if p1>=time and p2>=time:res.append(i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623330,
                "title": "python3-time-o-n",
                "content": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        n = len(security)\\n        \\n        left = [0 for _ in range(n)]\\n        right = [0 for _ in range(n)]\\n        \\n        for i in range(1, n):\\n            if security[i] <= security[i - 1]:\\n                left[i] += left[i - 1] + 1\\n            else: \\n                left[i] = 0 \\n        \\n        for i in range(n - 2, -1, -1):\\n            if security[i] <= security[i + 1]:\\n                right[i] += right[i + 1] + 1\\n            else: \\n                right[i] = 0 \\n        \\n        ans = []\\n        for i in range(time, n - time):\\n            if left[i] >= time and right[i] >= time:\\n                ans.append(i)\\n                \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        n = len(security)\\n        \\n        left = [0 for _ in range(n)]\\n        right = [0 for _ in range(n)]\\n        \\n        for i in range(1, n):\\n            if security[i] <= security[i - 1]:\\n                left[i] += left[i - 1] + 1\\n            else: \\n                left[i] = 0 \\n        \\n        for i in range(n - 2, -1, -1):\\n            if security[i] <= security[i + 1]:\\n                right[i] += right[i + 1] + 1\\n            else: \\n                right[i] = 0 \\n        \\n        ans = []\\n        for i in range(time, n - time):\\n            if left[i] >= time and right[i] >= time:\\n                ans.append(i)\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623404,
                "title": "array-pre-processing-easy-understanding",
                "content": "make two array pre and post to preprocess the array \\npre array store the length of subarray ending it index which is decreasing\\npost array store the length of subarry ending at index which is increasing\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    /*\\n    5,3,3,3,5,6,2\\n    0 1 2 3 0 0 1 \\n    0 4 3 2 1 0 0 \\n\\n\\n    \\n    */\\n    vector<int> goodDaysToRobBank(vector<int>& arr, int time) {\\n        int n = arr.size();\\n        vector<int> pre(n),post(n);\\n        \\n        pre[0] = 0;\\n        for(int i = 1; i < pre.size(); ++i){\\n            if(arr[i] <= arr[i-1]){\\n                pre[i] = pre[i-1]+1; // if it is decreasing add one\\n            }\\n            else{\\n                pre[i] = 0; // otherwise reset to zero\\n            }\\n        }\\n        \\n        post[n-1] = 0;\\n        \\n        for(int i = n-2; i>= 0; --i){\\n            if(arr[i] <= arr[i+1]){\\n                post[i] = post[i+1]+1; // if it is increasing add one\\n            }\\n            else{\\n                post[i] = 0; // otherwise reset to zero\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        \\n        for(int i = time; i < n-time; ++i){\\n            if(pre[i]>=time && post[i] >= time){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    /*\\n    5,3,3,3,5,6,2\\n    0 1 2 3 0 0 1 \\n    0 4 3 2 1 0 0 \\n\\n\\n    \\n    */\\n    vector<int> goodDaysToRobBank(vector<int>& arr, int time) {\\n        int n = arr.size();\\n        vector<int> pre(n),post(n);\\n        \\n        pre[0] = 0;\\n        for(int i = 1; i < pre.size(); ++i){\\n            if(arr[i] <= arr[i-1]){\\n                pre[i] = pre[i-1]+1; // if it is decreasing add one\\n            }\\n            else{\\n                pre[i] = 0; // otherwise reset to zero\\n            }\\n        }\\n        \\n        post[n-1] = 0;\\n        \\n        for(int i = n-2; i>= 0; --i){\\n            if(arr[i] <= arr[i+1]){\\n                post[i] = post[i+1]+1; // if it is increasing add one\\n            }\\n            else{\\n                post[i] = 0; // otherwise reset to zero\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        \\n        for(int i = time; i < n-time; ++i){\\n            if(pre[i]>=time && post[i] >= time){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623352,
                "title": "c-mono-deques-o-n-time-o-t-space",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Monotonic Deque\\n\\nFor a window `[i - time, i + time]`, use two monotonic deques `a` and `b` to track the numbers in the first half `[i - time, i]` and second half `[i, i + time]` of the window.\\n\\nKeep `a` monotonic non-increasing and `b` monotonic non-decreasing.\\n\\nIf both `a.size()` and `b.size()` equal `time + 1`, we add the current index `i` into the answer.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/biweekly-contest-67/problems/find-good-days-to-rob-the-bank/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(T)\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& A, int time) {\\n        deque<int> a, b;\\n        vector<int> ans;\\n        for (int i = 0; i + time < A.size(); ++i) {\\n            while (a.size() && A[a.back()] < A[i]) a.pop_back(); // Before pushing `i`, pop the indexes at the back of the deque whose corresponding value `< A[i]`\\n            a.push_back(i);\\n            if (a.front() < i - time) a.pop_front(); // Pop index if it\\'s out of window\\n            while (b.size() && A[b.back()] > A[i + time]) b.pop_back(); // Before pusing `i+time`, pop the indexes at the back of the deque whose corresponding value `> A[i+time]`\\n            b.push_back(i + time);\\n            if (b.front() < i) b.pop_front(); // Pop index if it\\'s out of window\\n            if (a.size() == time + 1 && b.size() == time + 1) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n## Solution 2. DP\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/find-good-days-to-rob-the-bank/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& A, int time) {\\n        int N = A.size(), left = 1;\\n        vector<int> right(N, 1), ans;\\n        for (int i = N - 2; i >= 0; --i) {\\n            if (A[i] <= A[i + 1]) right[i] += right[i + 1];\\n        }\\n        for (int i = 0; i + time < N; ++i) {\\n            if (i - 1 >= 0 && A[i] <= A[i - 1]) left++;\\n            else left = 1;\\n            if (left > time && right[i] > time) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/biweekly-contest-67/problems/find-good-days-to-rob-the-bank/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(T)\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& A, int time) {\\n        deque<int> a, b;\\n        vector<int> ans;\\n        for (int i = 0; i + time < A.size(); ++i) {\\n            while (a.size() && A[a.back()] < A[i]) a.pop_back(); // Before pushing `i`, pop the indexes at the back of the deque whose corresponding value `< A[i]`\\n            a.push_back(i);\\n            if (a.front() < i - time) a.pop_front(); // Pop index if it\\'s out of window\\n            while (b.size() && A[b.back()] > A[i + time]) b.pop_back(); // Before pusing `i+time`, pop the indexes at the back of the deque whose corresponding value `> A[i+time]`\\n            b.push_back(i + time);\\n            if (b.front() < i) b.pop_front(); // Pop index if it\\'s out of window\\n            if (a.size() == time + 1 && b.size() == time + 1) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/find-good-days-to-rob-the-bank/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& A, int time) {\\n        int N = A.size(), left = 1;\\n        vector<int> right(N, 1), ans;\\n        for (int i = N - 2; i >= 0; --i) {\\n            if (A[i] <= A[i + 1]) right[i] += right[i + 1];\\n        }\\n        for (int i = 0; i + time < N; ++i) {\\n            if (i - 1 >= 0 && A[i] <= A[i - 1]) left++;\\n            else left = 1;\\n            if (left > time && right[i] > time) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1664740,
                "title": "c-simple-prefix-suffix-calculation-tc-o-n-sc-o-n",
                "content": "I am explaining the solution with the help of example :-\\n\\n```\\nInput: security = [5,3,3,3,5,6,2], time = 2\\nOutput: [2,3]\\n```\\n\\nWe can simply find the solution by simply performing the following steps :-\\n\\nStep -1 -> Form the **prefix** array where prefix[i] represents number of days before i which obeys non-increasing which can be calculated in following manner :-\\n```\\nprefix[0] = 0;\\nfor(int i=1;i<n;i++) {\\n\\tif(security[i] <= security[i-1]) prefix[i] = prefix[i-1]+1;\\n\\telse prefix[i] = 0;\\n}\\n```\\n\\nStep -2 -> Form the **suffix** array where suffix[i] represents number of days after i which obeys non-decreasing which can be calculated in following manner :-\\n```\\nsuffix[n-1] = 0;\\nfor(int i=(n-2);i>=0;i--) {\\n\\tif(security[i] <= security[i+1]) suffix[i] = suffix[i+1]+1;\\n\\telse suffix[i] = 0;\\n}\\n```\\nStep -3 -> Now only that indexes should be included in our answer for which, both prefix[i] and suffix[i] are greater than or equal to the given integer **time**.\\n\\nFor our example, \\n```\\nprefix = [0, 1, 2, 3, 0, 0, 1]\\nsuffix = [0, 4, 3, 2, 1, 0, 0]\\nresult = [2, 3]\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n = security.size();\\n        vector<int> prefix(n), suffix(n);\\n        vector<int> ans;\\n        \\n        prefix[0] = 0;\\n        for(int i=1;i<n;i++) {\\n            if(security[i] <= security[i-1]) prefix[i] = prefix[i-1]+1;\\n            else prefix[i] = 0;\\n        }\\n        \\n        suffix[n-1] = 0;\\n        for(int i=(n-2);i>=0;i--) {\\n            if(security[i] <= security[i+1]) suffix[i] = suffix[i+1]+1;\\n            else suffix[i] = 0;\\n        }\\n        \\n        for(int i=0;i<n;i++) {\\n            if(prefix[i]>=time && suffix[i]>=time) ans.push_back(i);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nInput: security = [5,3,3,3,5,6,2], time = 2\\nOutput: [2,3]\\n```\n```\\nprefix[0] = 0;\\nfor(int i=1;i<n;i++) {\\n\\tif(security[i] <= security[i-1]) prefix[i] = prefix[i-1]+1;\\n\\telse prefix[i] = 0;\\n}\\n```\n```\\nsuffix[n-1] = 0;\\nfor(int i=(n-2);i>=0;i--) {\\n\\tif(security[i] <= security[i+1]) suffix[i] = suffix[i+1]+1;\\n\\telse suffix[i] = 0;\\n}\\n```\n```\\nprefix = [0, 1, 2, 3, 0, 0, 1]\\nsuffix = [0, 4, 3, 2, 1, 0, 0]\\nresult = [2, 3]\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n = security.size();\\n        vector<int> prefix(n), suffix(n);\\n        vector<int> ans;\\n        \\n        prefix[0] = 0;\\n        for(int i=1;i<n;i++) {\\n            if(security[i] <= security[i-1]) prefix[i] = prefix[i-1]+1;\\n            else prefix[i] = 0;\\n        }\\n        \\n        suffix[n-1] = 0;\\n        for(int i=(n-2);i>=0;i--) {\\n            if(security[i] <= security[i+1]) suffix[i] = suffix[i+1]+1;\\n            else suffix[i] = 0;\\n        }\\n        \\n        for(int i=0;i<n;i++) {\\n            if(prefix[i]>=time && suffix[i]>=time) ans.push_back(i);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646239,
                "title": "idea-explained-prefix-suffix-array-c-clean-code",
                "content": "**Intuition :**\\n\\n* Idea here is really straight forward. \\n* For each element we need to get the length of *non-increasing* subarray to its left,\\n* And get the length of *non-decreasing* subarray to its right.\\n* This can be done easily using prefix and suffix array. \\n* Prefix array stores the length of *non-increasing* subarray, \\n* Suffix array stores the length of *non-decreasing* subarray.\\n\\n\\t\\tEx: security = {5, 3, 3, 3, 5, 6, 2}\\n\\t\\t\\n\\t\\ti    ->  0 1 2 3 4 5 6\\n\\t\\tsec  ->  5 3 3 3 5 6 2\\n\\t\\tpref ->  0 1 2 3 0 0 1\\n\\t\\tsuff ->  5 4 3 2 1 0 0\\n\\t\\t\\n* Now, that we have prefix and suffix array ready. For each element we need to check if \\n\\t* `pref[i] >= time` and `suff[i] >= time` \\n\\t* i.e length of *non-increasing* and *non-decreasing* subarray must be greater than `time`.\\n\\n--------------------------\\n# Code : \\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        \\n        int n = security.size();\\n        vector<int> pref(n, 0), suff(n, 0);\\n        for(int i=1; i<n-1; i++) {\\n            if(security[i] <= security[i-1])\\n                pref[i] = pref[i-1] + 1;\\n        }\\n        \\n        for(int i=n-2; i>=0; i--) {\\n            if(security[i] <= security[i+1])\\n                suff[i] = suff[i+1] + 1;\\n        }\\n        \\n        vector<int> goodDays;\\n        for(int i=0; i<n; i++) {\\n            if(pref[i] >= time && suff[i] >= time) \\n                goodDays.push_back(i);\\n        }\\n        \\n        return goodDays;\\n    }\\n};\\n```\\n\\n--------------------------\\n\\n**Complexity :**\\n\\n* Time : `O(N)`, N is size of security array.\\n\\t* O(2* N) -> precompute `pref` and `suff` array\\n\\t* O(N) -> calculate `goodDays` array\\n\\n* Space : `O(N)`, to store `pref` and `suff` results.\\n--------------------------\\n***If you find this helpful, do give it a like :)***",
                "solutionTags": [
                    "Array",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        \\n        int n = security.size();\\n        vector<int> pref(n, 0), suff(n, 0);\\n        for(int i=1; i<n-1; i++) {\\n            if(security[i] <= security[i-1])\\n                pref[i] = pref[i-1] + 1;\\n        }\\n        \\n        for(int i=n-2; i>=0; i--) {\\n            if(security[i] <= security[i+1])\\n                suff[i] = suff[i+1] + 1;\\n        }\\n        \\n        vector<int> goodDays;\\n        for(int i=0; i<n; i++) {\\n            if(pref[i] >= time && suff[i] >= time) \\n                goodDays.push_back(i);\\n        }\\n        \\n        return goodDays;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623440,
                "title": "java-simple-solution-track-left-right-o-n",
                "content": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int n = security.length;\\n        int []left = new int[n];\\n        int []right = new int[n];\\n        \\n        for(int i = 1;i<n;i++){\\n            left[i] = security[i] <= security[i-1] ? left[i-1] + 1 : 0;\\n        }\\n        for(int i = n-2;i>=0;i--){\\n            right[i] = security[i] <= security[i+1] ? right[i+1] + 1 : 0;\\n        }\\n        \\n        List<Integer> res = new ArrayList<>();\\n        for(int i = time;i<security.length-time;i++){\\n            if(left[i] >= time && right[i] >= time){\\n                res.add(i);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int n = security.length;\\n        int []left = new int[n];\\n        int []right = new int[n];\\n        \\n        for(int i = 1;i<n;i++){\\n            left[i] = security[i] <= security[i-1] ? left[i-1] + 1 : 0;\\n        }\\n        for(int i = n-2;i>=0;i--){\\n            right[i] = security[i] <= security[i+1] ? right[i+1] + 1 : 0;\\n        }\\n        \\n        List<Integer> res = new ArrayList<>();\\n        for(int i = time;i<security.length-time;i++){\\n            if(left[i] >= time && right[i] >= time){\\n                res.add(i);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623325,
                "title": "python3-prefix-suffix",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/b553623546e2799477b8bca6b5c89f22c83a4d08) for solutions of weekly 67. \\n\\n```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        suffix = [0]*len(security)\\n        for i in range(len(security)-2, 0, -1): \\n            if security[i] <= security[i+1]: suffix[i] = suffix[i+1] + 1\\n        \\n        ans = []\\n        prefix = 0\\n        for i in range(len(security)-time): \\n            if i and security[i-1] >= security[i]: prefix += 1\\n            else: prefix = 0\\n            if prefix >= time and suffix[i] >= time: ans.append(i)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        suffix = [0]*len(security)\\n        for i in range(len(security)-2, 0, -1): \\n            if security[i] <= security[i+1]: suffix[i] = suffix[i+1] + 1\\n        \\n        ans = []\\n        prefix = 0\\n        for i in range(len(security)-time): \\n            if i and security[i-1] >= security[i]: prefix += 1\\n            else: prefix = 0\\n            if prefix >= time and suffix[i] >= time: ans.append(i)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885137,
                "title": "easy-c-solution-using-prefix-and-suffix-array",
                "content": "# Intuition\\n\\n\\n# Approach\\nWe will find previous and next greater elements for each index and will store them in two vector ---prefix and ---suffix respectively and finally will traverse through the security array and check if values at that particular index in prefix and sufix array are greater than time then we will push that index in our ans vector.\\n\\n# Complexity\\n- Time complexity:\\nO(n);\\n\\n- Space complexity:\\nO(n);\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n\\n        int n=security.size();\\n        vector<int>prefix(n,0);\\n        vector<int>sufix(n,0);\\n\\n        for(int i=1;i<n;i++){\\n            if(security[i-1]>=security[i]){\\n                prefix[i]=prefix[i-1]+1;\\n            }\\n        \\n        }\\n\\n        for(int i=n-2;i>=0;i--){\\n            if(security[i+1]>=security[i]){\\n                sufix[i]=sufix[i+1]+1;\\n            }\\n        }\\n        \\n        vector<int>ans;\\n\\n        for(int i=time;i<n-time;i++){\\n            if(prefix[i]>=time && sufix[i]>=time){\\n                ans.push_back(i);\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n\\n        int n=security.size();\\n        vector<int>prefix(n,0);\\n        vector<int>sufix(n,0);\\n\\n        for(int i=1;i<n;i++){\\n            if(security[i-1]>=security[i]){\\n                prefix[i]=prefix[i-1]+1;\\n            }\\n        \\n        }\\n\\n        for(int i=n-2;i>=0;i--){\\n            if(security[i+1]>=security[i]){\\n                sufix[i]=sufix[i+1]+1;\\n            }\\n        }\\n        \\n        vector<int>ans;\\n\\n        for(int i=time;i<n-time;i++){\\n            if(prefix[i]>=time && sufix[i]>=time){\\n                ans.push_back(i);\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886272,
                "title": "c-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        vector<int> robDays;\\n        int len = security.size();\\n\\n        // arrays to store number of non-increasing day before ith day, initialising with 0\\n        vector<int> numDaysBefore(len, 0);\\n        // arrays to store number of non-decreasing day after ith day\\n        vector<int> numDaysAfter(len, 0);\\n        \\n        // iterate from left to right, to find non-increasing pattern and storing number of non-inc days before each particular day\\n        for(int i=1; i<len; i++){\\n            if(security[i-1] >= security[i]){\\n                numDaysBefore[i] = 1 + numDaysBefore[i-1];\\n            }\\n        }\\n        \\n        // the above step for number of non-decreasing days before each particular day\\n        for(int j=len-2; j>=0; j--){\\n            if(security[j+1] >= security[j]){\\n                numDaysAfter[j] = 1 + numDaysAfter[j+1];\\n            }\\n        }\\n        \\n        // check if the condition 2 & 3 given in Q. are satisfy\\n        for(int k = time; k < (len - time); k++){\\n            if(numDaysBefore[k] >= time && numDaysAfter[k] >= time)\\n                robDays.push_back(k);\\n        }\\n        \\n        return robDays;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        vector<int> robDays;\\n        int len = security.size();\\n\\n        // arrays to store number of non-increasing day before ith day, initialising with 0\\n        vector<int> numDaysBefore(len, 0);\\n        // arrays to store number of non-decreasing day after ith day\\n        vector<int> numDaysAfter(len, 0);\\n        \\n        // iterate from left to right, to find non-increasing pattern and storing number of non-inc days before each particular day\\n        for(int i=1; i<len; i++){\\n            if(security[i-1] >= security[i]){\\n                numDaysBefore[i] = 1 + numDaysBefore[i-1];\\n            }\\n        }\\n        \\n        // the above step for number of non-decreasing days before each particular day\\n        for(int j=len-2; j>=0; j--){\\n            if(security[j+1] >= security[j]){\\n                numDaysAfter[j] = 1 + numDaysAfter[j+1];\\n            }\\n        }\\n        \\n        // check if the condition 2 & 3 given in Q. are satisfy\\n        for(int k = time; k < (len - time); k++){\\n            if(numDaysBefore[k] >= time && numDaysAfter[k] >= time)\\n                robDays.push_back(k);\\n        }\\n        \\n        return robDays;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646354,
                "title": "python-o-n-by-prefix-postfix-table-w-example",
                "content": "**Hint**:\\n\\nThink of **prefix table**/**postfix table** to record the length of continuous security guard weakening as well as strengthening. \\n\\nThen we can rewrite good day, Day_i, with the condition that \\n\\nContSecurity**WeakenLength( Day_i ) \\u2265 time threshold**, and \\nContSecurity**StrengthenLength( Day_i ) \\u2265 tIme threshold**.\\n\\n---\\n\\n**Example**:\\n\\nGiven input security \\n= [5, 3, 3, 3, 5, 6, 2] with **time = 2**\\n\\nWe can know\\nlength of continuous security guard weakening ( on **backward direction \\u2190**)\\n= [0, 1, **2**, **3**, 0, 0, 1]\\n\\nlength of continuous security guard strengthening ( on **forward direction \\u2192**)\\n= [0, 4, **3**, **2**, 1, 0, 0]\\n\\n---\\n\\nFor index 2, **index 2** has security weakening of length **2** and security strengthening of length **3**.\\n\\nFor index 3, **index 3** has security weakening of length **3** and security strengthening of length **2**.\\n\\n\\nOnly index 2 and index 3 have length of security weakening \\u2265 time, \\nand length of security strengthening \\u2265 time.\\n\\nTherefore, return [2, 3] as final answer.\\n\\n\\n---\\n\\n```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        \\n        # total length of security on duty days\\n        days = len(security)\\n        \\n        ## Base case\\n        if time == 0:\\n            \\n            # Threshold is too small, every day is good day.\\n            return [ day_i for day_i in range(days) ]\\n        \\n        \\n        elif time > days // 2:\\n            \\n            # Threshold is too large, impossible to have good days.\\n            return []\\n        \\n        \\n        ## General case\\n        \\n        # Prefix table, record of length of continuous security guard weakening on index i\\n        weakenDays = [0] * days\\n        # Postfix table, record of length of continuous security guard strengthening on index i\\n        strengthenDays = [0] * days\\n        \\n        # Update prefix table and postfix table\\n        for i in range(1, days):\\n            \\n            if security[i] <= security[i-1]:\\n                weakenDays[i] = weakenDays[i-1] + 1\\n\\n            if security[-i-1] <= security[-i]:\\n                strengthenDays[-i-1] =  strengthenDays[-i] + 1\\n\\n        \\n        # helper lambda function to judege good day by definition\\n        is_good_day = lambda i: ( weakenDays[i] >= time ) and ( strengthenDays[i] >= time )\\n\\n        return [ day_i for day_i in range( days ) if is_good_day(day_i) ]\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        \\n        # total length of security on duty days\\n        days = len(security)\\n        \\n        ## Base case\\n        if time == 0:\\n            \\n            # Threshold is too small, every day is good day.\\n            return [ day_i for day_i in range(days) ]\\n        \\n        \\n        elif time > days // 2:\\n            \\n            # Threshold is too large, impossible to have good days.\\n            return []\\n        \\n        \\n        ## General case\\n        \\n        # Prefix table, record of length of continuous security guard weakening on index i\\n        weakenDays = [0] * days\\n        # Postfix table, record of length of continuous security guard strengthening on index i\\n        strengthenDays = [0] * days\\n        \\n        # Update prefix table and postfix table\\n        for i in range(1, days):\\n            \\n            if security[i] <= security[i-1]:\\n                weakenDays[i] = weakenDays[i-1] + 1\\n\\n            if security[-i-1] <= security[-i]:\\n                strengthenDays[-i-1] =  strengthenDays[-i] + 1\\n\\n        \\n        # helper lambda function to judege good day by definition\\n        is_good_day = lambda i: ( weakenDays[i] >= time ) and ( strengthenDays[i] >= time )\\n\\n        return [ day_i for day_i in range( days ) if is_good_day(day_i) ]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624133,
                "title": "c-map-inc-dec-index-storage",
                "content": "**PLEASE UPVOTE IF U LIKE MY SOLUTION AND EXPLANATION**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& a, int time) \\n    {\\n        //as we need to check criteria for i-time to i+time so this condition is necessary\\n        if(2*time>a.size())return {};\\n        vector<int>res;\\n        //edge case here we do not have to check for the given condition \\n        //as time is 0 :)\\n        if(time==0)\\n        {\\n            for(int i=0;i<a.size();i++)res.push_back(i);\\n            return res;\\n        }\\n        //create two maps one for storing the indices(0th based)(start,end) of non-increasing subarray\\n        //one for storing (end,start) of non-decreasing subarray \\n        //storing in this way helps in better implementation \\n        map<int,int>dec,inc;\\n        int start=0,end=-1;\\n        \\n        //store the non-increasing subarray indices\\n        for(int i=1;i<a.size();)\\n        {\\n            if(a[i]<=a[i-1])\\n            {start=i-1;\\n               while(i<a.size()&&a[i]<=a[i-1])\\n            {end=i;i++;}\\n            dec[start]=end;  \\n            }\\n            else\\n                i++;\\n        }\\n        //store the non-decreasing subarray indices\\n         for(int i=1;i<a.size();)\\n        {\\n            if(a[i]>=a[i-1])\\n            {start=i-1;\\n               while(i<a.size()&&a[i]>=a[i-1])\\n            {end=i;i++;}\\n            inc[end]=start;  \\n            }\\n            else\\n                i++;\\n        }\\n        //we start from time and end at length-time for obvious reasons :\\')\\n        for(int i=time;i<a.size()-time;i++)\\n        {\\n            //here we find the start index of a non-increasing subarray just greater than\\n            //required criteria and check if the previous iterator\\'s end index is \\n            //greater thanor equal to (i)th value so we get a non-increasing subarray till i\\n            //from front\\n            auto it=dec.upper_bound(i-time);\\n            \\n            //here we find the end index of a non-decreasing subarray eual or greater than\\n            //required criteria and check if this iterator\\'s start index is lesser than or equal to\\n            //(i)th value so we get a non-decreasing subarray till i from back\\n            auto it1=inc.lower_bound(i+time);\\n            //cases where the criteria is not possible\\n            //u will get it by urself ik :)\\n           if(it==dec.begin())continue;\\n           if(it1==inc.end())continue;\\n            \\n            it--;//this is for decrementing the non-increasing iterator as mentioned above\\n            \\n            //this is the required condition\\n                if((*it).second>=i&&(*it1).second<=i)\\n                res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& a, int time) \\n    {\\n        //as we need to check criteria for i-time to i+time so this condition is necessary\\n        if(2*time>a.size())return {};\\n        vector<int>res;\\n        //edge case here we do not have to check for the given condition \\n        //as time is 0 :)\\n        if(time==0)\\n        {\\n            for(int i=0;i<a.size();i++)res.push_back(i);\\n            return res;\\n        }\\n        //create two maps one for storing the indices(0th based)(start,end) of non-increasing subarray\\n        //one for storing (end,start) of non-decreasing subarray \\n        //storing in this way helps in better implementation \\n        map<int,int>dec,inc;\\n        int start=0,end=-1;\\n        \\n        //store the non-increasing subarray indices\\n        for(int i=1;i<a.size();)\\n        {\\n            if(a[i]<=a[i-1])\\n            {start=i-1;\\n               while(i<a.size()&&a[i]<=a[i-1])\\n            {end=i;i++;}\\n            dec[start]=end;  \\n            }\\n            else\\n                i++;\\n        }\\n        //store the non-decreasing subarray indices\\n         for(int i=1;i<a.size();)\\n        {\\n            if(a[i]>=a[i-1])\\n            {start=i-1;\\n               while(i<a.size()&&a[i]>=a[i-1])\\n            {end=i;i++;}\\n            inc[end]=start;  \\n            }\\n            else\\n                i++;\\n        }\\n        //we start from time and end at length-time for obvious reasons :\\')\\n        for(int i=time;i<a.size()-time;i++)\\n        {\\n            //here we find the start index of a non-increasing subarray just greater than\\n            //required criteria and check if the previous iterator\\'s end index is \\n            //greater thanor equal to (i)th value so we get a non-increasing subarray till i\\n            //from front\\n            auto it=dec.upper_bound(i-time);\\n            \\n            //here we find the end index of a non-decreasing subarray eual or greater than\\n            //required criteria and check if this iterator\\'s start index is lesser than or equal to\\n            //(i)th value so we get a non-decreasing subarray till i from back\\n            auto it1=inc.lower_bound(i+time);\\n            //cases where the criteria is not possible\\n            //u will get it by urself ik :)\\n           if(it==dec.begin())continue;\\n           if(it1==inc.end())continue;\\n            \\n            it--;//this is for decrementing the non-increasing iterator as mentioned above\\n            \\n            //this is the required condition\\n                if((*it).second>=i&&(*it1).second<=i)\\n                res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623399,
                "title": "c-2100-find-good-days-to-rob-the-bank",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n = security.size(); \\n        vector<int> suffix(n); \\n        for (int i = n-2; i >= 0; --i) \\n            if (security[i] <= security[i+1]) suffix[i] = suffix[i+1] + 1; \\n        \\n        vector<int> ans; \\n        int prefix = 0; \\n        for (int i = 0; i < n-time; ++i) {\\n            if (i && security[i-1] >= security[i]) ++prefix; \\n            else prefix = 0; \\n            if (prefix >= time && suffix[i] >= time) ans.push_back(i); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n = security.size(); \\n        vector<int> suffix(n); \\n        for (int i = n-2; i >= 0; --i) \\n            if (security[i] <= security[i+1]) suffix[i] = suffix[i+1] + 1; \\n        \\n        vector<int> ans; \\n        int prefix = 0; \\n        for (int i = 0; i < n-time; ++i) {\\n            if (i && security[i-1] >= security[i]) ++prefix; \\n            else prefix = 0; \\n            if (prefix >= time && suffix[i] >= time) ans.push_back(i); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2611404,
                "title": "simple-python-easy-to-understand-solution-o-n",
                "content": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        n = len(security)\\n        pre = [0]*n\\n        post = [0]*n\\n        for i in range(1, n):\\n            if security[i-1] >= security[i]:\\n                pre[i] = pre[i-1] + 1\\n            else:\\n                pre[i] = 0\\n        for i in range(n-2, -1, -1):\\n            if security[i+1] >= security[i]:\\n                post[i] = post[i+1] + 1\\n            else:\\n                post[i] = 0\\n        res = []\\n        for i in range(n):\\n            if pre[i] >= time and post[i] >= time:\\n                res.append(i)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        n = len(security)\\n        pre = [0]*n\\n        post = [0]*n\\n        for i in range(1, n):\\n            if security[i-1] >= security[i]:\\n                pre[i] = pre[i-1] + 1\\n            else:\\n                pre[i] = 0\\n        for i in range(n-2, -1, -1):\\n            if security[i+1] >= security[i]:\\n                post[i] = post[i+1] + 1\\n            else:\\n                post[i] = 0\\n        res = []\\n        for i in range(n):\\n            if pre[i] >= time and post[i] >= time:\\n                res.append(i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2301932,
                "title": "c-tc-o-n-constant-space-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& st, int time) {\\n        int cnt = 0; // count no increasing element and decreasing element at same time \\n        int i = 0; // pointing to decreasing element\\n        int j = time; // pointing to increasing element\\n        vector<int> ans;\\n        while(j<st.size()){ //start traversing\\n            if(cnt==time){ // if we found cnt == time means no of decreasing && increasing  elements at left and right position are now target times then push current index into ans and cnt-- because current element is previous for next element \\n                ans.push_back(i);\\n                cnt--;\\n            }\\n            if(j!=st.size()-1 && st[i]>=st[i+1] && st[j]<=st[j+1]) {  // if array is  decreasing && increasing at same time at i and j then cnt++\\n                i++;\\n                j++;\\n                cnt++;\\n            } \\n            else{ // if any array in either non-decreasing in left and non-increasing in right or both then start a new count = 0\\n                i++;\\n                j++;\\n                cnt = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nIf You Like Solution Please Upvote:)\\nHappy Coding:)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& st, int time) {\\n        int cnt = 0; // count no increasing element and decreasing element at same time \\n        int i = 0; // pointing to decreasing element\\n        int j = time; // pointing to increasing element\\n        vector<int> ans;\\n        while(j<st.size()){ //start traversing\\n            if(cnt==time){ // if we found cnt == time means no of decreasing && increasing  elements at left and right position are now target times then push current index into ans and cnt-- because current element is previous for next element \\n                ans.push_back(i);\\n                cnt--;\\n            }\\n            if(j!=st.size()-1 && st[i]>=st[i+1] && st[j]<=st[j+1]) {  // if array is  decreasing && increasing at same time at i and j then cnt++\\n                i++;\\n                j++;\\n                cnt++;\\n            } \\n            else{ // if any array in either non-decreasing in left and non-increasing in right or both then start a new count = 0\\n                i++;\\n                j++;\\n                cnt = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786102,
                "title": "python-c-single-pass-o-n-time-o-1-space",
                "content": "The idea is to have two pointers seperated by `time`. The leading pointer (`p1`) counts how many days before it are non-decreasing, and the trailing pointer (`p0`) the number of days before it that are non-increasing. It\\'s a good day to rob the bank whenever both `p0` and `p1` are greater than `time`.\\n\\n**Python**\\n```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n\\t    n = len(security)\\n        if not time: return range(n)\\n        sols = []\\n        p0 = p1 = 0         \\n\\t\\tif n < 2*time: return sols\\n        for i in range(1, n-time):\\n            p0 += 1 if security[i-1] >= security[i] else -p0\\n            p1 += 1 if security[i+time-1] <= security[i+time] else -p1\\n            if p0 >= time and p1 >= time: sols.append(i)\\n        return sols\\n```\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n\\t    int n = security.size();\\n        int p0 = 0;\\n        int p1 = 0;\\n        vector<int> sols;\\n        \\n        if (time*2>n) return sols;\\n        if (time==0){\\n            sols.resize(n);\\n            iota(sols.begin(), sols.end(), 0);\\n            return sols;\\n        }\\n        \\n        for (int i=1; i < n-time; i++) {\\n            if (security[i-1]>=security[i]) p0++;\\n            else p0 = 0;\\n            if (security[i+time-1] <= security[i+time]) p1++;\\n            else p1 = 0;\\n            if (p0 >= time && p1 >= time) sols.push_back(i);   \\n        }\\n        return sols;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n\\t    n = len(security)\\n        if not time: return range(n)\\n        sols = []\\n        p0 = p1 = 0         \\n\\t\\tif n < 2*time: return sols\\n        for i in range(1, n-time):\\n            p0 += 1 if security[i-1] >= security[i] else -p0\\n            p1 += 1 if security[i+time-1] <= security[i+time] else -p1\\n            if p0 >= time and p1 >= time: sols.append(i)\\n        return sols\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n\\t    int n = security.size();\\n        int p0 = 0;\\n        int p1 = 0;\\n        vector<int> sols;\\n        \\n        if (time*2>n) return sols;\\n        if (time==0){\\n            sols.resize(n);\\n            iota(sols.begin(), sols.end(), 0);\\n            return sols;\\n        }\\n        \\n        for (int i=1; i < n-time; i++) {\\n            if (security[i-1]>=security[i]) p0++;\\n            else p0 = 0;\\n            if (security[i+time-1] <= security[i+time]) p1++;\\n            else p1 = 0;\\n            if (p0 >= time && p1 >= time) sols.push_back(i);   \\n        }\\n        return sols;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1666007,
                "title": "c-simple-2-pointer-precomputing-longest-increasing-decreasing-subarray-length",
                "content": "The core logic is simple. We somehow need to compute the longest increasing/decreasing subarray length. Then for each day, we can check if that day is suitable for robbery or not, using the condition given in the problem. \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n = security.size(), i = 0, j = 0; \\n        vector<int> nonDec(n, 1), nonInc(n, 0), res; \\n        \\n        while(j < n){\\n            nonInc[j] = j-i+1; \\n            if (j+1 < n && security[j] < security[j+1]) i = j+1; \\n            j++; \\n            \\n        }\\n        i = n-1, j = n-1; \\n        \\n        while(j >= 0){\\n            nonDec[j] = i-j + 1; \\n            if (j > 0 && security[j] < security[j-1]) i = j-1; \\n            j--; \\n            \\n        }\\n        \\n        for(int i=0; i<n ; i++){\\n            if(nonDec[i] > time && nonInc[i] > time) res.push_back(i); \\n        }\\n        return res ;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n = security.size(), i = 0, j = 0; \\n        vector<int> nonDec(n, 1), nonInc(n, 0), res; \\n        \\n        while(j < n){\\n            nonInc[j] = j-i+1; \\n            if (j+1 < n && security[j] < security[j+1]) i = j+1; \\n            j++; \\n            \\n        }\\n        i = n-1, j = n-1; \\n        \\n        while(j >= 0){\\n            nonDec[j] = i-j + 1; \\n            if (j > 0 && security[j] < security[j-1]) i = j-1; \\n            j--; \\n            \\n        }\\n        \\n        for(int i=0; i<n ; i++){\\n            if(nonDec[i] > time && nonInc[i] > time) res.push_back(i); \\n        }\\n        return res ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623719,
                "title": "simple-o-n-explained-javascript-solution",
                "content": "Let build to arrays `left[i]`and `right[i]`.\\nFor `left[i]=left[i-1]+1` if `security[i-1] >= security[i]` - not increasing order, or 0 otherwise.\\nFor `right[i] = right[i+1] +1` if `security[i+1] >= security[i]` - not decreasing order, or 0 otherwise.\\nThe day i is a good day to robe if `left[i] >= time && right[i] >= time`\\n\\n```\\nvar goodDaysToRobBank = function(security, time) {\\n    const n = security.length\\n    const left = buildLeftValidArray(security)\\n    const right = buildRightValidArray(security)\\n    \\n    const result = []\\n    for(let i = 0; i < security.length; i++){\\n        // The day i is good day to rob if left[i] and right[i] >= time\\n        if(left[i] >= time && right[i] >= time){\\n            result.push(i)\\n        }\\n    }\\n    \\n    return result\\n};\\n\\nfunction buildRightValidArray(security){\\n    const n = security.length\\n    const right = new Array(n)\\n    \\n    right[n-1] = 0\\n    \\n    for(let i = n-2; i >= 0; i--){\\n        if(security[i+1] >= security[i]){\\n            right[i] = right[i+1] +1\\n        }\\n        else{\\n            right[i] = 0\\n        }\\n    }\\n    \\n    return right\\n}\\n\\nfunction buildLeftValidArray(security){\\n    const n = security.length\\n    const left = new Array(n)\\n    left[0] = 0\\n    for(let i = 1; i < n; i++){\\n        if(security[i-1] >= security[i]){\\n            left[i] = left[i-1] + 1\\n        }else\\n        {\\n            left[i] = 0\\n        }\\n    }\\n    \\n    return left\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar goodDaysToRobBank = function(security, time) {\\n    const n = security.length\\n    const left = buildLeftValidArray(security)\\n    const right = buildRightValidArray(security)\\n    \\n    const result = []\\n    for(let i = 0; i < security.length; i++){\\n        // The day i is good day to rob if left[i] and right[i] >= time\\n        if(left[i] >= time && right[i] >= time){\\n            result.push(i)\\n        }\\n    }\\n    \\n    return result\\n};\\n\\nfunction buildRightValidArray(security){\\n    const n = security.length\\n    const right = new Array(n)\\n    \\n    right[n-1] = 0\\n    \\n    for(let i = n-2; i >= 0; i--){\\n        if(security[i+1] >= security[i]){\\n            right[i] = right[i+1] +1\\n        }\\n        else{\\n            right[i] = 0\\n        }\\n    }\\n    \\n    return right\\n}\\n\\nfunction buildLeftValidArray(security){\\n    const n = security.length\\n    const left = new Array(n)\\n    left[0] = 0\\n    for(let i = 1; i < n; i++){\\n        if(security[i-1] >= security[i]){\\n            left[i] = left[i-1] + 1\\n        }else\\n        {\\n            left[i] = 0\\n        }\\n    }\\n    \\n    return left\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1623331,
                "title": "java-prefix-arrays",
                "content": "```\\npublic List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        \\n        \\n        List<Integer> list = new ArrayList();\\n        \\n        int inc[] = new int[security.length];\\n        int dcr[] = new int[security.length];\\n        \\n        int count = 0;\\n        for(int i = 0;i<security.length-1;i++){\\n            if(security[i] >= security[i+1]){\\n                inc[i+1] = ++count;\\n            }else{\\n                count= 0;\\n                inc[i+1] = count;\\n            }\\n        }\\n        \\n         count = 0;\\n         for(int i=security.length-2; i>= 0;i--){\\n            if(security[i] <= security[i+1]){\\n                dcr[i] = ++count;\\n            }else{\\n                count= 0;\\n                dcr[i] = count;\\n            }\\n        }\\n        \\n        \\n        for(int i = 0;i<security.length;i++){\\n            if(inc[i] >= time && dcr[i] >= time){\\n                list.add(i);\\n            }\\n        }\\n \\n        return list;\\n\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        \\n        \\n        List<Integer> list = new ArrayList();\\n        \\n        int inc[] = new int[security.length];\\n        int dcr[] = new int[security.length];\\n        \\n        int count = 0;\\n        for(int i = 0;i<security.length-1;i++){\\n            if(security[i] >= security[i+1]){\\n                inc[i+1] = ++count;\\n            }else{\\n                count= 0;\\n                inc[i+1] = count;\\n            }\\n        }\\n        \\n         count = 0;\\n         for(int i=security.length-2; i>= 0;i--){\\n            if(security[i] <= security[i+1]){\\n                dcr[i] = ++count;\\n            }else{\\n                count= 0;\\n                dcr[i] = count;\\n            }\\n        }\\n        \\n        \\n        for(int i = 0;i<security.length;i++){\\n            if(inc[i] >= time && dcr[i] >= time){\\n                list.add(i);\\n            }\\n        }\\n \\n        return list;\\n\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1623302,
                "title": "left-to-right-and-right-to-left",
                "content": "We first go left-to-right, and collect `i` that has `time` non-increasing guards. We track those indices in `before`.\\n\\nThen, we go right-to-left and do the same for non-decreasing guards. If `i` is also in `before` - it\\'s a good day to rob a bank.\\n\\n(though, any day to rob a bank is a bad day)\\n\\n**C++**\\n```cpp\\nvector<int> goodDaysToRobBank(vector<int>& s, int time) {\\n    vector<int> before, res;\\n    int cnt = 0, sz = s.size();\\n    for (int i = 0; i < sz; ++i) {\\n        cnt = i > 0 && s[i - 1] >= s[i] ? cnt + 1 : 0;\\n        if (cnt >= time)\\n            before.push_back(i);\\n    }\\n    for (int i = sz - 1; !before.empty() && i >= 0; --i) {\\n        cnt = i < sz - 1 && s[i] <= s[i + 1] ? cnt + 1 : 0;\\n        if (cnt >= time && i == before.back())\\n            res.push_back(i);\\n        if (i <= before.back())\\n            before.pop_back();\\n    }        \\n    return vector<int>(rbegin(res), rend(res));\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<int> goodDaysToRobBank(vector<int>& s, int time) {\\n    vector<int> before, res;\\n    int cnt = 0, sz = s.size();\\n    for (int i = 0; i < sz; ++i) {\\n        cnt = i > 0 && s[i - 1] >= s[i] ? cnt + 1 : 0;\\n        if (cnt >= time)\\n            before.push_back(i);\\n    }\\n    for (int i = sz - 1; !before.empty() && i >= 0; --i) {\\n        cnt = i < sz - 1 && s[i] <= s[i + 1] ? cnt + 1 : 0;\\n        if (cnt >= time && i == before.back())\\n            res.push_back(i);\\n        if (i <= before.back())\\n            before.pop_back();\\n    }        \\n    return vector<int>(rbegin(res), rend(res));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3871097,
                "title": "prefix-sum-no-dp-easy-c-beats-100",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is very simple just count the number of **decreasing and increasing days** for each day and check whether this day is **good or not**.\\nHere I used **two vectors** to **store** the number of **decreasing and increasing** days for each ith day.\\n\\n```\\nFor example:- Security = [6,5,5,4,7,8,9,2] and Time = 2\\nFirst of all we will calculate the number of decreasing days for every ith day:-\\nDay 0:- 0\\nDay 1:- 1 ( [6] )\\nDay 2: -2 ( [6,5] )\\nDay 3:- 3 ( [6,5,5])\\nDay 4:- 0\\nDay 5:- 0\\nDay 6:- 0\\nDay 7:- 1 ( [9] )\\n\\nNow we will calculate the number of increasing days for every ith day:-\\nDay:-\\nDay 7:- 0\\nDay 6:- 0\\nDay 5:- 1 ( [9] )\\nDay 4: -2 ([8,9])\\nDay 3:- 3 ( [7,8,9] )\\nDay 2:- 0\\nDay 1:- 1 ( [5] )\\nDay 0:- 0\\n\\nWe can see that only the day-3 is a good day because there are three increasing and three decreasing days on this day.\\n```\\n\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& arr, int t) {\\n        int n = arr.size();\\n        vector<int> dec(n,0),inc(n,0),ans;\\n        for(int i = 1;i<n;i++) if(arr[i]<=arr[i-1]) dec[i]+=dec[i-1]+1;\\n        for(int i = n-2;i>=0;i--) if(arr[i]<=arr[i+1]) inc[i]+=inc[i+1]+1;\\n        for(int i = 0;i<n;i++)\\n        if(dec[i]>=t && inc[i]>=t) ans.push_back(i);\\n        return ans;   \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/8735c631-fefc-432d-82d9-0c60688c73b1_1691308823.9191308.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nFor example:- Security = [6,5,5,4,7,8,9,2] and Time = 2\\nFirst of all we will calculate the number of decreasing days for every ith day:-\\nDay 0:- 0\\nDay 1:- 1 ( [6] )\\nDay 2: -2 ( [6,5] )\\nDay 3:- 3 ( [6,5,5])\\nDay 4:- 0\\nDay 5:- 0\\nDay 6:- 0\\nDay 7:- 1 ( [9] )\\n\\nNow we will calculate the number of increasing days for every ith day:-\\nDay:-\\nDay 7:- 0\\nDay 6:- 0\\nDay 5:- 1 ( [9] )\\nDay 4: -2 ([8,9])\\nDay 3:- 3 ( [7,8,9] )\\nDay 2:- 0\\nDay 1:- 1 ( [5] )\\nDay 0:- 0\\n\\nWe can see that only the day-3 is a good day because there are three increasing and three decreasing days on this day.\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& arr, int t) {\\n        int n = arr.size();\\n        vector<int> dec(n,0),inc(n,0),ans;\\n        for(int i = 1;i<n;i++) if(arr[i]<=arr[i-1]) dec[i]+=dec[i-1]+1;\\n        for(int i = n-2;i>=0;i--) if(arr[i]<=arr[i+1]) inc[i]+=inc[i+1]+1;\\n        for(int i = 0;i<n;i++)\\n        if(dec[i]>=t && inc[i]>=t) ans.push_back(i);\\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2119827,
                "title": "simple-java-o-n-two-iteration-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        List<Integer> res = new ArrayList<>();\\n        if (time == 0) {\\n            for (int i = 0; i < security.length; i++) res.add(i);\\n            return res;\\n        }\\n        Set<Integer> set = new HashSet<>();\\n        int count = 1;\\n        for (int i = 1; i < security.length; i++) {\\n            if (security[i] <= security[i - 1]) {\\n                count++;\\n            } else {\\n                count = 1;\\n            }\\n            if (count > time) {\\n                set.add(i);\\n            }\\n        }\\n        \\n        count = 1;\\n        for (int i = security.length - 2; i >= 0; i--) {\\n            if (security[i] <= security[i + 1]) {\\n                count++;\\n            } else {\\n                count = 1;\\n            }\\n            if (count > time && set.contains(i)) res.add(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        List<Integer> res = new ArrayList<>();\\n        if (time == 0) {\\n            for (int i = 0; i < security.length; i++) res.add(i);\\n            return res;\\n        }\\n        Set<Integer> set = new HashSet<>();\\n        int count = 1;\\n        for (int i = 1; i < security.length; i++) {\\n            if (security[i] <= security[i - 1]) {\\n                count++;\\n            } else {\\n                count = 1;\\n            }\\n            if (count > time) {\\n                set.add(i);\\n            }\\n        }\\n        \\n        count = 1;\\n        for (int i = security.length - 2; i >= 0; i--) {\\n            if (security[i] <= security[i + 1]) {\\n                count++;\\n            } else {\\n                count = 1;\\n            }\\n            if (count > time && set.contains(i)) res.add(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2107182,
                "title": "c-prefix-suffix-consecutive-streaks-o-n-time-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int len = security.size();\\n        \\n        vector<int> leftCount(len, 0);\\n        for (int i = 1; i < len; i++) {\\n            if (security[i - 1] >= security[i]) {\\n                leftCount[i] += leftCount[i - 1] + 1;\\n            }\\n        }\\n        \\n        vector<int> rightCount(len);\\n        for (int i = len - 2; i >= 0; i--) {\\n            if (security[i] <= security[i + 1]) {\\n                rightCount[i] += rightCount[i + 1] + 1;\\n            }\\n        }\\n        \\n        vector<int> goodDayIndexes;\\n        for (int i = 0; i < len; i++) {\\n            if (leftCount[i] >= time && rightCount[i] >= time) {\\n                goodDayIndexes.push_back(i);\\n            }\\n        }\\n        \\n        return goodDayIndexes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int len = security.size();\\n        \\n        vector<int> leftCount(len, 0);\\n        for (int i = 1; i < len; i++) {\\n            if (security[i - 1] >= security[i]) {\\n                leftCount[i] += leftCount[i - 1] + 1;\\n            }\\n        }\\n        \\n        vector<int> rightCount(len);\\n        for (int i = len - 2; i >= 0; i--) {\\n            if (security[i] <= security[i + 1]) {\\n                rightCount[i] += rightCount[i + 1] + 1;\\n            }\\n        }\\n        \\n        vector<int> goodDayIndexes;\\n        for (int i = 0; i < len; i++) {\\n            if (leftCount[i] >= time && rightCount[i] >= time) {\\n                goodDayIndexes.push_back(i);\\n            }\\n        }\\n        \\n        return goodDayIndexes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1981073,
                "title": "c-prefix-and-suffix-o-n-time-and-space",
                "content": "```\\n/* \\n    Time: O(n)\\n    Space: O(n)\\n    Tag: Array Manipulation, Prefix, Sufix manipilation\\n    Difficulty: MH\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int> &security, int time) {\\n        int n = security.size();\\n        vector<int> leftSide(n), righSide(n);\\n        leftSide[0] = 0;\\n        for (int i = 1; i < n; i++) {\\n            if (security[i - 1] >= security[i])\\n                leftSide[i] = leftSide[i - 1];\\n            else\\n                leftSide[i] = i;\\n        }\\n        righSide[n - 1] = n - 1;\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (security[i + 1] < security[i])\\n                righSide[i] = i;\\n            else\\n                righSide[i] = righSide[i + 1];\\n        }\\n        vector<int> res;\\n        for (int i = 0; i < n; i++) {\\n            if (leftSide[i] <= i - time && righSide[i] >= i + time) res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Suffix Array"
                ],
                "code": "```\\n/* \\n    Time: O(n)\\n    Space: O(n)\\n    Tag: Array Manipulation, Prefix, Sufix manipilation\\n    Difficulty: MH\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int> &security, int time) {\\n        int n = security.size();\\n        vector<int> leftSide(n), righSide(n);\\n        leftSide[0] = 0;\\n        for (int i = 1; i < n; i++) {\\n            if (security[i - 1] >= security[i])\\n                leftSide[i] = leftSide[i - 1];\\n            else\\n                leftSide[i] = i;\\n        }\\n        righSide[n - 1] = n - 1;\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (security[i + 1] < security[i])\\n                righSide[i] = i;\\n            else\\n                righSide[i] = righSide[i + 1];\\n        }\\n        vector<int> res;\\n        for (int i = 0; i < n; i++) {\\n            if (leftSide[i] <= i - time && righSide[i] >= i + time) res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1961522,
                "title": "javascript-iterative-o-n-time-o-n-space-91-time-54-space",
                "content": "```\\nvar goodDaysToRobBank = function(security, time) {\\n    let decrease = [0];\\n    let increase = Array(security.length).fill(0);\\n    \\n    // Prefix\\n    for (let i = 1; i < security.length; i++) {\\n        if (security[i] <= security[i - 1]) decrease[i] = decrease[i - 1] + 1;\\n        else decrease[i] = 0;\\n    }\\n\\t\\n    // Suffix\\n    for (let j = security.length - 2; j >= 0; j--) {\\n        if (security[j] <= security[j + 1]) increase[j] = increase[j + 1] + 1;\\n        else increase[j] = 0;\\n    }\\n    \\n    let output = [];\\n    for (let k = 0; k < security.length; k++) {\\n        let left = decrease[k];\\n        let right = increase[k];\\n        if (left >= time && right >= time) output.push(k);\\n    }\\n    \\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar goodDaysToRobBank = function(security, time) {\\n    let decrease = [0];\\n    let increase = Array(security.length).fill(0);\\n    \\n    // Prefix\\n    for (let i = 1; i < security.length; i++) {\\n        if (security[i] <= security[i - 1]) decrease[i] = decrease[i - 1] + 1;\\n        else decrease[i] = 0;\\n    }\\n\\t\\n    // Suffix\\n    for (let j = security.length - 2; j >= 0; j--) {\\n        if (security[j] <= security[j + 1]) increase[j] = increase[j + 1] + 1;\\n        else increase[j] = 0;\\n    }\\n    \\n    let output = [];\\n    for (let k = 0; k < security.length; k++) {\\n        let left = decrease[k];\\n        let right = increase[k];\\n        if (left >= time && right >= time) output.push(k);\\n    }\\n    \\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1842503,
                "title": "java-prefix-and-suffix-method-easy-to-read-code",
                "content": "![image](https://assets.leetcode.com/users/images/4d52bbc9-42ba-4595-831c-1f6bb9f099e2_1647090498.2979236.png)\\n\\n\\n```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] arr, int time) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        int n = arr.length;\\n// keep two arrays pre and post\\n// pre[i] and post[i] will have the start index of the streak uptill i\\n// streak for pre is until arr[i]<=arr[i-1] is followed\\n// streak for post is until arr[i]<=arr[i+1] is followed\\n        \\n// a day will be good day to rob the bank if\\n//1. pre[i-1]<=i-time i.e. streak is followed for i-time days.\\n//2. post[i+1]>=i+timr i.e. streak is followed for i+time days.\\n//3. arr[i]<=arr[i-1]&&arr[i]<=arr[i+1]\\n        \\n        \\n        int[]pre = new int[n];\\n        int[] post = new int[n];\\n        pre[0] = 0;\\n        \\n        if(time==0)\\n        {\\n            for(int i=0;i<n;i++)\\n                res.add(i);\\n            return res;\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            if(arr[i]<=arr[i-1])\\n                pre[i] = pre[i-1]; // prev streak continue\\n            else\\n            {\\n                // new streak start\\n                pre[i] = i;\\n            }\\n        }\\n        post[n-1] = n-1;\\n         for(int i=n-2;i>=0;i--)\\n        {\\n            if(arr[i]<=arr[i+1])\\n                post[i] = post[i+1]; // prev streak continue\\n            else\\n            {\\n                // new streak start\\n                post[i] = i;\\n            }\\n        }\\n        for(int i=time;i<n-time;i++)\\n        {\\n            if((pre[i-1]<=i-time)&&(post[i+1]>=(i+time)&&(arr[i]<=arr[i-1])&&(arr[i]<=arr[i+1])))\\n                res.add(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] arr, int time) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        int n = arr.length;\\n// keep two arrays pre and post\\n// pre[i] and post[i] will have the start index of the streak uptill i\\n// streak for pre is until arr[i]<=arr[i-1] is followed\\n// streak for post is until arr[i]<=arr[i+1] is followed\\n        \\n// a day will be good day to rob the bank if\\n//1. pre[i-1]<=i-time i.e. streak is followed for i-time days.\\n//2. post[i+1]>=i+timr i.e. streak is followed for i+time days.\\n//3. arr[i]<=arr[i-1]&&arr[i]<=arr[i+1]\\n        \\n        \\n        int[]pre = new int[n];\\n        int[] post = new int[n];\\n        pre[0] = 0;\\n        \\n        if(time==0)\\n        {\\n            for(int i=0;i<n;i++)\\n                res.add(i);\\n            return res;\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            if(arr[i]<=arr[i-1])\\n                pre[i] = pre[i-1]; // prev streak continue\\n            else\\n            {\\n                // new streak start\\n                pre[i] = i;\\n            }\\n        }\\n        post[n-1] = n-1;\\n         for(int i=n-2;i>=0;i--)\\n        {\\n            if(arr[i]<=arr[i+1])\\n                post[i] = post[i+1]; // prev streak continue\\n            else\\n            {\\n                // new streak start\\n                post[i] = i;\\n            }\\n        }\\n        for(int i=time;i<n-time;i++)\\n        {\\n            if((pre[i-1]<=i-time)&&(post[i+1]>=(i+time)&&(arr[i]<=arr[i-1])&&(arr[i]<=arr[i+1])))\\n                res.add(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1648599,
                "title": "20-lines-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int n=security.length;\\n        int prefix[]=new int[n],suffix[]=new int[n];\\n        prefix[0]=0;suffix[n-1]=0;\\n        for(int i=1;i<n;i++)\\n            if(security[i-1]>=security[i])prefix[i]=prefix[i-1]+1;\\n            else prefix[i]=0;\\n        \\n        for(int i=n-2;i>=0;i--)\\n            if(security[i+1]>=security[i])suffix[i]=suffix[i+1]+1;\\n            else suffix[i]=0;\\n        \\n        List<Integer> res=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n            if(prefix[i]>=time && suffix[i]>=time)res.add(i);\\n        \\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int n=security.length;\\n        int prefix[]=new int[n],suffix[]=new int[n];\\n        prefix[0]=0;suffix[n-1]=0;\\n        for(int i=1;i<n;i++)\\n            if(security[i-1]>=security[i])prefix[i]=prefix[i-1]+1;\\n            else prefix[i]=0;\\n        \\n        for(int i=n-2;i>=0;i--)\\n            if(security[i+1]>=security[i])suffix[i]=suffix[i+1]+1;\\n            else suffix[i]=0;\\n        \\n        List<Integer> res=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n            if(prefix[i]>=time && suffix[i]>=time)res.add(i);\\n        \\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1627838,
                "title": "java-easy-and-concise-sliding-window-o-n",
                "content": "Just find if there are two fixed sliding windows [i-time, i] and [i, i + time]\\n```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        List<Integer> res = new ArrayList();\\n        int n = security.length, slow = 0;\\n        boolean[] left = new boolean[n]; // if there is a non-increasing sliding window start from [i - time, i]\\n        for(int i = 0; i < n; i++) {\\n            if(i == 0 || security[i] > security[i-1]) {  \\n                slow = i;\\n            } \\n            if(i - slow >= time) {\\n                left[i] = true;                \\n            }  \\n        }\\n        slow = n-1;\\n        for(int i = n-1; i >= 0; i--) {\\n            if(i == n-1 || security[i] > security[i+1]) {  \\n                slow = i;\\n            } \\n            if(slow - i >= time && left[i]) {\\n                res.add(i);           \\n            }  \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        List<Integer> res = new ArrayList();\\n        int n = security.length, slow = 0;\\n        boolean[] left = new boolean[n]; // if there is a non-increasing sliding window start from [i - time, i]\\n        for(int i = 0; i < n; i++) {\\n            if(i == 0 || security[i] > security[i-1]) {  \\n                slow = i;\\n            } \\n            if(i - slow >= time) {\\n                left[i] = true;                \\n            }  \\n        }\\n        slow = n-1;\\n        for(int i = n-1; i >= 0; i--) {\\n            if(i == n-1 || security[i] > security[i+1]) {  \\n                slow = i;\\n            } \\n            if(slow - i >= time && left[i]) {\\n                res.add(i);           \\n            }  \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625986,
                "title": "c-queue-vs-single-pass-4-pointers-vs-dp-solutions-compared-64ms-81mb",
                "content": "My first approach was to think of a queue before and one after our scanned day that in turn would reveal to us if the day was auspicious for a robbery or not.\\n\\nAnd thus I proceeded, first of all cutting a few edge cases out:\\n* if the time `t` is `0`, then each single element is valid and we can just overwrite `sec` with `iota` to be a succession of `sec.size()` elements starting from `0`, right before `return`ing it;\\n* conversely, if `t` was less than half `sec.size()`, no point in proceeding either, since we know already that no valid day can match our condition in terms of valid range, so we can just `return` an empty vector.\\n\\nWith that out of the table, we can focus on our core, general logic, declaring a few support variables:\\n* `len` will store the how many days we need to parse;\\n* `before` and `after` are aptly named queues which will store all the matching days as we progress;\\n* `res` is our accumulator variable where we will store our final result.\\n\\nTime to parse `sec`, using two pointers, `l` set to `0` and `m` set to `t` (that we increase now for convenience later); going on until `m < len`, and increasing them at each iteration, we will:\\n* reset `before` if it has at least one element and its last element is less then the one currently pointed by `l`;\\n* push said element (`sec[l]`) into `before`;\\n* specularly, reset `after` if it has at least one element and its last element is less then the one currently pointed by `m`;\\n* push said element (`sec[m]`) into `after`;\\n* check if the length of both `before` or `after` matches the current value of `t` (the original one, increased by `1`) and in case store the current index `m` into `res`, since we now know it\\'s a valid one;\\n* pop the front of `before` if its length is nw `t`;\\n* pop the front of `after` if its length is nw `t`.\\n\\nOnce done, we can just `return` `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& sec, int t) {\\n        // edge cases\\n        if (!t) {\\n            iota(begin(sec), end(sec), 0);\\n            return sec;\\n        }\\n        if (2 * t > sec.size()) return {};\\n        // support variables\\n        int len = sec.size();\\n        queue<int> before, after;\\n        vector<int> res;\\n        // preparing before and after\\n        for (int l = 0, m = t++; m < len; l++, m++) {\\n            if (before.size() && before.back() < sec[l]) {\\n                before = queue<int> ();\\n            }\\n            before.push(sec[l]);\\n            if (after.size() && after.back() > sec[m]) {\\n                after = queue<int> ();\\n            }\\n            after.push(sec[m]);\\n            if (before.size() == t && after.size() == t) res.push_back(l);\\n            if (before.size() == t) before.pop();\\n            if (after.size() == t) after.pop();\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nDo we actually care if we have more than the minimum amount of valid days in front of us? Not at all, so we might risk sacrificing a bit more memory (but it does not seem to be the case, running a few test cases) and avoid popping altogether from either queue, in this slightly quicker version:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& sec, int t) {\\n        // edge cases\\n        if (!t) {\\n            iota(begin(sec), end(sec), 0);\\n            return sec;\\n        }\\n        if (2 * t > sec.size()) return {};\\n        // support variables\\n        int len = sec.size();\\n        queue<int> before, after;\\n        vector<int> res;\\n        // building before and after\\n        for (int l = 0, m = t++; m < len; l++, m++) {\\n            if (before.size() && before.back() < sec[l]) {\\n                before = queue<int> ();\\n            }\\n            before.push(sec[l]);\\n            if (after.size() && after.back() > sec[m]) {\\n                after = queue<int> ();\\n            }\\n            after.push(sec[m]);\\n            if (before.size() >= t && after.size() >= t) res.push_back(l);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nBut, hey! Now that we put it this way, we do not even need to proceed with queues, since we would be just inserting elements in following the same order they have in `sec`; it might be much leaner and memory efficient if instead we rely on 4 pointers now, a pair each to delimit our `before` and `after` range, modifying the code like this and getting a crazy improvement (half the time, less than half the space!):\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& sec, int t) {\\n        // edge cases\\n        if (!t) {\\n            iota(begin(sec), end(sec), 0);\\n            return sec;\\n        }\\n        if (2 * t > sec.size()) return {};\\n        // support variables\\n        int len = sec.size();\\n        vector<int> res;\\n        // updating before and after range pointers\\n        for (int i = 0, l = 0, j = t, m = t; m < len; l++, m++) {\\n            if (l && sec[l - 1] < sec[l]) {\\n                i = l;\\n            }\\n            if (sec[m - 1] > sec[m]) {\\n                j = m;\\n            }\\n            if (l - i >= t && m - j >= t) res.push_back(l);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nNotice that this runs in just one pass, whereas we need at least two passes for a typical DP here; I tried to run it just for the sake of it and it was definitely a bit slower, since computing everything in advance and storing it was really not necessary.\\n\\nTo my surprise, the performance is basically the same as the solution above:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& sec, int t) {\\n        // edge cases\\n        if (!t) {\\n            iota(begin(sec), end(sec), 0);\\n            return sec;\\n        }\\n        if (2 * t >= sec.size()) return {};\\n        // support variables\\n        int len = sec.size() - 2 * t;\\n        bool before[len], after[len];\\n        fill(before, before + len, false);\\n        fill(after, after + len, false);\\n        vector<int> res;\\n        // preparing before and after\\n        for (int i = 0, currL = 0, j = sec.size() - 1, currR = 0; j >= t; i++, j--) {\\n            if (i && sec[i - 1] < sec[i]) currL = 0;\\n            if (currL++ >= t) before[i - t] = true;\\n            if (i && sec[j + 1] < sec[j]) currR = 0;\\n            if (currR++ >= t) after[j -  t] = true;\\n        }\\n        // populating res\\n        for (int i = 0, j = t; i < len; i++, j++) {\\n            if (before[i] && after[i]) res.push_back(j);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Queue"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& sec, int t) {\\n        // edge cases\\n        if (!t) {\\n            iota(begin(sec), end(sec), 0);\\n            return sec;\\n        }\\n        if (2 * t > sec.size()) return {};\\n        // support variables\\n        int len = sec.size();\\n        queue<int> before, after;\\n        vector<int> res;\\n        // preparing before and after\\n        for (int l = 0, m = t++; m < len; l++, m++) {\\n            if (before.size() && before.back() < sec[l]) {\\n                before = queue<int> ();\\n            }\\n            before.push(sec[l]);\\n            if (after.size() && after.back() > sec[m]) {\\n                after = queue<int> ();\\n            }\\n            after.push(sec[m]);\\n            if (before.size() == t && after.size() == t) res.push_back(l);\\n            if (before.size() == t) before.pop();\\n            if (after.size() == t) after.pop();\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& sec, int t) {\\n        // edge cases\\n        if (!t) {\\n            iota(begin(sec), end(sec), 0);\\n            return sec;\\n        }\\n        if (2 * t > sec.size()) return {};\\n        // support variables\\n        int len = sec.size();\\n        queue<int> before, after;\\n        vector<int> res;\\n        // building before and after\\n        for (int l = 0, m = t++; m < len; l++, m++) {\\n            if (before.size() && before.back() < sec[l]) {\\n                before = queue<int> ();\\n            }\\n            before.push(sec[l]);\\n            if (after.size() && after.back() > sec[m]) {\\n                after = queue<int> ();\\n            }\\n            after.push(sec[m]);\\n            if (before.size() >= t && after.size() >= t) res.push_back(l);\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& sec, int t) {\\n        // edge cases\\n        if (!t) {\\n            iota(begin(sec), end(sec), 0);\\n            return sec;\\n        }\\n        if (2 * t > sec.size()) return {};\\n        // support variables\\n        int len = sec.size();\\n        vector<int> res;\\n        // updating before and after range pointers\\n        for (int i = 0, l = 0, j = t, m = t; m < len; l++, m++) {\\n            if (l && sec[l - 1] < sec[l]) {\\n                i = l;\\n            }\\n            if (sec[m - 1] > sec[m]) {\\n                j = m;\\n            }\\n            if (l - i >= t && m - j >= t) res.push_back(l);\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& sec, int t) {\\n        // edge cases\\n        if (!t) {\\n            iota(begin(sec), end(sec), 0);\\n            return sec;\\n        }\\n        if (2 * t >= sec.size()) return {};\\n        // support variables\\n        int len = sec.size() - 2 * t;\\n        bool before[len], after[len];\\n        fill(before, before + len, false);\\n        fill(after, after + len, false);\\n        vector<int> res;\\n        // preparing before and after\\n        for (int i = 0, currL = 0, j = sec.size() - 1, currR = 0; j >= t; i++, j--) {\\n            if (i && sec[i - 1] < sec[i]) currL = 0;\\n            if (currL++ >= t) before[i - t] = true;\\n            if (i && sec[j + 1] < sec[j]) currR = 0;\\n            if (currR++ >= t) after[j -  t] = true;\\n        }\\n        // populating res\\n        for (int i = 0, j = t; i < len; i++, j++) {\\n            if (before[i] && after[i]) res.push_back(j);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623966,
                "title": "java-soluton-with-explanation-easy-to-understand-happycoding",
                "content": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        List<Integer>  res = new ArrayList<>();\\n        if(security == null || security.length == 0) return res;\\n        int n = security.length;\\n        \\n        // do preparations to save checking time\\n        // Store how many numbers larger than current number on the left side\\n        int[] largerCountOnLeft = new int[n];        \\n        int leftCount = 0;        \\n        for(int i = 1; i < n; i++){\\n             if(security[i] <= security[i-1]){\\n                  leftCount++;\\n                  largerCountOnLeft[i] = leftCount;\\n             }else{\\n                 leftCount = 0;\\n             }\\n        }\\n        \\n        // Store how many numbers larger than current number on the right side\\n        int[] largerCountOnRight = new int[n];\\n        int rightCount = 0;\\n        for(int i = n-2; i >= 0; i--){\\n             if(security[i] <= security[i+1]){\\n                  rightCount++;\\n                  largerCountOnRight[i] = rightCount;\\n             }else{\\n                  rightCount = 0;\\n             }\\n        }\\n        \\n        \\n        // check if current number is lowest than right and left and both sides has time+ numbers larger than current number\\n        for(int i = time; i < n - time; i++){\\n            if(largerCountOnLeft[i] >= time && largerCountOnRight[i] >= time){\\n                res.add(i);\\n            }             \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        List<Integer>  res = new ArrayList<>();\\n        if(security == null || security.length == 0) return res;\\n        int n = security.length;\\n        \\n        // do preparations to save checking time\\n        // Store how many numbers larger than current number on the left side\\n        int[] largerCountOnLeft = new int[n];        \\n        int leftCount = 0;        \\n        for(int i = 1; i < n; i++){\\n             if(security[i] <= security[i-1]){\\n                  leftCount++;\\n                  largerCountOnLeft[i] = leftCount;\\n             }else{\\n                 leftCount = 0;\\n             }\\n        }\\n        \\n        // Store how many numbers larger than current number on the right side\\n        int[] largerCountOnRight = new int[n];\\n        int rightCount = 0;\\n        for(int i = n-2; i >= 0; i--){\\n             if(security[i] <= security[i+1]){\\n                  rightCount++;\\n                  largerCountOnRight[i] = rightCount;\\n             }else{\\n                  rightCount = 0;\\n             }\\n        }\\n        \\n        \\n        // check if current number is lowest than right and left and both sides has time+ numbers larger than current number\\n        for(int i = time; i < n - time; i++){\\n            if(largerCountOnLeft[i] >= time && largerCountOnRight[i] >= time){\\n                res.add(i);\\n            }             \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623636,
                "title": "c-prefix-suffix-array-self-explanatory-0-n-solution",
                "content": "```\\n`vector<int> goodDaysToRobBank(vector<int>& a, int t) {\\n        int n=a.size();\\n        int b[n],c[n];\\n        b[0]=0;\\n        for(int i=1;i<n;i++){\\n            if(a[i]<=a[i-1]){\\n                b[i]=b[i-1]+1;\\n            }\\n            else{\\n                b[i]=0;\\n            }\\n        }\\n        c[0]=0;\\n        for(int i=1;i<n;i++){\\n            if(a[i]>=a[i-1]){\\n                c[i]=c[i-1]+1;\\n            }\\n            else{\\n                c[i]=0;\\n            }\\n        }\\n        vector<int> v;\\n        for(int i=t;i<n-t;i++){\\n            if(b[i]>=t&&c[i+t]>=t){\\n                v.push_back(i);\\n            }\\n        }\\n        return v;\\n    }\\n\\n``",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n`vector<int> goodDaysToRobBank(vector<int>& a, int t) {\\n        int n=a.size();\\n        int b[n],c[n];\\n        b[0]=0;\\n        for(int i=1;i<n;i++){\\n            if(a[i]<=a[i-1]){\\n                b[i]=b[i-1]+1;\\n            }\\n            else{\\n                b[i]=0;\\n            }\\n        }\\n        c[0]=0;\\n        for(int i=1;i<n;i++){\\n            if(a[i]>=a[i-1]){\\n                c[i]=c[i-1]+1;\\n            }\\n            else{\\n                c[i]=0;\\n            }\\n        }\\n        vector<int> v;\\n        for(int i=t;i<n-t;i++){\\n            if(b[i]>=t&&c[i+t]>=t){\\n                v.push_back(i);\\n            }\\n        }\\n        return v;\\n    }\\n\\n``",
                "codeTag": "Unknown"
            },
            {
                "id": 1623367,
                "title": "sliding-window-c",
                "content": "The idea is:\\n1 if the last day is a good day, only two day need to be checked\\n2 if the last day is not a good day, calculate it by check the decrease and increase condition\\n\\n    bool isGoodDay(vector<int>& security, int time, int day)\\n    {\\n        for(int i = day - time + 1; i <= day; i++)\\n        {\\n            if(security[i] > security[i-1]) return false;\\n        }\\n        for(int i = day + 1; i <= day + time; i++)\\n        {\\n            if(security[i] < security[i-1]) return false;\\n        }\\n        return true;\\n    }\\n\\t\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        vector<int> ans;\\n        int n = security.size();\\n        if(time == 0) \\n        {\\n            for(int i = 0; i < n; i++) ans.push_back(i);\\n            return ans;\\n        }\\n        if(n < 3) return ans;\\n        bool isPreGoodDay = false;\\n        for(int i = time; i < n - time; i++){\\n            if(!isPreGoodDay){\\n                if(isGoodDay(security,time,i)){\\n                   ans.push_back(i);\\n                   isPreGoodDay = true;\\n               }\\n            }\\n            else {\\n               if(security[i] <= security[i-1]  && security[i + time] >= security[i + time - 1] ){\\n                   ans.push_back(i);\\n               }\\n                else isPreGoodDay = false;\\n            }\\n        }\\n        return ans;\\n        \\n    }",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "The idea is:\\n1 if the last day is a good day, only two day need to be checked\\n2 if the last day is not a good day, calculate it by check the decrease and increase condition\\n\\n    bool isGoodDay(vector<int>& security, int time, int day)\\n    {\\n        for(int i = day - time + 1; i <= day; i++)\\n        {\\n            if(security[i] > security[i-1]) return false;\\n        }\\n        for(int i = day + 1; i <= day + time; i++)\\n        {\\n            if(security[i] < security[i-1]) return false;\\n        }\\n        return true;\\n    }\\n\\t\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        vector<int> ans;\\n        int n = security.size();\\n        if(time == 0) \\n        {\\n            for(int i = 0; i < n; i++) ans.push_back(i);\\n            return ans;\\n        }\\n        if(n < 3) return ans;\\n        bool isPreGoodDay = false;\\n        for(int i = time; i < n - time; i++){\\n            if(!isPreGoodDay){\\n                if(isGoodDay(security,time,i)){\\n                   ans.push_back(i);\\n                   isPreGoodDay = true;\\n               }\\n            }\\n            else {\\n               if(security[i] <= security[i-1]  && security[i + time] >= security[i + time - 1] ){\\n                   ans.push_back(i);\\n               }\\n                else isPreGoodDay = false;\\n            }\\n        }\\n        return ans;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3931272,
                "title": "sliding-window-approach-in-java",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) [Though queue size is TIME but the arrays of size N is used to store valid days index]\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        Deque<Integer> deque = new ArrayDeque<>();\\n        int n = security.length;\\n        List<Integer> arr = new ArrayList<>();\\n        if(time>=n) {return arr;}\\n        // add the window of size time elements in deque which are in decreased form\\n        for(int i=0;i<(time);i++) {\\n            while(deque.size()>0 && security[deque.peekLast()]<security[i]) {\\n                deque.removeLast();\\n            }\\n            deque.addLast(i);\\n        }\\n        // get the valid days whose left side elements are in decreased form in size time\\n        int left[] = getLeftValidDays(security, time, deque);\\n    \\n        deque = new ArrayDeque<>();\\n        //add the window of size time elements in deque which are in increased form\\n        for(int i=n-1;i>n-1-time;i--) {\\n             while(deque.size()>0 && security[deque.peekLast()]<security[i]) {\\n                deque.removeLast();\\n            }\\n            deque.addLast(i);\\n        }\\n        // get the valid days whose right side elements are in increased form in size time\\n        int right[] = getRightValidDays(security, time, deque);\\n\\n        // check if both left days & right days of that element are valid . If yes then add in list\\n        for(int i=time;i<=n-1-time;i++) {\\n            if((left[i]*right[i])==1) {\\n                arr.add(i);\\n            }\\n        }\\n        return arr;\\n    }\\n\\n    private int[] getLeftValidDays(int security[], int time, Deque<Integer> deque) {\\n        int n = security.length;\\n        int left[] = new int[n];\\n        Arrays.fill(left, 0);\\n        \\n        for(int i=time;i<=(n-1-time);i++) {\\n            int validIndexRange = i-time;\\n            while(deque.size()>0 && deque.peekFirst()<validIndexRange) {\\n                deque.removeFirst();\\n            }\\n            if((time==0) || (deque.size()==time && security[deque.peekLast()]>=security[i])) {\\n                left[i] = 1;\\n            }\\n            while(deque.size()>0 && security[deque.peekLast()]<security[i]) {\\n                deque.removeLast();\\n            }\\n            deque.addLast(i);\\n        }\\n        return left;\\n    }\\n\\n    private int[] getRightValidDays(int security[], int time, Deque<Integer> deque) {\\n\\n        int n = security.length;\\n        int right[] = new int[n];\\n        Arrays.fill(right, 0);\\n\\n        for(int i= n-1-time; i>=time;i--) {\\n            int validIndexRange = i+time;\\n            while(deque.size()>0 && deque.peekFirst()>validIndexRange) {\\n                deque.removeFirst();\\n            }\\n            if((time==0 ) || (security[deque.peekLast()]>=security[i] && deque.size()==time) ){\\n                right[i] = 1;\\n            }\\n            while(deque.size()>0 && security[deque.peekLast()]<security[i]) {\\n                deque.removeLast();\\n            }\\n            deque.addLast(i);\\n        }\\n        return right;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window",
                    "Monotonic Queue"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        Deque<Integer> deque = new ArrayDeque<>();\\n        int n = security.length;\\n        List<Integer> arr = new ArrayList<>();\\n        if(time>=n) {return arr;}\\n        // add the window of size time elements in deque which are in decreased form\\n        for(int i=0;i<(time);i++) {\\n            while(deque.size()>0 && security[deque.peekLast()]<security[i]) {\\n                deque.removeLast();\\n            }\\n            deque.addLast(i);\\n        }\\n        // get the valid days whose left side elements are in decreased form in size time\\n        int left[] = getLeftValidDays(security, time, deque);\\n    \\n        deque = new ArrayDeque<>();\\n        //add the window of size time elements in deque which are in increased form\\n        for(int i=n-1;i>n-1-time;i--) {\\n             while(deque.size()>0 && security[deque.peekLast()]<security[i]) {\\n                deque.removeLast();\\n            }\\n            deque.addLast(i);\\n        }\\n        // get the valid days whose right side elements are in increased form in size time\\n        int right[] = getRightValidDays(security, time, deque);\\n\\n        // check if both left days & right days of that element are valid . If yes then add in list\\n        for(int i=time;i<=n-1-time;i++) {\\n            if((left[i]*right[i])==1) {\\n                arr.add(i);\\n            }\\n        }\\n        return arr;\\n    }\\n\\n    private int[] getLeftValidDays(int security[], int time, Deque<Integer> deque) {\\n        int n = security.length;\\n        int left[] = new int[n];\\n        Arrays.fill(left, 0);\\n        \\n        for(int i=time;i<=(n-1-time);i++) {\\n            int validIndexRange = i-time;\\n            while(deque.size()>0 && deque.peekFirst()<validIndexRange) {\\n                deque.removeFirst();\\n            }\\n            if((time==0) || (deque.size()==time && security[deque.peekLast()]>=security[i])) {\\n                left[i] = 1;\\n            }\\n            while(deque.size()>0 && security[deque.peekLast()]<security[i]) {\\n                deque.removeLast();\\n            }\\n            deque.addLast(i);\\n        }\\n        return left;\\n    }\\n\\n    private int[] getRightValidDays(int security[], int time, Deque<Integer> deque) {\\n\\n        int n = security.length;\\n        int right[] = new int[n];\\n        Arrays.fill(right, 0);\\n\\n        for(int i= n-1-time; i>=time;i--) {\\n            int validIndexRange = i+time;\\n            while(deque.size()>0 && deque.peekFirst()>validIndexRange) {\\n                deque.removeFirst();\\n            }\\n            if((time==0 ) || (security[deque.peekLast()]>=security[i] && deque.size()==time) ){\\n                right[i] = 1;\\n            }\\n            while(deque.size()>0 && security[deque.peekLast()]<security[i]) {\\n                deque.removeLast();\\n            }\\n            deque.addLast(i);\\n        }\\n        return right;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833331,
                "title": "java-5ms-solution-o-n-time-complexity-and-o-n-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        List<Integer> list = new ArrayList<>();\\n        int n=security.length;\\n        int dpbef[]=new int[n];\\n        int dpaft[]=new int[n];\\n        for(int i=1;i<n;i++){\\n            if(security[i-1]>=security[i]){\\n               dpbef[i]=dpbef[i-1]+1;\\n            }\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            if(security[i]<=security[i+1]){\\n               dpaft[i]=dpaft[i+1]+1;\\n            }\\n        }\\n        for(int i=time;i<=n-time && i<n;i++){\\n            if(dpbef[i]>=time && dpaft[i]>=time){\\n                list.add(i);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        List<Integer> list = new ArrayList<>();\\n        int n=security.length;\\n        int dpbef[]=new int[n];\\n        int dpaft[]=new int[n];\\n        for(int i=1;i<n;i++){\\n            if(security[i-1]>=security[i]){\\n               dpbef[i]=dpbef[i-1]+1;\\n            }\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            if(security[i]<=security[i+1]){\\n               dpaft[i]=dpaft[i+1]+1;\\n            }\\n        }\\n        for(int i=time;i<=n-time && i<n;i++){\\n            if(dpbef[i]>=time && dpaft[i]>=time){\\n                list.add(i);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613520,
                "title": "java-solution-with-explanation",
                "content": "# Intuition\\nIn this type of questions, we need to think what is happening at every index and what is repeating.\\nAt every index we need to find whether in left their is decreasing and in right there is increasing or not.\\nSo instead of calculating every time we store the length of decreasing and increasing in 2 auxilliary array, and using this 2 array as lookup to find which index is safe.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int n = security.length;\\n        int[] left = new int[n];\\n        int[] right = new int[n];\\n\\n        for(int i = 1; i < n; i++){\\n            if(security[i-1] >= security[i]){\\n                left[i] = left[i-1] + 1;\\n            }\\n        }\\n        for(int i = n-2; i >= 0; i--){\\n            if(security[i] <= security[i+1]){\\n                right[i] = right[i+1] + 1;\\n            }\\n        }\\n        List<Integer> list = new ArrayList<>();\\n        for(int i = 0; i < n; i++){\\n            if(left[i] >= time && right[i] >= time){\\n                list.add(i);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int n = security.length;\\n        int[] left = new int[n];\\n        int[] right = new int[n];\\n\\n        for(int i = 1; i < n; i++){\\n            if(security[i-1] >= security[i]){\\n                left[i] = left[i-1] + 1;\\n            }\\n        }\\n        for(int i = n-2; i >= 0; i--){\\n            if(security[i] <= security[i+1]){\\n                right[i] = right[i+1] + 1;\\n            }\\n        }\\n        List<Integer> list = new ArrayList<>();\\n        for(int i = 0; i < n; i++){\\n            if(left[i] >= time && right[i] >= time){\\n                list.add(i);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087204,
                "title": "python-straightforward-o-n-solution-beats-80",
                "content": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        N = len(security)\\n        if time == 0:\\n            return [i for i in range(N)]\\n        \\n        \"\"\"\\n        example: [5,3,3,3,5,6,2]\\n        non_increasing_counts = [0, 1, 2, 3, 0, 0, 1]\\n        non_decreasing_counts = [0, 4, 3, 2, 1, 0, 0]\\n        \"\"\"\\n\\n        non_increasing_counts = [0] * N\\n        non_decreasing_counts = [0] * N\\n        # recording the days **before**, so we accumulate the count from the start\\n        for i in range(1, N):\\n            if security[i] <= security[i - 1]:\\n                non_increasing_counts[i] = non_increasing_counts[i - 1] + 1\\n\\n        # recording the days **after**, so we accumulate the count from the end\\n        for i in range(N - 2, -1, -1):\\n            if security[i] <= security[i + 1]:\\n                non_decreasing_counts[i] = non_decreasing_counts[i + 1] + 1\\n        \\n        res = []\\n        for i in range(N):\\n            if non_increasing_counts[i] >= time and non_decreasing_counts[i] >= time:\\n                res.append(i)\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        N = len(security)\\n        if time == 0:\\n            return [i for i in range(N)]\\n        \\n        \"\"\"\\n        example: [5,3,3,3,5,6,2]\\n        non_increasing_counts = [0, 1, 2, 3, 0, 0, 1]\\n        non_decreasing_counts = [0, 4, 3, 2, 1, 0, 0]\\n        \"\"\"\\n\\n        non_increasing_counts = [0] * N\\n        non_decreasing_counts = [0] * N\\n        # recording the days **before**, so we accumulate the count from the start\\n        for i in range(1, N):\\n            if security[i] <= security[i - 1]:\\n                non_increasing_counts[i] = non_increasing_counts[i - 1] + 1\\n\\n        # recording the days **after**, so we accumulate the count from the end\\n        for i in range(N - 2, -1, -1):\\n            if security[i] <= security[i + 1]:\\n                non_decreasing_counts[i] = non_decreasing_counts[i + 1] + 1\\n        \\n        res = []\\n        for i in range(N):\\n            if non_increasing_counts[i] >= time and non_decreasing_counts[i] >= time:\\n                res.append(i)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2638063,
                "title": "95-time-beats-80-space-beats-c-time-o-n-space-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& arr, int time) {\\n        int n = arr.size(),i;\\n        vector<int> in(n,1),de(n,1),ans;\\n        for(i = 1; i < n; i++){\\n            if(arr[i]<=arr[i-1]){\\n                in[i] += in[i-1];\\n            }\\n        }\\n        for(i = n-2; i >= 0; i--){\\n            if(arr[i]<=arr[i+1]){\\n                de[i] += de[i+1];\\n            }\\n        }\\n        for(i = 0; i < n; i++){\\n            if(in[i]>time && de[i]>time){\\n                ans.push_back(i);\\n            }\\n        }\\n        // for(auto &i: in)cout<<i<<\" \";\\n        // cout<<endl;\\n        // for(auto &i: de)cout<<i<<\" \";\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& arr, int time) {\\n        int n = arr.size(),i;\\n        vector<int> in(n,1),de(n,1),ans;\\n        for(i = 1; i < n; i++){\\n            if(arr[i]<=arr[i-1]){\\n                in[i] += in[i-1];\\n            }\\n        }\\n        for(i = n-2; i >= 0; i--){\\n            if(arr[i]<=arr[i+1]){\\n                de[i] += de[i+1];\\n            }\\n        }\\n        for(i = 0; i < n; i++){\\n            if(in[i]>time && de[i]>time){\\n                ans.push_back(i);\\n            }\\n        }\\n        // for(auto &i: in)cout<<i<<\" \";\\n        // cout<<endl;\\n        // for(auto &i: de)cout<<i<<\" \";\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2627392,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Precalculate***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& arr, int k) {\\n        \\n        int n = arr.size();\\n        \\n        // left[i] will store the length of increasing subarray including arr[i] on left side\\n        \\n        vector<int> left(n, 1);\\n        \\n        // fill left array\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            if(arr[i] <= arr[i - 1])\\n            {\\n                left[i] = left[i - 1] + 1;\\n            }\\n        }\\n        \\n        // right[i] will store the length of increasing subarray including arr[i] on right side\\n        \\n        vector<int> right(n, 1);\\n        \\n        // fill right array\\n        \\n        for(int i = n - 2; i >= 0; i--)\\n        {\\n            if(arr[i] <= arr[i + 1])\\n            {\\n                right[i] = right[i + 1] + 1;\\n            }\\n        }\\n        \\n        // push the possible index into res\\n        \\n        vector<int> res;\\n        \\n        for(int i = k; i <= n - k - 1; i++)\\n        {\\n            if(left[i] >= k + 1 && right[i] >= k + 1)\\n            {\\n                res.push_back(i);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& arr, int k) {\\n        \\n        int n = arr.size();\\n        \\n        // left[i] will store the length of increasing subarray including arr[i] on left side\\n        \\n        vector<int> left(n, 1);\\n        \\n        // fill left array\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            if(arr[i] <= arr[i - 1])\\n            {\\n                left[i] = left[i - 1] + 1;\\n            }\\n        }\\n        \\n        // right[i] will store the length of increasing subarray including arr[i] on right side\\n        \\n        vector<int> right(n, 1);\\n        \\n        // fill right array\\n        \\n        for(int i = n - 2; i >= 0; i--)\\n        {\\n            if(arr[i] <= arr[i + 1])\\n            {\\n                right[i] = right[i + 1] + 1;\\n            }\\n        }\\n        \\n        // push the possible index into res\\n        \\n        vector<int> res;\\n        \\n        for(int i = k; i <= n - k - 1; i++)\\n        {\\n            if(left[i] >= k + 1 && right[i] >= k + 1)\\n            {\\n                res.push_back(i);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2615886,
                "title": "python-prefix",
                "content": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        \\n        decreasing = [1] * len(security)\\n        \\n        count = 0\\n        for i in range(1, len(security)):\\n            if security[i] <= security[i - 1]:\\n                count += 1\\n            else:\\n                count = 0\\n            decreasing[i] = count\\n        \\n        increasing = [0] * len(security)\\n        increasing[-1] = 1\\n        count = 0\\n        for i in range(len(security) - 2 , -1, -1):\\n            if security[i] <= security[i+1]:\\n                count += 1\\n            else:\\n                count = 0\\n            increasing[i] = count\\n        res = []\\n        \\n        for i in range(time, len(security) - time):\\n            if increasing[i] >= time and decreasing[i] >= time:\\n                res.append(i)\\n        return res\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        \\n        decreasing = [1] * len(security)\\n        \\n        count = 0\\n        for i in range(1, len(security)):\\n            if security[i] <= security[i - 1]:\\n                count += 1\\n            else:\\n                count = 0\\n            decreasing[i] = count\\n        \\n        increasing = [0] * len(security)\\n        increasing[-1] = 1\\n        count = 0\\n        for i in range(len(security) - 2 , -1, -1):\\n            if security[i] <= security[i+1]:\\n                count += 1\\n            else:\\n                count = 0\\n            increasing[i] = count\\n        res = []\\n        \\n        for i in range(time, len(security) - time):\\n            if increasing[i] >= time and decreasing[i] >= time:\\n                res.append(i)\\n        return res\\n",
                "codeTag": "Java"
            },
            {
                "id": 2598528,
                "title": "python-o-n-compact-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        if not security or time < 0:\\n            return []\\n        \\n        n = len(security)\\n        left, right = [0] * n, [0] * n\\n        left[0], right[-1] = 0, 0\\n        \\n        # build 2 arrays where:\\n        # left contains the count of non-increasing elements for certain idx\\n        # right count of non-decreasing for certain idx\\n        for i, j in zip(range(1, n), reversed(range(0, n-1))):\\n            left[i] = left[i-1] + 1 if security[i] <= security[i - 1] else 0\\n            right[j] = right[j+1] + 1 if security[j] <= security[j + 1] else 0\\n               \\n        # filter out those days which match the requirement\\n        return [day for day in range(n) if left[day] >= time and right[day] >= time]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        if not security or time < 0:\\n            return []\\n        \\n        n = len(security)\\n        left, right = [0] * n, [0] * n\\n        left[0], right[-1] = 0, 0\\n        \\n        # build 2 arrays where:\\n        # left contains the count of non-increasing elements for certain idx\\n        # right count of non-decreasing for certain idx\\n        for i, j in zip(range(1, n), reversed(range(0, n-1))):\\n            left[i] = left[i-1] + 1 if security[i] <= security[i - 1] else 0\\n            right[j] = right[j+1] + 1 if security[j] <= security[j + 1] else 0\\n               \\n        # filter out those days which match the requirement\\n        return [day for day in range(n) if left[day] >= time and right[day] >= time]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2514965,
                "title": "c-prefix-suffix-easy-o-n-dynamic-programming-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        //jai shri ram\\n        int n=security.size();\\n        vector<int>pre(n,0),suff(n,0),ans;\\n        for(int i=0;i<n;i++){\\n            if(i!=0 && security[i]<=security[i-1]) pre[i]+=pre[i-1]+1;\\n            else pre[i]=1;\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            if(i!=n-1 && security[i]<=security[i+1]) suff[i]+=suff[i+1]+1;\\n            else suff[i]=1;\\n        }\\n        if(time==0) ans.push_back(0);\\n        for(int i=1;i<n-1;i++){\\n            if(pre[i]>time && suff[i]>time){\\n                ans.push_back(i);\\n            }\\n        }\\n        if(n>1 && time==0) ans.push_back(n-1);\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        //jai shri ram\\n        int n=security.size();\\n        vector<int>pre(n,0),suff(n,0),ans;\\n        for(int i=0;i<n;i++){\\n            if(i!=0 && security[i]<=security[i-1]) pre[i]+=pre[i-1]+1;\\n            else pre[i]=1;\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            if(i!=n-1 && security[i]<=security[i+1]) suff[i]+=suff[i+1]+1;\\n            else suff[i]=1;\\n        }\\n        if(time==0) ans.push_back(0);\\n        for(int i=1;i<n-1;i++){\\n            if(pre[i]>time && suff[i]>time){\\n                ans.push_back(i);\\n            }\\n        }\\n        if(n>1 && time==0) ans.push_back(n-1);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2421202,
                "title": "two-pass-solution-with-prefix-and-suffix-array",
                "content": "First pass store the prefix and suffix count of continuous increasing/decresing elements. \\nSecond pass check for the time condition and fill the indexes to result array\\n```\\n    vector<int> goodDaysToRobBank(vector<int>& S, int T) {\\n        int n = S.size();\\n        vector<int> res, L(n, 0), R(n, 0);\\n        for(int i=1 ; i < n-1; i++) {\\n            int j = n - (i + 1);\\n            if (S[i-1] >= S[i])  L[i] = L[i-1]+1;\\n            if (S[j] <= S[j+1]) R[j] = R[j+1]+1;\\n        }\\n        for(int i = 0; i < n; i++) {\\n            if(L[i] >= T && R[i] >= T) {\\n                res.push_back(i);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    vector<int> goodDaysToRobBank(vector<int>& S, int T) {\\n        int n = S.size();\\n        vector<int> res, L(n, 0), R(n, 0);\\n        for(int i=1 ; i < n-1; i++) {\\n            int j = n - (i + 1);\\n            if (S[i-1] >= S[i])  L[i] = L[i-1]+1;\\n            if (S[j] <= S[j+1]) R[j] = R[j+1]+1;\\n        }\\n        for(int i = 0; i < n; i++) {\\n            if(L[i] >= T && R[i] >= T) {\\n                res.push_back(i);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2346021,
                "title": "c-prefix-suffix-sum-easy-to-understand-fast",
                "content": "```\\n vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        \\n        int n= security.size();\\n        vector<int> st(n),end(n),ans;\\n        st[0]=0;\\n        \\n        for(int i=1;i<n;i++){\\n            if(security[i-1]>=security[i]){\\n                st[i]=st[i-1]+1;\\n            }\\n            else{\\n                st[i]=0;\\n            }\\n        }\\n        \\n        end[n-1]=0;\\n        \\n        for(int i=n-2;i>=0;i--){\\n            if(security[i]<=security[i+1]){\\n                end[i]=end[i+1]+1;\\n            }\\n            else{\\n                end[i]=0;\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(st[i]>= time && end[i]>= time){\\n                ans.push_back(i);\\n            }\\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Suffix Array"
                ],
                "code": "```\\n vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        \\n        int n= security.size();\\n        vector<int> st(n),end(n),ans;\\n        st[0]=0;\\n        \\n        for(int i=1;i<n;i++){\\n            if(security[i-1]>=security[i]){\\n                st[i]=st[i-1]+1;\\n            }\\n            else{\\n                st[i]=0;\\n            }\\n        }\\n        \\n        end[n-1]=0;\\n        \\n        for(int i=n-2;i>=0;i--){\\n            if(security[i]<=security[i+1]){\\n                end[i]=end[i+1]+1;\\n            }\\n            else{\\n                end[i]=0;\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(st[i]>= time && end[i]>= time){\\n                ans.push_back(i);\\n            }\\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2340246,
                "title": "c-prefix-sum-very-easy-code-80-faster",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n=security.size();\\n        vector<int> left(n,0),right(n,0);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(security[i-1]>=security[i])\\n                left[i]=left[i-1]+1;// stores number of good days before the current day\\n        }\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(security[i+1]>=security[i])\\n                right[i]=right[i+1]+1;// stores number of good days before the current day\\n        }\\n        vector<int> res;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(left[i]>=time && right[i]>=time)\\n                res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n=security.size();\\n        vector<int> left(n,0),right(n,0);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(security[i-1]>=security[i])\\n                left[i]=left[i-1]+1;// stores number of good days before the current day\\n        }\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(security[i+1]>=security[i])\\n                right[i]=right[i+1]+1;// stores number of good days before the current day\\n        }\\n        vector<int> res;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(left[i]>=time && right[i]>=time)\\n                res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2305339,
                "title": "c-easy-to-understand-prefix-suffix",
                "content": "```\\n    vector<int> goodDaysToRobBank(vector<int>& security, int t) {\\n        int n=security.size();\\n        vector<int>prefix(n),suffix(n);\\n        prefix[0]=0;\\n        suffix[n-1]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(security[i]<=security[i-1])\\n            {\\n                prefix[i]=prefix[i-1]+1; \\n            }\\n            else{\\n                prefix[i]=0;\\n            }\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(security[i]<=security[i+1]){\\n                suffix[i]=suffix[i+1]+1;\\n            }\\n            else{\\n                suffix[i]=0;\\n            }\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            if(suffix[i]>=t && prefix[i]>=t){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\n    vector<int> goodDaysToRobBank(vector<int>& security, int t) {\\n        int n=security.size();\\n        vector<int>prefix(n),suffix(n);\\n        prefix[0]=0;\\n        suffix[n-1]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(security[i]<=security[i-1])\\n            {\\n                prefix[i]=prefix[i-1]+1; \\n            }\\n            else{\\n                prefix[i]=0;\\n            }\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(security[i]<=security[i+1]){\\n                suffix[i]=suffix[i+1]+1;\\n            }\\n            else{\\n                suffix[i]=0;\\n            }\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            if(suffix[i]>=t && prefix[i]>=t){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2264664,
                "title": "c-array-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n = security.size();\\n        int cnt = 0;\\n        \\n        vector<int> left(n, 0), right(n, 0);\\n        \\n        for(int i = 1; i < n; i++){\\n            if(security[i] <= security[i - 1])\\n                cnt++;\\n            else\\n                cnt = 0;\\n            \\n            left[i] = cnt;\\n        }\\n        \\n        cnt = 0;\\n        \\n        for(int i = n - 2; i >= 0; i--){\\n            if(security[i] <= security[i+1])\\n                cnt++;\\n            else\\n                cnt = 0;\\n            \\n            right[i] = cnt;\\n        }\\n        \\n        vector<int> ans;\\n        for(int i = 0;i < n; i++){\\n            if(left[i] >= time && right[i] >= time){\\n                ans.push_back(i);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n = security.size();\\n        int cnt = 0;\\n        \\n        vector<int> left(n, 0), right(n, 0);\\n        \\n        for(int i = 1; i < n; i++){\\n            if(security[i] <= security[i - 1])\\n                cnt++;\\n            else\\n                cnt = 0;\\n            \\n            left[i] = cnt;\\n        }\\n        \\n        cnt = 0;\\n        \\n        for(int i = n - 2; i >= 0; i--){\\n            if(security[i] <= security[i+1])\\n                cnt++;\\n            else\\n                cnt = 0;\\n            \\n            right[i] = cnt;\\n        }\\n        \\n        vector<int> ans;\\n        for(int i = 0;i < n; i++){\\n            if(left[i] >= time && right[i] >= time){\\n                ans.push_back(i);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2201798,
                "title": "java-easy-explaination-prefix-suffix-appoach-solved",
                "content": "class Solution {\\n    public List<Integer> goodDaysToRobBank(int[] s, int time) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        int n = s.length;\\n        \\n        int[] a = new int[n];\\n        int[] b = new int[n];\\n        for(int i=1;i<n;i++){\\n            if(s[i]<=s[i-1]){\\n                a[i] = 1 + a[i-1] ;\\n            }\\n        }\\n        \\n        for(int i=n-2;i>=0;i--){\\n            if(s[i]<=s[i+1]){\\n                b[i] = 1 + b[i+1];\\n            }\\n        }\\n        \\n        for(int i=time;i<n-time;i++){\\n            if(a[i]>=time && b[i]>=time){\\n                res.add(i);\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n    public List<Integer> goodDaysToRobBank(int[] s, int time) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        int n = s.length;\\n        \\n        int[] a = new int[n];\\n        int[] b = new int[n];\\n        for(int i=1;i<n;i++){\\n            if(s[i]<=s[i-1]){\\n                a[i] = 1 + a[i-1] ;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2194732,
                "title": "c-simple-prefix-and-suffix",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        vector<int>res;\\n        int n=security.size();\\n        vector<int>left(n,0),right(n,0);\\n        for(int i=1;i<n;i++){\\n            if(security[i]<=security[i-1])left[i]=1+left[i-1];\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            if(security[i+1]>=security[i])right[i]=1+right[i+1];\\n        }\\n        for(int i=0;i<n;i++){\\n            if(left[i]>=time && right[i]>=time)res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        vector<int>res;\\n        int n=security.size();\\n        vector<int>left(n,0),right(n,0);\\n        for(int i=1;i<n;i++){\\n            if(security[i]<=security[i-1])left[i]=1+left[i-1];\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            if(security[i+1]>=security[i])right[i]=1+right[i+1];\\n        }\\n        for(int i=0;i<n;i++){\\n            if(left[i]>=time && right[i]>=time)res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2193544,
                "title": "java-easy-solution-prefix-array",
                "content": "\\tclass Solution {\\n\\t\\t/*\\n\\t\\tStore A Prefix Array With The Following Condition\\n\\t\\tsecurity[i - time] >= security[i - time + 1] >= ...\\n\\t\\t>= security[i]\\n\\t\\t<= ... <= security[i + time - 1] <= security[i + time]\\n\\t\\t */\\n\\t\\tpublic static List<Integer> goodDaysToRobBank(int[] security, int time) {\\n\\t\\t\\tint n = security.length;\\n\\t\\t\\tList<Integer> ans = new ArrayList<>();\\n\\t\\t\\tint[] prefLeft = new int[n];\\n\\t\\t\\tint[] prefRight = new int[n];\\n\\n\\t\\t\\t// Count the length of non-increasing elements to the left\\n\\t\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\t\\tif (security[i] <= security[i - 1])\\n\\t\\t\\t\\t\\tprefLeft[i] = prefLeft[i - 1] + 1;\\n\\t\\t\\t}\\n\\t\\t\\t// Count the length of non-decreasing elements to the right\\n\\t\\t\\tfor (int i = n - 2; i >= 0; --i) {\\n\\t\\t\\t\\tif (security[i] <= security[i + 1])\\n\\t\\t\\t\\t\\tprefRight[i] = prefRight[i + 1] + 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Insert all the indexes that satisfy the condition\\n\\t\\t\\tfor (int i = time; i < n - time; i++) {\\n\\t\\t\\t\\tif (prefLeft[i] >= time && prefRight[i] >= time)\\n\\t\\t\\t\\t\\tans.add(i);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\t/*\\n\\t\\tStore A Prefix Array With The Following Condition\\n\\t\\tsecurity[i - time] >= security[i - time + 1] >= ...\\n\\t\\t>= security[i]\\n\\t\\t<= ... <= security[i + time - 1] <= security[i + time]\\n\\t\\t */\\n\\t\\tpublic static List<Integer> goodDaysToRobBank(int[] security, int time) {\\n\\t\\t\\tint n = security.length;\\n\\t\\t\\tList<Integer> ans = new ArrayList<>();\\n\\t\\t\\tint[] prefLeft = new int[n];\\n\\t\\t\\tint[] prefRight = new int[n];\\n\\n\\t\\t\\t// Count the length of non-increasing elements to the left\\n\\t\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\t\\tif (security[i] <= security[i - 1])\\n\\t\\t\\t\\t\\tprefLeft[i] = prefLeft[i - 1] + 1;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2161847,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, A, t):\\n        n = len(A)\\n        def incGaurd(A):\\n            arr = [0] * n\\n            for i in range(1,n):\\n                if A[i-1] >= A[i]:\\n                    arr[i] = arr[i-1] + 1\\n            return arr\\n        _inc,_dec = incGaurd(A),incGaurd(A[::-1])[::-1]\\n        ans = []\\n        for i in range(n):\\n            if _inc[i] >= t and _dec[i] >= t:\\n                ans.append(i)\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, A, t):\\n        n = len(A)\\n        def incGaurd(A):\\n            arr = [0] * n\\n            for i in range(1,n):\\n                if A[i-1] >= A[i]:\\n                    arr[i] = arr[i-1] + 1\\n            return arr\\n        _inc,_dec = incGaurd(A),incGaurd(A[::-1])[::-1]\\n        ans = []\\n        for i in range(n):\\n            if _inc[i] >= t and _dec[i] >= t:\\n                ans.append(i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2057968,
                "title": "python-linear-with-keeping-track-of-sequence-length-time-o-n-space-o-1",
                "content": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n\\n        # cover edge cases to simplify algorithm\\n        if time == 0:\\n            return [i for i in range(len(security))]\\n        \\n        if 2*time >= len(security):\\n            return []\\n        \\n        # go days one by one while keeping track of the days sequence length before and after current days\\n        before = 0\\n        after = 0\\n        good_days = []\\n        for idx in range(1, len(security) - time):\\n            # count good days sequence lenght before the current day\\n            before = before + 1 if security[idx-1] >= security[idx] else 0\\n            # count good days sequence lenght after the current day\\n            after = after + 1 if security[idx+time-1] <= security[idx+time] else 0\\n                \\n            if idx >= time and before >= time and after >= time:\\n                good_days.append(idx)\\n            \\n        return good_days\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n\\n        # cover edge cases to simplify algorithm\\n        if time == 0:\\n            return [i for i in range(len(security))]\\n        \\n        if 2*time >= len(security):\\n            return []\\n        \\n        # go days one by one while keeping track of the days sequence length before and after current days\\n        before = 0\\n        after = 0\\n        good_days = []\\n        for idx in range(1, len(security) - time):\\n            # count good days sequence lenght before the current day\\n            before = before + 1 if security[idx-1] >= security[idx] else 0\\n            # count good days sequence lenght after the current day\\n            after = after + 1 if security[idx+time-1] <= security[idx+time] else 0\\n                \\n            if idx >= time and before >= time and after >= time:\\n                good_days.append(idx)\\n            \\n        return good_days\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1971538,
                "title": "c-simple-very-easy-solution",
                "content": "\\tpublic:\\n\\t\\tvector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        \\n        int n = security.size();\\n        vector<int>lft_non_inc(n, 0);\\n        vector<int>rht_non_dec(n, 0);\\n        vector<int>ans;\\n        \\n        for(int i=1;i<n;i++)\\n            if(security[i] <= security[i-1])\\n                lft_non_inc[i] = 1 + lft_non_inc[i-1];\\n        \\n        for(int i=(n-2);i>=0;i--)\\n            if(security[i] <= security[i+1])\\n                rht_non_dec[i] = 1 + rht_non_dec[i+1];\\n        \\n        for(int i=time;i<n-time;i++)\\n            if(rht_non_dec[i] >= time && lft_non_inc[i] >= time)\\n                ans.push_back(i);\\n        \\n        return ans;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tpublic:\\n\\t\\tvector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        \\n        int n = security.size();\\n        vector<int>lft_non_inc(n, 0);\\n        vector<int>rht_non_dec(n, 0);\\n        vector<int>ans;\\n        \\n        for(int i=1;i<n;i++)\\n            if(security[i] <= security[i-1])\\n                lft_non_inc[i] = 1 + lft_non_inc[i-1];\\n        \\n        for(int i=(n-2);i>=0;i--)\\n            if(security[i] <= security[i+1])\\n                rht_non_dec[i] = 1 + rht_non_dec[i+1];\\n        \\n        for(int i=time;i<n-time;i++)\\n            if(rht_non_dec[i] >= time && lft_non_inc[i] >= time)\\n                ans.push_back(i);\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1967736,
                "title": "python-o-n-solution-beats-90-pre-computation",
                "content": "\\tclass Solution:\\n\\t\\tdef goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n\\t\\t\\tif time == 0:\\n\\t\\t\\t\\treturn [i for i in range(len(security))]\\n\\t\\t\\tn = len(security)\\n\\t\\t\\tleft = [0 for i in range(n)]\\n\\t\\t\\tright = [0 for i in range(n)]\\n\\t\\t\\tfor i in range(n-2, -1, -1):\\n\\t\\t\\t\\tif security[i] >= security[i+1]:\\n\\t\\t\\t\\t\\tleft[i] = 1 + left[i+1]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tleft[i] = 0\\n\\t\\t\\tfor i in range(1, n):\\n\\t\\t\\t\\tif security[i] >= security[i-1]:\\n\\t\\t\\t\\t\\tright[i] = 1 + right[i-1]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tright[i] = 0\\n\\t\\t\\tans = []\\n\\t\\t\\tfor i in range(time, n-time):\\n\\t\\t\\t\\tif left[i-time] >= time and right[i+time] >= time:\\n\\t\\t\\t\\t\\tans.append(i)\\n\\t\\t\\treturn ans",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n\\t\\t\\tif time == 0:\\n\\t\\t\\t\\treturn [i for i in range(len(security))]\\n\\t\\t\\tn = len(security)\\n\\t\\t\\tleft = [0 for i in range(n)]\\n\\t\\t\\tright = [0 for i in range(n)]\\n\\t\\t\\tfor i in range(n-2, -1, -1):\\n\\t\\t\\t\\tif security[i] >= security[i+1]:\\n\\t\\t\\t\\t\\tleft[i] = 1 + left[i+1]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tleft[i] = 0\\n\\t\\t\\tfor i in range(1, n):\\n\\t\\t\\t\\tif security[i] >= security[i-1]:\\n\\t\\t\\t\\t\\tright[i] = 1 + right[i-1]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tright[i] = 0\\n\\t\\t\\tans = []\\n\\t\\t\\tfor i in range(time, n-time):\\n\\t\\t\\t\\tif left[i-time] >= time and right[i+time] >= time:\\n\\t\\t\\t\\t\\tans.append(i)\\n\\t\\t\\treturn ans",
                "codeTag": "Java"
            },
            {
                "id": 1765635,
                "title": "c-o-n-using-pre-computation-easy-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        // [5,3,3,3,5,6,2]\\n        // [0,1,2,3,0,0,1] --> count of contiguous no greater than current no to left\\n        // [0,4,3,2,1,0,0] --> count of contiguous no greater than current no to right\\n        int n = security.size();\\n        vector<int> left(n);\\n        vector<int> right(n);\\n        left[0] = 0, right[n - 1] = 0;\\n        \\n        for(int i = 1; i < n; i++) {\\n            if(security[i] <= security[i - 1]) {\\n                left[i] = left[i - 1] + 1;\\n            } else {\\n                left[i] = 0;\\n            }\\n        }\\n        \\n        for(int i = n - 2; i >= 0; i--) {\\n            if(security[i] <= security[i + 1]) {\\n                right[i] = right[i + 1] + 1;\\n            } else {\\n                right[i] = 0;\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        for(int i = 0; i < n; i++) {\\n            if(left[i] >= time && right[i] >= time) {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        // [5,3,3,3,5,6,2]\\n        // [0,1,2,3,0,0,1] --> count of contiguous no greater than current no to left\\n        // [0,4,3,2,1,0,0] --> count of contiguous no greater than current no to right\\n        int n = security.size();\\n        vector<int> left(n);\\n        vector<int> right(n);\\n        left[0] = 0, right[n - 1] = 0;\\n        \\n        for(int i = 1; i < n; i++) {\\n            if(security[i] <= security[i - 1]) {\\n                left[i] = left[i - 1] + 1;\\n            } else {\\n                left[i] = 0;\\n            }\\n        }\\n        \\n        for(int i = n - 2; i >= 0; i--) {\\n            if(security[i] <= security[i + 1]) {\\n                right[i] = right[i + 1] + 1;\\n            } else {\\n                right[i] = 0;\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        for(int i = 0; i < n; i++) {\\n            if(left[i] >= time && right[i] >= time) {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734643,
                "title": "python3-short-solution",
                "content": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        decreasing = [0] * len(security)\\n        increasing = [0] * len(security)\\n        for i in range(len(security)):\\n            if i > 0 and security[i - 1] >= security[i]:\\n                decreasing[i] = decreasing[i - 1] + 1\\n        for i in reversed(range(len(security))):\\n            if i < len(security) - 1 and security[i] <= security[i + 1]:\\n                increasing[i] = increasing[i + 1] + 1\\n        return [i for i in range(len(security)) if increasing[i] >= time and decreasing[i] >= time]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        decreasing = [0] * len(security)\\n        increasing = [0] * len(security)\\n        for i in range(len(security)):\\n            if i > 0 and security[i - 1] >= security[i]:\\n                decreasing[i] = decreasing[i - 1] + 1\\n        for i in reversed(range(len(security))):\\n            if i < len(security) - 1 and security[i] <= security[i + 1]:\\n                increasing[i] = increasing[i + 1] + 1\\n        return [i for i in range(len(security)) if increasing[i] >= time and decreasing[i] >= time]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676417,
                "title": "c-prefix-sufix-sum-clear-code",
                "content": "**Short Explaination after the code**\\n```\\nvector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n  = security.size();\\n        vector<int> ans;\\n        if(time == 0){\\n            for(int i = 0 ;i < n ; i++) ans.push_back(i);\\n            return ans;\\n        }\\n        vector<int> l(n) , r(n) , prel(n+2) , prer(n+2);\\n        for(int i = 0 ;i < n-1; i++){\\n            l[i] = security[i] < security[i+1];\\n        }\\n        for(int i = n-1 ;i > 0; i--){\\n            r[i] = security[i] < security[i-1];\\n        }\\n        prel[1] = l[0] , prer[n] = r[n-1];\\n        for(int i = 2 ;i <= n ; i++){\\n            prel[i] = l[i-1]+prel[i-1];\\n        }\\n        for(int i = n-1 ; i >0 ; i--){\\n            prer[i] = prer[i+1] + r[i-1];\\n        }\\n       \\n        for(int i = 1 ;i <= n ; i++){\\n            if(i-time > 0 and i + time <= n){\\n                if(prel[i-1] - prel[i-time-1] == 0 and prer[i+time+1] - prer[i+1] == 0) ans.push_back(i-1);\\n            } \\n        }\\n        return ans;\\n    }```\\nNote : \\n//Faling case / Break Down Case (Left / Right side - Decreasing order break down)\\nif(security[i] < security[i+1]) l[i] = 1;\\nif(security[i-1] > security[i]) r[i] = 1;\\nPut 1 in left (l) and right(r) Array.\\nMake PreFix sum from left to right and right to left with the failing case;\\nthen check\\nif(prel[i-1] - prel[i-time-1] == 0 and prer[i+time+1] - prer[i+1] == 0) ans.push_back(i-1);\\n== 0 , means no faliling case in the range [i-time , i+time] excluding i;\\n",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nvector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n  = security.size();\\n        vector<int> ans;\\n        if(time == 0){\\n            for(int i = 0 ;i < n ; i++) ans.push_back(i);\\n            return ans;\\n        }\\n        vector<int> l(n) , r(n) , prel(n+2) , prer(n+2);\\n        for(int i = 0 ;i < n-1; i++){\\n            l[i] = security[i] < security[i+1];\\n        }\\n        for(int i = n-1 ;i > 0; i--){\\n            r[i] = security[i] < security[i-1];\\n        }\\n        prel[1] = l[0] , prer[n] = r[n-1];\\n        for(int i = 2 ;i <= n ; i++){\\n            prel[i] = l[i-1]+prel[i-1];\\n        }\\n        for(int i = n-1 ; i >0 ; i--){\\n            prer[i] = prer[i+1] + r[i-1];\\n        }\\n       \\n        for(int i = 1 ;i <= n ; i++){\\n            if(i-time > 0 and i + time <= n){\\n                if(prel[i-1] - prel[i-time-1] == 0 and prer[i+time+1] - prer[i+1] == 0) ans.push_back(i-1);\\n            } \\n        }\\n        return ans;\\n    }```",
                "codeTag": "Unknown"
            },
            {
                "id": 1673190,
                "title": "c-find-longest-valley-in-the-array-very-simple",
                "content": "This problem is similar to the question: https://leetcode.com/problems/longest-mountain-in-array/\\n\\nIn this problem, it is required to find the longest valley in the array and check if the downward slope on the either side of the valley is longer than the value given as \"time\".\\n\\nThe vector \"forward\" records the decreasing phenomenon(i.e., the leftside downward slope of the valley) and the vector \"backward\" records the increasing phenomenon(i.e., the rightside downslope of the valley).\\n\\n```\\nclass Solution {\\npublic:\\n    void forwardUtility(vector<int>& security, vector<int>& forward, int n){\\n        forward[0] = 0;\\n        int downcount = 0;\\n        for (int i = 1; i <= n; i++){\\n            if (security[i] <= security[i-1]){\\n                downcount++;\\n                forward[i] = downcount;\\n            }\\n            else{\\n                downcount = 0;\\n                forward[i] = downcount;\\n            }\\n        }\\n    }\\n    void backwardUtility(vector<int>& security, vector<int>& backward, int n){\\n        backward[n] = 0;\\n        int upcount = 0;\\n        for (int i = n-1; i >= 0; i--){\\n            if (security[i] <= security[i+1]){\\n                upcount++;\\n                backward[i] = upcount;\\n            }\\n            else{\\n                upcount = 0;\\n                backward[i] = upcount;\\n            }\\n        }\\n    }\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int l = security.size();\\n        vector<int> ans;\\n        if (time > l)\\n            return ans;\\n        vector<int> forward(l, -1);\\n        vector<int> backward(l, -1);\\n        forward[0] = 0;\\n        backward[l-1] = 0;\\n        forwardUtility(security, forward, l-1);\\n        backwardUtility(security, backward, l-1);\\n        int rlimit = l-1-time;\\n        for (int i = time; i <= rlimit; i++){\\n            if (forward[i] >= time && backward[i] >= time){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nIn the above approach the use of the vector backward can be avoided by doing in-place updating in the security vector as below:\\nThis will not reduce space complexity but the space utilized will be less compared to the above code.\\n\\n```\\nclass Solution {\\npublic:\\n    void forwardUtility(vector<int>& security, vector<int>& forward, int n){\\n        forward[0] = 0;\\n        int downcount = 0;\\n        for (int i = 1; i <= n; i++){\\n            if (security[i] <= security[i-1]){\\n                downcount++;\\n                forward[i] = downcount;\\n            }\\n            else{\\n                downcount = 0;\\n                forward[i] = downcount;\\n            }\\n        }\\n    }\\n    void backwardUtility(vector<int>& security, int n){\\n        int temp = security[n];\\n        security[n] = 0;\\n        for (int i = n-1; i >= 0; i--){\\n            if (security[i] <= temp){\\n                temp = security[i];\\n                security[i] = security[i+1] + 1;\\n            }\\n            else{\\n                temp = security[i];\\n                security[i] = 0;\\n            }\\n        }\\n    }\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int l = security.size();\\n        vector<int> ans;\\n        if (time > l)\\n            return ans;\\n        vector<int> forward(l, -1);\\n        forwardUtility(security, forward, l-1);\\n        backwardUtility(security, l-1);\\n        int rlimit = l-1-time;\\n        for (int i = time; i <= rlimit; i++){\\n            if (forward[i] >= time && security[i] >= time){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void forwardUtility(vector<int>& security, vector<int>& forward, int n){\\n        forward[0] = 0;\\n        int downcount = 0;\\n        for (int i = 1; i <= n; i++){\\n            if (security[i] <= security[i-1]){\\n                downcount++;\\n                forward[i] = downcount;\\n            }\\n            else{\\n                downcount = 0;\\n                forward[i] = downcount;\\n            }\\n        }\\n    }\\n    void backwardUtility(vector<int>& security, vector<int>& backward, int n){\\n        backward[n] = 0;\\n        int upcount = 0;\\n        for (int i = n-1; i >= 0; i--){\\n            if (security[i] <= security[i+1]){\\n                upcount++;\\n                backward[i] = upcount;\\n            }\\n            else{\\n                upcount = 0;\\n                backward[i] = upcount;\\n            }\\n        }\\n    }\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int l = security.size();\\n        vector<int> ans;\\n        if (time > l)\\n            return ans;\\n        vector<int> forward(l, -1);\\n        vector<int> backward(l, -1);\\n        forward[0] = 0;\\n        backward[l-1] = 0;\\n        forwardUtility(security, forward, l-1);\\n        backwardUtility(security, backward, l-1);\\n        int rlimit = l-1-time;\\n        for (int i = time; i <= rlimit; i++){\\n            if (forward[i] >= time && backward[i] >= time){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void forwardUtility(vector<int>& security, vector<int>& forward, int n){\\n        forward[0] = 0;\\n        int downcount = 0;\\n        for (int i = 1; i <= n; i++){\\n            if (security[i] <= security[i-1]){\\n                downcount++;\\n                forward[i] = downcount;\\n            }\\n            else{\\n                downcount = 0;\\n                forward[i] = downcount;\\n            }\\n        }\\n    }\\n    void backwardUtility(vector<int>& security, int n){\\n        int temp = security[n];\\n        security[n] = 0;\\n        for (int i = n-1; i >= 0; i--){\\n            if (security[i] <= temp){\\n                temp = security[i];\\n                security[i] = security[i+1] + 1;\\n            }\\n            else{\\n                temp = security[i];\\n                security[i] = 0;\\n            }\\n        }\\n    }\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int l = security.size();\\n        vector<int> ans;\\n        if (time > l)\\n            return ans;\\n        vector<int> forward(l, -1);\\n        forwardUtility(security, forward, l-1);\\n        backwardUtility(security, l-1);\\n        int rlimit = l-1-time;\\n        for (int i = time; i <= rlimit; i++){\\n            if (forward[i] >= time && security[i] >= time){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1655311,
                "title": "python-o-n-prefix-suffix-type",
                "content": "Pre-Calculate for left and for right and then take intersection ,simple!!\\n```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        n=len(security)\\n        if time==0: return [i for i in range(n)]\\n        ans=set()\\n        valid_l,valid_r=set(),set()\\n        left,right=0,0\\n        for i in range(1,n):\\n            if security[i-1]>=security[i]: \\n                left+=1\\n            else:\\n                left=0\\n            if left>=time: \\n                valid_l.add(i)\\n        for i in range(n-2,-1,-1):\\n            if security[i]<=security[i+1]: \\n                right+=1\\n            else:\\n                right=0\\n            if right>=time: \\n                valid_r.add(i)\\n        ans=valid_l.intersection(valid_r)\\n        return list(ans)\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        n=len(security)\\n        if time==0: return [i for i in range(n)]\\n        ans=set()\\n        valid_l,valid_r=set(),set()\\n        left,right=0,0\\n        for i in range(1,n):\\n            if security[i-1]>=security[i]: \\n                left+=1\\n            else:\\n                left=0\\n            if left>=time: \\n                valid_l.add(i)\\n        for i in range(n-2,-1,-1):\\n            if security[i]<=security[i+1]: \\n                right+=1\\n            else:\\n                right=0\\n            if right>=time: \\n                valid_r.add(i)\\n        ans=valid_l.intersection(valid_r)\\n        return list(ans)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1632593,
                "title": "c-using-prefix-suffix-array",
                "content": "**Time: *O(n)***\\n**Space: *O(n)***\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n = security.size();\\n        int prefix[n], suffix[n];\\n        prefix[0]=1;\\n        suffix[n-1]=1;\\n        \\n        for(int i=1; i<n; ++i){\\n            if(security[i-1]>=security[i]) prefix[i] = 1+prefix[i-1];\\n            else prefix[i] = 1;\\n        }\\n        \\n        for(int j=n-2; j>=0; --j){\\n            if(security[j+1]>=security[j]) suffix[j] = 1+suffix[j+1];\\n            else suffix[j] = 1;\\n        }\\n        \\n        vector<int> ans;\\n        for(int k=0; k<n; ++k){\\n            if(prefix[k] > time && suffix[k] > time) ans.push_back(k);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n = security.size();\\n        int prefix[n], suffix[n];\\n        prefix[0]=1;\\n        suffix[n-1]=1;\\n        \\n        for(int i=1; i<n; ++i){\\n            if(security[i-1]>=security[i]) prefix[i] = 1+prefix[i-1];\\n            else prefix[i] = 1;\\n        }\\n        \\n        for(int j=n-2; j>=0; --j){\\n            if(security[j+1]>=security[j]) suffix[j] = 1+suffix[j+1];\\n            else suffix[j] = 1;\\n        }\\n        \\n        vector<int> ans;\\n        for(int k=0; k<n; ++k){\\n            if(prefix[k] > time && suffix[k] > time) ans.push_back(k);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1627871,
                "title": "java-prefix-sum-linear-extra-array-explained",
                "content": "for each day we need to know how many day to it\\'s left and to it\\'s right have security >=. This can be done if we do two sweeps on array and check if every next (and prior) day is less secure => it security value is less than a previous value.  Otherwise the chain is broken we can reset our counting. So we actually only care about immidiate neighbour and not all previous days.\\n\\nWe this information finding a good day is a matter of checking if for this day number of more secure days to the left and to the right are both >= than a time. This again can be done in one scan.\\n\\nWe can optimize initial two scans and two arrays into one scan and one 2d array.\\n\\nO(n) time - scan security array once to collect number of more secure days left-to-right and right-to-left, another scan to find good days\\nO(n) space - need [N][2] array to store number of more secure neighbouring days\\n\\n```\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        List<Integer> res = new ArrayList();\\n        int N = security.length;\\n        int[][] counts = new int[N][2];\\n        for (int i = 1; i < N; i++) {\\n            //fill right to left part\\n            if (security[i - 1] >= security[i]) {\\n                counts[i][0] = counts[i - 1][0] + 1; \\n            } \\n            //fill left to right part\\n            int ltorIdx = N - i - 1;\\n            if (security[ltorIdx] <= security[ltorIdx + 1]) {\\n                counts[ltorIdx][1] = counts[ltorIdx + 1][1] + 1; \\n            } \\n        }\\n        //i represents the potential day for robbery\\n        for (int i = time; i < N - time; i++) {\\n            if (counts[i][0] >= time && counts[i][1] >= time) {\\n                res.add(i);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        List<Integer> res = new ArrayList();\\n        int N = security.length;\\n        int[][] counts = new int[N][2];\\n        for (int i = 1; i < N; i++) {\\n            //fill right to left part\\n            if (security[i - 1] >= security[i]) {\\n                counts[i][0] = counts[i - 1][0] + 1; \\n            } \\n            //fill left to right part\\n            int ltorIdx = N - i - 1;\\n            if (security[ltorIdx] <= security[ltorIdx + 1]) {\\n                counts[ltorIdx][1] = counts[ltorIdx + 1][1] + 1; \\n            } \\n        }\\n        //i represents the potential day for robbery\\n        for (int i = time; i < N - time; i++) {\\n            if (counts[i][0] >= time && counts[i][1] >= time) {\\n                res.add(i);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1625921,
                "title": "sliding-windows-o-n-time-o-1-space",
                "content": "This kind of problem is usually solved by sliding window or prefix sum/count. Sliding window usually wins on space usage.\\nIn this case, we use 2 sliding windows: non-increasing `[deci..decj]` and non-decreasing `[inci..incj]`.\\nBoth have fixed size `time`, and it always has `decj = incj - time`. We just need to shrink the left.\\nCodes are straight forward:\\n```\\n    public IList<int> GoodDaysToRobBank(int[] security, int time) {\\n        var res = new List<int>();\\n        // sliding window [deci..decj] and [inci..incj], decj == incj - time\\n        int deci = 0, decj = -time, inci = 0, incj = 0;\\n        for (; incj < security.Length; decj++, incj++) {\\n            if (decj > 0 && security[decj-1] < security[decj]) // against dec\\n                deci = decj;\\n            if (deci + time < decj)  // window too large\\n                deci++;\\n            \\n            if (incj > 0 && security[incj-1] > security[incj]) // against inc\\n                inci = incj;\\n            if (inci + time < incj)  // window too large\\n                inci++;\\n            \\n            if (deci + time == decj && decj == inci)\\n                res.Add(decj);\\n        }\\n        \\n        return res;\\n    }\\n```\\n\\nPlease upvote if it helps.\\n\\n",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\n    public IList<int> GoodDaysToRobBank(int[] security, int time) {\\n        var res = new List<int>();\\n        // sliding window [deci..decj] and [inci..incj], decj == incj - time\\n        int deci = 0, decj = -time, inci = 0, incj = 0;\\n        for (; incj < security.Length; decj++, incj++) {\\n            if (decj > 0 && security[decj-1] < security[decj]) // against dec\\n                deci = decj;\\n            if (deci + time < decj)  // window too large\\n                deci++;\\n            \\n            if (incj > 0 && security[incj-1] > security[incj]) // against inc\\n                inci = incj;\\n            if (inci + time < incj)  // window too large\\n                inci++;\\n            \\n            if (deci + time == decj && decj == inci)\\n                res.Add(decj);\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1624923,
                "title": "javascript-very-easy-to-understand-solution",
                "content": "Runtime: 172 ms, faster than 100.00% of JavaScript online submissions for Find Good Days to Rob the Bank.\\nMemory Usage: 64.1 MB, less than 100.00% of JavaScript online submissions for Find Good Days to Rob the Bank.\\n```\\nvar goodDaysToRobBank = function(security, time) {\\n    let res = [];\\n    if(!time){\\n       let i = 0;\\n        while(i<security.length) res.push(i), i++;\\n        return res;\\n    }\\n    let increasing = 0;\\n    let decreasing = 0;\\n    let set = new Set();\\n    for(let i = 1; i < security.length; i++){\\n        if(security[i]>security[i-1]) decreasing = 0;\\n        else decreasing++;\\n        if(security[i]<security[i-1]) increasing = 0;\\n        else increasing++;\\n        if(decreasing>=time) set.add(i);\\n        if(increasing>=time&&set.has(i-time)) res.push(i-time);\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar goodDaysToRobBank = function(security, time) {\\n    let res = [];\\n    if(!time){\\n       let i = 0;\\n        while(i<security.length) res.push(i), i++;\\n        return res;\\n    }\\n    let increasing = 0;\\n    let decreasing = 0;\\n    let set = new Set();\\n    for(let i = 1; i < security.length; i++){\\n        if(security[i]>security[i-1]) decreasing = 0;\\n        else decreasing++;\\n        if(security[i]<security[i-1]) increasing = 0;\\n        else increasing++;\\n        if(decreasing>=time) set.add(i);\\n        if(increasing>=time&&set.has(i-time)) res.push(i-time);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1624190,
                "title": "simple-c-solution-optimal",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n=security.size();\\n        vector<int>prefix(n);\\n        \\n        prefix[0]=1;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(security[i]<=security[i-1])\\n                prefix[i]=prefix[i-1]+1;\\n            else\\n                prefix[i]=1;\\n        }\\n        vector<int>suffix(n);\\n         suffix[n-1]=1;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(security[i]<=security[i+1])\\n                suffix[i]=suffix[i+1]+1;\\n            else\\n                suffix[i]=1;\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(prefix[i]>=time+1 && suffix[i]>=time+1)\\n                ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n=security.size();\\n        vector<int>prefix(n);\\n        \\n        prefix[0]=1;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            if(security[i]<=security[i-1])\\n                prefix[i]=prefix[i-1]+1;\\n            else\\n                prefix[i]=1;\\n        }\\n        vector<int>suffix(n);\\n         suffix[n-1]=1;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(security[i]<=security[i+1])\\n                suffix[i]=suffix[i+1]+1;\\n            else\\n                suffix[i]=1;\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(prefix[i]>=time+1 && suffix[i]>=time+1)\\n                ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623629,
                "title": "c-easy-to-understand",
                "content": "class Solution {\\npublic:\\n\\n    vector<int> goodDaysToRobBank(vector<int>& vec, int time) {\\n\\t\\tint n=vec.size();\\n        vector<int>ans;\\n        if(n<(2*time+1))return ans;\\n        \\n        vector<int>dec(n,1);\\n        vector<int>inc(n,1);\\n\\t\\t\\n        for(int i=1;i<n;i++)\\n            if(vec[i-1]>=vec[i])\\n\\t\\t\\t\\tdec[i]=dec[i-1]+1;\\n        \\n        for(int i=n-2;i>=0;i--)\\n            if(vec[i]<=vec[i+1])\\n\\t\\t\\t\\tinc[i]=inc[i+1]+1;\\n        \\n        \\n        for(int i=time;i<n-time;i++)\\n            if(dec[i]>=time+1 and inc[i]>=time+1)\\n\\t\\t\\t\\tans.push_back(i);\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> goodDaysToRobBank(vector<int>& vec, int time) {\\n\\t\\tint n=vec.size();\\n        vector<int>ans;\\n        if(n<(2*time+1))return ans;\\n        \\n        vector<int>dec(n,1);\\n        vector<int>inc(n,1);\\n\\t\\t\\n        for(int i=1;i<n;i++)\\n            if(vec[i-1]>=vec[i])\\n\\t\\t\\t\\tdec[i]=dec[i-1]+1;\\n        \\n        for(int i=n-2;i>=0;i--)\\n            if(vec[i]<=vec[i+1])\\n\\t\\t\\t\\tinc[i]=inc[i+1]+1;\\n        \\n        \\n        for(int i=time;i<n-time;i++)\\n            if(dec[i]>=time+1 and inc[i]>=time+1)\\n\\t\\t\\t\\tans.push_back(i);\\n        \\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1623617,
                "title": "c-prefix",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& nums, int time) {\\n      int n=nums.size();  \\n      \\n      vector<int>bDiff(n,0);\\n     vector<int>fDiff(n,0);\\n\\n      int count=0;\\n      for(int i=1;i<n;i++){\\n        if(nums[i]-nums[i-1]<=0){\\n          count++;\\n          bDiff[i]=count;\\n        }\\n        else{\\n          count=0;\\n          bDiff[i]=0;\\n        }\\n      }\\n      \\n       count=0;\\n      for(int i=n-2;i>=0;i--){\\n        if(nums[i+1]-nums[i]>=0){\\n          count++;\\n          fDiff[i]=count;\\n        }\\n        else{\\n          count=0;\\n          fDiff[i]=0;\\n        }\\n      }\\n      \\n      vector<int>ans;\\n      for(int i=time;i<n-time;i++){\\n        if(bDiff[i]>=time && fDiff[i]>=time)\\n          ans.push_back(i);\\n      }\\n      \\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& nums, int time) {\\n      int n=nums.size();  \\n      \\n      vector<int>bDiff(n,0);\\n     vector<int>fDiff(n,0);\\n\\n      int count=0;\\n      for(int i=1;i<n;i++){\\n        if(nums[i]-nums[i-1]<=0){\\n          count++;\\n          bDiff[i]=count;\\n        }\\n        else{\\n          count=0;\\n          bDiff[i]=0;\\n        }\\n      }\\n      \\n       count=0;\\n      for(int i=n-2;i>=0;i--){\\n        if(nums[i+1]-nums[i]>=0){\\n          count++;\\n          fDiff[i]=count;\\n        }\\n        else{\\n          count=0;\\n          fDiff[i]=0;\\n        }\\n      }\\n      \\n      vector<int>ans;\\n      for(int i=time;i<n-time;i++){\\n        if(bDiff[i]>=time && fDiff[i]>=time)\\n          ans.push_back(i);\\n      }\\n      \\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623511,
                "title": "javascript-js-simple",
                "content": "```\\nvar goodDaysToRobBank = function(security, time) {\\n    const res = [];\\n    const len = security.length;\\n    const left = new Array(len).fill(len);\\n    const right = new Array(len).fill(len);\\n    \\n    for (let i = 1; i < len; i++) {\\n        left[i] = security[i] <= security[i - 1] ? left[i - 1] + 1 : 0;\\n    }\\n    for (let i = len - 2; i >= 0; i--) {\\n        right[i] = security[i] <= security[i + 1] ? right[i + 1] + 1 : 0;\\n    }\\n    for (let i = time; i < len - time; i++) {\\n        if (left[i] >= time && right[i] >= time) res.push(i);\\n    }\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar goodDaysToRobBank = function(security, time) {\\n    const res = [];\\n    const len = security.length;\\n    const left = new Array(len).fill(len);\\n    const right = new Array(len).fill(len);\\n    \\n    for (let i = 1; i < len; i++) {\\n        left[i] = security[i] <= security[i - 1] ? left[i - 1] + 1 : 0;\\n    }\\n    for (let i = len - 2; i >= 0; i--) {\\n        right[i] = security[i] <= security[i + 1] ? right[i + 1] + 1 : 0;\\n    }\\n    for (let i = time; i < len - time; i++) {\\n        if (left[i] >= time && right[i] >= time) res.push(i);\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1623504,
                "title": "go-dp-solution",
                "content": "We can use two dp array to store how many sequential nums larger or less than current num\\ndp1 for decreasing\\ndp2 for increasing \\nFor example:\\n[5,3,3,3,5,6,2]\\ndp1[0,1,2,3,0,0,1]\\ndp2[0,5,4,3,2,1,0]\\n\\nIf you have any improvement suggestion, please add comments. Thanks \\n\\n```\\nfunc goodDaysToRobBank(security []int, time int) []int {\\n    n := len(security)\\n    var ans []int\\n    \\n    if n < 2*time+1{\\n        return ans\\n    }\\n    \\n    dp1 := make([]int,n)\\n    dp2 := make([]int,n)\\n    \\n    for i:=1;i<n-time;i++{\\n        if security[i-1] >= security[i]{\\n            dp1[i] = dp1[i-1] + 1\\n        }else{\\n            dp1[i] = 0\\n        }\\n    }\\n    \\n    for j:=n-2;j>=time;j--{\\n        if security[j+1] >= security[j]{\\n            dp2[j] = dp2[j+1] + 1 \\n        }else{\\n            dp2[j] = 0\\n        }\\n    }\\n    \\n    for i:=time;i<n-time;i++{\\n        if dp1[i]>= time && dp2[i] >= time{\\n            ans = append(ans,i)\\n        }   \\n    }\\n\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc goodDaysToRobBank(security []int, time int) []int {\\n    n := len(security)\\n    var ans []int\\n    \\n    if n < 2*time+1{\\n        return ans\\n    }\\n    \\n    dp1 := make([]int,n)\\n    dp2 := make([]int,n)\\n    \\n    for i:=1;i<n-time;i++{\\n        if security[i-1] >= security[i]{\\n            dp1[i] = dp1[i-1] + 1\\n        }else{\\n            dp1[i] = 0\\n        }\\n    }\\n    \\n    for j:=n-2;j>=time;j--{\\n        if security[j+1] >= security[j]{\\n            dp2[j] = dp2[j+1] + 1 \\n        }else{\\n            dp2[j] = 0\\n        }\\n    }\\n    \\n    for i:=time;i<n-time;i++{\\n        if dp1[i]>= time && dp2[i] >= time{\\n            ans = append(ans,i)\\n        }   \\n    }\\n\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1623353,
                "title": "prefix-sum-and-suffix-sum",
                "content": "We only have to see previous time by prefix array and past time by suffix array and if union of both pre and suff is greater than equal to time than it will satisfy the condition and include this in ans\\nUsing prefixx sum and suffix sum\\n![image](https://assets.leetcode.com/users/images/4975dbde-ecdd-4220-a133-2a0d652f7b66_1639238557.7127664.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& s, int time) {\\n     \\n        int n=s.size(),temp=time;\\n        vector<int>pre(n,0),suff(n,0),v;\\n        for(int i=1;i<n;i++)\\n          {\\n           if(s[i-1]>=s[i]) pre[i]=pre[i-1]+1;\\n           else\\n               pre[i]=0;\\n          }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(s[i]<=s[i+1]) \\n                suff[i]=suff[i+1]+1;\\n            else\\n                suff[i]=0;\\n        }\\n       \\n        for(int i=0;i<n;i++)\\n        {\\n            if(suff[i]>=time and pre[i]>=time)\\n                v.push_back(i);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& s, int time) {\\n     \\n        int n=s.size(),temp=time;\\n        vector<int>pre(n,0),suff(n,0),v;\\n        for(int i=1;i<n;i++)\\n          {\\n           if(s[i-1]>=s[i]) pre[i]=pre[i-1]+1;\\n           else\\n               pre[i]=0;\\n          }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(s[i]<=s[i+1]) \\n                suff[i]=suff[i+1]+1;\\n            else\\n                suff[i]=0;\\n        }\\n       \\n        for(int i=0;i<n;i++)\\n        {\\n            if(suff[i]>=time and pre[i]>=time)\\n                v.push_back(i);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623340,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8  The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master) precompute monotonically increasing/decreasing lengths from left-to-right and from right-to-left to reduce asymptotic bounds to validate each `i`<sup>th</sup> index is `ok`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun goodDaysToRobBank(A: IntArray, K: Int): List<Int> {\\n        var N = A.size\\n        var L = IntArray(N) { 0 }\\n        var R = IntArray(N) { 0 }\\n        for (i in 1 until N) {\\n            var j = N - 1 - i\\n            L[i] = if (A[i - 1] >= A[i]) 1 + L[i - 1] else 0\\n            R[j] = if (A[j] <= A[j + 1]) 1 + R[j + 1] else 0\\n        }\\n        fun ok(i: Int): Boolean {\\n            if (i - K < 0 || N <= i + K)\\n                return false\\n            var l = L[i] - L[i - K]\\n            var r = R[i] - R[i + K]\\n            return l == K && r == K\\n        }\\n        return IntArray(N){ it }.filter{ ok(it) }\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet goodDaysToRobBank = (A, K) => {\\n    let N = A.length;\\n    let L = Array(N).fill(0),\\n        R = Array(N).fill(0);\\n    for (let i = 1; i < N; ++i) {\\n        let j = N - 1 - i;\\n        L[i] = A[i - 1] >= A[i] ? 1 + L[i - 1] : 0;\\n        R[j] = A[j] <= A[j + 1] ? 1 + R[j + 1] : 0;\\n    }\\n    let ok = i => {\\n        if (i - K < 0 || N <= i + K)\\n            return false;\\n        let l = L[i] - L[i - K],\\n            r = R[i] - R[i + K];\\n        return l == K && r == K;\\n    };\\n    return [...Array(N).keys()].filter(i => ok(i));\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def goodDaysToRobBank(self, A: List[int], K: int) -> List[int]:\\n        N = len(A)\\n        L = [0] * N\\n        R = [0] * N\\n        for i in range(1, N):\\n            j = N - 1 - i\\n            L[i] = 1 + L[i - 1] if A[i - 1] >= A[i] else 0\\n            R[j] = 1 + R[j + 1] if A[j] <= A[j + 1] else 0\\n        def ok(i):\\n            if i - K < 0 or N <= i + K:\\n                return False\\n            l = L[i] - L[i - K]\\n            r = R[i] - R[i + K]\\n            return l == K == r\\n        return [i for i in range(N) if ok(i)]\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    VI goodDaysToRobBank(VI& A, int K, VI good = {}) {\\n        int N = A.size();\\n        VI L(N),\\n           R(N);\\n        for (auto i{ 1 }; i < N; ++i) {\\n            auto j = N - 1 - i;\\n            L[i] = A[i - 1] >= A[i] ? 1 + L[i - 1] : 0;\\n            R[j] = A[j] <= A[j + 1] ? 1 + R[j + 1] : 0;\\n        }\\n        auto ok = [&](auto i) {\\n            auto l = L[i] - L[i - K],\\n                 r = R[i] - R[i + K];\\n            return K == l && K == r;\\n        };\\n        for (auto i{ K }; i + K < N; ++i)\\n            if (ok(i))\\n                good.push_back(i);\\n        return good;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun goodDaysToRobBank(A: IntArray, K: Int): List<Int> {\\n        var N = A.size\\n        var L = IntArray(N) { 0 }\\n        var R = IntArray(N) { 0 }\\n        for (i in 1 until N) {\\n            var j = N - 1 - i\\n            L[i] = if (A[i - 1] >= A[i]) 1 + L[i - 1] else 0\\n            R[j] = if (A[j] <= A[j + 1]) 1 + R[j + 1] else 0\\n        }\\n        fun ok(i: Int): Boolean {\\n            if (i - K < 0 || N <= i + K)\\n                return false\\n            var l = L[i] - L[i - K]\\n            var r = R[i] - R[i + K]\\n            return l == K && r == K\\n        }\\n        return IntArray(N){ it }.filter{ ok(it) }\\n    }\\n}\\n```\n```\\nlet goodDaysToRobBank = (A, K) => {\\n    let N = A.length;\\n    let L = Array(N).fill(0),\\n        R = Array(N).fill(0);\\n    for (let i = 1; i < N; ++i) {\\n        let j = N - 1 - i;\\n        L[i] = A[i - 1] >= A[i] ? 1 + L[i - 1] : 0;\\n        R[j] = A[j] <= A[j + 1] ? 1 + R[j + 1] : 0;\\n    }\\n    let ok = i => {\\n        if (i - K < 0 || N <= i + K)\\n            return false;\\n        let l = L[i] - L[i - K],\\n            r = R[i] - R[i + K];\\n        return l == K && r == K;\\n    };\\n    return [...Array(N).keys()].filter(i => ok(i));\\n};\\n```\n```\\nclass Solution:\\n    def goodDaysToRobBank(self, A: List[int], K: int) -> List[int]:\\n        N = len(A)\\n        L = [0] * N\\n        R = [0] * N\\n        for i in range(1, N):\\n            j = N - 1 - i\\n            L[i] = 1 + L[i - 1] if A[i - 1] >= A[i] else 0\\n            R[j] = 1 + R[j + 1] if A[j] <= A[j + 1] else 0\\n        def ok(i):\\n            if i - K < 0 or N <= i + K:\\n                return False\\n            l = L[i] - L[i - K]\\n            r = R[i] - R[i + K]\\n            return l == K == r\\n        return [i for i in range(N) if ok(i)]\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    VI goodDaysToRobBank(VI& A, int K, VI good = {}) {\\n        int N = A.size();\\n        VI L(N),\\n           R(N);\\n        for (auto i{ 1 }; i < N; ++i) {\\n            auto j = N - 1 - i;\\n            L[i] = A[i - 1] >= A[i] ? 1 + L[i - 1] : 0;\\n            R[j] = A[j] <= A[j + 1] ? 1 + R[j + 1] : 0;\\n        }\\n        auto ok = [&](auto i) {\\n            auto l = L[i] - L[i - K],\\n                 r = R[i] - R[i + K];\\n            return K == l && K == r;\\n        };\\n        for (auto i{ K }; i + K < N; ++i)\\n            if (ok(i))\\n                good.push_back(i);\\n        return good;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623324,
                "title": "c-solution-left-right",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& nums, int t)\\n    {\\n        int n=nums.size();\\n        vector<int>left(n,0),right(n,0);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i-1]>=nums[i])\\n            {\\n                left[i]=left[i-1]+1;\\n            }\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(nums[i]<=nums[i+1])\\n            {\\n                right[i]=right[i+1]+1;\\n            }\\n        }\\n        vector<int>v;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(left[i]>=t&&right[i]>=t)\\n            {\\n                v.push_back(i);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& nums, int t)\\n    {\\n        int n=nums.size();\\n        vector<int>left(n,0),right(n,0);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i-1]>=nums[i])\\n            {\\n                left[i]=left[i-1]+1;\\n            }\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(nums[i]<=nums[i+1])\\n            {\\n                right[i]=right[i+1]+1;\\n            }\\n        }\\n        vector<int>v;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(left[i]>=t&&right[i]>=t)\\n            {\\n                v.push_back(i);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4082233,
                "title": "c-straight-forward-solution",
                "content": "# Intuition\\nMy first thought was that this seems similar to the popular trapping rain water problem (#42)\\n\\n# Approach\\n- Fill an array, going from start (left) to end (right), record for each day how many previous days had same amount same or more guards ($$security[i-1]>=security[i] $$)\\n- Calculate the same by going from end (right) to start (left) - $$security[i]<=security[i+1]$$\\n- Pick the good days for robbery since you know for each day how many days before and after fit the criteria.\\n\\n# Complexity\\n- Time complexity:\\nO(N) - we do 2 passes from left to right\\n\\n- Space complexity:\\nO(N) - need to store the \\n\\n# Code\\n```\\n/* Could write this shorter and more elegant, but this is simple */\\npublic class Solution {\\n\\n    int[] LR;    \\n    int N;\\n\\n    public IList<int> GoodDaysToRobBank(int[] security, int time) {\\n        N = security.Length;\\n        LR = new int[N];\\n//Counter for days that fulfil the critera when moving L->R\\n        int counter = 0;\\n        for (int i = 0; i < N; i++)\\n        {\\n            if (i > 0)\\n            {\\n// This day has same or less guards than previos one\\n                if (security[i-1]>=security[i])\\n                    counter++;\\n                else\\n                    counter = 0; // Reset\\n            }\\n            LR[i] = counter;\\n        }\\n\\n        counter = 0;\\n\\n        var answer = new List<int>(N);\\n// Same approach, we move from R->L in this case no need to store\\n// results - we can just calculate answers rights away.\\n        for (int i = N-1; i>=0; i--)\\n        {\\n            if (i != N-1 )\\n            {\\n                if (security[i]<=security[i+1])\\n                    counter++;\\n                else\\n                    counter = 0;\\n            }\\n// This is a good day for robbery\\n            if (counter >=time && LR[i] >= time)\\n            {\\n                answer.Add(i);\\n            }\\n        }\\n        return answer;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/* Could write this shorter and more elegant, but this is simple */\\npublic class Solution {\\n\\n    int[] LR;    \\n    int N;\\n\\n    public IList<int> GoodDaysToRobBank(int[] security, int time) {\\n        N = security.Length;\\n        LR = new int[N];\\n//Counter for days that fulfil the critera when moving L->R\\n        int counter = 0;\\n        for (int i = 0; i < N; i++)\\n        {\\n            if (i > 0)\\n            {\\n// This day has same or less guards than previos one\\n                if (security[i-1]>=security[i])\\n                    counter++;\\n                else\\n                    counter = 0; // Reset\\n            }\\n            LR[i] = counter;\\n        }\\n\\n        counter = 0;\\n\\n        var answer = new List<int>(N);\\n// Same approach, we move from R->L in this case no need to store\\n// results - we can just calculate answers rights away.\\n        for (int i = N-1; i>=0; i--)\\n        {\\n            if (i != N-1 )\\n            {\\n                if (security[i]<=security[i+1])\\n                    counter++;\\n                else\\n                    counter = 0;\\n            }\\n// This is a good day for robbery\\n            if (counter >=time && LR[i] >= time)\\n            {\\n                answer.Add(i);\\n            }\\n        }\\n        return answer;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075143,
                "title": "using-prefix-sum-approch-and-precise-optiminal-solution-i-could-think-off-92-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(3n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(2n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int [] cntIn = new int[security.length];\\n        for(int i=1; i<security.length-time; i++){\\n            if(security[i] > security[i-1]) cntIn[i]=0;\\n            else cntIn[i] = cntIn[i-1]+1;\\n        }\\n\\n        int [] cntDe = new int[security.length];\\n        for(int i=security.length-2; i>=time; i--){\\n            if(security[i] > security[i+1]) cntDe[i]=0;\\n            else cntDe[i] = cntDe[i+1]+1;\\n        }\\n\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i=time; i<security.length; i++){\\n            if(cntIn[i]>=time && cntDe[i]>=time) list.add(i);\\n        }\\n\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int [] cntIn = new int[security.length];\\n        for(int i=1; i<security.length-time; i++){\\n            if(security[i] > security[i-1]) cntIn[i]=0;\\n            else cntIn[i] = cntIn[i-1]+1;\\n        }\\n\\n        int [] cntDe = new int[security.length];\\n        for(int i=security.length-2; i>=time; i--){\\n            if(security[i] > security[i+1]) cntDe[i]=0;\\n            else cntDe[i] = cntDe[i+1]+1;\\n        }\\n\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i=time; i<security.length; i++){\\n            if(cntIn[i]>=time && cntDe[i]>=time) list.add(i);\\n        }\\n\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060884,
                "title": "c-prefix-and-suffix-array",
                "content": "# Intuition\\nJust we have to build the prefix and suffix array and have to re-scan the arrays we have builded and check whether that day is good to rob or not!\\n\\n# Complexity\\n- Time complexity:\\n2*O(N) ~ O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n2*O(N) for prefix and suffix array!\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n = security.size();\\n        vector<int> before(security.size()+1, 0), after(security.size()+1, 0);\\n        for(int i=1;i<n;i++) {\\n            if(i==(n-1)) {\\n                if(security[i] <= security[i-1]) {\\n                    before[i] += before[i-1]+1;\\n                }\\n            }\\n            else {\\n                if(security[i] <= security[i-1]) {\\n                    before[i] += before[i-1]+1;\\n                }\\n                if((n-i-1) >= 0 && security[n-i-1] <= security[n-i]) {\\n                    after[n-i-1] += after[n-i]+1;\\n                }\\n            }\\n        }  \\n        vector<int> ans;  \\n        for(int i=max(0,time);i<(n-time);i++) {\\n            if(before[i] >= time && after[i] >= time) {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n = security.size();\\n        vector<int> before(security.size()+1, 0), after(security.size()+1, 0);\\n        for(int i=1;i<n;i++) {\\n            if(i==(n-1)) {\\n                if(security[i] <= security[i-1]) {\\n                    before[i] += before[i-1]+1;\\n                }\\n            }\\n            else {\\n                if(security[i] <= security[i-1]) {\\n                    before[i] += before[i-1]+1;\\n                }\\n                if((n-i-1) >= 0 && security[n-i-1] <= security[n-i]) {\\n                    after[n-i-1] += after[n-i]+1;\\n                }\\n            }\\n        }  \\n        vector<int> ans;  \\n        for(int i=max(0,time);i<(n-time);i++) {\\n            if(before[i] >= time && after[i] >= time) {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045021,
                "title": "easy-dp-cpp",
                "content": "# Intuition\\nTo determine the good days to rob the bank, we need to find days where the number of guards on duty is non-increasing for at least `time` days before and non-decreasing for at least `time` days after the current day. This implies that we should keep track of two things for each day:\\n\\n1. The number of consecutive days before the current day where the number of guards is non-increasing.\\n2. The number of consecutive days after the current day where the number of guards is non-decreasing.\\n\\nIf both of these values are greater than or equal to `time`, then the current day is a good day to rob the bank.\\n\\n# Approach\\n- Initialize two arrays, `dp` and `dp1`, both of size `n` (where `n` is the length of the `security` array) to keep track of the consecutive non-increasing and non-decreasing days, respectively.\\n- Loop through the `security` array from left to right to fill the `dp` array. For each day `i`, if `security[i]` is less than or equal to `security[i-1]`, increment `dp[i]` by 1; otherwise, reset `dp[i]` to 0.\\n- Loop through the `security` array from right to left to fill the `dp1` array. For each day `i`, if `security[i]` is less than or equal to `security[i+1]`, increment `dp1[i]` by 1; otherwise, reset `dp1[i]` to 0.\\n- Finally, loop through the `security` array again and check if both `dp[i]` and `dp1[i]` are greater than or equal to `time`. If they are, add `i` to the list of good days to rob the bank.\\n\\n# Complexity\\n- Time complexity: O(n), where n is the length of the `security` array. We loop through the array three times, each taking O(n) time.\\n- Space complexity: O(n), as we use two additional arrays of size `n` (`dp` and `dp1`) to store the consecutive non-increasing and non-decreasing days.\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n = security.size();\\n        vector<int> dp(n, 0), dp1(n, 0), ans;\\n\\n        // Calculate consecutive non-increasing days using dp array\\n        for (int i = 1; i < n; i++) {\\n            if (security[i] <= security[i - 1]) {\\n                dp[i] = dp[i - 1] + 1;\\n            }\\n        }\\n\\n        // Calculate consecutive non-decreasing days using dp1 array\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (security[i] <= security[i + 1]) {\\n                dp1[i] = dp1[i + 1] + 1;\\n            }\\n        }\\n\\n        // Check for good days to rob the bank\\n        for (int i = 0; i < n; i++) {\\n            if (dp[i] >= time && dp1[i] >= time) {\\n                ans.push_back(i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\nThis code should correctly find and return the good days to rob the bank based on the given conditions.\\nPls Upvote If you Like.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n = security.size();\\n        vector<int> dp(n, 0), dp1(n, 0), ans;\\n\\n        // Calculate consecutive non-increasing days using dp array\\n        for (int i = 1; i < n; i++) {\\n            if (security[i] <= security[i - 1]) {\\n                dp[i] = dp[i - 1] + 1;\\n            }\\n        }\\n\\n        // Calculate consecutive non-decreasing days using dp1 array\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (security[i] <= security[i + 1]) {\\n                dp1[i] = dp1[i + 1] + 1;\\n            }\\n        }\\n\\n        // Check for good days to rob the bank\\n        for (int i = 0; i < n; i++) {\\n            if (dp[i] >= time && dp1[i] >= time) {\\n                ans.push_back(i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992520,
                "title": "simple-c-prefix-and-suffix-check-clean-code-easy-to-understand",
                "content": "# Intuition\\nSimple prefix and suffix check\\n\\n# Approach\\nLine sweep \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        vector<int>ans;\\n        vector<int>before(security.size());\\n        vector<int>after(security.size());\\n        \\n        int currsize = 1;\\n        //filling the before array\\n        for(int i = 1; i<security.size() ;i++){\\n            \\n            if(security[i]<=security[i-1]){\\n                before[i] = currsize;\\n                currsize++;\\n            }\\n            else{\\n                before[i] = 0;\\n                currsize = 1;\\n            }\\n        }\\n\\n        //filling the after array\\n        currsize = 1;\\n        for(int i = security.size()-2; i>=0; i--){\\n            if(security[i]<=security[i+1]){\\n                after[i] = currsize;\\n                currsize++;\\n            }\\n\\n            else{\\n                after[i] = 0;\\n                currsize = 1;\\n            }\\n        }\\n\\n        for(int i = 0; i<security.size(); i++){\\n            if(i-time>=0 and i+time<security.size()){\\n                if(before[i]>=time and after[i]>=time){\\n                    ans.push_back(i);\\n                }\\n            }\\n\\n            else{\\n                continue;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Line Sweep",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        vector<int>ans;\\n        vector<int>before(security.size());\\n        vector<int>after(security.size());\\n        \\n        int currsize = 1;\\n        //filling the before array\\n        for(int i = 1; i<security.size() ;i++){\\n            \\n            if(security[i]<=security[i-1]){\\n                before[i] = currsize;\\n                currsize++;\\n            }\\n            else{\\n                before[i] = 0;\\n                currsize = 1;\\n            }\\n        }\\n\\n        //filling the after array\\n        currsize = 1;\\n        for(int i = security.size()-2; i>=0; i--){\\n            if(security[i]<=security[i+1]){\\n                after[i] = currsize;\\n                currsize++;\\n            }\\n\\n            else{\\n                after[i] = 0;\\n                currsize = 1;\\n            }\\n        }\\n\\n        for(int i = 0; i<security.size(); i++){\\n            if(i-time>=0 and i+time<security.size()){\\n                if(before[i]>=time and after[i]>=time){\\n                    ans.push_back(i);\\n                }\\n            }\\n\\n            else{\\n                continue;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968644,
                "title": "java-dp-2-array",
                "content": "Use two arrays, one count from left, on count from right;\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int n = security.length;\\n        int[] left = new int[n];\\n        int[] right = new int[n];\\n\\n        for (int i = 1; i < n; i++) {\\n            left[i] = security[i] <= security[i - 1] ? left[i] = left[i - 1] + 1 : 0;\\n        }\\n        for (int i = security.length - 2; i >= 0; i--) {\\n            right[i] = security[i] <= security[i + 1] ? right[i + 1] + 1 : 0;\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        for (int i = 0; i < security.length; i++) {\\n            if (left[i] >= time && right[i] >= time) {\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int n = security.length;\\n        int[] left = new int[n];\\n        int[] right = new int[n];\\n\\n        for (int i = 1; i < n; i++) {\\n            left[i] = security[i] <= security[i - 1] ? left[i] = left[i - 1] + 1 : 0;\\n        }\\n        for (int i = security.length - 2; i >= 0; i--) {\\n            right[i] = security[i] <= security[i + 1] ? right[i + 1] + 1 : 0;\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        for (int i = 0; i < security.length; i++) {\\n            if (left[i] >= time && right[i] >= time) {\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918725,
                "title": "best-solution-using-longest-increasing-subsequence",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        \\n        int n=security.size();\\n        vector<int> dp1(n,1);\\n        vector<int> dp2(n,1);\\n        if(n==1)\\n        {\\n            if(time==0)return {0};\\n            return {};\\n        }\\n\\n        //longest increaing securityay from end\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(security[i]<=security[i+1])\\n            {\\n                dp1[i]=1+dp1[i+1];\\n            }\\n        }\\n\\n        //longest decreasing subsecurityay form start\\n        for(int i=1;i<n;i++)\\n        {\\n            if(security[i]<=security[i-1])\\n            {\\n                dp2[i]=1+dp2[i-1];\\n            }\\n        }\\n\\n        security.clear();\\n        for(int i=time;i<n-time;i++)\\n        {\\n            if(i==0 && dp1[i]>=(time+1))\\n            {\\n                security.push_back(i);\\n            }\\n            else if(i==n-1 && dp2[i]>=(1+time))\\n            {\\n                security.push_back(i);\\n            }\\n            else if(dp2[i]>=(time+1) && dp1[i]>=(1+time))\\n            {\\n                security.push_back(i);\\n            }\\n        }\\n        return security;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        \\n        int n=security.size();\\n        vector<int> dp1(n,1);\\n        vector<int> dp2(n,1);\\n        if(n==1)\\n        {\\n            if(time==0)return {0};\\n            return {};\\n        }\\n\\n        //longest increaing securityay from end\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(security[i]<=security[i+1])\\n            {\\n                dp1[i]=1+dp1[i+1];\\n            }\\n        }\\n\\n        //longest decreasing subsecurityay form start\\n        for(int i=1;i<n;i++)\\n        {\\n            if(security[i]<=security[i-1])\\n            {\\n                dp2[i]=1+dp2[i-1];\\n            }\\n        }\\n\\n        security.clear();\\n        for(int i=time;i<n-time;i++)\\n        {\\n            if(i==0 && dp1[i]>=(time+1))\\n            {\\n                security.push_back(i);\\n            }\\n            else if(i==n-1 && dp2[i]>=(1+time))\\n            {\\n                security.push_back(i);\\n            }\\n            else if(dp2[i]>=(time+1) && dp1[i]>=(1+time))\\n            {\\n                security.push_back(i);\\n            }\\n        }\\n        return security;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855010,
                "title": "a-single-cycle-o-n-space-runtime-c",
                "content": "# Approach\\n\\nWe create a vector of per-day analyse and for each day we store whether in the original array there\\'s enough left and right days. We default-initialize days with \"Ok\", and then only update a day when it turns out not to be \"ok\".\\n\\nSince we need to consider days both on the left and right sides, we do that simultaneously in the same cycle.\\n\\nThe obvious optimization here is that each cycle instead of cycling through `time` elements on the left and right side we simply store/update the index of the last found \"bad\" day, then we calculate the distance to it from the current day.\\n\\nAfter we did that for every day, it is only a matter of gathering all \"okayish\" days from the vector and returning the result. The easiest way would be to do that in a separate cycle *(this wouldn\\'t influence $$O()$$ anyway)*, but for just for the sake of exercise I put it in the same cycle where calculation is done.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(const vector<int>& security, int time) {\\n        enum State {Ok, Bad};\\n        vector<State> days_analysis(security.size());\\n        int i_left_bad_days = -1, i_mirrored_right_bad_days = -1;\\n        vector<int> ret;\\n        const size_t i_indices_meet_location = (security.size() + 2) / 2 -1;\\n        for (int i = 0; i < security.size(); ++i) {\\n            if (i > 0 && security[i-1] < security[i]) {\\n                i_left_bad_days = i-1;\\n            }\\n            if (i - i_left_bad_days -1 < time)\\n                days_analysis[i] = Bad;\\n\\n            size_t i_right = security.size() - 1 - i;\\n            if (i > 0 && security[i_right] > security[i_right+1]) {\\n                i_mirrored_right_bad_days = i-1;\\n            }\\n            if (i - i_mirrored_right_bad_days -1 < time)\\n                days_analysis[i_right] = Bad;\\n\\n            if (i >= i_indices_meet_location) {\\n                if (days_analysis[i] == Ok)\\n                    ret.push_back(i);\\n                if (days_analysis[i_right] == Ok && i != i_right)\\n                    ret.push_back(i_right);\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(const vector<int>& security, int time) {\\n        enum State {Ok, Bad};\\n        vector<State> days_analysis(security.size());\\n        int i_left_bad_days = -1, i_mirrored_right_bad_days = -1;\\n        vector<int> ret;\\n        const size_t i_indices_meet_location = (security.size() + 2) / 2 -1;\\n        for (int i = 0; i < security.size(); ++i) {\\n            if (i > 0 && security[i-1] < security[i]) {\\n                i_left_bad_days = i-1;\\n            }\\n            if (i - i_left_bad_days -1 < time)\\n                days_analysis[i] = Bad;\\n\\n            size_t i_right = security.size() - 1 - i;\\n            if (i > 0 && security[i_right] > security[i_right+1]) {\\n                i_mirrored_right_bad_days = i-1;\\n            }\\n            if (i - i_mirrored_right_bad_days -1 < time)\\n                days_analysis[i_right] = Bad;\\n\\n            if (i >= i_indices_meet_location) {\\n                if (days_analysis[i] == Ok)\\n                    ret.push_back(i);\\n                if (days_analysis[i_right] == Ok && i != i_right)\\n                    ret.push_back(i_right);\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852286,
                "title": "c-o-n-beats-100",
                "content": "# Intuition\\nA given index is valid if there are a atleast `time` number of indices before it that are non-increasing and atleast a `time` number of indices that are non-decreasing.\\n\\nFor a given index we keep track 2 arrays: \\n\\n**Array1:**  Keeps track of the number of elements that are non increasing before the `ith` element\\n\\n**Array2:** Keeps track of the number of elements that are non decreasing after the `ith` element\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // if prev <= cur then dp[cur] = dp[prev] + 1 else 0\\n    // reverse the arr, run the same, reverse the dp2 => gives increasing\\n    void getNonIncreasingCntAtIdx(vector<int>&nums, vector<int>&dp)\\n    {\\n        dp[0] = 0;\\n        int prev = nums[0];\\n        for (int i = 1; i < nums.size();i++)\\n        {\\n            dp[i] = prev >= nums[i]\\n                ? 1 + dp[i-1]\\n                : 0;\\n            prev = nums[i];\\n        }\\n\\n        return;\\n    }\\n\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        vector<int> dp1(security.size(), 0);\\n        getNonIncreasingCntAtIdx(security, dp1);\\n\\n        vector<int> dp2(security.size(), 0);\\n        reverse(security.begin(), security.end());\\n        getNonIncreasingCntAtIdx(security, dp2);\\n        reverse(dp2.begin(), dp2.end());\\n\\n        vector<int> resArr;\\n        for (int i = 0; i < dp1.size(); i++)\\n        {\\n            if (time <= dp1[i] && time <= dp2[i])\\n                resArr.push_back(i);\\n        }\\n            \\n        return resArr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // if prev <= cur then dp[cur] = dp[prev] + 1 else 0\\n    // reverse the arr, run the same, reverse the dp2 => gives increasing\\n    void getNonIncreasingCntAtIdx(vector<int>&nums, vector<int>&dp)\\n    {\\n        dp[0] = 0;\\n        int prev = nums[0];\\n        for (int i = 1; i < nums.size();i++)\\n        {\\n            dp[i] = prev >= nums[i]\\n                ? 1 + dp[i-1]\\n                : 0;\\n            prev = nums[i];\\n        }\\n\\n        return;\\n    }\\n\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        vector<int> dp1(security.size(), 0);\\n        getNonIncreasingCntAtIdx(security, dp1);\\n\\n        vector<int> dp2(security.size(), 0);\\n        reverse(security.begin(), security.end());\\n        getNonIncreasingCntAtIdx(security, dp2);\\n        reverse(dp2.begin(), dp2.end());\\n\\n        vector<int> resArr;\\n        for (int i = 0; i < dp1.size(); i++)\\n        {\\n            if (time <= dp1[i] && time <= dp2[i])\\n                resArr.push_back(i);\\n        }\\n            \\n        return resArr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849366,
                "title": "c-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n=security.size();\\n        vector<int> left(n);\\n        left[0]=0;\\n        for(int i=1;i<n;i++)\\n            left[i]=(security[i-1]>=security[i]) ? left[i-1]+1 : 0 ; \\n\\n        vector<int> right(n);\\n        right[n-1]=0;\\n        for(int i=n-2;i>=0;i--)\\n            right[i]=(security[i+1]>=security[i]) ? right[i+1]+1 : 0;\\n\\n        vector<int> ans;\\n        for(int i=0;i<n;i++)\\n            if(left[i]>=time &&  right[i]>=time)\\n                ans.push_back(i);\\n\\n        return ans;           \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n=security.size();\\n        vector<int> left(n);\\n        left[0]=0;\\n        for(int i=1;i<n;i++)\\n            left[i]=(security[i-1]>=security[i]) ? left[i-1]+1 : 0 ; \\n\\n        vector<int> right(n);\\n        right[n-1]=0;\\n        for(int i=n-2;i>=0;i--)\\n            right[i]=(security[i+1]>=security[i]) ? right[i+1]+1 : 0;\\n\\n        vector<int> ans;\\n        for(int i=0;i<n;i++)\\n            if(left[i]>=time &&  right[i]>=time)\\n                ans.push_back(i);\\n\\n        return ans;           \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832765,
                "title": "most-optimized-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& nums, int time) {\\n        \\n        int n = nums.size();\\n        int l = 0;\\n        int r = 0;\\n\\n        vector<int>ans;\\n\\n        for(int i = 0; i < n; i++) {\\n\\n            //left pointer\\n            if((i - 1) >= 0 && nums[i] > nums[i - 1]) {\\n                l = i;\\n            }\\n\\n            \\n            //right pointer\\n            if(r <= i) {\\n                r = i;\\n                while(r + 1 < n && nums[r] <= nums[r + 1]){\\n                    r++;\\n                }\\n            }\\n\\n\\n            cout<<l<<\" \"<<r<<endl;\\n\\n\\n            if(r - l + 1 >= time && l <= i - time && r >= i + time) ans.push_back(i);\\n\\n        }\\n\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& nums, int time) {\\n        \\n        int n = nums.size();\\n        int l = 0;\\n        int r = 0;\\n\\n        vector<int>ans;\\n\\n        for(int i = 0; i < n; i++) {\\n\\n            //left pointer\\n            if((i - 1) >= 0 && nums[i] > nums[i - 1]) {\\n                l = i;\\n            }\\n\\n            \\n            //right pointer\\n            if(r <= i) {\\n                r = i;\\n                while(r + 1 < n && nums[r] <= nums[r + 1]){\\n                    r++;\\n                }\\n            }\\n\\n\\n            cout<<l<<\" \"<<r<<endl;\\n\\n\\n            if(r - l + 1 >= time && l <= i - time && r >= i + time) ans.push_back(i);\\n\\n        }\\n\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3822801,
                "title": "easy-to-understand-c-prefix-suffix-array-approach",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& s, int time) {\\n        int n=s.size();\\n        vector<int>prefix(n, 1), suffix(n, 1);\\n        for(int i=1; i<n; i++){\\n            if(s[i]<=s[i-1]){\\n                prefix[i]=prefix[i-1]+1;\\n            }\\n        }\\n        for(int i=n-2; i>=0; i--){\\n            if(s[i]<=s[i+1]){\\n                suffix[i]=1+suffix[i+1];\\n            }\\n        }\\n        vector<int>res;\\n        for(int i=0; i<n; i++){\\n            if(prefix[i]>time && suffix[i]>time){\\n                res.push_back(i);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& s, int time) {\\n        int n=s.size();\\n        vector<int>prefix(n, 1), suffix(n, 1);\\n        for(int i=1; i<n; i++){\\n            if(s[i]<=s[i-1]){\\n                prefix[i]=prefix[i-1]+1;\\n            }\\n        }\\n        for(int i=n-2; i>=0; i--){\\n            if(s[i]<=s[i+1]){\\n                suffix[i]=1+suffix[i+1];\\n            }\\n        }\\n        vector<int>res;\\n        for(int i=0; i<n; i++){\\n            if(prefix[i]>time && suffix[i]>time){\\n                res.push_back(i);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791326,
                "title": "ho-gya-bas-asan-h-ek-baar-click-ho-jaye-to",
                "content": "class Solution {\\n    public List<Integer> goodDaysToRobBank(int[] nums, int k) {\\n        int n=nums.length ;\\n        ArrayList<Integer>list = new ArrayList<>() ;\\n        int right[]=new int[nums.length] ;\\n        int left[]=new int[nums.length] ;\\n        right[nums.length-1]=0 ;\\n        left[0]=0 ;\\n        for(int i=n-2; i>=0; i--) {\\n            if(nums[i]<=nums[i+1]) {\\n                right[i]=right[i+1]+1 ;\\n            }\\n            else {\\n                right[i]=0 ;\\n            }\\n        }\\n        for(int i=1; i<n; i++) {\\n            if(nums[i]<=nums[i-1]) {\\n                left[i]=left[i-1]+1 ;\\n            }\\n            else {\\n                left[i]=0; \\n            }\\n        }\\n        for(int i=k; i<n-k; i++) {\\n            if(left[i]>=k && right[i]>=k) {\\n                list.add(i) ;\\n            }\\n        }\\n        return list ;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<Integer> goodDaysToRobBank(int[] nums, int k) {\\n        int n=nums.length ;\\n        ArrayList<Integer>list = new ArrayList<>() ;\\n        int right[]=new int[nums.length] ;\\n        int left[]=new int[nums.length] ;\\n        right[nums.length-1]=0 ;\\n        left[0]=0 ;\\n        for(int i=n-2; i>=0; i--) {\\n            if(nums[i]<=nums[i+1]) {\\n                right[i]=right[i+1]+1 ;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3789480,
                "title": "nonincrearese-nondecrease-slices",
                "content": "\\n# Code\\n```\\nfunc goodDaysToRobBank(security []int, time int) []int {\\n\\tnonInc := make([]int, len(security)+1)\\n\\tnonDec := make([]int, len(security)+1)\\n\\tfor i := 1; i < len(security); i++ {\\n\\t\\tif security[i] <= security[i-1] {\\n\\t\\t\\tnonInc[i] += nonInc[i-1]+1\\n\\t\\t}\\n\\n\\t\\tif security[i] >= security[i-1] {\\n\\t\\t\\tnonDec[i] += nonDec[i-1]+1\\n\\t\\t}\\n\\t}\\n\\n\\tout := make([]int, 0)\\n\\tfor i := time; i < len(security)-time; i++ {\\n\\t\\tif nonInc[i] >= time && nonDec[i+time] >= time {\\n\\t\\t\\tout = append(out, i)\\n\\t\\t}\\n\\t}\\n\\treturn out\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc goodDaysToRobBank(security []int, time int) []int {\\n\\tnonInc := make([]int, len(security)+1)\\n\\tnonDec := make([]int, len(security)+1)\\n\\tfor i := 1; i < len(security); i++ {\\n\\t\\tif security[i] <= security[i-1] {\\n\\t\\t\\tnonInc[i] += nonInc[i-1]+1\\n\\t\\t}\\n\\n\\t\\tif security[i] >= security[i-1] {\\n\\t\\t\\tnonDec[i] += nonDec[i-1]+1\\n\\t\\t}\\n\\t}\\n\\n\\tout := make([]int, 0)\\n\\tfor i := time; i < len(security)-time; i++ {\\n\\t\\tif nonInc[i] >= time && nonDec[i+time] >= time {\\n\\t\\t\\tout = append(out, i)\\n\\t\\t}\\n\\t}\\n\\treturn out\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3729156,
                "title": "python-easy-solution-prefix-suffix-in-o-n",
                "content": "# Intuition\\r\\nAt every index, if we can somehow find the number of decreasing days from its left, and the number of increasing days to its right, we can check if today is a good day to rob by simply checking if ```(number of decreasing days from left >= time) and (number of increasing days to right >= k)```\\r\\n# Approach\\r\\nThis questions requires us to generate prefix and suffix arrays for what we want to do. For the array ```decreasing```, we start by iterating through ```security``` one by one, each time calculating if ```security``` has been consecutively decreasing or not. If we find an element that increases, we reset the consecutive counter to 0.\\r\\n\\r\\nWe do a similar thing for the increasing array, except here, we start moving from the right side down to the left.\\r\\n\\r\\nI\\'ve expanded the code to make it more readable, though you may have clearly observed some opportunities to do the same with lesser lines of code and more compact loops.\\r\\n\\r\\nThe final loop runs between ``` [time, n - time)```, which is ```[time, n-time-1]``` in mathematical bounds.\\r\\n# Complexity\\r\\n- Time complexity:\\r\\nO(N) to make the prefix array, O(N) to make the suffix array, and O(N) to compute the solution.\\r\\n=> O(3N), which is O(N).\\r\\n- Space complexity:\\r\\nO(2N) to store the prefix and the suffix arrays, though this can be reduced to O(N) by combining them into a single array (try this as an exercise!)\\r\\n=> O(2N), which is O(N).\\r\\n# Code\\r\\n```\\r\\nclass Solution:\\r\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\r\\n        n = len(security)\\r\\n\\r\\n        decreasing = [0] * n\\r\\n        consec = 0\\r\\n        for i in range(1, n):\\r\\n            if security[i] <= security[i - 1]:\\r\\n                consec += 1\\r\\n                decreasing[i] = consec\\r\\n            else:\\r\\n                consec = 0\\r\\n                decreasing[i] = consec\\r\\n\\r\\n        increasing = [0] * n\\r\\n        consec = 0\\r\\n        for i in range(n - 2, -1, -1):\\r\\n            if security[i + 1] >= security[i]:\\r\\n                consec += 1\\r\\n                increasing[i] = consec\\r\\n            else:\\r\\n                consec = 0\\r\\n                increasing[i] = consec\\r\\n\\r\\n        ans = []\\r\\n        for i in range(time, n - time):\\r\\n            if increasing[i] >= time and decreasing[i] >= time:\\r\\n                ans.append(i)\\r\\n        return ans\\r\\n\\r\\n\\r\\n```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```(number of decreasing days from left >= time) and (number of increasing days to right >= k)```\n```decreasing```\n```security```\n```security```\n``` [time, n - time)```\n```[time, n-time-1]```\n```\\r\\nclass Solution:\\r\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\r\\n        n = len(security)\\r\\n\\r\\n        decreasing = [0] * n\\r\\n        consec = 0\\r\\n        for i in range(1, n):\\r\\n            if security[i] <= security[i - 1]:\\r\\n                consec += 1\\r\\n                decreasing[i] = consec\\r\\n            else:\\r\\n                consec = 0\\r\\n                decreasing[i] = consec\\r\\n\\r\\n        increasing = [0] * n\\r\\n        consec = 0\\r\\n        for i in range(n - 2, -1, -1):\\r\\n            if security[i + 1] >= security[i]:\\r\\n                consec += 1\\r\\n                increasing[i] = consec\\r\\n            else:\\r\\n                consec = 0\\r\\n                increasing[i] = consec\\r\\n\\r\\n        ans = []\\r\\n        for i in range(time, n - time):\\r\\n            if increasing[i] >= time and decreasing[i] >= time:\\r\\n                ans.append(i)\\r\\n        return ans\\r\\n\\r\\n\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698386,
                "title": "set",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf there are at least time adjacent pairs that is non-incresing, then the last index of the element could be a candidate.\\n\\nSimilarly, we could find all indices satisfying the non-decreasing condition.\\n\\nSince the for loop doesn\\'t consider the first and last element if time = 0, return all indices, else return intersection of the two sets.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        if time == 0:\\n            return [i for i in range(len(security))]\\n\\n        ni = set()\\n        nd = set()\\n        count = 0\\n\\n        for i in range(1, len(security)):\\n            if security[i] <= security[i-1]:\\n                count += 1\\n            else:\\n                count = 0\\n            \\n            if count >= time:\\n                ni.add(i)\\n\\n        count = 0\\n\\n        for i in range(len(security)-2, -1, -1):\\n            if security[i] <= security[i+1]:\\n                count += 1\\n            else:\\n                count = 0\\n            \\n            if count >= time:\\n                nd.add(i)\\n\\n        return list(ni&nd)     \\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        if time == 0:\\n            return [i for i in range(len(security))]\\n\\n        ni = set()\\n        nd = set()\\n        count = 0\\n\\n        for i in range(1, len(security)):\\n            if security[i] <= security[i-1]:\\n                count += 1\\n            else:\\n                count = 0\\n            \\n            if count >= time:\\n                ni.add(i)\\n\\n        count = 0\\n\\n        for i in range(len(security)-2, -1, -1):\\n            if security[i] <= security[i+1]:\\n                count += 1\\n            else:\\n                count = 0\\n            \\n            if count >= time:\\n                nd.add(i)\\n\\n        return list(ni&nd)     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696838,
                "title": "two-arrays-right-to-left-and-left-to-right-for-maintaining-the-incresing-and-decreasing-sequence",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] nums, int time) {\\n        int []ltr=new int [nums.length];\\n        for(int i=1;i<ltr.length;i++){\\n            if(nums[i]<=nums[i-1]){\\n                ltr[i]=ltr[i-1]+1;\\n            }\\n        }\\n        int []rtl=new int[nums.length];\\n        rtl[nums.length-1]=0;\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(nums[i]<=nums[i+1]){\\n                rtl[i]=rtl[i+1]+1;\\n            }\\n        }\\n        List<Integer>ans=new ArrayList<>();\\n        for(int i=0;i<rtl.length;i++){\\n            if(ltr[i]>=time && rtl[i]>=time){\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] nums, int time) {\\n        int []ltr=new int [nums.length];\\n        for(int i=1;i<ltr.length;i++){\\n            if(nums[i]<=nums[i-1]){\\n                ltr[i]=ltr[i-1]+1;\\n            }\\n        }\\n        int []rtl=new int[nums.length];\\n        rtl[nums.length-1]=0;\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(nums[i]<=nums[i+1]){\\n                rtl[i]=rtl[i+1]+1;\\n            }\\n        }\\n        List<Integer>ans=new ArrayList<>();\\n        for(int i=0;i<rtl.length;i++){\\n            if(ltr[i]>=time && rtl[i]>=time){\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686968,
                "title": "javascript-2100-find-good-days-to-rob-the-bank",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// a[i - t] >= a[i - t + 1] >= ... >=                 (decreasing)\\n//        a[i]\\n//               <= ... <= a[i + t - 1] <= a[i + t]   (increasing)\\nvar goodDaysToRobBank = function (a, t) {\\n  let an = [];\\n  for (let i = t; i + t < a.length; i++) {\\n    let bad = 0\\n    for (let j = i - t + 1; j <= i; j++)\\n      if (a[j - 1] < a[j]) {\\n        bad = 1; // increasing\\n        break\\n      }\\n    for (let j = i + 1; j <= i + t; j++)\\n      if (a[j - 1] > a[j]) {\\n        bad = 1; // decreasing\\n        break\\n      }\\n    if (!bad) {\\n      an.push(i)\\n    }\\n  }\\n  return an;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// a[i - t] >= a[i - t + 1] >= ... >=                 (decreasing)\\n//        a[i]\\n//               <= ... <= a[i + t - 1] <= a[i + t]   (increasing)\\nvar goodDaysToRobBank = function (a, t) {\\n  let an = [];\\n  for (let i = t; i + t < a.length; i++) {\\n    let bad = 0\\n    for (let j = i - t + 1; j <= i; j++)\\n      if (a[j - 1] < a[j]) {\\n        bad = 1; // increasing\\n        break\\n      }\\n    for (let j = i + 1; j <= i + t; j++)\\n      if (a[j - 1] > a[j]) {\\n        bad = 1; // decreasing\\n        break\\n      }\\n    if (!bad) {\\n      an.push(i)\\n    }\\n  }\\n  return an;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3672046,
                "title": "python3-simple-prefix-suffix-array",
                "content": "# Code\\n```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        N = len(security)\\n        prefix = [0]*N\\n        cnt = 0\\n        for i in range(1, N):\\n            if security[i-1]>=security[i]:\\n                cnt+=1\\n            else:\\n                cnt = 0\\n            prefix[i] = cnt\\n\\n        suffix = [0]*N\\n        cnt = 0\\n        for i in range(N-2, -1, -1):\\n            if security[i]<=security[i+1]:\\n                cnt+=1\\n            else:\\n                cnt = 0\\n            suffix[i] = cnt\\n\\n        ansArr = []\\n        for i in range(N):\\n            if prefix[i]>=time and suffix[i]>=time:\\n                ansArr.append(i)\\n            \\n        return ansArr\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        N = len(security)\\n        prefix = [0]*N\\n        cnt = 0\\n        for i in range(1, N):\\n            if security[i-1]>=security[i]:\\n                cnt+=1\\n            else:\\n                cnt = 0\\n            prefix[i] = cnt\\n\\n        suffix = [0]*N\\n        cnt = 0\\n        for i in range(N-2, -1, -1):\\n            if security[i]<=security[i+1]:\\n                cnt+=1\\n            else:\\n                cnt = 0\\n            suffix[i] = cnt\\n\\n        ansArr = []\\n        for i in range(N):\\n            if prefix[i]>=time and suffix[i]>=time:\\n                ansArr.append(i)\\n            \\n        return ansArr\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654874,
                "title": "cpp-prefix-suffix-array-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& arr, int time) {\\n        int n = arr.size();\\n        vector<int> pre(n,0),post(n,0),ans;\\n        for(int i=1;i<n;i++){\\n            if(arr[i-1]>=arr[i]) pre[i]=pre[i-1]+1;\\n            if(arr[n-i-1]<=arr[n-i]) post[n-i-1]=post[n-i]+1;\\n        }\\n        \\n        for(int i=0+time;i<n-time;i++){\\n            if(pre[i]>=time and post[i]>=time) ans.push_back(i);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& arr, int time) {\\n        int n = arr.size();\\n        vector<int> pre(n,0),post(n,0),ans;\\n        for(int i=1;i<n;i++){\\n            if(arr[i-1]>=arr[i]) pre[i]=pre[i-1]+1;\\n            if(arr[n-i-1]<=arr[n-i]) post[n-i-1]=post[n-i]+1;\\n        }\\n        \\n        for(int i=0+time;i<n-time;i++){\\n            if(pre[i]>=time and post[i]>=time) ans.push_back(i);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652176,
                "title": "easy-dp-approach",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] arr, int time) {\\n        List<Integer> ans = new ArrayList<>();\\n        \\n        int n = arr.length;\\n        int[] r = new int[n];\\n        int[] l = new int[n];\\n        \\n        for(int i=1;i<n;i++){\\n            if(arr[i-1]>=arr[i]){\\n                l[i] = l[i-1] + 1;\\n            }\\n        }\\n        \\n        for(int i=n-2;i>=0;i--){\\n            if(arr[i+1]>=arr[i]){\\n                r[i] = r[i+1] + 1;\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(l[i]>=time && r[i]>=time){\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] arr, int time) {\\n        List<Integer> ans = new ArrayList<>();\\n        \\n        int n = arr.length;\\n        int[] r = new int[n];\\n        int[] l = new int[n];\\n        \\n        for(int i=1;i<n;i++){\\n            if(arr[i-1]>=arr[i]){\\n                l[i] = l[i-1] + 1;\\n            }\\n        }\\n        \\n        for(int i=n-2;i>=0;i--){\\n            if(arr[i+1]>=arr[i]){\\n                r[i] = r[i+1] + 1;\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(l[i]>=time && r[i]>=time){\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652175,
                "title": "easy-dp-approach",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] arr, int time) {\\n        List<Integer> ans = new ArrayList<>();\\n        \\n        int n = arr.length;\\n        int[] r = new int[n];\\n        int[] l = new int[n];\\n        \\n        for(int i=1;i<n;i++){\\n            if(arr[i-1]>=arr[i]){\\n                l[i] = l[i-1] + 1;\\n            }\\n        }\\n        \\n        for(int i=n-2;i>=0;i--){\\n            if(arr[i+1]>=arr[i]){\\n                r[i] = r[i+1] + 1;\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(l[i]>=time && r[i]>=time){\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] arr, int time) {\\n        List<Integer> ans = new ArrayList<>();\\n        \\n        int n = arr.length;\\n        int[] r = new int[n];\\n        int[] l = new int[n];\\n        \\n        for(int i=1;i<n;i++){\\n            if(arr[i-1]>=arr[i]){\\n                l[i] = l[i-1] + 1;\\n            }\\n        }\\n        \\n        for(int i=n-2;i>=0;i--){\\n            if(arr[i+1]>=arr[i]){\\n                r[i] = r[i+1] + 1;\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(l[i]>=time && r[i]>=time){\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648264,
                "title": "rust-prefix-arrays-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn good_days_to_rob_bank(security: Vec<i32>, time: i32) -> Vec<i32> {\\n        let mut p1 = vec![0; security.len()];\\n        for i in 1..p1.len() {\\n            if security[i - 1] >= security[i] {\\n                p1[i] = 1 + p1[i - 1];\\n            }\\n        }\\n        // println!(\"{:?}\", p1);\\n\\n        let mut p2 = vec![0; security.len()];\\n        for i in (0..p2.len()-1).rev() {\\n            if security[i + 1] >= security[i] {\\n                p2[i] = 1 + p2[i + 1];\\n            }\\n        }\\n        // println!(\"{:?}\", p2);\\n\\n        let mut ans = vec![];\\n\\n        for i in 0..security.len() {\\n            if p1[i] >= time && p2[i] >= time {\\n                ans.push(i as i32);\\n            }\\n        }\\n\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn good_days_to_rob_bank(security: Vec<i32>, time: i32) -> Vec<i32> {\\n        let mut p1 = vec![0; security.len()];\\n        for i in 1..p1.len() {\\n            if security[i - 1] >= security[i] {\\n                p1[i] = 1 + p1[i - 1];\\n            }\\n        }\\n        // println!(\"{:?}\", p1);\\n\\n        let mut p2 = vec![0; security.len()];\\n        for i in (0..p2.len()-1).rev() {\\n            if security[i + 1] >= security[i] {\\n                p2[i] = 1 + p2[i + 1];\\n            }\\n        }\\n        // println!(\"{:?}\", p2);\\n\\n        let mut ans = vec![];\\n\\n        for i in 0..security.len() {\\n            if p1[i] >= time && p2[i] >= time {\\n                ans.push(i as i32);\\n            }\\n        }\\n\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3640549,
                "title": "easy-clean-dp-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n = security.size();\\n        vector<pair<int,int>> dp(n,{0,0});\\n        for(int i=0; i<n-1; i++) {\\n              dp[i+1].first = security[i] >= security[i+1] ? 1 + dp[i].first : 0;\\n        }\\n        for(int i=n-2; i>=0; i--) {\\n             dp[i].second = security[i] <= security[i+1] ? 1 + dp[i+1].second : 0; \\n        }\\n        vector<int> ans;\\n        for(int i=0; i<n; i++) {\\n              if(min(dp[i].first,dp[i].second)>=time) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n = security.size();\\n        vector<pair<int,int>> dp(n,{0,0});\\n        for(int i=0; i<n-1; i++) {\\n              dp[i+1].first = security[i] >= security[i+1] ? 1 + dp[i].first : 0;\\n        }\\n        for(int i=n-2; i>=0; i--) {\\n             dp[i].second = security[i] <= security[i+1] ? 1 + dp[i+1].second : 0; \\n        }\\n        vector<int> ans;\\n        for(int i=0; i<n; i++) {\\n              if(min(dp[i].first,dp[i].second)>=time) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580007,
                "title": "very-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n=security.size();\\n        vector<int>pre(n,0);\\n        vector<int>suf(n,0);\\n        for(int i=1;i<n;i++){\\n            if(security[i]<=security[i-1]){\\n                pre[i]=pre[i-1]+1;\\n            }\\n            else{\\n                pre[i]=0;\\n            }\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            if(security[i]<=security[i+1]){\\n                suf[i]=suf[i+1]+1;\\n            }\\n            else{\\n                suf[i]=0;\\n            }\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            if(pre[i]>=time && suf[i]>=time)ans.push_back(i);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n=security.size();\\n        vector<int>pre(n,0);\\n        vector<int>suf(n,0);\\n        for(int i=1;i<n;i++){\\n            if(security[i]<=security[i-1]){\\n                pre[i]=pre[i-1]+1;\\n            }\\n            else{\\n                pre[i]=0;\\n            }\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            if(security[i]<=security[i+1]){\\n                suf[i]=suf[i+1]+1;\\n            }\\n            else{\\n                suf[i]=0;\\n            }\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            if(pre[i]>=time && suf[i]>=time)ans.push_back(i);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524810,
                "title": "c-3-iterations-to-find-collect-v-shape",
                "content": "- Need to find `V-shape` indices with left/right V size `>= time`\\n- Iterate left to right, and right to left, to generate the `V size`\\n- A 3rd iterate to collect all `valid indices`\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n = security.size();\\n        vector<int> decs(n), incs(n);\\n        for(int i = 1;   i < n;  ++i) decs[i] = (security[i] <= security[i-1] ? decs[i-1] + 1 : 0);\\n        for(int i = n-2; i >= 0; --i) incs[i] = (security[i] <= security[i+1] ? incs[i+1] + 1 : 0);\\n            \\n        vector<int> ans;\\n        for(int i = time; i < n - time; ++i) {\\n            if(decs[i]>= time && incs[i] >= time)\\n                ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n = security.size();\\n        vector<int> decs(n), incs(n);\\n        for(int i = 1;   i < n;  ++i) decs[i] = (security[i] <= security[i-1] ? decs[i-1] + 1 : 0);\\n        for(int i = n-2; i >= 0; --i) incs[i] = (security[i] <= security[i+1] ? incs[i+1] + 1 : 0);\\n            \\n        vector<int> ans;\\n        for(int i = time; i < n - time; ++i) {\\n            if(decs[i]>= time && incs[i] >= time)\\n                ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511082,
                "title": "c-1-boolean-vector",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& s, int t) {\\n        int c = 0, prev = INT_MAX;\\n        vector<bool> h(s.size());\\n        for (int i = 0; i < s.size(); ++i){\\n            c = s[i] <= prev ? ++c : 1;\\n            prev = s[i];\\n            h[i] = c > t;\\n        }\\n        vector<int> ans;\\n        for (int i = s.size() - 1, c = 0, prev = INT_MAX; i >= 0; --i) {\\n            c = abs(s[i] <= prev) ? ++c : 1;\\n            prev = abs(s[i]);\\n            if (c > t && h[i]) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& s, int t) {\\n        int c = 0, prev = INT_MAX;\\n        vector<bool> h(s.size());\\n        for (int i = 0; i < s.size(); ++i){\\n            c = s[i] <= prev ? ++c : 1;\\n            prev = s[i];\\n            h[i] = c > t;\\n        }\\n        vector<int> ans;\\n        for (int i = s.size() - 1, c = 0, prev = INT_MAX; i >= 0; --i) {\\n            c = abs(s[i] <= prev) ? ++c : 1;\\n            prev = abs(s[i]);\\n            if (c > t && h[i]) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493053,
                "title": "python3-clean-prefix-and-suffix-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        \\n        n=len(security)\\n        prefix=[0]\\n        \\n        for i in range(1,n):\\n            if security[i-1]>=security[i]:\\n                prefix.append(prefix[-1]+1)\\n            \\n            else:\\n                prefix.append(0)\\n        \\n        suffix=[0]\\n        \\n        for i in range(n-2,-1,-1):\\n            if security[i]<=security[i+1]:\\n                suffix.append(suffix[-1]+1)\\n            else:\\n                suffix.append(0)\\n        \\n        \\n        suffix.reverse()\\n        \\n        \\n        ans=[]\\n        \\n        for i in range(time,n-time):\\n            if prefix[i]>=time and suffix[i]>=time:\\n                ans.append(i)\\n    \\n        return ans\\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        \\n        n=len(security)\\n        prefix=[0]\\n        \\n        for i in range(1,n):\\n            if security[i-1]>=security[i]:\\n                prefix.append(prefix[-1]+1)\\n            \\n            else:\\n                prefix.append(0)\\n        \\n        suffix=[0]\\n        \\n        for i in range(n-2,-1,-1):\\n            if security[i]<=security[i+1]:\\n                suffix.append(suffix[-1]+1)\\n            else:\\n                suffix.append(0)\\n        \\n        \\n        suffix.reverse()\\n        \\n        \\n        ans=[]\\n        \\n        for i in range(time,n-time):\\n            if prefix[i]>=time and suffix[i]>=time:\\n                ans.append(i)\\n    \\n        return ans\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3482767,
                "title": "create-new-prefix-and-suffix-vector-and-comparing-w-given-vector",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n\\n        int n=security.size();\\n        vector<int>prefix(n,0);\\n        vector<int>sufix(n,0);\\n\\n        for(int i=1;i<n;i++){\\n            if(security[i-1]>=security[i]){\\n                prefix[i]=prefix[i-1]+1;\\n            }\\n        \\n        }\\n\\n        for(int i=n-2;i>=0;i--){\\n            if(security[i+1]>=security[i]){\\n                sufix[i]=sufix[i+1]+1;\\n            }\\n        }\\n        \\n        vector<int>ans;\\n\\n        for(int i=time;i<n-time;i++){\\n            if(prefix[i]>=time && sufix[i]>=time){\\n                ans.push_back(i);\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n\\n        int n=security.size();\\n        vector<int>prefix(n,0);\\n        vector<int>sufix(n,0);\\n\\n        for(int i=1;i<n;i++){\\n            if(security[i-1]>=security[i]){\\n                prefix[i]=prefix[i-1]+1;\\n            }\\n        \\n        }\\n\\n        for(int i=n-2;i>=0;i--){\\n            if(security[i+1]>=security[i]){\\n                sufix[i]=sufix[i+1]+1;\\n            }\\n        }\\n        \\n        vector<int>ans;\\n\\n        for(int i=time;i<n-time;i++){\\n            if(prefix[i]>=time && sufix[i]>=time){\\n                ans.push_back(i);\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449814,
                "title": "c-o-n-beats-97-commented-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& nums, int time) {\\n        int n=nums.size();\\n        if(n<=2*time) return {};\\n        vector<int> n_inc(n); // inc[i] stores the maximum size of subarray ending at i and is in non-incresing order; something like prefix \\n        vector<int> n_dec(n); // dec[i] stores the maximum size of subarray starting at i and is in non-decreasing order; something like suffixes\\n        vector<int> ans;\\n        int s=1;\\n        n_inc[0]=1;\\n        for(int i=1;i<n;i++){\\n            if(nums[i]>nums[i-1]){\\n                s=1;\\n                n_inc[i]=1;\\n            }\\n            else{\\n                n_inc[i]=++s;\\n            }\\n        }\\n        s=1;\\n        n_dec[n-1]=1;\\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i]>nums[i+1]){\\n                s=1;\\n                n_dec[i]=1;\\n            }\\n            else{\\n                n_dec[i]=++s;\\n            }\\n        }\\n        for(int i=time;i<n-time;i++){\\n            if(n_inc[i]>time && n_dec[i]>time){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& nums, int time) {\\n        int n=nums.size();\\n        if(n<=2*time) return {};\\n        vector<int> n_inc(n); // inc[i] stores the maximum size of subarray ending at i and is in non-incresing order; something like prefix \\n        vector<int> n_dec(n); // dec[i] stores the maximum size of subarray starting at i and is in non-decreasing order; something like suffixes\\n        vector<int> ans;\\n        int s=1;\\n        n_inc[0]=1;\\n        for(int i=1;i<n;i++){\\n            if(nums[i]>nums[i-1]){\\n                s=1;\\n                n_inc[i]=1;\\n            }\\n            else{\\n                n_inc[i]=++s;\\n            }\\n        }\\n        s=1;\\n        n_dec[n-1]=1;\\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i]>nums[i+1]){\\n                s=1;\\n                n_dec[i]=1;\\n            }\\n            else{\\n                n_dec[i]=++s;\\n            }\\n        }\\n        for(int i=time;i<n-time;i++){\\n            if(n_inc[i]>time && n_dec[i]>time){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436060,
                "title": "c-1d-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& x, int time) {\\n        int n = int(x.size());\\n        int dp1[n];\\n        dp1[0] = 1;\\n        for(int i = 1 ; i < n ; ++i){\\n            if(x[i] <= x[i-1]) dp1[i] = 1 + dp1[i-1];\\n            else dp1[i] = 1;\\n        }\\n        int dp2[n];\\n        dp2[n-1] = 1;\\n        for(int i = n - 2;  i >= 0 ; --i){\\n            if(x[i] <= x[i+1]) dp2[i] = 1 + dp2[i+1];\\n            else dp2[i] = 1;\\n        }\\n        vector<int> res;\\n        for(int i = 0 ; i < n ; ++i){\\n            if(i - time < 0 ) continue;\\n            if(i + time > (n-1)) continue;\\n            int a = dp1[i];\\n            int b = dp2[i];\\n            int want = time + 1 ;\\n            if(a >= want and b >= want) res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& x, int time) {\\n        int n = int(x.size());\\n        int dp1[n];\\n        dp1[0] = 1;\\n        for(int i = 1 ; i < n ; ++i){\\n            if(x[i] <= x[i-1]) dp1[i] = 1 + dp1[i-1];\\n            else dp1[i] = 1;\\n        }\\n        int dp2[n];\\n        dp2[n-1] = 1;\\n        for(int i = n - 2;  i >= 0 ; --i){\\n            if(x[i] <= x[i+1]) dp2[i] = 1 + dp2[i+1];\\n            else dp2[i] = 1;\\n        }\\n        vector<int> res;\\n        for(int i = 0 ; i < n ; ++i){\\n            if(i - time < 0 ) continue;\\n            if(i + time > (n-1)) continue;\\n            int a = dp1[i];\\n            int b = dp2[i];\\n            int want = time + 1 ;\\n            if(a >= want and b >= want) res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418344,
                "title": "c-complexity-time-space-o-n-o-1-without-additional-vectors",
                "content": "1. Using precalculations for the first day\\n2. For each next day, the number of days that do not increase and the number of days that do not decrease can be calculated by knowing them for the current day and the difference between them.\\n\\n# Complexity\\n- Time complexity: *O(n)*\\n- Space complexity: *O(1)*\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        vector<int> res;\\n        auto size = security.size();\\n\\n        // no day is good if the time is more than half of the entire range\\n        if (time >= (size + 1) / 2) return res;\\n\\n        // we count the number of descents before and\\n        // ascents after first of the potential days\\n        int before = time;\\n        for (size_t i = time; i > 0; i--)\\n            if (security[i] > security[i - 1]) {\\n                before = time - i;\\n                break;\\n            }\\n        int after = time;\\n        for (int i = time * 2; i > time; i--)\\n            if (security[i] < security[i - 1]) {\\n                after = time * 2 - i;\\n                break;\\n            }\\n        \\n        // cycle from the first to the penultimate of the potential days\\n        int end = size - time - 1;\\n        for (int l = time, r = time * 2; l < end; l++, r++) {\\n            // check the main condition\\n            if ((before >= time) and (after >= time)) res.push_back(l);\\n\\n            // we count the number of descents before and\\n            // ascents after for the next day\\n            if (security[r] > security[r+1]) after = 0;\\n            else                             after++;\\n\\n            if (security[l] < security[l + 1]) before = 0;\\n            else                               before++;\\n        }\\n        //check the condition for the last potential day\\n        if (before >= time and after >= time)\\n            res.push_back(size - time - 1);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        vector<int> res;\\n        auto size = security.size();\\n\\n        // no day is good if the time is more than half of the entire range\\n        if (time >= (size + 1) / 2) return res;\\n\\n        // we count the number of descents before and\\n        // ascents after first of the potential days\\n        int before = time;\\n        for (size_t i = time; i > 0; i--)\\n            if (security[i] > security[i - 1]) {\\n                before = time - i;\\n                break;\\n            }\\n        int after = time;\\n        for (int i = time * 2; i > time; i--)\\n            if (security[i] < security[i - 1]) {\\n                after = time * 2 - i;\\n                break;\\n            }\\n        \\n        // cycle from the first to the penultimate of the potential days\\n        int end = size - time - 1;\\n        for (int l = time, r = time * 2; l < end; l++, r++) {\\n            // check the main condition\\n            if ((before >= time) and (after >= time)) res.push_back(l);\\n\\n            // we count the number of descents before and\\n            // ascents after for the next day\\n            if (security[r] > security[r+1]) after = 0;\\n            else                             after++;\\n\\n            if (security[l] < security[l + 1]) before = 0;\\n            else                               before++;\\n        }\\n        //check the condition for the last potential day\\n        if (before >= time and after >= time)\\n            res.push_back(size - time - 1);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3336351,
                "title": "c-prefix-sum",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& nums, int time) {\\n        int n = nums.size();\\n        vector<int> ans;\\n        if(time==0)\\n        {\\n            for(int i=0;i<n;i++)\\n            ans.push_back(i);\\n            return ans;\\n        }\\n        vector<int> pref(n);\\n        vector<int> suff(n);\\n        pref[0] = 1;\\n        suff[n-1] = 1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]<=nums[i-1])\\n            pref[i] = pref[i-1]+1;\\n            else\\n            pref[i] = 1;\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(nums[i]<=nums[i+1])\\n            suff[i] = suff[i+1]+1;\\n            else\\n            suff[i] = 1;\\n        }\\n        for(int i=time;i<n-time;i++)\\n        {\\n            if(nums[i]<=nums[i-1] && nums[i]<=nums[i+1])\\n            {\\n                if(pref[i-1]>=time && suff[i+1]>=time)\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& nums, int time) {\\n        int n = nums.size();\\n        vector<int> ans;\\n        if(time==0)\\n        {\\n            for(int i=0;i<n;i++)\\n            ans.push_back(i);\\n            return ans;\\n        }\\n        vector<int> pref(n);\\n        vector<int> suff(n);\\n        pref[0] = 1;\\n        suff[n-1] = 1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]<=nums[i-1])\\n            pref[i] = pref[i-1]+1;\\n            else\\n            pref[i] = 1;\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(nums[i]<=nums[i+1])\\n            suff[i] = suff[i+1]+1;\\n            else\\n            suff[i] = 1;\\n        }\\n        for(int i=time;i<n-time;i++)\\n        {\\n            if(nums[i]<=nums[i-1] && nums[i]<=nums[i+1])\\n            {\\n                if(pref[i-1]>=time && suff[i+1]>=time)\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332420,
                "title": "python3-decreasing-and-increasing-stack-one-pass",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPrimer: I know there are other solution which solve this problem, by going through the stack two times from left and from right in order to count the increasing and decreasing days at a current point in time. That is totally valid and even better than my approach (less memory). I just wanted to present another approach to solving this problem.\\n\\nFrom the description we know that we need a non-increasing stack on the left and a non decreasing stack on the right side.\\n\\nwe update these stacks with every step in the array and check whether they have the expected length.\\n\\nOnce we introduce an element that does not adhere to the property (is increasing to the left and decreasing to the right), we clear the stacks and start new.\\n\\nas long as both stacks have the expected length of time+1 (with the element in the middle), we can add the index to the result.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMonotonic Stacks\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(time+1)\\n# Code\\n```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        \\n        # trivial case for a too short array\\n        result = []\\n        if len(security) < 2*time+1:\\n            return result\\n        if not time:\\n            return list(range(len(security)))\\n        \\n        # make a sliding window with decreasing stack at the left\\n        # and increasing stack at the right\\n        left = collections.deque()\\n        right = collections.deque()\\n        for idx in range(time+1):\\n            while right and right[-1] < security[idx]:\\n                right.pop()\\n            right.append(security[idx])\\n        # go through the elements\\n        for idx, ele in enumerate(security[:-time]):\\n\\n            # check pop from the stack as long as the left element\\n            # is smaller\\n            while left and len(left) >= time+1:\\n                left.popleft()\\n            if left and ele > left[-1]:\\n                left.clear()\\n            left.append(ele)\\n            \\n            # check whether both stacks have length time\\n            if len(left) == time+1 and len(right) == time+1:\\n                result.append(idx)\\n            if idx == len(security)-time-1:\\n                break\\n\\n            # steal from the right side\\n            while right and len(right) >= time+1:\\n                right.popleft()\\n            if right and security[idx+time+1] < right[-1]:\\n                right.clear()\\n            right.append(security[idx+time+1])\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        \\n        # trivial case for a too short array\\n        result = []\\n        if len(security) < 2*time+1:\\n            return result\\n        if not time:\\n            return list(range(len(security)))\\n        \\n        # make a sliding window with decreasing stack at the left\\n        # and increasing stack at the right\\n        left = collections.deque()\\n        right = collections.deque()\\n        for idx in range(time+1):\\n            while right and right[-1] < security[idx]:\\n                right.pop()\\n            right.append(security[idx])\\n        # go through the elements\\n        for idx, ele in enumerate(security[:-time]):\\n\\n            # check pop from the stack as long as the left element\\n            # is smaller\\n            while left and len(left) >= time+1:\\n                left.popleft()\\n            if left and ele > left[-1]:\\n                left.clear()\\n            left.append(ele)\\n            \\n            # check whether both stacks have length time\\n            if len(left) == time+1 and len(right) == time+1:\\n                result.append(idx)\\n            if idx == len(security)-time-1:\\n                break\\n\\n            # steal from the right side\\n            while right and len(right) >= time+1:\\n                right.popleft()\\n            if right and security[idx+time+1] < right[-1]:\\n                right.clear()\\n            right.append(security[idx+time+1])\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327168,
                "title": "c-easy-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n=security.size();\\n        vector<int> ans;\\n        if(time==0)\\n        {\\n            for(int i=0;i<n;i++)\\n            ans.push_back(i);\\n            return ans;\\n        }\\n        vector<int> left(n,0);\\n        vector<int> right(n,0);\\n        \\n        left[0]=1;\\n        int curr=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(security[i]<=security[i-1])\\n            {\\n                curr++;\\n                left[i]=curr;\\n            }\\n            else\\n            {\\n                curr=1;\\n                left[i]=curr;\\n            }\\n        }\\n\\n        right[n-1]=1;\\n        curr=1;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(security[i]<=security[i+1])\\n            {\\n                curr++;\\n                right[i]=curr;\\n            }\\n            else\\n            {\\n                curr=1;\\n                right[i]=curr;\\n            }\\n        }\\n        \\n        for(int i=time;i<n-time;i++)\\n        {\\n            if((left[i]-left[i-time]>=time) and (right[i]-right[i+time]>=time))\\n            {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n=security.size();\\n        vector<int> ans;\\n        if(time==0)\\n        {\\n            for(int i=0;i<n;i++)\\n            ans.push_back(i);\\n            return ans;\\n        }\\n        vector<int> left(n,0);\\n        vector<int> right(n,0);\\n        \\n        left[0]=1;\\n        int curr=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(security[i]<=security[i-1])\\n            {\\n                curr++;\\n                left[i]=curr;\\n            }\\n            else\\n            {\\n                curr=1;\\n                left[i]=curr;\\n            }\\n        }\\n\\n        right[n-1]=1;\\n        curr=1;\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(security[i]<=security[i+1])\\n            {\\n                curr++;\\n                right[i]=curr;\\n            }\\n            else\\n            {\\n                curr=1;\\n                right[i]=curr;\\n            }\\n        }\\n        \\n        for(int i=time;i<n-time;i++)\\n        {\\n            if((left[i]-left[i-time]>=time) and (right[i]-right[i+time]>=time))\\n            {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316551,
                "title": "rust-elixir-with-2-counters",
                "content": "No extra space used for Rust. O(n) space for Elixir due to Enum functions.\\n# Code\\n```rust []\\nimpl Solution {\\n    pub fn good_days_to_rob_bank(security: Vec<i32>, time: i32) -> Vec<i32> {\\n        if time == 0 {\\n            return (0..security.len() as i32).collect();\\n        }\\n        let time = time as usize;\\n        let mut incr = 0;\\n        let mut decr = 0;\\n        let mut ans = Vec::new();\\n        for i in 1 + time..security.len() {\\n            if security[i - time] <= security[i - time - 1] {\\n                decr += 1;\\n            }\\n            else {\\n                decr = 0;\\n            }\\n            if security[i] >= security[i - 1] {\\n                incr += 1;\\n            }\\n            else {\\n                incr = 0;\\n            }\\n            if incr >= time && decr >= time {\\n                ans.push((i - time) as i32);\\n            }\\n        }\\n        ans\\n    }\\n}\\n```\\n```Elixir []\\ndefmodule Solution do\\n  @spec good_days_to_rob_bank(security :: [integer], time :: integer) :: [integer]\\n  def good_days_to_rob_bank(security, 0), do: Enum.to_list(0..length(security) - 1)\\n  def good_days_to_rob_bank(security, time) do\\n    Enum.drop(security, time)\\n    |> count_order(&Kernel.<=/2)\\n    |> Enum.zip(\\n      count_order(security, &Kernel.>=/2)\\n    )\\n    |> Enum.with_index(1)\\n    |> Enum.flat_map(fn {{incr, decr}, i} ->\\n      if incr >= time and decr >= time, do: [i], else: []\\n    end)\\n  end\\n\\n  defp count_order(list, fun) do\\n    Enum.chunk_every(list, 2, 1, :discard)\\n    |> Enum.map_reduce(0, fn [x, y], acc ->\\n      if fun.(x, y) do\\n        {acc + 1, acc + 1}\\n      else\\n        {0, 0}\\n      end\\n    end)\\n    |> elem(0)\\n  end\\nend\\n```",
                "solutionTags": [
                    "Rust",
                    "Elixir"
                ],
                "code": "```rust []\\nimpl Solution {\\n    pub fn good_days_to_rob_bank(security: Vec<i32>, time: i32) -> Vec<i32> {\\n        if time == 0 {\\n            return (0..security.len() as i32).collect();\\n        }\\n        let time = time as usize;\\n        let mut incr = 0;\\n        let mut decr = 0;\\n        let mut ans = Vec::new();\\n        for i in 1 + time..security.len() {\\n            if security[i - time] <= security[i - time - 1] {\\n                decr += 1;\\n            }\\n            else {\\n                decr = 0;\\n            }\\n            if security[i] >= security[i - 1] {\\n                incr += 1;\\n            }\\n            else {\\n                incr = 0;\\n            }\\n            if incr >= time && decr >= time {\\n                ans.push((i - time) as i32);\\n            }\\n        }\\n        ans\\n    }\\n}\\n```\n```Elixir []\\ndefmodule Solution do\\n  @spec good_days_to_rob_bank(security :: [integer], time :: integer) :: [integer]\\n  def good_days_to_rob_bank(security, 0), do: Enum.to_list(0..length(security) - 1)\\n  def good_days_to_rob_bank(security, time) do\\n    Enum.drop(security, time)\\n    |> count_order(&Kernel.<=/2)\\n    |> Enum.zip(\\n      count_order(security, &Kernel.>=/2)\\n    )\\n    |> Enum.with_index(1)\\n    |> Enum.flat_map(fn {{incr, decr}, i} ->\\n      if incr >= time and decr >= time, do: [i], else: []\\n    end)\\n  end\\n\\n  defp count_order(list, fun) do\\n    Enum.chunk_every(list, 2, 1, :discard)\\n    |> Enum.map_reduce(0, fn [x, y], acc ->\\n      if fun.(x, y) do\\n        {acc + 1, acc + 1}\\n      else\\n        {0, 0}\\n      end\\n    end)\\n    |> elem(0)\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3315355,
                "title": "java-dp-prefix-suffix-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int n = security.length;\\n        int[] prefix = new int[n];\\n        int[] suffix = new int[n];\\n        prefix[0] = 0;\\n        for(int i = 1; i < n; i++) {\\n            if(security[i] <= security[i - 1])\\n                prefix[i] = 1 + prefix[i - 1];\\n            else\\n                prefix[i] = 0;\\n        }\\n        for(int i = n - 2; i >= 0; i--) {\\n            if(security[i] <= security[i + 1])\\n                suffix[i] = 1 + suffix[i + 1];\\n            else \\n                suffix[i] = 0;\\n        }\\n        List<Integer> list = new ArrayList();\\n        for(int i = time; i < n - time; i++) {\\n            if(prefix[i] >= time && suffix[i] >= time)\\n                list.add(i);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int n = security.length;\\n        int[] prefix = new int[n];\\n        int[] suffix = new int[n];\\n        prefix[0] = 0;\\n        for(int i = 1; i < n; i++) {\\n            if(security[i] <= security[i - 1])\\n                prefix[i] = 1 + prefix[i - 1];\\n            else\\n                prefix[i] = 0;\\n        }\\n        for(int i = n - 2; i >= 0; i--) {\\n            if(security[i] <= security[i + 1])\\n                suffix[i] = 1 + suffix[i + 1];\\n            else \\n                suffix[i] = 0;\\n        }\\n        List<Integer> list = new ArrayList();\\n        for(int i = time; i < n - time; i++) {\\n            if(prefix[i] >= time && suffix[i] >= time)\\n                list.add(i);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293867,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        auto vl = leftGood(security, time);\\n        reverse(security.begin(), security.end());\\n        auto vr = leftGood(security, time);\\n        reverse(vr.begin(), vr.end());\\n        vector<int> res;\\n        for(int i=0;i<vr.size();i++){\\n            if(vl[i] && vr[i]) res.push_back(i);\\n        }\\n        return res;\\n    }\\n\\n    vector<bool> leftGood(vector<int>& v, int t){\\n        int cnt = 0;\\n        vector<bool> res;\\n        for(int i=0;i<v.size();i++){\\n            if(i>0){\\n                if(v[i] <= v[i-1]) cnt++;\\n                else cnt = 0; \\n            }\\n            res.push_back(cnt >= t);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        auto vl = leftGood(security, time);\\n        reverse(security.begin(), security.end());\\n        auto vr = leftGood(security, time);\\n        reverse(vr.begin(), vr.end());\\n        vector<int> res;\\n        for(int i=0;i<vr.size();i++){\\n            if(vl[i] && vr[i]) res.push_back(i);\\n        }\\n        return res;\\n    }\\n\\n    vector<bool> leftGood(vector<int>& v, int t){\\n        int cnt = 0;\\n        vector<bool> res;\\n        for(int i=0;i<v.size();i++){\\n            if(i>0){\\n                if(v[i] <= v[i-1]) cnt++;\\n                else cnt = 0; \\n            }\\n            res.push_back(cnt >= t);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291667,
                "title": "java-dp-o-n-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\n     public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int[] leftToRightDecreasing=new int[security.length];\\n        int[] rightToLeftIncreasing=new int[security.length];\\n        for (int i=1;i<security.length;i++){\\n            if(security[i]<=security[i-1]){\\n                leftToRightDecreasing[i]=leftToRightDecreasing[i-1]+1;\\n            }\\n        }\\n        for (int i=security.length-2;i>=0;i--){\\n            if(security[i]<=security[i+1]){\\n                rightToLeftIncreasing[i]=rightToLeftIncreasing[i+1]+1;\\n            }\\n        }\\n        List<Integer> list=new ArrayList<>();\\n        for (int i=time;i<security.length-time;i++){\\n            if(rightToLeftIncreasing[i]>=time && leftToRightDecreasing[i]>=time){\\n                list.add(i);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n     public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int[] leftToRightDecreasing=new int[security.length];\\n        int[] rightToLeftIncreasing=new int[security.length];\\n        for (int i=1;i<security.length;i++){\\n            if(security[i]<=security[i-1]){\\n                leftToRightDecreasing[i]=leftToRightDecreasing[i-1]+1;\\n            }\\n        }\\n        for (int i=security.length-2;i>=0;i--){\\n            if(security[i]<=security[i+1]){\\n                rightToLeftIncreasing[i]=rightToLeftIncreasing[i+1]+1;\\n            }\\n        }\\n        List<Integer> list=new ArrayList<>();\\n        for (int i=time;i<security.length-time;i++){\\n            if(rightToLeftIncreasing[i]>=time && leftToRightDecreasing[i]>=time){\\n                list.add(i);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278074,
                "title": "javascript-beats-100",
                "content": "# Code\\n```\\nvar goodDaysToRobBank = function(security, time) {\\n    let days=[];\\n    let check=true;\\n        for(let i=time;i<security.length-time;i++){\\n            for(let j=i-time;j<i;j++){\\n                if(security[j]<security[j+1]){\\n                    check=false;break\\n                }\\n            }\\n            if(check){\\n            for(let j=i;j<time+i;j++){\\n                if(security[j]>security[j+1]){\\n                    check=false;break\\n                }\\n            } \\n            if(check){days.push(i)}\\n            }\\n            check=true\\n        }\\n    return days\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar goodDaysToRobBank = function(security, time) {\\n    let days=[];\\n    let check=true;\\n        for(let i=time;i<security.length-time;i++){\\n            for(let j=i-time;j<i;j++){\\n                if(security[j]<security[j+1]){\\n                    check=false;break\\n                }\\n            }\\n            if(check){\\n            for(let j=i;j<time+i;j++){\\n                if(security[j]>security[j+1]){\\n                    check=false;break\\n                }\\n            } \\n            if(check){days.push(i)}\\n            }\\n            check=true\\n        }\\n    return days\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3275886,
                "title": "o-n-single-scan-single-dp-array-scala-explained",
                "content": "# Intuition\\nThis problem can be solved with prefix and suffix arrays: just scan left to right and right to left annotating the positions where the previous *time* values in security were monotonically increasing / decreasing.\\nThen match the positions where both prefix and suffix arrays satisfy the requirements.\\nThis solution has linear complexity O(3n).\\nThere\\'s no need, though to do it in three passages: it can be done in a single one.\\n\\n\\n# Approach\\nThe algorithm goes as this:\\n* if the security array is not large enough to account for pre and post observations, then it\\'s a trivial empty answer\\n* otherwise, allocate an array *dp* where we\\'ll store how many favourable conditions have we measured: this will be 0 for no conditions, 1 for either pre or post and 2 for both of them.\\n* keep the head of the result list in *result*. We\\'ll prepend each day to it to keep complexity O(1)\\n* scan left to right on i and keep count of the consecutive non-increasing days: if an increase is detected, reset the counter. Do the same from the right end.\\n* if days from left are greater or equal than the *time* threshold, increase the count in *dp*. If the count has reached 2, it means this day is a good one: add it to the result\\n* do the same for the right side\\n* return the *result* list\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nobject Solution {\\n    def goodDaysToRobBank(security: Array[Int], time: Int): List[Int] = {\\n        if (security.length < time * 2 + 1) {\\n            List.empty\\n        } else {\\n            val dp = Array.ofDim[Int](security.length) \\n            var pre = 0\\n            var post = 0\\n            var result = List.empty[Int]\\n            (0 until security.length).foreach { i =>\\n                if (i > 0 && security(i) <= security(i - 1)) {\\n                    pre += 1\\n                } else {\\n                    pre = 0\\n                }\\n                if (i > 0 && security(security.length - i - 1) <= security(security.length - i)) {\\n                    post += 1\\n                } else {\\n                    post = 0\\n                }\\n                if (pre >= time) {\\n                    dp(i) += 1\\n                    if (dp(i) == 2) {\\n                        result = i :: result\\n                    }\\n                }\\n                if (post >= time) {\\n                    dp(security.length - 1 - i) += 1\\n                    if (dp(security.length - 1 - i) == 2) {\\n                        result = (security.length - 1 - i) :: result\\n                    }\\n                }\\n            }\\n            result\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def goodDaysToRobBank(security: Array[Int], time: Int): List[Int] = {\\n        if (security.length < time * 2 + 1) {\\n            List.empty\\n        } else {\\n            val dp = Array.ofDim[Int](security.length) \\n            var pre = 0\\n            var post = 0\\n            var result = List.empty[Int]\\n            (0 until security.length).foreach { i =>\\n                if (i > 0 && security(i) <= security(i - 1)) {\\n                    pre += 1\\n                } else {\\n                    pre = 0\\n                }\\n                if (i > 0 && security(security.length - i - 1) <= security(security.length - i)) {\\n                    post += 1\\n                } else {\\n                    post = 0\\n                }\\n                if (pre >= time) {\\n                    dp(i) += 1\\n                    if (dp(i) == 2) {\\n                        result = i :: result\\n                    }\\n                }\\n                if (post >= time) {\\n                    dp(security.length - 1 - i) += 1\\n                    if (dp(security.length - 1 - i) == 2) {\\n                        result = (security.length - 1 - i) :: result\\n                    }\\n                }\\n            }\\n            result\\n        }\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3269493,
                "title": "simple-java-solution-o-n",
                "content": "# Approach\\nUse extra space to store increasing order of left->right and right->left\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] a, int time) {\\n        \\n        int n = a.length;\\n        int[] left = new int[n];\\n        int[] right = new int[n];\\n\\n        for(int i=1;i<n;i++){\\n            if(a[i]<=a[i-1]){\\n                left[i]=1+left[i-1]; \\n            }\\n        }\\n\\n        for(int i=n-2;i>=0;i--){\\n            if(a[i]<=a[i+1]){\\n                right[i]=1+right[i+1];\\n            }\\n        }\\n        List<Integer> result = new ArrayList<>();\\n        for(int i=time;i<n-time;i++){\\n            if(left[i]>=time && right[i]>=time) {\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] a, int time) {\\n        \\n        int n = a.length;\\n        int[] left = new int[n];\\n        int[] right = new int[n];\\n\\n        for(int i=1;i<n;i++){\\n            if(a[i]<=a[i-1]){\\n                left[i]=1+left[i-1]; \\n            }\\n        }\\n\\n        for(int i=n-2;i>=0;i--){\\n            if(a[i]<=a[i+1]){\\n                right[i]=1+right[i+1];\\n            }\\n        }\\n        List<Integer> result = new ArrayList<>();\\n        for(int i=time;i<n-time;i++){\\n            if(left[i]>=time && right[i]>=time) {\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224582,
                "title": "python-o-n-with-only-1-loop-through-the-security-list-speed-95-3-times-submits-values",
                "content": "Idea is quite similar to https://leetcode.com/problems/find-good-days-to-rob-the-bank/discuss/1623415/Python-Explanation-with-pictures-prefix-sum. but instead of 2 x loop, this solution is using 1 x loop hence better speed result.\\n```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        if len(security)<2*time+1:\\n            return []\\n        \\n        l=0\\n        for i in range(time-1,-1,-1):\\n            if security[i+1]<=security[i]:\\n                l+=1\\n            else:\\n                break\\n        r=0\\n        for i in range(time-1,-1,-1):\\n            if security[time+i+1]>=security[time+i]:\\n                r+=1\\n            else:\\n                break\\n        ans=[]\\n        if l==time and r==time:\\n            ans.append(time)\\n            \\n        for p in range(time+1,len(security)-time):\\n            if security[p]<=security[p-1]:\\n                l=min(time, l+1)\\n            else:\\n                l=0\\n            if security[p+time]>=security[p+time-1]:\\n                r=min(time, r+1)\\n            else:\\n                r=0\\n            if l==time and r==time:\\n                ans.append(p)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        if len(security)<2*time+1:\\n            return []\\n        \\n        l=0\\n        for i in range(time-1,-1,-1):\\n            if security[i+1]<=security[i]:\\n                l+=1\\n            else:\\n                break\\n        r=0\\n        for i in range(time-1,-1,-1):\\n            if security[time+i+1]>=security[time+i]:\\n                r+=1\\n            else:\\n                break\\n        ans=[]\\n        if l==time and r==time:\\n            ans.append(time)\\n            \\n        for p in range(time+1,len(security)-time):\\n            if security[p]<=security[p-1]:\\n                l=min(time, l+1)\\n            else:\\n                l=0\\n            if security[p+time]>=security[p+time-1]:\\n                r=min(time, r+1)\\n            else:\\n                r=0\\n            if l==time and r==time:\\n                ans.append(p)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3210056,
                "title": "easy-solution-in-c-prefix-suffix",
                "content": "# Complexity\\n- Time complexity:\\n**O(n)**\\n\\n- Space complexity:\\n**O(n)**\\n\\n# Code\\n### **Please Upvote if u liked my Solution**\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n=security.size(),j=0;\\n        vector<int> ans,prefix(n),suffix(n);\\n        for(int i=1;i<n;i++){\\n            j++;\\n            if(security[i]<=security[i-1])\\n                prefix[i]=j;\\n            else{\\n                j=0;\\n                prefix[i]=j;\\n            } \\n        }\\n        j=0;\\n        for(int i=n-2;i>=0;i--){\\n            j++;\\n            if(security[i]<=security[i+1])\\n                suffix[i]=j;\\n            else{\\n                j=0;\\n                suffix[i]=j;\\n            } \\n        }\\n        for(int i=0;i<n;i++)\\n            if(prefix[i]>=time && suffix[i]>=time)\\n                ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        int n=security.size(),j=0;\\n        vector<int> ans,prefix(n),suffix(n);\\n        for(int i=1;i<n;i++){\\n            j++;\\n            if(security[i]<=security[i-1])\\n                prefix[i]=j;\\n            else{\\n                j=0;\\n                prefix[i]=j;\\n            } \\n        }\\n        j=0;\\n        for(int i=n-2;i>=0;i--){\\n            j++;\\n            if(security[i]<=security[i+1])\\n                suffix[i]=j;\\n            else{\\n                j=0;\\n                suffix[i]=j;\\n            } \\n        }\\n        for(int i=0;i<n;i++)\\n            if(prefix[i]>=time && suffix[i]>=time)\\n                ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207634,
                "title": "easy-faster-efficient-java-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int n = security.length;\\n        int [] left = new int[n];\\n        int [] right = new int[n];\\n        left[0] = 0;\\n        for(int i = 1; i < n; i++){\\n            if(security[i - 1] >= security[i]){\\n                left[i] = left[i - 1] + 1;\\n            } else {\\n                left[i] = 0;\\n            }\\n        }\\n        right[n - 1] = 0;\\n        for(int i = n - 2; i >= 0; i--){\\n            if(security[i + 1] >= security[i]){\\n                right[i] = right[i + 1] + 1;\\n            } else{\\n                right[i] = 0;\\n            }\\n        }\\n        List<Integer> al = new ArrayList<>();\\n        for(int i = 0; i < n; i++){\\n            if(left[i] >= time && right[i] >= time){\\n                al.add(i);\\n            }\\n        }\\n        return al;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int n = security.length;\\n        int [] left = new int[n];\\n        int [] right = new int[n];\\n        left[0] = 0;\\n        for(int i = 1; i < n; i++){\\n            if(security[i - 1] >= security[i]){\\n                left[i] = left[i - 1] + 1;\\n            } else {\\n                left[i] = 0;\\n            }\\n        }\\n        right[n - 1] = 0;\\n        for(int i = n - 2; i >= 0; i--){\\n            if(security[i + 1] >= security[i]){\\n                right[i] = right[i + 1] + 1;\\n            } else{\\n                right[i] = 0;\\n            }\\n        }\\n        List<Integer> al = new ArrayList<>();\\n        for(int i = 0; i < n; i++){\\n            if(left[i] >= time && right[i] >= time){\\n                al.add(i);\\n            }\\n        }\\n        return al;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3179552,
                "title": "prefix-suffix-array-very-simple-c",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) \\n    {\\n        int n=security.size();\\n        vector<int> before(n,0), after(n,0);\\n        for(int x=1; x<n; x++)\\n        {\\n            if(security[x-1]>=security[x])\\n            {\\n                before[x]=1+before[x-1];\\n            }\\n        }\\n        for(int x=n-2; x>=0; x--)\\n        {\\n            if(security[x]<=security[x+1])\\n            {\\n                after[x]=1+after[x+1];\\n            }\\n        }\\n        vector<int> ans;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(after[x]>=time && before[x]>=time) ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) \\n    {\\n        int n=security.size();\\n        vector<int> before(n,0), after(n,0);\\n        for(int x=1; x<n; x++)\\n        {\\n            if(security[x-1]>=security[x])\\n            {\\n                before[x]=1+before[x-1];\\n            }\\n        }\\n        for(int x=n-2; x>=0; x--)\\n        {\\n            if(security[x]<=security[x+1])\\n            {\\n                after[x]=1+after[x+1];\\n            }\\n        }\\n        vector<int> ans;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(after[x]>=time && before[x]>=time) ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3122452,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) \\n    {\\n        int n=security.size();\\n        vector<int>pre(n,0);\\n        vector<int>after(n,0);\\n        int prev=INT_MIN;\\n        int cnt=0;\\n        for (int i=0;i<n;i++)\\n        {\\n           if (security[i]<=prev)\\n           {\\n               cnt++;\\n               pre[i]=cnt;\\n           }\\n           else{\\n               cnt=0;\\n               pre[i]=cnt;\\n           }\\n           prev=security[i];\\n        }\\n        prev=INT_MIN;\\n        for (int i=n-1;i>=0;i--)\\n        {\\n           if(security[i]<=prev)\\n           {\\n               cnt++;\\n               after[i]=cnt;\\n           }\\n           else{\\n               cnt=0;;\\n               after[i]=cnt;\\n           }\\n           prev=security[i];\\n        }\\n        vector<int>ans;\\n        for (int i=0;i<n;i++)\\n        {\\n            if (pre[i]>=time && after[i]>=time)\\n            {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) \\n    {\\n        int n=security.size();\\n        vector<int>pre(n,0);\\n        vector<int>after(n,0);\\n        int prev=INT_MIN;\\n        int cnt=0;\\n        for (int i=0;i<n;i++)\\n        {\\n           if (security[i]<=prev)\\n           {\\n               cnt++;\\n               pre[i]=cnt;\\n           }\\n           else{\\n               cnt=0;\\n               pre[i]=cnt;\\n           }\\n           prev=security[i];\\n        }\\n        prev=INT_MIN;\\n        for (int i=n-1;i>=0;i--)\\n        {\\n           if(security[i]<=prev)\\n           {\\n               cnt++;\\n               after[i]=cnt;\\n           }\\n           else{\\n               cnt=0;;\\n               after[i]=cnt;\\n           }\\n           prev=security[i];\\n        }\\n        vector<int>ans;\\n        for (int i=0;i<n;i++)\\n        {\\n            if (pre[i]>=time && after[i]>=time)\\n            {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3114561,
                "title": "c-easy-dp-solution",
                "content": "We use to DP vector.\\nOne vector to keep the number of days that is non-increasing  before ith day.\\nThe other one keep the number of days that is non-decreasing after the ith day.\\nThen we check from [time, N-time]\\n\\n\\'\\'\\'\\n\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        vector<int> res;\\n        int N = security.size();\\n        vector<int> nonInc(N,0);\\n        vector<int> nonDec(N,0);\\n        for (int i=1; i<N; i++) {\\n            if (security[i-1]>=security[i]) {\\n                nonInc[i] = nonInc[i-1]+1;\\n            }\\n        }\\n        for (int i=N-1; i>0; i--) {\\n            if (security[i]>=security[i-1]) {\\n                nonDec[i-1] = nonDec[i]+1;\\n            }\\n        }\\n        \\n        for (int i=time; i<N-time; i++) {\\n            if (nonInc[i]>=time && nonDec[i]>=time) {\\n                res.push_back(i);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "We use to DP vector.\\nOne vector to keep the number of days that is non-increasing  before ith day.\\nThe other one keep the number of days that is non-decreasing after the ith day.\\nThen we check from [time, N-time]\\n\\n\\'\\'\\'\\n\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        vector<int> res;\\n        int N = security.size();\\n        vector<int> nonInc(N,0);\\n        vector<int> nonDec(N,0);\\n        for (int i=1; i<N; i++) {\\n            if (security[i-1]>=security[i]) {\\n                nonInc[i] = nonInc[i-1]+1;\\n            }\\n        }\\n        for (int i=N-1; i>0; i--) {\\n            if (security[i]>=security[i-1]) {\\n                nonDec[i-1] = nonDec[i]+1;\\n            }\\n        }\\n        \\n        for (int i=time; i<N-time; i++) {\\n            if (nonInc[i]>=time && nonDec[i]>=time) {\\n                res.push_back(i);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 3106410,
                "title": "python-greedy-method-easy-code-and-solution-3-pass",
                "content": "# Intuition\\nbased on the requirement. Loop the array from left to right to see the increasement sequence length. and do the similar from right to left.\\nThen loop the sequence position, find the position meet min(left,right)>=time.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$O(n)$\\n\\n- Space complexity:\\n$O(n)$\\n\\n# Code\\n```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        if time ==0:\\n            return list(range(len(security)))\\n        left =[0]*len(security)\\n        right =[0]*len(security)\\n        for i in range(1,len(security)):\\n            if security[i]<=security[i-1]:\\n                left[i]=left[i-1]+1\\n        for i in range(len(security)-2,0,-1):\\n            if security[i]<=security[i+1]:\\n                right[i]=right[i+1]+1\\n        res = []\\n        for i,j in enumerate(security):\\n            if min(left[i],right[i])>=time:\\n                res.append(i)\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        if time ==0:\\n            return list(range(len(security)))\\n        left =[0]*len(security)\\n        right =[0]*len(security)\\n        for i in range(1,len(security)):\\n            if security[i]<=security[i-1]:\\n                left[i]=left[i-1]+1\\n        for i in range(len(security)-2,0,-1):\\n            if security[i]<=security[i+1]:\\n                right[i]=right[i+1]+1\\n        res = []\\n        for i,j in enumerate(security):\\n            if min(left[i],right[i])>=time:\\n                res.append(i)\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090798,
                "title": "python-o-n-pre-caching-data",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def goodDaysToRobBank(self, s: List[int], time: int) -> List[int]:\\n        @cache\\n        def count_left(cur):\\n            if cur == 0:\\n                return 0\\n\\n            if s[cur-1] >= s[cur]:\\n                return 1 + count_left(cur-1)\\n\\n            return 0\\n\\n        @cache\\n        def count_right(cur):\\n            if cur == len(s) - 1:\\n                return 0\\n\\n            if s[cur+1] >= s[cur]:\\n                return 1 + count_right(cur+1)\\n\\n            return 0\\n\\n        # precaching data\\n        count_left(0) # O(n)\\n        count_right(len(s)-1) # O(n)\\n\\n        ans = []\\n        for i in range(len(s)):\\n            left = count_left(i) # O(1)\\n            right = count_right(i) # O(1)\\n            if left >= time and right >= time:\\n                ans.append(i)\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, s: List[int], time: int) -> List[int]:\\n        @cache\\n        def count_left(cur):\\n            if cur == 0:\\n                return 0\\n\\n            if s[cur-1] >= s[cur]:\\n                return 1 + count_left(cur-1)\\n\\n            return 0\\n\\n        @cache\\n        def count_right(cur):\\n            if cur == len(s) - 1:\\n                return 0\\n\\n            if s[cur+1] >= s[cur]:\\n                return 1 + count_right(cur+1)\\n\\n            return 0\\n\\n        # precaching data\\n        count_left(0) # O(n)\\n        count_right(len(s)-1) # O(n)\\n\\n        ans = []\\n        for i in range(len(s)):\\n            left = count_left(i) # O(1)\\n            right = count_right(i) # O(1)\\n            if left >= time and right >= time:\\n                ans.append(i)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090349,
                "title": "java-o-n-easy-solution-with-explanation",
                "content": "Thoughts:\\n* use a 2D array to store: days before and days after\\n* We only care about the neighboring elements security[i-1] and security[i+1] because when i = i-1, we also check security[i-2] and security[i]\\n\\tExample: If we want to know how many non-increasing days before ith day\\n\\t\\t\\t\\t\\tWe will check security[i-1] ... security[0]\\n\\t\\t\\t\\t\\tBut for security[i-1], we also checked security[i-2] ... security[0]\\n\\t\\t\\t\\t\\tThus, for security[i]  = security[i-1] (The num of non-increasing days at i-1th day) +1\\n* Finally, check if the **non-increasing days before ith day** and **non-decreasing days after ith day** is >= time.\\n\\n\\n\\n```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        List<Integer> result = new ArrayList<>();\\n        int[][] prePost = new int[security.length][2];\\n        int daysBefore = 0;\\n        //get the num of days before i days\\n        for(int i = 1; i < security.length ; i++){\\n            if(security[i-1] >= security[i]){\\n                daysBefore++;\\n            }else{\\n                daysBefore = 0;\\n            }\\n            prePost[i][0] = daysBefore;\\n        }\\n        \\n        //get the num of days after i days\\n        int daysAfter = 0;\\n        for(int i = security.length-2; i>=0 ; i--){\\n            if(security[i] <= security[i+1]){\\n                daysAfter++;\\n            }else{\\n                daysAfter = 0;\\n            }\\n            prePost[i][1] = daysAfter;\\n        }\\n        \\n        for(int i = 0 ; i < prePost.length ; i++){\\n            if(prePost[i][0] >= time && prePost[i][1] >= time){\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        List<Integer> result = new ArrayList<>();\\n        int[][] prePost = new int[security.length][2];\\n        int daysBefore = 0;\\n        //get the num of days before i days\\n        for(int i = 1; i < security.length ; i++){\\n            if(security[i-1] >= security[i]){\\n                daysBefore++;\\n            }else{\\n                daysBefore = 0;\\n            }\\n            prePost[i][0] = daysBefore;\\n        }\\n        \\n        //get the num of days after i days\\n        int daysAfter = 0;\\n        for(int i = security.length-2; i>=0 ; i--){\\n            if(security[i] <= security[i+1]){\\n                daysAfter++;\\n            }else{\\n                daysAfter = 0;\\n            }\\n            prePost[i][1] = daysAfter;\\n        }\\n        \\n        for(int i = 0 ; i < prePost.length ; i++){\\n            if(prePost[i][0] >= time && prePost[i][1] >= time){\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3077247,
                "title": "simple-java-solution-with-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int len = security.length;\\n        int left[] = new int[len];\\n        int right[] = new int[len];\\n        List<Integer> res = new ArrayList<>();\\n        for(int i = 1; i < len; i++){\\n            if(security[i] <= security[i-1]){\\n                left[i] = left[i-1]+1;\\n            }\\n        }\\n\\n        for(int i = len - 2; i >= 0; i--){\\n            if(security[i] <= security[i+1]){\\n                right[i] = right[i+1]+1;\\n            }\\n        }\\n        for(int i = 0; i < len; i++){\\n            if(left[i] >= time && right[i]>=time){\\n                res.add(i);\\n            }    \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int len = security.length;\\n        int left[] = new int[len];\\n        int right[] = new int[len];\\n        List<Integer> res = new ArrayList<>();\\n        for(int i = 1; i < len; i++){\\n            if(security[i] <= security[i-1]){\\n                left[i] = left[i-1]+1;\\n            }\\n        }\\n\\n        for(int i = len - 2; i >= 0; i--){\\n            if(security[i] <= security[i+1]){\\n                right[i] = right[i+1]+1;\\n            }\\n        }\\n        for(int i = 0; i < len; i++){\\n            if(left[i] >= time && right[i]>=time){\\n                res.add(i);\\n            }    \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3077150,
                "title": "python-dp-solution",
                "content": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        n = len(security)\\n        right = [False] * n\\n        left = [False] * n\\n        res = []\\n\\n        cur_False = [True] * n\\n        total_False = 0\\n        for i in range(1,n):\\n            if security[i] > security[i-1]:\\n                if i <= time:\\n                    total_False += 1\\n                cur_False[i] = False\\n                \\n        for i in range(time,n):\\n            if total_False == 0:left[i] = True\\n            \\n            if i == n-1:continue\\n            if cur_False[i-(time-1)] == False:total_False -= 1\\n            if cur_False[i+1] == False: total_False += 1\\n            \\n        cur_False = [True] * n\\n        total_False = 0\\n        for i in range(n-2,-1,-1):\\n            if security[i] > security[i+1]:\\n                if n-1-time <= i:total_False += 1\\n                cur_False[i] = False\\n                \\n        for i in range(n-1-time,-1,-1):\\n            if total_False == 0:right[i] = True\\n            \\n            if i == 1:continue\\n            if cur_False[i+(time-1)] == False:total_False -= 1\\n            if cur_False[i-1] == False: total_False += 1\\n            \\n        for i in range(n):\\n            if left[i] and right[i]:\\n                res.append(i)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        n = len(security)\\n        right = [False] * n\\n        left = [False] * n\\n        res = []\\n\\n        cur_False = [True] * n\\n        total_False = 0\\n        for i in range(1,n):\\n            if security[i] > security[i-1]:\\n                if i <= time:\\n                    total_False += 1\\n                cur_False[i] = False\\n                \\n        for i in range(time,n):\\n            if total_False == 0:left[i] = True\\n            \\n            if i == n-1:continue\\n            if cur_False[i-(time-1)] == False:total_False -= 1\\n            if cur_False[i+1] == False: total_False += 1\\n            \\n        cur_False = [True] * n\\n        total_False = 0\\n        for i in range(n-2,-1,-1):\\n            if security[i] > security[i+1]:\\n                if n-1-time <= i:total_False += 1\\n                cur_False[i] = False\\n                \\n        for i in range(n-1-time,-1,-1):\\n            if total_False == 0:right[i] = True\\n            \\n            if i == 1:continue\\n            if cur_False[i+(time-1)] == False:total_False -= 1\\n            if cur_False[i-1] == False: total_False += 1\\n            \\n        for i in range(n):\\n            if left[i] and right[i]:\\n                res.append(i)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042856,
                "title": "simple-python-solution-with-prefix-sum-and-also-a-simple-tle-solution-for-easy-understanding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        # Time limit Exceeded\\n        # ans = []\\n        # if time >= len(security):\\n        #     return []\\n        # print(len(security), time)   \\n        # for i in range(time, len(security) - time):\\n        #     left, right, flag = i, i, True\\n        #     for j in range(time):\\n        #         if security[left] > security[left-1] or security[right] > security[right+1]:\\n        #             flag = False\\n        #             break\\n        #         left -= 1\\n        #         right += 1    \\n        #     if flag:\\n        #         ans.append(i)\\n        # return ans   \\n        \\n        n = len(security)\\n        pre = [0] * (n+1)\\n        post = [0] * (n+1)\\n\\n        for i in range(1, len(security)):\\n            if security[i] <= security[i-1]:\\n                pre[i] = pre[i-1] + 1\\n        for i in range(n-2, -1, -1):\\n            if security[i] <= security[i+1]:\\n                post[i] = post[i+1] + 1        \\n\\n        # post = post[::-1]\\n\\n        ans = []\\n        for i in range(time, n- time):\\n            if pre[i] >= time and post[i] >= time:\\n                ans.append(i)\\n        return ans            \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        # Time limit Exceeded\\n        # ans = []\\n        # if time >= len(security):\\n        #     return []\\n        # print(len(security), time)   \\n        # for i in range(time, len(security) - time):\\n        #     left, right, flag = i, i, True\\n        #     for j in range(time):\\n        #         if security[left] > security[left-1] or security[right] > security[right+1]:\\n        #             flag = False\\n        #             break\\n        #         left -= 1\\n        #         right += 1    \\n        #     if flag:\\n        #         ans.append(i)\\n        # return ans   \\n        \\n        n = len(security)\\n        pre = [0] * (n+1)\\n        post = [0] * (n+1)\\n\\n        for i in range(1, len(security)):\\n            if security[i] <= security[i-1]:\\n                pre[i] = pre[i-1] + 1\\n        for i in range(n-2, -1, -1):\\n            if security[i] <= security[i+1]:\\n                post[i] = post[i+1] + 1        \\n\\n        # post = post[::-1]\\n\\n        ans = []\\n        for i in range(time, n- time):\\n            if pre[i] >= time and post[i] >= time:\\n                ans.append(i)\\n        return ans            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3012669,
                "title": "longest-chain-on-both-sides",
                "content": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        n = len(security)\\n        mdec = [1] * n\\n        minc = [1] * n\\n        for i in range(1, n):\\n            if security[i] <= security[i - 1]:\\n                mdec[i] = 1 + mdec[i - 1]\\n        for i in range(n - 2, -1, -1):\\n            if security[i] <= security[i + 1]:\\n                minc[i] = 1 + minc[i + 1]\\n        res = []\\n        for i in range(time, n - time):\\n            if mdec[i] >= time + 1 and minc[i] >= time + 1:\\n                res.append(i)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        n = len(security)\\n        mdec = [1] * n\\n        minc = [1] * n\\n        for i in range(1, n):\\n            if security[i] <= security[i - 1]:\\n                mdec[i] = 1 + mdec[i - 1]\\n        for i in range(n - 2, -1, -1):\\n            if security[i] <= security[i + 1]:\\n                minc[i] = 1 + minc[i + 1]\\n        res = []\\n        for i in range(time, n - time):\\n            if mdec[i] >= time + 1 and minc[i] >= time + 1:\\n                res.append(i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2998829,
                "title": "java-one-of-the-easiest-solution-with-prefix-and-suffix-array-with-explanation",
                "content": "```\\npublic static List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int n = security.length;\\n        List<Integer> result = new ArrayList<>();\\n        int[] left = new int[n];\\n        int[] right = new int[n];\\n        for (int i = 1; i < n; i++) {\\n            if (security[i] <= security[i - 1]) {\\n                left[i] = left[i - 1] + 1;\\n            }\\n        }\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (security[i] <= security[i + 1]) {\\n                right[i] = right[i + 1] + 1;\\n            }\\n        }\\n        for (int i = time; i < n - time; i++) {\\n            if (left[i] >= time && right[i] >= time) {\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\npublic static List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int n = security.length;\\n        List<Integer> result = new ArrayList<>();\\n        int[] left = new int[n];\\n        int[] right = new int[n];\\n        for (int i = 1; i < n; i++) {\\n            if (security[i] <= security[i - 1]) {\\n                left[i] = left[i - 1] + 1;\\n            }\\n        }\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (security[i] <= security[i + 1]) {\\n                right[i] = right[i + 1] + 1;\\n            }\\n        }\\n        for (int i = time; i < n - time; i++) {\\n            if (left[i] >= time && right[i] >= time) {\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2998582,
                "title": "java-single-pass-sliding-window-o-n-solution-easy-to-understand",
                "content": "Look at left increment and increment **leftCounter** if below condtion :\\n```\\nsecurity[i - time] >= security[i - time + 1] >= ... >= security[i]\\n\\n```\\nIncrement **rightCounter** if below\\n```\\nsecurity[i] <= ... <= security[i + time - 1] <= security[i + time].\\n\\n```\\n\\nFinally check if both array elements greater than or equal to **time**\\n\\n# Code\\n```\\n//5,3,3,3,5,6,2 \\n//0,1,2,2,0,0,1  = leftMin\\n//0,2,2,2,1,0,0  = rightMin\\n\\n//1,1,1,1,1\\n//1,1,1,1,1 = leftMin\\n//1,1,1,1,1 = rightMin\\n\\n\\n//7,7,7,7,7,7,7,7,7,7,7,7,7\\n//0,1,2,3,4,5,5,5,5,5,5,5,5 = leftMin\\n\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        List<Integer>  result = new ArrayList<>(); \\n        if(time == 0){\\n            for(int i = 0 ; i <  security.length ;i++){\\n                result.add(i);\\n            }\\n            return result;\\n        }\\n        int[] leftMin = new int[security.length] ,  rightMin = new int[security.length];\\n        leftMin[0] = 0;\\n        rightMin[security.length - 1] = 0;\\n        int rightCounter = 0;\\n        int leftCounter = 0;\\n        int n =  security.length ;\\n        for(int i =  1 ;   i < security.length ; i++){\\n            if(security[i-1] >= security[i]){\\n                leftCounter++;\\n                leftMin[i]  = leftCounter;\\n            }\\n            else{\\n                leftMin[i] = 0;\\n                leftCounter = 0;\\n            }\\n            if(leftCounter >= time ){\\n                leftMin[i] = leftCounter;\\n                leftCounter--;\\n            }            \\n            if(security[n - i] >= security[n - i - 1]){\\n                rightCounter++;\\n                rightMin[n - i - 1]  = rightCounter;\\n            }\\n            else{\\n                rightMin[n - i - 1] = 0;\\n                rightCounter = 0;\\n            }\\n            if(rightCounter >= time ){\\n                rightMin[n - i - 1] = rightCounter;\\n                rightCounter--;\\n            } \\n        }\\n        for(int  i = 0 ; i < leftMin.length ; i++){\\n            if(leftMin[i] >= time  && leftMin[i] == rightMin[i]){\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nsecurity[i - time] >= security[i - time + 1] >= ... >= security[i]\\n\\n```\n```\\nsecurity[i] <= ... <= security[i + time - 1] <= security[i + time].\\n\\n```\n```\\n//5,3,3,3,5,6,2 \\n//0,1,2,2,0,0,1  = leftMin\\n//0,2,2,2,1,0,0  = rightMin\\n\\n//1,1,1,1,1\\n//1,1,1,1,1 = leftMin\\n//1,1,1,1,1 = rightMin\\n\\n\\n//7,7,7,7,7,7,7,7,7,7,7,7,7\\n//0,1,2,3,4,5,5,5,5,5,5,5,5 = leftMin\\n\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        List<Integer>  result = new ArrayList<>(); \\n        if(time == 0){\\n            for(int i = 0 ; i <  security.length ;i++){\\n                result.add(i);\\n            }\\n            return result;\\n        }\\n        int[] leftMin = new int[security.length] ,  rightMin = new int[security.length];\\n        leftMin[0] = 0;\\n        rightMin[security.length - 1] = 0;\\n        int rightCounter = 0;\\n        int leftCounter = 0;\\n        int n =  security.length ;\\n        for(int i =  1 ;   i < security.length ; i++){\\n            if(security[i-1] >= security[i]){\\n                leftCounter++;\\n                leftMin[i]  = leftCounter;\\n            }\\n            else{\\n                leftMin[i] = 0;\\n                leftCounter = 0;\\n            }\\n            if(leftCounter >= time ){\\n                leftMin[i] = leftCounter;\\n                leftCounter--;\\n            }            \\n            if(security[n - i] >= security[n - i - 1]){\\n                rightCounter++;\\n                rightMin[n - i - 1]  = rightCounter;\\n            }\\n            else{\\n                rightMin[n - i - 1] = 0;\\n                rightCounter = 0;\\n            }\\n            if(rightCounter >= time ){\\n                rightMin[n - i - 1] = rightCounter;\\n                rightCounter--;\\n            } \\n        }\\n        for(int  i = 0 ; i < leftMin.length ; i++){\\n            if(leftMin[i] >= time  && leftMin[i] == rightMin[i]){\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957642,
                "title": "easy-c-solution-o-n-faster",
                "content": "\\n# Approach: 2 vectors(prefix and suff), one to store the number of days before the ith day that is non-increasing, and another array to store the number of days after the ith day that is non-decreasing.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 3O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& a, int time) {\\n        int n=a.size();\\n        vector<int>v;\\n        int cnt=0;\\n        vector<int>pref(n,1),suff(n,1);\\n        for(int i=0;i<n;i++){\\n            if(i==0)continue;\\n            if(a[i]<=a[i-1]){\\n                cnt++;\\n                pref[i]+=cnt;\\n            }else{\\n                cnt=0;\\n            }\\n        }\\n        cnt=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(i==n-1)continue;\\n            if(a[i]<=a[i+1]){\\n                cnt++;\\n                suff[i]+=cnt;\\n            }else{\\n                cnt=0;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(pref[i]>=time+1&&suff[i]>=time+1){\\n                v.push_back(i);\\n            }\\n        }\\n\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& a, int time) {\\n        int n=a.size();\\n        vector<int>v;\\n        int cnt=0;\\n        vector<int>pref(n,1),suff(n,1);\\n        for(int i=0;i<n;i++){\\n            if(i==0)continue;\\n            if(a[i]<=a[i-1]){\\n                cnt++;\\n                pref[i]+=cnt;\\n            }else{\\n                cnt=0;\\n            }\\n        }\\n        cnt=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(i==n-1)continue;\\n            if(a[i]<=a[i+1]){\\n                cnt++;\\n                suff[i]+=cnt;\\n            }else{\\n                cnt=0;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(pref[i]>=time+1&&suff[i]>=time+1){\\n                v.push_back(i);\\n            }\\n        }\\n\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2936811,
                "title": "solution-in-rust",
                "content": "# Code\\n```\\nuse std::collections::HashSet;\\nuse std::iter::FromIterator;\\n impl Solution {\\n    pub fn good_days_to_rob_bank(security: Vec<i32>, time: i32) -> Vec<i32> {\\n        let mut pl = i32::MIN;\\n        let mut pr = i32::MIN;\\n\\n        let mut cl = 0;\\n        let mut cr = 0;\\n\\n        let mut a: HashSet<i32> = HashSet::new();\\n        let mut b: HashSet<i32> = HashSet::new();\\n        for i in 0..security.len() {\\n            if security[i] <= pl {\\n                cl += 1;\\n            } else {\\n                cl = 0;\\n            }\\n            if security[security.len() - 1 - i] <= pr {\\n                cr += 1;\\n            } else {\\n                cr = 0;\\n            }\\n\\n            if cl >= time {\\n                a.insert(i as i32);\\n            }\\n            if cr >= time {\\n                b.insert((security.len() - 1 - i) as i32);\\n            }\\n            pl = security[i];\\n            pr = security[security.len() - 1 - i];\\n        }\\n        let x = Vec::from_iter(HashSet::from(&a & &b).iter().cloned());\\n        x\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashSet;\\nuse std::iter::FromIterator;\\n impl Solution {\\n    pub fn good_days_to_rob_bank(security: Vec<i32>, time: i32) -> Vec<i32> {\\n        let mut pl = i32::MIN;\\n        let mut pr = i32::MIN;\\n\\n        let mut cl = 0;\\n        let mut cr = 0;\\n\\n        let mut a: HashSet<i32> = HashSet::new();\\n        let mut b: HashSet<i32> = HashSet::new();\\n        for i in 0..security.len() {\\n            if security[i] <= pl {\\n                cl += 1;\\n            } else {\\n                cl = 0;\\n            }\\n            if security[security.len() - 1 - i] <= pr {\\n                cr += 1;\\n            } else {\\n                cr = 0;\\n            }\\n\\n            if cl >= time {\\n                a.insert(i as i32);\\n            }\\n            if cr >= time {\\n                b.insert((security.len() - 1 - i) as i32);\\n            }\\n            pl = security[i];\\n            pr = security[security.len() - 1 - i];\\n        }\\n        let x = Vec::from_iter(HashSet::from(&a & &b).iter().cloned());\\n        x\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2930091,
                "title": "java-o-n-count-decreasing-days-on-left-and-increasing-on-right-of-each-day",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int ddays = 0;\\n        int[][] before_after = new int[security.length][2];\\n        for (int i = 1; i < security.length; i++) {\\n            if (security[i - 1] >= security[i]) {\\n                ddays++;\\n            } else {\\n                ddays = 0;\\n            }\\n            before_after[i][0]= ddays;\\n        }\\n        ddays = 0;\\n        for (int i = security.length - 1; i > 0; i--) {\\n            if (security[i - 1] <= security[i]) {\\n                ddays++;\\n            } else {\\n                ddays = 0;\\n            }\\n            before_after[i - 1][1]= ddays;\\n        }\\n        List<Integer> res = new LinkedList<>();\\n        for (int i = 0; i < before_after.length; i++) {\\n            if (before_after[i][0] >= time && before_after[i][1] >= time) {\\n                res.add(i);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int ddays = 0;\\n        int[][] before_after = new int[security.length][2];\\n        for (int i = 1; i < security.length; i++) {\\n            if (security[i - 1] >= security[i]) {\\n                ddays++;\\n            } else {\\n                ddays = 0;\\n            }\\n            before_after[i][0]= ddays;\\n        }\\n        ddays = 0;\\n        for (int i = security.length - 1; i > 0; i--) {\\n            if (security[i - 1] <= security[i]) {\\n                ddays++;\\n            } else {\\n                ddays = 0;\\n            }\\n            before_after[i - 1][1]= ddays;\\n        }\\n        List<Integer> res = new LinkedList<>();\\n        for (int i = 0; i < before_after.length; i++) {\\n            if (before_after[i][0] >= time && before_after[i][1] >= time) {\\n                res.add(i);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2913384,
                "title": "prabal-kumar-pandey",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        vector<int> right = {0};\\n        for (int i = size(security) - 1; i >= 1; --i) {\\n            right.emplace_back(security[i] >= security[i - 1] ? right.back() + 1 : 0);\\n        }\\n        reverse(begin(right), end(right));\\n        vector<int> result;\\n        for (int i = 0, left = 0; i < size(security); ++i) {\\n            if (left >= time && right[i] >= time) {\\n                result.emplace_back(i);\\n            }\\n            if (i + 1 < size(security)) {\\n                left = (security[i] >= security[i + 1]) ? left + 1 : 0;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        vector<int> right = {0};\\n        for (int i = size(security) - 1; i >= 1; --i) {\\n            right.emplace_back(security[i] >= security[i - 1] ? right.back() + 1 : 0);\\n        }\\n        reverse(begin(right), end(right));\\n        vector<int> result;\\n        for (int i = 0, left = 0; i < size(security); ++i) {\\n            if (left >= time && right[i] >= time) {\\n                result.emplace_back(i);\\n            }\\n            if (i + 1 < size(security)) {\\n                left = (security[i] >= security[i + 1]) ? left + 1 : 0;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2908396,
                "title": "golang-dp",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n# Code\\n```\\nfunc goodDaysToRobBank(security []int, time int) []int {\\n    var ans []int\\n    var n int = len(security)\\n    right := make([]int, n)\\n    left := make([]int, n)\\n    for i := n - 2; i >= 0; i-- {\\n        if security[i] <= security[i + 1] {\\n            right[i] = right[i + 1] + 1\\n        }\\n    }\\n    for i := 1; i < n; i++ {\\n        if security[i] <= security[i - 1] {\\n            left[i] = left[i - 1] + 1\\n        }\\n    }\\n    for i := n - time - 1; i >= time; i-- {\\n        if left[i] - left[i - time] == time && right[i] - right[i + time] == time {\\n            ans = append(ans, i)\\n        }\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc goodDaysToRobBank(security []int, time int) []int {\\n    var ans []int\\n    var n int = len(security)\\n    right := make([]int, n)\\n    left := make([]int, n)\\n    for i := n - 2; i >= 0; i-- {\\n        if security[i] <= security[i + 1] {\\n            right[i] = right[i + 1] + 1\\n        }\\n    }\\n    for i := 1; i < n; i++ {\\n        if security[i] <= security[i - 1] {\\n            left[i] = left[i - 1] + 1\\n        }\\n    }\\n    for i := n - time - 1; i >= time; i-- {\\n        if left[i] - left[i - time] == time && right[i] - right[i + time] == time {\\n            ans = append(ans, i)\\n        }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2908355,
                "title": "c-dp",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        vector<int> ans;\\n        int n = security.size();\\n        vector<int> right(n, 1), left(n, 1);\\n        for(int i = n - 2; i >= 0; i--) {\\n            if(security[i] <= security[i + 1])\\n                right[i] = right[i + 1] + 1;\\n        }\\n        for(int i = 1; i < n; i++) {\\n            if(security[i] <= security[i - 1])\\n                left[i] = left[i - 1] + 1;\\n        }\\n        for(int i = n - time - 1; i >= time; i--) {\\n            if(left[i] - left[i - time] == time && right[i] - right[i + time] == time)\\n                ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        vector<int> ans;\\n        int n = security.size();\\n        vector<int> right(n, 1), left(n, 1);\\n        for(int i = n - 2; i >= 0; i--) {\\n            if(security[i] <= security[i + 1])\\n                right[i] = right[i + 1] + 1;\\n        }\\n        for(int i = 1; i < n; i++) {\\n            if(security[i] <= security[i - 1])\\n                left[i] = left[i - 1] + 1;\\n        }\\n        for(int i = n - time - 1; i >= time; i--) {\\n            if(left[i] - left[i - time] == time && right[i] - right[i + time] == time)\\n                ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2908283,
                "title": "easy-to-read-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        good_days = []\\n\\n        prefix = [0]*len(security)\\n        suffix = [0]*len(security)\\n\\n        # prefix or suffix at ith index represents how many elements excluding current element is increasing or decreasing. \\n        prefix[0] = 0\\n        suffix[len(security)-1] = 0\\n\\n        # non-increasing 9 8 7 6\\n        for i in range(1, len(prefix)):\\n            if security[i-1] >= security[i]:\\n                prefix[i] = prefix[i-1] + 1\\n            else:\\n                prefix[i] = 0\\n        \\n        # non-decreasing 1 2 3 4\\n        for i in range(len(suffix)-2,-1,-1):\\n            if security[i] <= security[i+1]:\\n                suffix[i] = suffix[i+1] + 1\\n            else:\\n                suffix[i] = 0\\n        # print (prefix)\\n        # print (suffix)\\n        for i in range(time, len(security)-time):\\n            if time != 0 and prefix[i] >= time and suffix[i] >= time:\\n                good_days.append(i)\\n            elif time == 0: # Dont forget to miss this edge case.\\n                good_days.append(i)\\n        return good_days\\n\\n\\'\\'\\'\\nMissed [1,2,3,4] time = 1 expected ans is [] check failed code in submission.\\n\\'\\'\\'\\n\\n \\n\\n\\'\\'\\'\\nBrute force approach \\n\\n        1. traverse start from time days end loop at end days\\n        2. check time days before i - non increasing\\n        3. check time days after i - non decreasing\\n        4. add to answer. \\n\\n        TC: (N* time)\\n    \\n        You can reduce TC of step 2 and 3 by creating suffix and prefix array.\\n\\n\\n        # 5 3 3 3 5 6 2\\n        # + - - - + + -\\n        #   1 2 3 4 5 6 1\\n        #   1 5 4 3 2 1 1\\n\\n        # Does sum help ? No\\n\\'\\'\\'\\n\\n```",
                "solutionTags": [
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        good_days = []\\n\\n        prefix = [0]*len(security)\\n        suffix = [0]*len(security)\\n\\n        # prefix or suffix at ith index represents how many elements excluding current element is increasing or decreasing. \\n        prefix[0] = 0\\n        suffix[len(security)-1] = 0\\n\\n        # non-increasing 9 8 7 6\\n        for i in range(1, len(prefix)):\\n            if security[i-1] >= security[i]:\\n                prefix[i] = prefix[i-1] + 1\\n            else:\\n                prefix[i] = 0\\n        \\n        # non-decreasing 1 2 3 4\\n        for i in range(len(suffix)-2,-1,-1):\\n            if security[i] <= security[i+1]:\\n                suffix[i] = suffix[i+1] + 1\\n            else:\\n                suffix[i] = 0\\n        # print (prefix)\\n        # print (suffix)\\n        for i in range(time, len(security)-time):\\n            if time != 0 and prefix[i] >= time and suffix[i] >= time:\\n                good_days.append(i)\\n            elif time == 0: # Dont forget to miss this edge case.\\n                good_days.append(i)\\n        return good_days\\n\\n\\'\\'\\'\\nMissed [1,2,3,4] time = 1 expected ans is [] check failed code in submission.\\n\\'\\'\\'\\n\\n \\n\\n\\'\\'\\'\\nBrute force approach \\n\\n        1. traverse start from time days end loop at end days\\n        2. check time days before i - non increasing\\n        3. check time days after i - non decreasing\\n        4. add to answer. \\n\\n        TC: (N* time)\\n    \\n        You can reduce TC of step 2 and 3 by creating suffix and prefix array.\\n\\n\\n        # 5 3 3 3 5 6 2\\n        # + - - - + + -\\n        #   1 2 3 4 5 6 1\\n        #   1 5 4 3 2 1 1\\n\\n        # Does sum help ? No\\n\\'\\'\\'\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891526,
                "title": "java-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPreparing the metadata required to solve the each index of security array.\\n\\nPattern : Decrease <-> Day <-> Increase\\n\\n```\\nCode block\\n\\n    // Pattern:  Decrease <-> Day <-> Increase\\n    // Index:    0, 1, 2, 3, 4, 5, 6\\n    // Input:    5, 3, 3, 3, 5, 6, 2\\n    \\n    //left:     -1, 0, 0, 0, 0,-1, 5\\n    //right:    -1, 5, 5, 5, 5,-1,-1\\n\\n    //Ans:      -1,-1, 2, 3,-1,-1,-1\\n```\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPrefix sum\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        List<Integer> res = new ArrayList<>();\\n        int n = security.length;\\n        if(time == 0) {\\n           for(int i=0; i<n; i++) {\\n               res.add(i);\\n           }\\n           return res; \\n        }\\n        \\n        int[] left = new int[n];\\n        int[] right = new int[n];\\n\\n        left[0] = -1;\\n        int prevHigh = 0;\\n        for(int i=1; i<n; i++) {\\n            if(security[i] <= security[i-1]) {\\n                left[i] = prevHigh;\\n            } else {\\n                left[i] = -1;\\n                prevHigh = i;\\n            }\\n        }\\n\\n        right[n-1] = -1;\\n        int nextHigh = n-1;\\n        for(int i=n-2; i>=0; i--) {\\n            if(security[i] <= security[i+1]) {\\n                right[i] = nextHigh;\\n            } else {\\n                right[i] = -1;\\n                nextHigh = i;\\n            }\\n        }\\n\\n        System.out.println(Arrays.toString(left));\\n        System.out.println(Arrays.toString(right));\\n\\n        for(int i=1; i<n-1;i++) {\\n            if(left[i] != -1 && right[i] != -1 && i- left[i] >= time && right[i] - i >= time) {\\n                res.add(i);\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nCode block\\n\\n    // Pattern:  Decrease <-> Day <-> Increase\\n    // Index:    0, 1, 2, 3, 4, 5, 6\\n    // Input:    5, 3, 3, 3, 5, 6, 2\\n    \\n    //left:     -1, 0, 0, 0, 0,-1, 5\\n    //right:    -1, 5, 5, 5, 5,-1,-1\\n\\n    //Ans:      -1,-1, 2, 3,-1,-1,-1\\n```\n```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        List<Integer> res = new ArrayList<>();\\n        int n = security.length;\\n        if(time == 0) {\\n           for(int i=0; i<n; i++) {\\n               res.add(i);\\n           }\\n           return res; \\n        }\\n        \\n        int[] left = new int[n];\\n        int[] right = new int[n];\\n\\n        left[0] = -1;\\n        int prevHigh = 0;\\n        for(int i=1; i<n; i++) {\\n            if(security[i] <= security[i-1]) {\\n                left[i] = prevHigh;\\n            } else {\\n                left[i] = -1;\\n                prevHigh = i;\\n            }\\n        }\\n\\n        right[n-1] = -1;\\n        int nextHigh = n-1;\\n        for(int i=n-2; i>=0; i--) {\\n            if(security[i] <= security[i+1]) {\\n                right[i] = nextHigh;\\n            } else {\\n                right[i] = -1;\\n                nextHigh = i;\\n            }\\n        }\\n\\n        System.out.println(Arrays.toString(left));\\n        System.out.println(Arrays.toString(right));\\n\\n        for(int i=1; i<n-1;i++) {\\n            if(left[i] != -1 && right[i] != -1 && i- left[i] >= time && right[i] - i >= time) {\\n                res.add(i);\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2888890,
                "title": "o-n-complexity-solution-using-sliding-windows",
                "content": "# Intuition\\nScan from left to right with index `i`\\n\\nKeep two sliding widows. One window - `beforeWindow` extends backwards from `i` and contains a sequence of non-increasing numbers. If i is larger than `i-1` then the window size is 0\\n\\nThe `afterWindow` keeps track of elements from `i + times` and extends backwards towards i. if `i + times + 1` is less than `i + times`, then this element size is also reset to 0\\n\\nWhenever the number of elements in both of these sliding windows equals `times`, then `i` is a good day.\\n\\n# Approach\\nBoth of these sliding widows can be maintained O(1), because we only need to compare the leading end of the window to the next element. If that \\nelement violates the condition for the window, the widow must be reset to 0. If it satisfies, then the window length increased by one element.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nfunc goodDaysToRobBank(security []int, time int) []int {\\n    beforeWindowLen := 0\\n    afterWindownLen := 0\\n\\n    res := []int{}\\n\\n    i := 0\\n    for i < len(security) {\\n        if beforeWindowLen >= time && afterWindownLen >= time {\\n            res = append(res, i)\\n        }\\n\\n        if i + time + 1 == len(security) {\\n            break\\n        }\\n\\n        if i + 1 < len(security) && security[i] >= security[i+1] {\\n            beforeWindowLen ++\\n        } else {\\n            beforeWindowLen = 0\\n        }\\n\\n        if i + time + 1 < len(security) && security[i + time] <= security[i + time + 1 ] {\\n            afterWindownLen ++\\n        } else {\\n            afterWindownLen = 0\\n        }\\n\\n        i ++\\n    }\\n\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc goodDaysToRobBank(security []int, time int) []int {\\n    beforeWindowLen := 0\\n    afterWindownLen := 0\\n\\n    res := []int{}\\n\\n    i := 0\\n    for i < len(security) {\\n        if beforeWindowLen >= time && afterWindownLen >= time {\\n            res = append(res, i)\\n        }\\n\\n        if i + time + 1 == len(security) {\\n            break\\n        }\\n\\n        if i + 1 < len(security) && security[i] >= security[i+1] {\\n            beforeWindowLen ++\\n        } else {\\n            beforeWindowLen = 0\\n        }\\n\\n        if i + time + 1 < len(security) && security[i + time] <= security[i + time + 1 ] {\\n            afterWindownLen ++\\n        } else {\\n            afterWindownLen = 0\\n        }\\n\\n        i ++\\n    }\\n\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2887399,
                "title": "java-easy-java-easy-to-understand-buteforce-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust bruteforce with on e edge case\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbruteforce\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public boolean isDecreasing(int[] security,int start,int end){\\n        for(int i=start+1;i<=end;i++){\\n            if(security[i]>security[i-1]){\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n     public boolean isIncreasing(int[] security,int start,int end){\\n        for(int i=start+1;i<=end;i++){\\n            if(security[i]<security[i-1]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public boolean isGood(int[] security,int time,int idx){\\n\\n    if(!isDecreasing(security,idx-time,idx) || !isIncreasing(security,idx,idx+time) ){\\n        return false;\\n    }\\n    return true;\\n\\n    }\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        List<Integer> ans = new ArrayList<>();\\n\\n        HashSet<Integer> set  = new HashSet<>();\\n    \\n\\n        for(int i=time;i<security.length-time;i++){\\n            if(set.contains(i-1) && (security[i] == security[i-1])){\\n               \\n                    if(security[i+time-1] <= security[i+time]){\\n                        \\n                        ans.add(i);\\n                        set.add(i);\\n                    }\\n\\n            }\\n            else if(i<security.length-time && isGood(security,time,i)){\\n             //   System.out.println(i);\\n                ans.add(i);\\n                set.add(i);\\n\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public boolean isDecreasing(int[] security,int start,int end){\\n        for(int i=start+1;i<=end;i++){\\n            if(security[i]>security[i-1]){\\n                return false;\\n            }\\n        }\\n        return true;\\n\\n    }\\n     public boolean isIncreasing(int[] security,int start,int end){\\n        for(int i=start+1;i<=end;i++){\\n            if(security[i]<security[i-1]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public boolean isGood(int[] security,int time,int idx){\\n\\n    if(!isDecreasing(security,idx-time,idx) || !isIncreasing(security,idx,idx+time) ){\\n        return false;\\n    }\\n    return true;\\n\\n    }\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        List<Integer> ans = new ArrayList<>();\\n\\n        HashSet<Integer> set  = new HashSet<>();\\n    \\n\\n        for(int i=time;i<security.length-time;i++){\\n            if(set.contains(i-1) && (security[i] == security[i-1])){\\n               \\n                    if(security[i+time-1] <= security[i+time]){\\n                        \\n                        ans.add(i);\\n                        set.add(i);\\n                    }\\n\\n            }\\n            else if(i<security.length-time && isGood(security,time,i)){\\n             //   System.out.println(i);\\n                ans.add(i);\\n                set.add(i);\\n\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2862747,
                "title": "c-prefix-sum-suffix-sum-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) \\n    {\\n        int n=security.size();\\n        int prefix[n],sufix[n];\\n        prefix[0]=0;sufix[n-1]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(security[i]<=security[i-1])\\n            {\\n                prefix[i]=prefix[i-1]+1;\\n            }\\n            else\\n            {\\n                prefix[i]=0;\\n            }\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(security[i]<=security[i+1])\\n            {\\n                sufix[i]=sufix[i+1]+1;\\n            }\\n            else\\n            {\\n                sufix[i]=0;\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(prefix[i]>=time&&sufix[i]>=time)\\n            {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) \\n    {\\n        int n=security.size();\\n        int prefix[n],sufix[n];\\n        prefix[0]=0;sufix[n-1]=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(security[i]<=security[i-1])\\n            {\\n                prefix[i]=prefix[i-1]+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2860961,
                "title": "java-simple-two-pass-forward-backward-solution",
                "content": "# Complexity\\n- Time complexity: O(n). O(n) for the forward pass, and O(n) for the backward pass.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) to store the forward pass result `nonIncr`.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int n = security.length;\\n        Boolean[] nonIncr = new Boolean[n];\\n        int prev = Integer.MAX_VALUE;\\n        int cnt = -1;\\n        for (int i = 0; i < n; i++) {\\n            if (security[i] <= prev) {\\n                cnt += 1;\\n            }\\n            else {\\n                cnt = 0;\\n            }\\n            nonIncr[i] = cnt >= time ? true : false;\\n            prev = security[i];\\n        }\\n        int next = Integer.MAX_VALUE;\\n        cnt = -1;\\n        List<Integer> rst = new ArrayList<>();\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (security[i] <= next) {\\n                cnt += 1;\\n            }\\n            else {\\n                cnt = 0;\\n            }\\n            if (cnt >= time && nonIncr[i]) {\\n                rst.add(i);\\n            }\\n            next = security[i];\\n        }\\n        return rst;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int n = security.length;\\n        Boolean[] nonIncr = new Boolean[n];\\n        int prev = Integer.MAX_VALUE;\\n        int cnt = -1;\\n        for (int i = 0; i < n; i++) {\\n            if (security[i] <= prev) {\\n                cnt += 1;\\n            }\\n            else {\\n                cnt = 0;\\n            }\\n            nonIncr[i] = cnt >= time ? true : false;\\n            prev = security[i];\\n        }\\n        int next = Integer.MAX_VALUE;\\n        cnt = -1;\\n        List<Integer> rst = new ArrayList<>();\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (security[i] <= next) {\\n                cnt += 1;\\n            }\\n            else {\\n                cnt = 0;\\n            }\\n            if (cnt >= time && nonIncr[i]) {\\n                rst.add(i);\\n            }\\n            next = security[i];\\n        }\\n        return rst;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2860960,
                "title": "python-simple-o-n-solution",
                "content": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        nums = security\\n        prevs = []\\n        posts = []\\n        pos = 0\\n        for i, v in enumerate(nums):\\n            if i == 0 or nums[i] > nums[i - 1]:\\n                pos = i\\n            prevs.append(i - pos)\\n        for i in range(len(nums) - 1, -1, -1):\\n            if i == len(nums) - 1 or nums[i + 1] < nums[i]:\\n                pos = i\\n            posts.append(pos - i)\\n        posts = posts[::-1]\\n            \\n        res = []\\n        for i, (v1, v2) in enumerate(zip(posts, prevs)):\\n            if v1 >= time and v2 >= time:\\n                res.append(i)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        nums = security\\n        prevs = []\\n        posts = []\\n        pos = 0\\n        for i, v in enumerate(nums):\\n            if i == 0 or nums[i] > nums[i - 1]:\\n                pos = i\\n            prevs.append(i - pos)\\n        for i in range(len(nums) - 1, -1, -1):\\n            if i == len(nums) - 1 or nums[i + 1] < nums[i]:\\n                pos = i\\n            posts.append(pos - i)\\n        posts = posts[::-1]\\n            \\n        res = []\\n        for i, (v1, v2) in enumerate(zip(posts, prevs)):\\n            if v1 >= time and v2 >= time:\\n                res.append(i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854311,
                "title": "easy-and-clean-solution-with-tc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int [] nonInc = new int[security.length];\\n        int [] nonDec = new int[security.length];\\n        for(int i = 1; i < security.length;i++)\\n        {\\n            if(security[i] <= security[i-1])\\n            nonInc[i] = 1 + nonInc[i-1];\\n        }\\n        for(int i = security.length - 2; i >= 0;i--)\\n        {\\n            if(security[i] <= security[i+1])\\n            nonDec[i] = 1 + nonDec[i+1];\\n        }\\n        List<Integer> goodDays = new ArrayList<>();\\n        for(int i = time; i < security.length-time;i++)\\n        {\\n            if(nonInc[i] >= time && nonDec[i] >= time)\\n            goodDays.add(i);\\n        }\\n        return goodDays;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodDaysToRobBank(int[] security, int time) {\\n        int [] nonInc = new int[security.length];\\n        int [] nonDec = new int[security.length];\\n        for(int i = 1; i < security.length;i++)\\n        {\\n            if(security[i] <= security[i-1])\\n            nonInc[i] = 1 + nonInc[i-1];\\n        }\\n        for(int i = security.length - 2; i >= 0;i--)\\n        {\\n            if(security[i] <= security[i+1])\\n            nonDec[i] = 1 + nonDec[i+1];\\n        }\\n        List<Integer> goodDays = new ArrayList<>();\\n        for(int i = time; i < security.length-time;i++)\\n        {\\n            if(nonInc[i] >= time && nonDec[i] >= time)\\n            goodDays.add(i);\\n        }\\n        return goodDays;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2825439,
                "title": "c-prefix-array-and-suffix-array-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        vector<int> fromLeft(security.size(),0);\\n        vector<int> fromRight(security.size(),0);\\n        for(int i = 1; i < security.size(); i++) {\\n            if(security[i] <= security[i-1]) {\\n                fromLeft[i] = 1 + fromLeft[i-1];\\n            }\\n        }\\n        for(int i =  security.size() - 2; i >= 0; i--) {\\n            if(security[i] <= security[i+1]) {\\n                fromRight[i] = 1 + fromRight[i+1];\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i =0; i < security.size(); i++) {\\n            if(fromRight[i] >= time && fromLeft[i] >= time)\\n                ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& security, int time) {\\n        vector<int> fromLeft(security.size(),0);\\n        vector<int> fromRight(security.size(),0);\\n        for(int i = 1; i < security.size(); i++) {\\n            if(security[i] <= security[i-1]) {\\n                fromLeft[i] = 1 + fromLeft[i-1];\\n            }\\n        }\\n        for(int i =  security.size() - 2; i >= 0; i--) {\\n            if(security[i] <= security[i+1]) {\\n                fromRight[i] = 1 + fromRight[i+1];\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i =0; i < security.size(); i++) {\\n            if(fromRight[i] >= time && fromLeft[i] >= time)\\n                ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2801128,
                "title": "python3-prefix-sum-solution",
                "content": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n\\n      grid1 = [0, 1]\\n      grid2 = [0, 1]\\n\\n      for i in range(len(security)-1):\\n        if security[i] >= security[i+1]: grid1.append(1)\\n        else: grid1.append(0)\\n        if security[i] <= security[i+1]: grid2.append(1)\\n        else: grid2.append(0)\\n\\n      start = 0\\n      for i in range(len(grid1)):\\n        start += grid1[i]\\n        grid1[i] = start\\n\\n      start = 0\\n      for i in range(len(grid2)):\\n        start += grid2[i]\\n        grid2[i] = start\\n\\n      res = []\\n\\n      for t in range(time+1, len(grid1)-time):\\n        if grid1[t] - grid1[t-time] == time and grid2[t+time] - grid2[t] == time:\\n          res.append(t-1)\\n\\n      return res\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n\\n      grid1 = [0, 1]\\n      grid2 = [0, 1]\\n\\n      for i in range(len(security)-1):\\n        if security[i] >= security[i+1]: grid1.append(1)\\n        else: grid1.append(0)\\n        if security[i] <= security[i+1]: grid2.append(1)\\n        else: grid2.append(0)\\n\\n      start = 0\\n      for i in range(len(grid1)):\\n        start += grid1[i]\\n        grid1[i] = start\\n\\n      start = 0\\n      for i in range(len(grid2)):\\n        start += grid2[i]\\n        grid2[i] = start\\n\\n      res = []\\n\\n      for t in range(time+1, len(grid1)-time):\\n        if grid1[t] - grid1[t-time] == time and grid2[t+time] - grid2[t] == time:\\n          res.append(t-1)\\n\\n      return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792790,
                "title": "decreasing-sequence-o-n-explained-python",
                "content": "let element i be the last element of decreasing sequence from both left and right\\nif the length of both right and left sequence >= time+1, then ith element is valid\\n\\nYou can find the length of decreasing sequence using simple iteration and store them in an array.\\n\\nthen go through each element and validate using length of sequences\\n\\n**Time: O(n)\\nSpace:O(n)**\\n```\\ndef goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n    n = len(security)\\n    \\n    right = [1]*n\\n    for i in range(n-2, -1, -1):\\n        if security[i] <= security[i+1]:\\n            right[i] = right[i+1] + 1\\n    \\n    seq = 1\\n    ans = []\\n    for i in range(n):\\n        if i and security[i] <= security[i-1]:\\n            seq += 1\\n        else:\\n            seq = 1\\n        if min(seq, right[i]) >= time + 1:\\n            ans.append(i)\\n    \\n    return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\ndef goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n    n = len(security)\\n    \\n    right = [1]*n\\n    for i in range(n-2, -1, -1):\\n        if security[i] <= security[i+1]:\\n            right[i] = right[i+1] + 1\\n    \\n    seq = 1\\n    ans = []\\n    for i in range(n):\\n        if i and security[i] <= security[i-1]:\\n            seq += 1\\n        else:\\n            seq = 1\\n        if min(seq, right[i]) >= time + 1:\\n            ans.append(i)\\n    \\n    return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2789777,
                "title": "python-prefix-sum-o-n-time",
                "content": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        \\n        # O(n) time and space\\n        \\n        n = len(security)\\n        # number of non-increasing days before i-th day\\n        before = [0] * n\\n        # number of non-decreasing days after i-th day\\n        after = [0] * n\\n        \\n        count_before, count_after = 0, 0\\n        \\n        # fill arrays before and after in one pass\\n        for i in range(1, n):\\n            if security[i - 1] >= security[i]:\\n                count_before += 1\\n                before[i] = count_before\\n            else:\\n                count_before = 0\\n                \\n            if security[n - i - 1] <= security[n - i]:\\n                count_after += 1\\n                after[n - i - 1] = count_after\\n            else:\\n                count_after = 0\\n                \\n        result = []\\n        \\n        # the i-th day is considered good if before[i] and after[i] are greater than time\\n        for i in range(n):\\n            if before[i] >= time and after[i] >= time:\\n                result.append(i)\\n                \\n        return result\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def goodDaysToRobBank(self, security: List[int], time: int) -> List[int]:\\n        \\n        # O(n) time and space\\n        \\n        n = len(security)\\n        # number of non-increasing days before i-th day\\n        before = [0] * n\\n        # number of non-decreasing days after i-th day\\n        after = [0] * n\\n        \\n        count_before, count_after = 0, 0\\n        \\n        # fill arrays before and after in one pass\\n        for i in range(1, n):\\n            if security[i - 1] >= security[i]:\\n                count_before += 1\\n                before[i] = count_before\\n            else:\\n                count_before = 0\\n                \\n            if security[n - i - 1] <= security[n - i]:\\n                count_after += 1\\n                after[n - i - 1] = count_after\\n            else:\\n                count_after = 0\\n                \\n        result = []\\n        \\n        # the i-th day is considered good if before[i] and after[i] are greater than time\\n        for i in range(n):\\n            if before[i] >= time and after[i] >= time:\\n                result.append(i)\\n                \\n        return result\\n        \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1933112,
                "content": [
                    {
                        "username": "54k",
                        "content": "Okay, I don't need leetcode anymore to get a high paid job, I'll rob a bank at a good day instead"
                    },
                    {
                        "username": "julkar9",
                        "content": "My lawyer has advised me to not solve this question"
                    },
                    {
                        "username": "sheffy07_07",
                        "content": "ideally for[1,2,3,4] it should return {2,3} , but the answer is empty array. "
                    },
                    {
                        "username": "rhymes17",
                        "content": "Consider the fact that left side of the ith index must be decreasing and right side must be increasing.\nSo the given example [1,2,3,4], if you consider 3 as your ans, then left side is not decreasing, instead it is increasing. So it should return an empty array.\nFeel free to ask if you have any doubt.\nHappy Coding!"
                    },
                    {
                        "username": "Rounak_25",
                        "content": "for security=[1,2,3,4] and time=1, the ans should be[2,3] but it\\'s an empty array"
                    },
                    {
                        "username": "ayyush_sharma",
                        "content": "This Question is same as `2420. Find All Good Indices` on leetcode. :)\\n"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Has anyone solved it using sliding window? If yes, please share your solution!"
                    }
                ]
            },
            {
                "id": 2038564,
                "content": [
                    {
                        "username": "54k",
                        "content": "Okay, I don't need leetcode anymore to get a high paid job, I'll rob a bank at a good day instead"
                    },
                    {
                        "username": "julkar9",
                        "content": "My lawyer has advised me to not solve this question"
                    },
                    {
                        "username": "sheffy07_07",
                        "content": "ideally for[1,2,3,4] it should return {2,3} , but the answer is empty array. "
                    },
                    {
                        "username": "rhymes17",
                        "content": "Consider the fact that left side of the ith index must be decreasing and right side must be increasing.\nSo the given example [1,2,3,4], if you consider 3 as your ans, then left side is not decreasing, instead it is increasing. So it should return an empty array.\nFeel free to ask if you have any doubt.\nHappy Coding!"
                    },
                    {
                        "username": "Rounak_25",
                        "content": "for security=[1,2,3,4] and time=1, the ans should be[2,3] but it\\'s an empty array"
                    },
                    {
                        "username": "ayyush_sharma",
                        "content": "This Question is same as `2420. Find All Good Indices` on leetcode. :)\\n"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Has anyone solved it using sliding window? If yes, please share your solution!"
                    }
                ]
            },
            {
                "id": 2001092,
                "content": [
                    {
                        "username": "54k",
                        "content": "Okay, I don't need leetcode anymore to get a high paid job, I'll rob a bank at a good day instead"
                    },
                    {
                        "username": "julkar9",
                        "content": "My lawyer has advised me to not solve this question"
                    },
                    {
                        "username": "sheffy07_07",
                        "content": "ideally for[1,2,3,4] it should return {2,3} , but the answer is empty array. "
                    },
                    {
                        "username": "rhymes17",
                        "content": "Consider the fact that left side of the ith index must be decreasing and right side must be increasing.\nSo the given example [1,2,3,4], if you consider 3 as your ans, then left side is not decreasing, instead it is increasing. So it should return an empty array.\nFeel free to ask if you have any doubt.\nHappy Coding!"
                    },
                    {
                        "username": "Rounak_25",
                        "content": "for security=[1,2,3,4] and time=1, the ans should be[2,3] but it\\'s an empty array"
                    },
                    {
                        "username": "ayyush_sharma",
                        "content": "This Question is same as `2420. Find All Good Indices` on leetcode. :)\\n"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Has anyone solved it using sliding window? If yes, please share your solution!"
                    }
                ]
            },
            {
                "id": 2057754,
                "content": [
                    {
                        "username": "54k",
                        "content": "Okay, I don't need leetcode anymore to get a high paid job, I'll rob a bank at a good day instead"
                    },
                    {
                        "username": "julkar9",
                        "content": "My lawyer has advised me to not solve this question"
                    },
                    {
                        "username": "sheffy07_07",
                        "content": "ideally for[1,2,3,4] it should return {2,3} , but the answer is empty array. "
                    },
                    {
                        "username": "rhymes17",
                        "content": "Consider the fact that left side of the ith index must be decreasing and right side must be increasing.\nSo the given example [1,2,3,4], if you consider 3 as your ans, then left side is not decreasing, instead it is increasing. So it should return an empty array.\nFeel free to ask if you have any doubt.\nHappy Coding!"
                    },
                    {
                        "username": "Rounak_25",
                        "content": "for security=[1,2,3,4] and time=1, the ans should be[2,3] but it\\'s an empty array"
                    },
                    {
                        "username": "ayyush_sharma",
                        "content": "This Question is same as `2420. Find All Good Indices` on leetcode. :)\\n"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Has anyone solved it using sliding window? If yes, please share your solution!"
                    }
                ]
            },
            {
                "id": 2004577,
                "content": [
                    {
                        "username": "54k",
                        "content": "Okay, I don't need leetcode anymore to get a high paid job, I'll rob a bank at a good day instead"
                    },
                    {
                        "username": "julkar9",
                        "content": "My lawyer has advised me to not solve this question"
                    },
                    {
                        "username": "sheffy07_07",
                        "content": "ideally for[1,2,3,4] it should return {2,3} , but the answer is empty array. "
                    },
                    {
                        "username": "rhymes17",
                        "content": "Consider the fact that left side of the ith index must be decreasing and right side must be increasing.\nSo the given example [1,2,3,4], if you consider 3 as your ans, then left side is not decreasing, instead it is increasing. So it should return an empty array.\nFeel free to ask if you have any doubt.\nHappy Coding!"
                    },
                    {
                        "username": "Rounak_25",
                        "content": "for security=[1,2,3,4] and time=1, the ans should be[2,3] but it\\'s an empty array"
                    },
                    {
                        "username": "ayyush_sharma",
                        "content": "This Question is same as `2420. Find All Good Indices` on leetcode. :)\\n"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Has anyone solved it using sliding window? If yes, please share your solution!"
                    }
                ]
            },
            {
                "id": 1865398,
                "content": [
                    {
                        "username": "54k",
                        "content": "Okay, I don't need leetcode anymore to get a high paid job, I'll rob a bank at a good day instead"
                    },
                    {
                        "username": "julkar9",
                        "content": "My lawyer has advised me to not solve this question"
                    },
                    {
                        "username": "sheffy07_07",
                        "content": "ideally for[1,2,3,4] it should return {2,3} , but the answer is empty array. "
                    },
                    {
                        "username": "rhymes17",
                        "content": "Consider the fact that left side of the ith index must be decreasing and right side must be increasing.\nSo the given example [1,2,3,4], if you consider 3 as your ans, then left side is not decreasing, instead it is increasing. So it should return an empty array.\nFeel free to ask if you have any doubt.\nHappy Coding!"
                    },
                    {
                        "username": "Rounak_25",
                        "content": "for security=[1,2,3,4] and time=1, the ans should be[2,3] but it\\'s an empty array"
                    },
                    {
                        "username": "ayyush_sharma",
                        "content": "This Question is same as `2420. Find All Good Indices` on leetcode. :)\\n"
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Has anyone solved it using sliding window? If yes, please share your solution!"
                    }
                ]
            }
        ]
    },
    {
        "title": "Detonate the Maximum Bombs",
        "question_content": "<p>You are given a list of bombs. The <strong>range</strong> of a bomb is defined as the area where its effect can be felt. This area is in the shape of a <strong>circle</strong> with the center as the location of the bomb.</p>\n\n<p>The bombs are represented by a <strong>0-indexed</strong> 2D integer array <code>bombs</code> where <code>bombs[i] = [x<sub>i</sub>, y<sub>i</sub>, r<sub>i</sub>]</code>. <code>x<sub>i</sub></code> and <code>y<sub>i</sub></code> denote the X-coordinate and Y-coordinate of the location of the <code>i<sup>th</sup></code> bomb, whereas <code>r<sub>i</sub></code> denotes the <strong>radius</strong> of its range.</p>\n\n<p>You may choose to detonate a <strong>single</strong> bomb. When a bomb is detonated, it will detonate <strong>all bombs</strong> that lie in its range. These bombs will further detonate the bombs that lie in their ranges.</p>\n\n<p>Given the list of <code>bombs</code>, return <em>the <strong>maximum</strong> number of bombs that can be detonated if you are allowed to detonate <strong>only one</strong> bomb</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/06/desmos-eg-3.png\" style=\"width: 300px; height: 300px;\" />\n<pre>\n<strong>Input:</strong> bombs = [[2,1,3],[6,1,4]]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong>\nThe above figure shows the positions and ranges of the 2 bombs.\nIf we detonate the left bomb, the right bomb will not be affected.\nBut if we detonate the right bomb, both bombs will be detonated.\nSo the maximum bombs that can be detonated is max(1, 2) = 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/06/desmos-eg-2.png\" style=\"width: 300px; height: 300px;\" />\n<pre>\n<strong>Input:</strong> bombs = [[1,1,5],[10,10,5]]\n<strong>Output:</strong> 1\n<strong>Explanation:\n</strong>Detonating either bomb will not detonate the other bomb, so the maximum number of bombs that can be detonated is 1.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/11/07/desmos-eg1.png\" style=\"width: 300px; height: 300px;\" />\n<pre>\n<strong>Input:</strong> bombs = [[1,2,3],[2,3,1],[3,4,2],[4,5,3],[5,6,4]]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong>\nThe best bomb to detonate is bomb 0 because:\n- Bomb 0 detonates bombs 1 and 2. The red circle denotes the range of bomb 0.\n- Bomb 2 detonates bomb 3. The blue circle denotes the range of bomb 2.\n- Bomb 3 detonates bomb 4. The green circle denotes the range of bomb 3.\nThus all 5 bombs are detonated.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= bombs.length&nbsp;&lt;= 100</code></li>\n\t<li><code>bombs[i].length == 3</code></li>\n\t<li><code>1 &lt;= x<sub>i</sub>, y<sub>i</sub>, r<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1623311,
                "title": "python-simple-dfs-explained",
                "content": "In fact, this is graph proglem, starting with bomb, we need to traverse all bombs we can detonate and so on. Problem constraints allow us to just use bruteforce.\\n\\n#### Complexity\\nTime complexity is `O(n^3)`, because we start from `n` bombs and we can have upto `O(n^2)` edges.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def maximumDetonation(self, B):\\n        n, ans, G = len(B), 0, defaultdict(list)\\n        \\n        for i in range(n):\\n            for j in range(n):\\n                if i == j: continue\\n                if B[i][2]**2 >= (B[i][0] - B[j][0])**2 + (B[i][1] - B[j][1])**2:\\n                    G[i] += [j]\\n        \\n        \\n        def dfs(node, visited):\\n            for child in G[node]:\\n                if child not in visited:\\n                    visited.add(child)\\n                    dfs(child, visited)\\n\\n        for i in range(n):\\n            visited = set([i])\\n            dfs(i, visited)\\n            ans = max(ans, len(visited))\\n                          \\n        return ans\\n```\\n\\n#### Remark\\nThere is also `O(n^2)` solution: let us keep for each node set of nodes we can reach from this node: than we can recalculate it with usual dfs.\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def maximumDetonation(self, B):\\n        n, ans, G = len(B), 0, defaultdict(list)\\n        \\n        for i in range(n):\\n            for j in range(n):\\n                if i == j: continue\\n                if B[i][2]**2 >= (B[i][0] - B[j][0])**2 + (B[i][1] - B[j][1])**2:\\n                    G[i] += [j]\\n        \\n        \\n        def dfs(node, visited):\\n            for child in G[node]:\\n                if child not in visited:\\n                    visited.add(child)\\n                    dfs(child, visited)\\n\\n        for i in range(n):\\n            visited = set([i])\\n            dfs(i, visited)\\n            ans = max(ans, len(visited))\\n                          \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623333,
                "title": "bfs-or-dfs",
                "content": "We can represent bombs using a *directed* graph - when a bomb `i` can detonate bomb `j`, there is an edge from `i` to `j`. Note that the opposite may not be true.\\n\\nWe generate this graph (`al`), and, starting from each node, we run BFS (or DFS) and find out how many nodes we can reach.\\n\\n#### DFS\\nUsing a bitset boosted the runtime to 28 ms.\\n\\n**C++**\\n```cpp\\nint dfs(int i, vector<vector<int>> &al, bitset<100> &detonated) {\\n    if (!detonated[i]) {\\n        detonated[i] = true;\\n        for (int j : al[i])\\n            dfs(j, al, detonated);\\n    }\\n    return detonated.count();\\n}\\nint maximumDetonation(vector<vector<int>>& bs) {\\n    int res = 0, sz = bs.size();\\n    vector<vector<int>> al(bs.size());\\n    for (int i = 0; i < sz; ++i) {\\n        long long x = bs[i][0], y = bs[i][1], r2 = (long long)bs[i][2] * bs[i][2];\\n        for (int j = 0; j < bs.size(); ++j)\\n            if ((x - bs[j][0]) * (x - bs[j][0]) + (y - bs[j][1]) * (y - bs[j][1]) <= r2)\\n                al[i].push_back(j);\\n    }\\n    for (int i = 0; i < sz && res < sz; ++i)\\n        res = max(dfs(i, al, bitset<100>() = {}), res);\\n    return res;\\n}\\n```\\n\\n#### BFS\\n**C++**\\n```cpp\\nint maximumDetonation(vector<vector<int>>& bs) {\\n    int res = 0, sz = bs.size();\\n    vector<vector<int>> al(bs.size());\\n    for (int i = 0; i < sz; ++i) {\\n        long long x = bs[i][0], y = bs[i][1], r2 = (long long)bs[i][2] * bs[i][2];\\n        for (int j = 0; j < bs.size(); ++j)\\n            if ((x - bs[j][0]) * (x - bs[j][0]) + (y - bs[j][1]) * (y - bs[j][1]) <= r2)\\n                al[i].push_back(j);\\n    }\\n    for (int i = 0; i < sz && res < sz; ++i) {\\n        vector<int> q{i};\\n        unordered_set<int> detonated{i};\\n        while (!q.empty()) {\\n            vector<int> q1;\\n            for (int j : q)\\n                for (int k : al[j])\\n                    if (detonated.insert(k).second)\\n                        q1.push_back(k);\\n            swap(q, q1);\\n        }\\n        res = max((int)detonated.size(), res);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint dfs(int i, vector<vector<int>> &al, bitset<100> &detonated) {\\n    if (!detonated[i]) {\\n        detonated[i] = true;\\n        for (int j : al[i])\\n            dfs(j, al, detonated);\\n    }\\n    return detonated.count();\\n}\\nint maximumDetonation(vector<vector<int>>& bs) {\\n    int res = 0, sz = bs.size();\\n    vector<vector<int>> al(bs.size());\\n    for (int i = 0; i < sz; ++i) {\\n        long long x = bs[i][0], y = bs[i][1], r2 = (long long)bs[i][2] * bs[i][2];\\n        for (int j = 0; j < bs.size(); ++j)\\n            if ((x - bs[j][0]) * (x - bs[j][0]) + (y - bs[j][1]) * (y - bs[j][1]) <= r2)\\n                al[i].push_back(j);\\n    }\\n    for (int i = 0; i < sz && res < sz; ++i)\\n        res = max(dfs(i, al, bitset<100>() = {}), res);\\n    return res;\\n}\\n```\n```cpp\\nint maximumDetonation(vector<vector<int>>& bs) {\\n    int res = 0, sz = bs.size();\\n    vector<vector<int>> al(bs.size());\\n    for (int i = 0; i < sz; ++i) {\\n        long long x = bs[i][0], y = bs[i][1], r2 = (long long)bs[i][2] * bs[i][2];\\n        for (int j = 0; j < bs.size(); ++j)\\n            if ((x - bs[j][0]) * (x - bs[j][0]) + (y - bs[j][1]) * (y - bs[j][1]) <= r2)\\n                al[i].push_back(j);\\n    }\\n    for (int i = 0; i < sz && res < sz; ++i) {\\n        vector<int> q{i};\\n        unordered_set<int> detonated{i};\\n        while (!q.empty()) {\\n            vector<int> q1;\\n            for (int j : q)\\n                for (int k : al[j])\\n                    if (detonated.insert(k).second)\\n                        q1.push_back(k);\\n            swap(q, q1);\\n        }\\n        res = max((int)detonated.size(), res);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1624105,
                "title": "c-easy-to-understand-using-basic-dfs",
                "content": "```\\n\\nclass Solution {\\n#define ll long long int\\n    public:\\n    void dfs(vector<vector<int>> &graph,vector<bool> &visited,int &c,int &i)\\n    {\\n        visited[i]=true;\\n        c++;\\n        for(int j=0;j<graph[i].size();j++)\\n        {\\n            if(!visited[graph[i][j]])\\n             dfs(graph,visited,c,graph[i][j]);   \\n        }\\n    }\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n\\n        int n=bombs.size();\\n        vector<vector<int> > graph(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            ll x1,y1,r1;\\n            x1=bombs[i][0];\\n            y1=bombs[i][1];\\n            r1=bombs[i][2];\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i!=j)\\n                {\\n                     ll x2,y2,r2;\\n                     x2=abs(x1-bombs[j][0]);\\n                     y2=abs(y1-bombs[j][1]);\\n                    if(x2*x2+y2*y2<=r1*r1)\\n                    {\\n                        graph[i].push_back(j);\\n                    }\\n                }\\n            }\\n        }\\n        int ans=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            int c=0;\\n            vector<bool> visited(n,false);\\n            dfs(graph,visited,c,i);\\n            ans=max(ans,c);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\n\\nclass Solution {\\n#define ll long long int\\n    public:\\n    void dfs(vector<vector<int>> &graph,vector<bool> &visited,int &c,int &i)\\n    {\\n        visited[i]=true;\\n        c++;\\n        for(int j=0;j<graph[i].size();j++)\\n        {\\n            if(!visited[graph[i][j]])\\n             dfs(graph,visited,c,graph[i][j]);   \\n        }\\n    }\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n\\n        int n=bombs.size();\\n        vector<vector<int> > graph(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            ll x1,y1,r1;\\n            x1=bombs[i][0];\\n            y1=bombs[i][1];\\n            r1=bombs[i][2];\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i!=j)\\n                {\\n                     ll x2,y2,r2;\\n                     x2=abs(x1-bombs[j][0]);\\n                     y2=abs(y1-bombs[j][1]);\\n                    if(x2*x2+y2*y2<=r1*r1)\\n                    {\\n                        graph[i].push_back(j);\\n                    }\\n                }\\n            }\\n        }\\n        int ans=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            int c=0;\\n            vector<bool> visited(n,false);\\n            dfs(graph,visited,c,i);\\n            ans=max(ans,c);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623988,
                "title": "neat-code-java-dfs",
                "content": "```\\n public int maximumDetonation(int[][] bombs) {\\n        int n = bombs.length, ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            ans = Math.max(ans, dfs(i, new boolean[n], bombs));\\n        }\\n        return ans;\\n    }\\n\\n    private int dfs(int idx, boolean[] v, int[][] bombs) {\\n        int count = 1;\\n        v[idx] = true;\\n        int n = bombs.length;\\n        for (int i = 0; i < n; i++) {\\n            if (!v[i] && inRange(bombs[idx], bombs[i])) {\\n                count += dfs(i, v, bombs);\\n            }\\n        }\\n        return count;\\n    }\\n\\n    private boolean inRange(int[] a, int[] b) {\\n        long dx = a[0] - b[0], dy = a[1] - b[1], r = a[2];\\n        return dx * dx + dy * dy <= r * r;\\n    }\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n public int maximumDetonation(int[][] bombs) {\\n        int n = bombs.length, ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            ans = Math.max(ans, dfs(i, new boolean[n], bombs));\\n        }\\n        return ans;\\n    }\\n\\n    private int dfs(int idx, boolean[] v, int[][] bombs) {\\n        int count = 1;\\n        v[idx] = true;\\n        int n = bombs.length;\\n        for (int i = 0; i < n; i++) {\\n            if (!v[i] && inRange(bombs[idx], bombs[i])) {\\n                count += dfs(i, v, bombs);\\n            }\\n        }\\n        return count;\\n    }\\n\\n    private boolean inRange(int[] a, int[] b) {\\n        long dx = a[0] - b[0], dy = a[1] - b[1], r = a[2];\\n        return dx * dx + dy * dy <= r * r;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1623391,
                "title": "wrong-test-cases",
                "content": "For the input\\n```\\n[[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]\\n```\\nConsider the points at index 7 and 12\\n69, 51, 7\\n65, 59, 3\\n\\nGraphing them,\\n![image](https://assets.leetcode.com/users/images/ba9fa35f-c318-41cf-9bc4-0fc2a94d2af8_1639238833.236306.png)\\n\\nThe answer should be at least 2, however the judge tells 1.\\nAm I doing something wrong here?\\n",
                "solutionTags": [],
                "code": "```\\n[[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1897718,
                "title": "java-bfs-dfs-with-comments-easy",
                "content": "The main idea here is to take each bomb and check the number of bombs in its range. \\n\\n**BFS**: \\n\\n```\\n    public int maximumDetonation(int[][] bombs) {\\n        int max = 0;\\n        //iterate through each bomb and keep track of max\\n        for(int i = 0; i<bombs.length; i++){\\n            max = Math.max(max, getMaxBFS(bombs, i));    \\n        }\\n        return max;\\n    }\\n    \\n   private int getMaxBFS(int[][] bombs, int index){\\n        Queue<Integer> queue = new LinkedList<>();\\n        boolean[] seen = new boolean[bombs.length];\\n        \\n        seen[index] = true;\\n        queue.offer(index);\\n        \\n        int count = 1; // start from 1 since the first added bomb can detonate itself\\n        \\n        while(!queue.isEmpty()){\\n            int currBomb = queue.poll();\\n            for(int j = 0; j<bombs.length; j++){ //search for bombs to detonate\\n                if(!seen[j] && isInRange(bombs[currBomb], bombs[j])){\\n                    seen[j] = true;\\n                    count++;\\n                    queue.offer(j);\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    //use the distance between two points formula\\n    //then check if curr bomb radius is greater than the distance; meaning we can detonate the second bombs\\n    private boolean isInRange(int[] point1, int[] point2) {\\n        long dx = point1[0] - point2[0], dy = point1[1] - point2[1], radius = point1[2];\\n        long distance =  dx * dx + dy * dy;\\n        return distance <= radius * radius;\\n    }\\n```\\n\\n**DFS**: \\n\\n```\\n    public int maximumDetonation(int[][] bombs) {\\n        int max = 0;\\n        for (int i = 0; i < bombs.length; i++) {\\n            max = Math.max(max, getMaxDFS(i, bombs, new boolean[bombs.length]));\\n        }\\n        return max;\\n    }\\n\\n    private int getMaxDFS(int index, int[][] bombs, boolean[] seen) {\\n        int count = 1;\\n        seen[index] = true;\\n\\n        for (int i = 0; i < bombs.length; i++) {\\n            if (!seen[i] && isInRange(bombs[index], bombs[i])) {\\n                count += getMaxDFS(i, bombs, seen);\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    private boolean isInRange(int[] point1, int[] point2) {\\n        long dx = point1[0] - point2[0], dy = point1[1] - point2[1], radius = point1[2];\\n        long distance = dx * dx + dy * dy;\\n        return distance <= radius * radius;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n    public int maximumDetonation(int[][] bombs) {\\n        int max = 0;\\n        //iterate through each bomb and keep track of max\\n        for(int i = 0; i<bombs.length; i++){\\n            max = Math.max(max, getMaxBFS(bombs, i));    \\n        }\\n        return max;\\n    }\\n    \\n   private int getMaxBFS(int[][] bombs, int index){\\n        Queue<Integer> queue = new LinkedList<>();\\n        boolean[] seen = new boolean[bombs.length];\\n        \\n        seen[index] = true;\\n        queue.offer(index);\\n        \\n        int count = 1; // start from 1 since the first added bomb can detonate itself\\n        \\n        while(!queue.isEmpty()){\\n            int currBomb = queue.poll();\\n            for(int j = 0; j<bombs.length; j++){ //search for bombs to detonate\\n                if(!seen[j] && isInRange(bombs[currBomb], bombs[j])){\\n                    seen[j] = true;\\n                    count++;\\n                    queue.offer(j);\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    //use the distance between two points formula\\n    //then check if curr bomb radius is greater than the distance; meaning we can detonate the second bombs\\n    private boolean isInRange(int[] point1, int[] point2) {\\n        long dx = point1[0] - point2[0], dy = point1[1] - point2[1], radius = point1[2];\\n        long distance =  dx * dx + dy * dy;\\n        return distance <= radius * radius;\\n    }\\n```\n```\\n    public int maximumDetonation(int[][] bombs) {\\n        int max = 0;\\n        for (int i = 0; i < bombs.length; i++) {\\n            max = Math.max(max, getMaxDFS(i, bombs, new boolean[bombs.length]));\\n        }\\n        return max;\\n    }\\n\\n    private int getMaxDFS(int index, int[][] bombs, boolean[] seen) {\\n        int count = 1;\\n        seen[index] = true;\\n\\n        for (int i = 0; i < bombs.length; i++) {\\n            if (!seen[i] && isInRange(bombs[index], bombs[i])) {\\n                count += getMaxDFS(i, bombs, seen);\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    private boolean isInRange(int[] point1, int[] point2) {\\n        long dx = point1[0] - point2[0], dy = point1[1] - point2[1], radius = point1[2];\\n        long distance = dx * dx + dy * dy;\\n        return distance <= radius * radius;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1658366,
                "title": "intuition-explained-graph-dfs-based-approach-c-clean-code",
                "content": "**Intuition :**\\n\\n* Idea here is to first create a graph, such that there is a edge between two bombs `i` and `j`,\\n\\n\\t* if when we detonate `ith` bomb, then `jth bomb` lies within its **proximity** (as given in problem stmt),\\n\\t* i.e iff **`distance between centers <= radius of ith bomb`**\\n* To create graph, simply we need to loop over `bombs` list, and then for each `bomb i`, \\n\\t* we need to check if a `bomb j` lies withing its **proximity**. \\n\\t* In this way we will create `deto_adj`, where `deto_adj[i]` is list of all bombs that lie in its proximity\\n\\n\\t\\t\\tEx : say we have i = 2, n = 4. Also, say j = 0, 3 are nodes that lie within its proximity\\n\\t\\t\\t\\n\\t\\t\\t# 2 -> 0, 3\\n\\t\\t\\t\\n\\t\\t\\tThen, deto_adj[i] = deto_adj[2] = {0, 3} \\n\\t\\t\\t\\n\\t\\t\\tNote: This is a directed edge. \\n\\t\\t\\t\\n\\t\\t\\t\\n* So, once we have our graph [adjacency list], next for each bomb in `bombs` list, simply do a **DFS (or BFS)**, and \\n\\t* ***count the number of bombs (nodes) it can visit.***\\n* In then end we need to return the maximum count among all the bombs.\\n\\n------------------\\n# Code : DFS Approach\\n\\n```\\nclass Solution {\\npublic:\\n    \\n\\t// Check if (x2, y2) lie within the proximity of (x1, y1)\\n    bool check(long long x1, long long y1, long long x2, long long y2, long long d) {\\n        long long x = (x1-x2) * (x1-x2);\\n        long long y = (y1-y2) * (y1-y2);\\n        \\n        return (x + y  <= d * d);\\n    }\\n    \\n\\t// DFS to detonate \"node\" , and count number of other nodes \\n\\t// that can be detonated (visited) from currernt node.\\n    int detonate(vector<vector<int>>& adj, vector<bool>& vis, int node, int n) {\\n        \\n        int count = 1;\\n        vis[node] = true;\\n        \\n        for(auto& adjnode : adj[node]) {\\n            if(!vis[adjnode]) {\\n                count += detonate(adj, vis, adjnode, n);\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        \\n        int n = bombs.size();\\n        \\n        int maxBombs = 0;\\n        \\n\\t\\t// Adjacency list to store all edges for nodes [0, n-1]\\n\\t\\t// i.e all bombs that lie within proximity of node\\n        vector<vector<int>> deto_adj(n);\\n        \\n\\t\\t// Create graph by connecting directed edges\\n\\t\\t// Between ith and jth node\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(i != j && check(bombs[i][0], bombs[i][1], bombs[j][0], bombs[j][1], bombs[i][2])) {\\n                    deto_adj[i].push_back(j);\\n                }  \\n            }\\n        }\\n        \\n\\t\\t// For each bomb, do simple DFS (detonate)\\n\\t\\t// And get count of nodes that can be visited from current node\\t\\t\\n        for(int i=0; i<n; i++) {\\n            vector<bool> vis(n, false);\\n            \\n\\t\\t\\t// Also update maximum count\\n            maxBombs = max(maxBombs, detonate(deto_adj, vis, i, n));\\n        }\\n        \\n        return maxBombs;\\n    }\\n};\\n```\\n\\nNote: Instead of DFS, you can also use BFS. Both approach is correct.\\n\\n------------------\\n\\n**Complexity :** \\n\\n* Time : `O(N * N)` , N is number of bombs\\n\\t* To create `deto_adj` \\n\\t* And then for each bomb node, perform DFS\\n\\n* Space : `~ O(N * N)`, to create adjacency list\\n\\n***If you find this helpful, do give it a like : )***",
                "solutionTags": [
                    "Math",
                    "Depth-First Search",
                    "Graph",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\t// Check if (x2, y2) lie within the proximity of (x1, y1)\\n    bool check(long long x1, long long y1, long long x2, long long y2, long long d) {\\n        long long x = (x1-x2) * (x1-x2);\\n        long long y = (y1-y2) * (y1-y2);\\n        \\n        return (x + y  <= d * d);\\n    }\\n    \\n\\t// DFS to detonate \"node\" , and count number of other nodes \\n\\t// that can be detonated (visited) from currernt node.\\n    int detonate(vector<vector<int>>& adj, vector<bool>& vis, int node, int n) {\\n        \\n        int count = 1;\\n        vis[node] = true;\\n        \\n        for(auto& adjnode : adj[node]) {\\n            if(!vis[adjnode]) {\\n                count += detonate(adj, vis, adjnode, n);\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        \\n        int n = bombs.size();\\n        \\n        int maxBombs = 0;\\n        \\n\\t\\t// Adjacency list to store all edges for nodes [0, n-1]\\n\\t\\t// i.e all bombs that lie within proximity of node\\n        vector<vector<int>> deto_adj(n);\\n        \\n\\t\\t// Create graph by connecting directed edges\\n\\t\\t// Between ith and jth node\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(i != j && check(bombs[i][0], bombs[i][1], bombs[j][0], bombs[j][1], bombs[i][2])) {\\n                    deto_adj[i].push_back(j);\\n                }  \\n            }\\n        }\\n        \\n\\t\\t// For each bomb, do simple DFS (detonate)\\n\\t\\t// And get count of nodes that can be visited from current node\\t\\t\\n        for(int i=0; i<n; i++) {\\n            vector<bool> vis(n, false);\\n            \\n\\t\\t\\t// Also update maximum count\\n            maxBombs = max(maxBombs, detonate(deto_adj, vis, i, n));\\n        }\\n        \\n        return maxBombs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623797,
                "title": "c-simple-bfs-faster-than-100",
                "content": "**CODE**\\n```\\nclass Solution {\\npublic:\\n    \\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        ios::sync_with_stdio(false); cin.tie(NULL);\\n\\t\\t\\n        const int n = bombs.size();\\n\\t\\t\\n        vector<vector<int>>v(n);\\n        \\n        for(int i = 0; i < n; i++) {\\n            long long r = (long long)bombs[i][2] * bombs[i][2];\\n            for(int j = 0; j < n; j++) {\\n                if(i != j){\\n                    if((long long)((long long)bombs[i][0]-bombs[j][0]) * ((long long)bombs[i][0]-bombs[j][0])+(long long)(bombs[i][1]-bombs[j][1]) * ((long long)bombs[i][1]-bombs[j][1]) <= r){\\n                       v[i].push_back(j);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int ans = 1;\\n        // try each bomb and choose that which contributes maximum detonation.\\n        for(int i = 0; i < n; i++){\\n            vector<bool>vis(n, 0);\\n            int mx = 0;\\n            \\n\\t\\t\\tqueue<int>q;\\n            q.push(i);\\n\\t\\t\\t\\n            while(!q.empty()) {\\n                int s = q.size();\\n                for(int i = 0; i < s; i++) {\\n                    int x = q.front();\\n                    q.pop();\\n                    vis[x] = 1;\\n                    mx++;\\n                    for(auto p : v[x]) {\\n                        if(!vis[p]) {\\n                            q.push(p);\\n                            vis[p] = 1;\\n                        }\\n                    }\\n                }\\n            }\\n            ans = max(ans, mx);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Useful Problem link**\\nhttps://leetcode.com/problems/queries-on-number-of-points-inside-a-circle/\\n\\n**Do Upvote if you like the solution**",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        ios::sync_with_stdio(false); cin.tie(NULL);\\n\\t\\t\\n        const int n = bombs.size();\\n\\t\\t\\n        vector<vector<int>>v(n);\\n        \\n        for(int i = 0; i < n; i++) {\\n            long long r = (long long)bombs[i][2] * bombs[i][2];\\n            for(int j = 0; j < n; j++) {\\n                if(i != j){\\n                    if((long long)((long long)bombs[i][0]-bombs[j][0]) * ((long long)bombs[i][0]-bombs[j][0])+(long long)(bombs[i][1]-bombs[j][1]) * ((long long)bombs[i][1]-bombs[j][1]) <= r){\\n                       v[i].push_back(j);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int ans = 1;\\n        // try each bomb and choose that which contributes maximum detonation.\\n        for(int i = 0; i < n; i++){\\n            vector<bool>vis(n, 0);\\n            int mx = 0;\\n            \\n\\t\\t\\tqueue<int>q;\\n            q.push(i);\\n\\t\\t\\t\\n            while(!q.empty()) {\\n                int s = q.size();\\n                for(int i = 0; i < s; i++) {\\n                    int x = q.front();\\n                    q.pop();\\n                    vis[x] = 1;\\n                    mx++;\\n                    for(auto p : v[x]) {\\n                        if(!vis[p]) {\\n                            q.push(p);\\n                            vis[p] = 1;\\n                        }\\n                    }\\n                }\\n            }\\n            ans = max(ans, mx);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1627189,
                "title": "intuition-explained-can-simple-dfs-be-further-optimized",
                "content": "**NOTE: One Bomb can detonate other if and only if the other bomb lies within the area covered by the Bomb.**\\n\\n![image](https://assets.leetcode.com/users/images/f3110632-4cc7-4461-917b-489c8bc8b2e9_1639405880.1813633.png)\\n\\n![image](https://assets.leetcode.com/users/images/094a740b-d884-49af-be24-12b298167b9c_1639407042.709457.png)\\n\\n![image](https://assets.leetcode.com/users/images/a6f31a54-89db-401b-a12a-8f0326056bf4_1639408158.857844.png)\\n\\n```\\nclass Solution {\\npublic:\\n    double calcDis(int& x1, int& y1, int& x2, int& y2){\\n        \\n        long double dis = sqrtl(1LL * (x1-x2)*(x1-x2) + 1LL * (y1-y2)*(y1-y2));\\n        \\n        return dis;\\n    }\\n    \\n    void dfs(int node, vector<int>& visited,int& thisPathBombs, vector<int> canDetonate[]){\\n        \\n        visited[node] = 1;\\n        thisPathBombs++;\\n        \\n        for(int i=0;i<canDetonate[node].size();i++){\\n            \\n            int cnode = canDetonate[node][i];\\n            \\n            if(visited[cnode] == -1){\\n                dfs(cnode,visited,thisPathBombs,canDetonate);\\n            }\\n        }\\n    }\\n    \\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        \\n        int n = bombs.size();\\n        \\n        vector<int> canDetonate[n];\\n        \\n        int mxBombs = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                double dis = calcDis(bombs[i][0],bombs[i][1],bombs[j][0],bombs[j][1]);\\n                double d1 = bombs[i][2] * 1.0;\\n                double d2 = bombs[j][2] * 1.0;\\n                \\n                if(dis <= d1){\\n                    canDetonate[i].push_back(j);\\n                }\\n                \\n                if(dis <= d2){\\n                    canDetonate[j].push_back(i);\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++) {\\n            int thisPathBombs = 0;\\n            vector<int> visited(n,-1);\\n            dfs(i,visited,thisPathBombs,canDetonate);\\n            mxBombs = max(mxBombs, thisPathBombs);\\n        }\\n        \\n        return mxBombs;\\n    }\\n};\\n```\\n\\n**Here we are running dfs for every node for multiple times.**\\n\\n![image](https://assets.leetcode.com/users/images/15b06225-569e-4f44-aca3-eb6d5bf70a51_1639408208.1803577.png)\\n\\n![image](https://assets.leetcode.com/users/images/3598d97d-4c55-4949-b913-7c1bac856242_1639408657.9182005.png)\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double calcDis(int& x1, int& y1, int& x2, int& y2){\\n        \\n        long double dis = sqrtl(1LL * (x1-x2)*(x1-x2) + 1LL * (y1-y2)*(y1-y2));\\n        \\n        return dis;\\n    }\\n    \\n    void dfs(int node, vector<int>& visited,int& thisPathBombs, vector<int> canDetonate[]){\\n        \\n        visited[node] = 1;\\n        thisPathBombs++;\\n        \\n        for(int i=0;i<canDetonate[node].size();i++){\\n            \\n            int cnode = canDetonate[node][i];\\n            \\n            if(visited[cnode] == -1){\\n                dfs(cnode,visited,thisPathBombs,canDetonate);\\n            }\\n        }\\n    }\\n    \\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        \\n        int n = bombs.size();\\n        \\n        vector<int> canDetonate[n];\\n        \\n        int mxBombs = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                double dis = calcDis(bombs[i][0],bombs[i][1],bombs[j][0],bombs[j][1]);\\n                double d1 = bombs[i][2] * 1.0;\\n                double d2 = bombs[j][2] * 1.0;\\n                \\n                if(dis <= d1){\\n                    canDetonate[i].push_back(j);\\n                }\\n                \\n                if(dis <= d2){\\n                    canDetonate[j].push_back(i);\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++) {\\n            int thisPathBombs = 0;\\n            vector<int> visited(n,-1);\\n            dfs(i,visited,thisPathBombs,canDetonate);\\n            mxBombs = max(mxBombs, thisPathBombs);\\n        }\\n        \\n        return mxBombs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2698106,
                "title": "a-similar-question-asked-in-my-google-phone-interview-read-for-more",
                "content": "Solving this one saved me in my google phone interview. I\\'ve put the details of the interview here:\\nhttps://freezefrancis.medium.com/google-phone-interview-experience-a75c2d0e0080",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1799195,
                "title": "c-dfs-intuition-and-code-explained",
                "content": "### Explanation\\nThe intuition is to keep checking the bombs we can detonate if we start from the i-th bomb. The conditions for detonation are:\\n1. The bomb shouldn\\'t be visited before (Except if that is the starting point).\\n2. The distance between two points should be less than radius of the previous bomb, i.e, (x1-x2) * (y1-y2) <= r * r \\n\\nI have kept a visited array for every bomb and ans stores the maximum count. \\n\\n\\n\\n**Please upvote if this post helped you!** If you have any queries, you can comment below. I would be happy to help!\\n\\n### Code\\n```\\nclass Solution {\\npublic:\\n    bool check(long long x1,long long  x2, long long  y1,long long  y2,long long  r)\\n    {\\n        long long x=(x1-x2)*(x1-x2), y=(y1-y2)*(y1-y2); \\n        return x+y<=r*r; //using the distance formula\\n    }\\n    \\n    void help(vector<vector<int>>& bombs,vector<bool>& vis,int j, int& count){\\n        if(vis[j])return; //if we have already detonated this bomb \\n        \\n        count++;\\n        vis[j]=true;\\n        int x1=bombs[j][0], y1=bombs[j][1], r=bombs[j][2];\\n        \\n        for(int i=0;i<bombs.size();i++){\\n            int x2=bombs[i][0], y2=bombs[i][1];\\n            if(!vis[i] && check(x1,x2,y1,y2,r)) //check if this bomb can be detonated using the previous bomb\\n            help(bombs,vis,i,count);\\n        }\\n    }\\n    \\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n=bombs.size();\\n        int ans=INT_MIN;\\n        \\n        for(int i=0;i<n;i++){\\n            int count=0; \\n            vector<bool>visited(n,false);  // a visted array to keep track of the bombs already reached in the current sequence\\n            help(bombs,visited,i,count);\\n            ans=max(ans,count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(long long x1,long long  x2, long long  y1,long long  y2,long long  r)\\n    {\\n        long long x=(x1-x2)*(x1-x2), y=(y1-y2)*(y1-y2); \\n        return x+y<=r*r; //using the distance formula\\n    }\\n    \\n    void help(vector<vector<int>>& bombs,vector<bool>& vis,int j, int& count){\\n        if(vis[j])return; //if we have already detonated this bomb \\n        \\n        count++;\\n        vis[j]=true;\\n        int x1=bombs[j][0], y1=bombs[j][1], r=bombs[j][2];\\n        \\n        for(int i=0;i<bombs.size();i++){\\n            int x2=bombs[i][0], y2=bombs[i][1];\\n            if(!vis[i] && check(x1,x2,y1,y2,r)) //check if this bomb can be detonated using the previous bomb\\n            help(bombs,vis,i,count);\\n        }\\n    }\\n    \\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n=bombs.size();\\n        int ans=INT_MIN;\\n        \\n        for(int i=0;i<n;i++){\\n            int count=0; \\n            vector<bool>visited(n,false);  // a visted array to keep track of the bombs already reached in the current sequence\\n            help(bombs,visited,i,count);\\n            ans=max(ans,count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851600,
                "title": "python-bfs-dfs-and-why-union-find-is-not-the-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy initial intuition was union-find because it seems to find out the maximum RANK of the largest group. After a few trial and error, I figured out that union-find is only for undirected graph. So, I decided to solve this problem with typical BFS, DFS, DFS-Recursive approach.  \\n\\n[Example]\\nthere are three points\\npoint 1 is located at x=2 with radius 5\\npoint 2 is located at x=5 with radius 1\\npoint 3 is located at x=10 with radius 6\\n\\nunion-find approach will build those three points as a graph. (max rank = 3)\\nbut, in this scenario, the max value is 2 because the point 2 cannot detonate any bomb.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n0. Building adjacency list\\n1. BFS with deque\\n2. DFS with stack\\n3. DFS with recursion\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(V + E)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(V)\\n# Code\\n```\\nclass Solution:\\n    def maximumDetonation(self, bombs: List[List[int]]) -> int:\\n\\n        def is_connected(a,b):\\n            x1, y1, r1 = bombs[a]\\n            x2, y2, r2 = bombs[b]\\n            dist = math.sqrt((x1-x2)**2 + (y1-y2)**2)\\n            return dist <= r1\\n\\n\\n        conn = collections.defaultdict(list)\\n        for i in range(len(bombs)):\\n            for j in range(len(bombs)):\\n                if i != j:\\n                    if is_connected(i,j):\\n                        conn[i].append(j)\\n\\n        # 1. BFS\\n        # q = collections.deque()\\n        # maxCount = float(\\'-inf\\')\\n\\n        # for node in range(len(bombs)):\\n        #     if conn[node]:\\n        #         q.append(node)\\n        #         visited = set()\\n        #         visited.add(node)\\n        #         count = 0\\n        #         while q:\\n        #             curr = q.popleft()\\n        #             count+=1\\n        #             maxCount = max(maxCount, count)\\n        #             for child in conn[curr]:\\n        #                 if child not in visited:\\n        #                     visited.add(child)\\n        #                     q.append(child)\\n\\n        # return maxCount if maxCount != float(\\'-inf\\') else 1\\n\\n\\n        # 2. DFS\\n\\n        # stack = []\\n        # maxCount = float(\\'-inf\\')\\n\\n        # for node in range(len(bombs)):\\n        #     if conn[node]:\\n        #         visited = set()\\n        #         stack.append(node)\\n        #         visited.add(node)\\n        #         count = 0\\n        #         while stack:\\n\\n        #             curr = stack.pop()\\n        #             count+=1\\n        #             maxCount = max(maxCount, count)\\n\\n        #             for child in conn[curr]:\\n        #                 if child not in visited:\\n        #                     visited.add(child)\\n        #                     stack.append(child)\\n        # return maxCount if maxCount != float(\\'-inf\\') else 1\\n\\n\\n        # 3. DFS recursive                \\n                    \\n        def dfs(node):\\n\\n            if node in visited:\\n                return 0\\n\\n            visited.add(node)\\n            \\n            ans = 1\\n\\n            if node in conn:\\n                for child in conn[node]:\\n                    if child in visited:\\n                        continue\\n                    ans += dfs(child)\\n            \\n            return ans \\n\\n        maxCount = 1\\n        for node in conn:\\n            visited = set()\\n            maxCount = max(maxCount, dfs(node))\\n        return maxCount\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumDetonation(self, bombs: List[List[int]]) -> int:\\n\\n        def is_connected(a,b):\\n            x1, y1, r1 = bombs[a]\\n            x2, y2, r2 = bombs[b]\\n            dist = math.sqrt((x1-x2)**2 + (y1-y2)**2)\\n            return dist <= r1\\n\\n\\n        conn = collections.defaultdict(list)\\n        for i in range(len(bombs)):\\n            for j in range(len(bombs)):\\n                if i != j:\\n                    if is_connected(i,j):\\n                        conn[i].append(j)\\n\\n        # 1. BFS\\n        # q = collections.deque()\\n        # maxCount = float(\\'-inf\\')\\n\\n        # for node in range(len(bombs)):\\n        #     if conn[node]:\\n        #         q.append(node)\\n        #         visited = set()\\n        #         visited.add(node)\\n        #         count = 0\\n        #         while q:\\n        #             curr = q.popleft()\\n        #             count+=1\\n        #             maxCount = max(maxCount, count)\\n        #             for child in conn[curr]:\\n        #                 if child not in visited:\\n        #                     visited.add(child)\\n        #                     q.append(child)\\n\\n        # return maxCount if maxCount != float(\\'-inf\\') else 1\\n\\n\\n        # 2. DFS\\n\\n        # stack = []\\n        # maxCount = float(\\'-inf\\')\\n\\n        # for node in range(len(bombs)):\\n        #     if conn[node]:\\n        #         visited = set()\\n        #         stack.append(node)\\n        #         visited.add(node)\\n        #         count = 0\\n        #         while stack:\\n\\n        #             curr = stack.pop()\\n        #             count+=1\\n        #             maxCount = max(maxCount, count)\\n\\n        #             for child in conn[curr]:\\n        #                 if child not in visited:\\n        #                     visited.add(child)\\n        #                     stack.append(child)\\n        # return maxCount if maxCount != float(\\'-inf\\') else 1\\n\\n\\n        # 3. DFS recursive                \\n                    \\n        def dfs(node):\\n\\n            if node in visited:\\n                return 0\\n\\n            visited.add(node)\\n            \\n            ans = 1\\n\\n            if node in conn:\\n                for child in conn[node]:\\n                    if child in visited:\\n                        continue\\n                    ans += dfs(child)\\n            \\n            return ans \\n\\n        maxCount = 1\\n        for node in conn:\\n            visited = set()\\n            maxCount = max(maxCount, dfs(node))\\n        return maxCount\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623297,
                "title": "python-bfs-dfs-start-with-every-point-explanation",
                "content": "If the distance between `bombs[i]` and `bombs[j]` is smaller than or equal to the `radius` of `bombs[i]`, then we can detonate `bombs[j]` with `bombs[i]`. This relationship can be viewed as an edge `i -> j`.\\n\\nWe can enumerate all bomb pairs to construct a directed graph with these detonation relationships. And then we start with every bomb, use BFS / DFS to find how many bombs that we can reach.\\n\\nTime Complexity:\\n* Construct Graph: `O(N ** 2)`\\n* DFS / BFS (one time) is `O(N ** 2)` since there are at most `O(N ** 2)` edges in the constructed graph. We do BFS `N` times, so the worst complexity is `O(N ** 3)`.\\n\\n```python\\nclass Solution:\\n    def maximumDetonation(self, bombs: List[List[int]]) -> int:\\n        \\n        N = len(bombs)\\n        \\n        # construct directed graph\\n        G = defaultdict(list)\\n        for i in range(N):\\n            for j in range(N):\\n                if i == j:\\n                    continue\\n                bi = bombs[i]\\n                bj = bombs[j]\\n                if (bi[0] - bj[0]) ** 2 + (bi[1] - bj[1]) ** 2 <= bi[2] ** 2:\\n                    G[i].append(j)\\n\\n        # apply DFS with every bomb as start point\\n        max_ans = 1\\n        for start in range(N):\\n            queue = [start]\\n            visited = set([start])\\n            this_ans = 0\\n            while queue:\\n                pos = queue.pop()\\n                this_ans += 1\\n                for neib in G[pos]:\\n                    if neib not in visited:\\n                        queue.append(neib)\\n                        visited.add(neib)\\n            max_ans = max(this_ans, max_ans)\\n            if max_ans == N:\\n                return N\\n        return max_ans\\n```\\n\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maximumDetonation(self, bombs: List[List[int]]) -> int:\\n        \\n        N = len(bombs)\\n        \\n        # construct directed graph\\n        G = defaultdict(list)\\n        for i in range(N):\\n            for j in range(N):\\n                if i == j:\\n                    continue\\n                bi = bombs[i]\\n                bj = bombs[j]\\n                if (bi[0] - bj[0]) ** 2 + (bi[1] - bj[1]) ** 2 <= bi[2] ** 2:\\n                    G[i].append(j)\\n\\n        # apply DFS with every bomb as start point\\n        max_ans = 1\\n        for start in range(N):\\n            queue = [start]\\n            visited = set([start])\\n            this_ans = 0\\n            while queue:\\n                pos = queue.pop()\\n                this_ans += 1\\n                for neib in G[pos]:\\n                    if neib not in visited:\\n                        queue.append(neib)\\n                        visited.add(neib)\\n            max_ans = max(this_ans, max_ans)\\n            if max_ans == N:\\n                return N\\n        return max_ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619930,
                "title": "explained-simple-and-clear-python3-code",
                "content": "# Intuition\\nThe given problem involves determining the maximum number of bombs that can be detonated if you are allowed to detonate only one bomb. The bombs are represented as a list of 2D integer arrays, where each array contains the X-coordinate, Y-coordinate, and radius of a bomb.\\n\\n\\n# Approach\\nTo solve this problem, the provided solution uses a depth-first search (DFS) approach. It first initializes an empty list called \"connected\" to store the connections between the bombs. Each index in the \"connected\" list represents a bomb, and the corresponding value is a list of indices of other bombs that can be detonated if the bomb at that index is detonated.\\n\\nNext, the solution iterates through each bomb and checks its range against the ranges of other bombs. If the range of the current bomb overlaps with the range of another bomb, it adds the index of the other bomb to the \"connected\" list for the current bomb.\\n\\nAfter creating the \"connected\" list, the solution initializes an empty list called \"res\" to store the results. It also initializes an empty list called \"visited\" to keep track of the bombs that have been visited during the DFS.\\n\\nThen, for each bomb, the solution performs a DFS starting from that bomb\\'s index. During the DFS, it visits all the connected bombs and adds them to the \"visited\" list. After completing the DFS, it appends the length of the \"visited\" list to the \"res\" list.\\n\\nFinally, the solution returns the maximum value in the \"res\" list, which represents the maximum number of bombs that can be detonated if you are allowed to detonate only one bomb.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution depends on the number of bombs, denoted as \"n\". The creation of the \"connected\" list takes O(n^2) time since it involves comparing each bomb\\'s range with the ranges of other bombs. The DFS step is performed for each bomb, resulting in a time complexity of O(n^2) as well. Therefore, the overall time complexity is O(n^2).\\n\\n\\n- Space complexity:\\nThe space complexity of this solution is O(n^2) since the \"connected\" list stores connections for each bomb. Additionally, the \"res\" list and the \"visited\" list can each store up to n elements. Therefore, the overall space complexity is O(n^2).\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumDetonation(self, bombs: List[List[int]]) -> int:\\n        n=len(bombs)\\n        connected=[ [] for i in range(n)]\\n\\n        for i in range(n):\\n            sm=[]\\n            for j in range(n):\\n                if j!=i:\\n                    xi, yi, ri = bombs[i]\\n                    xj, yj, _ = bombs[j]\\n                    if ri ** 2 >= (xi - xj) ** 2 + (yi - yj) ** 2:\\n                        sm.append(j)\\n            connected[i]=sm\\n        \\n        res=[]\\n\\n        visited=[]\\n        def dfs(i:int):\\n\\n            if i not in visited:\\n                visited.append(i)\\n                for j in connected[i]:\\n                    dfs(j)\\n                \\n\\n        for i in range(n):\\n            visited.append(i)\\n            for j in connected[i]:\\n                dfs(j)\\n            res.append(len(visited))\\n            visited.clear()\\n\\n        return max(res)\\n        \\n \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumDetonation(self, bombs: List[List[int]]) -> int:\\n        n=len(bombs)\\n        connected=[ [] for i in range(n)]\\n\\n        for i in range(n):\\n            sm=[]\\n            for j in range(n):\\n                if j!=i:\\n                    xi, yi, ri = bombs[i]\\n                    xj, yj, _ = bombs[j]\\n                    if ri ** 2 >= (xi - xj) ** 2 + (yi - yj) ** 2:\\n                        sm.append(j)\\n            connected[i]=sm\\n        \\n        res=[]\\n\\n        visited=[]\\n        def dfs(i:int):\\n\\n            if i not in visited:\\n                visited.append(i)\\n                for j in connected[i]:\\n                    dfs(j)\\n                \\n\\n        for i in range(n):\\n            visited.append(i)\\n            for j in connected[i]:\\n                dfs(j)\\n            res.append(len(visited))\\n            visited.clear()\\n\\n        return max(res)\\n        \\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588082,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this problem, we are given a list of bombs represented by their coordinates (x and y) and the explosion radius. The task is to determine the maximum number of bombs that can be detonated by starting with any bomb and detonating all other bombs within its explosion range.\\n\\nImagine each bomb as a node in a graph. If two bombs are within range of each other, we can consider an edge between the corresponding nodes. The objective is to find the connected component with the maximum number of nodes, as it represents the maximum detonation possible.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo solve this problem, we can follow these steps:\\n\\n1. Initialize an adjacency list to represent the connections between bombs.\\n2. Iterate over each bomb and calculate the squared explosion radius (r).\\n3. Compare the squared Euclidean distance between each pair of bombs. If it is less than or equal to r, add an edge between them in the adjacency list.\\n4. Initialize a variable to keep track of the maximum detonation count (ans).\\n5. For each bomb, perform a BFS starting from that bomb to find the number of bombs that can be detonated.\\n6. Maintain a queue and a visited array during the BFS.\\n7. Start BFS from the current bomb by adding it to the queue and marking it as visited.\\n8. While the queue is not empty, process the front element, increment the detonation count, and visit its adjacent bombs if they haven\\'t been visited before.\\n9. Update the maximum detonation count if the current count is greater.\\n10. Repeat steps 5-9 for each bomb.\\n11. Return the maximum detonation count as the result.\\n\\nBy representing the bombs as nodes in a graph and performing a BFS traversal, we can identify the connected component with the maximum number of nodes, which corresponds to the maximum detonation count.\\n\\n\\n\\n# Complexity\\n- Time complexity: O(N^3)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) \\n    {\\n        const int n = bombs.size();\\n        vector<vector<int>> v(n);\\n\\n        for (int i = 0; i < n; i++) \\n        {\\n            long long r = (long long) bombs[i][2] * bombs[i][2];\\n            for (int j = 0; j < n; j++) \\n            {\\n                if (i != j) \\n                {\\n                    if ((long long) ((long long) bombs[i][0] - bombs[j][0]) * ((long long) bombs[i][0] - bombs[j][0]) + \\n                        (long long) (bombs[i][1] - bombs[j][1]) * ((long long) bombs[i][1] - bombs[j][1]) <= r) \\n                    {\\n                        v[i].push_back(j);\\n                    }\\n                }\\n            }\\n        }\\n\\n        int ans = 1;\\n        for (int i = 0; i < n; i++) \\n        {\\n            vector<bool> vis(n, false);\\n            int mx = 0;\\n            queue<int> q;\\n            q.push(i);\\n\\n            while (!q.empty()) \\n            {\\n                int s = q.size();\\n                for (int j = 0; j < s; j++) \\n                {\\n                    int x = q.front();\\n                    q.pop();\\n                    vis[x] = true;\\n                    mx++;\\n                    for (auto p : v[x]) \\n                    {\\n                        if (!vis[p]) {\\n                            q.push(p);\\n                            vis[p] = true;\\n                        }\\n                    }\\n                }\\n            }\\n            ans = max(ans, mx);\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) \\n    {\\n        const int n = bombs.size();\\n        vector<vector<int>> v(n);\\n\\n        for (int i = 0; i < n; i++) \\n        {\\n            long long r = (long long) bombs[i][2] * bombs[i][2];\\n            for (int j = 0; j < n; j++) \\n            {\\n                if (i != j) \\n                {\\n                    if ((long long) ((long long) bombs[i][0] - bombs[j][0]) * ((long long) bombs[i][0] - bombs[j][0]) + \\n                        (long long) (bombs[i][1] - bombs[j][1]) * ((long long) bombs[i][1] - bombs[j][1]) <= r) \\n                    {\\n                        v[i].push_back(j);\\n                    }\\n                }\\n            }\\n        }\\n\\n        int ans = 1;\\n        for (int i = 0; i < n; i++) \\n        {\\n            vector<bool> vis(n, false);\\n            int mx = 0;\\n            queue<int> q;\\n            q.push(i);\\n\\n            while (!q.empty()) \\n            {\\n                int s = q.size();\\n                for (int j = 0; j < s; j++) \\n                {\\n                    int x = q.front();\\n                    q.pop();\\n                    vis[x] = true;\\n                    mx++;\\n                    for (auto p : v[x]) \\n                    {\\n                        if (!vis[p]) {\\n                            q.push(p);\\n                            vis[p] = true;\\n                        }\\n                    }\\n                }\\n            }\\n            ans = max(ans, mx);\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623397,
                "title": "need-help-with-union-find-approach-cpp-uninon-find",
                "content": "```\\nclass Solution {\\npublic:\\n    long  dist(long a,long b,long x,long y){\\n        return sqrt(pow((a-x+0ll),2.0) + pow((b-y+0ll),2.0));\\n    }\\n    // static bool cmp(vector<int> &a,vector<int> &b){\\n    //     return a[2]>b[2];\\n    // }\\n    int getp_(vector<int> &p,int x){\\n        if(p[x]==x)return x;\\n        return p[x]=getp_(p,p[x]);\\n    }\\n    void union_(vector<int> &p,vector<int> &r,int x,int y){\\n        int px=getp_(p,x) , py=getp_(p,y);\\n        if(px==py)return;\\n        \\n        if(r[px]>r[py]){\\n            p[py]=px;\\n        }else if(r[py]>r[px]){\\n            p[px]=py;\\n        }else{\\n            p[px]=py;\\n            r[py]++;\\n        }\\n    }\\n    int maximumDetonation(vector<vector<int>>& bmb) {\\n        int n=bmb.size();\\n        vector<int> p(n,0),r(n,0);\\n        \\n        for(int i=0;i<n;++i){\\n            p[i]=i;\\n        }\\n        \\n        \\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<n;++j){\\n                // if(i!=j){\\n                    int dt=dist(bmb[i][0],bmb[i][1],bmb[j][0],bmb[j][1]);\\n                    if(dt<=bmb[i][2]){\\n                        union_(p,r,i,j);\\n                    }\\n                // }\\n            }\\n        }\\n        \\n        unordered_map<int,int> ump;\\n        int ans=1;\\n        for(int i=0;i<n;++i){\\n            ans=max(ans,++ump[getp_(p,i)]);\\n        }\\n        \\n        return ans;\\n//         vector<vector<int>> exp(bmb.size());\\n//         sort(bmb.begin(),bmb.end(),cmp);\\n//         for(int i=0;i<bmb.size();++i){\\n//             cout<<i<<\" -> \";\\n//             for(int j=i+1;j<bmb.size();++j){\\n//                 int dt=dist(bmb[i][0],bmb[i][1],bmb[j][0],bmb[j][1]);\\n//                 if(dt<=bmb[i][2]){\\n//                     exp[i].push_back(j);\\n//                     cout<<j<<\" \";\\n//                 }\\n//             }\\n//             cout<<endl;\\n//         }\\n        \\n//         int ans=1;\\n//         vector<int> blast(bmb.size(),0);\\n//         for(int i=bmb.size()-1;i>=0;--i){\\n//             int t=1;\\n//             for(int j=0;j<exp[i].size();++j){\\n//                 t+=blast[exp[i][j]];\\n//             }\\n//             blast[i]=t;\\n//             ans=max(ans,t);\\n//         }\\n        \\n//         return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long  dist(long a,long b,long x,long y){\\n        return sqrt(pow((a-x+0ll),2.0) + pow((b-y+0ll),2.0));\\n    }\\n    // static bool cmp(vector<int> &a,vector<int> &b){\\n    //     return a[2]>b[2];\\n    // }\\n    int getp_(vector<int> &p,int x){\\n        if(p[x]==x)return x;\\n        return p[x]=getp_(p,p[x]);\\n    }\\n    void union_(vector<int> &p,vector<int> &r,int x,int y){\\n        int px=getp_(p,x) , py=getp_(p,y);\\n        if(px==py)return;\\n        \\n        if(r[px]>r[py]){\\n            p[py]=px;\\n        }else if(r[py]>r[px]){\\n            p[px]=py;\\n        }else{\\n            p[px]=py;\\n            r[py]++;\\n        }\\n    }\\n    int maximumDetonation(vector<vector<int>>& bmb) {\\n        int n=bmb.size();\\n        vector<int> p(n,0),r(n,0);\\n        \\n        for(int i=0;i<n;++i){\\n            p[i]=i;\\n        }\\n        \\n        \\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<n;++j){\\n                // if(i!=j){\\n                    int dt=dist(bmb[i][0],bmb[i][1],bmb[j][0],bmb[j][1]);\\n                    if(dt<=bmb[i][2]){\\n                        union_(p,r,i,j);\\n                    }\\n                // }\\n            }\\n        }\\n        \\n        unordered_map<int,int> ump;\\n        int ans=1;\\n        for(int i=0;i<n;++i){\\n            ans=max(ans,++ump[getp_(p,i)]);\\n        }\\n        \\n        return ans;\\n//         vector<vector<int>> exp(bmb.size());\\n//         sort(bmb.begin(),bmb.end(),cmp);\\n//         for(int i=0;i<bmb.size();++i){\\n//             cout<<i<<\" -> \";\\n//             for(int j=i+1;j<bmb.size();++j){\\n//                 int dt=dist(bmb[i][0],bmb[i][1],bmb[j][0],bmb[j][1]);\\n//                 if(dt<=bmb[i][2]){\\n//                     exp[i].push_back(j);\\n//                     cout<<j<<\" \";\\n//                 }\\n//             }\\n//             cout<<endl;\\n//         }\\n        \\n//         int ans=1;\\n//         vector<int> blast(bmb.size(),0);\\n//         for(int i=bmb.size()-1;i>=0;--i){\\n//             int t=1;\\n//             for(int j=0;j<exp[i].size();++j){\\n//                 t+=blast[exp[i][j]];\\n//             }\\n//             blast[i]=t;\\n//             ans=max(ans,t);\\n//         }\\n        \\n//         return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2441011,
                "title": "c-dfs-connected-component-count",
                "content": "\\n\\t\\n\\t// Function to calculate dis^2 between two points\\n    long long dis(int x1, int y1, int x2, int y2)\\n    {\\n        return pow(x2-x1,2) + pow(y2-y1,2);\\n    }\\n    // DFS connected components count\\n    void dfs(int node, vector<vector<int>> &adj, vector<bool>& visited , int &count)\\n    {\\n        if(visited[node]) return;\\n        \\n        visited[node]=true;\\n        \\n        // increment count each time we visit a new node\\n        count++;\\n        \\n        for(auto i: adj[node])\\n            if(!visited[i])\\n                dfs(i,adj,visited,count);\\n    }\\n    int maximumDetonation(vector<vector<int>>& bomb) {\\n        \\n        int n=bomb.size();\\n        \\n        vector<vector<int>> adj(n);\\n        \\n        // for every comparison of bomb i->j check if the distance between the center of those two\\n        // bombs is less than or equal to the radius of either of the bomb. If yes then push them\\n        // adj[i] = {j} means that if we trigger i, j will be triggered\\n        for(int i=0;i<n;i++)\\n            for(int j=i+1;j<n;j++)\\n            {\\n                long long r =dis(bomb[i][0],bomb[i][1],bomb[j][0],bomb[j][1]);\\n                if(r<= pow(bomb[i][2],2)) adj[i].push_back(j);\\n                if(r<= pow(bomb[j][2],2)) adj[j].push_back(i);\\n            }\\n        \\n        int ans=INT_MIN;\\n        \\n        vector<bool> visited;\\n        \\n        // perform DFS for every bomb\\n        for(int i=0;i<n;i++)\\n        {\\n            visited=vector(n,false);\\n            int count=0;\\n            dfs(i,adj,visited,count);\\n            ans=max(ans,count);\\n        }\\n        \\n        return ans;\\n    }\\n\\t\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "\\n\\t\\n\\t// Function to calculate dis^2 between two points\\n    long long dis(int x1, int y1, int x2, int y2)\\n    {\\n        return pow(x2-x1,2) + pow(y2-y1,2);\\n    }\\n    // DFS connected components count\\n    void dfs(int node, vector<vector<int>> &adj, vector<bool>& visited , int &count)\\n    {\\n        if(visited[node]) return;\\n        \\n        visited[node]=true;\\n        \\n        // increment count each time we visit a new node\\n        count++;\\n        \\n        for(auto i: adj[node])\\n            if(!visited[i])\\n                dfs(i,adj,visited,count);\\n    }\\n    int maximumDetonation(vector<vector<int>>& bomb) {\\n        \\n        int n=bomb.size();\\n        \\n        vector<vector<int>> adj(n);\\n        \\n        // for every comparison of bomb i->j check if the distance between the center of those two\\n        // bombs is less than or equal to the radius of either of the bomb. If yes then push them\\n        // adj[i] = {j} means that if we trigger i, j will be triggered\\n        for(int i=0;i<n;i++)\\n            for(int j=i+1;j<n;j++)\\n            {\\n                long long r =dis(bomb[i][0],bomb[i][1],bomb[j][0],bomb[j][1]);\\n                if(r<= pow(bomb[i][2],2)) adj[i].push_back(j);\\n                if(r<= pow(bomb[j][2],2)) adj[j].push_back(i);\\n            }\\n        \\n        int ans=INT_MIN;\\n        \\n        vector<bool> visited;\\n        \\n        // perform DFS for every bomb\\n        for(int i=0;i<n;i++)\\n        {\\n            visited=vector(n,false);\\n            int count=0;\\n            dfs(i,adj,visited,count);\\n            ans=max(ans,count);\\n        }\\n        \\n        return ans;\\n    }\\n\\t\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1624625,
                "title": "java-solution-dfs-traversal",
                "content": "We just need to find out the maximum no. of connected components i.e. bombs\\n```\\nclass Solution {\\n    \\n    public int maximumDetonation(int[][] bombs) {\\n        \\n        List<List<Integer>> adj = new ArrayList<>();\\n        int n = bombs.length;\\n        boolean[] vis = new boolean[n];\\n        int max=1;\\n        \\n        \\n        for(int i=0;i<n;i++)\\n            adj.add(new ArrayList<>());\\n        \\n        for(int i=0;i<n;i++){\\n            long x = (long)bombs[i][0],y=(long)bombs[i][1],r=(long)bombs[i][2];\\n            \\n            for(int j=0;j<n;j++){\\n               int x1 = bombs[j][0],y1=bombs[j][1],r1=bombs[j][2];\\n                \\n               if(i!=j){\\n                   if((((x-x1)*(x-x1)+(y-y1)*(y-y1))<=r*r))\\n                   adj.get(i).add(j);\\n               }\\n            }\\n        }\\n\\n                \\n        for(int i=0;i<n;i++){\\n            int ans = DFS(i,adj,vis);\\n            Arrays.fill(vis,false);\\n            max = Math.max(ans,max);\\n        }\\n        \\n        return max;\\n        \\n    }\\n    \\n    private int DFS(int i,List<List<Integer>> adj,boolean []vis){\\n        vis[i]=true;\\n        int ans =1;\\n        for(int nd : adj.get(i)){\\n            if(!vis[nd])\\n                ans+=DFS(nd,adj,vis);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int maximumDetonation(int[][] bombs) {\\n        \\n        List<List<Integer>> adj = new ArrayList<>();\\n        int n = bombs.length;\\n        boolean[] vis = new boolean[n];\\n        int max=1;\\n        \\n        \\n        for(int i=0;i<n;i++)\\n            adj.add(new ArrayList<>());\\n        \\n        for(int i=0;i<n;i++){\\n            long x = (long)bombs[i][0],y=(long)bombs[i][1],r=(long)bombs[i][2];\\n            \\n            for(int j=0;j<n;j++){\\n               int x1 = bombs[j][0],y1=bombs[j][1],r1=bombs[j][2];\\n                \\n               if(i!=j){\\n                   if((((x-x1)*(x-x1)+(y-y1)*(y-y1))<=r*r))\\n                   adj.get(i).add(j);\\n               }\\n            }\\n        }\\n\\n                \\n        for(int i=0;i<n;i++){\\n            int ans = DFS(i,adj,vis);\\n            Arrays.fill(vis,false);\\n            max = Math.max(ans,max);\\n        }\\n        \\n        return max;\\n        \\n    }\\n    \\n    private int DFS(int i,List<List<Integer>> adj,boolean []vis){\\n        vis[i]=true;\\n        int ans =1;\\n        for(int nd : adj.get(i)){\\n            if(!vis[nd])\\n                ans+=DFS(nd,adj,vis);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623607,
                "title": "c-using-bfs",
                "content": "As its mentioned in first Solved example that for any two Bombs A-B , B will blast due to effect of A if and only if Centre of B lies inside or on the circumference of A  => radius of Bomb A (r1) >= Distance between their centers.\\n\\nSo We start bfs from Bomb i and including all those bombs in effect of A that satisfies above condition.\\n\\n```\\n#define lln long long int\\nclass Solution {\\n  int mx=INT_MIN;\\n  queue<int>q;\\n\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        \\n      int n=bombs.size();\\n      \\n      for(int i=0;i<n;i++){\\n         bfs(i,bombs);\\n      }\\n      \\n      return mx;\\n    }\\n  \\n      void bfs(int i, vector<vector<int>>& bombs){\\n          int n=bombs.size();\\n        vector<bool>vis(n,false);\\n        \\n         lln x1,y1,r1,x2,y2,r2;\\n          q.push(i);\\n          vis[i]=true;\\n        \\n         int count=1;\\n        \\n        while(!q.empty()){\\n    \\n          int j=q.front();\\n          vis[j]=true;\\n          q.pop();\\n          \\n          for(int k=0;k<n;k++){\\n            if(vis[k]==true)\\n              continue;\\n            \\n      x1=bombs[j][0],y1=bombs[j][1],r1=bombs[j][2];\\n      x2=bombs[k][0],y2=bombs[k][1],r2=bombs[k][2];\\n          \\n            if(r1 >= sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2)) ) {\\n              vis[k]=true;\\n               q.push(k);\\n              count++;\\n          }\\n        }\\n          \\n      }\\n               \\n       mx=max(mx,count);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\n#define lln long long int\\nclass Solution {\\n  int mx=INT_MIN;\\n  queue<int>q;\\n\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        \\n      int n=bombs.size();\\n      \\n      for(int i=0;i<n;i++){\\n         bfs(i,bombs);\\n      }\\n      \\n      return mx;\\n    }\\n  \\n      void bfs(int i, vector<vector<int>>& bombs){\\n          int n=bombs.size();\\n        vector<bool>vis(n,false);\\n        \\n         lln x1,y1,r1,x2,y2,r2;\\n          q.push(i);\\n          vis[i]=true;\\n        \\n         int count=1;\\n        \\n        while(!q.empty()){\\n    \\n          int j=q.front();\\n          vis[j]=true;\\n          q.pop();\\n          \\n          for(int k=0;k<n;k++){\\n            if(vis[k]==true)\\n              continue;\\n            \\n      x1=bombs[j][0],y1=bombs[j][1],r1=bombs[j][2];\\n      x2=bombs[k][0],y2=bombs[k][1],r2=bombs[k][2];\\n          \\n            if(r1 >= sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2)) ) {\\n              vis[k]=true;\\n               q.push(k);\\n              count++;\\n          }\\n        }\\n          \\n      }\\n               \\n       mx=max(mx,count);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623428,
                "title": "c-bfs-beginner-friendly-o-n-3",
                "content": "```\\nclass Solution {\\npublic:\\n    long long int cnt;\\n    long long get(vector<vector<int> > &ar, int i, int n){\\n        vector<int> vis(n,0);\\n        queue<vector<int> > q;\\n        \\n        vis[i] = 1;\\n        cnt++;\\n        \\n        q.push(ar[i]);\\n        while(!q.empty()){\\n            auto cur = q.front();\\n            q.pop();\\n            \\n            for(int j = 0; j < n; j++){\\n                if(!vis[j]){\\n                    long long int a = (ar[j][0] * 1ll - cur[0] * 1ll) * (ar[j][0] * 1ll - cur[0] * 1ll);    \\n                    long long int b = (ar[j][1] * 1ll - cur[1] * 1ll) * (ar[j][1] * 1ll - cur[1] * 1ll);\\n                    long long int c = cur[2] * 1ll * cur[2];\\n                    \\n                    // Check whether centre of new circle lies \\n                    // on or inside the current circle\\n                    long long int k = a + b - c;\\n                    if(k <= 0){\\n                        vis[j] = 1;\\n                        q.push(ar[j]);\\n                        cnt++;\\n                    }\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n    int maximumDetonation(vector<vector<int>>& ar) {\\n        int n = ar.size();\\n        long long int ans = -1;\\n        \\n        for(int i = 0; i < n; i++){\\n            cnt = 0;\\n            ans = max(ans, get(ar, i, n));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\nDo Upvote, If it helps!",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long int cnt;\\n    long long get(vector<vector<int> > &ar, int i, int n){\\n        vector<int> vis(n,0);\\n        queue<vector<int> > q;\\n        \\n        vis[i] = 1;\\n        cnt++;\\n        \\n        q.push(ar[i]);\\n        while(!q.empty()){\\n            auto cur = q.front();\\n            q.pop();\\n            \\n            for(int j = 0; j < n; j++){\\n                if(!vis[j]){\\n                    long long int a = (ar[j][0] * 1ll - cur[0] * 1ll) * (ar[j][0] * 1ll - cur[0] * 1ll);    \\n                    long long int b = (ar[j][1] * 1ll - cur[1] * 1ll) * (ar[j][1] * 1ll - cur[1] * 1ll);\\n                    long long int c = cur[2] * 1ll * cur[2];\\n                    \\n                    // Check whether centre of new circle lies \\n                    // on or inside the current circle\\n                    long long int k = a + b - c;\\n                    if(k <= 0){\\n                        vis[j] = 1;\\n                        q.push(ar[j]);\\n                        cnt++;\\n                    }\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n    int maximumDetonation(vector<vector<int>>& ar) {\\n        int n = ar.size();\\n        long long int ans = -1;\\n        \\n        for(int i = 0; i < n; i++){\\n            cnt = 0;\\n            ans = max(ans, get(ar, i, n));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623407,
                "title": "python-dfs-explained-easy-to-understand-faster-100",
                "content": "* First Construct a graph, each bomb as a vertex, if b is within the explosion radius of a, then there is a directed edge from a to b. Construct the adjacency matrix of the Directed graph.\\n\\t* Note that this is a directed graph, so we cannot use UnionFindSet.\\n* Traverse each bomb as the starting point and count the number of nodes it can reach on graph.\\n* Return the max count number.\\n```\\nclass Solution(object):\\n    def maximumDetonation(self, bombs):\\n        def count(i):\\n            dq, ret = [i], [i]\\n            while len(dq) > 0:\\n                i = dq.pop()\\n                for j in adj[i]:\\n                    if j not in ret and j not in dq:\\n                        dq.append(j)\\n                        ret.append(j)\\n            return len(ret)\\n\\n        adj = collections.defaultdict(list)\\n        for i in range(len(bombs)):\\n            for j in range(i + 1, len(bombs)):\\n                if (bombs[i][0] - bombs[j][0]) ** 2 + (bombs[i][1] - bombs[j][1]) ** 2 <= bombs[i][2] ** 2:\\n                    adj[i].append(j)\\n                if (bombs[i][0] - bombs[j][0]) ** 2 + (bombs[i][1] - bombs[j][1]) ** 2 <= bombs[j][2] ** 2:\\n                    adj[j].append(i)\\n        ret = 0\\n        for i in range(len(bombs)):\\n            ret = max(ret, count(i))\\n        return ret\\n```\\n**Please UPVOTE!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maximumDetonation(self, bombs):\\n        def count(i):\\n            dq, ret = [i], [i]\\n            while len(dq) > 0:\\n                i = dq.pop()\\n                for j in adj[i]:\\n                    if j not in ret and j not in dq:\\n                        dq.append(j)\\n                        ret.append(j)\\n            return len(ret)\\n\\n        adj = collections.defaultdict(list)\\n        for i in range(len(bombs)):\\n            for j in range(i + 1, len(bombs)):\\n                if (bombs[i][0] - bombs[j][0]) ** 2 + (bombs[i][1] - bombs[j][1]) ** 2 <= bombs[i][2] ** 2:\\n                    adj[i].append(j)\\n                if (bombs[i][0] - bombs[j][0]) ** 2 + (bombs[i][1] - bombs[j][1]) ** 2 <= bombs[j][2] ** 2:\\n                    adj[j].append(i)\\n        ret = 0\\n        for i in range(len(bombs)):\\n            ret = max(ret, count(i))\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589658,
                "title": "understandable-explanation-graph-visualized",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHow can we visiualize the problem?\\nWhich data structure should we use ?\\n\\nThe key to the solution is just visualization, if you crack that this question is a piece of cake.\\n\\nThink of a single detonation some other bombs and those other bombs are detonating further or they even might detonate a previous one.\\nAren\\'t you getting a feel of chain. A chain which might contain cycles , or some disconnected parts .\\nWe can visualize bombs as vertices with their detonation connection as directed edge between them.\\nAlso look at the constraints first we do not have to worry about time complexity much, an n^2 solution with be fairly good.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nImplement an inRange(bomb a,bomb b) funciton to check weather bomb b is in the range of a or not. You can easily check using basic co-ordinate geometry (remember class 12). I am shifting origin to co-ordinates of bomb a and checking now if co-ordinates of other bomb will lie in the range (x*x + y*y <= r*r) it will get detonated.\\n\\nNow create a directed graph with all pairs of (i,j) (i and j here represents bombs 0,1,2....n-1) and check if j is in the range of i there will be an edge from i to j.\\n\\nNow the question to just count the maximum number of reachable node from a single node and as we can go for O(n^2) we can simply run a bfs or dfs traversal from every node and count the number of nodes and return the maximum.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n   \\n    bool inRange(vector<int> v1,vector<int> v2)\\n    {\\n        long long x1 = v1[0],y1 = v1[1] , r = v1[2];\\n        long long x2 = v2[0] , y2 = v2[1];\\n\\n        x2 -= x1;\\n        y2 -= y1;\\n\\n        if(x2*x2 + y2*y2 <= r*r) return true;\\n        return false;\\n    }\\n\\n    int bfs(unordered_map<int,vector<int>> &adj,int node)\\n    {\\n        queue<int> q;\\n        vector<bool> visited(n+1,false); \\n        visited[node]=true;\\n        q.push(node);\\n        int ans = 0;\\n        while(!q.empty())\\n        {\\n            ans++;\\n\\n            int temp = q.front();\\n           \\n            q.pop();\\n            for(auto i : adj[temp])\\n            {\\n                if(!visited[i]) q.push(i);\\n                visited[i] = true;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n    int maximumDetonation(vector<vector<int>>& bombs)\\n    {\\n        n = bombs.size();\\n\\n        unordered_map<int,vector<int>> adj;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j) continue;\\n\\n                if(inRange(bombs[i],bombs[j]))\\n                {\\n                    adj[i+1].push_back(j+1);\\n                }\\n            }\\n        }\\n\\n        int ans = -1;\\n       \\n        for(int i=1;i<=n;i++)\\n        {\\n            ans = max(ans,bfs(adj,i));\\n       \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n   \\n    bool inRange(vector<int> v1,vector<int> v2)\\n    {\\n        long long x1 = v1[0],y1 = v1[1] , r = v1[2];\\n        long long x2 = v2[0] , y2 = v2[1];\\n\\n        x2 -= x1;\\n        y2 -= y1;\\n\\n        if(x2*x2 + y2*y2 <= r*r) return true;\\n        return false;\\n    }\\n\\n    int bfs(unordered_map<int,vector<int>> &adj,int node)\\n    {\\n        queue<int> q;\\n        vector<bool> visited(n+1,false); \\n        visited[node]=true;\\n        q.push(node);\\n        int ans = 0;\\n        while(!q.empty())\\n        {\\n            ans++;\\n\\n            int temp = q.front();\\n           \\n            q.pop();\\n            for(auto i : adj[temp])\\n            {\\n                if(!visited[i]) q.push(i);\\n                visited[i] = true;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n    int maximumDetonation(vector<vector<int>>& bombs)\\n    {\\n        n = bombs.size();\\n\\n        unordered_map<int,vector<int>> adj;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==j) continue;\\n\\n                if(inRange(bombs[i],bombs[j]))\\n                {\\n                    adj[i+1].push_back(j+1);\\n                }\\n            }\\n        }\\n\\n        int ans = -1;\\n       \\n        for(int i=1;i<=n;i++)\\n        {\\n            ans = max(ans,bfs(adj,i));\\n       \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589083,
                "title": "python-elegant-short-dfs",
                "content": "# Complexity\\n- Time complexity: $$O(n^{2})$$\\n- Space complexity: $$O(n^{2})$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumDetonation(self, bombs: List[List[int]]) -> int:\\n        def dfs(node: int, visited: set = None) -> set:\\n            if visited is None:\\n                visited = {node}\\n\\n            for child in graph[node]:\\n                if child not in visited:\\n                    visited.add(child)\\n                    dfs(child, visited)\\n\\n            return visited\\n\\n        graph = defaultdict(set)\\n\\n        for i, (x1, y1, rad) in enumerate(bombs):\\n            for j, (x2, y2, _) in enumerate(bombs):\\n                if (x1 - x2) ** 2 + (y1 - y2) ** 2 <= rad ** 2:\\n                    graph[i].add(j)\\n\\n        return max(len(dfs(i)) for i in range(len(bombs)))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def maximumDetonation(self, bombs: List[List[int]]) -> int:\\n        def dfs(node: int, visited: set = None) -> set:\\n            if visited is None:\\n                visited = {node}\\n\\n            for child in graph[node]:\\n                if child not in visited:\\n                    visited.add(child)\\n                    dfs(child, visited)\\n\\n            return visited\\n\\n        graph = defaultdict(set)\\n\\n        for i, (x1, y1, rad) in enumerate(bombs):\\n            for j, (x2, y2, _) in enumerate(bombs):\\n                if (x1 - x2) ** 2 + (y1 - y2) ** 2 <= rad ** 2:\\n                    graph[i].add(j)\\n\\n        return max(len(dfs(i)) for i in range(len(bombs)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588652,
                "title": "c-easy-dfs",
                "content": "# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int dfs(vector<int> &v, vector<vector<int>> &b, int i)\\n    {\\n        v[i] = 1;\\n        int x = b[i][0], y = b[i][1];\\n        int r = b[i][2];\\n        int j = 0;\\n        int ans = 1;\\n        for (int j = 0; j < b.size(); j++)\\n        {\\n            long long g = abs(x - b[j][0]);\\n            g *= g;\\n            long long gg = abs(y - b[j][1]);\\n            gg *= gg;\\n            double dis = sqrt(g + gg);\\n            if (dis <= (r) && !v[j])\\n            {\\n                ans += dfs(v, b, j);\\n            }\\n        }\\n        return ans;\\n    }\\n    int maximumDetonation(vector<vector<int>> &b)\\n    {\\n        int n = b.size();\\n        int ans = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            vector<int> v(n, 0);\\n            if (!v[i])\\n            {\\n                ans = max(ans, dfs(v, b, i));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/a5d5993c-bc66-4076-8557-f5928282fe17_1685692639.1890407.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int dfs(vector<int> &v, vector<vector<int>> &b, int i)\\n    {\\n        v[i] = 1;\\n        int x = b[i][0], y = b[i][1];\\n        int r = b[i][2];\\n        int j = 0;\\n        int ans = 1;\\n        for (int j = 0; j < b.size(); j++)\\n        {\\n            long long g = abs(x - b[j][0]);\\n            g *= g;\\n            long long gg = abs(y - b[j][1]);\\n            gg *= gg;\\n            double dis = sqrt(g + gg);\\n            if (dis <= (r) && !v[j])\\n            {\\n                ans += dfs(v, b, j);\\n            }\\n        }\\n        return ans;\\n    }\\n    int maximumDetonation(vector<vector<int>> &b)\\n    {\\n        int n = b.size();\\n        int ans = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            vector<int> v(n, 0);\\n            if (!v[i])\\n            {\\n                ans = max(ans, dfs(v, b, i));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588358,
                "title": "java-dfs-beats-70-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  private List<Integer>[] adj;\\n  private boolean[] seen;\\n\\n  private int dfs(int node) {\\n    seen[node] = true;\\n    var cnt = 1;\\n    \\n    for (var neighbor : adj[node])\\n      if (!seen[neighbor])\\n        cnt += dfs(neighbor);\\n    \\n    return cnt;\\n  }\\n\\n  public int maximumDetonation(int[][] bombs) {\\n    var max = 0;\\n    var n = bombs.length;\\n    seen = new boolean[n];\\n    adj = new ArrayList[n];\\n\\n    for (var i=0; i<n; i++)\\n      adj[i] = new ArrayList<>();\\n\\n    for (var i=0; i<n; i++) {\\n      for (var j=0; j<n; j++) {\\n        if (i == j) continue;\\n\\n        var a = bombs[i];\\n        var b = bombs[j];\\n\\n        if (Math.pow(a[0] - b[0], 2) + Math.pow(a[1] - b[1], 2) <= Math.pow(a[2], 2))\\n          adj[i].add(j);\\n      }\\n    }\\n    for (var i=0; i<n; i++) {\\n      Arrays.fill(seen, false);\\n      max = Math.max(max, dfs(i));\\n    }\\n    return max;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Depth-First Search",
                    "Graph",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\n  private List<Integer>[] adj;\\n  private boolean[] seen;\\n\\n  private int dfs(int node) {\\n    seen[node] = true;\\n    var cnt = 1;\\n    \\n    for (var neighbor : adj[node])\\n      if (!seen[neighbor])\\n        cnt += dfs(neighbor);\\n    \\n    return cnt;\\n  }\\n\\n  public int maximumDetonation(int[][] bombs) {\\n    var max = 0;\\n    var n = bombs.length;\\n    seen = new boolean[n];\\n    adj = new ArrayList[n];\\n\\n    for (var i=0; i<n; i++)\\n      adj[i] = new ArrayList<>();\\n\\n    for (var i=0; i<n; i++) {\\n      for (var j=0; j<n; j++) {\\n        if (i == j) continue;\\n\\n        var a = bombs[i];\\n        var b = bombs[j];\\n\\n        if (Math.pow(a[0] - b[0], 2) + Math.pow(a[1] - b[1], 2) <= Math.pow(a[2], 2))\\n          adj[i].add(j);\\n      }\\n    }\\n    for (var i=0; i<n; i++) {\\n      Arrays.fill(seen, false);\\n      max = Math.max(max, dfs(i));\\n    }\\n    return max;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587769,
                "title": "java-solution-for-detonate-the-maximum-bombs-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given problem involves finding the maximum number of bombs that can be detonated by choosing a single bomb. To solve this, we can represent the bombs as a graph, where each bomb is a node and there is an edge between two bombs if one can detonate the other. By using graph traversal techniques, such as Breadth-First Search (BFS), we can find the maximum number of detonated bombs.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Build the graph: Iterate over each pair of bombs and check if one bomb can detonate the other. If so, create a directed edge from the first bomb to the second bomb in the graph.\\n1. Perform BFS: Iterate over each bomb and perform a BFS traversal starting from that bomb. Count the number of visited nodes during the traversal, which represents the number of detonated bombs.\\n1. Update the maximum count: Keep track of the maximum detonated count encountered during the BFS traversal.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of building the graph is O(n^2) since we iterate over each pair of bombs. The BFS traversal is performed for each bomb, which has a time complexity of O(n + m), where n is the number of nodes (bombs) and m is the number of edges in the graph. In the worst case, the number of edges can be O(n^2), resulting in a time complexity of O(n^3). However, on average, the number of edges tends to be much smaller, resulting in an average time complexity closer to O(n^2).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(n^2) to store the graph using a HashMap, where n is the number of bombs. Additionally, the BFS traversal requires O(n) space for the queue and O(n) space for the visited set, resulting in a total space complexity of O(n^2 + n + n) = O(n^2).\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumDetonation(int[][] bombs) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        int n = bombs.length;\\n        \\n        // Build the graph\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int xi = bombs[i][0], yi = bombs[i][1], ri = bombs[i][2];\\n                int xj = bombs[j][0], yj = bombs[j][1];\\n                \\n                // Create a path from node i to node j, if bomb i detonates bomb j.\\n                if ((long)ri * ri >= (long)(xi - xj) * (xi - xj) + (long)(yi - yj) * (yi - yj)) {\\n                    graph.computeIfAbsent(i, k -> new ArrayList<>()).add(j);\\n                }\\n            }\\n        }\\n        \\n        int answer = 0;\\n        for (int i = 0; i < n; i++) {\\n            answer = Math.max(answer, bfs(i, graph));\\n        }\\n        \\n        return answer;\\n    }\\n    \\n    private int bfs(int i, Map<Integer, List<Integer>> graph) {\\n        Deque<Integer> queue = new ArrayDeque<>();\\n        Set<Integer> visited = new HashSet<>();\\n        queue.offer(i);\\n        visited.add(i);\\n        while (!queue.isEmpty()) {\\n            int cur = queue.poll();\\n            for (int neib : graph.getOrDefault(cur, new ArrayList<>())) {\\n                if (!visited.contains(neib)) {\\n                    visited.add(neib);\\n                    queue.offer(neib);\\n                }\\n            }\\n        }\\n        return visited.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumDetonation(int[][] bombs) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        int n = bombs.length;\\n        \\n        // Build the graph\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int xi = bombs[i][0], yi = bombs[i][1], ri = bombs[i][2];\\n                int xj = bombs[j][0], yj = bombs[j][1];\\n                \\n                // Create a path from node i to node j, if bomb i detonates bomb j.\\n                if ((long)ri * ri >= (long)(xi - xj) * (xi - xj) + (long)(yi - yj) * (yi - yj)) {\\n                    graph.computeIfAbsent(i, k -> new ArrayList<>()).add(j);\\n                }\\n            }\\n        }\\n        \\n        int answer = 0;\\n        for (int i = 0; i < n; i++) {\\n            answer = Math.max(answer, bfs(i, graph));\\n        }\\n        \\n        return answer;\\n    }\\n    \\n    private int bfs(int i, Map<Integer, List<Integer>> graph) {\\n        Deque<Integer> queue = new ArrayDeque<>();\\n        Set<Integer> visited = new HashSet<>();\\n        queue.offer(i);\\n        visited.add(i);\\n        while (!queue.isEmpty()) {\\n            int cur = queue.poll();\\n            for (int neib : graph.getOrDefault(cur, new ArrayList<>())) {\\n                if (!visited.contains(neib)) {\\n                    visited.add(neib);\\n                    queue.offer(neib);\\n                }\\n            }\\n        }\\n        return visited.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2581558,
                "title": "why-is-this-wrong-python-union-find-solution-passes-111-160",
                "content": "```\\nclass UnionF:\\n    def __init__(self, n):\\n        self.rank = [1 for _ in range(n)]\\n        self.par = [i for i in range(n)]\\n        self.n = n\\n        \\n    def find(self, n):\\n        # Path Compression + Finds root\\n        while n != self.par[n]:\\n            self.par[n] = self.par[self.par[n]]\\n            n = self.par[n]\\n        return n\\n    \\n    def union(self, n1, n2):\\n        p1, p2 = self.find(n1), self.find(n2)\\n        # If they aren\\'t already unioned, union them\\n        if p1 != p2:\\n            if self.rank[p1] > self.rank[p2]:\\n                self.rank[p1] += 1\\n                self.par[p2] = p1\\n            else:\\n                self.rank[p2] += 1\\n                self.par[p1] = p2\\n\\nclass Solution:\\n    def maximumDetonation(self, bombs: List[List[int]]) -> int:\\n        n = len(bombs)\\n        union = UnionF(n)\\n        \\n        for i in range(n):\\n            for j in range(i):\\n                x1, y1, r1 = bombs[i][0], bombs[i][1], bombs[i][2]\\n                x2, y2, r2 = bombs[j][0], bombs[j][1], bombs[j][2]\\n                \\n                distance = sqrt((x2-x1)**2 + (y2-y1)**2)\\n                # Bombs would detonate eaach other\\n                if distance <= (r1 + r2):\\n                    union.union(i, j) \\n        # Max rank is also the same as number of detonated bombs (connected componenets)\\n        return max(union.rank)\\n```\\nThis is the test case it is failing:\\n[[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]\\n\\nI return 2 bombs detonate each other but the answer is 1 bombs detonates.\\n\\nSpecificially the bombs: [65, 59, 3] [69, 51, 7] are 8.94427190999916 distance apart yet the problem says they should not detonate each other. Why is this so?\\n",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass UnionF:\\n    def __init__(self, n):\\n        self.rank = [1 for _ in range(n)]\\n        self.par = [i for i in range(n)]\\n        self.n = n\\n        \\n    def find(self, n):\\n        # Path Compression + Finds root\\n        while n != self.par[n]:\\n            self.par[n] = self.par[self.par[n]]\\n            n = self.par[n]\\n        return n\\n    \\n    def union(self, n1, n2):\\n        p1, p2 = self.find(n1), self.find(n2)\\n        # If they aren\\'t already unioned, union them\\n        if p1 != p2:\\n            if self.rank[p1] > self.rank[p2]:\\n                self.rank[p1] += 1\\n                self.par[p2] = p1\\n            else:\\n                self.rank[p2] += 1\\n                self.par[p1] = p2\\n\\nclass Solution:\\n    def maximumDetonation(self, bombs: List[List[int]]) -> int:\\n        n = len(bombs)\\n        union = UnionF(n)\\n        \\n        for i in range(n):\\n            for j in range(i):\\n                x1, y1, r1 = bombs[i][0], bombs[i][1], bombs[i][2]\\n                x2, y2, r2 = bombs[j][0], bombs[j][1], bombs[j][2]\\n                \\n                distance = sqrt((x2-x1)**2 + (y2-y1)**2)\\n                # Bombs would detonate eaach other\\n                if distance <= (r1 + r2):\\n                    union.union(i, j) \\n        # Max rank is also the same as number of detonated bombs (connected componenets)\\n        return max(union.rank)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1859591,
                "title": "c-graphs-math-explained",
                "content": "**Approach :**\\n\\n* Since the constraints are low i.e we are given only 100 bombs at max, we can, for each bomb we can find if we detonate this bomb, how many other bombs it can detonate. \\n\\n* Now we can represent bombs as nodes in graph. \\n* Also we need to revisit our High School Geometry, to check if a point lies outside circle or inside or on the circumference, that can be done by checking the distance between the point and centre of other circle.\\n* Now if distance is greater than radius of other circle, then we cannot detonate that bomb, according to the question.\\n* Then after finding the relation between bombs we can run DFS to find how many other bombs a single bomb, if detonated, can detonate.\\n\\n```\\nclass Solution {\\npublic:\\n    double eucDis(int x1,int y1,int x2,int y2)\\n    {\\n        double temp=pow(x1-x2,2)+pow(y1-y2,2);\\n        return sqrt(temp);\\n    }\\n    void dfs(int node,vector<int>&vis,vector<int>graph[],int &c)\\n    {\\n        c++;\\n        vis[node]=1;\\n        for(auto i:graph[node])\\n        {\\n            if(!vis[i])\\n            {\\n                dfs(i,vis,graph,c);\\n            }\\n        }\\n    }\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        \\n        int n=bombs.size();\\n        vector<int>graph[n+1];\\n        int i,j;\\n        for(i=0;i<n;i++)\\n        {\\n            bombs[i].push_back(i);\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            \\n            for(j=0;j<n;j++)\\n            {\\n                if(i==j)\\n                    continue;\\n                double dis1=eucDis(bombs[i][0],bombs[i][1],bombs[j][0],\\n                               bombs[j][1]);\\n                \\n                if(dis1<=bombs[i][2])\\n                {\\n                    int node1=bombs[i][3];\\n                    int node2=bombs[j][3];\\n                    graph[node1].push_back(node2);\\n                }\\n            }\\n        }\\n       \\n        int maxi=1;\\n        for(i=0;i<n;i++)\\n        {\\n            int c=0;\\n            if(graph[i].empty())\\n                continue;\\n            vector<int>vis(n+1,0);\\n            \\n            dfs(i,vis,graph,c);   \\n            maxi=max(maxi,c);\\n            \\n            \\n        }\\n        return maxi;\\n    }\\n};\\n```\\n\\n**Runtime: 110 ms, faster than 78.69% of C++ online submissions for Detonate the Maximum Bombs.**\\n\\n\\n**Memory Usage: 17.2 MB, less than 56.73% of C++ online submissions for Detonate the Maximum Bombs.**\\n\\n\\n**Pls upvote the solution if you found helpful, it means a lot.\\nAlso comment down your doubts.\\nHappy Coding : )**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double eucDis(int x1,int y1,int x2,int y2)\\n    {\\n        double temp=pow(x1-x2,2)+pow(y1-y2,2);\\n        return sqrt(temp);\\n    }\\n    void dfs(int node,vector<int>&vis,vector<int>graph[],int &c)\\n    {\\n        c++;\\n        vis[node]=1;\\n        for(auto i:graph[node])\\n        {\\n            if(!vis[i])\\n            {\\n                dfs(i,vis,graph,c);\\n            }\\n        }\\n    }\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        \\n        int n=bombs.size();\\n        vector<int>graph[n+1];\\n        int i,j;\\n        for(i=0;i<n;i++)\\n        {\\n            bombs[i].push_back(i);\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            \\n            for(j=0;j<n;j++)\\n            {\\n                if(i==j)\\n                    continue;\\n                double dis1=eucDis(bombs[i][0],bombs[i][1],bombs[j][0],\\n                               bombs[j][1]);\\n                \\n                if(dis1<=bombs[i][2])\\n                {\\n                    int node1=bombs[i][3];\\n                    int node2=bombs[j][3];\\n                    graph[node1].push_back(node2);\\n                }\\n            }\\n        }\\n       \\n        int maxi=1;\\n        for(i=0;i<n;i++)\\n        {\\n            int c=0;\\n            if(graph[i].empty())\\n                continue;\\n            vector<int>vis(n+1,0);\\n            \\n            dfs(i,vis,graph,c);   \\n            maxi=max(maxi,c);\\n            \\n            \\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1638829,
                "title": "javascript-dfs-solution",
                "content": "```\\n/**\\n * @param {number[][]} bombs\\n * @return {number}\\n */\\nvar maximumDetonation = function(bombs) {\\n    if(bombs.length <= 1) return bombs.length;\\n    \\n    let adj = {}, maxSize = 0;\\n    const checkIfInsideRange = (x, y, center_x, center_y, radius) =>{\\n        return ( (x-center_x)**2 + (y-center_y)**2 <= radius**2 ) \\n    }\\n\\t\\n\\t//CREATE ADJACENCY MATRIX\\n    for(let i = 0;i<bombs.length;i++){\\n        for(let j = i+1;j<bombs.length;j++){\\n            if(!adj[i]) adj[i] = [];\\n            if(!adj[j]) adj[j] = [];\\n            let bombOne = bombs[i];\\n            let bombTwo = bombs[j];\\n            let fir = checkIfInsideRange(bombOne[0], bombOne[1], bombTwo[0], bombTwo[1], bombOne[2]);     \\n            if(fir) adj[i].push(j);\\n            let sec = checkIfInsideRange(bombOne[0], bombOne[1], bombTwo[0], bombTwo[1], bombTwo[2]);\\n            if(sec) adj[j].push(i);\\n        }\\n    }\\n\\t\\n\\t//DEPTH FIRST SEARCH TO FIND ALL BOMBS TRIGGERED BY NODE\\n    const dfs = (node, visited)=>{\\n        let detonated = 1;\\n        visited[node] = true;\\n        let childs = adj[node] || []\\n        for(let child of childs){\\n            if(visited[child]) continue;\\n            detonated += dfs(child, visited)\\n        }\\n        maxSize = Math.max(maxSize, detonated)\\n        return detonated;\\n    }\\n    \\n    for(let i = 0 ;i<bombs.length;i++){\\n        dfs(i, {})\\n    }\\n    return maxSize\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[][]} bombs\\n * @return {number}\\n */\\nvar maximumDetonation = function(bombs) {\\n    if(bombs.length <= 1) return bombs.length;\\n    \\n    let adj = {}, maxSize = 0;\\n    const checkIfInsideRange = (x, y, center_x, center_y, radius) =>{\\n        return ( (x-center_x)**2 + (y-center_y)**2 <= radius**2 ) \\n    }\\n\\t\\n\\t//CREATE ADJACENCY MATRIX\\n    for(let i = 0;i<bombs.length;i++){\\n        for(let j = i+1;j<bombs.length;j++){\\n            if(!adj[i]) adj[i] = [];\\n            if(!adj[j]) adj[j] = [];\\n            let bombOne = bombs[i];\\n            let bombTwo = bombs[j];\\n            let fir = checkIfInsideRange(bombOne[0], bombOne[1], bombTwo[0], bombTwo[1], bombOne[2]);     \\n            if(fir) adj[i].push(j);\\n            let sec = checkIfInsideRange(bombOne[0], bombOne[1], bombTwo[0], bombTwo[1], bombTwo[2]);\\n            if(sec) adj[j].push(i);\\n        }\\n    }\\n\\t\\n\\t//DEPTH FIRST SEARCH TO FIND ALL BOMBS TRIGGERED BY NODE\\n    const dfs = (node, visited)=>{\\n        let detonated = 1;\\n        visited[node] = true;\\n        let childs = adj[node] || []\\n        for(let child of childs){\\n            if(visited[child]) continue;\\n            detonated += dfs(child, visited)\\n        }\\n        maxSize = Math.max(maxSize, detonated)\\n        return detonated;\\n    }\\n    \\n    for(let i = 0 ;i<bombs.length;i++){\\n        dfs(i, {})\\n    }\\n    return maxSize\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1632803,
                "title": "c-bfs",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    bool isInside(ll circle_x, ll circle_y, ll rad, ll x, ll y){\\n        if ((x - circle_x) * (x - circle_x) + (y - circle_y) * (y - circle_y) <= rad * rad) return true;\\n        else return false;\\n    }\\n    \\n    int bfs(int i, unordered_map<int,vector<int>> &map, int n){\\n        vector<int> vis(n,false);\\n        queue<int> q;\\n        q.push(i);\\n        vis[i] = true;\\n        int count=0;\\n        while(!q.empty()){\\n            int cur = q.front(); q.pop();\\n            count++;\\n            for(auto &child : map[cur]){\\n                if(vis[child]==false){\\n                    q.push(child);\\n                    vis[child] = true;\\n                } \\n            }\\n        }\\n        return count;\\n    }\\n    \\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n = bombs.size();\\n        unordered_map<int,vector<int>> map;\\n        \\n        for(int i=0; i<n; ++i){\\n            int circle_x = bombs[i][0];\\n            int circle_y = bombs[i][1];\\n            int rad = bombs[i][2];\\n            for(int j=0; j<n; ++j){\\n                if(i!=j){\\n                    int x = bombs[j][0];\\n                    int y = bombs[j][1];\\n                    if(isInside(circle_x, circle_y, rad, x, y)) map[i].push_back(j);\\n                } \\n            }\\n        }\\n        \\n        int maxDefuse = 0;\\n        for(int i=0; i<n; ++i){\\n            maxDefuse = max(maxDefuse, bfs(i,map,n));\\n        }\\n        return maxDefuse;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    bool isInside(ll circle_x, ll circle_y, ll rad, ll x, ll y){\\n        if ((x - circle_x) * (x - circle_x) + (y - circle_y) * (y - circle_y) <= rad * rad) return true;\\n        else return false;\\n    }\\n    \\n    int bfs(int i, unordered_map<int,vector<int>> &map, int n){\\n        vector<int> vis(n,false);\\n        queue<int> q;\\n        q.push(i);\\n        vis[i] = true;\\n        int count=0;\\n        while(!q.empty()){\\n            int cur = q.front(); q.pop();\\n            count++;\\n            for(auto &child : map[cur]){\\n                if(vis[child]==false){\\n                    q.push(child);\\n                    vis[child] = true;\\n                } \\n            }\\n        }\\n        return count;\\n    }\\n    \\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n = bombs.size();\\n        unordered_map<int,vector<int>> map;\\n        \\n        for(int i=0; i<n; ++i){\\n            int circle_x = bombs[i][0];\\n            int circle_y = bombs[i][1];\\n            int rad = bombs[i][2];\\n            for(int j=0; j<n; ++j){\\n                if(i!=j){\\n                    int x = bombs[j][0];\\n                    int y = bombs[j][1];\\n                    if(isInside(circle_x, circle_y, rad, x, y)) map[i].push_back(j);\\n                } \\n            }\\n        }\\n        \\n        int maxDefuse = 0;\\n        for(int i=0; i<n; ++i){\\n            maxDefuse = max(maxDefuse, bfs(i,map,n));\\n        }\\n        return maxDefuse;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588739,
                "title": "detonate-the-maximum-bombs-optimized-solution-daily-leetcode-challenge",
                "content": "```\\nclass Solution {\\npublic:\\n    // Helper function to calculate distance between two points\\n    int distance(int x, int y, int x1, int y1)\\n    {\\n        double temp = sqrt(pow(x1 - x, 2) + pow(y1 - y, 2));  // Euclidean distance formula\\n        return ceil(temp);  // Round up the distance to the nearest integer\\n    }\\n    \\n    // Depth-first search to calculate the number of bombs that can be detonated starting from a given index\\n    int dfs(int index, vector<int>& visited, vector<vector<int>>& graph)\\n    {\\n        int temp = 1;  // Initialize the count to 1, considering the current bomb itself as detonated\\n        visited[index] = 1;  // Mark the current index as visited\\n        \\n        // Iterate through the adjacent bombs in the graph\\n        for (auto x : graph[index])\\n        {\\n            if (visited[x] == 0)  // If the adjacent bomb has not been visited\\n            {\\n                temp += dfs(x, visited, graph);  // Recursively calculate the count of detonated bombs\\n            }\\n        }\\n        \\n        return temp;  // Return the total count of detonated bombs\\n    }\\n    \\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n = bombs.size();  // Total number of bombs\\n        \\n        // Create a graph to represent the relationships between bombs\\n        vector<vector<int>> graph(n);\\n        \\n        // Construct the graph by checking the distances between each pair of bombs\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = i + 1; j < n; j++)\\n            {\\n                int x = bombs[i][0];\\n                int y = bombs[i][1];\\n                int x1 = bombs[j][0];\\n                int y1 = bombs[j][1];\\n                int r = bombs[i][2];\\n                int r1 = bombs[j][2];\\n                \\n                // Calculate the distance between the bombs and check if they can detonate each other\\n                int temp = distance(x, y, x1, y1);\\n                if (temp <= r)\\n                {\\n                    graph[i].push_back(j);  // Add j as an adjacent bomb to i\\n                }\\n                if (temp <= r1)\\n                {\\n                    graph[j].push_back(i);  // Add i as an adjacent bomb to j\\n                }\\n            }\\n        }\\n        \\n        // Perform depth-first search on each bomb to find the maximum number of detonated bombs\\n        vector<int> visited;  // Keep track of visited bombs\\n        vector<int> x(n, 0);  // Initialize the visited array with zeros\\n        int ans = 1;  // Initialize the maximum count of detonated bombs to 1\\n        \\n        // Iterate through each bomb as a starting point for the depth-first search\\n        for (int i = 0; i < n; i++)\\n        {\\n            visited = x;  // Reset the visited array for each iteration\\n            int temp = dfs(i, visited, graph);  // Perform depth-first search and get the count\\n            ans = max(ans, temp);  // Update the maximum count if necessary\\n        }\\n        \\n        return ans;  // Return the maximum count of detonated bombs\\n    }\\n};\\n```\\n\\n**PLEASE UPVOTE :)**",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Helper function to calculate distance between two points\\n    int distance(int x, int y, int x1, int y1)\\n    {\\n        double temp = sqrt(pow(x1 - x, 2) + pow(y1 - y, 2));  // Euclidean distance formula\\n        return ceil(temp);  // Round up the distance to the nearest integer\\n    }\\n    \\n    // Depth-first search to calculate the number of bombs that can be detonated starting from a given index\\n    int dfs(int index, vector<int>& visited, vector<vector<int>>& graph)\\n    {\\n        int temp = 1;  // Initialize the count to 1, considering the current bomb itself as detonated\\n        visited[index] = 1;  // Mark the current index as visited\\n        \\n        // Iterate through the adjacent bombs in the graph\\n        for (auto x : graph[index])\\n        {\\n            if (visited[x] == 0)  // If the adjacent bomb has not been visited\\n            {\\n                temp += dfs(x, visited, graph);  // Recursively calculate the count of detonated bombs\\n            }\\n        }\\n        \\n        return temp;  // Return the total count of detonated bombs\\n    }\\n    \\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n = bombs.size();  // Total number of bombs\\n        \\n        // Create a graph to represent the relationships between bombs\\n        vector<vector<int>> graph(n);\\n        \\n        // Construct the graph by checking the distances between each pair of bombs\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = i + 1; j < n; j++)\\n            {\\n                int x = bombs[i][0];\\n                int y = bombs[i][1];\\n                int x1 = bombs[j][0];\\n                int y1 = bombs[j][1];\\n                int r = bombs[i][2];\\n                int r1 = bombs[j][2];\\n                \\n                // Calculate the distance between the bombs and check if they can detonate each other\\n                int temp = distance(x, y, x1, y1);\\n                if (temp <= r)\\n                {\\n                    graph[i].push_back(j);  // Add j as an adjacent bomb to i\\n                }\\n                if (temp <= r1)\\n                {\\n                    graph[j].push_back(i);  // Add i as an adjacent bomb to j\\n                }\\n            }\\n        }\\n        \\n        // Perform depth-first search on each bomb to find the maximum number of detonated bombs\\n        vector<int> visited;  // Keep track of visited bombs\\n        vector<int> x(n, 0);  // Initialize the visited array with zeros\\n        int ans = 1;  // Initialize the maximum count of detonated bombs to 1\\n        \\n        // Iterate through each bomb as a starting point for the depth-first search\\n        for (int i = 0; i < n; i++)\\n        {\\n            visited = x;  // Reset the visited array for each iteration\\n            int temp = dfs(i, visited, graph);  // Perform depth-first search and get the count\\n            ans = max(ans, temp);  // Update the maximum count if necessary\\n        }\\n        \\n        return ans;  // Return the maximum count of detonated bombs\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2285193,
                "title": "detonate-maximum-bombs-c-explained-solution",
                "content": "The problem here can be solved in 2 ways. Using **BFS** or **DFS**. We have discussed BFS here because it can reduce down the code needed in DFS to form the graph first. Basically if you see, we have been given a **DIRECTED GRAPH**. Note : **The graph might not be a DAG (Directed Acyclic Graph) cause it might be possible that a series of bombs might blast each other thus forming a cycle. So specifically we are only given a directed graph.** Now simply what we can do is choose each bomb and then perform BFS to obtain all bombs that might get detonated and take maximum among all choices. The implementation is given below :\\n\\nTime Complexity : O(N^2)\\nSpace Complexity : O(N)\\n\\nCode\\n```\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        ios_base::sync_with_stdio(0);\\n        int n = bombs.size();\\n        int maxbombs = 0; vector<bool>visited(n,false);\\n        for(int i = 0; i<n; i++){\\n            queue<int>q; int countbombs = 0;\\n            q.push(i);\\n            while(!q.empty()){\\n                int u = q.front(); q.pop();\\n                countbombs++;\\n                visited[u] = true;\\n                long long x = bombs[u][0],y = bombs[u][1],r = bombs[u][2];\\n                for(int j = 0; j<n; j++){\\n                    if(!visited[j]){\\n                        long long dx = bombs[j][0],dy = bombs[j][1],rd = bombs[j][2];\\n                        long long dis = (x-dx)*(x-dx)+(y-dy)*(y-dy);\\n                        if(dis<=r*r){\\n                            visited[j] = true;\\n                            q.push(j);\\n                        }\\n                    }\\n                }\\n            }\\n            maxbombs = max(maxbombs,countbombs);\\n            for(int i = 0; i<n; i++){\\n                visited[i] = false;\\n            }\\n        }\\n        return maxbombs;\\n    }\\n};\\n```\\n\\n**Do Upvote If Found Helpful !**",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        ios_base::sync_with_stdio(0);\\n        int n = bombs.size();\\n        int maxbombs = 0; vector<bool>visited(n,false);\\n        for(int i = 0; i<n; i++){\\n            queue<int>q; int countbombs = 0;\\n            q.push(i);\\n            while(!q.empty()){\\n                int u = q.front(); q.pop();\\n                countbombs++;\\n                visited[u] = true;\\n                long long x = bombs[u][0],y = bombs[u][1],r = bombs[u][2];\\n                for(int j = 0; j<n; j++){\\n                    if(!visited[j]){\\n                        long long dx = bombs[j][0],dy = bombs[j][1],rd = bombs[j][2];\\n                        long long dis = (x-dx)*(x-dx)+(y-dy)*(y-dy);\\n                        if(dis<=r*r){\\n                            visited[j] = true;\\n                            q.push(j);\\n                        }\\n                    }\\n                }\\n            }\\n            maxbombs = max(maxbombs,countbombs);\\n            for(int i = 0; i<n; i++){\\n                visited[i] = false;\\n            }\\n        }\\n        return maxbombs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1644092,
                "title": "python-bfs-faster-than-96",
                "content": "1. Create a dictionary: the key is the index of each bomb, value is the indexes of all the bombs which the key bomb could detonate;\\n2. Use BFS to calculate the number of bombs \\n3. **No need to loop for all the keys in the dictionary,** for example:\\nif bombs[3] can detonate bombs[4], bombs[5], bombs[6], so there is no need to calculate the detonated quantity of bombs 4,5 and 6;\\ncause this question requires returning the maximum quantity detonated, and the number of bombs 4, 5, and 6 will no more than that of bomb 3.\\n**so the looped bomb list should be keeping removing all the sub-detonated bombs after each iteration.**\\n\\n    Please leave messages if you get any questions or suggestions. Thank you.\\n\\nclass Solution:\\n    def maximumDetonation(self, bombs: List[List[int]]) -> int:\\n        \\n        \\n        cnt,n=0,len(bombs)\\n        ori=set(range(n))\\n        dic={}\\n        for i in range(n):\\n            dic[i]=set()\\n        \\n        for i in range(n):\\n            [x1,y1,r1]=bombs[i]\\n            for j in range(i+1,n):\\n                [x2,y2,r2]=bombs[j]\\n                \\n                sqare_distance=pow(x1-x2,2)+pow(y1-y2,2)                \\n                if sqare_distance<=pow(r1,2):\\n                    dic[i].add(j)\\n                if sqare_distance<=pow(r2,2):\\n                    dic[j].add(i)\\n                \\n        while ori:\\n            i=ori.pop()\\n            cur=diff=dic[i]          \\n            cur.add(i)\\n            pre=cur           \\n                        \\n            while diff:                \\n                for next in diff:\\n                    cur=cur|dic[next]                    \\n                \\n                diff=cur-pre\\n                pre=cur              \\n            \\n            ori-=pre                           // step 3          \\n            cnt=max(cnt,len(cur))\\n                \\n        return cnt",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "class Solution:\\n    def maximumDetonation(self, bombs: List[List[int]]) -> int:\\n        \\n        \\n        cnt,n=0,len(bombs)\\n        ori=set(range(n))\\n        dic={}",
                "codeTag": "Java"
            },
            {
                "id": 1623520,
                "title": "simple-java-dfs-faster-than-90",
                "content": "Here is a brute force solution. TC might be improved. \\n\\nThis below snippet code improves the runtime to 90%\\n\\n```\\nif(k == bombs.length){ //improves runtime.\\n     return k;\\n }\\n```\\n\\n```\\nclass Solution {\\n    Map<Integer, List<Integer>> map = new HashMap<>();\\n    public int maximumDetonation(int[][] bombs) {\\n        \\n        for(int i=0; i<bombs.length; i++){\\n            int[] b1 = bombs[i];\\n            for(int j=0; j<bombs.length; j++){\\n                if(i == j){\\n                    continue;\\n                }\\n                int[] b2 = bombs[j];\\n                if(isInside(b1[0], b1[1], b1[2], b2[0], b2[1])){\\n                    map.putIfAbsent(i, new ArrayList<>());\\n                    map.get(i).add(j);\\n                }\\n            }\\n        }\\n\\n        int max = 0;\\n        for(int i=0; i<bombs.length; i++){\\n            int k = dfs(i, new boolean[bombs.length]);\\n            if(k == bombs.length){ //improves runtime.\\n                return k;\\n            }\\n            max = Math.max(max, k);\\n        }\\n\\n        return max;\\n    }\\n    \\n    private int dfs(int node, boolean[] vs){\\n        if(vs[node]){\\n            return 0;\\n        }\\n        vs[node] = true;\\n        \\n        int res = 1;\\n        for(int nei : map.getOrDefault(node, new ArrayList<>())){\\n            res += dfs(nei, vs);\\n        }\\n\\n        return res;\\n    }\\n    \\n\\t//if a circle touches or crosses another circle\\'s center then detonating the previos circle will also detonate this circle.\\n    private boolean isInside(long x1, long y1,\\n                            long rad, long x, long y){\\n        long dist = ((x - x1) * (x - x1) + (y - y1) * (y - y1));\\n        long radius = rad * rad;\\n        \\n        return radius >= dist;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nif(k == bombs.length){ //improves runtime.\\n     return k;\\n }\\n```\n```\\nclass Solution {\\n    Map<Integer, List<Integer>> map = new HashMap<>();\\n    public int maximumDetonation(int[][] bombs) {\\n        \\n        for(int i=0; i<bombs.length; i++){\\n            int[] b1 = bombs[i];\\n            for(int j=0; j<bombs.length; j++){\\n                if(i == j){\\n                    continue;\\n                }\\n                int[] b2 = bombs[j];\\n                if(isInside(b1[0], b1[1], b1[2], b2[0], b2[1])){\\n                    map.putIfAbsent(i, new ArrayList<>());\\n                    map.get(i).add(j);\\n                }\\n            }\\n        }\\n\\n        int max = 0;\\n        for(int i=0; i<bombs.length; i++){\\n            int k = dfs(i, new boolean[bombs.length]);\\n            if(k == bombs.length){ //improves runtime.\\n                return k;\\n            }\\n            max = Math.max(max, k);\\n        }\\n\\n        return max;\\n    }\\n    \\n    private int dfs(int node, boolean[] vs){\\n        if(vs[node]){\\n            return 0;\\n        }\\n        vs[node] = true;\\n        \\n        int res = 1;\\n        for(int nei : map.getOrDefault(node, new ArrayList<>())){\\n            res += dfs(nei, vs);\\n        }\\n\\n        return res;\\n    }\\n    \\n\\t//if a circle touches or crosses another circle\\'s center then detonating the previos circle will also detonate this circle.\\n    private boolean isInside(long x1, long y1,\\n                            long rad, long x, long y){\\n        long dist = ((x - x1) * (x - x1) + (y - y1) * (y - y1));\\n        long radius = rad * rad;\\n        \\n        return radius >= dist;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591286,
                "title": "java-bfs-beats-99-7-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe systematically explore each bomb and its surrounding bombs to determine the maximum number of bombs that can be detonated from each starting point. By performing BFS, we ensure that we consider all reachable bombs and maximize the count of detonations.\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n# Here\\'s a step-by-step approach:\\n\\n1.The **isPossible** **function** determines whether a given bomb can detonate another bomb based on their positions and explosion ranges. It calculates the Euclidean distance between the bombs and compares it with the explosion range. If the distance is less than or equal to the explosion range, the bomb can detonate the other bomb.\\n2.The **helper function** takes the array of bombs and a current bomb index as input. It iterates through all the other bombs, excluding the current bomb, and checks if the current bomb can detonate the surrounding bomb using the isPossible function. If it can, the index of the surrounding bomb is added to the indi_lst ArrayList.\\n3.The **bfs function** performs a BFS traversal starting from a given bomb index. It initializes a queue and a visited array. It adds the starting bomb index to the queue, marks it as visited, increments the count, and then continues exploring its neighboring bombs. For each neighboring bomb, if it hasn\\'t been visited yet, it adds it to the queue, marks it as visited, and increments the count. This process continues until the queue is empty.\\n4.The **maximumDetonation function** is the main function that utilizes the helper and bfs functions. It iterates through each bomb in the given array. If a bomb has not been visited yet, it calls the bfs function to find the maximum number of bombs that can be detonated starting from that bomb. It keeps track of the maximum count of detonations across all bombs and returns it as the result.\\n\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    //Function to know cur_bomb can explode the sur_bomb(current bomb, surounding bomb)\\n    public static boolean isPossible(int[] cur_bomb, int[] sur_bomb) {\\n        long cbx = cur_bomb[0];\\n        long cby = cur_bomb[1];\\n        long cbcap = cur_bomb[2];\\n        long sbx = sur_bomb[0];\\n        long sby = sur_bomb[1];\\n        return (cbx - sbx) * (cbx - sbx) + (cby - sby) * (cby - sby) <= cbcap*cbcap;\\n    }\\n    //helper function to get the ArrayList of surrounding bombs the current bomb can effect.\\n    public static ArrayList<Integer> helper(int[][] bombs, int cur) {\\n        ArrayList<Integer> indi_lst = new ArrayList<>();\\n        for (int i = 0; i < bombs.length; i++) {\\n            if (i == cur) {\\n                continue;\\n            }\\n            if (isPossible(bombs[cur], bombs[i])) {\\n                indi_lst.add(i);\\n            }\\n        }\\n        return indi_lst;\\n    }\\n    //bfs to find the maximum number of bombs the current bomb can explode.\\n    public static int bfs(ArrayList<ArrayList<Integer>> lst, int i, boolean[] flag) {\\n        int res = 0;\\n        Queue<Integer> que = new LinkedList<>();\\n        boolean[] cur_vis = new boolean[lst.size()];\\n        que.add(i);\\n        flag[i] = true;\\n        cur_vis[i]=true;\\n        res++;\\n        while (!que.isEmpty()) {\\n            int bmb = que.poll();\\n            for (int tmp : lst.get(bmb)) {\\n                if (!cur_vis[tmp]) {\\n                    que.add(tmp);\\n                    res++;\\n                    cur_vis[tmp] = true;\\n                    flag[tmp] = true;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    //main function\\n    public int maximumDetonation(int[][] bombs) {\\n        int n = bombs.length;\\n        ArrayList<ArrayList<Integer>> lst = new ArrayList<>(n);\\n        for (int i = 0; i < n; i++) {\\n            lst.add(helper(bombs, i));\\n        }\\n        int res = 0;\\n        boolean[] flag = new boolean[n];\\n        for (int i = 0; i < n; i++) {\\n            if (!flag[i]) {\\n                res = Math.max(res, bfs(lst, i, flag));\\n            }\\n        }\\n        // System.out.println(lst);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    //Function to know cur_bomb can explode the sur_bomb(current bomb, surounding bomb)\\n    public static boolean isPossible(int[] cur_bomb, int[] sur_bomb) {\\n        long cbx = cur_bomb[0];\\n        long cby = cur_bomb[1];\\n        long cbcap = cur_bomb[2];\\n        long sbx = sur_bomb[0];\\n        long sby = sur_bomb[1];\\n        return (cbx - sbx) * (cbx - sbx) + (cby - sby) * (cby - sby) <= cbcap*cbcap;\\n    }\\n    //helper function to get the ArrayList of surrounding bombs the current bomb can effect.\\n    public static ArrayList<Integer> helper(int[][] bombs, int cur) {\\n        ArrayList<Integer> indi_lst = new ArrayList<>();\\n        for (int i = 0; i < bombs.length; i++) {\\n            if (i == cur) {\\n                continue;\\n            }\\n            if (isPossible(bombs[cur], bombs[i])) {\\n                indi_lst.add(i);\\n            }\\n        }\\n        return indi_lst;\\n    }\\n    //bfs to find the maximum number of bombs the current bomb can explode.\\n    public static int bfs(ArrayList<ArrayList<Integer>> lst, int i, boolean[] flag) {\\n        int res = 0;\\n        Queue<Integer> que = new LinkedList<>();\\n        boolean[] cur_vis = new boolean[lst.size()];\\n        que.add(i);\\n        flag[i] = true;\\n        cur_vis[i]=true;\\n        res++;\\n        while (!que.isEmpty()) {\\n            int bmb = que.poll();\\n            for (int tmp : lst.get(bmb)) {\\n                if (!cur_vis[tmp]) {\\n                    que.add(tmp);\\n                    res++;\\n                    cur_vis[tmp] = true;\\n                    flag[tmp] = true;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    //main function\\n    public int maximumDetonation(int[][] bombs) {\\n        int n = bombs.length;\\n        ArrayList<ArrayList<Integer>> lst = new ArrayList<>(n);\\n        for (int i = 0; i < n; i++) {\\n            lst.add(helper(bombs, i));\\n        }\\n        int res = 0;\\n        boolean[] flag = new boolean[n];\\n        for (int i = 0; i < n; i++) {\\n            if (!flag[i]) {\\n                res = Math.max(res, bfs(lst, i, flag));\\n            }\\n        }\\n        // System.out.println(lst);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590666,
                "title": "an-easy-dfs-solution-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf one bomb explodes and the bombs that comes inside its range, it\\'s the indication that its a dfs/bfs problem\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere, i have discussed the dfs approach, just running dfs for each bomb (with a new visited array each time) to see how many bombs will explode if that bomb explodes, and then take max out of all.\\nI have set the ans initially to one, cause in the worst case 1 bomb will always explode as given in question\\n\\n# Complexity\\n- Time complexity: O(n^2), In the worst case for all dfs calls all bombs will be visited\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n- n = no. of bombs\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>& bombs, int i, vector<int>& visited){\\n        int n = bombs.size();\\n        visited[i]=1;\\n        // return 1 + dfs call to the bombs in ranges if not visited\\n\\n        int output = 1;\\n        for(int j=0;j<n;j++){\\n            double tot_dist = sqrt(pow(bombs[i][0]-bombs[j][0],2) + pow(bombs[i][1]-bombs[j][1],2));\\n            if(visited[j]==0 && tot_dist<=bombs[i][2]){\\n                output+= dfs(bombs,j,visited);\\n            }\\n        }\\n        return output;\\n    }\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        // I guess my approach after thinking would be a dfs approach, if a bomb denotes dfs to the bomb in its ranges and return the max output out of all dfs calls\\n        int n = bombs.size();\\n        \\n        int ans = 1;\\n        for(int i=0;i<n;i++){\\n            vector<int> visited(n,0);\\n            ans = max(ans,dfs(bombs,i,visited));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>& bombs, int i, vector<int>& visited){\\n        int n = bombs.size();\\n        visited[i]=1;\\n        // return 1 + dfs call to the bombs in ranges if not visited\\n\\n        int output = 1;\\n        for(int j=0;j<n;j++){\\n            double tot_dist = sqrt(pow(bombs[i][0]-bombs[j][0],2) + pow(bombs[i][1]-bombs[j][1],2));\\n            if(visited[j]==0 && tot_dist<=bombs[i][2]){\\n                output+= dfs(bombs,j,visited);\\n            }\\n        }\\n        return output;\\n    }\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        // I guess my approach after thinking would be a dfs approach, if a bomb denotes dfs to the bomb in its ranges and return the max output out of all dfs calls\\n        int n = bombs.size();\\n        \\n        int ans = 1;\\n        for(int i=0;i<n;i++){\\n            vector<int> visited(n,0);\\n            ans = max(ans,dfs(bombs,i,visited));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590571,
                "title": "video-explanation-math-to-graph-to-dfs-clear-explanation-java",
                "content": "# Approach\\nhttps://youtu.be/hTqokf-HCqg\\n\\n# Similar Problems:\\n\\n- [463. Island Perimeter](https://leetcode.com/problems/island-perimeter/)\\n- [657. Robot Return to Origin](https://leetcode.com/problems/robot-return-to-origin/)\\n- [200. Number of Islands](https://leetcode.com/problems/number-of-islands/)\\n- [Number of Islands II](https://leetcode.com/problems/number-of-islands-ii/)\\n- [547. Number of Provinces](https://leetcode.com/problems/number-of-provinces/)\\n- [2316. Count Unreachable Pairs of Nodes in an Undirected Graph](https://leetcode.com/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/)\\n- [Number of Distinct Islands](https://leetcode.com/problems/number-of-distinct-islands/)\\n- [Number of Connected Components in an Undirected Graph](https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/)\\n- [130. Surrounded Regions](https://leetcode.com/problems/surrounded-regions/)\\n- [2658. Maximum Number of Fish in a Grid](https://leetcode.com/problems/maximum-number-of-fish-in-a-grid/)\\n- [994. Rotting Oranges](https://leetcode.com/problems/rotting-oranges/)\\n- [695. Max Area of Island](https://leetcode.com/problems/max-area-of-island/)\\n- [529. Minesweeper](https://leetcode.com/problems/minesweeper/)\\n\\nI suggest you also solve the above mentioned problem. They can be solved using dfs, bfs or union find algorithms.\\n\\n# Complexity\\n- Time complexity: $$O(N^3)$$\\nBuilding the graph takes $$O(N^2)$$ time. The time complexity of a typical DFS is $$O(V+E)$$ where $$V$$ represents the number of nodes, and $$E$$ represents the number of edges. More specifically, there are $$n$$ nodes and $$n^2$$ edges in this problem. We need to perform $$n$$ depth-first searches.\\n\\n- Space complexity: The space complexity of DFS is $$(N^2)$$. \\nThere are $$(n^2)$$ edges stored in **graph**.\\n\\n# Code (DFS):\\n``` Java []\\nclass Solution {\\n    int n;\\n    public int maximumDetonation(int[][] bombs) {\\n        int res = 0;\\n        n = bombs.length;\\n        for(int i=0; i<n; i++) {\\n            int[] bomb = bombs[i];\\n            boolean[] seen = new boolean[n];\\n            seen[i] = true;\\n            res = Math.max(res, dfs(bombs, i, seen, 1));\\n        }\\n        return res;\\n    }\\n\\n    int dfs(int[][] bombs, int bombIndex, boolean[] seen, int detonate) {\\n        int[] curBomb = bombs[bombIndex];\\n        for(int i=0; i<n; i++) {\\n            if(i==bombIndex || seen[i]) {\\n                continue;\\n            }\\n            int[] bomb = bombs[i];\\n            int x1 = curBomb[0];\\n            int y1 = curBomb[1];\\n            long r1 = curBomb[2];\\n\\n            int x2 = bomb[0];\\n            int y2 = bomb[1];\\n            int r2 = bomb[2];\\n\\n            long dx = (x1-x2);\\n            long dy = (y1-y2);\\n            if(r1*r1 >= dx*dx + dy*dy) {\\n                seen[i] = true;\\n                detonate+=dfs(bombs, i, seen, 1);\\n            }\\n        }\\n        return detonate;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "``` Java []\\nclass Solution {\\n    int n;\\n    public int maximumDetonation(int[][] bombs) {\\n        int res = 0;\\n        n = bombs.length;\\n        for(int i=0; i<n; i++) {\\n            int[] bomb = bombs[i];\\n            boolean[] seen = new boolean[n];\\n            seen[i] = true;\\n            res = Math.max(res, dfs(bombs, i, seen, 1));\\n        }\\n        return res;\\n    }\\n\\n    int dfs(int[][] bombs, int bombIndex, boolean[] seen, int detonate) {\\n        int[] curBomb = bombs[bombIndex];\\n        for(int i=0; i<n; i++) {\\n            if(i==bombIndex || seen[i]) {\\n                continue;\\n            }\\n            int[] bomb = bombs[i];\\n            int x1 = curBomb[0];\\n            int y1 = curBomb[1];\\n            long r1 = curBomb[2];\\n\\n            int x2 = bomb[0];\\n            int y2 = bomb[1];\\n            int r2 = bomb[2];\\n\\n            long dx = (x1-x2);\\n            long dy = (y1-y2);\\n            if(r1*r1 >= dx*dx + dy*dy) {\\n                seen[i] = true;\\n                detonate+=dfs(bombs, i, seen, 1);\\n            }\\n        }\\n        return detonate;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590138,
                "title": "easy-math-and-graph-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long int\\nclass Solution {\\n    public:\\n    void dfs(vector<vector<int>> &adj,vector<bool> &visited,int &c,int &i) {\\n        visited[i]=true;\\n        c++;\\n        for(auto it:adj[i]) {\\n            if(!visited[it])\\n                dfs(adj,visited,c,it);   \\n        }\\n    }\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n\\n        int n=bombs.size();\\n        vector<vector<int> > adj(n);\\n        for(int i=0;i<n;i++) {\\n            ll x1,y1,r1;\\n            x1=bombs[i][0];\\n            y1=bombs[i][1];\\n            r1=bombs[i][2];\\n            for(int j=0;j<n;j++) {\\n                if(i!=j) {\\n                    ll x,y;\\n                    x=abs(x1-bombs[j][0]);\\n                    y=abs(y1-bombs[j][1]);\\n                    if(x*x+y*y<=r1*r1)\\n                        adj[i].push_back(j);\\n                }\\n            }\\n        }\\n\\n        int ans=INT_MIN;\\n        for(int i=0;i<n;i++) {\\n            int c=0;\\n            vector<bool> visited(n,false);\\n            dfs(adj,visited,c,i);\\n            ans=max(ans,c);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\n    public:\\n    void dfs(vector<vector<int>> &adj,vector<bool> &visited,int &c,int &i) {\\n        visited[i]=true;\\n        c++;\\n        for(auto it:adj[i]) {\\n            if(!visited[it])\\n                dfs(adj,visited,c,it);   \\n        }\\n    }\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n\\n        int n=bombs.size();\\n        vector<vector<int> > adj(n);\\n        for(int i=0;i<n;i++) {\\n            ll x1,y1,r1;\\n            x1=bombs[i][0];\\n            y1=bombs[i][1];\\n            r1=bombs[i][2];\\n            for(int j=0;j<n;j++) {\\n                if(i!=j) {\\n                    ll x,y;\\n                    x=abs(x1-bombs[j][0]);\\n                    y=abs(y1-bombs[j][1]);\\n                    if(x*x+y*y<=r1*r1)\\n                        adj[i].push_back(j);\\n                }\\n            }\\n        }\\n\\n        int ans=INT_MIN;\\n        for(int i=0;i<n;i++) {\\n            int c=0;\\n            vector<bool> visited(n,false);\\n            dfs(adj,visited,c,i);\\n            ans=max(ans,c);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589935,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    void dfs(int src,vector<int>& vis,vector<int> adj[])\\n    {\\n        vis[src]=1;\\n        for(int x:adj[src])\\n        {\\n            if(vis[x]==0)\\n            {\\n                dfs(x,vis,adj);\\n            }\\n        }\\n    }\\n    int maximumDetonation(vector<vector<int>>& bombs) \\n    {\\n          int n=bombs.size();\\n          vector<int> adj[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            ll r1=bombs[i][2];\\n            ll x1=bombs[i][0];\\n            ll y1=bombs[i][1];\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i!=j)\\n                {\\n                    ll x2=bombs[j][0];\\n                    ll y2=bombs[j][1];\\n                    ll r2=bombs[j][2];\\n                    ll dsq=(x1-x2)*(x1-x2) + (y1-y2)*(y1-y2);;\\n                    if(dsq<=r1*r1)\\n                    {\\n                        adj[i].push_back(j); \\n                    }\\n                }\\n            }\\n        }\\n        vector<int> vis(n);\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            dfs(i,vis,adj); \\n            int cnt=0;\\n            for(int j=0;j<n;j++) \\n              if(vis[j]==1) cnt++;\\n            ans=max(ans,cnt);\\n            fill(vis.begin(),vis.end(),0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    void dfs(int src,vector<int>& vis,vector<int> adj[])\\n    {\\n        vis[src]=1;\\n        for(int x:adj[src])\\n        {\\n            if(vis[x]==0)\\n            {\\n                dfs(x,vis,adj);\\n            }\\n        }\\n    }\\n    int maximumDetonation(vector<vector<int>>& bombs) \\n    {\\n          int n=bombs.size();\\n          vector<int> adj[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            ll r1=bombs[i][2];\\n            ll x1=bombs[i][0];\\n            ll y1=bombs[i][1];\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i!=j)\\n                {\\n                    ll x2=bombs[j][0];\\n                    ll y2=bombs[j][1];\\n                    ll r2=bombs[j][2];\\n                    ll dsq=(x1-x2)*(x1-x2) + (y1-y2)*(y1-y2);;\\n                    if(dsq<=r1*r1)\\n                    {\\n                        adj[i].push_back(j); \\n                    }\\n                }\\n            }\\n        }\\n        vector<int> vis(n);\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            dfs(i,vis,adj); \\n            int cnt=0;\\n            for(int j=0;j<n;j++) \\n              if(vis[j]==1) cnt++;\\n            ans=max(ans,cnt);\\n            fill(vis.begin(),vis.end(),0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589116,
                "title": "c-easy-to-understand-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void dfs(int node, int &count, vector<vector<int>> &adj, vector<int> &visited){\\n        visited[node] = true;\\n        count++;\\n        for(auto neigh:adj[node]){\\n            if(!visited[neigh])\\n                dfs(neigh, count, adj, visited);\\n        }\\n    }\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n  = bombs.size();\\n        vector<vector<int>> adj(n);\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                int xi = bombs[i][0], yi = bombs[i][1], ri = bombs[i][2];\\n                int xj = bombs[j][0], yj = bombs[j][1];\\n                if(i != j && (long)ri * ri >= (long)(xi - xj) * (xi - xj) + (long)(yi - yj) * (yi - yj) ){\\n                    adj[i].push_back(j);\\n                }\\n            }\\n        }\\n\\n        \\n        int ans = -1;\\n\\n        for(int i=0;i<n;i++){\\n            int count = 0;\\n            vector<int> visited(n, 0);\\n            dfs(i, count, adj, visited);\\n            ans = max(ans, count);\\n        }\\n\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void dfs(int node, int &count, vector<vector<int>> &adj, vector<int> &visited){\\n        visited[node] = true;\\n        count++;\\n        for(auto neigh:adj[node]){\\n            if(!visited[neigh])\\n                dfs(neigh, count, adj, visited);\\n        }\\n    }\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n  = bombs.size();\\n        vector<vector<int>> adj(n);\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                int xi = bombs[i][0], yi = bombs[i][1], ri = bombs[i][2];\\n                int xj = bombs[j][0], yj = bombs[j][1];\\n                if(i != j && (long)ri * ri >= (long)(xi - xj) * (xi - xj) + (long)(yi - yj) * (yi - yj) ){\\n                    adj[i].push_back(j);\\n                }\\n            }\\n        }\\n\\n        \\n        int ans = -1;\\n\\n        for(int i=0;i<n;i++){\\n            int count = 0;\\n            vector<int> visited(n, 0);\\n            dfs(i, count, adj, visited);\\n            ans = max(ans, count);\\n        }\\n\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589085,
                "title": "detailed-explanation-dfs-with-time-and-space-complexity-analysis",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBasic idea is to solve this problem is we are considering n bombs from 0 to n-1. We treat this individuals bomb as node in the graph. If a bomb can reach to the other bombs it means if bomb radius can cover any other bomb then there should be directed edge between this bombs. We need to do this for each bomb and we created graph.\\n\\nNow the next question is how do we know that one bomb can cover the other bomn in it radius. So for two bomb if we want to find distance we use this equation:\\n$$ d = \\\\sqrt{(x_2 - x_1)^2 + (y_2-y_1)^2}$$\\n\\nwe need to check that if distance is less then the radius of bomb then it can reach to the other bomb.\\n\\n$$\\nd<=r,\\n$$\\n$$\\nd^2  = (x_2 - x_1)^2 + (y_2-y_1)^2\\n$$\\n$$\\nd^2  <= r^2  \\n$$ if this condition is true it means bombs can detonate other bomb.\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumDetonation(int[][] bombs) {\\n        int n = bombs.length;\\n\\n        // Create the adjacency list representation of the graph\\n        List<List<Integer>> adjList = createGraph(bombs);\\n\\n        // Array to track visited nodes during DFS\\n        boolean[] vis = new boolean[n];\\n\\n        // Array to keep track of the detonation count\\n        int[] count = new int[1];\\n\\n        // Variable to store the maximum detonation count\\n        int maxValue = Integer.MIN_VALUE;\\n\\n        // Perform DFS starting from each node to find the detonation count\\n        for(int node = 0; node < n; node++){\\n            Arrays.fill(vis, false); // Reset the visited array for each DFS\\n            count[0] = 0; // Reset the detonation count for each DFS\\n            dfs(node, adjList, vis, count); // Perform DFS\\n            maxValue = Math.max(maxValue, count[0]); // Update the maximum detonation count\\n        }\\n\\n        return maxValue; // Return the maximum detonation count\\n    }\\n\\n    // Depth-First Search (DFS) implementation\\n    public void dfs(int node, List<List<Integer>> adjList, boolean[] vis, int count[]){\\n        vis[node] = true; // Mark the current node as visited\\n        count[0]++; // Increment the detonation count for the current node\\n\\n        // Iterate through the adjacent nodes of the current node\\n        for(Integer adjNode : adjList.get(node)){\\n            if(!vis[adjNode]){ // If the adjacent node is not visited\\n                dfs(adjNode, adjList, vis, count); // Recursively perform DFS on the adjacent node\\n            }\\n        }\\n    }\\n\\n    // Create the adjacency list representation of the graph\\n    public List<List<Integer>> createGraph(int[][] bombs){\\n        int n = bombs.length;\\n        List<List<Integer>> adjList = new ArrayList<>(n);\\n\\n        // Iterate through each node in the graph\\n        for(int node = 0; node < n; node++){\\n            adjList.add(new ArrayList<>()); // Create an empty list for the current node\\n            long x1 = bombs[node][0]; // x-coordinate of the current node\\n            long y1 = bombs[node][1]; // y-coordinate of the current node\\n            long r1 = bombs[node][2]; // radius of the current node\\n\\n            // Iterate through each other node in the graph\\n            for(int otherNode = 0; otherNode < n; otherNode++){\\n                if(node != otherNode){ // If the other node is not the current node\\n                    long x2 = bombs[otherNode][0]; // x-coordinate of the other node\\n                    long y2 = bombs[otherNode][1]; // y-coordinate of the other node\\n\\n                    long X = Math.abs(x1 - x2); // Absolute difference in x-coordinates\\n                    long Y = Math.abs(y1 - y2); // Absolute difference in y-coordinates\\n\\n                    if(X * X + Y * Y <= r1 * r1){ // If the distance between the nodes is within the radius\\n                        adjList.get(node).add(otherNode); // Add the other node to the adjacency list of the current node\\n                    }\\n                }\\n            }\\n        }\\n\\n        return adjList; // Return the adjacency list\\n    }\\n}\\n\\n```\\n\\n# Complexity\\n### Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- The **createGraph** method iterates over each bomb and compares it to every other bomb to see if it is within the explosion radius, creating the adjacency list. Due to the two nested loops involved, O(N^2) comparisons are produced. As a result, the adjacency list generation takes O(N^2) time, where N is the total number of bombs.\\n\\n- **DFS traversal:** For each bomb in the graph, we do a DFS traversal in the main maximumDetonation procedure. We just make one trip to each node during each traverse. The total number of iterations required for the DFS traversal is O(N) since each node can have a maximum of N-1 connections (apart from those to itself).\\n\\n- Therefore, the overall time complexity of the solution is O(N^2 + N^2), which simplifies to **O(N^2)**.\\n\\n### Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- The number of bombs, N, determines the solution\\'s O(N) space complexity. This is because the connections between each bomb must be stored because we describe the graph as an adjacency list. The area needed would be inversely correlated to the number of explosives in the worst-case scenario, when all bombs are connected to one another.\\n\\n## Please upvote if you find it useful.\\n\\nif anything wrong please feel free to comment down.",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumDetonation(int[][] bombs) {\\n        int n = bombs.length;\\n\\n        // Create the adjacency list representation of the graph\\n        List<List<Integer>> adjList = createGraph(bombs);\\n\\n        // Array to track visited nodes during DFS\\n        boolean[] vis = new boolean[n];\\n\\n        // Array to keep track of the detonation count\\n        int[] count = new int[1];\\n\\n        // Variable to store the maximum detonation count\\n        int maxValue = Integer.MIN_VALUE;\\n\\n        // Perform DFS starting from each node to find the detonation count\\n        for(int node = 0; node < n; node++){\\n            Arrays.fill(vis, false); // Reset the visited array for each DFS\\n            count[0] = 0; // Reset the detonation count for each DFS\\n            dfs(node, adjList, vis, count); // Perform DFS\\n            maxValue = Math.max(maxValue, count[0]); // Update the maximum detonation count\\n        }\\n\\n        return maxValue; // Return the maximum detonation count\\n    }\\n\\n    // Depth-First Search (DFS) implementation\\n    public void dfs(int node, List<List<Integer>> adjList, boolean[] vis, int count[]){\\n        vis[node] = true; // Mark the current node as visited\\n        count[0]++; // Increment the detonation count for the current node\\n\\n        // Iterate through the adjacent nodes of the current node\\n        for(Integer adjNode : adjList.get(node)){\\n            if(!vis[adjNode]){ // If the adjacent node is not visited\\n                dfs(adjNode, adjList, vis, count); // Recursively perform DFS on the adjacent node\\n            }\\n        }\\n    }\\n\\n    // Create the adjacency list representation of the graph\\n    public List<List<Integer>> createGraph(int[][] bombs){\\n        int n = bombs.length;\\n        List<List<Integer>> adjList = new ArrayList<>(n);\\n\\n        // Iterate through each node in the graph\\n        for(int node = 0; node < n; node++){\\n            adjList.add(new ArrayList<>()); // Create an empty list for the current node\\n            long x1 = bombs[node][0]; // x-coordinate of the current node\\n            long y1 = bombs[node][1]; // y-coordinate of the current node\\n            long r1 = bombs[node][2]; // radius of the current node\\n\\n            // Iterate through each other node in the graph\\n            for(int otherNode = 0; otherNode < n; otherNode++){\\n                if(node != otherNode){ // If the other node is not the current node\\n                    long x2 = bombs[otherNode][0]; // x-coordinate of the other node\\n                    long y2 = bombs[otherNode][1]; // y-coordinate of the other node\\n\\n                    long X = Math.abs(x1 - x2); // Absolute difference in x-coordinates\\n                    long Y = Math.abs(y1 - y2); // Absolute difference in y-coordinates\\n\\n                    if(X * X + Y * Y <= r1 * r1){ // If the distance between the nodes is within the radius\\n                        adjList.get(node).add(otherNode); // Add the other node to the adjacency list of the current node\\n                    }\\n                }\\n            }\\n        }\\n\\n        return adjList; // Return the adjacency list\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588509,
                "title": "c-dfs-bfs-solutions-with-detonating-bomb-process-beating-90-22",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe crucial part is to create the directed graph, i.e. the adjacent list. The bombs are the the vertice. If bomb[j] is within the bomb range of bomb[i], there is a directed edge from bomb[i] to bomb[j]. Then either of DFS or BFS can be applied for solving this problem.\\n\\nAccording the radius of bomb range, sort the bombs in descending order. Then create adjacent list according to Euclidean distance fomula:\\n$$\\nd^2((x, y),(x_j, y_j))=(x-x_j)^2+(y-y_j)^2\\\\leq r^2  \\\\qquad(1)\\n$$\\nwhere $(x, y,r)$ is the info for the  detonating bomb[i] and the bomb[j] with coordinates $(x_j, y_j)$ lies within the bomb[i] range. The computation for the inequality needs to use long long int to prevent overflow! But there are many cases that the bomb is closed to the detonating bomb.\\n\\nSo, we used firstly the easy computing to test whether\\n$$\\n|x-x_j|+|y-y_j|\\\\leq r \\\\qquad(2)\\n$$\\nif the inequality  (2) that\\'s fine add j to adj[i], if not then try the inequality (1) for Euclidean distance fomula. It is clear if the inequality (2) is satisfied, then the inequalty (1) is valid since the triangle inequality.\\n[DFS& BFS solves Leetcode 934 shortest bridge with English subtitles, please turn on if necessary]\\n[https://youtu.be/9Lx7yr-tmfI](https://youtu.be/9Lx7yr-tmfI)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTest case:\\n```\\n[[647,457,91],[483,716,37],[426,119,35],[355,588,40],[850,874,49],[232,568,46],[886,1,30],[54,377,3],[933,986,50],[305,790,49],[372,961,67],[671,314,58],[577,221,29],[380,147,91],[600,535,1],[806,329,64],[536,753,18],[906,88,23],[436,783,82],[652,674,45],[449,668,20],[419,13,66],[853,767,60],[169,288,33],[871,608,66],[337,445,35],[388,623,39],[723,503,81],[14,19,19],[98,648,72],[147,565,93],[655,434,1],[407,663,22],[805,947,83],[942,160,70],[959,496,93],[30,988,53],[187,849,60],[980,483,41],[663,150,76],[268,39,50],[513,522,75],[61,450,90],[115,231,12],[346,304,74],[385,540,23],[905,178,19],[336,896,81],[751,811,94],[527,783,78],[635,965,19],[334,290,39],[748,460,77],[414,134,22],[955,485,29],[925,787,43],[243,771,75],[675,223,29],[788,618,82],[462,544,30],[999,259,50],[210,146,12],[789,442,70],[286,36,55],[451,953,6],[719,914,14],[664,452,14],[933,637,29],[206,926,16],[100,422,98],[97,333,4],[505,631,26],[908,287,65],[907,316,86],[949,185,16],[639,735,62],[401,739,18],[605,926,21],[25,391,69],[80,24,9],[435,874,92],[940,381,18],[260,740,87],[727,515,17],[361,152,16],[512,470,67],[189,27,27],[517,439,94],[159,543,76],[373,698,38],[781,836,97],[584,190,23],[383,367,86],[825,141,63],[117,926,85],[169,588,60],[56,981,100],[294,716,100],[781,370,89],[373,44,78]]\\n```\\nSort the bombs! Create the adjacent list\\n```\\nn=100\\n56,981,100\\n294,716,100\\n100,422,98\\n781,836,97\\n751,811,94\\n517,439,94\\n147,565,93\\n959,496,93\\n435,874,92\\n647,457,91\\n380,147,91\\n61,450,90\\n781,370,89\\n260,740,87\\n383,367,86\\n907,316,86\\n117,926,85\\n805,947,83\\n436,783,82\\n788,618,82\\n336,896,81\\n723,503,81\\n527,783,78\\n373,44,78\\n748,460,77\\n159,543,76\\n663,150,76\\n243,771,75\\n513,522,75\\n346,304,74\\n98,648,72\\n789,442,70\\n942,160,70\\n25,391,69\\n372,961,67\\n512,470,67\\n871,608,66\\n419,13,66\\n908,287,65\\n806,329,64\\n825,141,63\\n639,735,62\\n187,849,60\\n853,767,60\\n169,588,60\\n671,314,58\\n286,36,55\\n30,988,53\\n933,986,50\\n999,259,50\\n268,39,50\\n850,874,49\\n305,790,49\\n232,568,46\\n652,674,45\\n925,787,43\\n980,483,41\\n355,588,40\\n388,623,39\\n334,290,39\\n373,698,38\\n483,716,37\\n337,445,35\\n426,119,35\\n169,288,33\\n462,544,30\\n886,1,30\\n933,637,29\\n955,485,29\\n675,223,29\\n577,221,29\\n189,27,27\\n505,631,26\\n385,540,23\\n584,190,23\\n906,88,23\\n407,663,22\\n414,134,22\\n605,926,21\\n449,668,20\\n635,965,19\\n905,178,19\\n14,19,19\\n536,753,18\\n401,739,18\\n940,381,18\\n727,515,17\\n206,926,16\\n949,185,16\\n361,152,16\\n719,914,14\\n664,452,14\\n115,231,12\\n210,146,12\\n80,24,9\\n451,953,6\\n97,333,4\\n54,377,3\\n600,535,1\\n655,434,1\\n=======\\nadj lists:\\n0:[16,47]\\n1:[13,27,52,60]\\n2:[11,33,96,97]\\n3:[4,51]\\n4:[3]\\n5:[28,35]\\n6:[25,44,53]\\n7:[56,68]\\n8:[18,95]\\n9:[21,91,99]\\n10:[63,77,89]\\n11:[2,33,97]\\n12:[31,39]\\n13:[1,27,52]\\n14:[29]\\n15:[38,85]\\n16:[0]\\n18:[61,84]\\n20:[34]\\n21:[24,86,91]\\n22:[83]\\n23:[37]\\n24:[21,31,86]\\n25:[6,44]\\n26:[69]\\n27:[13,52]\\n28:[35,65]\\n29:[14,59]\\n31:[24]\\n32:[81,88]\\n33:[97]\\n35:[5,28]\\n37:[23]\\n38:[15]\\n39:[12]\\n44:[6,25]\\n46:[50]\\n47:[0]\\n50:[46]\\n56:[7,68]\\n59:[29]\\n63:[77]\\n68:[7,56]\\n77:[63]\\n86:[21]\\nans=7\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code with Explanation in Comments\\nIf the sorting process is not used, the elapsed time is 90 ms and beats 90.22%.  With sorting, the elapsed time is 106 ms and beats 81.1%\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int MaxBomb = 1;\\n    vector<vector<int>> adj;\\n\\n    // Print the information of bombs\\n    void print(vector<vector<int>>& bombs){\\n        cout << \"n=\" << n << endl;\\n        for(vector<int> b : bombs)\\n            cout << b[0] << \",\" << b[1] << \",\" << b[2] << endl;\\n    }\\n\\n    // Print the adjacent list information\\n    void print_adj(){\\n        cout << \"=======\\\\nadj lists:\\\\n\";\\n        for(int i=0; i<n; i++){\\n            cout << i << \":[\";\\n            for(int j=0; j<adj[i].size(); j++)\\n                cout << adj[i][j] << \",\";\\n            cout << \"]\" << endl;\\n        }\\n    }\\n\\n    // Create the adjacent list\\n    void create_adj(vector<vector<int>>& bombs){\\n        for(int i=0; i<n; i++){\\n            long long r = bombs[i][2], x = bombs[i][0], y = bombs[i][1];\\n            for(int j=0; j<n; j++){\\n                if(i != j){\\n                    double xd = bombs[j][0] - x, yd = bombs[j][1] - y;\\n                    if (abs(xd) + abs(yd) <= r) \\n// If the distance is less than or equal to the radius, it might be very close to bomb[i]\\n                        \\n                        adj[i].push_back(j);\\n                    else if (r*r >= xd*xd + yd*yd) \\n// If the distance satisfies condition (1)\\n                        adj[i].push_back(j);\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<bool> detonated;\\n\\n    // Use Depth-First Search (DFS) recursively to calculate the number of bombs in the detonation range\\n    void dfs(int i){\\n        MaxBomb++;\\n        detonated[i] = 1;\\n        for(int j : adj[i]){\\n            if(!detonated[j])\\n                dfs(j);\\n        }\\n    }\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        n = bombs.size();\\n\\n        // Sort the bombs in descending order based on the radius\\n        sort(bombs.begin(), bombs.end(),\\n        [](vector<int>& a, vector<int>& b ){\\n            if(a[2] != b[2]) return a[2] > b[2];\\n            return a[1] > b[1];\\n        });\\n\\n        // Print the sorted bombs information\\n        print(bombs);\\n\\n        adj.resize(n);\\n        create_adj(bombs); // Create the adjacent list\\n        print_adj(); // Print the adjacent list information\\n\\n        int ans = 0;\\n        detonated.assign(n, 0);\\n        for(int i = 0; i < n; i++){\\n            if(!detonated[i]){\\n                MaxBomb = 0;\\n                dfs(i); // Call the DFS function to calculate the number of bombs in the detonation range\\n                ans = max(ans, MaxBomb);\\n            }\\n            detonated.assign(n, 0);\\n        }\\n        cout << ans << endl;\\n        return ans;\\n    }\\n};\\n\\n```\\n# BFS can work too. Just replace dfs by bfs\\n```\\nvoid bfs(int i) {\\n        queue<int> q;\\n        q.push(i);\\n        detonated[i] = 1;     \\n        while (!q.empty()) {\\n            int j = q.front();\\n            q.pop();\\n            MaxBomb++;        \\n            for (int k : adj[j]) {\\n                if (!detonated[k]) {\\n                    q.push(k);\\n                    detonated[k] = 1;\\n                }\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Geometry"
                ],
                "code": "```\\n[[647,457,91],[483,716,37],[426,119,35],[355,588,40],[850,874,49],[232,568,46],[886,1,30],[54,377,3],[933,986,50],[305,790,49],[372,961,67],[671,314,58],[577,221,29],[380,147,91],[600,535,1],[806,329,64],[536,753,18],[906,88,23],[436,783,82],[652,674,45],[449,668,20],[419,13,66],[853,767,60],[169,288,33],[871,608,66],[337,445,35],[388,623,39],[723,503,81],[14,19,19],[98,648,72],[147,565,93],[655,434,1],[407,663,22],[805,947,83],[942,160,70],[959,496,93],[30,988,53],[187,849,60],[980,483,41],[663,150,76],[268,39,50],[513,522,75],[61,450,90],[115,231,12],[346,304,74],[385,540,23],[905,178,19],[336,896,81],[751,811,94],[527,783,78],[635,965,19],[334,290,39],[748,460,77],[414,134,22],[955,485,29],[925,787,43],[243,771,75],[675,223,29],[788,618,82],[462,544,30],[999,259,50],[210,146,12],[789,442,70],[286,36,55],[451,953,6],[719,914,14],[664,452,14],[933,637,29],[206,926,16],[100,422,98],[97,333,4],[505,631,26],[908,287,65],[907,316,86],[949,185,16],[639,735,62],[401,739,18],[605,926,21],[25,391,69],[80,24,9],[435,874,92],[940,381,18],[260,740,87],[727,515,17],[361,152,16],[512,470,67],[189,27,27],[517,439,94],[159,543,76],[373,698,38],[781,836,97],[584,190,23],[383,367,86],[825,141,63],[117,926,85],[169,588,60],[56,981,100],[294,716,100],[781,370,89],[373,44,78]]\\n```\n```\\nn=100\\n56,981,100\\n294,716,100\\n100,422,98\\n781,836,97\\n751,811,94\\n517,439,94\\n147,565,93\\n959,496,93\\n435,874,92\\n647,457,91\\n380,147,91\\n61,450,90\\n781,370,89\\n260,740,87\\n383,367,86\\n907,316,86\\n117,926,85\\n805,947,83\\n436,783,82\\n788,618,82\\n336,896,81\\n723,503,81\\n527,783,78\\n373,44,78\\n748,460,77\\n159,543,76\\n663,150,76\\n243,771,75\\n513,522,75\\n346,304,74\\n98,648,72\\n789,442,70\\n942,160,70\\n25,391,69\\n372,961,67\\n512,470,67\\n871,608,66\\n419,13,66\\n908,287,65\\n806,329,64\\n825,141,63\\n639,735,62\\n187,849,60\\n853,767,60\\n169,588,60\\n671,314,58\\n286,36,55\\n30,988,53\\n933,986,50\\n999,259,50\\n268,39,50\\n850,874,49\\n305,790,49\\n232,568,46\\n652,674,45\\n925,787,43\\n980,483,41\\n355,588,40\\n388,623,39\\n334,290,39\\n373,698,38\\n483,716,37\\n337,445,35\\n426,119,35\\n169,288,33\\n462,544,30\\n886,1,30\\n933,637,29\\n955,485,29\\n675,223,29\\n577,221,29\\n189,27,27\\n505,631,26\\n385,540,23\\n584,190,23\\n906,88,23\\n407,663,22\\n414,134,22\\n605,926,21\\n449,668,20\\n635,965,19\\n905,178,19\\n14,19,19\\n536,753,18\\n401,739,18\\n940,381,18\\n727,515,17\\n206,926,16\\n949,185,16\\n361,152,16\\n719,914,14\\n664,452,14\\n115,231,12\\n210,146,12\\n80,24,9\\n451,953,6\\n97,333,4\\n54,377,3\\n600,535,1\\n655,434,1\\n=======\\nadj lists:\\n0:[16,47]\\n1:[13,27,52,60]\\n2:[11,33,96,97]\\n3:[4,51]\\n4:[3]\\n5:[28,35]\\n6:[25,44,53]\\n7:[56,68]\\n8:[18,95]\\n9:[21,91,99]\\n10:[63,77,89]\\n11:[2,33,97]\\n12:[31,39]\\n13:[1,27,52]\\n14:[29]\\n15:[38,85]\\n16:[0]\\n18:[61,84]\\n20:[34]\\n21:[24,86,91]\\n22:[83]\\n23:[37]\\n24:[21,31,86]\\n25:[6,44]\\n26:[69]\\n27:[13,52]\\n28:[35,65]\\n29:[14,59]\\n31:[24]\\n32:[81,88]\\n33:[97]\\n35:[5,28]\\n37:[23]\\n38:[15]\\n39:[12]\\n44:[6,25]\\n46:[50]\\n47:[0]\\n50:[46]\\n56:[7,68]\\n59:[29]\\n63:[77]\\n68:[7,56]\\n77:[63]\\n86:[21]\\nans=7\\n```\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int MaxBomb = 1;\\n    vector<vector<int>> adj;\\n\\n    // Print the information of bombs\\n    void print(vector<vector<int>>& bombs){\\n        cout << \"n=\" << n << endl;\\n        for(vector<int> b : bombs)\\n            cout << b[0] << \",\" << b[1] << \",\" << b[2] << endl;\\n    }\\n\\n    // Print the adjacent list information\\n    void print_adj(){\\n        cout << \"=======\\\\nadj lists:\\\\n\";\\n        for(int i=0; i<n; i++){\\n            cout << i << \":[\";\\n            for(int j=0; j<adj[i].size(); j++)\\n                cout << adj[i][j] << \",\";\\n            cout << \"]\" << endl;\\n        }\\n    }\\n\\n    // Create the adjacent list\\n    void create_adj(vector<vector<int>>& bombs){\\n        for(int i=0; i<n; i++){\\n            long long r = bombs[i][2], x = bombs[i][0], y = bombs[i][1];\\n            for(int j=0; j<n; j++){\\n                if(i != j){\\n                    double xd = bombs[j][0] - x, yd = bombs[j][1] - y;\\n                    if (abs(xd) + abs(yd) <= r) \\n// If the distance is less than or equal to the radius, it might be very close to bomb[i]\\n                        \\n                        adj[i].push_back(j);\\n                    else if (r*r >= xd*xd + yd*yd) \\n// If the distance satisfies condition (1)\\n                        adj[i].push_back(j);\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<bool> detonated;\\n\\n    // Use Depth-First Search (DFS) recursively to calculate the number of bombs in the detonation range\\n    void dfs(int i){\\n        MaxBomb++;\\n        detonated[i] = 1;\\n        for(int j : adj[i]){\\n            if(!detonated[j])\\n                dfs(j);\\n        }\\n    }\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        n = bombs.size();\\n\\n        // Sort the bombs in descending order based on the radius\\n        sort(bombs.begin(), bombs.end(),\\n        [](vector<int>& a, vector<int>& b ){\\n            if(a[2] != b[2]) return a[2] > b[2];\\n            return a[1] > b[1];\\n        });\\n\\n        // Print the sorted bombs information\\n        print(bombs);\\n\\n        adj.resize(n);\\n        create_adj(bombs); // Create the adjacent list\\n        print_adj(); // Print the adjacent list information\\n\\n        int ans = 0;\\n        detonated.assign(n, 0);\\n        for(int i = 0; i < n; i++){\\n            if(!detonated[i]){\\n                MaxBomb = 0;\\n                dfs(i); // Call the DFS function to calculate the number of bombs in the detonation range\\n                ans = max(ans, MaxBomb);\\n            }\\n            detonated.assign(n, 0);\\n        }\\n        cout << ans << endl;\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nvoid bfs(int i) {\\n        queue<int> q;\\n        q.push(i);\\n        detonated[i] = 1;     \\n        while (!q.empty()) {\\n            int j = q.front();\\n            q.pop();\\n            MaxBomb++;        \\n            for (int k : adj[j]) {\\n                if (!detonated[k]) {\\n                    q.push(k);\\n                    detonated[k] = 1;\\n                }\\n            }\\n        }\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3588156,
                "title": "c-solution-using-dfs",
                "content": "# Complexity\\n- Time complexity:\\nO(n^3)\\n\\n- Space complexity:\\nO(n^2)to store the graph + O(n)for dfs recursion stack\\n\\n# Code\\n```\\n class Solution {\\npublic:\\n    //general dfs algorithm to find all the connected bombs (you can use bfs as well)\\n    void dfs(int node, vector<int> &visited, vector<int> adj[], int &cnt){\\n        visited[node] = 1;\\n        cnt++;\\n\\n        for(auto neighbour: adj[node]){\\n            if(!visited[neighbour]){\\n                dfs(neighbour, visited, adj, cnt);\\n            }\\n        }\\n    }\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n = bombs.size();\\n        vector<int> adj[n];\\n\\n        //make a directed graph of the distance of bombs with one another\\n        //if the radius of a bomb is greater than the distance with another bomb -> it means there is a directed edge between them\\n        for(int i=0; i<n; i++){\\n            long long int x0, y0, r0;\\n            x0 = bombs[i][0];\\n            y0 = bombs[i][1];\\n            r0 = bombs[i][2];\\n\\n            for(int j=0; j<n; j++){\\n                //if i and j are equal it means both bombs are same so there is no need to check\\n                if(i != j){\\n                    long long int x, y;\\n                    x = abs(x0 - bombs[j][0]);\\n                    y = abs(y0 - bombs[j][1]);\\n\\n                    if(x*x + y*y <= r0*r0){\\n                        adj[i].push_back(j);\\n                    }\\n                }\\n            }\\n        }\\n\\n        //call dfs for every node to see how many bombs are connected with that single bomb\\n        int ans = INT_MIN;\\n        for(int i=0; i<n; i++){\\n            int cnt = 0;\\n            vector<int> visited(n, 0);\\n            dfs(i, visited, adj, cnt);\\n\\n            ans = max(ans, cnt);\\n        }\\n\\n        //return the bomb with maximum number of connected bombs\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\n class Solution {\\npublic:\\n    //general dfs algorithm to find all the connected bombs (you can use bfs as well)\\n    void dfs(int node, vector<int> &visited, vector<int> adj[], int &cnt){\\n        visited[node] = 1;\\n        cnt++;\\n\\n        for(auto neighbour: adj[node]){\\n            if(!visited[neighbour]){\\n                dfs(neighbour, visited, adj, cnt);\\n            }\\n        }\\n    }\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n = bombs.size();\\n        vector<int> adj[n];\\n\\n        //make a directed graph of the distance of bombs with one another\\n        //if the radius of a bomb is greater than the distance with another bomb -> it means there is a directed edge between them\\n        for(int i=0; i<n; i++){\\n            long long int x0, y0, r0;\\n            x0 = bombs[i][0];\\n            y0 = bombs[i][1];\\n            r0 = bombs[i][2];\\n\\n            for(int j=0; j<n; j++){\\n                //if i and j are equal it means both bombs are same so there is no need to check\\n                if(i != j){\\n                    long long int x, y;\\n                    x = abs(x0 - bombs[j][0]);\\n                    y = abs(y0 - bombs[j][1]);\\n\\n                    if(x*x + y*y <= r0*r0){\\n                        adj[i].push_back(j);\\n                    }\\n                }\\n            }\\n        }\\n\\n        //call dfs for every node to see how many bombs are connected with that single bomb\\n        int ans = INT_MIN;\\n        for(int i=0; i<n; i++){\\n            int cnt = 0;\\n            vector<int> visited(n, 0);\\n            dfs(i, visited, adj, cnt);\\n\\n            ans = max(ans, cnt);\\n        }\\n\\n        //return the bomb with maximum number of connected bombs\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3189562,
                "title": "c-easy-to-understand-dfs-solution",
                "content": "# Intuition\\nWe select a bomb Bi to detonate first and then look for other bombs in range (let\\'s say it is Bj), it form\\'s a graph i.e, there exist a directed edge between bomb Bi and Bj and so on. Thus, DFS can be applied on each and every bomb in our array and max result can be checked after completion of each DFS.\\n\\n# Approach\\n1. Declare ans as -1 or INT_MIN (any negative value).\\n2. Select each bomb in the array as the first bomb to detonate.\\n3. Create a hash table to keep record of already detonated bomb so that we don\\'t count them more than once in our DFS (Similar to avoiding cycle in a graph).\\n4. Call DFS.\\n5. Go through each bomb that has not yet detonated.\\n6. If the bomb Bj is in range i.e the distance between the bombs Bi and Bj in less than ri(radius of Bi) than Bj will explode so mark it visited and apply DFS on it and add the bombs that will detonate because of Bj to Bi. \\n7. Return the number of bombs that can explode because of the detonation of ith bomb *(Note that curr_ans=1 because if a bomb is detonated than atleast it will explode even if no other bomb is in range).*\\n8. Compare it with the earlier answer .\\n# Complexity\\n- Time complexity:\\nO(n^3)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    long long distance(long long x1,long long y1,long long x2,long long y2){\\n        return (x2-x1)*(x2-x1)+(y2-y1)*(y2-y1);\\n    }\\n    int dfs(vector<vector<int>>&bombs,int i,map<int,bool>&visited){\\n        int curr_ans=1;\\n        \\n        for(int j=0;j<bombs.size();j++){\\n            if(j==i or visited[j]==true)continue;\\n            long long dis=distance(bombs[i][0],bombs[i][1],bombs[j][0],bombs[j][1]);\\n            if(dis<=bombs[i][2]*1LL*bombs[i][2]){\\n                visited[j]=true;\\n                curr_ans+=dfs(bombs,j,visited);\\n            }\\n        }\\n        return curr_ans;\\n    }\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int ans=INT_MIN;\\n        for(int i=0;i<bombs.size();i++){\\n            map<int,bool>visited; //use unordered_map or vector for better time\\n            visited[i]=true;\\n            ans=max(ans,dfs(bombs,i,visited));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    long long distance(long long x1,long long y1,long long x2,long long y2){\\n        return (x2-x1)*(x2-x1)+(y2-y1)*(y2-y1);\\n    }\\n    int dfs(vector<vector<int>>&bombs,int i,map<int,bool>&visited){\\n        int curr_ans=1;\\n        \\n        for(int j=0;j<bombs.size();j++){\\n            if(j==i or visited[j]==true)continue;\\n            long long dis=distance(bombs[i][0],bombs[i][1],bombs[j][0],bombs[j][1]);\\n            if(dis<=bombs[i][2]*1LL*bombs[i][2]){\\n                visited[j]=true;\\n                curr_ans+=dfs(bombs,j,visited);\\n            }\\n        }\\n        return curr_ans;\\n    }\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int ans=INT_MIN;\\n        for(int i=0;i<bombs.size();i++){\\n            map<int,bool>visited; //use unordered_map or vector for better time\\n            visited[i]=true;\\n            ans=max(ans,dfs(bombs,i,visited));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2006655,
                "title": "c-bfs-easy-to-understand",
                "content": "**Approach**:-For Every Bomb We will Check how many others Bombs Lies inside it and how many Bombs lies inside the bomb which Lies inside Checking Bomb and this will Go on.\\n-->This will be done with the help of **BFS.**\\n-->We will return the bomb which will cover Maximum number of Bombs..\\n```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    ll BFS(vector<vector<int>>& bombs,int i)\\n    {\\n        vector<bool>visited(bombs.size(),0);\\n        queue<int>q;\\n        q.push(i);\\n        visited[i]=true;\\n        ll count=1;\\n        int n=visited.size();\\n        while(!q.empty())\\n        {\\n            int idx=q.front();\\n            q.pop();\\n            ll x=bombs[idx][0];\\n            ll y=bombs[idx][1];\\n            ll r=bombs[idx][2];\\n            \\n            for(int k=0;k<n;k++)\\n            {\\n                if(visited[k]==1) continue;\\n                \\n                ll x1=bombs[k][0];\\n                ll y1=bombs[k][1];\\n                \\n                ll dist=(x-x1)*(x-x1)+(y-y1)*(y-y1); //Distance btween center.\\n                \\n                if(dist<=r*r) //Check whaether it Lies inside it or not (condition that Point Lies inside a circle)\\n                    count++,visited[k]=1,q.push(k); //If yes Mark as Visited ,increase Count and Push in queue.\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        ll ans=1,n=bombs.size();\\n        vector<bool>visited(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            /*For every Bomb Check how many Bomb we can detonate.\\n            -->Use BFS to Check*/\\n                ans=max(ans,BFS(bombs,i)); \\n        }\\n        \\n        return (int)ans;\\n    }\\n};\\n```\\n*If you find it helpful, please upvote.*",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    ll BFS(vector<vector<int>>& bombs,int i)\\n    {\\n        vector<bool>visited(bombs.size(),0);\\n        queue<int>q;\\n        q.push(i);\\n        visited[i]=true;\\n        ll count=1;\\n        int n=visited.size();\\n        while(!q.empty())\\n        {\\n            int idx=q.front();\\n            q.pop();\\n            ll x=bombs[idx][0];\\n            ll y=bombs[idx][1];\\n            ll r=bombs[idx][2];\\n            \\n            for(int k=0;k<n;k++)\\n            {\\n                if(visited[k]==1) continue;\\n                \\n                ll x1=bombs[k][0];\\n                ll y1=bombs[k][1];\\n                \\n                ll dist=(x-x1)*(x-x1)+(y-y1)*(y-y1); //Distance btween center.\\n                \\n                if(dist<=r*r) //Check whaether it Lies inside it or not (condition that Point Lies inside a circle)\\n                    count++,visited[k]=1,q.push(k); //If yes Mark as Visited ,increase Count and Push in queue.\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        ll ans=1,n=bombs.size();\\n        vector<bool>visited(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            /*For every Bomb Check how many Bomb we can detonate.\\n            -->Use BFS to Check*/\\n                ans=max(ans,BFS(bombs,i)); \\n        }\\n        \\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767070,
                "title": "easy-c-solution-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(int i, int &count, vector<bool> &visited, vector<vector<int>> &adj){\\n        visited[i] = true;\\n        count++;\\n        for(auto it : adj[i])\\n        {\\n            if(!visited[it])\\n            dfs(it, count, visited, adj);\\n        }\\n    }\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n       int n = bombs.size();\\n       vector<vector<int>> adj(n);\\n       for(int i=0; i<n; i++){\\n           long long r1 = bombs[i][2];\\n           long long x1 = bombs[i][0], y1 = bombs[i][1];\\n           for(int j = 0; j<n; j++){\\n             if(j != i){\\n                 long long x2 = bombs[j][0], y2 = bombs[j][1];\\n                 long long dist = (x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2);\\n                 if(dist <= r1*r1)\\n                 adj[i].push_back(j);\\n             }\\n           }\\n       }\\n       vector<bool> visited(n, 0);\\n       int ans = 0;\\n       for(int i=0; i<n; i++)\\n       {\\n           int count = 0;\\n           dfs(i, count, visited, adj);\\n           ans = max(ans, count);\\n           fill(visited.begin(), visited.end(), 0);\\n       } \\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int i, int &count, vector<bool> &visited, vector<vector<int>> &adj){\\n        visited[i] = true;\\n        count++;\\n        for(auto it : adj[i])\\n        {\\n            if(!visited[it])\\n            dfs(it, count, visited, adj);\\n        }\\n    }\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n       int n = bombs.size();\\n       vector<vector<int>> adj(n);\\n       for(int i=0; i<n; i++){\\n           long long r1 = bombs[i][2];\\n           long long x1 = bombs[i][0], y1 = bombs[i][1];\\n           for(int j = 0; j<n; j++){\\n             if(j != i){\\n                 long long x2 = bombs[j][0], y2 = bombs[j][1];\\n                 long long dist = (x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2);\\n                 if(dist <= r1*r1)\\n                 adj[i].push_back(j);\\n             }\\n           }\\n       }\\n       vector<bool> visited(n, 0);\\n       int ans = 0;\\n       for(int i=0; i<n; i++)\\n       {\\n           int count = 0;\\n           dfs(i, count, visited, adj);\\n           ans = max(ans, count);\\n           fill(visited.begin(), visited.end(), 0);\\n       } \\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625917,
                "title": "union-find-146-160-test-cases-passed-why",
                "content": "Any buddy give me some advise? Why Union Find does\\'t work!\\n```\\n\\nclass Union:\\n    def __init__ (self,n):\\n        self.root = [i for i in range(n)]\\n        self.rank = [1 for i in range(n)]\\n        self.count = n\\n            \\n    def union(self,x,y):\\n        rootX = self.find(x)\\n        rootY = self.find(y)\\n        if rootX != rootY:\\n            if self.rank[x]>self.rank[y]:\\n                self.root[rootY] = rootX\\n            elif self.rank[x]<self.rank[y]:\\n                self.root[rootX] = rootY\\n            else:\\n                self.root[rootY]=rootX\\n                self.rank[rootX] += 1 \\n            self.count -= 1\\n        \\n                \\n    def find(self,x):\\n        if self.root[x]==x:\\n            return x\\n        self.root[x]=self.find(self.root[x])\\n        return self.root[x]\\n\\n\\nclass Solution:\\n    def maximumDetonation(self, bombs: List[List[int]]) -> int:\\n        l = len(bombs)\\n        u = Union(l)\\n        \\n        def distance (p1,p2):\\n            return ((p1[0]-p2[0])**2 + (p1[1]-p2[1])**2)**0.5\\n        \\n        for i in range(l):\\n            for j in range(l):\\n                # if i==j:\\n                #     continue\\n                di = distance(bombs[i],bombs[j])\\n                # print(di)\\n                if bombs[i][2]>=di or bombs[j][2]>=di:\\n                    u.union(i,j)\\n\\n        print(u.root)\\n        mapping = {}\\n        for i in u.root:\\n            mapping[i] = mapping.get(i,0) + 1\\n        return max(mapping.values())\\n\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\n\\nclass Union:\\n    def __init__ (self,n):\\n        self.root = [i for i in range(n)]\\n        self.rank = [1 for i in range(n)]\\n        self.count = n\\n            \\n    def union(self,x,y):\\n        rootX = self.find(x)\\n        rootY = self.find(y)\\n        if rootX != rootY:\\n            if self.rank[x]>self.rank[y]:\\n                self.root[rootY] = rootX\\n            elif self.rank[x]<self.rank[y]:\\n                self.root[rootX] = rootY\\n            else:\\n                self.root[rootY]=rootX\\n                self.rank[rootX] += 1 \\n            self.count -= 1\\n        \\n                \\n    def find(self,x):\\n        if self.root[x]==x:\\n            return x\\n        self.root[x]=self.find(self.root[x])\\n        return self.root[x]\\n\\n\\nclass Solution:\\n    def maximumDetonation(self, bombs: List[List[int]]) -> int:\\n        l = len(bombs)\\n        u = Union(l)\\n        \\n        def distance (p1,p2):\\n            return ((p1[0]-p2[0])**2 + (p1[1]-p2[1])**2)**0.5\\n        \\n        for i in range(l):\\n            for j in range(l):\\n                # if i==j:\\n                #     continue\\n                di = distance(bombs[i],bombs[j])\\n                # print(di)\\n                if bombs[i][2]>=di or bombs[j][2]>=di:\\n                    u.union(i,j)\\n\\n        print(u.root)\\n        mapping = {}\\n        for i in u.root:\\n            mapping[i] = mapping.get(i,0) + 1\\n        return max(mapping.values())\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624682,
                "title": "c-28ms-100-hamilton-path-with-bfs",
                "content": "Runtime: 28 ms, faster than 100.00% of C++ online submissions for Detonate the Maximum Bombs.\\nMemory Usage: 20.4 MB, less than 53.85% of C++ online submissions for Detonate the Maximum Bombs.\\n```\\nclass Solution {\\npublic:\\n  int maximumDetonation(vector<vector<int>>& b) {\\n    int n = b.size(), answer = 1;\\n    vector<vector<int>>g(n);\\n    \\n    for(int i = 0; i != n; i++){\\n      long R = (long)b[i][2] * b[i][2];\\n      for(int j = i+1; j != n; j++){\\n        long dx = b[j][0] - b[i][0], dy = b[j][1] - b[i][1];\\n        long r = (long)b[j][2] * b[j][2];\\n        long d = dx*dx + dy*dy;\\n        if( d <= R) g[i].push_back(j);\\n        if( d <= r) g[j].push_back(i);\\n      }\\n    }\\n    \\n    for(int i = 0; i != n && answer != n; i++){\\n      vector<int>vis;\\n      vis.clear();\\n      vis.resize(n,0);\\n      queue<int>q;\\n      q.push(i);\\n    \\n      int k = 0;\\n      while(!q.empty()){\\n        int t = q.front(); q.pop();\\n        if(vis[t]) continue;\\n        vis[t] = 1, k++;\\n          \\n        for(auto next: g[t]) if(vis[next] == 0) q.push(next);\\n      }\\n      answer = max<int>(answer, k);\\n    }\\n    \\n    return answer;\\n  }\\n};\\n```\\n\\n**when I was solving contest I tried to solve this proublem with greedy algo , but it pass only 153 tests from 157 (very pity)**\\n```\\nclass Solution {\\npublic:\\n  static bool comp(vector<int> &a, vector<int>&b){\\n    return a[2] > b[2];\\n  }\\n  \\n  int maximumDetonation(vector<vector<int>>& b) {\\n    sort(b.begin(), b.end(), comp);\\n    int n = b.size(), answer = 1;\\n    vector<int>vis(n,0);\\n    \\n    for(int i = 0; i != n; i++)\\n      if(vis[i] == 0){\\n        vis[i] = 1;\\n        vector<vector<int>>v;\\n        v.push_back(b[i]);\\n        for(int j = 0; j != v.size(); j++){\\n          long R = (long)v[j][2] * v[j][2]; \\n          for(int k = 0; k != n; k++)\\n            if(vis[k] == 0){\\n            long dx = v[j][0] - b[k][0], dy = v[j][1] - b[k][1];\\n            if( dx*dx + dy*dy <= R)\\n              vis[k] = 1, v.push_back(b[k]);  \\n          }\\n        }  \\n        answer = max<int>(answer, v.size());\\n        v.clear();\\n      }\\n    \\n    return answer;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int maximumDetonation(vector<vector<int>>& b) {\\n    int n = b.size(), answer = 1;\\n    vector<vector<int>>g(n);\\n    \\n    for(int i = 0; i != n; i++){\\n      long R = (long)b[i][2] * b[i][2];\\n      for(int j = i+1; j != n; j++){\\n        long dx = b[j][0] - b[i][0], dy = b[j][1] - b[i][1];\\n        long r = (long)b[j][2] * b[j][2];\\n        long d = dx*dx + dy*dy;\\n        if( d <= R) g[i].push_back(j);\\n        if( d <= r) g[j].push_back(i);\\n      }\\n    }\\n    \\n    for(int i = 0; i != n && answer != n; i++){\\n      vector<int>vis;\\n      vis.clear();\\n      vis.resize(n,0);\\n      queue<int>q;\\n      q.push(i);\\n    \\n      int k = 0;\\n      while(!q.empty()){\\n        int t = q.front(); q.pop();\\n        if(vis[t]) continue;\\n        vis[t] = 1, k++;\\n          \\n        for(auto next: g[t]) if(vis[next] == 0) q.push(next);\\n      }\\n      answer = max<int>(answer, k);\\n    }\\n    \\n    return answer;\\n  }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n  static bool comp(vector<int> &a, vector<int>&b){\\n    return a[2] > b[2];\\n  }\\n  \\n  int maximumDetonation(vector<vector<int>>& b) {\\n    sort(b.begin(), b.end(), comp);\\n    int n = b.size(), answer = 1;\\n    vector<int>vis(n,0);\\n    \\n    for(int i = 0; i != n; i++)\\n      if(vis[i] == 0){\\n        vis[i] = 1;\\n        vector<vector<int>>v;\\n        v.push_back(b[i]);\\n        for(int j = 0; j != v.size(); j++){\\n          long R = (long)v[j][2] * v[j][2]; \\n          for(int k = 0; k != n; k++)\\n            if(vis[k] == 0){\\n            long dx = v[j][0] - b[k][0], dy = v[j][1] - b[k][1];\\n            if( dx*dx + dy*dy <= R)\\n              vis[k] = 1, v.push_back(b[k]);  \\n          }\\n        }  \\n        answer = max<int>(answer, v.size());\\n        v.clear();\\n      }\\n    \\n    return answer;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623699,
                "title": "javascript-simple-bfs-explained",
                "content": "For every bomb we build a list of bombs that will detonate if current bomb will detonante.\\nStart dfs for every bomb and count how many bombs will finally detonate if current bomb will detonate first.\\nStore the max achived number of bombs.\\n```\\nvar maximumDetonation = function(bombs) {\\n    const n = bombs.length\\n    let map = new Map()\\n\\t// For every bomb build list of affected bombs\\n    for(let i = 0; i < n; i++){\\n        map.set(i, [])\\n        for(let j = 0; j < n; j++){\\n            if(i === j){\\n                continue\\n            }\\n            let b1 = bombs[i]\\n            let b2 = bombs[j]\\n            if(willDetonateBomb(b1[0], b1[1], b1[2], b2[0], b2[1], b2[2])){\\n                const a = map.get(i)\\n                a.push(j)\\n            }\\n        }\\n    }\\n    \\n    let max = 0\\n\\t// run BFS for every bomb\\n    for(let i = 0; i < bombs.length; i++){\\n        const queue = [i]\\n        const visited = new Set()\\n\\n        while(queue.length){\\n            let current = queue.shift()\\n            \\n            if(!visited.has(current)){\\n                visited.add(current)\\n                const ch = map.get(current)\\n               \\n                ch.forEach(c => {\\n                    if(!visited.has(c)){\\n                        queue.push(c)\\n                    }\\n                })\\n            }\\n        }\\n        \\n        max = Math.max(visited.size, max)\\n    }\\n    \\n    return max\\n};\\n\\nfunction willDetonateBomb(x1, y1, r1,x2, y2, r2)\\n{\\n    let distSq = (x1 - x2) * (x1 - x2) +\\n                 (y1 - y2) * (y1 - y2)\\n    let radSq = r1 * r1\\n    if (distSq <= radSq)\\n        return true\\n    return false\\n}\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar maximumDetonation = function(bombs) {\\n    const n = bombs.length\\n    let map = new Map()\\n\\t// For every bomb build list of affected bombs\\n    for(let i = 0; i < n; i++){\\n        map.set(i, [])\\n        for(let j = 0; j < n; j++){\\n            if(i === j){\\n                continue\\n            }\\n            let b1 = bombs[i]\\n            let b2 = bombs[j]\\n            if(willDetonateBomb(b1[0], b1[1], b1[2], b2[0], b2[1], b2[2])){\\n                const a = map.get(i)\\n                a.push(j)\\n            }\\n        }\\n    }\\n    \\n    let max = 0\\n\\t// run BFS for every bomb\\n    for(let i = 0; i < bombs.length; i++){\\n        const queue = [i]\\n        const visited = new Set()\\n\\n        while(queue.length){\\n            let current = queue.shift()\\n            \\n            if(!visited.has(current)){\\n                visited.add(current)\\n                const ch = map.get(current)\\n               \\n                ch.forEach(c => {\\n                    if(!visited.has(c)){\\n                        queue.push(c)\\n                    }\\n                })\\n            }\\n        }\\n        \\n        max = Math.max(visited.size, max)\\n    }\\n    \\n    return max\\n};\\n\\nfunction willDetonateBomb(x1, y1, r1,x2, y2, r2)\\n{\\n    let distSq = (x1 - x2) * (x1 - x2) +\\n                 (y1 - y2) * (y1 - y2)\\n    let radSq = r1 * r1\\n    if (distSq <= radSq)\\n        return true\\n    return false\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1623528,
                "title": "c-graph-thought-process",
                "content": "Thought Process in Brief: \\n\\nI thought about the relation between any two bombs. It appeared every (bomb1,bom2) pair can be represented with true/false. i.e does triggering bomb2 triggers bomb1? So I created a matrix with **(i,j)==true**, if: **j**th bomb triggers **i**th bomb\\n\\nI thought about triggering every one of them one by one. I was initially thinking in the lines of a 1D dp, which was wrong since the problem can\\'t be broked down in smaller subproblem with some function f,z such that: f(n)=z(f(n-1)) *[Think about it]*\\n\\nObserving the relation i.e. the matrix, it appeared as an adjacency matrix, So the problem must be modelable as a graph with ***bombs as nodes*** and the ***relations as directed edges***. \\n\\nVoila, it is a question of finding the node from which maximum nodes can be traversed in the connected component. (which can be done using dfs) \\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool inrange(int x1,int y1,int r1,int x2,int y2,int r2){\\n        long long int x=abs(x1-x2);\\n        long long int y=abs(y1-y2);\\n        long long int r=abs(r2);\\n        return x*x+y*y<=r*r;\\n    }\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n=bombs.size();\\n        vector<vector<bool>> v(n,vector<bool>(n,false));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++)\\n                if(inrange(bombs[i][0],bombs[i][1],bombs[i][2],bombs[j][0],bombs[j][1],bombs[j][2]))\\n                    v[i][j]=true;\\n        }\\n        int maxi=0;\\n        for(int i=0;i<n;i++){\\n            vector<int> visited(n,-1);\\n            int num=1;\\n            if(visited[i]==-1) dfs(v,visited,num,i);\\n            maxi=max(maxi,num);\\n        }\\n        return maxi;\\n    }\\n    void dfs(vector<vector<bool>>& v,vector<int>& visited,int& num,int cur){\\n        visited[cur]=num;\\n        for(int i=0;i<visited.size();i++){\\n            if(visited[i]==-1 and v[i][cur])\\n                dfs(v,visited,++num,i);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool inrange(int x1,int y1,int r1,int x2,int y2,int r2){\\n        long long int x=abs(x1-x2);\\n        long long int y=abs(y1-y2);\\n        long long int r=abs(r2);\\n        return x*x+y*y<=r*r;\\n    }\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n=bombs.size();\\n        vector<vector<bool>> v(n,vector<bool>(n,false));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++)\\n                if(inrange(bombs[i][0],bombs[i][1],bombs[i][2],bombs[j][0],bombs[j][1],bombs[j][2]))\\n                    v[i][j]=true;\\n        }\\n        int maxi=0;\\n        for(int i=0;i<n;i++){\\n            vector<int> visited(n,-1);\\n            int num=1;\\n            if(visited[i]==-1) dfs(v,visited,num,i);\\n            maxi=max(maxi,num);\\n        }\\n        return maxi;\\n    }\\n    void dfs(vector<vector<bool>>& v,vector<int>& visited,int& num,int cur){\\n        visited[cur]=num;\\n        for(int i=0;i<visited.size();i++){\\n            if(visited[i]==-1 and v[i][cur])\\n                dfs(v,visited,++num,i);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623424,
                "title": "bfs-c",
                "content": "First make a graph in such a way  that there will be a directed edge from u to v if and only if the distance between u and v is less than or equal to the radius of u.\\n\\nThen do Bfs one by one from each bomb and find the maximum ans.\\n\\ncode:\\n```\\nint maximumDetonation(vector<vector<int>>& nums) {\\n        vector<vector<int>>graph(nums.size(), vector<int>());\\n        for(int i=0;i<nums.size();i++){\\n            int cx=nums[i][0], cy=nums[i][1], cr=nums[i][2];\\n            for(int j=0;j<nums.size();j++){\\n                if(i!=j){\\n                    int x=nums[j][0], y=nums[j][1];\\n                    long long dis=(long long)pow(abs(cx-x), 2)+(long long)pow(abs(cy-y), 2);\\n                    if(sqrt(dis)<=cr){\\n                        graph[i].push_back(j);\\n                    }\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            int cur=0;\\n            queue<int>q;\\n            q.push(i);\\n            unordered_map<int, int>visited;\\n            visited[i]=1;\\n            while(!q.empty()){\\n                int f=q.front();q.pop();\\n                cur++;\\n                for(auto v:graph[f]){\\n                    if(visited[v]==0){\\n                        q.push(v);\\n                        visited[v]=1;\\n                    }\\n                }\\n            }\\n            ans=max(ans, cur);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nint maximumDetonation(vector<vector<int>>& nums) {\\n        vector<vector<int>>graph(nums.size(), vector<int>());\\n        for(int i=0;i<nums.size();i++){\\n            int cx=nums[i][0], cy=nums[i][1], cr=nums[i][2];\\n            for(int j=0;j<nums.size();j++){\\n                if(i!=j){\\n                    int x=nums[j][0], y=nums[j][1];\\n                    long long dis=(long long)pow(abs(cx-x), 2)+(long long)pow(abs(cy-y), 2);\\n                    if(sqrt(dis)<=cr){\\n                        graph[i].push_back(j);\\n                    }\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            int cur=0;\\n            queue<int>q;\\n            q.push(i);\\n            unordered_map<int, int>visited;\\n            visited[i]=1;\\n            while(!q.empty()){\\n                int f=q.front();q.pop();\\n                cur++;\\n                for(auto v:graph[f]){\\n                    if(visited[v]==0){\\n                        q.push(v);\\n                        visited[v]=1;\\n                    }\\n                }\\n            }\\n            ans=max(ans, cur);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3767553,
                "title": "c-bfs-detailed-explanation-dry-run-runtime-beats-87-47",
                "content": "# Intuition\\nWhile reading the problem we get to understand that this is a sort of problem where a relationship needs to be established between bombs so that when one explodes the other one does too. This becomes more clearer by the fact that the range is involved while deciding that. So with this information it becomes clear that it is a graph problem. Most of the graph problems revolve around 4 algorithms, DFS, BFS, Union Find and Topological Sort. Also one problem can be solved by more than one of these algorithms. Since we need to detonate maximum number of bombs by detonating a single bomb so at any given time all the children of a node are coming into the picture and hence BFS is the algorithm we will go with.\\n\\n# Approach\\n\\n**Example used - bombs = [[1,2,3],[2,3,1],[3,4,2],[4,5,3],[5,6,4]]**\\n\\n**Adjacency List Creation**\\n\\nOur solution starts by building the Adjacency List of the form in the image. This kind of structure can be used to represent both a directed and an undirected graph, the difference being that in undirected we will be adding two edges for each relationship, one for each node involved whereas in directed just one edge is added. In our case we will be using a directed graph since bomb 1 being in the range of bomb 2 does not mean it is true the other way around as the ranges differ for both of them even though the distance remains same.\\nWe will be using the mathematical formula to calculate distance between any two bombs. If the range of the first bomb is greater than the calculated distance, we can assume that bomb 2 will detonate on the detonation of bomb 1 and hence there a directed edge from bomb 1 to bomb 2.\\nOnce our Adjacency list is ready we need a way to find a way to detonate maximum bombs. For this we will be using the breadth first search algorithm to iterate over all nodes in the graph, then run the BFS for each of them since we don\\'t know which bomb will detonate all the bombs. We also maintain the \\'maxBombsDetonated\\' state so that at any point if we detonate all bombs we don\\'t need to iterate further and can exit then and there.\\n\\n![image.png](https://assets.leetcode.com/users/images/844c794c-7c05-4657-b355-f313133fb705_1689405355.7905874.png)\\n\\n\\n**How BFS works**\\n\\nBreadth First Search is an algorithm to traverse the nodes of a graph in a breadth wise manner, what it means is instead of going in one direction straight like in DFS, we want to iterate over the current node as well as over all its children before moving onto a new node and its children thereafter, so in this manner we go level by level instead of in one direction depth wise. For BFS algorithm we use Queue data structure since it helps to preserve the order of insertion.\\nThe exist condition for this is generally the queue count becoming zero as no more nodes are left to process. Also another important point is that we need to maintain a \\'visited\\' set inorder to not detonate a bomb again which has already been detonated since there could be a case in which we come back to the node from which we started via some other intermediate node.\\nIn the below image I have shown a dry run for the example.\\nHere since the first iteration with i = 0 itself detonates all 5 bombs we don\\'t to traverse further and the code exists.\\n\\n![image.png](https://assets.leetcode.com/users/images/84407e38-69a9-42cc-9741-d5dc55121406_1689406682.9492385.png)\\n\\n# **If you found my solution and explanation helpful, please consider upvoting it. Your upvote will help rank it higher among other solutions, making it easier for people seeking assistance to find. Feel free to ask any follow-up questions in the comment section. Thank you for reading!**\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nInitializing the adjacency list: O(n)\\n\\nThe code initializes the adjacency list by creating a new list for each vertex. This takes O(n) time, where n is the number of bombs.\\nConstructing the adjacency list: O(n^2)\\n\\nThe code constructs the adjacency list by checking the distance between each pair of bombs and adding an edge if they are adjacent. This involves nested loops, where the outer loop runs n times and the inner loop also runs n times. Therefore, this step takes O(n^2) time.\\nBFS traversal: O(n + m)\\n\\nThe code performs a BFS traversal on the adjacency list. The time complexity of BFS is O(V + E), where V is the number of vertices and E is the number of edges. In this case, the number of vertices is n, and the number of edges is the sum of the sizes of all lists in the adjacency list, which can be denoted as m. Therefore, the BFS traversal takes O(n + m) time.\\nMain loop: O(n * (n + m))\\n\\nThe code iterates over each vertex and performs a BFS traversal on it. Since the BFS traversal takes O(n + m) time, and this is done for each of the n vertices, the overall time complexity of the main loop is O(n * (n + m)).\\nOverall, the time complexity of the given code is O(n^2 + n + m), which can be simplified to O(n^2 + m) in the worst case.\\n# Code\\n```\\npublic class Solution {\\n    List<int>[] adjacencyList;\\n    public int MaximumDetonation(int[][] bombs) \\n    {\\n        int n = bombs.Length;\\n        adjacencyList = new List<int>[n];\\n        int maxBombsDetonated = 0;\\n\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            adjacencyList[i] = new List<int>();\\n        }\\n\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            for(int j = 0 ; j < n ; j++)\\n            {\\n                if(i != j)\\n                {\\n                    double dist = Math.Sqrt(Math.Pow((bombs[i][0]-bombs[j][0]),2) + Math.Pow((bombs[i][1] - bombs[j][1]),2));\\n                    if(bombs[i][2] >= dist)\\n                    {\\n                        // bombs are adjacent if the second bomb lies in the range of first, drawing an edge from first to second\\n                        adjacencyList[i].Add(j);\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            maxBombsDetonated = Math.Max(BFS(i),maxBombsDetonated);\\n            if(maxBombsDetonated == n)\\n            {\\n                return n;\\n            }\\n        }\\n        return maxBombsDetonated;          \\n    }\\n    public int BFS(int i)\\n    {\\n       // Travsering the adjacencyList in BFS manner \\n       Queue<int> queue = new Queue<int>();\\n       HashSet<int> visited = new HashSet<int>();\\n\\n       queue.Enqueue(i);\\n       visited.Add(i);\\n\\n       while(queue.Count != 0)\\n       {\\n           int temp = queue.Dequeue();\\n           foreach(int curr in adjacencyList[temp])\\n           {\\n               if(!visited.Contains(curr))\\n               {\\n                   queue.Enqueue(curr);\\n                   visited.Add(curr);\\n               }\\n           }\\n       }\\n       return visited.Count;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C#",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\npublic class Solution {\\n    List<int>[] adjacencyList;\\n    public int MaximumDetonation(int[][] bombs) \\n    {\\n        int n = bombs.Length;\\n        adjacencyList = new List<int>[n];\\n        int maxBombsDetonated = 0;\\n\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            adjacencyList[i] = new List<int>();\\n        }\\n\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            for(int j = 0 ; j < n ; j++)\\n            {\\n                if(i != j)\\n                {\\n                    double dist = Math.Sqrt(Math.Pow((bombs[i][0]-bombs[j][0]),2) + Math.Pow((bombs[i][1] - bombs[j][1]),2));\\n                    if(bombs[i][2] >= dist)\\n                    {\\n                        // bombs are adjacent if the second bomb lies in the range of first, drawing an edge from first to second\\n                        adjacencyList[i].Add(j);\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            maxBombsDetonated = Math.Max(BFS(i),maxBombsDetonated);\\n            if(maxBombsDetonated == n)\\n            {\\n                return n;\\n            }\\n        }\\n        return maxBombsDetonated;          \\n    }\\n    public int BFS(int i)\\n    {\\n       // Travsering the adjacencyList in BFS manner \\n       Queue<int> queue = new Queue<int>();\\n       HashSet<int> visited = new HashSet<int>();\\n\\n       queue.Enqueue(i);\\n       visited.Add(i);\\n\\n       while(queue.Count != 0)\\n       {\\n           int temp = queue.Dequeue();\\n           foreach(int curr in adjacencyList[temp])\\n           {\\n               if(!visited.Contains(curr))\\n               {\\n                   queue.Enqueue(curr);\\n                   visited.Add(curr);\\n               }\\n           }\\n       }\\n       return visited.Count;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634889,
                "title": "very-intuitive-solution-amazing-dsa-concepts-used-must-see",
                "content": "## This question deserves more attention as it is one of the most beautiful problems I\\'ve seen! Absolute JOY !!\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNow, the biggest question in anyone\\'s mind when they first see this question is \"How is this a graph\\'s question\"? And that\\'s where the solution is! Once you figure it out, its just a matter of applying DFS or BFS!!\\n\\nThe hint is given in the question itself! Now, consider yourself on the first bomb, if there are any other bombs in your blast radius, they will explode when YOU explode! So, isn\\'t that similar to you having a path to those bombs?\\n\\nSimilarly, every bomb will have its own range of other bombs. You will observe a graph like structure getting formed where the paths are basically saying that this bomb can be \"reached\" or exploded.\\nYou just need to find the max depth of the created graph!\\n\\n## My solution is kind of not very efficient, but it is simple, intuitive, focuses on core DSA concepts and solves the problem gracefully!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCoordinate Geometry distance formula is used to calculate distance between any two points\\n\\nFirst, you need to create the graph!\\n\\nFor that, I have used the adjacency list method implemented using an unordered MAP! Where each key is the vertex having a vector of elements which are the nodes it can reach aka the bombs within the blast radius.\\n\\nTo check if the bomb is in the blast radius, if the sum of radius of the two bombs is greater or equal to the distance between the centers of the bombs, then the said bombs are in blast radius of each other. That\\'s exactly what I\\'ve done here.\\nFor every ith bomb, i check it with all the bombs except for the case where i==j as its comparing the bomb with itself.\\n\\nI am using a set as my visited tool, mostly for using the size function to get my answer!\\nI apply DFS on every \"key\" of my map or adj. list and keep on taking max of size of visited set as my answer!\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef long long LL;\\n    LL distancesq(LL x1, LL y1, LL x2, LL y2){\\n        return (LL)((x1 - x2) * (x1 - x2)) + ((y1 - y2) * (y1 - y2));\\n    }\\n    int max(int a, int b){\\n        return a > b ? a : b;\\n    }\\n    void dfs(unordered_map<int, vector<int>> &umap, int u,unordered_set<int> & visited){\\n        visited.insert(u);\\n        for(int &v : umap[u]){\\n            if(visited.find(v) == visited.end()){\\n                dfs(umap, v, visited);\\n            }\\n        }\\n    }\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        // r >= d for a bomb to detonate other bomb\\n        unordered_map<int, vector<int>> umap;\\n        int count = 0;\\n        int n = bombs.size();\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0; j < n ; j++){\\n                if(i == j)\\n                    continue;\\n                LL x1 = bombs[i][0];\\n                LL x2 = bombs[j][0];\\n                LL y1 = bombs[i][1];\\n                LL y2 = bombs[j][1];\\n                LL centre_dist = distancesq(x1, y1, x2, y2);\\n                LL r = bombs[i][2];\\n                if ((r * r) >= centre_dist)\\n                    umap[i].push_back(j);\\n            }\\n        }\\n        int m = 0;\\n        unordered_set<int> visited;\\n        for(int i = 0; i<n; i++) {\\n            dfs(umap, i, visited);\\n            m = max(m, visited.size());\\n            visited.clear();\\n        }\\n        return m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long LL;\\n    LL distancesq(LL x1, LL y1, LL x2, LL y2){\\n        return (LL)((x1 - x2) * (x1 - x2)) + ((y1 - y2) * (y1 - y2));\\n    }\\n    int max(int a, int b){\\n        return a > b ? a : b;\\n    }\\n    void dfs(unordered_map<int, vector<int>> &umap, int u,unordered_set<int> & visited){\\n        visited.insert(u);\\n        for(int &v : umap[u]){\\n            if(visited.find(v) == visited.end()){\\n                dfs(umap, v, visited);\\n            }\\n        }\\n    }\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        // r >= d for a bomb to detonate other bomb\\n        unordered_map<int, vector<int>> umap;\\n        int count = 0;\\n        int n = bombs.size();\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0; j < n ; j++){\\n                if(i == j)\\n                    continue;\\n                LL x1 = bombs[i][0];\\n                LL x2 = bombs[j][0];\\n                LL y1 = bombs[i][1];\\n                LL y2 = bombs[j][1];\\n                LL centre_dist = distancesq(x1, y1, x2, y2);\\n                LL r = bombs[i][2];\\n                if ((r * r) >= centre_dist)\\n                    umap[i].push_back(j);\\n            }\\n        }\\n        int m = 0;\\n        unordered_set<int> visited;\\n        for(int i = 0; i<n; i++) {\\n            dfs(umap, i, visited);\\n            m = max(m, visited.size());\\n            visited.clear();\\n        }\\n        return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608292,
                "title": "easy-to-understand-straight-forward-c-solution-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(int xi, int yi, int ri, int xj, int yj){\\n        // return (long)ri * ri >= (long)(xi - xj) * (xi - xj) + (long)(yi - yj) * (yi - yj); \\n        long long c1c2 = (long long )(xi - xj) * (xi - xj) + (long long)(yi - yj) * (yi - yj);\\n        long long r1r2 = (long long) ri * ri;\\n        return r1r2 >= c1c2;\\n    }\\n    void dfs(int node, vector<vector<int>>&g, vector<int>&vis, int &cnt){\\n        cnt++;\\n        vis[node] = 1;\\n        for(auto i:g[node]){\\n            if(!vis[i]) dfs(i,g,vis,cnt);\\n        }\\n    }\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n = bombs.size();\\n        vector<vector<int>>g(n);\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                int xi = bombs[i][0], yi = bombs[i][1], ri = bombs[i][2];\\n                int xj = bombs[j][0], yj = bombs[j][1];\\n                if(i!=j && check(xi,yi,ri,xj,yj)){\\n                    g[i].push_back(j);\\n                } \\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            int cnt = 0;\\n            vector<int>vis(n,0);\\n            dfs(i,g,vis,cnt);\\n            ans = max(ans,cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int xi, int yi, int ri, int xj, int yj){\\n        // return (long)ri * ri >= (long)(xi - xj) * (xi - xj) + (long)(yi - yj) * (yi - yj); \\n        long long c1c2 = (long long )(xi - xj) * (xi - xj) + (long long)(yi - yj) * (yi - yj);\\n        long long r1r2 = (long long) ri * ri;\\n        return r1r2 >= c1c2;\\n    }\\n    void dfs(int node, vector<vector<int>>&g, vector<int>&vis, int &cnt){\\n        cnt++;\\n        vis[node] = 1;\\n        for(auto i:g[node]){\\n            if(!vis[i]) dfs(i,g,vis,cnt);\\n        }\\n    }\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n = bombs.size();\\n        vector<vector<int>>g(n);\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                int xi = bombs[i][0], yi = bombs[i][1], ri = bombs[i][2];\\n                int xj = bombs[j][0], yj = bombs[j][1];\\n                if(i!=j && check(xi,yi,ri,xj,yj)){\\n                    g[i].push_back(j);\\n                } \\n            }\\n        }\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            int cnt = 0;\\n            vector<int>vis(n,0);\\n            dfs(i,g,vis,cnt);\\n            ans = max(ans,cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592019,
                "title": "c-beginner-friendly-easy-to-understand-o-n-3-time-complexity",
                "content": "# Complexity\\n- ## Time complexity:\\n1. The outer loop iterates N times, where N is the number of bombs (for(long long i=0; i<bombs.size(); i++)).\\n\\n    Time complexity: O(N)\\n2. Inside the outer loop, there is a while loop that iterates until the    stack is empty.\\n\\n3. The while loop can potentially iterate N times because each bomb can be visited at most once.\\nTherefore, the worst-case time complexity of the while loop is O(N).\\n4. Inside the while loop, there is an inner loop that iterates N times (for(long long j=0; j<bombs.size(); j++)).\\nTime complexity: O(N)\\n5. The total time complexity of the inner loop is O(N), and it is executed O(N) times (inside the while loop).\\nTime complexity: O(N^2)\\n\\nPutting it all together, the overall time complexity is O(N) * O(N^2) = O(N^3).\\n\\n- ## Space complexity:\\n1. The maxBombs variable requires constant space.\\n\\n2. The visited vector is used to track visited bombs. It has a size equal to the number of bombs, so it requires O(N) space.\\n\\n3. The s stack is used for the DFS traversal. In the worst case, when all bombs are visited, the stack can store N elements.\\n\\n4. The space complexity of the s stack is O(N).\\nAll other variables used within loops require constant space.\\n\\nPutting it all together, the overall space complexity is dominated by the space used by the visited vector and the s stack, both of which can grow up to N elements. Therefore, the space complexity of your code is O(N^2), where N is the number of bombs.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        long long maxBombs = 0;\\n        for(long long i=0; i<bombs.size(); i++) // O(N)\\n        {\\n            long long crrIndBombs = 1;\\n            \\n            vector<long long> visited(bombs.size(), 0); \\n            stack<long long> s;\\n            s.push(i);\\n            visited[i] = 1;\\n\\n            while(s.size())\\n            {\\n                long long node = s.top();\\n                long long rad = bombs[node][2];\\n                long long xCord = bombs[node][0];\\n                long long yCord = bombs[node][1];\\n                s.pop();\\n\\n                for(long long j=0; j<bombs.size(); j++)\\n                {\\n                    if(!visited[j])\\n                    {\\n                        long long total = ((xCord - bombs[j][0]) * (xCord - bombs[j][0])) + ((yCord - bombs[j][1]) * (yCord - bombs[j][1]));\\n                        if (sqrt(total) <= rad){\\n                            crrIndBombs++;\\n                            s.push(j);\\n                            visited[j] = 1;\\n                        }\\n                    }\\n                }\\n            }\\n\\n            maxBombs = max(maxBombs, crrIndBombs);\\n        }\\n        return maxBombs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        long long maxBombs = 0;\\n        for(long long i=0; i<bombs.size(); i++) // O(N)\\n        {\\n            long long crrIndBombs = 1;\\n            \\n            vector<long long> visited(bombs.size(), 0); \\n            stack<long long> s;\\n            s.push(i);\\n            visited[i] = 1;\\n\\n            while(s.size())\\n            {\\n                long long node = s.top();\\n                long long rad = bombs[node][2];\\n                long long xCord = bombs[node][0];\\n                long long yCord = bombs[node][1];\\n                s.pop();\\n\\n                for(long long j=0; j<bombs.size(); j++)\\n                {\\n                    if(!visited[j])\\n                    {\\n                        long long total = ((xCord - bombs[j][0]) * (xCord - bombs[j][0])) + ((yCord - bombs[j][1]) * (yCord - bombs[j][1]));\\n                        if (sqrt(total) <= rad){\\n                            crrIndBombs++;\\n                            s.push(j);\\n                            visited[j] = 1;\\n                        }\\n                    }\\n                }\\n            }\\n\\n            maxBombs = max(maxBombs, crrIndBombs);\\n        }\\n        return maxBombs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591564,
                "title": "kosaraju-s-algorithm-topological-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is an attempt to arrive at an $$O(n^2)$$ solution by using the concept of Strongly Connected Components. This approach still runs at $$O(n^3)$$ time.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) Creation of adjacency list and reversed adjacency list. This costs looping through the vertices twice, therefore this costs $$O(n^2)$$.\\n\\n2) Kosaraju\\'s algorithm. This costs running through the adjacency list twice. The adjacency list can have $$n^2$$ items. Therefore, this costs $$O(n^2)$$.\\n\\n3) Topological sort in reversed order. We avoid double counting of bombs by using hashset on each node. We update the child hashset when the parent detonates the child. Updating a set with multiple items costs $$O(n)$$. The topological sort algorithm runs through the $$n^2$$ items. Therefore, the total is $$O(n^3)$$.\\n\\n# Complexity\\n- Time complexity: $$O(n^3)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumDetonation(self, bombs: List[List[int]]) -> int:\\n        # // Adjacency List\\n        b = [Bomb(x, y, r) for x, y, r in bombs]\\n        adj = defaultdict(list)\\n        r_adj = defaultdict(list)\\n        for bomb1 in b:\\n            for bomb2 in b:\\n                if bomb1 == bomb2:\\n                    continue\\n                if bomb1.enclosed(bomb2):\\n                    adj[bomb1].append(bomb2)\\n                    r_adj[bomb2].append(bomb1)\\n\\n        # // Kosaraju\\'s Algorithm for SCC\\n        stack = []\\n        visited = set()\\n        def dfs1(node):\\n            if node in visited:\\n                return\\n\\n            visited.add(node)\\n            for nei in adj[node]:\\n                dfs1(nei)\\n\\n            stack.append(node)\\n        \\n        for bomb in b:\\n            dfs1(bomb)\\n\\n        who = defaultdict(Bomb)\\n        visited = set()\\n        def dfs2(node, root):\\n            if node in visited:\\n                return\\n            visited.add(node)\\n            who[node] = root\\n            for nei in r_adj[node]:\\n                dfs2(nei, root)\\n        \\n        while stack:\\n            curr = stack.pop()\\n            if curr in visited:\\n                continue\\n            dfs2(curr, curr)\\n\\n        \\n        # // Reversed Topological Sort\\n        representatives = set(list(who.values()))\\n        weights = {u: 0 for u in representatives}\\n        indegree = {u: 0 for u in representatives}\\n        new_adj = defaultdict(set)\\n        for u in b:\\n            for v in adj[u]:\\n                if who[u] == who[v]:\\n                    continue\\n                if who[u] in new_adj[who[v]]:\\n                    continue\\n                new_adj[who[v]].add(who[u])\\n                indegree[who[u]] += 1\\n\\n        for u in who:\\n            weights[who[u]] += 1\\n        \\n        q = deque()\\n        for u in indegree:\\n            if indegree[u] == 0:\\n                q.append(u)\\n\\n        res = {u: set([u]) for u in representatives}\\n        visited = set()\\n        while q:\\n            for _ in range(len(q)):\\n                node = q.popleft()\\n                for child in new_adj[node]:\\n                    if child in visited:\\n                        continue\\n                    \\n                    # // Update set to avoid double counts\\n                    res[child].update(res[node])\\n                    \\n                    indegree[child] -= 1\\n                    if indegree[child] == 0:\\n                        q.append(child)\\n                        visited.add(child)\\n        \\n        # // Sum weights inside the set and take max\\n        maxb = 0\\n        for u in res:\\n            curr = 0\\n            for i in res[u]:\\n                curr += weights[i]\\n            maxb = max(maxb, curr)\\n\\n        return maxb\\n        \\n\\nclass Bomb:\\n    def __init__(self, x, y, r):\\n        self.x = x\\n        self.y = y\\n        self.r = r\\n\\n    def enclosed(self, other):\\n        return self.r ** 2 >= (self.x - other.x) ** 2 + (self.y - other.y) ** 2\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Topological Sort",
                    "Strongly Connected Component"
                ],
                "code": "```\\nclass Solution:\\n    def maximumDetonation(self, bombs: List[List[int]]) -> int:\\n        # // Adjacency List\\n        b = [Bomb(x, y, r) for x, y, r in bombs]\\n        adj = defaultdict(list)\\n        r_adj = defaultdict(list)\\n        for bomb1 in b:\\n            for bomb2 in b:\\n                if bomb1 == bomb2:\\n                    continue\\n                if bomb1.enclosed(bomb2):\\n                    adj[bomb1].append(bomb2)\\n                    r_adj[bomb2].append(bomb1)\\n\\n        # // Kosaraju\\'s Algorithm for SCC\\n        stack = []\\n        visited = set()\\n        def dfs1(node):\\n            if node in visited:\\n                return\\n\\n            visited.add(node)\\n            for nei in adj[node]:\\n                dfs1(nei)\\n\\n            stack.append(node)\\n        \\n        for bomb in b:\\n            dfs1(bomb)\\n\\n        who = defaultdict(Bomb)\\n        visited = set()\\n        def dfs2(node, root):\\n            if node in visited:\\n                return\\n            visited.add(node)\\n            who[node] = root\\n            for nei in r_adj[node]:\\n                dfs2(nei, root)\\n        \\n        while stack:\\n            curr = stack.pop()\\n            if curr in visited:\\n                continue\\n            dfs2(curr, curr)\\n\\n        \\n        # // Reversed Topological Sort\\n        representatives = set(list(who.values()))\\n        weights = {u: 0 for u in representatives}\\n        indegree = {u: 0 for u in representatives}\\n        new_adj = defaultdict(set)\\n        for u in b:\\n            for v in adj[u]:\\n                if who[u] == who[v]:\\n                    continue\\n                if who[u] in new_adj[who[v]]:\\n                    continue\\n                new_adj[who[v]].add(who[u])\\n                indegree[who[u]] += 1\\n\\n        for u in who:\\n            weights[who[u]] += 1\\n        \\n        q = deque()\\n        for u in indegree:\\n            if indegree[u] == 0:\\n                q.append(u)\\n\\n        res = {u: set([u]) for u in representatives}\\n        visited = set()\\n        while q:\\n            for _ in range(len(q)):\\n                node = q.popleft()\\n                for child in new_adj[node]:\\n                    if child in visited:\\n                        continue\\n                    \\n                    # // Update set to avoid double counts\\n                    res[child].update(res[node])\\n                    \\n                    indegree[child] -= 1\\n                    if indegree[child] == 0:\\n                        q.append(child)\\n                        visited.add(child)\\n        \\n        # // Sum weights inside the set and take max\\n        maxb = 0\\n        for u in res:\\n            curr = 0\\n            for i in res[u]:\\n                curr += weights[i]\\n            maxb = max(maxb, curr)\\n\\n        return maxb\\n        \\n\\nclass Bomb:\\n    def __init__(self, x, y, r):\\n        self.x = x\\n        self.y = y\\n        self.r = r\\n\\n    def enclosed(self, other):\\n        return self.r ** 2 >= (self.x - other.x) ** 2 + (self.y - other.y) ** 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590843,
                "title": "short-and-sweet-js-solution-using-bfs",
                "content": "# Intuition\\nA new bomb explodes if its distance to the current bomb is less than the radius of the current bomb. \\nWe can calculate this with a^2 + b^2 = c^2\\nWe can use BFS to check which bombs explodes, by adding exploding boms to our queue. \\nWe have to check what the maximum number of exploding bombs is for each starting bomb, since order matters here, which is fine, since there are only 100 bombs\\n\\n# Approach\\nBFS\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nnot sure, we only create one queue and one set at a time, so O(n)?\\n# Code\\n```\\n/**\\n * @param {number[][]} bombs\\n * @return {number}\\n */\\nvar maximumDetonation = function(bombs) {\\n    let answer = 0\\n    for (let i  = 0; i < bombs.length; i++) {\\n        const exploded = new Set([i])\\n        const queue = [bombs[i]]\\n        while(queue.length > 0) {\\n            const bomb = queue.shift()\\n            for (let j = 0; j < bombs.length; j++) {\\n                if (exploded.has(j)) continue\\n                const newBomb = bombs[j]\\n                const distance = ((Math.abs(newBomb[0] - bomb[0])**2 )+ (Math.abs(newBomb[1] - bomb[1])**2)) ** 0.5\\n                if (distance <= bomb[2]) {\\n                    queue.push(newBomb)\\n                    exploded.add(j)\\n                }\\n            }\\n        }\\n        answer = Math.max(exploded.size, answer)\\n    }\\n    return answer\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} bombs\\n * @return {number}\\n */\\nvar maximumDetonation = function(bombs) {\\n    let answer = 0\\n    for (let i  = 0; i < bombs.length; i++) {\\n        const exploded = new Set([i])\\n        const queue = [bombs[i]]\\n        while(queue.length > 0) {\\n            const bomb = queue.shift()\\n            for (let j = 0; j < bombs.length; j++) {\\n                if (exploded.has(j)) continue\\n                const newBomb = bombs[j]\\n                const distance = ((Math.abs(newBomb[0] - bomb[0])**2 )+ (Math.abs(newBomb[1] - bomb[1])**2)) ** 0.5\\n                if (distance <= bomb[2]) {\\n                    queue.push(newBomb)\\n                    exploded.add(j)\\n                }\\n            }\\n        }\\n        answer = Math.max(exploded.size, answer)\\n    }\\n    return answer\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3590157,
                "title": "maybe-fastest-rust-solution-100-beat-by-runtime-and-memory",
                "content": "# Intuition\\nFirst thought was to sort by influence to neighbor bombs, then link top influencers. But I\\'ve quickly infered it\\'s a wrong way.\\n\\nSecond thought was describe bombs and ther \"victims\" as graph. Then there is need to extract separated clusters of connected nodes. Cluster with biggest number of nodes is the answer. And it was bingo! \\n\\n# Approach\\nBuild directed graph where nodes are bombs and edges are connections to bombs affected by blast. Pythagorean theorem is in game here. To avoid floating point arithmetic we can use squared blast radius:\\n\\n$$r_{i}^2 <= d_{ij}^2 = (x_{i} - x_{j})^2 + (y_{i} - y_{j})^2$$\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^3)$$\\n\\n- Space complexity:\\n$$O(n^2)$$\\n\\n# Code\\n```\\nimpl Solution {\\n    // beats 100% by runtime and memory, so code is a bit wired\\n    pub fn maximum_detonation(bombs: Vec<Vec<i32>>) -> i32 {\\n        // Deep first graph traversing helper.\\n        // Pass a starting node to search from. \\n        fn count_nodes_in_cluster(graph: &Vec<Vec<usize>>, node: usize, stack: &mut Vec<usize>, visited: &mut Vec<bool>) -> usize {\\n            stack.push(node);\\n            while let Some(current) = stack.pop() {\\n                if visited[current] {\\n                    continue;\\n                }\\n                visited[current] = true;\\n                stack.extend(graph[current].iter().cloned());\\n            }\\n\\n            return visited.iter().filter(|&&flag| flag).count();\\n        }\\n\\n        let bombs_count = bombs.len(); // to avoid multiple function calling\\n        let mut visited = vec![false; bombs_count]; // reusable substitute of HashMap\\n        let mut connected_bombs = vec![Vec::with_capacity(bombs_count-1); bombs_count]; // allocate memory ahead\\n\\n        for i in 0..bombs_count {\\n            let x_i = bombs[i][0] as i64; // squared value may not fit in i32\\n            let y_i = bombs[i][1] as i64;\\n            let r_i = (bombs[i][2] as i64) * (bombs[i][2] as i64);\\n\\n            for j in i + 1..bombs_count {\\n                let x_j = bombs[j][0] as i64;\\n                let y_j = bombs[j][1] as i64;\\n                let r_j = bombs[j][2] as i64;\\n\\n                let d = (x_i - x_j) * (x_i - x_j) + (y_i - y_j) * (y_i - y_j);\\n                if d <= r_i {\\n                    connected_bombs[i].push(j);\\n                }\\n                // don\\'t forget to check reverse blast\\n                if d <= r_j * r_j {\\n                    connected_bombs[j].push(i);\\n                }\\n            }\\n        }\\n\\n        let mut result = 0;\\n        let mut stack = vec![]; // reusable stack for performance reason\\n        for i in 0..bombs_count {\\n            let excluded = count_nodes_in_cluster(&connected_bombs, i, &mut stack, &mut visited);\\n            if excluded > result {\\n                result = excluded;\\n            }\\n            visited.fill(false);\\n        }\\n\\n        return result as i32;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Graph",
                    "Geometry"
                ],
                "code": "```\\nimpl Solution {\\n    // beats 100% by runtime and memory, so code is a bit wired\\n    pub fn maximum_detonation(bombs: Vec<Vec<i32>>) -> i32 {\\n        // Deep first graph traversing helper.\\n        // Pass a starting node to search from. \\n        fn count_nodes_in_cluster(graph: &Vec<Vec<usize>>, node: usize, stack: &mut Vec<usize>, visited: &mut Vec<bool>) -> usize {\\n            stack.push(node);\\n            while let Some(current) = stack.pop() {\\n                if visited[current] {\\n                    continue;\\n                }\\n                visited[current] = true;\\n                stack.extend(graph[current].iter().cloned());\\n            }\\n\\n            return visited.iter().filter(|&&flag| flag).count();\\n        }\\n\\n        let bombs_count = bombs.len(); // to avoid multiple function calling\\n        let mut visited = vec![false; bombs_count]; // reusable substitute of HashMap\\n        let mut connected_bombs = vec![Vec::with_capacity(bombs_count-1); bombs_count]; // allocate memory ahead\\n\\n        for i in 0..bombs_count {\\n            let x_i = bombs[i][0] as i64; // squared value may not fit in i32\\n            let y_i = bombs[i][1] as i64;\\n            let r_i = (bombs[i][2] as i64) * (bombs[i][2] as i64);\\n\\n            for j in i + 1..bombs_count {\\n                let x_j = bombs[j][0] as i64;\\n                let y_j = bombs[j][1] as i64;\\n                let r_j = bombs[j][2] as i64;\\n\\n                let d = (x_i - x_j) * (x_i - x_j) + (y_i - y_j) * (y_i - y_j);\\n                if d <= r_i {\\n                    connected_bombs[i].push(j);\\n                }\\n                // don\\'t forget to check reverse blast\\n                if d <= r_j * r_j {\\n                    connected_bombs[j].push(i);\\n                }\\n            }\\n        }\\n\\n        let mut result = 0;\\n        let mut stack = vec![]; // reusable stack for performance reason\\n        for i in 0..bombs_count {\\n            let excluded = count_nodes_in_cluster(&connected_bombs, i, &mut stack, &mut visited);\\n            if excluded > result {\\n                result = excluded;\\n            }\\n            visited.fill(false);\\n        }\\n\\n        return result as i32;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3589958,
                "title": "easy-to-understand-solution-c-with-comments",
                "content": "# Intuition\\nIn the given 2D vector bombs they are giving a co-ordinate with radius.\\nSo intuition is to build an adjacency list in which we can see how \\nmany more co-ordinates we can access at a particular index.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSo the Approach is to see from every index at i using radius that how many more indexes we can reach to maximize our answer.By the help of distance formula x1 is i and x2 is j, DistanceBetweenx1ANDx2 = ( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) ) and radius.\\nif DistanceBetweenx1ANDx2 <= radius (at i) then we can reach other wise we can\\'t.\\n\\n\\n\\nAs comments has give follow that to undestand the complete solution.\\n\\nFEEL FREE TO DISCUSS YOUR IDEAS WE AS A COMMUNITY LETS HELP EACH OTHER.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- In Worst Case:O(n*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    typedef long long ll;\\nprivate:\\n    void dfs(int node,vector<int>*adj,vector<bool>&vis,int &ANS){\\n        vis[node]=true;\\n        //Increasing the number of bombs detonated\\n        ANS+=1;\\n        //Going through all the adjacent/neighbours nodes\\n        for(auto &adjNode:adj[node]){\\n            if(!vis[adjNode]){\\n                dfs(adjNode,adj,vis,ANS);\\n            }\\n        }\\n    }\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        \\n        int n=bombs.size();\\n        vector<int>adj[n];\\n\\n        for(int i=0;i<n;i++){\\n            // this is the value of first point in graph and radius\\n            ll x1=(ll)bombs[i][0];\\n            ll y1=(ll)bombs[i][1];\\n            ll r1=(ll)bombs[i][2];\\n            for(int j=0;j<n;j++){\\n                // this is the value of second point in graph and radius\\n                ll x2=(ll)bombs[j][0];\\n                ll y2=(ll)bombs[j][1];\\n                ll r2=(ll)bombs[j][2];\\n                //Here we are finding the distance from point (x1,y1) to (x2,y2)\\n                ll DistanceBetweenx1ANDx2 = ( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) );\\n                //Checking whether the distance is less than or equal to r1 as up to r1 only our circle          \\n                //can stetch\\n                if(DistanceBetweenx1ANDx2 <= r1*r1){\\n                    // Here we can state that from index i to index j we can reach by using radius r1\\n                    adj[i].push_back(j);\\n                }\\n            }\\n        }\\n\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            vector<bool>vis(n,false);\\n            if(!vis[i]){\\n                //Here initially we are keeping ANS=0 for every node to see that maximum number of bombs \\n                //can be detonated  from node i\\n                int ANS=0;\\n                dfs(i,adj,vis,ANS);\\n                ans=max(ans,ANS);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    typedef long long ll;\\nprivate:\\n    void dfs(int node,vector<int>*adj,vector<bool>&vis,int &ANS){\\n        vis[node]=true;\\n        //Increasing the number of bombs detonated\\n        ANS+=1;\\n        //Going through all the adjacent/neighbours nodes\\n        for(auto &adjNode:adj[node]){\\n            if(!vis[adjNode]){\\n                dfs(adjNode,adj,vis,ANS);\\n            }\\n        }\\n    }\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        \\n        int n=bombs.size();\\n        vector<int>adj[n];\\n\\n        for(int i=0;i<n;i++){\\n            // this is the value of first point in graph and radius\\n            ll x1=(ll)bombs[i][0];\\n            ll y1=(ll)bombs[i][1];\\n            ll r1=(ll)bombs[i][2];\\n            for(int j=0;j<n;j++){\\n                // this is the value of second point in graph and radius\\n                ll x2=(ll)bombs[j][0];\\n                ll y2=(ll)bombs[j][1];\\n                ll r2=(ll)bombs[j][2];\\n                //Here we are finding the distance from point (x1,y1) to (x2,y2)\\n                ll DistanceBetweenx1ANDx2 = ( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) );\\n                //Checking whether the distance is less than or equal to r1 as up to r1 only our circle          \\n                //can stetch\\n                if(DistanceBetweenx1ANDx2 <= r1*r1){\\n                    // Here we can state that from index i to index j we can reach by using radius r1\\n                    adj[i].push_back(j);\\n                }\\n            }\\n        }\\n\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            vector<bool>vis(n,false);\\n            if(!vis[i]){\\n                //Here initially we are keeping ANS=0 for every node to see that maximum number of bombs \\n                //can be detonated  from node i\\n                int ANS=0;\\n                dfs(i,adj,vis,ANS);\\n                ans=max(ans,ANS);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589851,
                "title": "c-dfs-intuitive-clean-code",
                "content": "# Intuition\\nThe bombs will detonate all of the bombs which are in its range. So form groups which connects all bombs which are linked to each other.\\nCount the number of bombs connected together in a group. The group with maximum number of bombs will be our answer.\\n\\n# Approach\\nForm the a directed graph which connects the bombs. Run a dfs and count the number of bombs in each graph. The maximum would be our answer.\\n\\nRefer to the code for better understanding :)\\n\\n# Complexity\\n- Time complexity:O(N*N)\\n\\n- Space complexity:O(N*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<int>& vis, vector<int> graph[], int& c){\\n        vis[node] = 1;\\n        c++;\\n        for(auto child:graph[node]){\\n            if(vis[child]) continue;\\n            dfs(child, vis, graph, c);\\n        }\\n    }\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n = bombs.size();\\n        vector<int> graph[n];\\n        for(int i=0; i<n; i++){\\n            long long r = bombs[i][2];\\n            int x = bombs[i][0];\\n            int y = bombs[i][1];\\n\\n            for(int j=0; j<n; j++){\\n                if(i==j) continue;\\n                int x1 = bombs[j][0];\\n                int y1 = bombs[j][1];\\n                long long r1 = bombs[j][2];\\n\\n                long long dist = (pow(x-x1,2)+pow(y-y1,2));\\n                if(dist <= (r*r)) graph[i].push_back(j);\\n            }\\n        }\\n\\n        int maxi=1;\\n        for(int i=0; i<n; i++){\\n            int c=0;\\n            vector<int> vis(n,0);\\n            dfs(i, vis, graph, c);\\n            maxi = max(maxi, c);\\n        }\\n        return maxi;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<int>& vis, vector<int> graph[], int& c){\\n        vis[node] = 1;\\n        c++;\\n        for(auto child:graph[node]){\\n            if(vis[child]) continue;\\n            dfs(child, vis, graph, c);\\n        }\\n    }\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n = bombs.size();\\n        vector<int> graph[n];\\n        for(int i=0; i<n; i++){\\n            long long r = bombs[i][2];\\n            int x = bombs[i][0];\\n            int y = bombs[i][1];\\n\\n            for(int j=0; j<n; j++){\\n                if(i==j) continue;\\n                int x1 = bombs[j][0];\\n                int y1 = bombs[j][1];\\n                long long r1 = bombs[j][2];\\n\\n                long long dist = (pow(x-x1,2)+pow(y-y1,2));\\n                if(dist <= (r*r)) graph[i].push_back(j);\\n            }\\n        }\\n\\n        int maxi=1;\\n        for(int i=0; i<n; i++){\\n            int c=0;\\n            vector<int> vis(n,0);\\n            dfs(i, vis, graph, c);\\n            maxi = max(maxi, c);\\n        }\\n        return maxi;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589631,
                "title": "python-dfs-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDFS Solution\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N + E + V)\\n    where\\n    - N : Length of array\\n    - E : Number of Edges\\n    - V : Number of Nodes\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n- Python\\n```\\nclass Solution:\\n    def visit(self, node, adj, vis):\\n        vis[node] = 1\\n        ans = 1\\n        for nod in adj[node]:\\n            if vis[nod] == 0:\\n                ans += self.visit(nod, adj, vis)\\n        return ans\\n        \\n    def maximumDetonation(self, bombs: List[List[int]]) -> int:\\n        n = len(bombs)\\n        adj = {i : [] for i in range(n)}\\n\\n        for i in range(n):\\n            x1, y1, r1 = bombs[i][0], bombs[i][1], bombs[i][2] \\n            for j in range(i, n):\\n                x2, y2, r2 = bombs[j][0], bombs[j][1], bombs[j][2]\\n                d = ((x1-x2)**2 + (y1-y2)**2)**0.5\\n                if d <= r1:\\n                    adj[i].append(j)\\n                if d <= r2:\\n                    adj[j].append(i)\\n        \\n        ans = 0\\n\\n        for i in range(n):\\n            vis = [0] * n\\n            if vis[i] == 0:\\n                ans = max(ans, self.visit(i, adj, vis))\\n        return ans                \\n```\\n# UPVOTE Please!!",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def visit(self, node, adj, vis):\\n        vis[node] = 1\\n        ans = 1\\n        for nod in adj[node]:\\n            if vis[nod] == 0:\\n                ans += self.visit(nod, adj, vis)\\n        return ans\\n        \\n    def maximumDetonation(self, bombs: List[List[int]]) -> int:\\n        n = len(bombs)\\n        adj = {i : [] for i in range(n)}\\n\\n        for i in range(n):\\n            x1, y1, r1 = bombs[i][0], bombs[i][1], bombs[i][2] \\n            for j in range(i, n):\\n                x2, y2, r2 = bombs[j][0], bombs[j][1], bombs[j][2]\\n                d = ((x1-x2)**2 + (y1-y2)**2)**0.5\\n                if d <= r1:\\n                    adj[i].append(j)\\n                if d <= r2:\\n                    adj[j].append(i)\\n        \\n        ans = 0\\n\\n        for i in range(n):\\n            vis = [0] * n\\n            if vis[i] == 0:\\n                ans = max(ans, self.visit(i, adj, vis))\\n        return ans                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588968,
                "title": "java-3-ms-100-build-graph-then-dfs-from-each-bomb",
                "content": "This code converts the bomb location and radius to a graph where each bomb is a node in the graph, and the directional edges of the graph are the other bombs that the current bomb can reach with its blast radius.  After the graph is build into the variable `links[][]`, a depth-first-search (DFS) is performed starting from each bomb, to determine the total number of bombs to explode from each starting bomb.\\n\\nThis code is speed optimized.  Most other fast code examples for this leetcode problem, use a List\\\\<Integer> to contain the edges of the graph.  This code gains some speed by using a byte array terminated with a -1, to contain the edges of the graph.  The primitive data type `byte` array can be faster in execution than the more complex `List` data type.  We can use the byte array because we know the maximum number of edges for any graph node, will be 100, according to the constraints section of the leetcode problem description.  And 100 is a reasonable length to allocate in memory.\\n\\nIf there are `n` bombs in the passed `bombs[]` array, the graph will consist of a 2-D byte array `byte[][] links = new byte[n][n+1]` where the first index is the node number (index in the `bombs[]` array).  The second index is the index into the edges node numbers, terminatred by a -1 value.\\n\\nThis code has runtime as fast as 3ms in June 2023, but usually (~70% of submits) has runtime of 4ms. \\nIf useful, please upvote.\\n```\\nclass Solution {\\n    public int maximumDetonation(int[][] bombs) {\\n        int n = bombs.length;\\n        if (n <= 1)  return n;\\n        if (n == 2)  return twoBombs(bombs);\\n        \\n        byte[][] links = new byte[n][n + 1];\\n        int[] linksLen = new int[n];\\n        for (int b = 0; b < n; b++)\\n            buildLinks(links, linksLen, bombs, bombs[b], b);\\n        \\n        int maxLinks = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (linksLen[i] > maxLinks)  maxLinks = linksLen[i];\\n            links[i][linksLen[i]] = (byte)-1;\\n        }\\n        if (maxLinks == 0 || maxLinks == n - 1)  return maxLinks + 1;\\n        \\n        int maxExplosions = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            maxExplosions = Math.max(maxExplosions, countExplosions(links, new boolean[n], i));\\n            if (maxExplosions == n)  break;\\n        }\\n        return maxExplosions;\\n    }\\n    \\n    \\n    private int countExplosions(byte[][] links, boolean[] used, int b) {\\n        used[b] = true;\\n        int explosions = 1;\\n        for (int b1 : links[b]) {\\n            if (b1 < 0)  break;\\n            if (!used[b1])  explosions += countExplosions(links, used, b1);\\n        }\\n        return explosions;\\n    }\\n    \\n    \\n    private void buildLinks(byte[][] links, int[] linksLen, int[][] bombs, int[] bomb, int b) {\\n        int x = bomb[0];\\n        int y = bomb[1];\\n        long radius = (long)bomb[2] * bomb[2];\\n        for (int b1 = links.length - 1; b1 > b; b1--) {\\n            int[] bomb1 = bombs[b1];\\n            long dist = distance(x, y, bomb1[0], bomb1[1]);\\n            if (dist <= radius)  links[b][linksLen[b]++] = (byte)b1;\\n            if (dist <= (long)bomb1[2] * bomb1[2])  links[b1][linksLen[b1]++] = (byte)b;\\n        }\\n    }\\n    \\n    \\n    private long distance(int x1, int y1, int x2, int y2) {\\n        return (long)(x1 - x2) * (x1 - x2) + (long)(y1 - y2) * (y1 - y2);\\n    }\\n    \\n    \\n    private int twoBombs(int[][] bombs) {\\n            int[] b0 = bombs[0];\\n            int[] b1 = bombs[1];\\n            long dist = distance(b0[0], b0[1], b1[0], b1[1]);\\n            if (dist <= (long)b0[2] * b0[2] || dist <= (long)b1[2] * b1[2])  return 2;\\n            return 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumDetonation(int[][] bombs) {\\n        int n = bombs.length;\\n        if (n <= 1)  return n;\\n        if (n == 2)  return twoBombs(bombs);\\n        \\n        byte[][] links = new byte[n][n + 1];\\n        int[] linksLen = new int[n];\\n        for (int b = 0; b < n; b++)\\n            buildLinks(links, linksLen, bombs, bombs[b], b);\\n        \\n        int maxLinks = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (linksLen[i] > maxLinks)  maxLinks = linksLen[i];\\n            links[i][linksLen[i]] = (byte)-1;\\n        }\\n        if (maxLinks == 0 || maxLinks == n - 1)  return maxLinks + 1;\\n        \\n        int maxExplosions = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            maxExplosions = Math.max(maxExplosions, countExplosions(links, new boolean[n], i));\\n            if (maxExplosions == n)  break;\\n        }\\n        return maxExplosions;\\n    }\\n    \\n    \\n    private int countExplosions(byte[][] links, boolean[] used, int b) {\\n        used[b] = true;\\n        int explosions = 1;\\n        for (int b1 : links[b]) {\\n            if (b1 < 0)  break;\\n            if (!used[b1])  explosions += countExplosions(links, used, b1);\\n        }\\n        return explosions;\\n    }\\n    \\n    \\n    private void buildLinks(byte[][] links, int[] linksLen, int[][] bombs, int[] bomb, int b) {\\n        int x = bomb[0];\\n        int y = bomb[1];\\n        long radius = (long)bomb[2] * bomb[2];\\n        for (int b1 = links.length - 1; b1 > b; b1--) {\\n            int[] bomb1 = bombs[b1];\\n            long dist = distance(x, y, bomb1[0], bomb1[1]);\\n            if (dist <= radius)  links[b][linksLen[b]++] = (byte)b1;\\n            if (dist <= (long)bomb1[2] * bomb1[2])  links[b1][linksLen[b1]++] = (byte)b;\\n        }\\n    }\\n    \\n    \\n    private long distance(int x1, int y1, int x2, int y2) {\\n        return (long)(x1 - x2) * (x1 - x2) + (long)(y1 - y2) * (y1 - y2);\\n    }\\n    \\n    \\n    private int twoBombs(int[][] bombs) {\\n            int[] b0 = bombs[0];\\n            int[] b1 = bombs[1];\\n            long dist = distance(b0[0], b0[1], b1[0], b1[1]);\\n            if (dist <= (long)b0[2] * b0[2] || dist <= (long)b1[2] * b1[2])  return 2;\\n            return 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588921,
                "title": "c-dfs-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<int>&vis,vector<vector<int>>&temp,int &t,int& i){\\n        vis[i]=1;\\n          t++;\\n        for(int j=0;j<temp[i].size();j++){\\n            if(!vis[temp[i][j]]){\\n                \\n                dfs(vis,temp,t,temp[i][j]);\\n            }\\n        }\\n    }\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n=bombs.size();\\n        vector<vector<int>>temp(n);\\n\\n        for(int i=0;i<n;i++){\\n            long long x=bombs[i][0];\\n            long long y=bombs[i][1];\\n            long long r=bombs[i][2];\\n            for(int j=0;j<n;j++){\\n                if(i!=j){\\n                    long long x1=abs(x-bombs[j][0]);\\n                    long long y1=abs(y-bombs[j][1]);\\n                    if(x1*x1+y1*y1<=r*r){\\n                        temp[i].push_back(j);\\n                    }\\n                }\\n            }\\n        }\\n\\n       \\n        int ans=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            int t=0;\\n       vector<int>vis(n,0);\\n                dfs(vis,temp,t,i);\\n                ans=max(ans,t);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<int>&vis,vector<vector<int>>&temp,int &t,int& i){\\n        vis[i]=1;\\n          t++;\\n        for(int j=0;j<temp[i].size();j++){\\n            if(!vis[temp[i][j]]){\\n                \\n                dfs(vis,temp,t,temp[i][j]);\\n            }\\n        }\\n    }\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n=bombs.size();\\n        vector<vector<int>>temp(n);\\n\\n        for(int i=0;i<n;i++){\\n            long long x=bombs[i][0];\\n            long long y=bombs[i][1];\\n            long long r=bombs[i][2];\\n            for(int j=0;j<n;j++){\\n                if(i!=j){\\n                    long long x1=abs(x-bombs[j][0]);\\n                    long long y1=abs(y-bombs[j][1]);\\n                    if(x1*x1+y1*y1<=r*r){\\n                        temp[i].push_back(j);\\n                    }\\n                }\\n            }\\n        }\\n\\n       \\n        int ans=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            int t=0;\\n       vector<int>vis(n,0);\\n                dfs(vis,temp,t,i);\\n                ans=max(ans,t);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588865,
                "title": "python-approach-by-using-euclidean-distance-and-dfs",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    # DFS ...!\\n    def dfs(self, i):\\n        self.visit[i] = 1\\n        \\n        for node in self.d[i]:\\n            if self.visit[node] == 1:\\n                continue\\n            self.dfs(node)\\n\\n    def maximumDetonation(self, bombs: List[List[int]]) -> int:\\n        n = len(bombs)\\n        d = {}\\n        for i in range(n): d[i] = set()\\n\\n        for i in range(n):\\n            for j in range(n):\\n                if i == j: continue\\n\\n                # Euclidean Distance\\n                temp =(bombs[i][0]-bombs[j][0])**2+(bombs[i][1]-bombs[j][1])**2      \\n\\n                if temp <= bombs[j][2]**2: d[j].add(i)\\n                if temp <= bombs[i][2]**2: d[i].add(j)\\n        \\n        self.d = d\\n        ans = 1\\n        for i in range(n):\\n            self.visit = [0]*n\\n            self.dfs(i)\\n            ans = max(ans , sum(self.visit))    # No.of 1\\'s\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    # DFS ...!\\n    def dfs(self, i):\\n        self.visit[i] = 1\\n        \\n        for node in self.d[i]:\\n            if self.visit[node] == 1:\\n                continue\\n            self.dfs(node)\\n\\n    def maximumDetonation(self, bombs: List[List[int]]) -> int:\\n        n = len(bombs)\\n        d = {}\\n        for i in range(n): d[i] = set()\\n\\n        for i in range(n):\\n            for j in range(n):\\n                if i == j: continue\\n\\n                # Euclidean Distance\\n                temp =(bombs[i][0]-bombs[j][0])**2+(bombs[i][1]-bombs[j][1])**2      \\n\\n                if temp <= bombs[j][2]**2: d[j].add(i)\\n                if temp <= bombs[i][2]**2: d[i].add(j)\\n        \\n        self.d = d\\n        ans = 1\\n        for i in range(n):\\n            self.visit = [0]*n\\n            self.dfs(i)\\n            ans = max(ans , sum(self.visit))    # No.of 1\\'s\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588747,
                "title": "simple-solution-using-java-dfs",
                "content": "# The algorithm is pretty simple \\n- First of all you need to create a graph such that it stores the bombs which are located in its range. We have the radius of the bomb and we run a for loop iterating over all the bombs calculate the distance between the two bombs and compare with the radius then we will able to decide whether the bomb is in our range or not.\\n- After creating the graph we need to run DFS/BFS algorithm on the graph and find the total no.of reachable nodes from a particular node. We need to run this for all the nodes present in the graph.\\n- The DFS/BFS algorithm count all the reachable nodes and returns the value. We store our result in a varaible called \\'result\\' and compare it with the newly arrived DFS count.\\n- It is a very simple problem , if you are able to write functions for different parts of the problem like Creation of graph and DFS/BFS function.\\n\\n---\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int DFS(HashMap<Integer,ArrayList<Integer>> adj , int source,boolean[] visited)\\n    {\\n        visited[source] = true;\\n        int res = 1;\\n        for(int item : adj.get(source))\\n        {\\n            if(visited[item] == false)\\n            {\\n                res += DFS(adj,item,visited);\\n            }\\n        }\\n        return res;\\n    }\\n    public int maximumDetonation(int[][] bombs) {\\n        HashMap<Integer,ArrayList<Integer>> hmap = new HashMap<>();\\n        for(int i = 0;i<bombs.length;i++)\\n        {\\n            ArrayList<Integer> arr = new ArrayList<>();\\n            hmap.put(i,arr);\\n        }\\n        for(int i = 0;i<bombs.length;i++)\\n        {\\n            long x1 = bombs[i][0];\\n            long y1 = bombs[i][1];\\n            long r1 = bombs[i][2];\\n            for(int j = 0;j<bombs.length;j++)\\n            {\\n                if(i!=j)\\n                {\\n                    long x2 = bombs[j][0];\\n                    long y2 = bombs[j][1];\\n                    if(((x2-x1)*(x2-x1)) + ((y2-y1)*(y2-y1)) <= r1*r1)\\n                    {\\n                        ArrayList<Integer> arr = hmap.get(i);\\n                        arr.add(j);\\n                        hmap.put(i,arr);\\n                    } \\n                }  \\n            }\\n        }\\n        int result = 1;\\n        for(int i = 0;i<bombs.length;i++)\\n        {\\n            boolean[] visited = new boolean[bombs.length];\\n            result = Math.max(result,DFS(hmap,i,visited));\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n---\\n\\n\\n#### *If you\\'ve liked my explanation don\\'t forget to upvote and encourage.*",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int DFS(HashMap<Integer,ArrayList<Integer>> adj , int source,boolean[] visited)\\n    {\\n        visited[source] = true;\\n        int res = 1;\\n        for(int item : adj.get(source))\\n        {\\n            if(visited[item] == false)\\n            {\\n                res += DFS(adj,item,visited);\\n            }\\n        }\\n        return res;\\n    }\\n    public int maximumDetonation(int[][] bombs) {\\n        HashMap<Integer,ArrayList<Integer>> hmap = new HashMap<>();\\n        for(int i = 0;i<bombs.length;i++)\\n        {\\n            ArrayList<Integer> arr = new ArrayList<>();\\n            hmap.put(i,arr);\\n        }\\n        for(int i = 0;i<bombs.length;i++)\\n        {\\n            long x1 = bombs[i][0];\\n            long y1 = bombs[i][1];\\n            long r1 = bombs[i][2];\\n            for(int j = 0;j<bombs.length;j++)\\n            {\\n                if(i!=j)\\n                {\\n                    long x2 = bombs[j][0];\\n                    long y2 = bombs[j][1];\\n                    if(((x2-x1)*(x2-x1)) + ((y2-y1)*(y2-y1)) <= r1*r1)\\n                    {\\n                        ArrayList<Integer> arr = hmap.get(i);\\n                        arr.add(j);\\n                        hmap.put(i,arr);\\n                    } \\n                }  \\n            }\\n        }\\n        int result = 1;\\n        for(int i = 0;i<bombs.length;i++)\\n        {\\n            boolean[] visited = new boolean[bombs.length];\\n            result = Math.max(result,DFS(hmap,i,visited));\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588039,
                "title": "c-dfs",
                "content": "# Code\\n```\\nstruct Solution {\\n    int maximumDetonation(vector<vector<int>>& a) {\\n        int n = (int) a.size();\\n        vector<vector<int>> g(n);\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i == j) {\\n                    continue;\\n                }\\n                long long dx = a[j][0] - a[i][0];\\n                long long dy = a[j][1] - a[i][1];\\n                long long dd = dx * dx + dy * dy;\\n                if (dd <= 1LL * a[i][2] * a[i][2]) {\\n                    g[i].emplace_back(j);\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for (int r = 0; r < n; r++) {\\n            vector<int> b(n);\\n            auto dfs = [&](auto&& self, int v, int p) -> void {\\n                b[v] = 1;\\n                for (int to : g[v]) {\\n                    if (to == p || b[to]) {\\n                        continue;\\n                    }\\n                    self(self, to, v);\\n                }\\n            };\\n            dfs(dfs, r, -1);\\n            ans = max(ans, accumulate(b.begin(), b.end(), 0));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nstruct Solution {\\n    int maximumDetonation(vector<vector<int>>& a) {\\n        int n = (int) a.size();\\n        vector<vector<int>> g(n);\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i == j) {\\n                    continue;\\n                }\\n                long long dx = a[j][0] - a[i][0];\\n                long long dy = a[j][1] - a[i][1];\\n                long long dd = dx * dx + dy * dy;\\n                if (dd <= 1LL * a[i][2] * a[i][2]) {\\n                    g[i].emplace_back(j);\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for (int r = 0; r < n; r++) {\\n            vector<int> b(n);\\n            auto dfs = [&](auto&& self, int v, int p) -> void {\\n                b[v] = 1;\\n                for (int to : g[v]) {\\n                    if (to == p || b[to]) {\\n                        continue;\\n                    }\\n                    self(self, to, v);\\n                }\\n            };\\n            dfs(dfs, r, -1);\\n            ans = max(ans, accumulate(b.begin(), b.end(), 0));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3588010,
                "title": "python-short-and-clean-dfs-functional-programming",
                "content": "# Approach\\nTL;DR, Similar to [Editorial Solution](https://leetcode.com/problems/detonate-the-maximum-bombs/editorial/) but shorter and cleaner.\\n\\n# Complexity\\n- Time complexity: $$O(n ^ 3)$$\\n\\n- Space complexity: $$O(n ^ 2)$$\\n\\n# Code\\n```python\\nclass Solution:\\n    def maximumDetonation(self, bombs: list[list[int]]) -> int:\\n        Bomb = tuple[int, int, int]\\n        T = Hashable\\n        Graph = Mapping[T, Collection[T]]\\n\\n        def in_range(b1: Bomb, b2: Bomb) -> bool:\\n            return (b1[0] - b2[0]) ** 2 + (b1[1] - b2[1]) ** 2 <= b1[2] ** 2\\n\\n        def connections(graph: Graph, src: T, seen: set[T]) -> int:\\n            return seen.add(src) or 1 + sum(connections(graph, x, seen) for x in graph[src] if x not in seen)\\n\\n        g = {i: tuple(j for j, b2 in enumerate(bombs) if in_range(b1, b2)) for i, b1 in enumerate(bombs)}\\n        return max(connections(g, x, set()) for x in g)\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Graph",
                    "Geometry"
                ],
                "code": "```python\\nclass Solution:\\n    def maximumDetonation(self, bombs: list[list[int]]) -> int:\\n        Bomb = tuple[int, int, int]\\n        T = Hashable\\n        Graph = Mapping[T, Collection[T]]\\n\\n        def in_range(b1: Bomb, b2: Bomb) -> bool:\\n            return (b1[0] - b2[0]) ** 2 + (b1[1] - b2[1]) ** 2 <= b1[2] ** 2\\n\\n        def connections(graph: Graph, src: T, seen: set[T]) -> int:\\n            return seen.add(src) or 1 + sum(connections(graph, x, seen) for x in graph[src] if x not in seen)\\n\\n        g = {i: tuple(j for j, b2 in enumerate(bombs) if in_range(b1, b2)) for i, b1 in enumerate(bombs)}\\n        return max(connections(g, x, set()) for x in g)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587742,
                "title": "swift-minimal-bfs",
                "content": "**BFS (accepted answer)**\\n```\\nclass Solution {\\n    func maximumDetonation(_ bombs: [[Int]]) -> Int {\\n\\t\\n        func contains(_ a:[Int], _ b:[Int]) -> Bool {\\n            let (deltaX, deltaY) = (a[0]-b[0], a[1]-b[1])\\n            return deltaX * deltaX + deltaY * deltaY <= a[2] * a[2]\\n        }\\n        \\n        let bombsInRadius = bombs.indices.map { i in\\n            bombs.indices.filter { j in contains(bombs[i], bombs[j]) }\\n        }\\n        \\n        func bfs(_ start: Int) -> Int {\\n            var bfs = Set([start]), visited = bfs\\n            while !bfs.isEmpty {\\n                bfs = Set(bfs.flatMap { bomb in bombsInRadius[bomb]}).subtracting(visited)\\n                visited.formUnion(bfs)\\n            }\\n            return visited.count\\n        }\\n        \\n        return bombs.indices.map(bfs).max()!\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maximumDetonation(_ bombs: [[Int]]) -> Int {\\n\\t\\n        func contains(_ a:[Int], _ b:[Int]) -> Bool {\\n            let (deltaX, deltaY) = (a[0]-b[0], a[1]-b[1])\\n            return deltaX * deltaX + deltaY * deltaY <= a[2] * a[2]\\n        }\\n        \\n        let bombsInRadius = bombs.indices.map { i in\\n            bombs.indices.filter { j in contains(bombs[i], bombs[j]) }\\n        }\\n        \\n        func bfs(_ start: Int) -> Int {\\n            var bfs = Set([start]), visited = bfs\\n            while !bfs.isEmpty {\\n                bfs = Set(bfs.flatMap { bomb in bombsInRadius[bomb]}).subtracting(visited)\\n                visited.formUnion(bfs)\\n            }\\n            return visited.count\\n        }\\n        \\n        return bombs.indices.map(bfs).max()!\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587706,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def maximumDetonation(self, bombs: List[List[int]]) -> int:\\n        graph = [[] for _ in bombs]\\n        for i, (xi, yi, ri) in enumerate(bombs): \\n            for j, (xj, yj, rj) in enumerate(bombs): \\n                if i < j: \\n                    dist2 = (xi-xj)**2 + (yi-yj)**2\\n                    if dist2 <= ri**2:\\n                        graph[i].append(j)\\n                    if dist2 <= rj**2:\\n                        graph[j].append(i)\\n        \\n        def fn(x):\\n            ans = 1\\n            seen = {x}\\n            stack = [x]\\n            while stack: \\n                u = stack.pop()\\n                for v in graph[u]: \\n                    if v not in seen: \\n                        ans += 1\\n                        seen.add(v)\\n                        stack.append(v)\\n            return ans \\n        \\n        return max(fn(x) for x in range(len(bombs)))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumDetonation(self, bombs: List[List[int]]) -> int:\\n        graph = [[] for _ in bombs]\\n        for i, (xi, yi, ri) in enumerate(bombs): \\n            for j, (xj, yj, rj) in enumerate(bombs): \\n                if i < j: \\n                    dist2 = (xi-xj)**2 + (yi-yj)**2\\n                    if dist2 <= ri**2:\\n                        graph[i].append(j)\\n                    if dist2 <= rj**2:\\n                        graph[j].append(i)\\n        \\n        def fn(x):\\n            ans = 1\\n            seen = {x}\\n            stack = [x]\\n            while stack: \\n                u = stack.pop()\\n                for v in graph[u]: \\n                    if v not in seen: \\n                        ans += 1\\n                        seen.add(v)\\n                        stack.append(v)\\n            return ans \\n        \\n        return max(fn(x) for x in range(len(bombs)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587627,
                "title": "c-using-graph",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n#define ll long long int\\n    public:\\n    void dfs(vector<vector<int>> &graph,vector<bool> &visited,int &c,int &i)\\n    {\\n        visited[i]=true;\\n        c++;\\n        for(int j=0;j<graph[i].size();j++)\\n        {\\n            if(!visited[graph[i][j]])\\n             dfs(graph,visited,c,graph[i][j]);   \\n        }\\n    }\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n\\n        int n=bombs.size();\\n        vector<vector<int> > graph(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            ll x1,y1,r1;\\n            x1=bombs[i][0];\\n            y1=bombs[i][1];\\n            r1=bombs[i][2];\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i!=j)\\n                {\\n                     ll x2,y2,r2;\\n                     x2=abs(x1-bombs[j][0]);\\n                     y2=abs(y1-bombs[j][1]);\\n                    if(x2*x2+y2*y2<=r1*r1)\\n                    {\\n                        graph[i].push_back(j);\\n                    }\\n                }\\n            }\\n        }\\n        int ans=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            int c=0;\\n            vector<bool> visited(n,false);\\n            dfs(graph,visited,c,i);\\n            ans=max(ans,c);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n#define ll long long int\\n    public:\\n    void dfs(vector<vector<int>> &graph,vector<bool> &visited,int &c,int &i)\\n    {\\n        visited[i]=true;\\n        c++;\\n        for(int j=0;j<graph[i].size();j++)\\n        {\\n            if(!visited[graph[i][j]])\\n             dfs(graph,visited,c,graph[i][j]);   \\n        }\\n    }\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n\\n        int n=bombs.size();\\n        vector<vector<int> > graph(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            ll x1,y1,r1;\\n            x1=bombs[i][0];\\n            y1=bombs[i][1];\\n            r1=bombs[i][2];\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i!=j)\\n                {\\n                     ll x2,y2,r2;\\n                     x2=abs(x1-bombs[j][0]);\\n                     y2=abs(y1-bombs[j][1]);\\n                    if(x2*x2+y2*y2<=r1*r1)\\n                    {\\n                        graph[i].push_back(j);\\n                    }\\n                }\\n            }\\n        }\\n        int ans=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            int c=0;\\n            vector<bool> visited(n,false);\\n            dfs(graph,visited,c,i);\\n            ans=max(ans,c);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587566,
                "title": "easy-to-understand-c-dfs",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int cnt = 0;\\n    void dfs(vector<int> adj[], vector<int>& v, int i){\\n        cnt++;\\n        v[i] = 1;\\n        for(int x: adj[i])\\n            if(!v[x])\\n                dfs(adj, v, x);\\n    }\\n    void makeAdjList(vector<vector<int>>& b, vector<int> adj[]){\\n        for(int i = 0; i<b.size(); ++i){\\n            for(int j = 0; j<b.size(); ++j){\\n                if(i!=j)\\n                    if(pow(b[j][0] - b[i][0], 2) + pow(b[j][1] - b[i][1], 2) - pow(b[i][2],2) <= 0)\\n                        adj[i].push_back(j);\\n            }\\n        }\\n    }\\n    int maximumDetonation(vector<vector<int>>& b) {\\n        vector<int> adj[b.size()];\\n        makeAdjList(b, adj);\\n        int res = 0;\\n        for(int i = 0; i<b.size(); ++i){\\n            vector<int> v(b.size(), 0);\\n            cnt = 0;\\n            dfs(adj, v, i);\\n            res = max(res, cnt);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int cnt = 0;\\n    void dfs(vector<int> adj[], vector<int>& v, int i){\\n        cnt++;\\n        v[i] = 1;\\n        for(int x: adj[i])\\n            if(!v[x])\\n                dfs(adj, v, x);\\n    }\\n    void makeAdjList(vector<vector<int>>& b, vector<int> adj[]){\\n        for(int i = 0; i<b.size(); ++i){\\n            for(int j = 0; j<b.size(); ++j){\\n                if(i!=j)\\n                    if(pow(b[j][0] - b[i][0], 2) + pow(b[j][1] - b[i][1], 2) - pow(b[i][2],2) <= 0)\\n                        adj[i].push_back(j);\\n            }\\n        }\\n    }\\n    int maximumDetonation(vector<vector<int>>& b) {\\n        vector<int> adj[b.size()];\\n        makeAdjList(b, adj);\\n        int res = 0;\\n        for(int i = 0; i<b.size(); ++i){\\n            vector<int> v(b.size(), 0);\\n            cnt = 0;\\n            dfs(adj, v, i);\\n            res = max(res, cnt);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587544,
                "title": "ruby-solution-with-bfs-100-100",
                "content": "# Intuition\\nFor each bomb, find the bombs it immediately causes to explode, then BFS to find how many it explodes in total.\\n\\n# Approach\\n1. Create a hash of bombs that each bomb will directly explode (each key is an index, each value is an array of indices of other bombs).\\n2. Iterate through every pair of bombs.  For each pair:\\n    - Use the distance formula to check if the first bomb explodes the other.  If so, add it to the hash.\\n    - Check if the second bomb explodes the first bomb, and add it to the *second* bomb\\'s array if so.\\n3. Initialize the maximum to be zero (in case there are no bombs).\\n4. BFS from each bomb to see all other bombs it explodes:\\n    - Create a set of bombs that have exploded.\\n    - Create a queue with the first bomb.\\n    - For each bomb in the queue, check if it explodes any bombs that haven\\'t exploded yet.  If so, add those bombs to the checked set and the queue.\\n    - Once queue is empty, compare the size of the checked (exploded) bombs to max, and take whichever is bigger.\\n5. Return max.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n^2)$$\\n\\n# Code\\n```\\ndef maximum_detonation(bombs)\\n    chain = Hash.new { |h,k| h[k] = [] }\\n\\n    bombs.each_with_index do |bomb,i|\\n        bombs.each_with_index do |bomb2,j|\\n            if i > j\\n                a,b,c = bomb\\n                d,e,f = bomb2\\n\\n                chain[i] << j if (a-d)**2 + (b-e)**2 <= c**2\\n                chain[j] << i if (a-d)**2 + (b-e)**2 <= f**2\\n            end\\n        end\\n    end\\n\\n    max = 0\\n\\n    (0...bombs.length).each do |i|\\n        checked = Set[i]\\n        queue = checked.to_a\\n\\n        until queue.empty?\\n            bomb = queue.shift\\n            connections = chain[bomb]\\n            connections.each do |connection|\\n                queue << connection unless checked.include?(connection)\\n                checked.add(connection)\\n            end\\n        end\\n\\n        max = checked.size if checked.size > max\\n    end\\n\\n    max\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef maximum_detonation(bombs)\\n    chain = Hash.new { |h,k| h[k] = [] }\\n\\n    bombs.each_with_index do |bomb,i|\\n        bombs.each_with_index do |bomb2,j|\\n            if i > j\\n                a,b,c = bomb\\n                d,e,f = bomb2\\n\\n                chain[i] << j if (a-d)**2 + (b-e)**2 <= c**2\\n                chain[j] << i if (a-d)**2 + (b-e)**2 <= f**2\\n            end\\n        end\\n    end\\n\\n    max = 0\\n\\n    (0...bombs.length).each do |i|\\n        checked = Set[i]\\n        queue = checked.to_a\\n\\n        until queue.empty?\\n            bomb = queue.shift\\n            connections = chain[bomb]\\n            connections.each do |connection|\\n                queue << connection unless checked.include?(connection)\\n                checked.add(connection)\\n            end\\n        end\\n\\n        max = checked.size if checked.size > max\\n    end\\n\\n    max\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3587531,
                "title": "daily-leetcoding-challenge-june-day-2",
                "content": "This problem is the Daily LeetCoding Challenge for June, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/detonate-the-maximum-bombs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Depth-First Search, Recursive\n\n  \n**Approach 2:** Depth-First Search, Iterative\n\n  \n**Approach 3:** Breadth-First Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/detonate-the-maximum-bombs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2961934,
                "title": "c-bfs-graph-traversal",
                "content": "# Intuition\\nPorted from Java from: https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/1623563/simple-java-bfs/?page=3\\n# Approach\\nDue to its radial exploration nature, BFS almost litteraly fits this problem. I confess I did try first Union-Find, but could only get 125 of LeetCode\\'s test cases to pass...\\n\\nThe first part of the BFS solution consists in computing the indiviual reach of each bomb (using Euclidean distance) and storing it in a dictionary. Note that bombs that don\\'t reach any other bombs are not added to the dictonary:\\n\\n```\\nDictionary<int,List<int>> map = new ();\\n\\nfor(int i=0; i < bombs.Length;i++){\\n    for(int j=0; j< bombs.Length;j++){\\n        if(j==i) \\n            continue;\\n        long sum = (long)(bombs[i][0]-bombs[j][0])*(long)(bombs[i][0]-bombs[j][0])+(long)(bombs[i][1]-bombs[j][1])*(long)(bombs[i][1]-bombs[j][1]);\\n        long self = (long)bombs[i][2]*(long)bombs[i][2];\\n        if(self >= sum){\\n            if(!map.ContainsKey(i)){\\n                map.Add(i,new List<int>());\\n            }\\n            map[i].Add(j);\\n        }\\n    }\\n}\\n```\\nThe second par is BFS itself. Note that the visited array is reset for every new starting node/traversal.\\n```\\nfor(int i=0;i< bombs.Length;i++){\\n...\\n    int[] visit = new int[bombs.Length];\\n```\\nAt the end of each traversal, the maximum bomb reach is updated:\\n```\\nmax = Math.Max(max,count);\\n\\n```\\nBFS will allow us to accumulate and explore the reach of each bomb. Each traversal will be optmized since we\\'ll avoid repeated operations by marking the visited nodes. \\nThe fact that we already have a precomputed dictionary with the individual reach of each bomb also makes a huge performance difference when running the BFS traversal for each bomb.\\n\\n# Code\\n```\\npublic class Solution {\\n\\n    public int MaximumDetonation(int[][] bombs) {\\n        Dictionary<int,List<int>> map = new ();\\n        \\n        for(int i=0; i < bombs.Length;i++){\\n            for(int j=0; j< bombs.Length;j++){\\n                if(j==i) \\n                    continue;\\n                long sum = (long)(bombs[i][0]-bombs[j][0])*(long)(bombs[i][0]-bombs[j][0])+(long)(bombs[i][1]-bombs[j][1])*(long)(bombs[i][1]-bombs[j][1]);\\n                long self = (long)bombs[i][2]*(long)bombs[i][2];\\n                if(self >= sum){\\n                    if(!map.ContainsKey(i)){\\n                        map.Add(i,new List<int>());\\n                    }\\n                    map[i].Add(j);\\n                }\\n            }\\n        }\\n        int max = 1;\\n        \\n        for(int i=0;i< bombs.Length;i++){\\n            if(!map.ContainsKey(i)){\\n                continue;\\n            }\\n            int[] visit = new int[bombs.Length];\\n            int count = 1;\\n            Queue<int> q = new ();\\n            q.Enqueue(i);\\n            visit[i] = 1;\\n            while(q.Count > 0){\\n                int size = q.Count;\\n                while(size > 0){\\n                    int cur = q.Dequeue();\\n                    if(!map.ContainsKey(cur)){\\n                        size--;\\n                        continue;\\n                    }\\n                    foreach(int x in map[cur]){\\n                        if(visit[x]==1) \\n                            continue;\\n                        q.Enqueue(x);\\n                        visit[x] = 1;\\n                        count++;\\n                    }\\n                    size--;\\n                }\\n            }\\n            max = Math.Max(max,count);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Breadth-First Search"
                ],
                "code": "```\\nDictionary<int,List<int>> map = new ();\\n\\nfor(int i=0; i < bombs.Length;i++){\\n    for(int j=0; j< bombs.Length;j++){\\n        if(j==i) \\n            continue;\\n        long sum = (long)(bombs[i][0]-bombs[j][0])*(long)(bombs[i][0]-bombs[j][0])+(long)(bombs[i][1]-bombs[j][1])*(long)(bombs[i][1]-bombs[j][1]);\\n        long self = (long)bombs[i][2]*(long)bombs[i][2];\\n        if(self >= sum){\\n            if(!map.ContainsKey(i)){\\n                map.Add(i,new List<int>());\\n            }\\n            map[i].Add(j);\\n        }\\n    }\\n}\\n```\n```\\nfor(int i=0;i< bombs.Length;i++){\\n...\\n    int[] visit = new int[bombs.Length];\\n```\n```\\nmax = Math.Max(max,count);\\n\\n```\n```\\npublic class Solution {\\n\\n    public int MaximumDetonation(int[][] bombs) {\\n        Dictionary<int,List<int>> map = new ();\\n        \\n        for(int i=0; i < bombs.Length;i++){\\n            for(int j=0; j< bombs.Length;j++){\\n                if(j==i) \\n                    continue;\\n                long sum = (long)(bombs[i][0]-bombs[j][0])*(long)(bombs[i][0]-bombs[j][0])+(long)(bombs[i][1]-bombs[j][1])*(long)(bombs[i][1]-bombs[j][1]);\\n                long self = (long)bombs[i][2]*(long)bombs[i][2];\\n                if(self >= sum){\\n                    if(!map.ContainsKey(i)){\\n                        map.Add(i,new List<int>());\\n                    }\\n                    map[i].Add(j);\\n                }\\n            }\\n        }\\n        int max = 1;\\n        \\n        for(int i=0;i< bombs.Length;i++){\\n            if(!map.ContainsKey(i)){\\n                continue;\\n            }\\n            int[] visit = new int[bombs.Length];\\n            int count = 1;\\n            Queue<int> q = new ();\\n            q.Enqueue(i);\\n            visit[i] = 1;\\n            while(q.Count > 0){\\n                int size = q.Count;\\n                while(size > 0){\\n                    int cur = q.Dequeue();\\n                    if(!map.ContainsKey(cur)){\\n                        size--;\\n                        continue;\\n                    }\\n                    foreach(int x in map[cur]){\\n                        if(visit[x]==1) \\n                            continue;\\n                        q.Enqueue(x);\\n                        visit[x] = 1;\\n                        count++;\\n                    }\\n                    size--;\\n                }\\n            }\\n            max = Math.Max(max,count);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780489,
                "title": "c",
                "content": "```\\nint maximumDetonation(int** bombs, int bombsSize, int* bombsColSize){\\n    bool* check = calloc(bombsSize, sizeof(bool));\\n    bool** attach = malloc(bombsSize * sizeof(bool*));\\n    for(int i = 0; i < bombsSize; i++){\\n        attach[i] = calloc(bombsSize , sizeof(bool));\\n    }\\n\\n    for(int i = 0; i < bombsSize; i++){\\n        attach[i][i] = true;\\n        for(int j = i+1; j < bombsSize; j++){\\n            int x = abs(bombs[i][0] - bombs[j][0] ) ;\\n            int y = abs(bombs[i][1] - bombs[j][1] ) ;\\n            long long dis = (long long)x*x + (long long)y*y;\\n            if(dis <= (long long)bombs[i][2]*bombs[i][2])\\n                attach[i][j] = true;\\n            if(dis <= (long long)bombs[j][2]*bombs[j][2])\\n                attach[j][i] = true;\\n        }\\n    }\\n    \\n    int* stack1 = malloc(bombsSize * sizeof(int));\\n    int* stack2 = malloc(bombsSize * sizeof(int));\\n    int id1 = 0, id2 = 0;\\n    int max = 1;\\n    for(int i = 0; i < bombsSize; i++){\\n        check = calloc(bombsSize, sizeof(bool));\\n        int cur = 1;\\n        check[i] = true;\\n        stack1[id1] = i;\\n        id1++;\\n        while(id1 || id2){\\n            if(id1){\\n                for(int j = 0; j < id1; j++){\\n                    int p = stack1[j];\\n                    for(int k = 0; k < bombsSize; k++){\\n                        if(attach[p][k] && check[k] == false){\\n                            cur++;\\n                            check[k] = true;\\n                            stack2[id2] = k;\\n                            id2++;\\n                        }\\n                    }\\n                }\\n                id1 = 0;\\n            }\\n            else{\\n                for(int j = 0; j < id2; j++){\\n                    int p = stack2[j];\\n                    for(int k = 0; k < bombsSize; k++){\\n                        if(attach[p][k] && check[k] == false){\\n                            cur++;\\n                            check[k] = true;\\n                            stack1[id1] = k;\\n                            id1++;\\n                        }\\n                    }\\n                }\\n                id2 = 0;\\n            }\\n        }\\n        max = fmax(max, cur);\\n    }\\n    return max;\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nint maximumDetonation(int** bombs, int bombsSize, int* bombsColSize){\\n    bool* check = calloc(bombsSize, sizeof(bool));\\n    bool** attach = malloc(bombsSize * sizeof(bool*));\\n    for(int i = 0; i < bombsSize; i++){\\n        attach[i] = calloc(bombsSize , sizeof(bool));\\n    }\\n\\n    for(int i = 0; i < bombsSize; i++){\\n        attach[i][i] = true;\\n        for(int j = i+1; j < bombsSize; j++){\\n            int x = abs(bombs[i][0] - bombs[j][0] ) ;\\n            int y = abs(bombs[i][1] - bombs[j][1] ) ;\\n            long long dis = (long long)x*x + (long long)y*y;\\n            if(dis <= (long long)bombs[i][2]*bombs[i][2])\\n                attach[i][j] = true;\\n            if(dis <= (long long)bombs[j][2]*bombs[j][2])\\n                attach[j][i] = true;\\n        }\\n    }\\n    \\n    int* stack1 = malloc(bombsSize * sizeof(int));\\n    int* stack2 = malloc(bombsSize * sizeof(int));\\n    int id1 = 0, id2 = 0;\\n    int max = 1;\\n    for(int i = 0; i < bombsSize; i++){\\n        check = calloc(bombsSize, sizeof(bool));\\n        int cur = 1;\\n        check[i] = true;\\n        stack1[id1] = i;\\n        id1++;\\n        while(id1 || id2){\\n            if(id1){\\n                for(int j = 0; j < id1; j++){\\n                    int p = stack1[j];\\n                    for(int k = 0; k < bombsSize; k++){\\n                        if(attach[p][k] && check[k] == false){\\n                            cur++;\\n                            check[k] = true;\\n                            stack2[id2] = k;\\n                            id2++;\\n                        }\\n                    }\\n                }\\n                id1 = 0;\\n            }\\n            else{\\n                for(int j = 0; j < id2; j++){\\n                    int p = stack2[j];\\n                    for(int k = 0; k < bombsSize; k++){\\n                        if(attach[p][k] && check[k] == false){\\n                            cur++;\\n                            check[k] = true;\\n                            stack1[id1] = k;\\n                            id1++;\\n                        }\\n                    }\\n                }\\n                id2 = 0;\\n            }\\n        }\\n        max = fmax(max, cur);\\n    }\\n    return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2692165,
                "title": "c-using-dfs-neat-code-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<bool>&visited, vector<int>adj[], int &currDiffused){\\n        \\n        currDiffused += 1;// increasing the number of bombs getting detonated as we do dfs traversal\\n        \\n        for(auto child : adj[node]){\\n            if(!visited[child]){\\n                visited[child] = true;\\n                dfs(child, visited, adj, currDiffused);\\n            }\\n        }\\n    }\\n    int maximumDetonation(vector<vector<int>>& arr) {\\n        \\n        int n = arr.size();\\n        vector<int>adj[n];\\n        \\n        //forming adjacency list\\n        for(int i = 0; i < n; i++){\\n            \\n            long long x = arr[i][0], y = arr[i][1], r = arr[i][2];\\n            for(int j = 0; j < n; j++){\\n                \\n                if(i == j) continue;// current cirle(node) can\\'t have itself as its adjacent node\\n                \\n                long long xx = arr[j][0], yy = arr[j][1];\\n                long long diffx = (x - xx) * (x - xx), diffy = (y - yy) * (y - yy), rSquare = r * r;\\n                if(diffx + diffy <= rSquare){// jth bomb will also diffuse if it\\'s center lies inside the ith bomb\\'s range, so jth bomb will be adjacent node to ith bomb\\n                    adj[i].push_back(j);\\n                }\\n                \\n            }\\n        }\\n        \\n        int maxDiffused = 0;//will store maximum bombs that can be detonated\\n        for(int node = 0; node < n; node++){\\n            \\n            vector<bool>visited(n, false);\\n            \\n            int currDiffused = 0;// It stores maximum bombs that will be detonated, if we detonate current bomb node\\n            if(!visited[node]){\\n                \\n                visited[node] = true;\\n                dfs(node, visited, adj, currDiffused);\\n            }\\n          \\n            maxDiffused = max(maxDiffused, currDiffused);\\n        }\\n        \\n        return maxDiffused;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<bool>&visited, vector<int>adj[], int &currDiffused){\\n        \\n        currDiffused += 1;// increasing the number of bombs getting detonated as we do dfs traversal\\n        \\n        for(auto child : adj[node]){\\n            if(!visited[child]){\\n                visited[child] = true;\\n                dfs(child, visited, adj, currDiffused);\\n            }\\n        }\\n    }\\n    int maximumDetonation(vector<vector<int>>& arr) {\\n        \\n        int n = arr.size();\\n        vector<int>adj[n];\\n        \\n        //forming adjacency list\\n        for(int i = 0; i < n; i++){\\n            \\n            long long x = arr[i][0], y = arr[i][1], r = arr[i][2];\\n            for(int j = 0; j < n; j++){\\n                \\n                if(i == j) continue;// current cirle(node) can\\'t have itself as its adjacent node\\n                \\n                long long xx = arr[j][0], yy = arr[j][1];\\n                long long diffx = (x - xx) * (x - xx), diffy = (y - yy) * (y - yy), rSquare = r * r;\\n                if(diffx + diffy <= rSquare){// jth bomb will also diffuse if it\\'s center lies inside the ith bomb\\'s range, so jth bomb will be adjacent node to ith bomb\\n                    adj[i].push_back(j);\\n                }\\n                \\n            }\\n        }\\n        \\n        int maxDiffused = 0;//will store maximum bombs that can be detonated\\n        for(int node = 0; node < n; node++){\\n            \\n            vector<bool>visited(n, false);\\n            \\n            int currDiffused = 0;// It stores maximum bombs that will be detonated, if we detonate current bomb node\\n            if(!visited[node]){\\n                \\n                visited[node] = true;\\n                dfs(node, visited, adj, currDiffused);\\n            }\\n          \\n            maxDiffused = max(maxDiffused, currDiffused);\\n        }\\n        \\n        return maxDiffused;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677498,
                "title": "easy-to-understand-java-solution-using-bfs",
                "content": "See the solution here:\\nhttps://github.com/Freeze777/SDE-Interviewer-Notes/blob/main/LeetCodeJava/src/main/java/leetcode/medium/graph/DetonateMaxBombs.java",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2509889,
                "title": "python-simple-dfs",
                "content": "\\n    def maximumDetonation(self, bombs):\\n        dict1 = defaultdict(list)\\n        \\n        for i in range(len(bombs)):\\n            for j in range(len(bombs)):\\n                dist = abs(bombs[i][0] - bombs[j][0])**2 + abs(bombs[i][1] - bombs[j][1])**2\\n                if dist <= bombs[i][2]**2:\\n                    dict1[i].append(j)\\n                    \\n        def dfs(node):\\n            visited.add(node)\\n            \\n            for child in dict1[node]:\\n                if child not in visited:\\n                    dfs(child)\\n                    \\n        max_val = 0\\n        \\n        for i in range(len(bombs)):\\n            visited = set()\\n            dfs(i)\\n            max_val = max(max_val, len(visited))\\n        \\n        return max_val",
                "solutionTags": [],
                "code": "\\n    def maximumDetonation(self, bombs):\\n        dict1 = defaultdict(list)\\n        \\n        for i in range(len(bombs)):\\n            for j in range(len(bombs)):\\n                dist = abs(bombs[i][0] - bombs[j][0])**2 + abs(bombs[i][1] - bombs[j][1])**2\\n                if dist <= bombs[i][2]**2:\\n                    dict1[i].append(j)\\n                    \\n        def dfs(node):\\n            visited.add(node)\\n            \\n            for child in dict1[node]:\\n                if child not in visited:\\n                    dfs(child)\\n                    \\n        max_val = 0\\n        \\n        for i in range(len(bombs)):\\n            visited = set()\\n            dfs(i)\\n            max_val = max(max_val, len(visited))\\n        \\n        return max_val",
                "codeTag": "Python3"
            },
            {
                "id": 2312596,
                "title": "java-easy-and-intuitive-with-explaination-graph-dfs-geometry",
                "content": "```\\nclass Solution {\\n    /*\\n    Make directed graph\\n    u -> v means, v is in the range of u\\n    check from which node maximum nodes can be reached and return the number of nodes reached\\n    */\\n    public int maximumDetonation(int[][] bombs) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n    \\n        int n = bombs.length;\\n        for(int i = 0; i< n; i++){\\n            graph.put(i, new ArrayList<>());\\n            for(int j = 0; j< n; j++){\\n                if(i == j) continue;\\n                if(inRange(bombs[i], bombs[j]))\\n                    graph.get(i).add(j);\\n            }\\n        }\\n        \\n        int max = 0;\\n        for(int i = 0; i< n; i++){\\n            max = Math.max(max, dfs(i, graph, new HashSet<>()));\\n        }\\n        return max;\\n    }\\n    \\n    private boolean inRange(int[] u, int[] v){\\n        // (x-a)^2 + (y-b)^2 = R^2 -> point (a, b) is at border\\n        // (x-a)^2 + (y-b)^2 < R^2 -> point (a, b) is inside the circle\\n        // (x-a)^2 + (y-b)^2 > R^2 -> point (a, b) is outside the circle\\n        return Math.pow(u[0]-v[0], 2) + Math.pow(u[1]-v[1], 2) <= Math.pow(u[2], 2);\\n    }\\n    \\n    private int dfs(int node, Map<Integer, List<Integer>> graph, Set<Integer> visited){\\n        if(visited.contains(node)) return 0;\\n        visited.add(node);\\n        int res = 0;\\n        for(int neigh: graph.get(node)){\\n            res += dfs(neigh, graph, visited);\\n        }\\n        return res + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    /*\\n    Make directed graph\\n    u -> v means, v is in the range of u\\n    check from which node maximum nodes can be reached and return the number of nodes reached\\n    */\\n    public int maximumDetonation(int[][] bombs) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n    \\n        int n = bombs.length;\\n        for(int i = 0; i< n; i++){\\n            graph.put(i, new ArrayList<>());\\n            for(int j = 0; j< n; j++){\\n                if(i == j) continue;\\n                if(inRange(bombs[i], bombs[j]))\\n                    graph.get(i).add(j);\\n            }\\n        }\\n        \\n        int max = 0;\\n        for(int i = 0; i< n; i++){\\n            max = Math.max(max, dfs(i, graph, new HashSet<>()));\\n        }\\n        return max;\\n    }\\n    \\n    private boolean inRange(int[] u, int[] v){\\n        // (x-a)^2 + (y-b)^2 = R^2 -> point (a, b) is at border\\n        // (x-a)^2 + (y-b)^2 < R^2 -> point (a, b) is inside the circle\\n        // (x-a)^2 + (y-b)^2 > R^2 -> point (a, b) is outside the circle\\n        return Math.pow(u[0]-v[0], 2) + Math.pow(u[1]-v[1], 2) <= Math.pow(u[2], 2);\\n    }\\n    \\n    private int dfs(int node, Map<Integer, List<Integer>> graph, Set<Integer> visited){\\n        if(visited.contains(node)) return 0;\\n        visited.add(node);\\n        int res = 0;\\n        for(int neigh: graph.get(node)){\\n            res += dfs(neigh, graph, visited);\\n        }\\n        return res + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954294,
                "title": "java-with-comments-11ms-beats-100-dfs",
                "content": "graph is a adjacency list.\\n```\\nclass Solution {\\n    public int maximumDetonation(int[][] bombs) {\\n        int n = bombs.length;\\n        List<Integer>[] graph = new List[n];\\n        for (int i = 0; i < n; i++) graph[i] =  new ArrayList<Integer>();\\n\\t\\t// O(n^2 /2)  by using j = i+1\\n\\t\\t for (int i = 0; i < n; i++) {\\n            for (int j = i+1; j < n; j++) {\\n                // use double since multiplying large values like 10^5 will cause overflow\\n                double dx = bombs[i][0] - bombs[j][0];\\n                double dy = bombs[i][1] - bombs[j][1];\\n                double r1  = bombs[i][2], r2  = bombs[j][2];\\n                double dist =  dx * dx + dy * dy;\\n                if ( dist <= r1 * r1) graph[i].add(j);\\n                if ( dist <= r2 * r2) graph[j].add(i);\\n            }\\n            \\n        }\\n        boolean[] visited = new boolean[n];\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            ans = Math.max(ans, dfs(graph, i, visited));\\n            if (ans == n) return ans; //all of the nodes can be visited\\n            Arrays.fill(visited, false);\\n        }\\n        return ans;\\n    }\\n    private int dfs(List<Integer>[] graph, int i, boolean[] visited) {\\n        int cc = 0;\\n        if (visited[i]) return 0;\\n        visited[i] = true;\\n        for (int neigh: graph[i]) {\\n            cc += dfs(graph, neigh, visited);\\n        }\\n        return cc + 1;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumDetonation(int[][] bombs) {\\n        int n = bombs.length;\\n        List<Integer>[] graph = new List[n];\\n        for (int i = 0; i < n; i++) graph[i] =  new ArrayList<Integer>();\\n\\t\\t// O(n^2 /2)  by using j = i+1\\n\\t\\t for (int i = 0; i < n; i++) {\\n            for (int j = i+1; j < n; j++) {\\n                // use double since multiplying large values like 10^5 will cause overflow\\n                double dx = bombs[i][0] - bombs[j][0];\\n                double dy = bombs[i][1] - bombs[j][1];\\n                double r1  = bombs[i][2], r2  = bombs[j][2];\\n                double dist =  dx * dx + dy * dy;\\n                if ( dist <= r1 * r1) graph[i].add(j);\\n                if ( dist <= r2 * r2) graph[j].add(i);\\n            }\\n            \\n        }\\n        boolean[] visited = new boolean[n];\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            ans = Math.max(ans, dfs(graph, i, visited));\\n            if (ans == n) return ans; //all of the nodes can be visited\\n            Arrays.fill(visited, false);\\n        }\\n        return ans;\\n    }\\n    private int dfs(List<Integer>[] graph, int i, boolean[] visited) {\\n        int cc = 0;\\n        if (visited[i]) return 0;\\n        visited[i] = true;\\n        for (int neigh: graph[i]) {\\n            cc += dfs(graph, neigh, visited);\\n        }\\n        return cc + 1;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1870271,
                "title": "python-solution-that-you-want",
                "content": "```\\nclass Solution:\\n    def maximumDetonation(self, bombs: List[List[int]]) -> int:\\n        if len(bombs)==1:\\n            return 1\\n        \\n        adlist={i:[] for i in range(len(bombs))}\\n        \\n        for i in range(len(bombs)):\\n            x1,y1,r1=bombs[i]\\n            for j in range(i+1,len(bombs)):\\n                x2,y2,r2=bombs[j]\\n                dist=((x2-x1)**2+(y2-y1)**2)**(1/2)\\n                if dist<=r1:\\n                    adlist[i].append(j)  \\n                if dist<=r2:\\n                    adlist[j].append(i)\\n        \\n        def dfs(adlist,seen,start):\\n            seen.add(start)\\n            for i in adlist[start]:\\n                if i not in seen:\\n                    dfs(adlist,seen,i)\\n        maxx=1   \\n        for v in adlist:\\n            seen=set()\\n            seen.add(v)\\n            dfs(adlist,seen,v)\\n            maxx=max(maxx,len(seen))\\n        return maxx\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maximumDetonation(self, bombs: List[List[int]]) -> int:\\n        if len(bombs)==1:\\n            return 1\\n        \\n        adlist={i:[] for i in range(len(bombs))}\\n        \\n        for i in range(len(bombs)):\\n            x1,y1,r1=bombs[i]\\n            for j in range(i+1,len(bombs)):\\n                x2,y2,r2=bombs[j]\\n                dist=((x2-x1)**2+(y2-y1)**2)**(1/2)\\n                if dist<=r1:\\n                    adlist[i].append(j)  \\n                if dist<=r2:\\n                    adlist[j].append(i)\\n        \\n        def dfs(adlist,seen,start):\\n            seen.add(start)\\n            for i in adlist[start]:\\n                if i not in seen:\\n                    dfs(adlist,seen,i)\\n        maxx=1   \\n        for v in adlist:\\n            seen=set()\\n            seen.add(v)\\n            dfs(adlist,seen,v)\\n            maxx=max(maxx,len(seen))\\n        return maxx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1801080,
                "title": "c-easy-solution",
                "content": "\\tpublic class Solution\\n\\t{\\n\\t\\tpublic int MaximumDetonation(int[][] bombs)\\n\\t\\t{\\n\\t\\t\\tint max = 0;\\n\\t\\t\\tDictionary<int, List<int>> graph = new Dictionary<int, List<int>>();\\n\\n\\t\\t\\tfor (int i = 0; i < bombs.GetLength(0); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (!graph.ContainsKey(i))\\n\\t\\t\\t\\t\\tgraph[i] = new List<int>();\\n\\n\\t\\t\\t\\tfor (int j = i + 1; j < bombs.GetLength(0); j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (!graph.ContainsKey(j))\\n\\t\\t\\t\\t\\t\\tgraph[j] = new List<int>();\\n\\n\\t\\t\\t\\t\\tif (CheckIfCirclesIntersact(bombs[i][0], bombs[i][1], bombs[j][0], bombs[j][1], bombs[i][2]))\\n\\t\\t\\t\\t\\t\\tgraph[i].Add(j);\\n\\n\\t\\t\\t\\t\\tif (CheckIfCirclesIntersact(bombs[j][0], bombs[j][1], bombs[i][0], bombs[i][1], bombs[j][2]))\\n\\t\\t\\t\\t\\t\\tgraph[j].Add(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (int i = 0; i < bombs.GetLength(0); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tHashSet<int> set = new HashSet<int>() { i };\\n\\t\\t\\t\\tBFS(graph, i, set);\\n\\t\\t\\t\\tmax = Math.Max(max, set.Count);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn max;\\n\\t\\t}\\n\\n\\t\\tprivate void BFS(Dictionary<int, List<int>> graph, int idx, HashSet<int> set)\\n\\t\\t{\\n\\t\\t\\tQueue<int> queue = new Queue<int>();\\n\\n\\t\\t\\tqueue.Enqueue(idx);\\n\\n\\t\\t\\twhile (queue.Count > 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint node = queue.Dequeue();\\n\\n\\t\\t\\t\\tforeach (var n in graph[node])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (!set.Contains(n))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tqueue.Enqueue(n);\\n\\t\\t\\t\\t\\t\\tset.Add(n);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tprivate bool CheckIfCirclesIntersact(int x1, int y1, int x2, int y2, int r1)\\n\\t\\t{\\n\\t\\t\\tlong dx = x1 - x2;\\n\\t\\t\\tlong dy = y1 - y2;\\n\\t\\t\\tlong radius = r1;\\n\\n\\t\\t\\tlong distSq = (dx * dx) + (dy * dy);\\n\\t\\t\\tlong radSumSq = radius * radius;\\n\\n\\t\\t\\treturn distSq <= radSumSq;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "class Solution\\n\\t{\\n\\t\\tpublic int MaximumDetonation(int[][] bombs)\\n\\t\\t{\\n\\t\\t\\tint max = 0;\\n\\t\\t\\tDictionary<int, List<int>> graph = new Dictionary<int, List<int>>();\\n\\n\\t\\t\\tfor (int i = 0; i < bombs.GetLength(0); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (!graph.ContainsKey(i))\\n\\t\\t\\t\\t\\tgraph[i] = new List<int>();\\n\\n\\t\\t\\t\\tfor (int j = i + 1; j < bombs.GetLength(0); j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (!graph.ContainsKey(j))\\n\\t\\t\\t\\t\\t\\tgraph[j] = new List<int>();\\n\\n\\t\\t\\t\\t\\tif (CheckIfCirclesIntersact(bombs[i][0], bombs[i][1], bombs[j][0], bombs[j][1], bombs[i][2]))\\n\\t\\t\\t\\t\\t\\tgraph[i].Add(j);\\n\\n\\t\\t\\t\\t\\tif (CheckIfCirclesIntersact(bombs[j][0], bombs[j][1], bombs[i][0], bombs[i][1], bombs[j][2]))\\n\\t\\t\\t\\t\\t\\tgraph[j].Add(i);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1795131,
                "title": "java-dfs-with-memorization-faster-than-97",
                "content": "Basic idea is simmilar to highest voted posts, just optimized a little with caching.\\nHere I used a Set for marking visited for simplicity and it can also be reused later, since it contains info about all bombs that will explode if we start at bomb[i].\\n\\n````\\nclass Solution {\\n    public int maximumDetonation(int[][] bombs) {\\n        int n = bombs.length;\\n        int res = 0;\\n        Map<Integer, Set<Integer>> cache = new HashMap<>(); \\n        for (int i = 0; i < n; i++) {\\n            Set<Integer> exploded = new HashSet<>(); \\n            dfs(i, bombs, exploded, cache);\\n            cache.put(i, exploded);\\n            res = Math.max(res, exploded.size());\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private void dfs(int current, int[][] bombs, Set<Integer> visited, Map<Integer, Set<Integer>> cache) {\\n        if (cache.containsKey(current)) {\\n            visited.addAll(cache.get(current));\\n            return;\\n        }\\n        \\n        visited.add(current);\\n        int n = bombs.length;\\n        for (int i = 0; i < n; i++) {\\n            if (!visited.contains(i) && inRange(bombs[current], bombs[i])) {\\n                visited.add(i);\\n                dfs(i, bombs, visited, cache);\\n            }\\n        }\\n    }\\n        \\n    private boolean inRange(int[] a, int[] b) {\\n        long dx = a[0] - b[0], dy = a[1] - b[1], r = a[2];\\n        return dx * dx + dy * dy <= r * r;\\n    }\\n}\\n````",
                "solutionTags": [],
                "code": "````\\nclass Solution {\\n    public int maximumDetonation(int[][] bombs) {\\n        int n = bombs.length;\\n        int res = 0;\\n        Map<Integer, Set<Integer>> cache = new HashMap<>(); \\n        for (int i = 0; i < n; i++) {\\n            Set<Integer> exploded = new HashSet<>(); \\n            dfs(i, bombs, exploded, cache);\\n            cache.put(i, exploded);\\n            res = Math.max(res, exploded.size());\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private void dfs(int current, int[][] bombs, Set<Integer> visited, Map<Integer, Set<Integer>> cache) {\\n        if (cache.containsKey(current)) {\\n            visited.addAll(cache.get(current));\\n            return;\\n        }\\n        \\n        visited.add(current);\\n        int n = bombs.length;\\n        for (int i = 0; i < n; i++) {\\n            if (!visited.contains(i) && inRange(bombs[current], bombs[i])) {\\n                visited.add(i);\\n                dfs(i, bombs, visited, cache);\\n            }\\n        }\\n    }\\n        \\n    private boolean inRange(int[] a, int[] b) {\\n        long dx = a[0] - b[0], dy = a[1] - b[1], r = a[2];\\n        return dx * dx + dy * dy <= r * r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1634037,
                "title": "js-easy-to-understand-for-beginners-as-well-commented",
                "content": "1. Find all the neighbours of a particular bomb. Neighbours are those bombs which are present within the radius of another bomb.\\n2. The formula to find the dist between the 2 points(bombs)  is `\\u221A (x2 \\u2212 x1)2 + (y2 \\u2212 y1)2`. So we need to check if that dist. lies within the range of particular bomb. \\nie.`\\u221A (x2 \\u2212 x1)2 + (y2 \\u2212 y1)2 <= r(radius)`.If a bomb lies within radius of another bomb then they\\'re considered as neighbours.\\n3. After finding the neighbours and storing on hashmap, do a typical BFS and find out all the neighbours of neighbours and max among them.\\n```\\nvar maximumDetonation = function(bombs) {\\n\\n\\tconst neighbours = findNeighbours(bombs);\\n\\tlet max=0;\\n\\n\\tfor(let i=0;i<bombs.length;i++){\\n\\t\\tconst count=findMaxDetonations(i,neighbours)\\n\\t\\t/* if the count is bombs.length which means a bomb detonated can have impact on all the bombs present. \\n\\t\\tSo that would be max. So just return instead of proceeding to save time.*/\\n\\t\\tif(count===bombs.length)return count;\\n\\t\\tmax=Math.max(max,count)\\n\\t}\\n\\treturn max\\n\\n\\tfunction findNeighbours(b){\\n\\n\\t\\tconst map = new Map();\\n\\n\\t\\tfor(let i=0;i<b.length;i++){\\n\\t\\t\\tconst x1 = b[i][0]\\n\\t\\t\\tconst y1 = b[i][1]\\n\\t\\t\\tconst r = b[i][2]\\n\\t\\t\\tfor(let j=0;j<b.length;j++){\\n\\t\\t\\t\\t// i!==j to make sure we are not taking that bomb itself.\\n\\t\\t\\t\\tif(i!==j){\\n\\t\\t\\t\\t\\tconst x2=b[j][0];\\n\\t\\t\\t\\t\\tconst y2=b[j][1];\\n\\t\\t\\t\\t\\t// this is the formula mentioned on first point. But we do r*r instead of r because we are not taking the root.\\n\\t\\t\\t\\t\\t// It\\'ll work when used root as well.  Math.sqrt((x1-x2)**2 + (y1-y2)**2) <= r\\n\\t\\t\\t\\t\\tif((x1-x2)**2 + (y1-y2)**2 <= r*r){\\n\\t\\t\\t\\t\\t\\tif(map.has(i)){\\n\\t\\t\\t\\t\\t\\t\\tconst arr=map.get(i)\\n\\t\\t\\t\\t\\t\\t\\tarr.push(j)\\n\\t\\t\\t\\t\\t\\t\\tmap.set(i,arr)\\n\\t\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\t\\tmap.set(i,[j])    \\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// this map has all the neighbours to a particular bomb\\n\\t\\treturn map\\n\\t}\\n\\n\\tfunction findMaxDetonations(start,map){\\n\\t\\tconst visited = new Set();\\n\\t\\tconst q = []\\n\\t\\tq.push(start);\\n\\t\\tvisited.add(start)\\n\\t\\twhile(q.length){\\n\\t\\t\\tconst len=q.length\\n\\t\\t\\t\\tconst first=q.shift();\\n\\t\\t\\t\\t// Some bombs have no neighbours so make sure to check it before proceeding\\n\\t\\t\\t\\tif(map.has(first)){\\n\\t\\t\\t\\t\\tfor(let b of map.get(first)){\\n\\t\\t\\t\\t\\t\\tif(!visited.has(b)){\\n\\t\\t\\t\\t\\t\\t\\tvisited.add(b)\\n\\t\\t\\t\\t\\t\\t\\tq.push(b)\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}    \\n\\t\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// contains the neighbours visited\\n\\t\\treturn visited.size\\n\\t}\\n\\n};\\n```\\nRuntime: 100 ms, faster than 100.00% of JavaScript online submissions for Detonate the Maximum Bombs.\\nMemory Usage: 46.4 MB, less than 42.55% of JavaScript online submissions for Detonate the Maximum Bombs.",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar maximumDetonation = function(bombs) {\\n\\n\\tconst neighbours = findNeighbours(bombs);\\n\\tlet max=0;\\n\\n\\tfor(let i=0;i<bombs.length;i++){\\n\\t\\tconst count=findMaxDetonations(i,neighbours)\\n\\t\\t/* if the count is bombs.length which means a bomb detonated can have impact on all the bombs present. \\n\\t\\tSo that would be max. So just return instead of proceeding to save time.*/\\n\\t\\tif(count===bombs.length)return count;\\n\\t\\tmax=Math.max(max,count)\\n\\t}\\n\\treturn max\\n\\n\\tfunction findNeighbours(b){\\n\\n\\t\\tconst map = new Map();\\n\\n\\t\\tfor(let i=0;i<b.length;i++){\\n\\t\\t\\tconst x1 = b[i][0]\\n\\t\\t\\tconst y1 = b[i][1]\\n\\t\\t\\tconst r = b[i][2]\\n\\t\\t\\tfor(let j=0;j<b.length;j++){\\n\\t\\t\\t\\t// i!==j to make sure we are not taking that bomb itself.\\n\\t\\t\\t\\tif(i!==j){\\n\\t\\t\\t\\t\\tconst x2=b[j][0];\\n\\t\\t\\t\\t\\tconst y2=b[j][1];\\n\\t\\t\\t\\t\\t// this is the formula mentioned on first point. But we do r*r instead of r because we are not taking the root.\\n\\t\\t\\t\\t\\t// It\\'ll work when used root as well.  Math.sqrt((x1-x2)**2 + (y1-y2)**2) <= r\\n\\t\\t\\t\\t\\tif((x1-x2)**2 + (y1-y2)**2 <= r*r){\\n\\t\\t\\t\\t\\t\\tif(map.has(i)){\\n\\t\\t\\t\\t\\t\\t\\tconst arr=map.get(i)\\n\\t\\t\\t\\t\\t\\t\\tarr.push(j)\\n\\t\\t\\t\\t\\t\\t\\tmap.set(i,arr)\\n\\t\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\t\\tmap.set(i,[j])    \\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// this map has all the neighbours to a particular bomb\\n\\t\\treturn map\\n\\t}\\n\\n\\tfunction findMaxDetonations(start,map){\\n\\t\\tconst visited = new Set();\\n\\t\\tconst q = []\\n\\t\\tq.push(start);\\n\\t\\tvisited.add(start)\\n\\t\\twhile(q.length){\\n\\t\\t\\tconst len=q.length\\n\\t\\t\\t\\tconst first=q.shift();\\n\\t\\t\\t\\t// Some bombs have no neighbours so make sure to check it before proceeding\\n\\t\\t\\t\\tif(map.has(first)){\\n\\t\\t\\t\\t\\tfor(let b of map.get(first)){\\n\\t\\t\\t\\t\\t\\tif(!visited.has(b)){\\n\\t\\t\\t\\t\\t\\t\\tvisited.add(b)\\n\\t\\t\\t\\t\\t\\t\\tq.push(b)\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}    \\n\\t\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// contains the neighbours visited\\n\\t\\treturn visited.size\\n\\t}\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1626435,
                "title": "c-using-bfs-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) \\n    {\\n       \\n        int n = bombs.size();\\n         vector<vector<int>>adj(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            int x1 = bombs[i][0];\\n            int y1 = bombs[i][1];\\n            int r1 = bombs[i][2];\\n            for(int j=0;j<n;j++)\\n            {\\n                int x2 = bombs[j][0];\\n                int y2 = bombs[j][1];\\n                int r2 = bombs[j][2];\\n                long long int  xx = abs(x2-x1);\\n                long long int yy = abs(y2-y1);\\n                long long int rr =r1;  \\n                if((xx*xx + yy*yy) <= (rr*rr))\\n                {\\n                    adj[i].push_back(j);\\n                   \\n                }           \\n            }\\n        }\\n        queue<int>qq;\\n        int ans = 0;\\n      for(int i=0;i<n;i++)\\n      {\\n           vector<int>vis(n,0);\\n              int cc = 0;\\n              qq.push(i);\\n              while(qq.size()>0)\\n              {\\n                  auto it = qq.front();\\n                  qq.pop();   \\n                  cc++;\\n                  vis[it] = 1;\\n                  for(auto itt: adj[it])\\n                  {\\n                      if(vis[itt]==0)\\n                      {\\n                          qq.push(itt);\\n                          vis[itt] = 1;\\n                      }\\n                  } \\n              }\\n              ans = max(ans,cc);\\n      }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) \\n    {\\n       \\n        int n = bombs.size();\\n         vector<vector<int>>adj(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            int x1 = bombs[i][0];\\n            int y1 = bombs[i][1];\\n            int r1 = bombs[i][2];\\n            for(int j=0;j<n;j++)\\n            {\\n                int x2 = bombs[j][0];\\n                int y2 = bombs[j][1];\\n                int r2 = bombs[j][2];\\n                long long int  xx = abs(x2-x1);\\n                long long int yy = abs(y2-y1);\\n                long long int rr =r1;  \\n                if((xx*xx + yy*yy) <= (rr*rr))\\n                {\\n                    adj[i].push_back(j);\\n                   \\n                }           \\n            }\\n        }\\n        queue<int>qq;\\n        int ans = 0;\\n      for(int i=0;i<n;i++)\\n      {\\n           vector<int>vis(n,0);\\n              int cc = 0;\\n              qq.push(i);\\n              while(qq.size()>0)\\n              {\\n                  auto it = qq.front();\\n                  qq.pop();   \\n                  cc++;\\n                  vis[it] = 1;\\n                  for(auto itt: adj[it])\\n                  {\\n                      if(vis[itt]==0)\\n                      {\\n                          qq.push(itt);\\n                          vis[itt] = 1;\\n                      }\\n                  } \\n              }\\n              ans = max(ans,cc);\\n      }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623389,
                "title": "can-this-be-done-using-union-find-i-tried-but-got-wrong-answer",
                "content": "```\\nclass Solution {\\npublic:\\n    int dsfind(vector<int > &parent, int x)// with path compression\\n    {\\n        if(parent[x]==x)\\n        return x;\\n\\n        int res = dsfind(parent, parent[x]);\\n        parent[x] = res;\\n        return res;\\n    }\\n    void dsunion(vector<int > &parent, int x, int y)// with no improvement\\n    {\\n        int parentx = dsfind(parent, x);\\n        int parenty = dsfind(parent, y);\\n\\n        if(parentx==parenty)\\n        return;\\n        parent[parenty] = parentx; // or reverse\\n    }\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n = bombs.size();\\n        vector<int > parent(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            parent[i]=i;\\n        }\\n        for(int i=0;i<n-1;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                long long int x1 = (long long int)(bombs[i][0]-bombs[j][0])*(bombs[i][0]-bombs[j][0]);\\n                long long int x2 = (long long int)(bombs[i][1]-bombs[j][1])*(bombs[i][1]-bombs[j][1]);\\n                \\n                int dist = sqrt(x1+x2);\\n                if(dist<=bombs[i][2]+bombs[j][2])\\n                {\\n                    dsunion(parent,i,j);\\n                }\\n            }\\n        }\\n        map<int, int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[dsfind(parent,parent[i])]++;\\n        }\\n        int ans = INT_MIN;\\n        for(auto it:mp)\\n            ans=max(ans, it.second);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dsfind(vector<int > &parent, int x)// with path compression\\n    {\\n        if(parent[x]==x)\\n        return x;\\n\\n        int res = dsfind(parent, parent[x]);\\n        parent[x] = res;\\n        return res;\\n    }\\n    void dsunion(vector<int > &parent, int x, int y)// with no improvement\\n    {\\n        int parentx = dsfind(parent, x);\\n        int parenty = dsfind(parent, y);\\n\\n        if(parentx==parenty)\\n        return;\\n        parent[parenty] = parentx; // or reverse\\n    }\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n = bombs.size();\\n        vector<int > parent(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            parent[i]=i;\\n        }\\n        for(int i=0;i<n-1;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                long long int x1 = (long long int)(bombs[i][0]-bombs[j][0])*(bombs[i][0]-bombs[j][0]);\\n                long long int x2 = (long long int)(bombs[i][1]-bombs[j][1])*(bombs[i][1]-bombs[j][1]);\\n                \\n                int dist = sqrt(x1+x2);\\n                if(dist<=bombs[i][2]+bombs[j][2])\\n                {\\n                    dsunion(parent,i,j);\\n                }\\n            }\\n        }\\n        map<int, int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[dsfind(parent,parent[i])]++;\\n        }\\n        int ans = INT_MIN;\\n        for(auto it:mp)\\n            ans=max(ans, it.second);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623351,
                "title": "c-commented-dfs-solution-using-two-visited-array",
                "content": "```\\nclass Solution {\\npublic:\\n\\t// function to check if a point lies inside or on the circle\\n    bool isInside(long long cx, long long cy,long long r, long long x, long long y)\\n    {\\n    \\n        if ((x-cx)*(x-cx)+(y-cy)*(y-cy)<=pow(r,2))\\n            return true;\\n        else\\n            return false;\\n    }\\n    \\n\\t// dfs for checking if the point lies inside or on for every elt of array\\n    void dfs(vector<vector<int>>&b,int k,vector<int>&vis,vector<int>&vis1)\\n    {\\n        if(vis1[k]==1)\\n            return;\\n        \\n        vis1[k]=1;\\n        for(int i=0;i<b.size();i++)\\n        {\\n\\t\\t\\t// check for neighbouring bombs which gets detonated\\n            if(i!=k)\\n            if(isInside(b[k][0],b[k][1],b[k][2],b[i][0],b[i][1]))\\n            {\\n                if(vis1[i]!=1)\\n                dfs(b,i,vis,vis1);\\n            } \\n        }\\n        vis[k]=1;\\n    }\\n    int maximumDetonation(vector<vector<int>>& b) {\\n        \\n        // minimum ans is 1(atleast 1 bomb will detonate)\\n        int ans=1;\\n        \\n        \\n        for(int i=0;i<b.size();i++)\\n        {\\n            int s=1;\\n            vector<int>vis(b.size(),0),vis1(b.size(),0);\\n            //b[i]=1;\\n            vis[i]=1;\\n            \\n\\t\\t\\t//calling dfs\\n            dfs(b,i,vis,vis1);\\n                \\n            // if the the array vis is marked as 1 then the bomb is detonated\\n            for(auto it :vis)\\n                if(it==1)\\n                    s++;\\n            if(s>=ans)\\n            {\\n                ans=s;\\n            }\\n        }\\n        return ans-1;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t// function to check if a point lies inside or on the circle\\n    bool isInside(long long cx, long long cy,long long r, long long x, long long y)\\n    {\\n    \\n        if ((x-cx)*(x-cx)+(y-cy)*(y-cy)<=pow(r,2))\\n            return true;\\n        else\\n            return false;\\n    }\\n    \\n\\t// dfs for checking if the point lies inside or on for every elt of array\\n    void dfs(vector<vector<int>>&b,int k,vector<int>&vis,vector<int>&vis1)\\n    {\\n        if(vis1[k]==1)\\n            return;\\n        \\n        vis1[k]=1;\\n        for(int i=0;i<b.size();i++)\\n        {\\n\\t\\t\\t// check for neighbouring bombs which gets detonated\\n            if(i!=k)\\n            if(isInside(b[k][0],b[k][1],b[k][2],b[i][0],b[i][1]))\\n            {\\n                if(vis1[i]!=1)\\n                dfs(b,i,vis,vis1);\\n            } \\n        }\\n        vis[k]=1;\\n    }\\n    int maximumDetonation(vector<vector<int>>& b) {\\n        \\n        // minimum ans is 1(atleast 1 bomb will detonate)\\n        int ans=1;\\n        \\n        \\n        for(int i=0;i<b.size();i++)\\n        {\\n            int s=1;\\n            vector<int>vis(b.size(),0),vis1(b.size(),0);\\n            //b[i]=1;\\n            vis[i]=1;\\n            \\n\\t\\t\\t//calling dfs\\n            dfs(b,i,vis,vis1);\\n                \\n            // if the the array vis is marked as 1 then the bomb is detonated\\n            for(auto it :vis)\\n                if(it==1)\\n                    s++;\\n            if(s>=ans)\\n            {\\n                ans=s;\\n            }\\n        }\\n        return ans-1;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623343,
                "title": "python3-digraph",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/b553623546e2799477b8bca6b5c89f22c83a4d08) for solutions of weekly 67. \\n\\n```\\nclass Solution:\\n    def maximumDetonation(self, bombs: List[List[int]]) -> int:\\n        graph = [[] for _ in bombs]\\n        for i, (xi, yi, ri) in enumerate(bombs): \\n            for j, (xj, yj, rj) in enumerate(bombs): \\n                if i < j: \\n                    dist2 = (xi-xj)**2 + (yi-yj)**2\\n                    if dist2 <= ri**2: graph[i].append(j)\\n                    if dist2 <= rj**2: graph[j].append(i)\\n        \\n        def fn(x):\\n            \"\"\"Return connected components of x.\"\"\"\\n            ans = 1\\n            seen = {x}\\n            stack = [x]\\n            while stack: \\n                u = stack.pop()\\n                for v in graph[u]: \\n                    if v not in seen: \\n                        ans += 1\\n                        seen.add(v)\\n                        stack.append(v)\\n            return ans \\n        \\n        return max(fn(x) for x in range(len(bombs)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumDetonation(self, bombs: List[List[int]]) -> int:\\n        graph = [[] for _ in bombs]\\n        for i, (xi, yi, ri) in enumerate(bombs): \\n            for j, (xj, yj, rj) in enumerate(bombs): \\n                if i < j: \\n                    dist2 = (xi-xj)**2 + (yi-yj)**2\\n                    if dist2 <= ri**2: graph[i].append(j)\\n                    if dist2 <= rj**2: graph[j].append(i)\\n        \\n        def fn(x):\\n            \"\"\"Return connected components of x.\"\"\"\\n            ans = 1\\n            seen = {x}\\n            stack = [x]\\n            while stack: \\n                u = stack.pop()\\n                for v in graph[u]: \\n                    if v not in seen: \\n                        ans += 1\\n                        seen.add(v)\\n                        stack.append(v)\\n            return ans \\n        \\n        return max(fn(x) for x in range(len(bombs)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1623291,
                "title": "c-bfs",
                "content": "Step 1 : Create adjacency list for all bomb using the distance formula. \\nStep 2 : BFS from all nodes and maintain max value of bombs blasted. \\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // function to find if bomb \\'b\\' is in range of bomb \\'a\\'\\n    int insideRange(vector<int> a, vector<int> b)\\n    {\\n        long long x = abs((a[0]-b[0]));\\n        long long y = abs((a[1]-b[1]));\\n        long long r = a[2];\\n        long long dis = x*x + y*y;\\n        return  r*r >= dis ;\\n    }\\n    \\n    int bfs(int bid, int len, vector<vector<int>> adj)\\n    {\\n        int val = 1;\\n        vector<int> blasted(len, 0);\\n        queue<int> q;\\n        q.push(bid);\\n        blasted[bid]=1;\\n        int blastedTillNow = 1;\\n        while(!q.empty())\\n        {\\n            int f = q.front();\\n            q.pop();\\n            for(auto k : adj[f])\\n            {\\n                if(!blasted[k])\\n                {\\n                    q.push(k);\\n                    blasted[k]=1;\\n                    blastedTillNow++;\\n                    val = max(val, blastedTillNow);\\n                    \\n                    \\n                }\\n            }\\n        }\\n        return val;\\n    }\\n        \\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        \\n        //create adjacency list for all bombs\\n        vector<vector<int>> adj(bombs.size());\\n        for(int i=0; i<bombs.size(); i++)\\n        {\\n            for(int j=0; j<bombs.size(); j++)\\n            {\\n                if(i!=j)\\n                {\\n                    if(insideRange(bombs[i], bombs[j]))\\n                    {\\n                        adj[i].push_back(j);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        \\n        int ans = 0;\\n        // perform bfs considering every bomb as source , find the max ans\\n        for(int i=0; i<bombs.size(); i++)\\n        {\\n            int x = bfs(i, bombs.size(), adj);\\n            ans = max(ans, x);\\n        }\\n        \\n        return ans;\\n        \\n      \\n    }\\n};",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    // function to find if bomb \\'b\\' is in range of bomb \\'a\\'\\n    int insideRange(vector<int> a, vector<int> b)\\n    {\\n        long long x = abs((a[0]-b[0]));\\n        long long y = abs((a[1]-b[1]));\\n        long long r = a[2];\\n        long long dis = x*x + y*y;\\n        return  r*r >= dis ;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3690878,
                "title": "c-clean-code",
                "content": "```\\n/*\\n\\nImplicit Graph\\n    * node : Bombs represented by their centre coordinates and radius\\n    * neighbors/edges : If bombOne can detonate bombTwo there is an edge from bombOne to bombTwp (NOT neccesaarily other way around)\\n\\n    Return the size of the largest connected component.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int numMaxBombsDetonated = 0;\\n\\n        unordered_map<int, vector<int>> graph; // Adjacency List : {0 : [1, 2, 4], 1 : [0, 3, 6]}\\n        buildGraph(bombs, graph);\\n\\n        for(int node = 0 ; node < bombs.size() ; node++) {\\n            unordered_set<int> visited; // Directed Graph : One node can be part of multiple connected components. So use new visited every time.\\n            \\n            if(visited.find(node) != visited.end())\\n                continue;\\n\\n            int numOfCurrBombsDetonated = getSizeOfAndMarkConnectedComponentDFS(graph, node, visited); // Visit a node only once in a connected component.\\n\\n            numMaxBombsDetonated = max(numMaxBombsDetonated, numOfCurrBombsDetonated);\\n        }\\n\\n        return numMaxBombsDetonated;\\n    }\\n\\nprivate:\\n    float getDistBetween(int x_One, int y_One, int x_Two, int y_Two) {\\n        float distBetweenPoints = 0.0;\\n\\n        int x_diff_abs = abs(x_One - x_Two);\\n        int y_diff_abs = abs(y_One - y_Two);\\n\\n        float sumOfSquaresDist = pow( (x_diff_abs), 2) + pow( (y_diff_abs), 2);\\n\\n        distBetweenPoints = pow( (sumOfSquaresDist), 0.5);\\n\\n        return distBetweenPoints;\\n    }\\n\\n    bool doesEdgeExist(vector<int>& bombOne, vector<int>& bombTwo) {\\n        int x_Center_bombOne = bombOne[0];\\n        int y_Center_bombOne = bombOne[1];\\n        int radius_bombOne = bombOne[2];\\n\\n        int x_Center_bombTwo = bombTwo[0];\\n        int y_Center_bombTwo = bombTwo[1];\\n        int radius_bombTwo = bombTwo[2];\\n\\n        float dist_bombOne_bombTwo = getDistBetween(x_Center_bombOne, y_Center_bombOne, x_Center_bombTwo, y_Center_bombTwo);\\n\\n        if(dist_bombOne_bombTwo <= radius_bombOne)\\n            return true;\\n\\n        return false;\\n    }\\n\\n    void buildGraph(vector<vector<int>>& bombs, unordered_map<int, vector<int>>& graph) {\\n        // Initialize\\n        for(int node = 0 ; node < bombs.size() ; node++) {\\n            graph[node] = vector<int>();\\n        }\\n\\n        // Add the edges\\n        for(int index = 0 ; index < bombs.size() - 1 ; index++) {\\n            for(int subIndex = index + 1 ; subIndex < bombs.size() ; subIndex++) {\\n                \\n                vector<int> bombOne = bombs[index];\\n                vector<int> bombTwo = bombs[subIndex];\\n\\n                if(doesEdgeExist(bombOne, bombTwo))\\n                    graph[index].push_back(subIndex);\\n\\n                if(doesEdgeExist(bombTwo, bombOne)) // Don\\'t use else-if. We want to check for edges both ways not either ways.\\n                    graph[subIndex].push_back(index);\\n\\n            }\\n        }\\n\\n        return;\\n    }\\n\\n    int getSizeOfAndMarkConnectedComponentDFS(unordered_map<int, vector<int>>& graph, int currNode, unordered_set<int>& visited) {\\n        // Base Case(s)\\n        if(visited.find(currNode) != visited.end())\\n            return 0;\\n\\n        // Process Node\\n        int sizeOfConnectedComponentFromCurr = 1;\\n        visited.insert(currNode);\\n\\n        // Recurse on Neighbors\\n        vector<int> neighborNodes = graph[currNode];\\n\\n        for(auto neighborNode : neighborNodes) {\\n            int sizeOfConnectedComponentFromNeighbor = getSizeOfAndMarkConnectedComponentDFS(graph, neighborNode, visited);\\n\\n            sizeOfConnectedComponentFromCurr += sizeOfConnectedComponentFromNeighbor;\\n        }\\n\\n        return sizeOfConnectedComponentFromCurr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n\\nImplicit Graph\\n    * node : Bombs represented by their centre coordinates and radius\\n    * neighbors/edges : If bombOne can detonate bombTwo there is an edge from bombOne to bombTwp (NOT neccesaarily other way around)\\n\\n    Return the size of the largest connected component.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int numMaxBombsDetonated = 0;\\n\\n        unordered_map<int, vector<int>> graph; // Adjacency List : {0 : [1, 2, 4], 1 : [0, 3, 6]}\\n        buildGraph(bombs, graph);\\n\\n        for(int node = 0 ; node < bombs.size() ; node++) {\\n            unordered_set<int> visited; // Directed Graph : One node can be part of multiple connected components. So use new visited every time.\\n            \\n            if(visited.find(node) != visited.end())\\n                continue;\\n\\n            int numOfCurrBombsDetonated = getSizeOfAndMarkConnectedComponentDFS(graph, node, visited); // Visit a node only once in a connected component.\\n\\n            numMaxBombsDetonated = max(numMaxBombsDetonated, numOfCurrBombsDetonated);\\n        }\\n\\n        return numMaxBombsDetonated;\\n    }\\n\\nprivate:\\n    float getDistBetween(int x_One, int y_One, int x_Two, int y_Two) {\\n        float distBetweenPoints = 0.0;\\n\\n        int x_diff_abs = abs(x_One - x_Two);\\n        int y_diff_abs = abs(y_One - y_Two);\\n\\n        float sumOfSquaresDist = pow( (x_diff_abs), 2) + pow( (y_diff_abs), 2);\\n\\n        distBetweenPoints = pow( (sumOfSquaresDist), 0.5);\\n\\n        return distBetweenPoints;\\n    }\\n\\n    bool doesEdgeExist(vector<int>& bombOne, vector<int>& bombTwo) {\\n        int x_Center_bombOne = bombOne[0];\\n        int y_Center_bombOne = bombOne[1];\\n        int radius_bombOne = bombOne[2];\\n\\n        int x_Center_bombTwo = bombTwo[0];\\n        int y_Center_bombTwo = bombTwo[1];\\n        int radius_bombTwo = bombTwo[2];\\n\\n        float dist_bombOne_bombTwo = getDistBetween(x_Center_bombOne, y_Center_bombOne, x_Center_bombTwo, y_Center_bombTwo);\\n\\n        if(dist_bombOne_bombTwo <= radius_bombOne)\\n            return true;\\n\\n        return false;\\n    }\\n\\n    void buildGraph(vector<vector<int>>& bombs, unordered_map<int, vector<int>>& graph) {\\n        // Initialize\\n        for(int node = 0 ; node < bombs.size() ; node++) {\\n            graph[node] = vector<int>();\\n        }\\n\\n        // Add the edges\\n        for(int index = 0 ; index < bombs.size() - 1 ; index++) {\\n            for(int subIndex = index + 1 ; subIndex < bombs.size() ; subIndex++) {\\n                \\n                vector<int> bombOne = bombs[index];\\n                vector<int> bombTwo = bombs[subIndex];\\n\\n                if(doesEdgeExist(bombOne, bombTwo))\\n                    graph[index].push_back(subIndex);\\n\\n                if(doesEdgeExist(bombTwo, bombOne)) // Don\\'t use else-if. We want to check for edges both ways not either ways.\\n                    graph[subIndex].push_back(index);\\n\\n            }\\n        }\\n\\n        return;\\n    }\\n\\n    int getSizeOfAndMarkConnectedComponentDFS(unordered_map<int, vector<int>>& graph, int currNode, unordered_set<int>& visited) {\\n        // Base Case(s)\\n        if(visited.find(currNode) != visited.end())\\n            return 0;\\n\\n        // Process Node\\n        int sizeOfConnectedComponentFromCurr = 1;\\n        visited.insert(currNode);\\n\\n        // Recurse on Neighbors\\n        vector<int> neighborNodes = graph[currNode];\\n\\n        for(auto neighborNode : neighborNodes) {\\n            int sizeOfConnectedComponentFromNeighbor = getSizeOfAndMarkConnectedComponentDFS(graph, neighborNode, visited);\\n\\n            sizeOfConnectedComponentFromCurr += sizeOfConnectedComponentFromNeighbor;\\n        }\\n\\n        return sizeOfConnectedComponentFromCurr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3593081,
                "title": "easy-c-solution-dfs",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int dfs(int node, vector<int> adj[], vector<int> &vis)\\n    {\\n        int cnt=1;\\n        vis[node]=1;\\n        for(auto it: adj[node])\\n        {\\n            if(!vis[it])\\n            {\\n                cnt+=dfs(it,adj,vis);\\n            }\\n        }\\n        return cnt;\\n    }\\n    int maximumDetonation(vector<vector<int>>& bombs) \\n    {\\n        int n=bombs.size();\\n        vector<int> adj[n];\\n        for(int x=0; x<n; x++)\\n        {\\n            for(int y=0; y<n; y++)\\n            {\\n                long long dist=pow((bombs[x][0]-bombs[y][0]),2)+pow((bombs[x][1]-bombs[y][1]),2);\\n                if(dist<=(long long)bombs[x][2]*bombs[x][2]) adj[x].push_back(y);\\n                if(dist<=(long long)bombs[y][2]*bombs[y][2]) adj[y].push_back(x);\\n            }\\n        }\\n        int ans=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            vector<int> vis(n,0);\\n            ans=max(ans,dfs(x,adj,vis));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int dfs(int node, vector<int> adj[], vector<int> &vis)\\n    {\\n        int cnt=1;\\n        vis[node]=1;\\n        for(auto it: adj[node])\\n        {\\n            if(!vis[it])\\n            {\\n                cnt+=dfs(it,adj,vis);\\n            }\\n        }\\n        return cnt;\\n    }\\n    int maximumDetonation(vector<vector<int>>& bombs) \\n    {\\n        int n=bombs.size();\\n        vector<int> adj[n];\\n        for(int x=0; x<n; x++)\\n        {\\n            for(int y=0; y<n; y++)\\n            {\\n                long long dist=pow((bombs[x][0]-bombs[y][0]),2)+pow((bombs[x][1]-bombs[y][1]),2);\\n                if(dist<=(long long)bombs[x][2]*bombs[x][2]) adj[x].push_back(y);\\n                if(dist<=(long long)bombs[y][2]*bombs[y][2]) adj[y].push_back(x);\\n            }\\n        }\\n        int ans=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            vector<int> vis(n,0);\\n            ans=max(ans,dfs(x,adj,vis));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591292,
                "title": "c-dfs-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\ndirected graph && DFS\\n\\n# Complexity\\n- Time complexity:\\nO(n^3)\\n\\n- Space complexity:\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void  dfs(int u,vector<vector<int>>&adj,vector<bool>&vis){\\n      vis[u]=1;\\n        for(auto x:adj[u]){\\n           if(vis[x]==0)\\n             dfs(x,adj,vis);\\n            }\\n        \\n        return ;\\n    }\\n    long long distSq(int x1,int y1,int x2,int y2){\\n        long long t= abs(x1-x2);\\n        long long u= abs(y1-y2);\\n        return ((t*t)+(u*u));\\n        }\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n=bombs.size();\\n\\n        vector<vector<int>>adj(n);\\n        for(auto i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                int r1=bombs[i][2];\\n                int r2=bombs[j][2];\\n                long long distance=distSq(bombs[i][0],bombs[i][1],bombs[j][0],bombs[j][1]);\\n                if(distance<=(long long)r2*(long long)r2){\\n                    adj[j].push_back(i);\\n\\n                }\\n                 if(distance<=(long long)r1*(long long)r1){\\n                    adj[i].push_back(j);\\n                    \\n                }\\n            }\\n        }\\n\\n        int res=1;\\n        for(int i=0;i<n;i++){\\n            vector<bool>vis(n,0);\\n           (dfs(i,adj,vis));\\n           int count=0;\\n           for(auto x: vis)\\n           count+=x;\\n           res=max(res,count);\\n\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void  dfs(int u,vector<vector<int>>&adj,vector<bool>&vis){\\n      vis[u]=1;\\n        for(auto x:adj[u]){\\n           if(vis[x]==0)\\n             dfs(x,adj,vis);\\n            }\\n        \\n        return ;\\n    }\\n    long long distSq(int x1,int y1,int x2,int y2){\\n        long long t= abs(x1-x2);\\n        long long u= abs(y1-y2);\\n        return ((t*t)+(u*u));\\n        }\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n=bombs.size();\\n\\n        vector<vector<int>>adj(n);\\n        for(auto i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                int r1=bombs[i][2];\\n                int r2=bombs[j][2];\\n                long long distance=distSq(bombs[i][0],bombs[i][1],bombs[j][0],bombs[j][1]);\\n                if(distance<=(long long)r2*(long long)r2){\\n                    adj[j].push_back(i);\\n\\n                }\\n                 if(distance<=(long long)r1*(long long)r1){\\n                    adj[i].push_back(j);\\n                    \\n                }\\n            }\\n        }\\n\\n        int res=1;\\n        for(int i=0;i<n;i++){\\n            vector<bool>vis(n,0);\\n           (dfs(i,adj,vis));\\n           int count=0;\\n           for(auto x: vis)\\n           count+=x;\\n           res=max(res,count);\\n\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591097,
                "title": "c-bfs-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int fodega(vector<int> &v1,vector<int> &v2){\\n        long long a=v1[0]-v2[0];\\n        long long b=v1[1]-v2[1];\\n        if((a*a)+(b*b) <= pow((v1[2]),2)) {\\n  return 1;\\n        }\\n        return 0;\\n    }\\n\\n    int bfs(int point, vector<vector<int>> &adj,unordered_map<int,bool> vis) {\\n        int count=0;\\n        queue<int> q;\\n      q.push(point);\\n      vis[point]=1;\\n\\n      while(!q.empty()){\\n          int t=q.front();\\n           q.pop(); count++;\\n\\n          for(auto &i:adj[t]){\\n              if(!vis[i]){\\n                q.push(i);\\n                vis[i]=1;\\n              } \\n          }\\n      }\\n        return count;\\n    }\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int ans=0;int n=bombs.size();\\n        unordered_map<int ,bool> vis;\\n        vector<vector<int>> adj;\\n\\n        //prepare adjacency list\\n\\n        for(int i=0;i<bombs.size();i++){\\n            vector<int>temp;\\n            for(int j=0;j<n ;j++){\\n                if(fodega(bombs[i],bombs[j])==1 && j!=i) {\\n                temp.push_back(j);\\n                }\\n            }\\n        adj.push_back(temp);\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                ans=max(ans, bfs(i,adj,vis));\\n            }\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fodega(vector<int> &v1,vector<int> &v2){\\n        long long a=v1[0]-v2[0];\\n        long long b=v1[1]-v2[1];\\n        if((a*a)+(b*b) <= pow((v1[2]),2)) {\\n  return 1;\\n        }\\n        return 0;\\n    }\\n\\n    int bfs(int point, vector<vector<int>> &adj,unordered_map<int,bool> vis) {\\n        int count=0;\\n        queue<int> q;\\n      q.push(point);\\n      vis[point]=1;\\n\\n      while(!q.empty()){\\n          int t=q.front();\\n           q.pop(); count++;\\n\\n          for(auto &i:adj[t]){\\n              if(!vis[i]){\\n                q.push(i);\\n                vis[i]=1;\\n              } \\n          }\\n      }\\n        return count;\\n    }\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int ans=0;int n=bombs.size();\\n        unordered_map<int ,bool> vis;\\n        vector<vector<int>> adj;\\n\\n        //prepare adjacency list\\n\\n        for(int i=0;i<bombs.size();i++){\\n            vector<int>temp;\\n            for(int j=0;j<n ;j++){\\n                if(fodega(bombs[i],bombs[j])==1 && j!=i) {\\n                temp.push_back(j);\\n                }\\n            }\\n        adj.push_back(temp);\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                ans=max(ans, bfs(i,adj,vis));\\n            }\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590790,
                "title": "c-dfs-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> adj[101];\\n    vector<bool> vis;\\n    int ans=0;\\n    void dfs(int i) {\\n        vis[i]=1;\\n        for(auto x:adj[i]) {\\n            if(!vis[x]) {\\n                dfs(x);\\n            }\\n        }\\n    }\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n=bombs.size();\\n        for(int i=0;i<n;i++) {\\n            for(int j=i+1;j<n;j++) {\\n                long long x1=bombs[i][0],x2=bombs[j][0],y1=bombs[i][1],y2=bombs[j][1];\\n                long long z1=1LL*bombs[i][2]*bombs[i][2], z2=1LL*bombs[j][2]*bombs[j][2];\\n                long long d=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\\n                if(d<=z1) \\n                    adj[i].push_back(j);\\n                if(d<=z2) \\n                    adj[j].push_back(i);\\n            }\\n        }\\n        int cnt=1,ans=0;\\n        for(int i=0;i<n;i++) {  \\n            vis.clear();\\n            vis.resize(n,0);   \\n            dfs(i); int cur=0;\\n            for(auto x:vis) if(x) cur++;\\n            ans=max(ans,cur);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> adj[101];\\n    vector<bool> vis;\\n    int ans=0;\\n    void dfs(int i) {\\n        vis[i]=1;\\n        for(auto x:adj[i]) {\\n            if(!vis[x]) {\\n                dfs(x);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3590750,
                "title": "c-super-cool-dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void dfs(int node, unordered_set<int>& vis, vector<int> adj[]){\\n        vis.insert(node);\\n        for(int child : adj[node]){\\n            if(vis.find(child) == vis.end()){\\n                dfs(child,vis,adj);\\n            }\\n        }\\n    }\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n = bombs.size();\\n        vector<int> adj[n];\\n        for(int i=0; i<n; i++){\\n            long long x1 = bombs[i][0];\\n            long long y1 = bombs[i][1];\\n            long long r1 = bombs[i][2];\\n\\n            for(int j=i+1; j<n; j++){\\n                long long x2 = bombs[j][0];\\n                long long y2 = bombs[j][1];\\n                long long r2 = bombs[j][2];\\n\\n                long long d = (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1);\\n                bool dist1 = d <= r1*r1;\\n                bool dist2 = d <= r2*r2;\\n\\n                if(dist1){\\n                    adj[i].push_back(j);\\n                }\\n                if(dist2){\\n                    adj[j].push_back(i);\\n                }\\n\\n            }\\n        }\\n        int maxi = 0;\\n        for(int i=0; i<n; i++){\\n            unordered_set<int> vis;\\n            dfs(i,vis,adj);\\n            maxi = max(maxi,(int)vis.size());\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Depth-First Search",
                    "Graph",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void dfs(int node, unordered_set<int>& vis, vector<int> adj[]){\\n        vis.insert(node);\\n        for(int child : adj[node]){\\n            if(vis.find(child) == vis.end()){\\n                dfs(child,vis,adj);\\n            }\\n        }\\n    }\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n = bombs.size();\\n        vector<int> adj[n];\\n        for(int i=0; i<n; i++){\\n            long long x1 = bombs[i][0];\\n            long long y1 = bombs[i][1];\\n            long long r1 = bombs[i][2];\\n\\n            for(int j=i+1; j<n; j++){\\n                long long x2 = bombs[j][0];\\n                long long y2 = bombs[j][1];\\n                long long r2 = bombs[j][2];\\n\\n                long long d = (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1);\\n                bool dist1 = d <= r1*r1;\\n                bool dist2 = d <= r2*r2;\\n\\n                if(dist1){\\n                    adj[i].push_back(j);\\n                }\\n                if(dist2){\\n                    adj[j].push_back(i);\\n                }\\n\\n            }\\n        }\\n        int maxi = 0;\\n        for(int i=0; i<n; i++){\\n            unordered_set<int> vis;\\n            dfs(i,vis,adj);\\n            maxi = max(maxi,(int)vis.size());\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590616,
                "title": "dfs-distance-should-be-radius-to-form-an-directed-edge",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    \\n    void dfs(int s,vector<bool> &vis, long long int &ans,vector<vector<int>> &g)\\n    {\\n        if(vis[s])\\n            return ;\\n        ans++;\\n        vis[s] = 1;\\n        for(int i=0;i<g[s].size();i++)\\n        {\\n            int val = g[s][i];\\n        \\n            if(!vis[val])\\n                dfs(val,vis,ans,g);\\n        }\\n    }\\n    \\n    \\n    int maximumDetonation(vector<vector<int>>& b) {\\n        \\n        int n = b.size();\\n        \\n        vector<vector<int>>g(105);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j = i+1;j<n;j++)\\n            {\\n                long long int x1 = b[i][0];\\n                long long int y1 = b[i][1];\\n                long long int r1 = b[i][2];\\n                \\n                long long int x2 = b[j][0];\\n                long long int y2 = b[j][1];\\n                long long int r2 = b[j][2];\\n                \\n                long long int d = ceil(sqrt(pow((x1-x2),2) + pow((y1-y2),2)));\\n                \\n                if(d<=r1)\\n                {\\n                    g[i].push_back(j);\\n                }\\n                \\n                if(d<=r2)\\n                {\\n                    g[j].push_back(i);\\n                }\\n                \\n            }\\n        }\\n        \\n        \\n        long long int res = 0,ans = 0;\\n        \\n        for(int i=0;i<=n;i++)\\n        {\\n            vector<bool> vis(n,false);\\n            // cout<<i<<\" \"<<endl;\\n            \\n            dfs(i,vis,ans,g);\\n            res = max(res,ans);\\n            ans = 0;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    \\n    void dfs(int s,vector<bool> &vis, long long int &ans,vector<vector<int>> &g)\\n    {\\n        if(vis[s])\\n            return ;\\n        ans++;\\n        vis[s] = 1;\\n        for(int i=0;i<g[s].size();i++)\\n        {\\n            int val = g[s][i];\\n        \\n            if(!vis[val])\\n                dfs(val,vis,ans,g);\\n        }\\n    }\\n    \\n    \\n    int maximumDetonation(vector<vector<int>>& b) {\\n        \\n        int n = b.size();\\n        \\n        vector<vector<int>>g(105);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j = i+1;j<n;j++)\\n            {\\n                long long int x1 = b[i][0];\\n                long long int y1 = b[i][1];\\n                long long int r1 = b[i][2];\\n                \\n                long long int x2 = b[j][0];\\n                long long int y2 = b[j][1];\\n                long long int r2 = b[j][2];\\n                \\n                long long int d = ceil(sqrt(pow((x1-x2),2) + pow((y1-y2),2)));\\n                \\n                if(d<=r1)\\n                {\\n                    g[i].push_back(j);\\n                }\\n                \\n                if(d<=r2)\\n                {\\n                    g[j].push_back(i);\\n                }\\n                \\n            }\\n        }\\n        \\n        \\n        long long int res = 0,ans = 0;\\n        \\n        for(int i=0;i<=n;i++)\\n        {\\n            vector<bool> vis(n,false);\\n            // cout<<i<<\" \"<<endl;\\n            \\n            dfs(i,vis,ans,g);\\n            res = max(res,ans);\\n            ans = 0;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3590465,
                "title": "detonate-the-maximum-bombs-100-fastest-dfs",
                "content": "# Intuition\\nWe have to find the maximum bombs we can detonate by defusing one bomb.\\n\\n# Approach\\nWe made a directed graph and found the maximum connected components in a graph.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n^2)$$\\n\\n# Code\\n```\\nclass Solution {\\n    int answer= 0;\\n    int ctr=0;\\npublic:\\n    bool check(int x,int y,int r){\\n        long long int value = (long long int)x*x + (long long int)y*y - (long long int)r*r;\\n        if(value<=0)\\n            return true;\\n        return false;\\n    }\\n\\n    void dfs(vector<vector<int>>&adjList, vector<bool>&vis,vector<bool>&cyclic,int node){\\n        vis[node] = true;\\n        cyclic[node] = true;\\n        ctr++;\\n        if(adjList[node].size()==0){\\n            return;\\n        }\\n        for(int i=0; i<adjList[node].size(); i++){\\n            if(!cyclic[adjList[node][i]])\\n            {\\n                dfs(adjList, vis, cyclic, adjList[node][i]);\\n            }\\n\\n        }\\n        \\n    }\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n = bombs.size();\\n        vector<vector<int>>adjList(n);\\n        for(int i=0; i<n-1; i++){\\n            for(int j=i+1; j<n; j++){\\n                if(check(bombs[j][0]-bombs[i][0],bombs[j][1]-bombs[i][1],bombs[i][2])){\\n                    adjList[i].push_back(j);\\n                }\\n                if(check(bombs[j][0]-bombs[i][0],bombs[j][1]-bombs[i][1],bombs[j][2])){\\n                    adjList[j].push_back(i);\\n                }\\n            }\\n        }\\n\\n        vector<bool>vis(n,false);\\n        for(int i=0; i<n; i++){\\n            vector<bool>cyclic(n,false);\\n            if(!vis[i]){\\n                dfs(adjList, vis,cyclic, i);\\n                 answer = max(answer, ctr);\\n                ctr=0;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```\\n**please upvote if you like the solution**",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    int answer= 0;\\n    int ctr=0;\\npublic:\\n    bool check(int x,int y,int r){\\n        long long int value = (long long int)x*x + (long long int)y*y - (long long int)r*r;\\n        if(value<=0)\\n            return true;\\n        return false;\\n    }\\n\\n    void dfs(vector<vector<int>>&adjList, vector<bool>&vis,vector<bool>&cyclic,int node){\\n        vis[node] = true;\\n        cyclic[node] = true;\\n        ctr++;\\n        if(adjList[node].size()==0){\\n            return;\\n        }\\n        for(int i=0; i<adjList[node].size(); i++){\\n            if(!cyclic[adjList[node][i]])\\n            {\\n                dfs(adjList, vis, cyclic, adjList[node][i]);\\n            }\\n\\n        }\\n        \\n    }\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n = bombs.size();\\n        vector<vector<int>>adjList(n);\\n        for(int i=0; i<n-1; i++){\\n            for(int j=i+1; j<n; j++){\\n                if(check(bombs[j][0]-bombs[i][0],bombs[j][1]-bombs[i][1],bombs[i][2])){\\n                    adjList[i].push_back(j);\\n                }\\n                if(check(bombs[j][0]-bombs[i][0],bombs[j][1]-bombs[i][1],bombs[j][2])){\\n                    adjList[j].push_back(i);\\n                }\\n            }\\n        }\\n\\n        vector<bool>vis(n,false);\\n        for(int i=0; i<n; i++){\\n            vector<bool>cyclic(n,false);\\n            if(!vis[i]){\\n                dfs(adjList, vis,cyclic, i);\\n                 answer = max(answer, ctr);\\n                ctr=0;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590348,
                "title": "easy-to-understand-with-video-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have a radius/range for each bomb and every bomb in that radius will explode that will start a chain reaction. This implies that we need to constuct a graph where adjecent nodes will be the bomb index in the range.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe\\'ll construct a graph whose adj nodes will denote the coordinates of bomb which will explode if Ith bomb exploded.\\nNow we\\'ll run a DFS on the graph we constructed and calculate the longest chain we have.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2) + O(n^2)--> to construct the graph and run dfs for every node.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2) --> as we are constructing graph.\\n\\n# Video Link : \\nhttps://www.youtube.com/watch?v=jqzel5CawPA\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& graph, int start,vector<bool>& vis,int& len){\\n        if(vis[start]) return;\\n        vis[start] = true;\\n        len++;\\n        for(int node:graph[start]){\\n            if(!vis[node]) dfs(graph,node,vis,len);\\n        }\\n\\n    }\\n    bool isBombInRange(int x1,int y1,int x2,int y2,int radius){\\n        float dist = sqrt(pow(x1-x2,2)+pow(y1-y2,2));\\n        return ceil(dist)<=radius;\\n    }\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        vector<vector<int>> graph(bombs.size());\\n        for(int i=0;i<bombs.size();i++){\\n            for(int j=i+1;j<bombs.size();j++){\\n                // if(i!=j){\\n                    int x1 = bombs[i][0];\\n                    int y1 = bombs[i][1];\\n                    int radius1 = bombs[i][2];\\n                    int x2 = bombs[j][0];\\n                    int y2 = bombs[j][1];\\n                    int radius2 = bombs[j][2];\\n                    if(isBombInRange(x1,y1,x2,y2,radius1)){\\n                        graph[i].push_back(j);\\n                    }\\n                    if(isBombInRange(x1,y1,x2,y2,radius2)) graph[j].push_back(i);\\n                // }\\n            }\\n        }\\n\\n        // printGraph(graph);\\n\\n        \\n        int ans = 0;\\n        for(int i=0;i<bombs.size();i++){\\n            // if(!vis[i]){\\n                vector<bool> vis(bombs.size(),false);\\n                int temp = 0;\\n                dfs(graph,i,vis,temp);\\n                ans = max(ans,temp);\\n            // }\\n        }\\n        return ans;\\n    }\\n\\n    void printGraph(vector<vector<int>>& graph){\\n        for(int i=0;i<graph.size();i++){\\n            for(int node:graph[i]) cout<<node<<\" \";\\n            cout<<endl;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Depth-First Search",
                    "Graph",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& graph, int start,vector<bool>& vis,int& len){\\n        if(vis[start]) return;\\n        vis[start] = true;\\n        len++;\\n        for(int node:graph[start]){\\n            if(!vis[node]) dfs(graph,node,vis,len);\\n        }\\n\\n    }\\n    bool isBombInRange(int x1,int y1,int x2,int y2,int radius){\\n        float dist = sqrt(pow(x1-x2,2)+pow(y1-y2,2));\\n        return ceil(dist)<=radius;\\n    }\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        vector<vector<int>> graph(bombs.size());\\n        for(int i=0;i<bombs.size();i++){\\n            for(int j=i+1;j<bombs.size();j++){\\n                // if(i!=j){\\n                    int x1 = bombs[i][0];\\n                    int y1 = bombs[i][1];\\n                    int radius1 = bombs[i][2];\\n                    int x2 = bombs[j][0];\\n                    int y2 = bombs[j][1];\\n                    int radius2 = bombs[j][2];\\n                    if(isBombInRange(x1,y1,x2,y2,radius1)){\\n                        graph[i].push_back(j);\\n                    }\\n                    if(isBombInRange(x1,y1,x2,y2,radius2)) graph[j].push_back(i);\\n                // }\\n            }\\n        }\\n\\n        // printGraph(graph);\\n\\n        \\n        int ans = 0;\\n        for(int i=0;i<bombs.size();i++){\\n            // if(!vis[i]){\\n                vector<bool> vis(bombs.size(),false);\\n                int temp = 0;\\n                dfs(graph,i,vis,temp);\\n                ans = max(ans,temp);\\n            // }\\n        }\\n        return ans;\\n    }\\n\\n    void printGraph(vector<vector<int>>& graph){\\n        for(int i=0;i<graph.size();i++){\\n            for(int node:graph[i]) cout<<node<<\" \";\\n            cout<<endl;\\n        }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3589949,
                "title": "java-bfs-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maximumDetonation(int[][] bombs) {\\n        Arrays.sort(bombs, (o1, o2) -> o2[2] - o1[2]);\\n        int res = 0;\\n        for (int i = 0; i < bombs.length; i++) {\\n            int[][] copy = Arrays.copyOf(bombs, bombs.length);\\n            int count = 1;\\n            Queue<int[]> queue = new LinkedList<>();\\n            queue.offer(copy[i]);\\n            copy[i] = null;\\n            while (!queue.isEmpty()) {\\n                int[] arr = queue.poll();\\n                int y = arr[1], x = arr[0], r = arr[2];\\n                for (int j = 0; j < copy.length; j++) {\\n                    int[] b = copy[j];\\n                    if (b == null) continue;\\n                    int y1 = b[1], x1 = b[0], r1 = b[2];\\n                    double dist = Math.sqrt(Math.pow(y - y1, 2) + Math.pow(x - x1, 2));\\n                    if (dist <= r) {\\n                        count++;\\n                        queue.offer(b);\\n                        copy[j] = null;\\n                    }\\n                }\\n            }\\n            res = Math.max(count, res);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumDetonation(int[][] bombs) {\\n        Arrays.sort(bombs, (o1, o2) -> o2[2] - o1[2]);\\n        int res = 0;\\n        for (int i = 0; i < bombs.length; i++) {\\n            int[][] copy = Arrays.copyOf(bombs, bombs.length);\\n            int count = 1;\\n            Queue<int[]> queue = new LinkedList<>();\\n            queue.offer(copy[i]);\\n            copy[i] = null;\\n            while (!queue.isEmpty()) {\\n                int[] arr = queue.poll();\\n                int y = arr[1], x = arr[0], r = arr[2];\\n                for (int j = 0; j < copy.length; j++) {\\n                    int[] b = copy[j];\\n                    if (b == null) continue;\\n                    int y1 = b[1], x1 = b[0], r1 = b[2];\\n                    double dist = Math.sqrt(Math.pow(y - y1, 2) + Math.pow(x - x1, 2));\\n                    if (dist <= r) {\\n                        count++;\\n                        queue.offer(b);\\n                        copy[j] = null;\\n                    }\\n                }\\n            }\\n            res = Math.max(count, res);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589789,
                "title": "python3-easy-solution",
                "content": "# Code\\n```\\nfrom typing import List\\nimport collections\\n\\nclass Solution:\\n    def maximumDetonation(self, bombs: List[List[int]]) -> int:\\n        n2nxt = collections.defaultdict(set)\\n        lb = len(bombs)\\n\\n        for i in range(lb):  # i is the source\\n            xi, yi, ri = bombs[i]\\n\\n            for j in range(lb):\\n                if i == j:\\n                    continue\\n\\n                xj, yj, rj = bombs[j]\\n\\n                if ri ** 2 >= (xi - xj) ** 2 + (yi - yj) ** 2:  # reachable from i\\n                    n2nxt[i].add(j)\\n\\n        def dfs(n, seen):  # return None\\n            if n in seen:\\n                return\\n            seen.add(n)\\n            for nxt in n2nxt[n]:\\n                dfs(nxt, seen)\\n\\n        ans = 0\\n        for i in range(lb):\\n            seen = set()\\n            dfs(i, seen)\\n            ans = max(ans, len(seen))\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom typing import List\\nimport collections\\n\\nclass Solution:\\n    def maximumDetonation(self, bombs: List[List[int]]) -> int:\\n        n2nxt = collections.defaultdict(set)\\n        lb = len(bombs)\\n\\n        for i in range(lb):  # i is the source\\n            xi, yi, ri = bombs[i]\\n\\n            for j in range(lb):\\n                if i == j:\\n                    continue\\n\\n                xj, yj, rj = bombs[j]\\n\\n                if ri ** 2 >= (xi - xj) ** 2 + (yi - yj) ** 2:  # reachable from i\\n                    n2nxt[i].add(j)\\n\\n        def dfs(n, seen):  # return None\\n            if n in seen:\\n                return\\n            seen.add(n)\\n            for nxt in n2nxt[n]:\\n                dfs(nxt, seen)\\n\\n        ans = 0\\n        for i in range(lb):\\n            seen = set()\\n            dfs(i, seen)\\n            ans = max(ans, len(seen))\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589583,
                "title": "c-easiest-solution-with-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid addToHashMap(std::unordered_map<int, std::list<int>>& hashMap, int key, int value) {\\n    // Check if the key is present in the hashmap\\n    if (hashMap.count(key) > 0) {\\n        // Key is present, add the value to the existing list\\n        hashMap[key].push_back(value);\\n    } else {\\n        // Key is not present, create a new list and add the value\\n        std::list<int> newList;\\n        newList.push_back(value);\\n        hashMap[key] = newList;\\n    }\\n}\\n\\n\\nint dfs(int cur, std::unordered_set<int>& visited, std::unordered_map<int, std::list<int>>& graph) {\\n    int count = 1;  // Count the current node as visited\\n    visited.insert(cur);\\n\\n    for (int element : graph[cur]) {\\n      if (visited.count(element) > 0) {\\n    } else {\\n        count+=dfs(element, visited, graph);\\n        }\\n    }\\n\\n    return count;\\n}\\n\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        std::unordered_map<int, std::list<int>> graph;\\n        int n = bombs.size();\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==j){\\n                    continue;\\n                }\\n                //cout << i << \" \" << j << endl;\\n                long long comp = static_cast<long long>(bombs[i][2]) * bombs[i][2];\\n                long long distance = (static_cast<long long>(bombs[i][0]-bombs[j][0])*(bombs[i][0]-bombs[j][0])) + (static_cast<long long>(bombs[i][1]-bombs[j][1])*(bombs[i][1]-bombs[j][1]));\\n                //cout << comp << \" \" << distance << endl;\\n                if(comp>=distance){\\n                    addToHashMap(graph, i, j);\\n                } \\n            }\\n        }\\n        int answer = 0;\\n        for (int i = 0; i < n; i++) {\\n            std::unordered_set<int> visited;\\n            int count = dfs(i, visited, graph);\\n            answer = max(answer, count);\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid addToHashMap(std::unordered_map<int, std::list<int>>& hashMap, int key, int value) {\\n    // Check if the key is present in the hashmap\\n    if (hashMap.count(key) > 0) {\\n        // Key is present, add the value to the existing list\\n        hashMap[key].push_back(value);\\n    } else {\\n        // Key is not present, create a new list and add the value\\n        std::list<int> newList;\\n        newList.push_back(value);\\n        hashMap[key] = newList;\\n    }\\n}\\n\\n\\nint dfs(int cur, std::unordered_set<int>& visited, std::unordered_map<int, std::list<int>>& graph) {\\n    int count = 1;  // Count the current node as visited\\n    visited.insert(cur);\\n\\n    for (int element : graph[cur]) {\\n      if (visited.count(element) > 0) {\\n    } else {\\n        count+=dfs(element, visited, graph);\\n        }\\n    }\\n\\n    return count;\\n}\\n\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        std::unordered_map<int, std::list<int>> graph;\\n        int n = bombs.size();\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==j){\\n                    continue;\\n                }\\n                //cout << i << \" \" << j << endl;\\n                long long comp = static_cast<long long>(bombs[i][2]) * bombs[i][2];\\n                long long distance = (static_cast<long long>(bombs[i][0]-bombs[j][0])*(bombs[i][0]-bombs[j][0])) + (static_cast<long long>(bombs[i][1]-bombs[j][1])*(bombs[i][1]-bombs[j][1]));\\n                //cout << comp << \" \" << distance << endl;\\n                if(comp>=distance){\\n                    addToHashMap(graph, i, j);\\n                } \\n            }\\n        }\\n        int answer = 0;\\n        for (int i = 0; i < n; i++) {\\n            std::unordered_set<int> visited;\\n            int count = dfs(i, visited, graph);\\n            answer = max(answer, count);\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3589501,
                "title": "c-detonate-maximum-bombs-bfs-arrow-marking-highly-efficient-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt any instant, the amount of bombs detonating can be considered an equally logical approach as visiting a node in the graph.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nConsider a directed graph, in which every single node denotes a bomb. Now, a directed edge connects two nodes a and b, **if and only if** b also detonates, if a detonates (i.e. distance between the centers of a and b is less than that of radii of detonation of a). So, we make the graph (adjacency list) using a helper function isInside that takes the coordinates of bomb a, bomb b, and the detonation radius of a and returns true only when b is in the range of the bomb a\\'s radius.\\nAfter this, when we construct the adjacency list, we move on to find the maximum number of bombs that can be detonated, using **BFS**.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^3)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isInside(int xi,int yi,int ri,int xj,int yj){\\n        return (long)ri * ri >= (long)(xi - xj) * (xi - xj) + (long)(yi - yj) * (yi - yj);\\n    }\\n    int bfs(int idx,vector<vector<int>> &adj){\\n        vector<bool> vis(adj.size(),false);\\n        queue<int> q;\\n        q.push(idx);\\n        int maxBombs=0;\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            if(!vis[node]){\\n                for(auto i:adj[node]){\\n                    if(!vis[i]){\\n                        q.push(i);\\n                    }\\n                }\\n                maxBombs++;\\n                vis[node]=true;\\n            }\\n        }\\n        return maxBombs;\\n    }\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        vector<vector<int>> adj(bombs.size());\\n        for(int i=0;i<bombs.size();i++){\\n            vector<int> bomb1=bombs[i];\\n            for(int j=0;j<bombs.size();j++){\\n                if(i!=j){\\n                    vector<int> bomb2=bombs[j];\\n                    if(isInside(bomb1[0],bomb1[1],bomb1[2],bomb2[0],bomb2[1])){\\n                        adj[i].push_back(j);\\n                    }\\n                }\\n            }\\n        }\\n        int maxPathLength=INT_MIN;\\n        for(int i=0;i<adj.size();i++){\\n            maxPathLength=max(maxPathLength,bfs(i,adj));\\n        }\\n        return maxPathLength;\\n    }\\n};\\n```\\nPlease Upvote if you understood the approach!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isInside(int xi,int yi,int ri,int xj,int yj){\\n        return (long)ri * ri >= (long)(xi - xj) * (xi - xj) + (long)(yi - yj) * (yi - yj);\\n    }\\n    int bfs(int idx,vector<vector<int>> &adj){\\n        vector<bool> vis(adj.size(),false);\\n        queue<int> q;\\n        q.push(idx);\\n        int maxBombs=0;\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            if(!vis[node]){\\n                for(auto i:adj[node]){\\n                    if(!vis[i]){\\n                        q.push(i);\\n                    }\\n                }\\n                maxBombs++;\\n                vis[node]=true;\\n            }\\n        }\\n        return maxBombs;\\n    }\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        vector<vector<int>> adj(bombs.size());\\n        for(int i=0;i<bombs.size();i++){\\n            vector<int> bomb1=bombs[i];\\n            for(int j=0;j<bombs.size();j++){\\n                if(i!=j){\\n                    vector<int> bomb2=bombs[j];\\n                    if(isInside(bomb1[0],bomb1[1],bomb1[2],bomb2[0],bomb2[1])){\\n                        adj[i].push_back(j);\\n                    }\\n                }\\n            }\\n        }\\n        int maxPathLength=INT_MIN;\\n        for(int i=0;i<adj.size();i++){\\n            maxPathLength=max(maxPathLength,bfs(i,adj));\\n        }\\n        return maxPathLength;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589472,
                "title": "dfs-cinch-solution",
                "content": "# Intuition   \\n- Determine if a bomb is placed within the destroyable range of other bombs  \\n- **Recall equation of a circle- \\n X^2 + Y^2 = R^2**\\n-  Equation for bomb Within the Range\\n**(X-x)^2 + (Y-y)^2 <= R^2** \\n- If there is a bomb within range, establish a connection.\\n- Detonate each bomb and identify the one capable of detonating the maximum number of bombs.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dfs(int node, vector<int> adj[], vector<bool>& vis){\\n        vis[node] = 1;\\n        int count=1;\\n        for(auto it : adj[node])\\n            if(!vis[it])\\n                count += dfs(it, adj, vis);\\n        return count;\\n    }\\n\\n    int maximumDetonation(vector<vector<int>>& nums) {\\n        int n = nums.size();\\n        vector<int> adj[n];\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(i == j)\\n                    continue;\\n                int x = abs(nums[i][0] - nums[j][0]);\\n                int y = abs(nums[i][1] - nums[j][1]);\\n                if( pow(x,2) + pow(y,2) <= pow(nums[i][2],2) )\\n                    adj[i].push_back(j);\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0; i<n; i++){\\n            vector<bool> vis(n, 0);\\n            ans = max(ans, dfs(i, adj, vis));\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dfs(int node, vector<int> adj[], vector<bool>& vis){\\n        vis[node] = 1;\\n        int count=1;\\n        for(auto it : adj[node])\\n            if(!vis[it])\\n                count += dfs(it, adj, vis);\\n        return count;\\n    }\\n\\n    int maximumDetonation(vector<vector<int>>& nums) {\\n        int n = nums.size();\\n        vector<int> adj[n];\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(i == j)\\n                    continue;\\n                int x = abs(nums[i][0] - nums[j][0]);\\n                int y = abs(nums[i][1] - nums[j][1]);\\n                if( pow(x,2) + pow(y,2) <= pow(nums[i][2],2) )\\n                    adj[i].push_back(j);\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0; i<n; i++){\\n            vector<bool> vis(n, 0);\\n            ans = max(ans, dfs(i, adj, vis));\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589376,
                "title": "discuss-with-some-error",
                "content": "Hey guys, we all know this problem can be solved with a graph. We first build the directed graph of the bombs, then traverse all the nodes, finding the node that can trigger the most bombs.\\n\\nHowever, I\\'ve encountered some errors that I can\\'t explain.\\n\\nHere\\'s the correct code:\\n\\n# Code\\n```\\nusing LL = long long;\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int ans = 1, count;\\n        vector<int> visited;\\n        unordered_map<int, vector<int>> graph;\\n\\n        auto makeGraph = [&] () {\\n            for (int i = 0 ; i < bombs.size() ; ++i ) {\\n                for (int j = 0 ; j < bombs.size() ; ++j ) {\\n                    if (i == j) continue;\\n                    LL x_i = bombs[i][0], y_i = bombs[i][1], r_i = bombs[i][2];\\n                    LL x_j = bombs[j][0], y_j = bombs[j][1];\\n                    LL connect = pow(r_i, 2) - (pow((y_j - y_i), 2) + pow((x_j - x_i), 2));\\n                    if (connect >= 0) {\\n                        // printf(\"%d to %d \\\\n\", i, j);\\n                        graph[i].emplace_back(j);\\n                    }\\n                }\\n            }\\n            return 0;\\n        }();\\n        \\n        function<void(int)> dfs = [&] (int node) {\\n            ans = max(ans, count++);\\n            visited[node] = 1;\\n            for (auto to : graph[node]) {\\n                if (visited[to] == 1) continue;\\n                dfs(to); \\n            }\\n        };\\n\\n        for (int i = 0 ; i < bombs.size() ; ++i ) {\\n            if (graph.count(i) == 0) continue;\\n            count = 1;\\n            visited.assign(bombs.size(), 0);\\n            dfs(i);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\nBut when I use the range-based for loop to traverse the nodes, I get the wrong answer with this case:\\n\\n[[855,82,158],[17,719,430],[90,756,164],[376,17,340],[691,636,152],[565,776,5],[464,154,271],[53,361,162],[278,609,82],[202,927,219],[542,865,377],[330,402,270],[720,199,10],[986,697,443],[471,296,69],[393,81,404],[127,405,177]]\\n\\nHere\\'s the code I used:\\n\\n# Code\\n```\\nfor (auto [key, val] : graph) {\\n    count = 1;\\n    visited.assign(bombs.size(), 0);\\n    dfs(key);\\n}\\n```\\n\\nI think both methods are logically equivalent, so I don\\'t know why I got the wrong answer. It\\'s weird. Can someone explain this?",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nusing LL = long long;\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int ans = 1, count;\\n        vector<int> visited;\\n        unordered_map<int, vector<int>> graph;\\n\\n        auto makeGraph = [&] () {\\n            for (int i = 0 ; i < bombs.size() ; ++i ) {\\n                for (int j = 0 ; j < bombs.size() ; ++j ) {\\n                    if (i == j) continue;\\n                    LL x_i = bombs[i][0], y_i = bombs[i][1], r_i = bombs[i][2];\\n                    LL x_j = bombs[j][0], y_j = bombs[j][1];\\n                    LL connect = pow(r_i, 2) - (pow((y_j - y_i), 2) + pow((x_j - x_i), 2));\\n                    if (connect >= 0) {\\n                        // printf(\"%d to %d \\\\n\", i, j);\\n                        graph[i].emplace_back(j);\\n                    }\\n                }\\n            }\\n            return 0;\\n        }();\\n        \\n        function<void(int)> dfs = [&] (int node) {\\n            ans = max(ans, count++);\\n            visited[node] = 1;\\n            for (auto to : graph[node]) {\\n                if (visited[to] == 1) continue;\\n                dfs(to); \\n            }\\n        };\\n\\n        for (int i = 0 ; i < bombs.size() ; ++i ) {\\n            if (graph.count(i) == 0) continue;\\n            count = 1;\\n            visited.assign(bombs.size(), 0);\\n            dfs(i);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```\\nfor (auto [key, val] : graph) {\\n    count = 1;\\n    visited.assign(bombs.size(), 0);\\n    dfs(key);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589374,
                "title": "c-bfs-graphs-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n=bombs.size(), ans=0;\\n        vector<int>adj[n];\\n        vector<int>v(n, 0);\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(i!=j){\\n                    if(pow(bombs[i][0]-bombs[j][0], 2)+pow(bombs[i][1]-bombs[j][1], 2)<=pow(bombs[i][2], 2)){\\n                        adj[i].push_back(j);\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            queue<int>q;\\n            v[i]=1;\\n            int cnt=0;\\n            q.push(i);\\n            while(!q.empty()){\\n                int num=q.front();\\n                q.pop();\\n                for(auto it: adj[num]){\\n                    if(!v[it]){\\n                        v[it]=1;\\n                        q.push(it);\\n                    }\\n                }\\n            }\\n            for(int j=0; j<n; j++){\\n                if(v[j]){cnt++;}\\n            }\\n            ans=max(ans, cnt);\\n            vector<int>temp(n, 0);\\n            v=temp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n=bombs.size(), ans=0;\\n        vector<int>adj[n];\\n        vector<int>v(n, 0);\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(i!=j){\\n                    if(pow(bombs[i][0]-bombs[j][0], 2)+pow(bombs[i][1]-bombs[j][1], 2)<=pow(bombs[i][2], 2)){\\n                        adj[i].push_back(j);\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            queue<int>q;\\n            v[i]=1;\\n            int cnt=0;\\n            q.push(i);\\n            while(!q.empty()){\\n                int num=q.front();\\n                q.pop();\\n                for(auto it: adj[num]){\\n                    if(!v[it]){\\n                        v[it]=1;\\n                        q.push(it);\\n                    }\\n                }\\n            }\\n            for(int j=0; j<n; j++){\\n                if(v[j]){cnt++;}\\n            }\\n            ans=max(ans, cnt);\\n            vector<int>temp(n, 0);\\n            v=temp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589357,
                "title": "solution-swift-dfs",
                "content": "**TC:** O(n * n)\\n**SC:** O(n * n)\\n```\\nclass Solution {\\n    func maximumDetonation(_ bombs: [[Int]]) -> Int {\\n        func check(\\n            point: (x: Int, y: Int),\\n            isInside circle: (x: Int, y: Int, r: Int)\\n        ) -> Bool {\\n            let distance = sqrt(\\n                pow(Double(point.x - circle.x), 2.0) + pow(Double(point.y - circle.y), 2.0)\\n            )\\n            return Double(circle.r) >= distance\\n        }\\n\\n        let n = bombs.count\\n        var map = [Int: [Int]]()\\n        var result = 1\\n\\n        for i in 0..<n {\\n            map[i] = []\\n            for j in 0..<n where j != i {\\n                guard check(point: (bombs[j][0], bombs[j][1]), isInside: (bombs[i][0], bombs[i][1], bombs[i][2])) \\n                else { continue }\\n                map[i]?.append(j)\\n            }\\n        }\\n\\n        for i in 0..<n {\\n            var used = Set<Int>()\\n            var current = Set<Int>([i])\\n            while !current.isEmpty {\\n                let node = current.removeFirst()\\n                used.insert(node)\\n                for adj in map[node]! where !used.contains(adj) {\\n                    current.insert(adj)\\n                }\\n            }\\n\\n            result = max(result, used.count)\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    func maximumDetonation(_ bombs: [[Int]]) -> Int {\\n        func check(\\n            point: (x: Int, y: Int),\\n            isInside circle: (x: Int, y: Int, r: Int)\\n        ) -> Bool {\\n            let distance = sqrt(\\n                pow(Double(point.x - circle.x), 2.0) + pow(Double(point.y - circle.y), 2.0)\\n            )\\n            return Double(circle.r) >= distance\\n        }\\n\\n        let n = bombs.count\\n        var map = [Int: [Int]]()\\n        var result = 1\\n\\n        for i in 0..<n {\\n            map[i] = []\\n            for j in 0..<n where j != i {\\n                guard check(point: (bombs[j][0], bombs[j][1]), isInside: (bombs[i][0], bombs[i][1], bombs[i][2])) \\n                else { continue }\\n                map[i]?.append(j)\\n            }\\n        }\\n\\n        for i in 0..<n {\\n            var used = Set<Int>()\\n            var current = Set<Int>([i])\\n            while !current.isEmpty {\\n                let node = current.removeFirst()\\n                used.insert(node)\\n                for adj in map[node]! where !used.contains(adj) {\\n                    current.insert(adj)\\n                }\\n            }\\n\\n            result = max(result, used.count)\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589348,
                "title": "87ms-100-beats-runtime-typescript-javascript-go",
                "content": "# Code\\n``` typescript []\\nfunction maximumDetonation(bombs: number[][]): number {\\n    const neighbours: Map<number, number[]> = new Map();\\n    for (let i = 0; i < bombs.length; i++) {\\n        const x1 = bombs[i][0];\\n        const y1 = bombs[i][1];\\n        const r = bombs[i][2];\\n        for (let j = 0; j < bombs.length; j++) {\\n            if (i !== j) {\\n                const x2 = bombs[j][0];\\n                const y2 = bombs[j][1];\\n                if ((x1 - x2) ** 2 + (y1 - y2) ** 2 <= r ** 2) {\\n                    if (neighbours.has(i)) {\\n                        neighbours.get(i).push(j);\\n                        neighbours.set(i, neighbours.get(i))\\n                    } else {\\n                        neighbours.set(i, [j]);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\tlet max = 0;\\n\\tfor(let i = 0; i < bombs.length; i++) {\\n\\t\\tconst visited: Set<number> = new Set();\\n\\t\\tconst q: number[] = [];\\n\\t\\tq.push(i);\\n\\t\\tvisited.add(i);\\n\\t\\twhile (q.length) {\\n            const first = q.shift();\\n            if (neighbours.has(first)) {\\n                for (let b of neighbours.get(first)) {\\n                    if (!visited.has(b)) {\\n                        visited.add(b);\\n                        q.push(b);\\n                    }\\n                }    \\n            }\\n\\t\\t}\\n    \\tif (visited.size === bombs.length) {\\n            return visited.size;\\n        }\\n\\t\\tmax = Math.max(max, visited.size);\\n\\t}\\n\\treturn max;\\n};\\n```\\n``` javascript []\\nvar maximumDetonation = function(bombs) {\\n    const neighbours = new Map();\\n    for (let i = 0; i < bombs.length; i++) {\\n        const x1 = bombs[i][0];\\n        const y1 = bombs[i][1];\\n        const r = bombs[i][2];\\n        for (let j = 0; j < bombs.length; j++) {\\n            if (i !== j) {\\n                const x2 = bombs[j][0];\\n                const y2 = bombs[j][1];\\n                if ((x1 - x2) ** 2 + (y1 - y2) ** 2 <= r ** 2) {\\n                    if (neighbours.has(i)) {\\n                        neighbours.get(i).push(j);\\n                        neighbours.set(i, neighbours.get(i))\\n                    } else {\\n                        neighbours.set(i, [j]);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\tlet max = 0;\\n\\tfor(let i = 0; i < bombs.length; i++) {\\n\\t\\tconst visited = new Set();\\n\\t\\tconst q = [];\\n\\t\\tq.push(i);\\n\\t\\tvisited.add(i);\\n\\t\\twhile (q.length) {\\n            const first = q.shift();\\n            if (neighbours.has(first)) {\\n                for (let b of neighbours.get(first)) {\\n                    if (!visited.has(b)) {\\n                        visited.add(b);\\n                        q.push(b);\\n                    }\\n                }    \\n            }\\n\\t\\t}\\n    \\tif (visited.size === bombs.length) {\\n            return visited.size;\\n        }\\n\\t\\tmax = Math.max(max, visited.size);\\n\\t}\\n\\treturn max;\\n};\\n```\\n``` golang []\\nfunc maximumDetonation(bombs [][]int) int {\\n    neighbours := make(map[int][]int)\\n    for i := 0; i < len(bombs); i++ {\\n        x1 := bombs[i][0]\\n        y1 := bombs[i][1]\\n        r := bombs[i][2]\\n        for j := 0; j < len(bombs); j++ {\\n            if i != j {\\n                x2 := bombs[j][0]\\n                y2 := bombs[j][1]\\n                if (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2) <= r*r {\\n                    neighbours[i] = append(neighbours[i], j)\\n                }\\n            }\\n        }\\n    }\\n    max := 0\\n    for i := 0; i < len(bombs); i++ {\\n        visited := make(map[int]bool)\\n        q := []int{i}\\n        visited[i] = true\\n        for len(q) > 0 {\\n            first := q[0]\\n            q = q[1:]\\n            if val, ok := neighbours[first]; ok {\\n                for _, b := range val {\\n                    if !visited[b] {\\n                        visited[b] = true\\n                        q = append(q, b)\\n                    }\\n                }\\n            }\\n        }\\n        if len(visited) == len(bombs) {\\n            return len(visited)\\n        }\\n        l := len(visited)\\n        if l > max {\\n            max = l\\n        }\\n    }\\n    return max\\n}\\n```\\n![Screenshot 2023-06-02 at 15.02.30.png](https://assets.leetcode.com/users/images/9610f70e-270a-490a-abc9-6b2c293aa5cf_1685707909.1516757.png)\\n![Screenshot 2023-06-02 at 14.59.17.png](https://assets.leetcode.com/users/images/713ae8cc-e512-4f9a-bc72-d30643c0b343_1685707915.689838.png)\\n![Screenshot 2023-06-02 at 15.19.00.png](https://assets.leetcode.com/users/images/dcd5358d-eb9e-4564-b992-949fae4b8144_1685708362.588776.png)\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Go",
                    "TypeScript"
                ],
                "code": "``` typescript []\\nfunction maximumDetonation(bombs: number[][]): number {\\n    const neighbours: Map<number, number[]> = new Map();\\n    for (let i = 0; i < bombs.length; i++) {\\n        const x1 = bombs[i][0];\\n        const y1 = bombs[i][1];\\n        const r = bombs[i][2];\\n        for (let j = 0; j < bombs.length; j++) {\\n            if (i !== j) {\\n                const x2 = bombs[j][0];\\n                const y2 = bombs[j][1];\\n                if ((x1 - x2) ** 2 + (y1 - y2) ** 2 <= r ** 2) {\\n                    if (neighbours.has(i)) {\\n                        neighbours.get(i).push(j);\\n                        neighbours.set(i, neighbours.get(i))\\n                    } else {\\n                        neighbours.set(i, [j]);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\tlet max = 0;\\n\\tfor(let i = 0; i < bombs.length; i++) {\\n\\t\\tconst visited: Set<number> = new Set();\\n\\t\\tconst q: number[] = [];\\n\\t\\tq.push(i);\\n\\t\\tvisited.add(i);\\n\\t\\twhile (q.length) {\\n            const first = q.shift();\\n            if (neighbours.has(first)) {\\n                for (let b of neighbours.get(first)) {\\n                    if (!visited.has(b)) {\\n                        visited.add(b);\\n                        q.push(b);\\n                    }\\n                }    \\n            }\\n\\t\\t}\\n    \\tif (visited.size === bombs.length) {\\n            return visited.size;\\n        }\\n\\t\\tmax = Math.max(max, visited.size);\\n\\t}\\n\\treturn max;\\n};\\n```\n``` javascript []\\nvar maximumDetonation = function(bombs) {\\n    const neighbours = new Map();\\n    for (let i = 0; i < bombs.length; i++) {\\n        const x1 = bombs[i][0];\\n        const y1 = bombs[i][1];\\n        const r = bombs[i][2];\\n        for (let j = 0; j < bombs.length; j++) {\\n            if (i !== j) {\\n                const x2 = bombs[j][0];\\n                const y2 = bombs[j][1];\\n                if ((x1 - x2) ** 2 + (y1 - y2) ** 2 <= r ** 2) {\\n                    if (neighbours.has(i)) {\\n                        neighbours.get(i).push(j);\\n                        neighbours.set(i, neighbours.get(i))\\n                    } else {\\n                        neighbours.set(i, [j]);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\tlet max = 0;\\n\\tfor(let i = 0; i < bombs.length; i++) {\\n\\t\\tconst visited = new Set();\\n\\t\\tconst q = [];\\n\\t\\tq.push(i);\\n\\t\\tvisited.add(i);\\n\\t\\twhile (q.length) {\\n            const first = q.shift();\\n            if (neighbours.has(first)) {\\n                for (let b of neighbours.get(first)) {\\n                    if (!visited.has(b)) {\\n                        visited.add(b);\\n                        q.push(b);\\n                    }\\n                }    \\n            }\\n\\t\\t}\\n    \\tif (visited.size === bombs.length) {\\n            return visited.size;\\n        }\\n\\t\\tmax = Math.max(max, visited.size);\\n\\t}\\n\\treturn max;\\n};\\n```\n``` golang []\\nfunc maximumDetonation(bombs [][]int) int {\\n    neighbours := make(map[int][]int)\\n    for i := 0; i < len(bombs); i++ {\\n        x1 := bombs[i][0]\\n        y1 := bombs[i][1]\\n        r := bombs[i][2]\\n        for j := 0; j < len(bombs); j++ {\\n            if i != j {\\n                x2 := bombs[j][0]\\n                y2 := bombs[j][1]\\n                if (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2) <= r*r {\\n                    neighbours[i] = append(neighbours[i], j)\\n                }\\n            }\\n        }\\n    }\\n    max := 0\\n    for i := 0; i < len(bombs); i++ {\\n        visited := make(map[int]bool)\\n        q := []int{i}\\n        visited[i] = true\\n        for len(q) > 0 {\\n            first := q[0]\\n            q = q[1:]\\n            if val, ok := neighbours[first]; ok {\\n                for _, b := range val {\\n                    if !visited[b] {\\n                        visited[b] = true\\n                        q = append(q, b)\\n                    }\\n                }\\n            }\\n        }\\n        if len(visited) == len(bombs) {\\n            return len(visited)\\n        }\\n        l := len(visited)\\n        if l > max {\\n            max = l\\n        }\\n    }\\n    return max\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3589258,
                "title": "adjacency-matrix-dfs-easy-way",
                "content": "```\\nclass Solution {\\n    vector<bool> vis;\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n = bombs.size();\\n\\n        vector<int> adj[n];\\n        for (int i=0; i<n; i++) {\\n            int x = bombs[i][0];\\n            int y = bombs[i][1];\\n            int z = bombs[i][2];\\n\\n            for (int j=i+1; j<n; j++) {\\n                int a = bombs[j][0];\\n                int b = bombs[j][1];\\n                int c = bombs[j][2];\\n\\n                int p = abs(x-a);\\n                int q = abs(y-b);\\n\\n                if (1LL*p*p + 1LL*q*q <= 1LL*z*z) {\\n                    adj[i].push_back(j);\\n                }\\n                if (1LL*p*p + 1LL*q*q <= 1LL*c*c) {\\n                    adj[j].push_back(i);\\n                }\\n            }\\n        }\\n\\n        int ans = 0;\\n\\n        for (int i=0; i<n; i++) {\\n            vis = vector<bool> (n);\\n            ans = max(ans, dfs(adj, i));\\n        }\\n\\n        return ans;\\n    }\\n\\n    int dfs(vector<int> adj[], int i) {\\n        vis[i] = 1;\\n\\n        int ans = 1;\\n        for (auto j: adj[i]) {\\n            if (!vis[j])\\n                ans += dfs(adj, j);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    vector<bool> vis;\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n = bombs.size();\\n\\n        vector<int> adj[n];\\n        for (int i=0; i<n; i++) {\\n            int x = bombs[i][0];\\n            int y = bombs[i][1];\\n            int z = bombs[i][2];\\n\\n            for (int j=i+1; j<n; j++) {\\n                int a = bombs[j][0];\\n                int b = bombs[j][1];\\n                int c = bombs[j][2];\\n\\n                int p = abs(x-a);\\n                int q = abs(y-b);\\n\\n                if (1LL*p*p + 1LL*q*q <= 1LL*z*z) {\\n                    adj[i].push_back(j);\\n                }\\n                if (1LL*p*p + 1LL*q*q <= 1LL*c*c) {\\n                    adj[j].push_back(i);\\n                }\\n            }\\n        }\\n\\n        int ans = 0;\\n\\n        for (int i=0; i<n; i++) {\\n            vis = vector<bool> (n);\\n            ans = max(ans, dfs(adj, i));\\n        }\\n\\n        return ans;\\n    }\\n\\n    int dfs(vector<int> adj[], int i) {\\n        vis[i] = 1;\\n\\n        int ans = 1;\\n        for (auto j: adj[i]) {\\n            if (!vis[j])\\n                ans += dfs(adj, j);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589184,
                "title": "c-math-dfs",
                "content": "\\n# Approach\\n- DFS\\n- Math\\n\\n# Complexity\\n- Time complexity: <strong>O(n^3)</strong>\\n\\n- Space complexity: <strong>O(n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaximumDetonation(int[][] bombs) {\\n        int ans=0;\\n        var st=new HashSet<int[]>();\\n        foreach(var bomb in bombs)\\n        {\\n            ans=Math.Max(ans,DFS(bomb,bombs,st));\\n            st.Clear();\\n        }\\n        return ans;\\n    }\\n\\n\\n\\n    private int DFS(int[] node,int[][] bombs,HashSet<int[]> vis)\\n    {\\n        vis.Add(node);     \\n        int ans=1;\\n        foreach(var bomb in bombs)\\n        {\\n            if(!vis.Contains(bomb)&& InRange(node,bomb))\\n                ans+=DFS(bomb,bombs,vis);\\n        }\\n\\n        return ans;\\n    } \\n\\n\\n\\n\\n\\n    private bool InRange(int[] first,int[] second)\\n    {\\n        long x1=first[0];\\n        long y1=first[1];\\n        long r1=first[2];\\n\\n        long x2=second[0];\\n        long y2=second[1];\\n        long r2=second[2];\\n\\n        long xdiff=x1-x2;\\n        long ydiff=y1-y2;\\n\\n        long dist=(xdiff*xdiff)+(ydiff*ydiff);\\n        return r1*r1>=dist;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaximumDetonation(int[][] bombs) {\\n        int ans=0;\\n        var st=new HashSet<int[]>();\\n        foreach(var bomb in bombs)\\n        {\\n            ans=Math.Max(ans,DFS(bomb,bombs,st));\\n            st.Clear();\\n        }\\n        return ans;\\n    }\\n\\n\\n\\n    private int DFS(int[] node,int[][] bombs,HashSet<int[]> vis)\\n    {\\n        vis.Add(node);     \\n        int ans=1;\\n        foreach(var bomb in bombs)\\n        {\\n            if(!vis.Contains(bomb)&& InRange(node,bomb))\\n                ans+=DFS(bomb,bombs,vis);\\n        }\\n\\n        return ans;\\n    } \\n\\n\\n\\n\\n\\n    private bool InRange(int[] first,int[] second)\\n    {\\n        long x1=first[0];\\n        long y1=first[1];\\n        long r1=first[2];\\n\\n        long x2=second[0];\\n        long y2=second[1];\\n        long r2=second[2];\\n\\n        long xdiff=x1-x2;\\n        long ydiff=y1-y2;\\n\\n        long dist=(xdiff*xdiff)+(ydiff*ydiff);\\n        return r1*r1>=dist;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589178,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n        int bfs(vector<vector<int>>&bombs,int source){\\n\\n            int n = bombs.size();\\n            vector<bool>vis(n,false);\\n            queue<pair<int,pair<int,int>>>q;\\n            q.push({bombs[source][2],{bombs[source][0],bombs[source][1]}});\\n            vis[source] = true;\\n            int count = 1;\\n            while(!q.empty()){\\n                {\\n                    long long int a = q.front().second.first,b = q.front().second.second;\\n                    long long int r = q.front().first;\\n                    q.pop();\\n                    for(int i=0;i<n;i++){\\n                        if(!vis[i]){\\n                            long long int c = bombs[i][0],d = bombs[i][1],e = abs(a-c),f = abs(d-b);\\n                            if(e*e+f*f<=r*r){\\n\\n                                count++;\\n                                vis[i] = true;\\n                                \\n                                q.push({bombs[i][2],{bombs[i][0],bombs[i][1]}});\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            return count;\\n        }\\n\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n\\n        int n = bombs.size();\\n        int maxi = 0;\\n        for(int i=0;i<n;i++){\\n            maxi = max(maxi,bfs(bombs,i));\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        int bfs(vector<vector<int>>&bombs,int source){\\n\\n            int n = bombs.size();\\n            vector<bool>vis(n,false);\\n            queue<pair<int,pair<int,int>>>q;\\n            q.push({bombs[source][2],{bombs[source][0],bombs[source][1]}});\\n            vis[source] = true;\\n            int count = 1;\\n            while(!q.empty()){\\n                {\\n                    long long int a = q.front().second.first,b = q.front().second.second;\\n                    long long int r = q.front().first;\\n                    q.pop();\\n                    for(int i=0;i<n;i++){\\n                        if(!vis[i]){\\n                            long long int c = bombs[i][0],d = bombs[i][1],e = abs(a-c),f = abs(d-b);\\n                            if(e*e+f*f<=r*r){\\n\\n                                count++;\\n                                vis[i] = true;\\n                                \\n                                q.push({bombs[i][2],{bombs[i][0],bombs[i][1]}});\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            return count;\\n        }\\n\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n\\n        int n = bombs.size();\\n        int maxi = 0;\\n        for(int i=0;i<n;i++){\\n            maxi = max(maxi,bfs(bombs,i));\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588985,
                "title": "easy-python-solution-using-bfs-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumDetonation(self, bombs: List[List[int]]) -> int:\\n        mx=0\\n        n=len(bombs)\\n        for i in range(n):\\n            vis=[0]*n\\n            ct=1\\n            queue=[(bombs[i])]\\n            vis[i]=1\\n            while queue:\\n                x=queue.pop(0)\\n                # print(x,ct)\\n                for j in range(n):\\n                    if vis[j]==0 and((x[0]-bombs[j][0])**2+(x[1]-bombs[j][1])**2)<=x[2]**2:\\n                        ct+=1\\n                        queue.append((bombs[j]))\\n                        vis[j]=1\\n            mx=max(mx,ct)\\n        return mx\\n            \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumDetonation(self, bombs: List[List[int]]) -> int:\\n        mx=0\\n        n=len(bombs)\\n        for i in range(n):\\n            vis=[0]*n\\n            ct=1\\n            queue=[(bombs[i])]\\n            vis[i]=1\\n            while queue:\\n                x=queue.pop(0)\\n                # print(x,ct)\\n                for j in range(n):\\n                    if vis[j]==0 and((x[0]-bombs[j][0])**2+(x[1]-bombs[j][1])**2)<=x[2]**2:\\n                        ct+=1\\n                        queue.append((bombs[j]))\\n                        vis[j]=1\\n            mx=max(mx,ct)\\n        return mx\\n            \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588941,
                "title": "easy-c-approach-using-queue-and-bool-vector-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsing queue and a boolian vector\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n = bombs.size();\\n        queue<vector<int>> q;\\n\\n        int count = 0;\\n        int ans = 0;\\n        for(int i = 0; i < n ; i++)\\n        {\\n            vector<bool> detonated(n,false);\\n            q.push(bombs[i]);\\n            detonated[i] = true;\\n            count = 1;\\n            while(!q.empty())\\n            {\\n                auto it = q.front();\\n                q.pop();\\n\\n                // int det = it.first;\\n\\n                for(int j = 0; j  < n; j++)\\n                {\\n                    if(!detonated[j] && sqrt(pow(bombs[j][0] - it[0], 2) + pow(bombs[j][1] - it[1],2)) <= it[2]){\\n                        detonated[j] = true;\\n                        q.push(bombs[j]);\\n                        count++;\\n                    };\\n                }\\n            }\\n\\n            ans = max(ans, count);\\n                \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n = bombs.size();\\n        queue<vector<int>> q;\\n\\n        int count = 0;\\n        int ans = 0;\\n        for(int i = 0; i < n ; i++)\\n        {\\n            vector<bool> detonated(n,false);\\n            q.push(bombs[i]);\\n            detonated[i] = true;\\n            count = 1;\\n            while(!q.empty())\\n            {\\n                auto it = q.front();\\n                q.pop();\\n\\n                // int det = it.first;\\n\\n                for(int j = 0; j  < n; j++)\\n                {\\n                    if(!detonated[j] && sqrt(pow(bombs[j][0] - it[0], 2) + pow(bombs[j][1] - it[1],2)) <= it[2]){\\n                        detonated[j] = true;\\n                        q.push(bombs[j]);\\n                        count++;\\n                    };\\n                }\\n            }\\n\\n            ans = max(ans, count);\\n                \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588930,
                "title": "1-1-100000-100000-100000-1-getting-wrong-understand-why",
                "content": "Who all are comparing like these to check the reach\\n`x1 <= i` and `i <= x2` and `y1 <= j` and `j <= y2`\\n\\n- If you try to compare only coordinates then this is the case where it goes wrong\\n\\n\\n\\n![bombsLeetCode.jpeg](https://assets.leetcode.com/users/images/903250d7-8ed5-4904-96cc-fd47518237a4_1685698245.2045515.jpeg)\\n\\n\\n\\n- so, instead take the distance between the center of other circle & current circle (dist)  ... comapre with the radius of current circle (r)\\n- if dist <= r  then it\\'s inside the range else not in range. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //int vis[101];\\n    int maxi=0;\\n\\n    bool inRange(int i, int j, int ind, vector<vector<int>>& bombs){\\n        double r=bombs[ind][2];\\n        double x=bombs[ind][0];\\n        double y=bombs[ind][1];\\n\\n        double t1 = abs(x-i);\\n        double t2 = abs(y-j);\\n        double dist =  (t1*t1) + (t2*t2) ;\\n\\n        if(dist<=r*r) return true;\\n        return false;\\n    }\\n\\n    int dfs(int ind,vector<vector<int>>& bombs,vector<int>& vis){\\n        vis[ind]=1;\\n        int t=0;\\n        for(int i=0;i<bombs.size();i++){\\n            if(i==ind)continue;\\n            if(vis[i]==0 and inRange(bombs[i][0],bombs[i][1],ind,bombs)){\\n                t+=dfs(i,bombs,vis);\\n            }    \\n        }\\n        return t+1;\\n    }\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n=bombs.size();\\n\\n        for(int i=0;i<n;i++){\\n            vector<int> vis(n,0);\\n            maxi=max(maxi,dfs(i,bombs,vis) );\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //int vis[101];\\n    int maxi=0;\\n\\n    bool inRange(int i, int j, int ind, vector<vector<int>>& bombs){\\n        double r=bombs[ind][2];\\n        double x=bombs[ind][0];\\n        double y=bombs[ind][1];\\n\\n        double t1 = abs(x-i);\\n        double t2 = abs(y-j);\\n        double dist =  (t1*t1) + (t2*t2) ;\\n\\n        if(dist<=r*r) return true;\\n        return false;\\n    }\\n\\n    int dfs(int ind,vector<vector<int>>& bombs,vector<int>& vis){\\n        vis[ind]=1;\\n        int t=0;\\n        for(int i=0;i<bombs.size();i++){\\n            if(i==ind)continue;\\n            if(vis[i]==0 and inRange(bombs[i][0],bombs[i][1],ind,bombs)){\\n                t+=dfs(i,bombs,vis);\\n            }    \\n        }\\n        return t+1;\\n    }\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n=bombs.size();\\n\\n        for(int i=0;i<n;i++){\\n            vector<int> vis(n,0);\\n            maxi=max(maxi,dfs(i,bombs,vis) );\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588898,
                "title": "c-100-dfs-with-precomputed-distances",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNo need to explicitly represent the graph. You can know the edges implicitly from the distances between bombs. To avoid repeated distance computations we precompute the distances between all pairs of bombs.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nbool detonated[100];\\n\\nstatic int dfs(int **bombs, int n, float (*dist)[100], int i) {\\n\\tint d = 0;\\n\\tdetonated[i] = true;\\n\\n\\tfor(int j = 0; j < n; ++j)\\n\\t\\tif(!detonated[j] && dist[i][j] <= bombs[i][2])\\n\\t\\t\\t\\td += dfs(bombs, n, dist, j);\\n\\n\\treturn d+1;\\n}\\n\\nint maximumDetonation(int **bombs, int n, int *bombsColSize) {\\n\\tfloat dist[100][100];\\n\\n\\tfor(int i = 0; i < n; ++i) {\\n\\t\\tfor(int j = i+1; j < n; ++j) {\\n\\t\\t\\tfloat d = hypotf(bombs[i][0] - bombs[j][0], bombs[i][1] - bombs[j][1]);\\n\\t\\t\\tdist[i][j] = d;\\n\\t\\t\\tdist[j][i] = d;\\n\\t\\t}\\n\\t}\\n\\n\\tint best = 0;\\n\\n\\tfor(int i = 0; i < n; ++i) {\\n\\t\\tmemset(detonated, 0, sizeof detonated);\\n\\t\\tint d = dfs(bombs, n, dist, i);\\n\\t\\tif(best < d) best = d;\\n\\t}\\n\\n\\treturn best;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool detonated[100];\\n\\nstatic int dfs(int **bombs, int n, float (*dist)[100], int i) {\\n\\tint d = 0;\\n\\tdetonated[i] = true;\\n\\n\\tfor(int j = 0; j < n; ++j)\\n\\t\\tif(!detonated[j] && dist[i][j] <= bombs[i][2])\\n\\t\\t\\t\\td += dfs(bombs, n, dist, j);\\n\\n\\treturn d+1;\\n}\\n\\nint maximumDetonation(int **bombs, int n, int *bombsColSize) {\\n\\tfloat dist[100][100];\\n\\n\\tfor(int i = 0; i < n; ++i) {\\n\\t\\tfor(int j = i+1; j < n; ++j) {\\n\\t\\t\\tfloat d = hypotf(bombs[i][0] - bombs[j][0], bombs[i][1] - bombs[j][1]);\\n\\t\\t\\tdist[i][j] = d;\\n\\t\\t\\tdist[j][i] = d;\\n\\t\\t}\\n\\t}\\n\\n\\tint best = 0;\\n\\n\\tfor(int i = 0; i < n; ++i) {\\n\\t\\tmemset(detonated, 0, sizeof detonated);\\n\\t\\tint d = dfs(bombs, n, dist, i);\\n\\t\\tif(best < d) best = d;\\n\\t}\\n\\n\\treturn best;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3588688,
                "title": "c-solution-using-bfs-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n=bombs.size();\\n        vector<vector<pair<int,int>>> adj;\\n        vector<pair<int,int>> curr;\\n        map<pair<int,int>,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=bombs[i][0],y=bombs[i][1],r=bombs[i][2];\\n            mp[{x,y}]=i;\\n        }\\n        long v1,v2,v3 ;\\n        for(int i=0;i<n;i++)\\n        {\\n            curr.clear();\\n            int x=bombs[i][0],y=bombs[i][1],r=bombs[i][2];\\n            for(int j=0;j<n;j++)\\n            {\\n                int x1=bombs[j][0],y1=bombs[j][1];\\n                v1=x1-x;\\n                v2=y1-y;\\n                v3=r;\\n                if(v1*v1+v2*v2<=v3*v3)\\n                {\\n                    curr.push_back({x1,y1});\\n                }\\n            }\\n            adj.push_back(curr);\\n        }\\n        \\n        int ans=1,cnt=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            cnt=0;\\n            vector<bool> vis(n,false);\\n            queue<pair<int,int>> pq;\\n            for(auto x:adj[i])\\n            {\\n                pq.push(x);\\n                cnt++;\\n                vis[mp[x]]=true;\\n            }\\n            while(!pq.empty())\\n            {\\n                auto e=pq.front();\\n                pq.pop();\\n                for(auto x:adj[mp[e]])\\n                {\\n                    if(!vis[mp[x]])\\n                    {\\n                        cnt++;\\n                        vis[mp[x]]=true;\\n                        pq.push(x);\\n                    }\\n                }\\n            }\\n            ans=max(ans,cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n=bombs.size();\\n        vector<vector<pair<int,int>>> adj;\\n        vector<pair<int,int>> curr;\\n        map<pair<int,int>,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=bombs[i][0],y=bombs[i][1],r=bombs[i][2];\\n            mp[{x,y}]=i;\\n        }\\n        long v1,v2,v3 ;\\n        for(int i=0;i<n;i++)\\n        {\\n            curr.clear();\\n            int x=bombs[i][0],y=bombs[i][1],r=bombs[i][2];\\n            for(int j=0;j<n;j++)\\n            {\\n                int x1=bombs[j][0],y1=bombs[j][1];\\n                v1=x1-x;\\n                v2=y1-y;\\n                v3=r;\\n                if(v1*v1+v2*v2<=v3*v3)\\n                {\\n                    curr.push_back({x1,y1});\\n                }\\n            }\\n            adj.push_back(curr);\\n        }\\n        \\n        int ans=1,cnt=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            cnt=0;\\n            vector<bool> vis(n,false);\\n            queue<pair<int,int>> pq;\\n            for(auto x:adj[i])\\n            {\\n                pq.push(x);\\n                cnt++;\\n                vis[mp[x]]=true;\\n            }\\n            while(!pq.empty())\\n            {\\n                auto e=pq.front();\\n                pq.pop();\\n                for(auto x:adj[mp[e]])\\n                {\\n                    if(!vis[mp[x]])\\n                    {\\n                        cnt++;\\n                        vis[mp[x]]=true;\\n                        pq.push(x);\\n                    }\\n                }\\n            }\\n            ans=max(ans,cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588687,
                "title": "dfs-c",
                "content": "```\\nclass Solution {\\n    int dfs(int node, vector<int> adj[], vector<int> &vis) {\\n        vis[node] = 1;\\n        int cnt = 1;\\n        for(int ad : adj[node]) {\\n            if(!vis[ad]) cnt += dfs(ad, adj, vis);\\n        }\\n        return cnt;\\n    }\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n = bombs.size(), ans = 0;\\n        vector<int> adj[n];\\n\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(i == j) continue;\\n                double d = pow(pow(bombs[i][0] - bombs[j][0], 2) + pow(bombs[i][1] - bombs[j][1], 2), 0.5);\\n                if(d <= bombs[i][2]) adj[i].push_back(j);\\n            }\\n        }\\n        for(int i=0; i<n; i++) {\\n            vector<int> vis(n);\\n            ans = max(ans, dfs(i, adj, vis));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(int node, vector<int> adj[], vector<int> &vis) {\\n        vis[node] = 1;\\n        int cnt = 1;\\n        for(int ad : adj[node]) {\\n            if(!vis[ad]) cnt += dfs(ad, adj, vis);\\n        }\\n        return cnt;\\n    }\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n = bombs.size(), ans = 0;\\n        vector<int> adj[n];\\n\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(i == j) continue;\\n                double d = pow(pow(bombs[i][0] - bombs[j][0], 2) + pow(bombs[i][1] - bombs[j][1], 2), 0.5);\\n                if(d <= bombs[i][2]) adj[i].push_back(j);\\n            }\\n        }\\n        for(int i=0; i<n; i++) {\\n            vector<int> vis(n);\\n            ans = max(ans, dfs(i, adj, vis));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588643,
                "title": "c-bfs-multisource-bfs",
                "content": "# Intuition\\nWe will try for each bomb, how many bombs can it detonante\\nIf a bomb A detonantes bomb B , Bomb B will further detonante next possible bombs\\n\\nThis makes us think of Graph Algorithms BFS/DFS\\n\\n# Approach\\nWe will use BFS for solving this problem \\n\\n# Complexity\\n- Time complexity:\\n$$O(N*N^2)$$\\n\\n- Space complexity:\\n$$O(N)$$ for storing queue\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n = bombs.size();\\n        int ans = INT_MIN;\\n        for(int i = 0;i<n;i++)\\n        {\\n            //using each and every bombs we are \\n            //checking how many bombs can be detonanted \\n            //from this bomb \\n            int x = bfs(bombs, i);\\n            ans = max(ans , x);\\n        }\\n        return ans;\\n    }\\n    int bfs(vector<vector<int>> &bombs , int src)\\n    {\\n        queue<pair<int , pair<int , int>>> q;\\n        q.push({bombs[src][2] , {bombs[src][0] , bombs[src][1]}});\\n\\n        // q-> {dis , x , y}\\n\\n        int count = 1;\\n        int n = bombs.size();\\n        vector<int> vis(n , 0);\\n        vis[src] = 1;\\n        while(q.size())\\n        {\\n            int r = q.front().first;\\n            int x = q.front().second.first;\\n            int y = q.front().second.second;\\n            q.pop();\\n            for(int i = 0;i<n;i++)\\n            {\\n                if(vis[i] == 0)\\n                {\\n                    int nx = bombs[i][0];\\n                    int ny = bombs[i][1];\\n                    int rr = bombs[i][2];\\n                    long long dx = abs(x-nx);\\n                    long long dy = abs(y-ny);\\n                    if(dx*dx+dy*dy <= (long long)r*(long long)r)\\n                    //this if condition is used for checking if the next bomb lies in range or not. \\n                    //THINK OF IT!! AS DISTANCE FORMULA!!\\n                    {\\n                        vis[i] = 1;\\n                        q.push({rr , {nx, ny}});\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n = bombs.size();\\n        int ans = INT_MIN;\\n        for(int i = 0;i<n;i++)\\n        {\\n            //using each and every bombs we are \\n            //checking how many bombs can be detonanted \\n            //from this bomb \\n            int x = bfs(bombs, i);\\n            ans = max(ans , x);\\n        }\\n        return ans;\\n    }\\n    int bfs(vector<vector<int>> &bombs , int src)\\n    {\\n        queue<pair<int , pair<int , int>>> q;\\n        q.push({bombs[src][2] , {bombs[src][0] , bombs[src][1]}});\\n\\n        // q-> {dis , x , y}\\n\\n        int count = 1;\\n        int n = bombs.size();\\n        vector<int> vis(n , 0);\\n        vis[src] = 1;\\n        while(q.size())\\n        {\\n            int r = q.front().first;\\n            int x = q.front().second.first;\\n            int y = q.front().second.second;\\n            q.pop();\\n            for(int i = 0;i<n;i++)\\n            {\\n                if(vis[i] == 0)\\n                {\\n                    int nx = bombs[i][0];\\n                    int ny = bombs[i][1];\\n                    int rr = bombs[i][2];\\n                    long long dx = abs(x-nx);\\n                    long long dy = abs(y-ny);\\n                    if(dx*dx+dy*dy <= (long long)r*(long long)r)\\n                    //this if condition is used for checking if the next bomb lies in range or not. \\n                    //THINK OF IT!! AS DISTANCE FORMULA!!\\n                    {\\n                        vis[i] = 1;\\n                        q.push({rr , {nx, ny}});\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588637,
                "title": "dfs-approach-php",
                "content": "# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public function dfs($node, $graph, &$visited = []) {\\n        if ($visited[$node]) {\\n            return $result;\\n        }\\n\\n        $visited[$node] = 1;\\n        $neighbors = $graph[$node] ?? [];\\n        foreach($neighbors as $neighbor) {\\n            $this->dfs($neighbor, $graph, $visited);\\n        }\\n        \\n        return count($visited);\\n    }\\n\\n    public function isBombInRadius($bomb1, $bomb2) {\\n        return pow($bomb2[0] - $bomb1[0], 2) + pow($bomb2[1] - $bomb1[1], 2) <= pow($bomb1[2], 2);\\n    }\\n\\n    /**\\n     * @param Integer[][] $bombs\\n     * @return Integer\\n     */\\n    function maximumDetonation($bombs, $result = 0) {\\n        if (empty($bombs)) {\\n            return $result;\\n        }\\n\\n        $graph = [];\\n        $visited = [];\\n\\n        foreach($bombs as $index => $bomb1) {\\n            $nodes = [];\\n\\n            for ($i = 0; $i < count($bombs); $i++) {\\n                $isBombInRadius = $this->isBombInRadius($bomb1, $bombs[$i]);\\n\\n                if ($isBombInRadius && $i !== $index) {\\n                    $nodes[] = $i;\\n                }\\n            }\\n\\n            if (count($nodes)) {\\n                $graph[$index] = $nodes ;\\n            }   \\n        }\\n\\n        if (count($graph) === 0) {\\n            return $result + 1;\\n        }\\n\\n        foreach($graph as $node => $neighbors) {\\n            $result = max($result, $this->dfs($node, $graph));\\n        }\\n\\n        return $result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n    public function dfs($node, $graph, &$visited = []) {\\n        if ($visited[$node]) {\\n            return $result;\\n        }\\n\\n        $visited[$node] = 1;\\n        $neighbors = $graph[$node] ?? [];\\n        foreach($neighbors as $neighbor) {\\n            $this->dfs($neighbor, $graph, $visited);\\n        }\\n        \\n        return count($visited);\\n    }\\n\\n    public function isBombInRadius($bomb1, $bomb2) {\\n        return pow($bomb2[0] - $bomb1[0], 2) + pow($bomb2[1] - $bomb1[1], 2) <= pow($bomb1[2], 2);\\n    }\\n\\n    /**\\n     * @param Integer[][] $bombs\\n     * @return Integer\\n     */\\n    function maximumDetonation($bombs, $result = 0) {\\n        if (empty($bombs)) {\\n            return $result;\\n        }\\n\\n        $graph = [];\\n        $visited = [];\\n\\n        foreach($bombs as $index => $bomb1) {\\n            $nodes = [];\\n\\n            for ($i = 0; $i < count($bombs); $i++) {\\n                $isBombInRadius = $this->isBombInRadius($bomb1, $bombs[$i]);\\n\\n                if ($isBombInRadius && $i !== $index) {\\n                    $nodes[] = $i;\\n                }\\n            }\\n\\n            if (count($nodes)) {\\n                $graph[$index] = $nodes ;\\n            }   \\n        }\\n\\n        if (count($graph) === 0) {\\n            return $result + 1;\\n        }\\n\\n        foreach($graph as $node => $neighbors) {\\n            $result = max($result, $this->dfs($node, $graph));\\n        }\\n\\n        return $result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588619,
                "title": "bfs-easy-c-ac",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMake it graph\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRepersent each bomb with ID, and store all the bombs in range of each ID.\\nDo BFS over each bomb the max no of visited nodes at any point will be the answer.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bomb) {\\n        int n = bomb.size();\\n        vector<vector<int>> g(n);\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            for(int j = 0 ; j < n ; j++)\\n            {\\n                if(i != j)\\n                {\\n                    long long int a = bomb[i][0];\\n                    long long int b = bomb[i][1];\\n                    long long int r = bomb[i][2];\\n                    long long int x = bomb[j][0];\\n                    long long int y = bomb[j][1];\\n                    long long int t1 = (x - a)*(x - a);\\n                    long long int t2 = (y - b)*(y - b);\\n                    r =  r*r;\\n                    if(r >= (t1 + t2))\\n                    {\\n                        g[i].push_back(j);\\n                    }\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int i = 0 ; i< n ; i++)\\n        {\\n            queue<int> q;\\n            q.push(i);\\n            vector<bool> vis(n,false);\\n            vis[i] = true;\\n            int res = 1;\\n            while(!q.empty())\\n            {\\n                int crr = q.front();\\n                q.pop();\\n                for(auto& x : g[crr])\\n                {\\n                    if(!vis[x])\\n                    {\\n                        q.push(x);\\n                        res++;\\n                        vis[x] = true;\\n                    }\\n                }\\n            }\\n            ans = max(ans,res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bomb) {\\n        int n = bomb.size();\\n        vector<vector<int>> g(n);\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            for(int j = 0 ; j < n ; j++)\\n            {\\n                if(i != j)\\n                {\\n                    long long int a = bomb[i][0];\\n                    long long int b = bomb[i][1];\\n                    long long int r = bomb[i][2];\\n                    long long int x = bomb[j][0];\\n                    long long int y = bomb[j][1];\\n                    long long int t1 = (x - a)*(x - a);\\n                    long long int t2 = (y - b)*(y - b);\\n                    r =  r*r;\\n                    if(r >= (t1 + t2))\\n                    {\\n                        g[i].push_back(j);\\n                    }\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int i = 0 ; i< n ; i++)\\n        {\\n            queue<int> q;\\n            q.push(i);\\n            vector<bool> vis(n,false);\\n            vis[i] = true;\\n            int res = 1;\\n            while(!q.empty())\\n            {\\n                int crr = q.front();\\n                q.pop();\\n                for(auto& x : g[crr])\\n                {\\n                    if(!vis[x])\\n                    {\\n                        q.push(x);\\n                        res++;\\n                        vis[x] = true;\\n                    }\\n                }\\n            }\\n            ans = max(ans,res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588506,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Build Graph\\n- Apply DFS to count max connected componet from each vertex\\n\\n# Complexity\\n- Time complexity: $$O(n^3)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumDetonation(int[][] bombs) {\\n        var G = new Graph(bombs);\\n        var cc = new CC(G);\\n        return cc.maxComponent();\\n    }\\n}\\n\\nclass Graph {\\n\\n    private final List<Integer> [] adj;\\n    private final int V;\\n\\n    Graph(int[][] bombs) {\\n        this.V = bombs.length;\\n        this.adj = new List[V];\\n\\n        for (var v = 0; v < V; ++v)\\n            adj[v] = new ArrayList<Integer>();\\n\\n        for (var v = 0; v < V - 1; ++v) {\\n            for (var w = v + 1; w < V; ++w) {\\n                if (isPointInside(bombs[v], bombs[w]))\\n                    adj[v].add(w);\\n                \\n                if (isPointInside(bombs[w], bombs[v]))\\n                    adj[w].add(v);\\n            }\\n        }\\n    }\\n\\n    // w inside v\\n    private boolean isPointInside(int[] v, int[] w) {\\n        long xv = v[0], yv = v[1];\\n        long r = v[2];\\n        long xw = w[0], yw = w[1];\\n        return r * r >= (xv - xw) * (xv - xw) + (yv - yw) * (yv - yw);\\n    }\\n\\n    public int V() {\\n        return V;\\n    }\\n\\n    public Iterable<Integer> adj(int v) {\\n        return adj[v];\\n    }\\n}\\n\\nclass CC {\\n\\n    private final Graph G;\\n    private int max;\\n\\n    CC(Graph G) {\\n        this.G = G;\\n\\n        for (var v = 0; v < G.V(); ++v)\\n            max = Integer.max(max, dfs(new boolean[G.V()], v));\\n    }\\n\\n    private int dfs(boolean[] marked, int v) {\\n        marked[v] = true;\\n\\n        var c = 1;\\n        for (var w: G.adj(v)) {\\n            if (!marked[w])\\n                c += dfs(marked, w);\\n        }\\n\\n        return c;\\n    }\\n\\n    public int maxComponent() {\\n        return max;\\n    }\\n}   \\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumDetonation(int[][] bombs) {\\n        var G = new Graph(bombs);\\n        var cc = new CC(G);\\n        return cc.maxComponent();\\n    }\\n}\\n\\nclass Graph {\\n\\n    private final List<Integer> [] adj;\\n    private final int V;\\n\\n    Graph(int[][] bombs) {\\n        this.V = bombs.length;\\n        this.adj = new List[V];\\n\\n        for (var v = 0; v < V; ++v)\\n            adj[v] = new ArrayList<Integer>();\\n\\n        for (var v = 0; v < V - 1; ++v) {\\n            for (var w = v + 1; w < V; ++w) {\\n                if (isPointInside(bombs[v], bombs[w]))\\n                    adj[v].add(w);\\n                \\n                if (isPointInside(bombs[w], bombs[v]))\\n                    adj[w].add(v);\\n            }\\n        }\\n    }\\n\\n    // w inside v\\n    private boolean isPointInside(int[] v, int[] w) {\\n        long xv = v[0], yv = v[1];\\n        long r = v[2];\\n        long xw = w[0], yw = w[1];\\n        return r * r >= (xv - xw) * (xv - xw) + (yv - yw) * (yv - yw);\\n    }\\n\\n    public int V() {\\n        return V;\\n    }\\n\\n    public Iterable<Integer> adj(int v) {\\n        return adj[v];\\n    }\\n}\\n\\nclass CC {\\n\\n    private final Graph G;\\n    private int max;\\n\\n    CC(Graph G) {\\n        this.G = G;\\n\\n        for (var v = 0; v < G.V(); ++v)\\n            max = Integer.max(max, dfs(new boolean[G.V()], v));\\n    }\\n\\n    private int dfs(boolean[] marked, int v) {\\n        marked[v] = true;\\n\\n        var c = 1;\\n        for (var w: G.adj(v)) {\\n            if (!marked[w])\\n                c += dfs(marked, w);\\n        }\\n\\n        return c;\\n    }\\n\\n    public int maxComponent() {\\n        return max;\\n    }\\n}   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588490,
                "title": "kotlin-dfs-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    fun maximumDetonation(bombs: Array<IntArray>): Int {\\n        val n = bombs.size\\n        var visit = BooleanArray(n){ false }\\n        var memo = IntArray(n){ -1 }\\n\\n        fun dfs(id: Int): Int{\\n            if (visit[id]) return 0\\n            visit[id] = true\\n\\n            var count = 1\\n            val curr = bombs[id]\\n\\n            for (i in 0 until n) {\\n                if (id == i) continue\\n                if (visit[i]) continue\\n                val next = bombs[i]\\n\\n                if (dist(curr, next) <= curr[2].toDouble()) {\\n                    count += dfs(i)\\n                }\\n            }\\n\\n            return count\\n        }\\n\\n        var result = 0\\n\\n        for (i in 0 until n) {\\n            visit = BooleanArray(n){ false }\\n            result = Math.max(result, dfs(i))\\n        }\\n\\n        return result\\n    }\\n\\n    fun dist(a: IntArray, b: IntArray): Double {\\n        val dx = Math.abs(a[0] - b[0]).toDouble()\\n        val dy = Math.abs(a[1] - b[1]).toDouble()\\n        return Math.sqrt(dx * dx + dy * dy)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun maximumDetonation(bombs: Array<IntArray>): Int {\\n        val n = bombs.size\\n        var visit = BooleanArray(n){ false }\\n        var memo = IntArray(n){ -1 }\\n\\n        fun dfs(id: Int): Int{\\n            if (visit[id]) return 0\\n            visit[id] = true\\n\\n            var count = 1\\n            val curr = bombs[id]\\n\\n            for (i in 0 until n) {\\n                if (id == i) continue\\n                if (visit[i]) continue\\n                val next = bombs[i]\\n\\n                if (dist(curr, next) <= curr[2].toDouble()) {\\n                    count += dfs(i)\\n                }\\n            }\\n\\n            return count\\n        }\\n\\n        var result = 0\\n\\n        for (i in 0 until n) {\\n            visit = BooleanArray(n){ false }\\n            result = Math.max(result, dfs(i))\\n        }\\n\\n        return result\\n    }\\n\\n    fun dist(a: IntArray, b: IntArray): Double {\\n        val dx = Math.abs(a[0] - b[0]).toDouble()\\n        val dy = Math.abs(a[1] - b[1]).toDouble()\\n        return Math.sqrt(dx * dx + dy * dy)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588483,
                "title": "detonate-maximum-bombs-easy-c-bfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n=bombs.size();\\n   \\n        int maxi=0;\\n        for(int i=0;i<bombs.size();i++){\\n            int cnt = 0;\\n            vector<int>visited(n,0);\\n            int x=bombs[i][0];\\n            int y=bombs[i][1];\\n            int r=bombs[i][2];\\n            queue<pair<int,pair<int,int>>>dq;\\n            dq.push({r,{x,y}});\\n            visited[i]=1;\\n            while(!dq.empty()){\\n                cnt++;\\n                pair<int,pair<int,int>>p=dq.front();\\n                int a=p.second.first;\\n                int b=p.second.second;\\n                int c=p.first;\\n                // cout<<a<<\" \"<<b<<\" \"<<c<<endl;\\n                dq.pop();\\n                for(int j=0;j<bombs.size();j++){\\n                    if(visited[j]==0){\\n                        long long int dist=(long long)pow(abs(a-bombs[j][0]),2)+(long long )pow(abs(b-bombs[j][1]),2);\\n                        if(dist <= (long long)c*c){ \\n                            //cout<<dist<<\" \"<<c*c<<endl;\\n                            dq.push({bombs[j][2],{bombs[j][0],bombs[j][1]}});\\n                            visited[j]=1;\\n                        }\\n                    }\\n                }\\n            }\\n            maxi=max(maxi,cnt);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n=bombs.size();\\n   \\n        int maxi=0;\\n        for(int i=0;i<bombs.size();i++){\\n            int cnt = 0;\\n            vector<int>visited(n,0);\\n            int x=bombs[i][0];\\n            int y=bombs[i][1];\\n            int r=bombs[i][2];\\n            queue<pair<int,pair<int,int>>>dq;\\n            dq.push({r,{x,y}});\\n            visited[i]=1;\\n            while(!dq.empty()){\\n                cnt++;\\n                pair<int,pair<int,int>>p=dq.front();\\n                int a=p.second.first;\\n                int b=p.second.second;\\n                int c=p.first;\\n                // cout<<a<<\" \"<<b<<\" \"<<c<<endl;\\n                dq.pop();\\n                for(int j=0;j<bombs.size();j++){\\n                    if(visited[j]==0){\\n                        long long int dist=(long long)pow(abs(a-bombs[j][0]),2)+(long long )pow(abs(b-bombs[j][1]),2);\\n                        if(dist <= (long long)c*c){ \\n                            //cout<<dist<<\" \"<<c*c<<endl;\\n                            dq.push({bombs[j][2],{bombs[j][0],bombs[j][1]}});\\n                            visited[j]=1;\\n                        }\\n                    }\\n                }\\n            }\\n            maxi=max(maxi,cnt);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3588352,
                "title": "typescript-bfs-beats-100",
                "content": "\\n# Approach\\n- First, find connections between each node of the array and fill the map.\\n- After that, do BFS on each node and find the number of nodes you can visit from each node; the maximum of them will be answered.\\n\\n\\n\\n# Code\\n```\\nfunction BFS(bombs: number[][], map: Map<number, number[]>, startNode: number): number {\\n    let visited: number[] = new Array(bombs.length).fill(-1);\\n    let count: number = 0;\\n    let queae: number[] = [startNode];\\n    visited[startNode] = 1;\\n    while (queae.length != 0) {\\n        let temp: number | undefined = queae.shift();\\n        if (temp != undefined) {\\n            count++;\\n            let val: number[] | undefined = map.get(temp);\\n            if (val) {\\n                for (let index = 0; index < val.length; index++) {\\n                    if (visited[val[index]] == -1) {\\n                        queae.push(val[index]);\\n                        visited[val[index]] = 1;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return count;\\n};\\nfunction maximumDetonation(bombs: number[][]): number {\\n    let map: Map<number, number[]> = new Map();\\n    for (let index = 0; index < bombs.length; index++) {\\n        map.set(index, []);\\n    }\\n    for (let index = 0; index < bombs.length; index++) {\\n        for (let j = 0; j < bombs.length; j++) {\\n            if (index !== j) {\\n                let distance: number = Math.sqrt(Math.abs(Math.pow((bombs[index][0] - bombs[j][0]), 2) + Math.pow((bombs[index][1] - bombs[j][1]), 2)));\\n                if (distance <= bombs[index][2]) {\\n                    map.get(index)?.push(j);\\n                }\\n            }\\n\\n        }\\n    }\\n    let max: number = 0;\\n    for (let index = 0; index < bombs.length; index++) {\\n        let detonated: number = BFS(bombs, map, index);\\n        if (detonated > max) {\\n            max = detonated;\\n        }\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Hash Table",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nfunction BFS(bombs: number[][], map: Map<number, number[]>, startNode: number): number {\\n    let visited: number[] = new Array(bombs.length).fill(-1);\\n    let count: number = 0;\\n    let queae: number[] = [startNode];\\n    visited[startNode] = 1;\\n    while (queae.length != 0) {\\n        let temp: number | undefined = queae.shift();\\n        if (temp != undefined) {\\n            count++;\\n            let val: number[] | undefined = map.get(temp);\\n            if (val) {\\n                for (let index = 0; index < val.length; index++) {\\n                    if (visited[val[index]] == -1) {\\n                        queae.push(val[index]);\\n                        visited[val[index]] = 1;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return count;\\n};\\nfunction maximumDetonation(bombs: number[][]): number {\\n    let map: Map<number, number[]> = new Map();\\n    for (let index = 0; index < bombs.length; index++) {\\n        map.set(index, []);\\n    }\\n    for (let index = 0; index < bombs.length; index++) {\\n        for (let j = 0; j < bombs.length; j++) {\\n            if (index !== j) {\\n                let distance: number = Math.sqrt(Math.abs(Math.pow((bombs[index][0] - bombs[j][0]), 2) + Math.pow((bombs[index][1] - bombs[j][1]), 2)));\\n                if (distance <= bombs[index][2]) {\\n                    map.get(index)?.push(j);\\n                }\\n            }\\n\\n        }\\n    }\\n    let max: number = 0;\\n    for (let index = 0; index < bombs.length; index++) {\\n        let detonated: number = BFS(bombs, map, index);\\n        if (detonated > max) {\\n            max = detonated;\\n        }\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3588327,
                "title": "c-bfs-or-dfs-explained",
                "content": "**INTUTION:**\\n* Constraints is: 1 <= bombs.length <= 100, so N^2 approach will work\\n*  We will pick bombs one by one start BFS/DFS from there, keep a count of no of bomb it has detonated\\n*   Find and return the maximum count recorded\\n*   NOTE: Instead of BFS, we can also perform DFS (but BFS here is more time effiecient \\u23F3)\\n\\n**CODE:**\\n```\\nclass Solution {\\npublic:\\n    \\n    double helper(long long x1, long long y1, long long x2, long long y2){\\n\\t\\t// helper function to find distance between 2 points\\n        double sq= 1.0*(((x1-x2)*(x1-x2)) + ((y1-y2)*(y1-y2)));\\n        return (double)(sqrt(sq));\\n    }\\n    \\n    int bfs(int start, vector<int>* adj, int n){\\n        vector<int> isVis(n, false);\\n        queue<int> q; int cnt=0; // number of bombs detonated by \\'start\\'\\n        q.push(start); isVis[start]=true;\\n        \\n        while(!q.empty()){\\n            int front= q.front(); q.pop(); cnt++; \\n            for(int i=0; i<adj[front].size(); i++){\\n                int nbr= adj[front][i];\\n                if(isVis[nbr]==false){\\n                    q.push(nbr); isVis[nbr]=true;\\n                }\\n            }\\n        }\\n        return cnt; // number of bombs detonated by \\'start\\'\\n    }\\n    \\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n=bombs.size(); vector<int> adj[n];\\n        for(int i=0; i<n; i++){\\n            int r=bombs[i][2];\\n            for(int j=0; j<n; j++){\\n                if(i==j){ continue; }\\n                double dist= helper(bombs[i][0], bombs[i][1], bombs[j][0], bombs[j][1]);\\n                // I have to find wheather jth bomb lies in the range of ith bomb or not\\n                if(dist<=1.0*r){ \\n\\t\\t\\t\\t\\tadj[i].push_back(j);  // note that this is a one-way connection\\n\\t\\t\\t\\t}\\n            }\\n        }\\n        \\n        int ans=0;\\n        for(int i=0; i<n; i++){\\n            ans= max(ans, bfs(i, adj, n));\\n        }\\n        return ans;\\n    }\\n};\\n```\\nTime Complexity: O(n^2) || Space Complexity: O(n^2)\\nThanks !",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    double helper(long long x1, long long y1, long long x2, long long y2){\\n\\t\\t// helper function to find distance between 2 points\\n        double sq= 1.0*(((x1-x2)*(x1-x2)) + ((y1-y2)*(y1-y2)));\\n        return (double)(sqrt(sq));\\n    }\\n    \\n    int bfs(int start, vector<int>* adj, int n){\\n        vector<int> isVis(n, false);\\n        queue<int> q; int cnt=0; // number of bombs detonated by \\'start\\'\\n        q.push(start); isVis[start]=true;\\n        \\n        while(!q.empty()){\\n            int front= q.front(); q.pop(); cnt++; \\n            for(int i=0; i<adj[front].size(); i++){\\n                int nbr= adj[front][i];\\n                if(isVis[nbr]==false){\\n                    q.push(nbr); isVis[nbr]=true;\\n                }\\n            }\\n        }\\n        return cnt; // number of bombs detonated by \\'start\\'\\n    }\\n    \\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n=bombs.size(); vector<int> adj[n];\\n        for(int i=0; i<n; i++){\\n            int r=bombs[i][2];\\n            for(int j=0; j<n; j++){\\n                if(i==j){ continue; }\\n                double dist= helper(bombs[i][0], bombs[i][1], bombs[j][0], bombs[j][1]);\\n                // I have to find wheather jth bomb lies in the range of ith bomb or not\\n                if(dist<=1.0*r){ \\n\\t\\t\\t\\t\\tadj[i].push_back(j);  // note that this is a one-way connection\\n\\t\\t\\t\\t}\\n            }\\n        }\\n        \\n        int ans=0;\\n        for(int i=0; i<n; i++){\\n            ans= max(ans, bfs(i, adj, n));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588171,
                "title": "c-simple-dfs-solution",
                "content": "# Intuition\\nTo do this graph problem, we have to find the maximum length of serial-wise bombs aligned within their range with respect to each other.\\n\\n# Approach\\nOur objective is to traverse using DFS and find as many bombs in a given range that can be detonated. The constraints of the problem make it suitable for a brute-force approach.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the given code is indeed `O(n^3)` because it iterates over `n` bombs and potentially explores up to `O(n^2)` edges.\\n\\n- Space complexity:\\nThe space complexity of this code is `O(n^2)`, where n is the number of bombs.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>& bombs, int node, int n,vector<int>& vis){\\n        if(vis[node]) return 1;\\n\\n        double dist; int c = 1;\\n        vis[node] = 1;\\n\\n        for(int i = 0;i<n;++i){\\n            if(!vis[i]){\\n                dist = sqrt(pow((bombs[i][0] - bombs[node][0]),2) + pow((bombs[i][1] - bombs[node][1]),2));\\n\\n                if(dist <= bombs[node][2]){\\n                     c += dfs(bombs,i,n,vis);\\n                }\\n\\n            }\\n        }\\n\\n        return c;\\n    }\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n = bombs.size();\\n        int out = 0;\\n\\n        for(int i = 0 ;i< n;++i){\\n            vector<int> vis(n,0);\\n            out = max(out,dfs(bombs,i,n,vis));\\n        }\\n\\n        return out;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>& bombs, int node, int n,vector<int>& vis){\\n        if(vis[node]) return 1;\\n\\n        double dist; int c = 1;\\n        vis[node] = 1;\\n\\n        for(int i = 0;i<n;++i){\\n            if(!vis[i]){\\n                dist = sqrt(pow((bombs[i][0] - bombs[node][0]),2) + pow((bombs[i][1] - bombs[node][1]),2));\\n\\n                if(dist <= bombs[node][2]){\\n                     c += dfs(bombs,i,n,vis);\\n                }\\n\\n            }\\n        }\\n\\n        return c;\\n    }\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n = bombs.size();\\n        int out = 0;\\n\\n        for(int i = 0 ;i< n;++i){\\n            vector<int> vis(n,0);\\n            out = max(out,dfs(bombs,i,n,vis));\\n        }\\n\\n        return out;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588120,
                "title": "using-dfs-appr-may-be-you-will-find-this-solution-easiest",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid dfs(vector<vector<int>>& edges,vector<bool>& visited,int &i,int &count){\\n    visited[i]=true;\\n    count++;\\n    for(int j=0;j<edges[i].size();j++){\\n     if(!visited[edges[i][j]]){\\n         dfs(edges,visited,edges[i][j],count);\\n     }\\n    }\\n}\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n  int n=bombs.size();\\n       vector<vector<int>> edges(n);\\n  \\n    //we will first find the edges or we can say how much bombs lie in each in individual range like for bomb first does bomb 2 to n how much of them lie in the radius of first bomb\\n \\n            for (int i = 0; i < n; i++) {\\n            long long x = bombs[i][0];\\n            long long y = bombs[i][1];\\n            long long r = bombs[i][2];\\n            int count = 0;\\n            \\n            for (int j = 0; j < n; j++) {\\n                if (i == j) {\\n                    continue;\\n                }\\n                \\n                long long x2 = abs(bombs[j][0]-x);\\n                long long y2 = abs(bombs[j][1]-y);\\n                \\n                if ((( x2*x2) + (y2 * y2)) <= (r*r)) {\\n                    edges[i].push_back(j);\\n                }\\n            }\\n        }\\n    \\n        // as we have find the edges avai now we travel across each vector of edge and cout how many element each part of edge vector are inter connected and return the max of them \\n        int maxima=INT_MIN;\\n      for(int i=0;i<n;i++){\\n            int count=0;\\n            vector<bool> visited(n,false);\\n            dfs(edges,visited,i,count);\\n            maxima=max(maxima,count);\\n      }\\n    \\n    return maxima;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Depth-First Search",
                    "Graph",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid dfs(vector<vector<int>>& edges,vector<bool>& visited,int &i,int &count){\\n    visited[i]=true;\\n    count++;\\n    for(int j=0;j<edges[i].size();j++){\\n     if(!visited[edges[i][j]]){\\n         dfs(edges,visited,edges[i][j],count);\\n     }\\n    }\\n}\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n  int n=bombs.size();\\n       vector<vector<int>> edges(n);\\n  \\n    //we will first find the edges or we can say how much bombs lie in each in individual range like for bomb first does bomb 2 to n how much of them lie in the radius of first bomb\\n \\n            for (int i = 0; i < n; i++) {\\n            long long x = bombs[i][0];\\n            long long y = bombs[i][1];\\n            long long r = bombs[i][2];\\n            int count = 0;\\n            \\n            for (int j = 0; j < n; j++) {\\n                if (i == j) {\\n                    continue;\\n                }\\n                \\n                long long x2 = abs(bombs[j][0]-x);\\n                long long y2 = abs(bombs[j][1]-y);\\n                \\n                if ((( x2*x2) + (y2 * y2)) <= (r*r)) {\\n                    edges[i].push_back(j);\\n                }\\n            }\\n        }\\n    \\n        // as we have find the edges avai now we travel across each vector of edge and cout how many element each part of edge vector are inter connected and return the max of them \\n        int maxima=INT_MIN;\\n      for(int i=0;i<n;i++){\\n            int count=0;\\n            vector<bool> visited(n,false);\\n            dfs(edges,visited,i,count);\\n            maxima=max(maxima,count);\\n      }\\n    \\n    return maxima;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3588081,
                "title": "c-dfs-easy-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst of all for every bomb i check how many bombs can be decoded including that bomb. if a bomb decodes two bombs then further that two bomb will decode the other bombs.So we now know we will have to use graph and create adjacency list.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNow to create the adjacency list we have to check which bomb can be  \\ndecoded for that we calculate distance between the center of the bombs\\nif it is smaller than the radius then the bomb can be decoded and we push bomb j in adjacency of i.\\nNow to get the maximum count we start with every bomb individually and do dfs/bfs traversal to get no of bombs decoded and finally take the maximum count.\\n\\n**If This Helped Please Upvote!**\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid dfs(int start,vector<int>&vis,vector<int>adj[],int &count){\\n    vis[start]=1;\\n    count++;\\n    for(auto it:adj[start]){\\n        if(!vis[it]){\\n            dfs(it,vis,adj,count);\\n        }\\n    }\\n}\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int ans= INT_MIN;\\n        int n= bombs.size();\\n        vector<int>adj[n];\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                long long x1=bombs[i][0];\\n                long long y1=bombs[i][1];\\n                long long r1= bombs[i][2];\\n                if(i!=j){\\n                    long long x= abs(x1-bombs[j][0]);\\n                    long long y= abs(y1-bombs[j][1]);\\n                    if(x*x+y*y<=r1*r1){\\n                        adj[i].push_back(j);\\n\\n\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            int count=0;\\n            vector<int>vis(n,0);\\n            dfs(i,vis,adj,count);\\n            ans= max(ans,count);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid dfs(int start,vector<int>&vis,vector<int>adj[],int &count){\\n    vis[start]=1;\\n    count++;\\n    for(auto it:adj[start]){\\n        if(!vis[it]){\\n            dfs(it,vis,adj,count);\\n        }\\n    }\\n}\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int ans= INT_MIN;\\n        int n= bombs.size();\\n        vector<int>adj[n];\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                long long x1=bombs[i][0];\\n                long long y1=bombs[i][1];\\n                long long r1= bombs[i][2];\\n                if(i!=j){\\n                    long long x= abs(x1-bombs[j][0]);\\n                    long long y= abs(y1-bombs[j][1]);\\n                    if(x*x+y*y<=r1*r1){\\n                        adj[i].push_back(j);\\n\\n\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            int count=0;\\n            vector<int>vis(n,0);\\n            dfs(i,vis,adj,count);\\n            ans= max(ans,count);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3588004,
                "title": "c-easiest-solution",
                "content": "# Intuition\\nEasy method from bfs.\\n\\n## Approach\\ngraph and depth first search.\\n\\n## Complexity\\n- Time complexity:\\nnlog(n)\\n\\n- Space complexity:\\nlog(n)\\n\\n ## Code\\n\\n```\\nclass Solution {\\n    using ll = long long;\\n    bool ispossible(vector<int>&a,vector<int>&b){\\n        ll distance = 1LL*(a[0] - b[0])*(a[0] - b[0]) + 1LL*(a[1]-b[1])*(a[1]-b[1]);\\n        if(distance<=1LL*a[2]*a[2])return true;//a can destroy b \\n        return false;\\n    }\\n    void dfs(int node,vector<int>&vis,vector<int>adj[],int &currentsize){\\n        vis[node] = 1;\\n        currentsize++;\\n        for(auto adjnode : adj[node]){\\n            if(!vis[adjnode]){\\n                dfs(adjnode,vis,adj,currentsize);\\n            }\\n        }\\n    }\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n = bombs.size();\\n        vector<int> adj[n];\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(ispossible(bombs[i],bombs[j])){\\n                    adj[i].push_back(j);\\n                }\\n                if(ispossible(bombs[j],bombs[i])){\\n                    adj[j].push_back(i);\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(auto it : adj[i]){\\n                cout<<it<<\" \";\\n            }\\n            cout<<endl;\\n        }\\n        //now graph is created\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            vector<int> vis(n,0);\\n            int currentsize = 0;\\n            dfs(i,vis,adj,currentsize);\\n            ans = max(ans,currentsize);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    using ll = long long;\\n    bool ispossible(vector<int>&a,vector<int>&b){\\n        ll distance = 1LL*(a[0] - b[0])*(a[0] - b[0]) + 1LL*(a[1]-b[1])*(a[1]-b[1]);\\n        if(distance<=1LL*a[2]*a[2])return true;//a can destroy b \\n        return false;\\n    }\\n    void dfs(int node,vector<int>&vis,vector<int>adj[],int &currentsize){\\n        vis[node] = 1;\\n        currentsize++;\\n        for(auto adjnode : adj[node]){\\n            if(!vis[adjnode]){\\n                dfs(adjnode,vis,adj,currentsize);\\n            }\\n        }\\n    }\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n = bombs.size();\\n        vector<int> adj[n];\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(ispossible(bombs[i],bombs[j])){\\n                    adj[i].push_back(j);\\n                }\\n                if(ispossible(bombs[j],bombs[i])){\\n                    adj[j].push_back(i);\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(auto it : adj[i]){\\n                cout<<it<<\" \";\\n            }\\n            cout<<endl;\\n        }\\n        //now graph is created\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            vector<int> vis(n,0);\\n            int currentsize = 0;\\n            dfs(i,vis,adj,currentsize);\\n            ans = max(ans,currentsize);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3587986,
                "title": "2101-detonate-the-maximum-bombs",
                "content": "```\\nclass Solution {\\npublic:\\n    int dfs(int i, vector<vector<int>> &al, bitset<100> &detonated) {\\n    if (!detonated[i]) {\\n        detonated[i] = true;\\n        for (int j : al[i])\\n            dfs(j, al, detonated);\\n    }\\n    return detonated.count();\\n}\\nint maximumDetonation(vector<vector<int>>& bs) {\\n    int res = 0, sz = bs.size();\\n    vector<vector<int>> al(bs.size());\\n    for (int i = 0; i < sz; ++i) {\\n        long long x = bs[i][0], y = bs[i][1], r2 = (long long)bs[i][2] * bs[i][2];\\n        for (int j = 0; j < bs.size(); ++j)\\n            if ((x - bs[j][0]) * (x - bs[j][0]) + (y - bs[j][1]) * (y - bs[j][1]) <= r2)\\n                al[i].push_back(j);\\n    }\\n    for (int i = 0; i < sz && res < sz; ++i)\\n        res = max(dfs(i, al, bitset<100>() = {}), res);\\n    return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int i, vector<vector<int>> &al, bitset<100> &detonated) {\\n    if (!detonated[i]) {\\n        detonated[i] = true;\\n        for (int j : al[i])\\n            dfs(j, al, detonated);\\n    }\\n    return detonated.count();\\n}\\nint maximumDetonation(vector<vector<int>>& bs) {\\n    int res = 0, sz = bs.size();\\n    vector<vector<int>> al(bs.size());\\n    for (int i = 0; i < sz; ++i) {\\n        long long x = bs[i][0], y = bs[i][1], r2 = (long long)bs[i][2] * bs[i][2];\\n        for (int j = 0; j < bs.size(); ++j)\\n            if ((x - bs[j][0]) * (x - bs[j][0]) + (y - bs[j][1]) * (y - bs[j][1]) <= r2)\\n                al[i].push_back(j);\\n    }\\n    for (int i = 0; i < sz && res < sz; ++i)\\n        res = max(dfs(i, al, bitset<100>() = {}), res);\\n    return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587892,
                "title": "c-solution-using-adjacency-list-and-dfs",
                "content": "\\n# Code\\n```\\ntypedef struct Node {\\n    int bomb;\\n    struct Node *next;\\n} Node;\\n\\nint inRange(int **bombs, int i, int j) {\\n    int x1, y1, r1, x2, y2;\\n    long long rangeSquared, distanceSquared;\\n    x1 = bombs[i][0];\\n    y1 = bombs[i][1];\\n    r1 = bombs[i][2];\\n    x2 = bombs[j][0];\\n    y2 = bombs[j][1];\\n    rangeSquared = (long long) r1 * (long long) r1;\\n    distanceSquared = (long long) (x1 - x2) * \\n                      (long long) (x1 - x2) + \\n                      (long long) (y1 - y2) * \\n                      (long long) (y1 - y2);\\n    return distanceSquared <= rangeSquared;\\n}\\n\\nint dfs(Node **bombList, int node, int *visited) {\\n    int count = 1;\\n    Node *n = bombList[node];\\n    int neighbour;\\n    visited[node] = 1;\\n    while (n != NULL) {\\n        neighbour = n->bomb;\\n        if (!visited[neighbour]) {\\n            count += dfs(bombList, neighbour, visited);\\n        }\\n        n = n->next;\\n    }\\n    return count;\\n}\\n\\nint maximumDetonation(int** bombs, int bombsSize, int* bombsColSize){\\n    int i, j, visited[bombsSize];\\n    int numberDetonated, maxNumberDetonated = INT_MIN;\\n    Node **bombList = (Node**) calloc(bombsSize, sizeof(Node*));\\n    Node *dest;\\n\\n    /* Build up adjacency list */\\n    for (i = 0; i < bombsSize; ++i) {\\n        for (j = 0; j < bombsSize; ++j) {\\n            if (i != j && inRange(bombs, i, j)) {\\n                dest = (Node*) malloc(sizeof(Node));\\n                dest->bomb = j;\\n                dest->next = bombList[i];\\n                bombList[i] = dest;\\n            }\\n        }\\n    }\\n    /* determine how many bombs will be detonated from each bomb */\\n    for (i = 0; i < bombsSize; ++i) {\\n        memset((void*) visited, 0, bombsSize * sizeof(int));\\n        numberDetonated = dfs(bombList, i, visited);\\n        if (numberDetonated > maxNumberDetonated) {\\n            maxNumberDetonated = numberDetonated;\\n        }\\n    }\\n    return maxNumberDetonated;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntypedef struct Node {\\n    int bomb;\\n    struct Node *next;\\n} Node;\\n\\nint inRange(int **bombs, int i, int j) {\\n    int x1, y1, r1, x2, y2;\\n    long long rangeSquared, distanceSquared;\\n    x1 = bombs[i][0];\\n    y1 = bombs[i][1];\\n    r1 = bombs[i][2];\\n    x2 = bombs[j][0];\\n    y2 = bombs[j][1];\\n    rangeSquared = (long long) r1 * (long long) r1;\\n    distanceSquared = (long long) (x1 - x2) * \\n                      (long long) (x1 - x2) + \\n                      (long long) (y1 - y2) * \\n                      (long long) (y1 - y2);\\n    return distanceSquared <= rangeSquared;\\n}\\n\\nint dfs(Node **bombList, int node, int *visited) {\\n    int count = 1;\\n    Node *n = bombList[node];\\n    int neighbour;\\n    visited[node] = 1;\\n    while (n != NULL) {\\n        neighbour = n->bomb;\\n        if (!visited[neighbour]) {\\n            count += dfs(bombList, neighbour, visited);\\n        }\\n        n = n->next;\\n    }\\n    return count;\\n}\\n\\nint maximumDetonation(int** bombs, int bombsSize, int* bombsColSize){\\n    int i, j, visited[bombsSize];\\n    int numberDetonated, maxNumberDetonated = INT_MIN;\\n    Node **bombList = (Node**) calloc(bombsSize, sizeof(Node*));\\n    Node *dest;\\n\\n    /* Build up adjacency list */\\n    for (i = 0; i < bombsSize; ++i) {\\n        for (j = 0; j < bombsSize; ++j) {\\n            if (i != j && inRange(bombs, i, j)) {\\n                dest = (Node*) malloc(sizeof(Node));\\n                dest->bomb = j;\\n                dest->next = bombList[i];\\n                bombList[i] = dest;\\n            }\\n        }\\n    }\\n    /* determine how many bombs will be detonated from each bomb */\\n    for (i = 0; i < bombsSize; ++i) {\\n        memset((void*) visited, 0, bombsSize * sizeof(int));\\n        numberDetonated = dfs(bombList, i, visited);\\n        if (numberDetonated > maxNumberDetonated) {\\n            maxNumberDetonated = numberDetonated;\\n        }\\n    }\\n    return maxNumberDetonated;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3587856,
                "title": "java-dfs-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumDetonation(int[][] bombs) {\\n        int ans  = 0;\\n        int n = bombs.length;\\n        boolean[] visited = new boolean[n];\\n        int var;\\n        for(int i=0; i<n; i++) {\\n            Arrays.fill(visited, false);\\n            var = dfs(i, bombs, visited);\\n            ans = Math.max(ans, var);\\n        }\\n        return ans;\\n    }\\n\\n    int dfs(int ind, int[][] bombs, boolean[] visited) {\\n        visited[ind]=true;\\n        long r = bombs[ind][2];\\n        r = r*r;\\n        int ans = 0;\\n        for(int i=0; i<bombs.length; i++) {\\n            if(i==ind || visited[i])\\n            continue;\\n            long xDiff = (bombs[ind][0]-bombs[i][0]);\\n            long yDiff = (bombs[ind][1]-bombs[i][1]);\\n            long dis = xDiff*xDiff + yDiff*yDiff;\\n            if(dis<=r) {\\n                ans+=dfs(i, bombs, visited);\\n            }\\n        }\\n        return ans+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumDetonation(int[][] bombs) {\\n        int ans  = 0;\\n        int n = bombs.length;\\n        boolean[] visited = new boolean[n];\\n        int var;\\n        for(int i=0; i<n; i++) {\\n            Arrays.fill(visited, false);\\n            var = dfs(i, bombs, visited);\\n            ans = Math.max(ans, var);\\n        }\\n        return ans;\\n    }\\n\\n    int dfs(int ind, int[][] bombs, boolean[] visited) {\\n        visited[ind]=true;\\n        long r = bombs[ind][2];\\n        r = r*r;\\n        int ans = 0;\\n        for(int i=0; i<bombs.length; i++) {\\n            if(i==ind || visited[i])\\n            continue;\\n            long xDiff = (bombs[ind][0]-bombs[i][0]);\\n            long yDiff = (bombs[ind][1]-bombs[i][1]);\\n            long dis = xDiff*xDiff + yDiff*yDiff;\\n            if(dis<=r) {\\n                ans+=dfs(i, bombs, visited);\\n            }\\n        }\\n        return ans+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587779,
                "title": "dfs-and-circle-interception",
                "content": "# Code\\n```\\ndef dfs(stack, visited, adj)\\n    while stack.length > 0\\n        node = stack.pop\\n        next if visited.include?(node)\\n        visited << node\\n\\n        x,y,r = node\\n\\n        adj[node].each do |n|\\n            stack.push(n)\\n        end \\n    end \\nend \\n\\n\\ndef maximum_detonation(bombs)\\n    max = -Float::INFINITY\\n    b = bombs.map.with_index {|n, index| [*n, index]}\\n    adj = {}\\n    b.each do |node|\\n        x,y,r=node \\n        adj[node] = []\\n        b.each do |n| \\n            next if (node == n)\\n            d = ((n[0] - x) * (n[0] - x)) + ((n[1] - y) * (n[1] - y))\\n            if (d <= r ** 2)\\n                adj[node] << n\\n            end \\n        end \\n    end \\n\\n    b.each do |node| \\n        visited = []\\n        stack = [node]\\n\\n        dfs(stack, visited, adj)\\n        max = visited.length if (visited.length > max)\\n        return max if (max == bombs.length)\\n    end \\n    return max\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef dfs(stack, visited, adj)\\n    while stack.length > 0\\n        node = stack.pop\\n        next if visited.include?(node)\\n        visited << node\\n\\n        x,y,r = node\\n\\n        adj[node].each do |n|\\n            stack.push(n)\\n        end \\n    end \\nend \\n\\n\\ndef maximum_detonation(bombs)\\n    max = -Float::INFINITY\\n    b = bombs.map.with_index {|n, index| [*n, index]}\\n    adj = {}\\n    b.each do |node|\\n        x,y,r=node \\n        adj[node] = []\\n        b.each do |n| \\n            next if (node == n)\\n            d = ((n[0] - x) * (n[0] - x)) + ((n[1] - y) * (n[1] - y))\\n            if (d <= r ** 2)\\n                adj[node] << n\\n            end \\n        end \\n    end \\n\\n    b.each do |node| \\n        visited = []\\n        stack = [node]\\n\\n        dfs(stack, visited, adj)\\n        max = visited.length if (visited.length > max)\\n        return max if (max == bombs.length)\\n    end \\n    return max\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3587770,
                "title": "python-3-dfs",
                "content": "# Intuition\\nCan\\'t do DSU for this question because explosion\\'s effect should be unidirection. eg. bomb A can affect bomb B doesn\\'t implies bomb B can also affect bomb A.\\n\\nYou can go either DFS/BFS.\\n\\n# Approach\\nDFS\\n\\n# My mistake\\nI chose DSU in the beginning. But later I realized the single direction effect. A couple of minutes had gone at that time...\\n\\n# Complexity\\n- Time complexity:\\nO(n^2) -> double loops preprocess / dfs both comsumes n^2 time\\n\\n- Space complexity:\\nO(n^2) -> n2nxt map\\n\\nn = len(bombs)\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumDetonation(self, bombs: List[List[int]]) -> int:\\n        \\n        import collections\\n\\n        n2nxt = collections.defaultdict(set)\\n        lb = len(bombs)\\n\\n\\n        for i in range(lb): # i is source\\n            xi, yi, ri = bombs[i]\\n\\n            for j in range(lb):\\n                if i == j: continue\\n\\n                xj, yj, rj = bombs[j]\\n\\n                if ri ** 2 >= (xi - xj) ** 2 + (yi - yj) ** 2: # reachable from i\\n                    n2nxt[i].add(j)\\n        \\n        def dfs(n): # return None\\n            if n in seen: return\\n            seen.add(n)\\n            for nxt in n2nxt[n]:\\n                dfs(nxt)\\n\\n        ans = 0\\n        for i in range(lb):\\n            seen = set()\\n            dfs(i)\\n            ans = max(ans, len(seen))\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maximumDetonation(self, bombs: List[List[int]]) -> int:\\n        \\n        import collections\\n\\n        n2nxt = collections.defaultdict(set)\\n        lb = len(bombs)\\n\\n\\n        for i in range(lb): # i is source\\n            xi, yi, ri = bombs[i]\\n\\n            for j in range(lb):\\n                if i == j: continue\\n\\n                xj, yj, rj = bombs[j]\\n\\n                if ri ** 2 >= (xi - xj) ** 2 + (yi - yj) ** 2: # reachable from i\\n                    n2nxt[i].add(j)\\n        \\n        def dfs(n): # return None\\n            if n in seen: return\\n            seen.add(n)\\n            for nxt in n2nxt[n]:\\n                dfs(nxt)\\n\\n        ans = 0\\n        for i in range(lb):\\n            seen = set()\\n            dfs(i)\\n            ans = max(ans, len(seen))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587739,
                "title": "javascript-solution-using-recursion-depth-first-search",
                "content": "Here\\'s a simple solution using recursion DFS.\\n1. Create an adjacency list array `adj` which is an array of arrays where `adj[bombIndex] = [array of bombs within bombIndex\\'s range]`\\n2. To check the range, create a helper function `checkRange` to calculate the distance between the two bombs using Pythagoras `a^2 + b^2 = c^2` and compare with the explosion radius of the two bombs, then return an array `[hasBomb1HitBomb2, hasBomb2HitBomb1]`\\n3. After building `adj`, create a `dfs` function to visit the bomb nodes and recursively call `dfs` on `adj[bombNode]`\\n4. Keep a `visited` `Set()` in `dfs` to make sure it doesn\\'t re-visit visited nodes and end up in an infinite loop, also keep track of the bombs triggered using the `bomb` variable\\n5. To count the bombs triggered, initialize `bomb` as `1` to count the original bomb, then add all the bombs triggered by the subsequent bombs from `adj[bombNode]`, and call `Math.max()` to record the `max` number of bombs triggered\\n6. Loop through all the bombs and call `dfs` on each bomb index, then return `max`.\\n\\n```\\n/**\\n * @param {number[][]} bombs\\n * @return {number}\\n */\\nvar maximumDetonation = function(bombs) {\\n    const n = bombs.length\\n    if (n <= 1) return n\\n    const adj = new Array(n).fill(0).map(a => [])\\n\\n    const checkRange = ([x1, y1, r1], [x2, y2, r2]) => {\\n        const dist = (x1 - x2)**2 + (y1 - y2)**2\\n        return [r1**2 >= dist, r2**2 >= dist]\\n    }\\n\\n    for (let i=0; i<n; i++) {\\n        for (let j=i+1; j<n; j++) {\\n            const [hitsJ, hitsI] = checkRange(bombs[i], bombs[j])\\n            if (hitsJ) adj[i].push(j)\\n            if (hitsI) adj[j].push(i)\\n        }\\n    }\\n\\n    let max = 0\\n    const dfs = (node, visited = new Set()) => {\\n        visited.add(node)\\n        let bomb = 1\\n        for (let next of adj[node]) {\\n            if (!visited.has(next)) {\\n                bomb += dfs(next, visited)\\n            }\\n        }\\n        max = Math.max(max, bomb)\\n        return bomb\\n    }\\n\\n    for (let i=0; i<n; i++) dfs(i)\\n    return max\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {number[][]} bombs\\n * @return {number}\\n */\\nvar maximumDetonation = function(bombs) {\\n    const n = bombs.length\\n    if (n <= 1) return n\\n    const adj = new Array(n).fill(0).map(a => [])\\n\\n    const checkRange = ([x1, y1, r1], [x2, y2, r2]) => {\\n        const dist = (x1 - x2)**2 + (y1 - y2)**2\\n        return [r1**2 >= dist, r2**2 >= dist]\\n    }\\n\\n    for (let i=0; i<n; i++) {\\n        for (let j=i+1; j<n; j++) {\\n            const [hitsJ, hitsI] = checkRange(bombs[i], bombs[j])\\n            if (hitsJ) adj[i].push(j)\\n            if (hitsI) adj[j].push(i)\\n        }\\n    }\\n\\n    let max = 0\\n    const dfs = (node, visited = new Set()) => {\\n        visited.add(node)\\n        let bomb = 1\\n        for (let next of adj[node]) {\\n            if (!visited.has(next)) {\\n                bomb += dfs(next, visited)\\n            }\\n        }\\n        max = Math.max(max, bomb)\\n        return bomb\\n    }\\n\\n    for (let i=0; i<n; i++) dfs(i)\\n    return max\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587628,
                "title": "c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid detonate(vector<vector<int>>& bombs, vector<bool>& detonated, int i) {\\n    int n = bombs.size();\\n    for (int j = 0; j < n; j++) {\\n        if (detonated[j]) continue;\\n        long long dx = bombs[i][0] - bombs[j][0];\\n        long long dy = bombs[i][1] - bombs[j][1];\\n        long long d2 = dx * dx + dy * dy;\\n        long long r2 = (long long)bombs[i][2] * bombs[i][2];\\n        if (d2 <= r2) {\\n            detonated[j] = true;\\n            detonate(bombs, detonated, j);\\n        }\\n    }\\n}\\n\\nint maximumDetonation(vector<vector<int>>& bombs) {\\n    int n = bombs.size();\\n    int res = 1;\\n    for (int i = 0; i < n; i++) {\\n        vector<bool> detonated(n);\\n        detonated[i] = true;\\n        detonate(bombs, detonated, i);\\n        int cnt = 0;\\n        for (int j = 0; j < n; j++) {\\n            if (detonated[j]) cnt++;\\n        }\\n        res = max(res, cnt);\\n    }\\n    return res;\\n}    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid detonate(vector<vector<int>>& bombs, vector<bool>& detonated, int i) {\\n    int n = bombs.size();\\n    for (int j = 0; j < n; j++) {\\n        if (detonated[j]) continue;\\n        long long dx = bombs[i][0] - bombs[j][0];\\n        long long dy = bombs[i][1] - bombs[j][1];\\n        long long d2 = dx * dx + dy * dy;\\n        long long r2 = (long long)bombs[i][2] * bombs[i][2];\\n        if (d2 <= r2) {\\n            detonated[j] = true;\\n            detonate(bombs, detonated, j);\\n        }\\n    }\\n}\\n\\nint maximumDetonation(vector<vector<int>>& bombs) {\\n    int n = bombs.size();\\n    int res = 1;\\n    for (int i = 0; i < n; i++) {\\n        vector<bool> detonated(n);\\n        detonated[i] = true;\\n        detonate(bombs, detonated, i);\\n        int cnt = 0;\\n        for (int j = 0; j < n; j++) {\\n            if (detonated[j]) cnt++;\\n        }\\n        res = max(res, cnt);\\n    }\\n    return res;\\n}    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3482981,
                "title": "java-96-84-faster-one-added-check-boosted-it-from-8-faster",
                "content": "Let\\'s face it, this code can be pretty slow.\\nMy original run was only 8% faster.\\n\\nHowever, during the traversal of the nodes in the graph, if you find that ALL bombs exploded from a single source, then return early. This simple check boosted me up to 96.84% faster on my next run:\\n\\nif (maxDetonationsFromSingleSource == graph.size())\\n    return maxDetonationsFromSingleSource;\\n\\n\\n```\\nclass Solution {\\n    public int maximumDetonation(int[][] bombs) {\\n        \\n        Map<Integer, ArrayList<Integer>> graph = new HashMap<>();\\n        for (int i = 0; i < bombs.length; i++) {\\n            graph.put(i, new ArrayList<Integer>());\\n        }\\n\\n        // Check bombs within range of eachother \\n        for (int i = 0; i < bombs.length - 1; i++) {\\n            for (int j = 1; j < bombs.length; j++) {   \\n                double distance = calculateDistance(bombs[i][0], bombs[i][1], bombs[j][0], bombs[j][1]);\\n                if (distance <= bombs[i][2])\\n                    graph.get(i).add(j);\\n                if (distance <= bombs[j][2])\\n                    graph.get(j).add(i);\\n            }\\n        }\\n\\n        int maxDetonationsFromSingleSource = 0;\\n        Set<Integer> detonated = new HashSet<>();\\n\\n        for (int i = 0; i < bombs.length; i++) {\\n            detonated.clear();\\n            dfs(i, detonated, graph);\\n            maxDetonationsFromSingleSource = Math.max(maxDetonationsFromSingleSource, detonated.size());\\n            if (maxDetonationsFromSingleSource == graph.size())\\n                return maxDetonationsFromSingleSource;\\n        }\\n\\n        return maxDetonationsFromSingleSource;\\n    }\\n\\n    private double calculateDistance(int x1, int y1, int x2, int y2) {\\n        return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\\n    }\\n\\n    private void dfs(int node, Set<Integer> detonated, Map<Integer, ArrayList<Integer>> graph) {\\n        detonated.add(node);\\n        for (int nextNode : graph.get(node)) {\\n            if (!detonated.contains(nextNode))\\n                dfs(nextNode, detonated, graph);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumDetonation(int[][] bombs) {\\n        \\n        Map<Integer, ArrayList<Integer>> graph = new HashMap<>();\\n        for (int i = 0; i < bombs.length; i++) {\\n            graph.put(i, new ArrayList<Integer>());\\n        }\\n\\n        // Check bombs within range of eachother \\n        for (int i = 0; i < bombs.length - 1; i++) {\\n            for (int j = 1; j < bombs.length; j++) {   \\n                double distance = calculateDistance(bombs[i][0], bombs[i][1], bombs[j][0], bombs[j][1]);\\n                if (distance <= bombs[i][2])\\n                    graph.get(i).add(j);\\n                if (distance <= bombs[j][2])\\n                    graph.get(j).add(i);\\n            }\\n        }\\n\\n        int maxDetonationsFromSingleSource = 0;\\n        Set<Integer> detonated = new HashSet<>();\\n\\n        for (int i = 0; i < bombs.length; i++) {\\n            detonated.clear();\\n            dfs(i, detonated, graph);\\n            maxDetonationsFromSingleSource = Math.max(maxDetonationsFromSingleSource, detonated.size());\\n            if (maxDetonationsFromSingleSource == graph.size())\\n                return maxDetonationsFromSingleSource;\\n        }\\n\\n        return maxDetonationsFromSingleSource;\\n    }\\n\\n    private double calculateDistance(int x1, int y1, int x2, int y2) {\\n        return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\\n    }\\n\\n    private void dfs(int node, Set<Integer> detonated, Map<Integer, ArrayList<Integer>> graph) {\\n        detonated.add(node);\\n        for (int nextNode : graph.get(node)) {\\n            if (!detonated.contains(nextNode))\\n                dfs(nextNode, detonated, graph);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397596,
                "title": "c-dfs-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int distance(int x, int y, int x1, int y1)\\n    {\\n        double temp = sqrt(pow(x1-x,2) + pow(y1-y,2));\\n        return ceil(temp);\\n    }\\n    \\n    int dfs(int index, vector<int> &visited, vector<vector<int>> &graph)\\n    {\\n        int temp = 1;\\n        visited[index] = 1;\\n        for(auto x : graph[index])\\n        {\\n            if(visited[x] == 0)\\n            {\\n                temp += dfs(x,visited,graph);\\n            }\\n        }\\n        return temp;\\n    }\\n    \\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n = bombs.size();\\n        vector<vector<int>> graph(n);\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            for(int j = i+1 ; j < n ; j++)\\n            {\\n                int x = bombs[i][0];\\n                int y = bombs[i][1];\\n                int x1 = bombs[j][0];\\n                int y1 = bombs[j][1];\\n                int r = bombs[i][2];\\n                int r1 = bombs[j][2];\\n                int temp = distance(x,y,x1,y1);\\n                if(temp <= r)\\n                {\\n                    graph[i].push_back(j);\\n                }\\n                if(temp <= r1)\\n                {\\n                    graph[j].push_back(i);\\n                }\\n            }\\n        }\\n        vector<int> visited;\\n        vector<int> x(n,0);\\n        int ans = 1;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            visited = x;\\n            int temp = dfs(i,visited,graph);\\n            ans = max(ans,temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int distance(int x, int y, int x1, int y1)\\n    {\\n        double temp = sqrt(pow(x1-x,2) + pow(y1-y,2));\\n        return ceil(temp);\\n    }\\n    \\n    int dfs(int index, vector<int> &visited, vector<vector<int>> &graph)\\n    {\\n        int temp = 1;\\n        visited[index] = 1;\\n        for(auto x : graph[index])\\n        {\\n            if(visited[x] == 0)\\n            {\\n                temp += dfs(x,visited,graph);\\n            }\\n        }\\n        return temp;\\n    }\\n    \\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n = bombs.size();\\n        vector<vector<int>> graph(n);\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            for(int j = i+1 ; j < n ; j++)\\n            {\\n                int x = bombs[i][0];\\n                int y = bombs[i][1];\\n                int x1 = bombs[j][0];\\n                int y1 = bombs[j][1];\\n                int r = bombs[i][2];\\n                int r1 = bombs[j][2];\\n                int temp = distance(x,y,x1,y1);\\n                if(temp <= r)\\n                {\\n                    graph[i].push_back(j);\\n                }\\n                if(temp <= r1)\\n                {\\n                    graph[j].push_back(i);\\n                }\\n            }\\n        }\\n        vector<int> visited;\\n        vector<int> x(n,0);\\n        int ans = 1;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            visited = x;\\n            int temp = dfs(i,visited,graph);\\n            ans = max(ans,temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389055,
                "title": "dfs-but-with-a-binary-search-to-optimise-graph-building",
                "content": "# Intuition\\n1. Build an adjacency list of the bomb topology\\n2. DFS from each bomb and collect the maximum number of detonated bombs\\n2. We can apply some heuristics to optimize step 1.\\n\\n# Heuristic\\n1. Sort bombs in ascending x coordinate\\n2. Binary search for the first bomb that satisfies:\\n```bomb.x >= origin.x - origin.radius```\\n3. Start building the adjacency list from this bomb, skipping the `self` bomb in the process\\n4. Stop searching for reachable bombs once the current bomb stops satisfying 2., that is `bomb.x > origin.x + origin.radius `\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n- Space complexity: O(N)\\n\\n# Code\\n```py3\\nfrom collections import defaultdict\\nclass Solution:\\n    def is_reachable(self, origin, target):\\n        ox, oy, orad = origin\\n        tx, ty, _ = target\\n\\n        height = oy - ty\\n        width = ox - tx\\n\\n        return height * height + width * width <= orad * orad\\n    \\n    def get_leftmost_bomb_within_radius(self, start, bombs):\\n        l, r = 0, start - 1\\n        ox, oy, orad = origin = bombs[start]\\n        target = ox - orad\\n\\n        while l < r:\\n            mid = l + (r - l) // 2\\n            if bombs[mid][0] >= target:\\n                r = mid\\n            else:\\n                l = mid + 1\\n                \\n        return r if r == l else l\\n\\n    def detonate(self, i, graph, seen):\\n        if i in seen:\\n            return\\n        seen.add(i)\\n        for neighbour in graph[i]:\\n            self.detonate(neighbour, graph, seen)\\n\\n    def build_graph(self, bombs):\\n        N = len(bombs)\\n        graph = defaultdict(list)\\n        for i in range(N):\\n            leftmost = self.get_leftmost_bomb_within_radius(i, bombs)\\n            ox, oy, orad = origin = bombs[i]\\n            for j in range(leftmost, N):\\n                if i == j: continue\\n                if bombs[j][0] > ox + orad: # no chance these bombs onwards can be detonated\\n                    break\\n                if self.is_reachable(origin, bombs[j]):\\n                    graph[i].append(j)\\n        return graph\\n\\n    def maximumDetonation(self, bombs: List[List[int]]) -> int:\\n        bombs = sorted(bombs, key=lambda b: b[0]) # sorted in asc bomb.x\\n        graph = self.build_graph(bombs)\\n        detonated = 0        \\n        \\n        for i in range(len(bombs)):\\n            seen = set()\\n            self.detonate(i, graph, seen)\\n            detonated = max(detonated, len(seen))\\n        return detonated\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```bomb.x >= origin.x - origin.radius```\n```py3\\nfrom collections import defaultdict\\nclass Solution:\\n    def is_reachable(self, origin, target):\\n        ox, oy, orad = origin\\n        tx, ty, _ = target\\n\\n        height = oy - ty\\n        width = ox - tx\\n\\n        return height * height + width * width <= orad * orad\\n    \\n    def get_leftmost_bomb_within_radius(self, start, bombs):\\n        l, r = 0, start - 1\\n        ox, oy, orad = origin = bombs[start]\\n        target = ox - orad\\n\\n        while l < r:\\n            mid = l + (r - l) // 2\\n            if bombs[mid][0] >= target:\\n                r = mid\\n            else:\\n                l = mid + 1\\n                \\n        return r if r == l else l\\n\\n    def detonate(self, i, graph, seen):\\n        if i in seen:\\n            return\\n        seen.add(i)\\n        for neighbour in graph[i]:\\n            self.detonate(neighbour, graph, seen)\\n\\n    def build_graph(self, bombs):\\n        N = len(bombs)\\n        graph = defaultdict(list)\\n        for i in range(N):\\n            leftmost = self.get_leftmost_bomb_within_radius(i, bombs)\\n            ox, oy, orad = origin = bombs[i]\\n            for j in range(leftmost, N):\\n                if i == j: continue\\n                if bombs[j][0] > ox + orad: # no chance these bombs onwards can be detonated\\n                    break\\n                if self.is_reachable(origin, bombs[j]):\\n                    graph[i].append(j)\\n        return graph\\n\\n    def maximumDetonation(self, bombs: List[List[int]]) -> int:\\n        bombs = sorted(bombs, key=lambda b: b[0]) # sorted in asc bomb.x\\n        graph = self.build_graph(bombs)\\n        detonated = 0        \\n        \\n        for i in range(len(bombs)):\\n            seen = set()\\n            self.detonate(i, graph, seen)\\n            detonated = max(detonated, len(seen))\\n        return detonated\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974048,
                "title": "swift-bfs",
                "content": "\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O (n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    var bombs = [[Int]]()\\n    func maximumDetonation(_ bombs: [[Int]]) -> Int {\\n        self.bombs = bombs\\n        var maxCount = 1\\n        for i in 0..<bombs.count {\\n            var count = bfs(i)\\n            maxCount = max(maxCount, count)\\n        }\\n        return maxCount\\n    }\\n\\n    func bfs(_ index: Int) -> Int {\\n        var count = 1\\n        var queue = [Int]()\\n        queue.append(index)\\n        var visited = Array(repeating: false, count: bombs.count)\\n        visited[index] = true\\n\\n        while !queue.isEmpty {\\n            let top = queue.removeFirst()            \\n            for i in 0..<bombs.count {\\n                if !visited[i] && reachable(top, i) {\\n                   queue.append(i)\\n                   visited[i] = true\\n                   count += 1 \\n                }\\n            }\\n        }\\n\\n        return count\\n    }\\n\\n    func reachable(_ source: Int, _ target: Int) -> Bool {\\n        let bombSource = bombs[source]\\n        let bombTarget = bombs[target]\\n        let bombDiffX = bombSource[0] - bombTarget[0]\\n        let bombDiffY = bombSource[1] - bombTarget[1]\\n        let bombR = bombSource[2]\\n\\n        return bombR * bombR >= bombDiffX * bombDiffX + bombDiffY * bombDiffY\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    var bombs = [[Int]]()\\n    func maximumDetonation(_ bombs: [[Int]]) -> Int {\\n        self.bombs = bombs\\n        var maxCount = 1\\n        for i in 0..<bombs.count {\\n            var count = bfs(i)\\n            maxCount = max(maxCount, count)\\n        }\\n        return maxCount\\n    }\\n\\n    func bfs(_ index: Int) -> Int {\\n        var count = 1\\n        var queue = [Int]()\\n        queue.append(index)\\n        var visited = Array(repeating: false, count: bombs.count)\\n        visited[index] = true\\n\\n        while !queue.isEmpty {\\n            let top = queue.removeFirst()            \\n            for i in 0..<bombs.count {\\n                if !visited[i] && reachable(top, i) {\\n                   queue.append(i)\\n                   visited[i] = true\\n                   count += 1 \\n                }\\n            }\\n        }\\n\\n        return count\\n    }\\n\\n    func reachable(_ source: Int, _ target: Int) -> Bool {\\n        let bombSource = bombs[source]\\n        let bombTarget = bombs[target]\\n        let bombDiffX = bombSource[0] - bombTarget[0]\\n        let bombDiffY = bombSource[1] - bombTarget[1]\\n        let bombR = bombSource[2]\\n\\n        return bombR * bombR >= bombDiffX * bombDiffX + bombDiffY * bombDiffY\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2857744,
                "title": "python-bfs-commented",
                "content": "```\\nclass Solution:\\n    def maximumDetonation(self, bombs: List[List[int]]) -> int:\\n        def is_connected(a,b):\\n            \\'\\'\\'\\n            return whether two points should be connected or not.\\n            \\'\\'\\'\\n            x1, y1, r1 = bombs[a]\\n            x2, y2, r2 = bombs[b]\\n            dist = math.sqrt((x1-x2)**2 + (y1-y2)**2)\\n            return dist <= r1\\n\\n        q = deque()\\n        def bfs(start_node):\\n            \\'\\'\\'\\n            This function runs bfs from the start node, and returns the \\n            number of points we can detonate starting at that point.\\n            \\'\\'\\'\\n            q.append(start_node)\\n            visited.add(start_node)\\n            detonated_count = 0  \\n            while q:\\n                curr = q.popleft()\\n                detonated_count += 1 \\n                for child in graph[curr]:\\n                    if child not in visited:\\n                        visited.add(child)\\n                        q.append(child)\\n            return detonated_count\\n        \\n        # 1) Build The graph by connecting points in the same range\\n        graph = defaultdict(list)\\n        points = range(len(bombs))\\n        # Undirected Graph: try all possible combinations of lenghth 2 (p1, p2)\\n        for a, b in combinations(points, 2):\\n            if is_connected(a, b):\\n                graph[a].append(b)\\n            if is_connected(b, a):\\n                graph[b].append(a)\\n\\n        # 2) Run BFS from each point and take the maximum of them\\n        maxCount = 1\\n        for point in points:\\n            if graph[point]:\\n                visited = set()\\n                maxCount = max(maxCount, bfs(point))\\n            \\n        return maxCount\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maximumDetonation(self, bombs: List[List[int]]) -> int:\\n        def is_connected(a,b):\\n            \\'\\'\\'\\n            return whether two points should be connected or not.\\n            \\'\\'\\'\\n            x1, y1, r1 = bombs[a]\\n            x2, y2, r2 = bombs[b]\\n            dist = math.sqrt((x1-x2)**2 + (y1-y2)**2)\\n            return dist <= r1\\n\\n        q = deque()\\n        def bfs(start_node):\\n            \\'\\'\\'\\n            This function runs bfs from the start node, and returns the \\n            number of points we can detonate starting at that point.\\n            \\'\\'\\'\\n            q.append(start_node)\\n            visited.add(start_node)\\n            detonated_count = 0  \\n            while q:\\n                curr = q.popleft()\\n                detonated_count += 1 \\n                for child in graph[curr]:\\n                    if child not in visited:\\n                        visited.add(child)\\n                        q.append(child)\\n            return detonated_count\\n        \\n        # 1) Build The graph by connecting points in the same range\\n        graph = defaultdict(list)\\n        points = range(len(bombs))\\n        # Undirected Graph: try all possible combinations of lenghth 2 (p1, p2)\\n        for a, b in combinations(points, 2):\\n            if is_connected(a, b):\\n                graph[a].append(b)\\n            if is_connected(b, a):\\n                graph[b].append(a)\\n\\n        # 2) Run BFS from each point and take the maximum of them\\n        maxCount = 1\\n        for point in points:\\n            if graph[point]:\\n                visited = set()\\n                maxCount = max(maxCount, bfs(point))\\n            \\n        return maxCount\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2856171,
                "title": "c-basic-bfs-approach-self-explainatory",
                "content": "```\\nbool isInside(int i,int j,vector<vector<int>> &bombs)\\n    {\\n        long long x1,y1,r1,x2,y2,r2;\\n        x1=bombs[i][0];\\n        y1=bombs[i][1];\\n        r1=bombs[i][2];\\n        x2=abs(x1-bombs[j][0]);\\n        y2=abs(y1-bombs[j][1]);\\n        if(x2*x2+y2*y2<=r1*r1)\\n            return 1;\\n        else\\n            return 0;\\n    }\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int count = 1;\\n        int ans = 1;\\n        for(int i=0;i<bombs.size();i++)\\n        {\\n            count = 1;\\n            queue<int> q;\\n            vector<bool> vis(bombs.size(),0);\\n            vis[i] = 1;\\n            q.push(i);\\n            while(!q.empty())\\n            {\\n                int temp = q.front();\\n                q.pop();\\n                for(int j=0;j<bombs.size();j++)\\n                {\\n                    if(temp==j)\\n                        continue;\\n                    \\n                    if(isInside(temp,j,bombs)&&vis[j]==0)\\n                    {\\n                        count++;\\n                        q.push(j);\\n                        vis[j] = 1;\\n                    }\\n                }\\n            }\\n            ans = max(count,ans);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nbool isInside(int i,int j,vector<vector<int>> &bombs)\\n    {\\n        long long x1,y1,r1,x2,y2,r2;\\n        x1=bombs[i][0];\\n        y1=bombs[i][1];\\n        r1=bombs[i][2];\\n        x2=abs(x1-bombs[j][0]);\\n        y2=abs(y1-bombs[j][1]);\\n        if(x2*x2+y2*y2<=r1*r1)\\n            return 1;\\n        else\\n            return 0;\\n    }\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int count = 1;\\n        int ans = 1;\\n        for(int i=0;i<bombs.size();i++)\\n        {\\n            count = 1;\\n            queue<int> q;\\n            vector<bool> vis(bombs.size(),0);\\n            vis[i] = 1;\\n            q.push(i);\\n            while(!q.empty())\\n            {\\n                int temp = q.front();\\n                q.pop();\\n                for(int j=0;j<bombs.size();j++)\\n                {\\n                    if(temp==j)\\n                        continue;\\n                    \\n                    if(isInside(temp,j,bombs)&&vis[j]==0)\\n                    {\\n                        count++;\\n                        q.push(j);\\n                        vis[j] = 1;\\n                    }\\n                }\\n            }\\n            ans = max(count,ans);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2830807,
                "title": "python-simple-and-clean-dfs-bfs-solutions",
                "content": "```\\nfrom collections import deque\\nfrom itertools import combinations\\nfrom math import hypot\\n\\n\\nclass Solution:\\n    def maximumDetonation(self, bombs: list[list[int]]) -> int:\\n        n = len(bombs)\\n        g = [[] for _ in range(n)]\\n\\n        for i, j in combinations(range(n), 2):\\n            (x1, y1, r1), (x2, y2, r2) = bombs[i], bombs[j]\\n\\n            if (d := hypot(x1 - x2, y1 - y2)) <= r1:\\n                g[i].append(j)\\n\\n            if d <= r2:\\n                g[j].append(i)\\n\\n        return self.max_size_of_a_component_dfs(g)\\n        # return self.max_size_of_a_component_bfs(g)\\n\\n    @staticmethod\\n    def max_size_of_a_component_dfs(g: list[list[int]]) -> int:\\n        n = len(g)\\n\\n        def dfs(u: int, visited: list[bool]) -> int:\\n            visited[u] = True\\n\\n            return 1 + sum(dfs(v, visited) for v in g[u] if not visited[v])\\n\\n        return max(dfs(i, [False] * n) for i in range(n))\\n\\n    @staticmethod\\n    def max_size_of_a_component_bfs(g: list[list[int]]) -> int:\\n        n = len(g)\\n\\n        q = deque()\\n\\n        def bfs(start: int) -> int:\\n            visited = [False] * n\\n\\n            def add_to_q(node: int):\\n                q.append(node)\\n                visited[node] = True\\n\\n            add_to_q(start)\\n\\n            while q:\\n                u = q.popleft()\\n\\n                for v in g[u]:\\n                    if not visited[v]:\\n                        add_to_q(v)\\n\\n            return sum(visited)\\n\\n        return max(bfs(i) for i in range(n))\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\nfrom itertools import combinations\\nfrom math import hypot\\n\\n\\nclass Solution:\\n    def maximumDetonation(self, bombs: list[list[int]]) -> int:\\n        n = len(bombs)\\n        g = [[] for _ in range(n)]\\n\\n        for i, j in combinations(range(n), 2):\\n            (x1, y1, r1), (x2, y2, r2) = bombs[i], bombs[j]\\n\\n            if (d := hypot(x1 - x2, y1 - y2)) <= r1:\\n                g[i].append(j)\\n\\n            if d <= r2:\\n                g[j].append(i)\\n\\n        return self.max_size_of_a_component_dfs(g)\\n        # return self.max_size_of_a_component_bfs(g)\\n\\n    @staticmethod\\n    def max_size_of_a_component_dfs(g: list[list[int]]) -> int:\\n        n = len(g)\\n\\n        def dfs(u: int, visited: list[bool]) -> int:\\n            visited[u] = True\\n\\n            return 1 + sum(dfs(v, visited) for v in g[u] if not visited[v])\\n\\n        return max(dfs(i, [False] * n) for i in range(n))\\n\\n    @staticmethod\\n    def max_size_of_a_component_bfs(g: list[list[int]]) -> int:\\n        n = len(g)\\n\\n        q = deque()\\n\\n        def bfs(start: int) -> int:\\n            visited = [False] * n\\n\\n            def add_to_q(node: int):\\n                q.append(node)\\n                visited[node] = True\\n\\n            add_to_q(start)\\n\\n            while q:\\n                u = q.popleft()\\n\\n                for v in g[u]:\\n                    if not visited[v]:\\n                        add_to_q(v)\\n\\n            return sum(visited)\\n\\n        return max(bfs(i) for i in range(n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788912,
                "title": "simple-bfs-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI think its easy to understand if we think that radius of all circle are same. In that case \\nIf we have 3 point A,B,C\\n\\nA reachable to B\\nB reachable to A\\nC is not reachable from A, B\\n\\nIn that case, if we did not find C while exploring A then we will never going to find A while exploring C\\n\\nso we can iterate all the bombs by maintaining single visit array and return maxValue.\\n\\nNow the thing is complicated here because the radius are not same so if we \\nwe have 3 points A, B, C\\n\\nA reachable to B\\nB reachable to A\\nC is not reachable from A, B\\n\\nbut it possible that C can reach to A and B. In that case while exploring C we can encounter A and B again. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nIn solution, If you can see I used two visited array. The outer one is for visiting all the bomb point. If i have explored B while exploring A then i don\\'t need to explore B again. \\n\\nIf I am exploring C and I found A then i have to explore A again. \\n\\n# Complexity\\n- Time complexity: O(V * V)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(V)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumDetonation(int[][] bombs) {\\n        int max = 0;\\n        boolean[] visited = new boolean[bombs.length];\\n        for(int i =0; i<bombs.length; i++){\\n            if(!visited[i]){\\n                Queue<Integer> queue = new LinkedList<>();\\n                boolean[] currVisited = new boolean[bombs.length];\\n                queue.offer(i);\\n                int count =1;\\n                currVisited[i] = true;\\n                visited[i] = true;\\n                while(!queue.isEmpty()){\\n                    int index = queue.poll();\\n                    int[] curBomb = bombs[index];\\n                    for(int j=0; j<bombs.length; j++){\\n                        if(!currVisited[j] && isReachable(curBomb, bombs[j])){\\n                            visited[i] = true;\\n                            currVisited[j] = true;\\n                            count++;\\n                            queue.offer(j);\\n                        }           \\n                    }\\n                }       \\n                max = Math.max(max, count);\\n            }\\n        }        \\n        return max;\\n    }\\n\\n    private boolean isReachable(int[] bombA, int[] bombB) {\\n        long dx = bombA[0] - bombB[0], dy = bombA[1] - bombB[1], radius = bombA[2];\\n        long distance =  dx * dx + dy * dy;\\n        return distance <= radius * radius;\\n    }\\n\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumDetonation(int[][] bombs) {\\n        int max = 0;\\n        boolean[] visited = new boolean[bombs.length];\\n        for(int i =0; i<bombs.length; i++){\\n            if(!visited[i]){\\n                Queue<Integer> queue = new LinkedList<>();\\n                boolean[] currVisited = new boolean[bombs.length];\\n                queue.offer(i);\\n                int count =1;\\n                currVisited[i] = true;\\n                visited[i] = true;\\n                while(!queue.isEmpty()){\\n                    int index = queue.poll();\\n                    int[] curBomb = bombs[index];\\n                    for(int j=0; j<bombs.length; j++){\\n                        if(!currVisited[j] && isReachable(curBomb, bombs[j])){\\n                            visited[i] = true;\\n                            currVisited[j] = true;\\n                            count++;\\n                            queue.offer(j);\\n                        }           \\n                    }\\n                }       \\n                max = Math.max(max, count);\\n            }\\n        }        \\n        return max;\\n    }\\n\\n    private boolean isReachable(int[] bombA, int[] bombB) {\\n        long dx = bombA[0] - bombB[0], dy = bombA[1] - bombB[1], radius = bombA[2];\\n        long distance =  dx * dx + dy * dy;\\n        return distance <= radius * radius;\\n    }\\n\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2725731,
                "title": "why-the-answer-1-for-this",
                "content": "[[1,1,100000],[100000,100000,1]]",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2663847,
                "title": "dfs-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int dfs(int node, unordered_map<int, vector<int> > &mp, vector<bool> &vis)\\n    {\\n        if(vis[node]){\\n           return 0;\\n        }\\n        vis[node]=true;\\n        int num=1;\\n        for(auto it: mp[node])\\n        {\\n            num +=dfs(it,mp,vis);\\n        }\\n        return num;\\n    }\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        unordered_map<int, vector<int> > mp;\\n        int n=bombs.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            long long  x1,y1,r1;\\n            x1=bombs[i][0];\\n            y1=bombs[i][1];\\n            r1=bombs[i][2];\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i!=j)\\n                {\\n                     long long x2,y2,r2;\\n                     x2=abs(x1-bombs[j][0]);\\n                     y2=abs(y1-bombs[j][1]);\\n                    if(x2*x2+y2*y2<=r1*r1)\\n                    {\\n                        mp[i].push_back(j);\\n                    }\\n                }\\n            }\\n        }\\n       \\n        int maxi=-1;\\n        for(int i=0;i<bombs.size();i++)\\n        {\\n            vector<bool> vis(bombs.size(),false);\\n          maxi=max(maxi,dfs(i,mp,vis));\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int node, unordered_map<int, vector<int> > &mp, vector<bool> &vis)\\n    {\\n        if(vis[node]){\\n           return 0;\\n        }\\n        vis[node]=true;\\n        int num=1;\\n        for(auto it: mp[node])\\n        {\\n            num +=dfs(it,mp,vis);\\n        }\\n        return num;\\n    }\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        unordered_map<int, vector<int> > mp;\\n        int n=bombs.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            long long  x1,y1,r1;\\n            x1=bombs[i][0];\\n            y1=bombs[i][1];\\n            r1=bombs[i][2];\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i!=j)\\n                {\\n                     long long x2,y2,r2;\\n                     x2=abs(x1-bombs[j][0]);\\n                     y2=abs(y1-bombs[j][1]);\\n                    if(x2*x2+y2*y2<=r1*r1)\\n                    {\\n                        mp[i].push_back(j);\\n                    }\\n                }\\n            }\\n        }\\n       \\n        int maxi=-1;\\n        for(int i=0;i<bombs.size();i++)\\n        {\\n            vector<bool> vis(bombs.size(),false);\\n          maxi=max(maxi,dfs(i,mp,vis));\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612060,
                "title": "easy-understanding-python-faster-than-85",
                "content": "Don\\'t be afraid about the size of my code, I just break this down in classes and methods! What I did was converte the bombs in a graph, when the ditance between one bomb and another is smaller than the radius of the source bomb, we connect those two bombs on the graph. \\n\\nAfter this, we can do a DFS approach and use the visited set as the size of the bomb chain. \\n\\nThe biggest time complexity is the DFS algorithms that is O(V + E), where V is the number of vertices (bombs) and E is the number of edges (connected bombs).\\n\\n\\tfrom collections import defaultdict\\n\\n\\tclass Solution:\\n\\t\\tdef maximumDetonation(self, bombs: List[List[int]]) -> int:\\n        \\n\\t\\t\\tself.graph = self.bombs_to_graph(bombs)\\n\\t\\t\\tprint(self.graph.graph)\\n\\t\\t\\tans = 1\\n\\t\\t\\tself.dp = [0]*len(bombs)\\n\\t\\t\\tfor i in range(len(bombs)):\\n\\t\\t\\t\\tvisited = set()\\n\\t\\t\\t\\tself.DFS(i, visited)\\n\\t\\t\\t\\tans = max(ans, len(visited))\\n\\t\\t\\treturn ans\\n\\n\\n\\n\\n\\t\\tdef DFS(self, v, visited):\\n\\n\\t\\t\\tvisited.add(v)\\n\\t\\t\\tfor neigh in self.graph.graph[v]:\\n\\t\\t\\t\\tif neigh not in visited:\\n\\t\\t\\t\\t\\tself.DFS(neigh, visited)\\n\\n\\t\\tdef bombs_to_graph(self, bombs):\\n\\t\\t\\tgraph = Graph()\\n\\t\\t\\tfor i_s, source in enumerate(bombs):\\n\\t\\t\\t\\tfor i_d, dest in enumerate(bombs):\\n\\t\\t\\t\\t\\tif i_s == i_d: continue\\n\\n\\t\\t\\t\\t\\tif self.is_on_range(source, dest):\\n\\t\\t\\t\\t\\t\\tgraph.add_edge(i_s, i_d)\\n\\n\\t\\t\\treturn graph\\n\\n\\t\\tdef is_on_range(self, source, dest):\\n\\n\\t\\t\\tdist = ((source[0] - dest[0])**2 + (source[1] - dest[1])**2)**0.5\\n\\t\\t\\treturn dist <= source[2]\\n     \\n        \\n\\tclass Graph:\\n\\t\\tdef __init__(self):\\n\\t\\t\\tself.graph = defaultdict(list)\\n\\n\\t\\tdef add_edge(self, s, d):\\n\\t\\t\\tself.graph[s].append(d)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "Don\\'t be afraid about the size of my code, I just break this down in classes and methods! What I did was converte the bombs in a graph, when the ditance between one bomb and another is smaller than the radius of the source bomb, we connect those two bombs on the graph. \\n\\nAfter this, we can do a DFS approach and use the visited set as the size of the bomb chain. \\n\\nThe biggest time complexity is the DFS algorithms that is O(V + E), where V is the number of vertices (bombs) and E is the number of edges (connected bombs).\\n\\n\\tfrom collections import defaultdict\\n\\n\\tclass Solution:\\n\\t\\tdef maximumDetonation(self, bombs: List[List[int]]) -> int:\\n        \\n\\t\\t\\tself.graph = self.bombs_to_graph(bombs)\\n\\t\\t\\tprint(self.graph.graph)\\n\\t\\t\\tans = 1\\n\\t\\t\\tself.dp = [0]*len(bombs)\\n\\t\\t\\tfor i in range(len(bombs)):\\n\\t\\t\\t\\tvisited = set()\\n\\t\\t\\t\\tself.DFS(i, visited)\\n\\t\\t\\t\\tans = max(ans, len(visited))\\n\\t\\t\\treturn ans\\n\\n\\n\\n\\n\\t\\tdef DFS(self, v, visited):\\n\\n\\t\\t\\tvisited.add(v)\\n\\t\\t\\tfor neigh in self.graph.graph[v]:\\n\\t\\t\\t\\tif neigh not in visited:\\n\\t\\t\\t\\t\\tself.DFS(neigh, visited)\\n\\n\\t\\tdef bombs_to_graph(self, bombs):\\n\\t\\t\\tgraph = Graph()\\n\\t\\t\\tfor i_s, source in enumerate(bombs):\\n\\t\\t\\t\\tfor i_d, dest in enumerate(bombs):\\n\\t\\t\\t\\t\\tif i_s == i_d: continue\\n\\n\\t\\t\\t\\t\\tif self.is_on_range(source, dest):\\n\\t\\t\\t\\t\\t\\tgraph.add_edge(i_s, i_d)\\n\\n\\t\\t\\treturn graph\\n\\n\\t\\tdef is_on_range(self, source, dest):\\n\\n\\t\\t\\tdist = ((source[0] - dest[0])**2 + (source[1] - dest[1])**2)**0.5\\n\\t\\t\\treturn dist <= source[2]\\n     \\n        \\n\\tclass Graph:\\n\\t\\tdef __init__(self):\\n\\t\\t\\tself.graph = defaultdict(list)\\n\\n\\t\\tdef add_edge(self, s, d):\\n\\t\\t\\tself.graph[s].append(d)",
                "codeTag": "Java"
            },
            {
                "id": 2606176,
                "title": "java-dfs",
                "content": "```\\nclass Solution {\\n    public int maximumDetonation(int[][] bombs) {\\n        int n = bombs.length;\\n        Circle[] circles = new Circle[n];\\n        for(int i=0;i<n;i++) circles[i] = new Circle(bombs[i][0],bombs[i][1],bombs[i][2]);\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for(int i=0;i<n;i++) graph.add(new ArrayList<>());\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==j) continue;\\n                if(circles[i].canDetonate(circles[j]))\\n                    graph.get(i).add(j);\\n            }\\n        }\\n        int answer = 0;\\n        for(int i=0;i<n;i++) answer = Math.max(answer,dfs(graph,new boolean[n],i));\\n        return answer;\\n    }\\n    private int dfs(List<List<Integer>> graph, boolean[] visited, int node){\\n        int res = 1;\\n        visited[node] = true;\\n        for(int child: graph.get(node)){\\n            if(visited[child]) continue;\\n            res += dfs(graph,visited,child);\\n        }\\n        return res;\\n    }\\n}\\nclass Circle{\\n    int x;\\n    int y;\\n    int r;\\n\\n    public Circle(int x, int y, int r) {\\n        this.x = x;\\n        this.y = y;\\n        this.r = r;\\n    }\\n    public boolean canDetonate(Circle other){\\n        return this.r>=Math.sqrt(Math.pow(Math.abs(this.x-other.x),2)+Math.pow(Math.abs(this.y-other.y),2));\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumDetonation(int[][] bombs) {\\n        int n = bombs.length;\\n        Circle[] circles = new Circle[n];\\n        for(int i=0;i<n;i++) circles[i] = new Circle(bombs[i][0],bombs[i][1],bombs[i][2]);\\n        List<List<Integer>> graph = new ArrayList<>();\\n        for(int i=0;i<n;i++) graph.add(new ArrayList<>());\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==j) continue;\\n                if(circles[i].canDetonate(circles[j]))\\n                    graph.get(i).add(j);\\n            }\\n        }\\n        int answer = 0;\\n        for(int i=0;i<n;i++) answer = Math.max(answer,dfs(graph,new boolean[n],i));\\n        return answer;\\n    }\\n    private int dfs(List<List<Integer>> graph, boolean[] visited, int node){\\n        int res = 1;\\n        visited[node] = true;\\n        for(int child: graph.get(node)){\\n            if(visited[child]) continue;\\n            res += dfs(graph,visited,child);\\n        }\\n        return res;\\n    }\\n}\\nclass Circle{\\n    int x;\\n    int y;\\n    int r;\\n\\n    public Circle(int x, int y, int r) {\\n        this.x = x;\\n        this.y = y;\\n        this.r = r;\\n    }\\n    public boolean canDetonate(Circle other){\\n        return this.r>=Math.sqrt(Math.pow(Math.abs(this.x-other.x),2)+Math.pow(Math.abs(this.y-other.y),2));\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2551258,
                "title": "simple-bfs-c-93-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>v;\\n    vector<bool>bol;\\n    long long  c=0;\\n    void dfs(int i)\\n    {\\n        bol[i]=true;\\n        c++;\\n        // cout<<i<<\" \";\\n        for(auto c:v[i])\\n        {\\n            if(!bol[c])\\n                dfs(c);\\n        }\\n    }\\n    int maximumDetonation(vector<vector<int>>& b) {\\n        v = vector<vector<int>>(b.size());\\n       \\n        for(int i =0;i<v.size();++i)\\n        {\\n            for(int j =i+1;j<v.size();++j)\\n            {\\n                long long x1 = pow((b[i][0]-b[j][0]),2)+.25;\\n                long long x2 = pow((b[i][1]-b[j][1]),2)+.25;\\n                \\n                long long g = ceil(sqrt(x1+x2));\\n                if(g<=b[i][2])\\n                    v[i].push_back(j);\\n                if(g<=b[j][2])\\n                    v[j].push_back(i); \\n            }\\n        }\\n        \\n        long long k =0;\\n        for(int i=0;i<v.size();++i)\\n        {\\n             bol = vector<bool>(b.size());\\n                dfs(i),k = max(k,c),c=0;\\n        }\\n    \\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>v;\\n    vector<bool>bol;\\n    long long  c=0;\\n    void dfs(int i)\\n    {\\n        bol[i]=true;\\n        c++;\\n        // cout<<i<<\" \";\\n        for(auto c:v[i])\\n        {\\n            if(!bol[c])\\n                dfs(c);\\n        }\\n    }\\n    int maximumDetonation(vector<vector<int>>& b) {\\n        v = vector<vector<int>>(b.size());\\n       \\n        for(int i =0;i<v.size();++i)\\n        {\\n            for(int j =i+1;j<v.size();++j)\\n            {\\n                long long x1 = pow((b[i][0]-b[j][0]),2)+.25;\\n                long long x2 = pow((b[i][1]-b[j][1]),2)+.25;\\n                \\n                long long g = ceil(sqrt(x1+x2));\\n                if(g<=b[i][2])\\n                    v[i].push_back(j);\\n                if(g<=b[j][2])\\n                    v[j].push_back(i); \\n            }\\n        }\\n        \\n        long long k =0;\\n        for(int i=0;i<v.size();++i)\\n        {\\n             bol = vector<bool>(b.size());\\n                dfs(i),k = max(k,c),c=0;\\n        }\\n    \\n        return k;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2544555,
                "title": "wrong-test-cases-bad-question",
                "content": "```\\n// [[1,1,100000],[100000,100000,1]] , this test case  answer is 2 but it shows 1 :(  \\n\\nvoid dfs(int node,vector<int>&vis, vector<int> adj[]){\\n  vis[node]=1;\\n  for(auto it: adj[node]){\\n    if(vis[it]==0)dfs(it,vis,adj);\\n  }\\n}\\n\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n      int n = bombs.size();\\n      vector<int> adj[n];\\n      \\n      for(int i=0;i<bombs.size();i++){\\n        long long  z = (long long)bombs[i][2]*bombs[i][2];\\n        for(int j=0;j<bombs.size();j++){\\n          if(i==j)continue;\\n          long long  yd = bombs[j][1] - bombs[i][1];\\n          long long  xd = bombs[j][0] - bombs[j][0];\\n          long long  dist = (yd*yd) + (xd*xd);\\n          cout<<z<<\" \"<<dist<<\"\\\\n\";\\n          if(dist<=z){\\n            adj[i].push_back(j);\\n          }\\n        }\\n      }\\n      \\n      int ans=1;\\n      for(int i=0;i<n;i++){\\n        vector<int> vis(n,0);\\n        dfs(i,vis,adj);\\n        \\n        int cnt=0;\\n        for(int j=0;j<n;j++) if(vis[j])cnt++; \\n      \\n        ans = max(ans,cnt);\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// [[1,1,100000],[100000,100000,1]] , this test case  answer is 2 but it shows 1 :(  \\n\\nvoid dfs(int node,vector<int>&vis, vector<int> adj[]){\\n  vis[node]=1;\\n  for(auto it: adj[node]){\\n    if(vis[it]==0)dfs(it,vis,adj);\\n  }\\n}\\n\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n      int n = bombs.size();\\n      vector<int> adj[n];\\n      \\n      for(int i=0;i<bombs.size();i++){\\n        long long  z = (long long)bombs[i][2]*bombs[i][2];\\n        for(int j=0;j<bombs.size();j++){\\n          if(i==j)continue;\\n          long long  yd = bombs[j][1] - bombs[i][1];\\n          long long  xd = bombs[j][0] - bombs[j][0];\\n          long long  dist = (yd*yd) + (xd*xd);\\n          cout<<z<<\" \"<<dist<<\"\\\\n\";\\n          if(dist<=z){\\n            adj[i].push_back(j);\\n          }\\n        }\\n      }\\n      \\n      int ans=1;\\n      for(int i=0;i<n;i++){\\n        vector<int> vis(n,0);\\n        dfs(i,vis,adj);\\n        \\n        int cnt=0;\\n        for(int j=0;j<n;j++) if(vis[j])cnt++; \\n      \\n        ans = max(ans,cnt);\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2518760,
                "title": "c-easy-solution-using-dfs-euclidean-distance",
                "content": "* Easy to understand, must upvote! \\uD83D\\uDE43\\n\\n```\\nclass Solution {\\npublic:\\n    int DFS(unordered_map<int, vector<int>> &graph, int bomb, vector<bool> &isVisited) {\\n        if(isVisited[bomb])\\n            return 0;\\n        isVisited[bomb] = true;\\n        int count = 1;\\n        for(auto &x: graph[bomb]) {\\n            count += DFS(graph, x, isVisited);\\n        }\\n        return count;\\n    }\\n    \\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        unordered_map<int, vector<int>> graph;\\n        for(int i = 0; i < bombs.size(); i++) {\\n            double distance = 0.0;\\n            for(int j = 0; j < bombs.size(); j++) {\\n                distance = sqrt(pow((bombs[j][0]-bombs[i][0]), 2) + pow((bombs[j][1]-bombs[i][1]), 2));\\n                if(distance <= bombs[i][2]) {\\n                    graph[i].push_back(j);\\n                }\\n            }\\n        }\\n        int maxDetonated = 0;\\n        vector<bool> isVisited(bombs.size(), false);\\n        for(int i = 0; i < bombs.size(); i++) {\\n            fill(isVisited.begin(), isVisited.end(), false);\\n            int detonated = DFS(graph, i, isVisited);\\n            maxDetonated = max(maxDetonated, detonated);\\n        }\\n        return maxDetonated;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int DFS(unordered_map<int, vector<int>> &graph, int bomb, vector<bool> &isVisited) {\\n        if(isVisited[bomb])\\n            return 0;\\n        isVisited[bomb] = true;\\n        int count = 1;\\n        for(auto &x: graph[bomb]) {\\n            count += DFS(graph, x, isVisited);\\n        }\\n        return count;\\n    }\\n    \\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        unordered_map<int, vector<int>> graph;\\n        for(int i = 0; i < bombs.size(); i++) {\\n            double distance = 0.0;\\n            for(int j = 0; j < bombs.size(); j++) {\\n                distance = sqrt(pow((bombs[j][0]-bombs[i][0]), 2) + pow((bombs[j][1]-bombs[i][1]), 2));\\n                if(distance <= bombs[i][2]) {\\n                    graph[i].push_back(j);\\n                }\\n            }\\n        }\\n        int maxDetonated = 0;\\n        vector<bool> isVisited(bombs.size(), false);\\n        for(int i = 0; i < bombs.size(); i++) {\\n            fill(isVisited.begin(), isVisited.end(), false);\\n            int detonated = DFS(graph, i, isVisited);\\n            maxDetonated = max(maxDetonated, detonated);\\n        }\\n        return maxDetonated;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564767,
                "content": [
                    {
                        "username": "darkalarm",
                        "content": "When I read the question, my first thought was using union find for this question. But after a few test cases, I could understand that the question is actually about a directed graph. Union Find works for an undirected graph.\\n\\n![image](https://assets.leetcode.com/users/images/f7fb76c8-9ab7-4044-bd5f-569b21621f01_1639243400.360309.png)\\n\\nYou can see from the example above, the green circle can detonate the blue circle. But not the other way round. This means, there will be a directed edge from green circle to blue circule.\\n\\nThe question is asking us to find the maximum number of connected nodes in this graph. BFS sounds like the best approach."
                    },
                    {
                        "username": "reassurance",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) \\nMaybe I can help you in understanding why DFS might be faster than BFS although the logic of this question can be handled by both. \\nIn my DFS code, it is seen that if we trail down the path of the possible bombs that can be detonated by the current bomb, we can see that we have a chance to discover bombs that might trigger a **CHAIN** reaction. In other words, a queue in BFS will take longer time to finish and might include bombs that are isolated thereby reducing the impact. \\nAlthough I would not fully agree with my explanation above, this intuition sounded right to me.\\n\\nWould love to see someone prove this!"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "thats good, but how about dfs, I did BFS but my beats were ery low . Seen some solutions thst used DFS, they were more efficient. Don\\'t know the logic why, but it is what it is. try that too and tell me too if you understand why DFS is better than BFS in this case."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "great job, bro"
                    },
                    {
                        "username": "prateek4463",
                        "content": "thanks ! "
                    },
                    {
                        "username": "anfatum",
                        "content": "`bombs` =\\n[[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]\\n`Expected`\\n1\\n\\nAren\\'t [69,51,7] and [65,59,3] intersecting thus there is more than one explosion? "
                    },
                    {
                        "username": "blackhat130",
                        "content": "[@LakshayTheGupta](/LakshayTheGupta) Haha, Great Explanation. "
                    },
                    {
                        "username": "LakshayTheGupta",
                        "content": "[@piudpie](/piudpie) No that must be common sense that to activate  the bomb , it should be inside the range of the exploding bomb. The bomb is not itself a circle with radius R. \\nConclusion : we lack common sense and leetcode is trying to prove in every problem \\uD83E\\uDD23. (I had 2-3 wrong submissions before figuring this issue out \\uD83E\\uDD79)"
                    },
                    {
                        "username": "piudpie",
                        "content": "[@lohani](/lohani) They should have mentioned it in the problem statement, thank you for clarifying though!"
                    },
                    {
                        "username": "psionl0",
                        "content": "the distance between the 2 bombs is sqrt((65-69)^2 + (59-51)^2) = 8.9 which is greater than the range of either bomb."
                    },
                    {
                        "username": "pulkit_singhall",
                        "content": "[@lohani](/lohani) What is the condition for centre to be inside the radius?"
                    },
                    {
                        "username": "lohani",
                        "content": "I stumbled on this same issue. But there is a catch in the problem statement. The second bomb will only be detonated if it\\'s center comes inside the radius of the first bomb. Just intersection of circles is not enough."
                    },
                    {
                        "username": "hengjunlin1129",
                        "content": "I figured out that\\nbomb A can trigger bomb B\\nbomb C can trigger bomb B\\nbomb B cannot trigger bomb A and C\\nbomb A, C cannot trigger each other\\nbut in Union Find A B C will be in same group. (cause A->B, C->B"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "but if c can detonate b, then b must also be able to detonate c"
                    },
                    {
                        "username": "tejasX",
                        "content": "Thanks. I got my mistake."
                    },
                    {
                        "username": "drekker007",
                        "content": "Thank you so much bro!! You made me realize my mistakes!!"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "[@R4Ks](/R4Ks) suppose A has center (0,0) and radius 10, B has center (0,8) and radius 2 , C has center at (0,12) and radius 4, now A can only detonate B, C can also detonate B but B can\\'t detonate either of A and C, neither can A and C detonate each other.."
                    },
                    {
                        "username": "psionl0",
                        "content": "Nope. Detonating one of the bombs won\\'t result in all of the bombs being detonated."
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Give an example and show me such a scenario"
                    },
                    {
                        "username": "rs9",
                        "content": "This problem can be easily solved by DFS/BFS from each vertex in O(N^2). But can it be solved in O(N*logN) or O(N*sqrtN)?\\n\\nIs it possible to somehow lower number of vertex pairs to process by using some data structure like R-tree or over data structures used for knn-algorithms.\\nIs it possible by finding strongly connected components and edge contractions lower asymptotic computation complexity from O(N^2) to O(NlogN), O(NsqrtN) or maybe even O(N).\\n\\nUPD: I found answer to my question. It is no. It\\'s impossible to be  O(N^(2-eps)) for any eps>0.\\nhttps://www.sciencedirect.com/science/article/abs/pii/S0020019016300734?via%3Dihub\\n\\n![image](https://assets.leetcode.com/users/images/459461ca-2281-4e25-bba7-00299938c183_1639421565.9786224.jpeg)\\n"
                    },
                    {
                        "username": "yjian012",
                        "content": "[@cecilia5](/cecilia5) That's exactly my thought too, I totally agree with the finding the SCCs part. But what do you do after getting the DAG? Suppose we start with a DAG, and you know the roots. How do you find the number of vertices that can be reached from each root? You still need to go through most of the vertices/edges again, I think, so it would still be O( |V|*(|V|+|E|) )."
                    },
                    {
                        "username": "Arana",
                        "content": "No. The graph is not given, so this problem cannot be solved by any algorithm less than O(n^3)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "If the graph is given, however, I wonder what\\'s wrong with this algorithm.\\n\\n1.) Run Tarjan\\'s to get the SCCs\\n2.) Create a DAG G\\' of SCCs\\n3.) Compute a topological sorted order T of the reverse of G\\'.\\n4.) For each SCC n in T, compute the size of the connected components starting from arbitrary node of n as the size of n plus the size of all the SCC child of it in G\\'. By the topological sort above, the size should be already there.\\n\\nThis should be $$ O(|V| + |E|) $$ for all steps (note that G\\' can be seen as a contraction of G so is smaller than G)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I wondered the same but I was thinking geometrically. If the bombs are all reaching each other, the adjacency list alone would have $$ O(n^2) $$ entries, so that\\'s the end of it."
                    },
                    {
                        "username": "idklol8",
                        "content": "recommend you not solve on airport wifi while waiting for boarding"
                    },
                    {
                        "username": "anonymousjohndoe999",
                        "content": "haha"
                    },
                    {
                        "username": "Petersburg",
                        "content": "tried and failed"
                    },
                    {
                        "username": "dominhnhut01",
                        "content": "Thank you! I just spent the whole 1 hour just to figure out why my Union Find is not working"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "While calculating the distance between two centers remember to cast the squared value with long. Rest is pretty straightforward in this."
                    },
                    {
                        "username": "tbaby",
                        "content": "Watch out for exceeding max int."
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "[@mfulbright](/mfulbright) Agree, overflow is so annoying and that\\'s why many people switch to Python."
                    },
                    {
                        "username": "mfulbright",
                        "content": "Yeah that got me for a minute too. I hate bullshit like that, it just makes me waste time switching my ints to longs to see if that\\'s what the problem is."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Take a look at Constraints. `O(n^3)` will be fast enough"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Test case:\n```\n[[647,457,91],[483,716,37],[426,119,35],[355,588,40],[850,874,49],[232,568,46],[886,1,30],[54,377,3],[933,986,50],[305,790,49],[372,961,67],[671,314,58],[577,221,29],[380,147,91],[600,535,1],[806,329,64],[536,753,18],[906,88,23],[436,783,82],[652,674,45],[449,668,20],[419,13,66],[853,767,60],[169,288,33],[871,608,66],[337,445,35],[388,623,39],[723,503,81],[14,19,19],[98,648,72],[147,565,93],[655,434,1],[407,663,22],[805,947,83],[942,160,70],[959,496,93],[30,988,53],[187,849,60],[980,483,41],[663,150,76],[268,39,50],[513,522,75],[61,450,90],[115,231,12],[346,304,74],[385,540,23],[905,178,19],[336,896,81],[751,811,94],[527,783,78],[635,965,19],[334,290,39],[748,460,77],[414,134,22],[955,485,29],[925,787,43],[243,771,75],[675,223,29],[788,618,82],[462,544,30],[999,259,50],[210,146,12],[789,442,70],[286,36,55],[451,953,6],[719,914,14],[664,452,14],[933,637,29],[206,926,16],[100,422,98],[97,333,4],[505,631,26],[908,287,65],[907,316,86],[949,185,16],[639,735,62],[401,739,18],[605,926,21],[25,391,69],[80,24,9],[435,874,92],[940,381,18],[260,740,87],[727,515,17],[361,152,16],[512,470,67],[189,27,27],[517,439,94],[159,543,76],[373,698,38],[781,836,97],[584,190,23],[383,367,86],[825,141,63],[117,926,85],[169,588,60],[56,981,100],[294,716,100],[781,370,89],[373,44,78]]\n```\nSort the bombs! Create the adjacent list. Then apply DFS and got the result 7!\n```\nn=100\n56,981,100\n294,716,100\n100,422,98\n781,836,97\n751,811,94\n517,439,94\n147,565,93\n959,496,93\n435,874,92\n647,457,91\n380,147,91\n61,450,90\n781,370,89\n260,740,87\n383,367,86\n907,316,86\n117,926,85\n805,947,83\n436,783,82\n788,618,82\n336,896,81\n723,503,81\n527,783,78\n373,44,78\n748,460,77\n159,543,76\n663,150,76\n243,771,75\n513,522,75\n346,304,74\n98,648,72\n789,442,70\n942,160,70\n25,391,69\n372,961,67\n512,470,67\n871,608,66\n419,13,66\n908,287,65\n806,329,64\n825,141,63\n639,735,62\n187,849,60\n853,767,60\n169,588,60\n671,314,58\n286,36,55\n30,988,53\n933,986,50\n999,259,50\n268,39,50\n850,874,49\n305,790,49\n232,568,46\n652,674,45\n925,787,43\n980,483,41\n355,588,40\n388,623,39\n334,290,39\n373,698,38\n483,716,37\n337,445,35\n426,119,35\n169,288,33\n462,544,30\n886,1,30\n933,637,29\n955,485,29\n675,223,29\n577,221,29\n189,27,27\n505,631,26\n385,540,23\n584,190,23\n906,88,23\n407,663,22\n414,134,22\n605,926,21\n449,668,20\n635,965,19\n905,178,19\n14,19,19\n536,753,18\n401,739,18\n940,381,18\n727,515,17\n206,926,16\n949,185,16\n361,152,16\n719,914,14\n664,452,14\n115,231,12\n210,146,12\n80,24,9\n451,953,6\n97,333,4\n54,377,3\n600,535,1\n655,434,1\n=======\nadj lists:\n0:[16,47]\n1:[13,27,52,60]\n2:[11,33,96,97]\n3:[4,51]\n4:[3]\n5:[28,35]\n6:[25,44,53]\n7:[56,68]\n8:[18,95]\n9:[21,91,99]\n10:[63,77,89]\n11:[2,33,97]\n12:[31,39]\n13:[1,27,52]\n14:[29]\n15:[38,85]\n16:[0]\n18:[61,84]\n20:[34]\n21:[24,86,91]\n22:[83]\n23:[37]\n24:[21,31,86]\n25:[6,44]\n26:[69]\n27:[13,52]\n28:[35,65]\n29:[14,59]\n31:[24]\n32:[81,88]\n33:[97]\n35:[5,28]\n37:[23]\n38:[15]\n39:[12]\n44:[6,25]\n46:[50]\n47:[0]\n50:[46]\n56:[7,68]\n59:[29]\n63:[77]\n68:[7,56]\n77:[63]\n86:[21]\nans=7\n```"
                    },
                    {
                        "username": "anurag-k",
                        "content": "Got the same error. Store the distance between two points in double, int will round off the value and give an error."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@smbody](/smbody) should be  test case"
                    },
                    {
                        "username": "smbody",
                        "content": "But i am getting it as 8, what is so special abt this test case?\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588509/c-dfs-bfs-solutions-with-detonating-bomb-process-beating-90-22/"
                    }
                ]
            },
            {
                "id": 1714639,
                "content": [
                    {
                        "username": "darkalarm",
                        "content": "When I read the question, my first thought was using union find for this question. But after a few test cases, I could understand that the question is actually about a directed graph. Union Find works for an undirected graph.\\n\\n![image](https://assets.leetcode.com/users/images/f7fb76c8-9ab7-4044-bd5f-569b21621f01_1639243400.360309.png)\\n\\nYou can see from the example above, the green circle can detonate the blue circle. But not the other way round. This means, there will be a directed edge from green circle to blue circule.\\n\\nThe question is asking us to find the maximum number of connected nodes in this graph. BFS sounds like the best approach."
                    },
                    {
                        "username": "reassurance",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) \\nMaybe I can help you in understanding why DFS might be faster than BFS although the logic of this question can be handled by both. \\nIn my DFS code, it is seen that if we trail down the path of the possible bombs that can be detonated by the current bomb, we can see that we have a chance to discover bombs that might trigger a **CHAIN** reaction. In other words, a queue in BFS will take longer time to finish and might include bombs that are isolated thereby reducing the impact. \\nAlthough I would not fully agree with my explanation above, this intuition sounded right to me.\\n\\nWould love to see someone prove this!"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "thats good, but how about dfs, I did BFS but my beats were ery low . Seen some solutions thst used DFS, they were more efficient. Don\\'t know the logic why, but it is what it is. try that too and tell me too if you understand why DFS is better than BFS in this case."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "great job, bro"
                    },
                    {
                        "username": "prateek4463",
                        "content": "thanks ! "
                    },
                    {
                        "username": "anfatum",
                        "content": "`bombs` =\\n[[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]\\n`Expected`\\n1\\n\\nAren\\'t [69,51,7] and [65,59,3] intersecting thus there is more than one explosion? "
                    },
                    {
                        "username": "blackhat130",
                        "content": "[@LakshayTheGupta](/LakshayTheGupta) Haha, Great Explanation. "
                    },
                    {
                        "username": "LakshayTheGupta",
                        "content": "[@piudpie](/piudpie) No that must be common sense that to activate  the bomb , it should be inside the range of the exploding bomb. The bomb is not itself a circle with radius R. \\nConclusion : we lack common sense and leetcode is trying to prove in every problem \\uD83E\\uDD23. (I had 2-3 wrong submissions before figuring this issue out \\uD83E\\uDD79)"
                    },
                    {
                        "username": "piudpie",
                        "content": "[@lohani](/lohani) They should have mentioned it in the problem statement, thank you for clarifying though!"
                    },
                    {
                        "username": "psionl0",
                        "content": "the distance between the 2 bombs is sqrt((65-69)^2 + (59-51)^2) = 8.9 which is greater than the range of either bomb."
                    },
                    {
                        "username": "pulkit_singhall",
                        "content": "[@lohani](/lohani) What is the condition for centre to be inside the radius?"
                    },
                    {
                        "username": "lohani",
                        "content": "I stumbled on this same issue. But there is a catch in the problem statement. The second bomb will only be detonated if it\\'s center comes inside the radius of the first bomb. Just intersection of circles is not enough."
                    },
                    {
                        "username": "hengjunlin1129",
                        "content": "I figured out that\\nbomb A can trigger bomb B\\nbomb C can trigger bomb B\\nbomb B cannot trigger bomb A and C\\nbomb A, C cannot trigger each other\\nbut in Union Find A B C will be in same group. (cause A->B, C->B"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "but if c can detonate b, then b must also be able to detonate c"
                    },
                    {
                        "username": "tejasX",
                        "content": "Thanks. I got my mistake."
                    },
                    {
                        "username": "drekker007",
                        "content": "Thank you so much bro!! You made me realize my mistakes!!"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "[@R4Ks](/R4Ks) suppose A has center (0,0) and radius 10, B has center (0,8) and radius 2 , C has center at (0,12) and radius 4, now A can only detonate B, C can also detonate B but B can\\'t detonate either of A and C, neither can A and C detonate each other.."
                    },
                    {
                        "username": "psionl0",
                        "content": "Nope. Detonating one of the bombs won\\'t result in all of the bombs being detonated."
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Give an example and show me such a scenario"
                    },
                    {
                        "username": "rs9",
                        "content": "This problem can be easily solved by DFS/BFS from each vertex in O(N^2). But can it be solved in O(N*logN) or O(N*sqrtN)?\\n\\nIs it possible to somehow lower number of vertex pairs to process by using some data structure like R-tree or over data structures used for knn-algorithms.\\nIs it possible by finding strongly connected components and edge contractions lower asymptotic computation complexity from O(N^2) to O(NlogN), O(NsqrtN) or maybe even O(N).\\n\\nUPD: I found answer to my question. It is no. It\\'s impossible to be  O(N^(2-eps)) for any eps>0.\\nhttps://www.sciencedirect.com/science/article/abs/pii/S0020019016300734?via%3Dihub\\n\\n![image](https://assets.leetcode.com/users/images/459461ca-2281-4e25-bba7-00299938c183_1639421565.9786224.jpeg)\\n"
                    },
                    {
                        "username": "yjian012",
                        "content": "[@cecilia5](/cecilia5) That's exactly my thought too, I totally agree with the finding the SCCs part. But what do you do after getting the DAG? Suppose we start with a DAG, and you know the roots. How do you find the number of vertices that can be reached from each root? You still need to go through most of the vertices/edges again, I think, so it would still be O( |V|*(|V|+|E|) )."
                    },
                    {
                        "username": "Arana",
                        "content": "No. The graph is not given, so this problem cannot be solved by any algorithm less than O(n^3)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "If the graph is given, however, I wonder what\\'s wrong with this algorithm.\\n\\n1.) Run Tarjan\\'s to get the SCCs\\n2.) Create a DAG G\\' of SCCs\\n3.) Compute a topological sorted order T of the reverse of G\\'.\\n4.) For each SCC n in T, compute the size of the connected components starting from arbitrary node of n as the size of n plus the size of all the SCC child of it in G\\'. By the topological sort above, the size should be already there.\\n\\nThis should be $$ O(|V| + |E|) $$ for all steps (note that G\\' can be seen as a contraction of G so is smaller than G)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I wondered the same but I was thinking geometrically. If the bombs are all reaching each other, the adjacency list alone would have $$ O(n^2) $$ entries, so that\\'s the end of it."
                    },
                    {
                        "username": "idklol8",
                        "content": "recommend you not solve on airport wifi while waiting for boarding"
                    },
                    {
                        "username": "anonymousjohndoe999",
                        "content": "haha"
                    },
                    {
                        "username": "Petersburg",
                        "content": "tried and failed"
                    },
                    {
                        "username": "dominhnhut01",
                        "content": "Thank you! I just spent the whole 1 hour just to figure out why my Union Find is not working"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "While calculating the distance between two centers remember to cast the squared value with long. Rest is pretty straightforward in this."
                    },
                    {
                        "username": "tbaby",
                        "content": "Watch out for exceeding max int."
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "[@mfulbright](/mfulbright) Agree, overflow is so annoying and that\\'s why many people switch to Python."
                    },
                    {
                        "username": "mfulbright",
                        "content": "Yeah that got me for a minute too. I hate bullshit like that, it just makes me waste time switching my ints to longs to see if that\\'s what the problem is."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Take a look at Constraints. `O(n^3)` will be fast enough"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Test case:\n```\n[[647,457,91],[483,716,37],[426,119,35],[355,588,40],[850,874,49],[232,568,46],[886,1,30],[54,377,3],[933,986,50],[305,790,49],[372,961,67],[671,314,58],[577,221,29],[380,147,91],[600,535,1],[806,329,64],[536,753,18],[906,88,23],[436,783,82],[652,674,45],[449,668,20],[419,13,66],[853,767,60],[169,288,33],[871,608,66],[337,445,35],[388,623,39],[723,503,81],[14,19,19],[98,648,72],[147,565,93],[655,434,1],[407,663,22],[805,947,83],[942,160,70],[959,496,93],[30,988,53],[187,849,60],[980,483,41],[663,150,76],[268,39,50],[513,522,75],[61,450,90],[115,231,12],[346,304,74],[385,540,23],[905,178,19],[336,896,81],[751,811,94],[527,783,78],[635,965,19],[334,290,39],[748,460,77],[414,134,22],[955,485,29],[925,787,43],[243,771,75],[675,223,29],[788,618,82],[462,544,30],[999,259,50],[210,146,12],[789,442,70],[286,36,55],[451,953,6],[719,914,14],[664,452,14],[933,637,29],[206,926,16],[100,422,98],[97,333,4],[505,631,26],[908,287,65],[907,316,86],[949,185,16],[639,735,62],[401,739,18],[605,926,21],[25,391,69],[80,24,9],[435,874,92],[940,381,18],[260,740,87],[727,515,17],[361,152,16],[512,470,67],[189,27,27],[517,439,94],[159,543,76],[373,698,38],[781,836,97],[584,190,23],[383,367,86],[825,141,63],[117,926,85],[169,588,60],[56,981,100],[294,716,100],[781,370,89],[373,44,78]]\n```\nSort the bombs! Create the adjacent list. Then apply DFS and got the result 7!\n```\nn=100\n56,981,100\n294,716,100\n100,422,98\n781,836,97\n751,811,94\n517,439,94\n147,565,93\n959,496,93\n435,874,92\n647,457,91\n380,147,91\n61,450,90\n781,370,89\n260,740,87\n383,367,86\n907,316,86\n117,926,85\n805,947,83\n436,783,82\n788,618,82\n336,896,81\n723,503,81\n527,783,78\n373,44,78\n748,460,77\n159,543,76\n663,150,76\n243,771,75\n513,522,75\n346,304,74\n98,648,72\n789,442,70\n942,160,70\n25,391,69\n372,961,67\n512,470,67\n871,608,66\n419,13,66\n908,287,65\n806,329,64\n825,141,63\n639,735,62\n187,849,60\n853,767,60\n169,588,60\n671,314,58\n286,36,55\n30,988,53\n933,986,50\n999,259,50\n268,39,50\n850,874,49\n305,790,49\n232,568,46\n652,674,45\n925,787,43\n980,483,41\n355,588,40\n388,623,39\n334,290,39\n373,698,38\n483,716,37\n337,445,35\n426,119,35\n169,288,33\n462,544,30\n886,1,30\n933,637,29\n955,485,29\n675,223,29\n577,221,29\n189,27,27\n505,631,26\n385,540,23\n584,190,23\n906,88,23\n407,663,22\n414,134,22\n605,926,21\n449,668,20\n635,965,19\n905,178,19\n14,19,19\n536,753,18\n401,739,18\n940,381,18\n727,515,17\n206,926,16\n949,185,16\n361,152,16\n719,914,14\n664,452,14\n115,231,12\n210,146,12\n80,24,9\n451,953,6\n97,333,4\n54,377,3\n600,535,1\n655,434,1\n=======\nadj lists:\n0:[16,47]\n1:[13,27,52,60]\n2:[11,33,96,97]\n3:[4,51]\n4:[3]\n5:[28,35]\n6:[25,44,53]\n7:[56,68]\n8:[18,95]\n9:[21,91,99]\n10:[63,77,89]\n11:[2,33,97]\n12:[31,39]\n13:[1,27,52]\n14:[29]\n15:[38,85]\n16:[0]\n18:[61,84]\n20:[34]\n21:[24,86,91]\n22:[83]\n23:[37]\n24:[21,31,86]\n25:[6,44]\n26:[69]\n27:[13,52]\n28:[35,65]\n29:[14,59]\n31:[24]\n32:[81,88]\n33:[97]\n35:[5,28]\n37:[23]\n38:[15]\n39:[12]\n44:[6,25]\n46:[50]\n47:[0]\n50:[46]\n56:[7,68]\n59:[29]\n63:[77]\n68:[7,56]\n77:[63]\n86:[21]\nans=7\n```"
                    },
                    {
                        "username": "anurag-k",
                        "content": "Got the same error. Store the distance between two points in double, int will round off the value and give an error."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@smbody](/smbody) should be  test case"
                    },
                    {
                        "username": "smbody",
                        "content": "But i am getting it as 8, what is so special abt this test case?\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588509/c-dfs-bfs-solutions-with-detonating-bomb-process-beating-90-22/"
                    }
                ]
            },
            {
                "id": 1567701,
                "content": [
                    {
                        "username": "darkalarm",
                        "content": "When I read the question, my first thought was using union find for this question. But after a few test cases, I could understand that the question is actually about a directed graph. Union Find works for an undirected graph.\\n\\n![image](https://assets.leetcode.com/users/images/f7fb76c8-9ab7-4044-bd5f-569b21621f01_1639243400.360309.png)\\n\\nYou can see from the example above, the green circle can detonate the blue circle. But not the other way round. This means, there will be a directed edge from green circle to blue circule.\\n\\nThe question is asking us to find the maximum number of connected nodes in this graph. BFS sounds like the best approach."
                    },
                    {
                        "username": "reassurance",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) \\nMaybe I can help you in understanding why DFS might be faster than BFS although the logic of this question can be handled by both. \\nIn my DFS code, it is seen that if we trail down the path of the possible bombs that can be detonated by the current bomb, we can see that we have a chance to discover bombs that might trigger a **CHAIN** reaction. In other words, a queue in BFS will take longer time to finish and might include bombs that are isolated thereby reducing the impact. \\nAlthough I would not fully agree with my explanation above, this intuition sounded right to me.\\n\\nWould love to see someone prove this!"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "thats good, but how about dfs, I did BFS but my beats were ery low . Seen some solutions thst used DFS, they were more efficient. Don\\'t know the logic why, but it is what it is. try that too and tell me too if you understand why DFS is better than BFS in this case."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "great job, bro"
                    },
                    {
                        "username": "prateek4463",
                        "content": "thanks ! "
                    },
                    {
                        "username": "anfatum",
                        "content": "`bombs` =\\n[[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]\\n`Expected`\\n1\\n\\nAren\\'t [69,51,7] and [65,59,3] intersecting thus there is more than one explosion? "
                    },
                    {
                        "username": "blackhat130",
                        "content": "[@LakshayTheGupta](/LakshayTheGupta) Haha, Great Explanation. "
                    },
                    {
                        "username": "LakshayTheGupta",
                        "content": "[@piudpie](/piudpie) No that must be common sense that to activate  the bomb , it should be inside the range of the exploding bomb. The bomb is not itself a circle with radius R. \\nConclusion : we lack common sense and leetcode is trying to prove in every problem \\uD83E\\uDD23. (I had 2-3 wrong submissions before figuring this issue out \\uD83E\\uDD79)"
                    },
                    {
                        "username": "piudpie",
                        "content": "[@lohani](/lohani) They should have mentioned it in the problem statement, thank you for clarifying though!"
                    },
                    {
                        "username": "psionl0",
                        "content": "the distance between the 2 bombs is sqrt((65-69)^2 + (59-51)^2) = 8.9 which is greater than the range of either bomb."
                    },
                    {
                        "username": "pulkit_singhall",
                        "content": "[@lohani](/lohani) What is the condition for centre to be inside the radius?"
                    },
                    {
                        "username": "lohani",
                        "content": "I stumbled on this same issue. But there is a catch in the problem statement. The second bomb will only be detonated if it\\'s center comes inside the radius of the first bomb. Just intersection of circles is not enough."
                    },
                    {
                        "username": "hengjunlin1129",
                        "content": "I figured out that\\nbomb A can trigger bomb B\\nbomb C can trigger bomb B\\nbomb B cannot trigger bomb A and C\\nbomb A, C cannot trigger each other\\nbut in Union Find A B C will be in same group. (cause A->B, C->B"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "but if c can detonate b, then b must also be able to detonate c"
                    },
                    {
                        "username": "tejasX",
                        "content": "Thanks. I got my mistake."
                    },
                    {
                        "username": "drekker007",
                        "content": "Thank you so much bro!! You made me realize my mistakes!!"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "[@R4Ks](/R4Ks) suppose A has center (0,0) and radius 10, B has center (0,8) and radius 2 , C has center at (0,12) and radius 4, now A can only detonate B, C can also detonate B but B can\\'t detonate either of A and C, neither can A and C detonate each other.."
                    },
                    {
                        "username": "psionl0",
                        "content": "Nope. Detonating one of the bombs won\\'t result in all of the bombs being detonated."
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Give an example and show me such a scenario"
                    },
                    {
                        "username": "rs9",
                        "content": "This problem can be easily solved by DFS/BFS from each vertex in O(N^2). But can it be solved in O(N*logN) or O(N*sqrtN)?\\n\\nIs it possible to somehow lower number of vertex pairs to process by using some data structure like R-tree or over data structures used for knn-algorithms.\\nIs it possible by finding strongly connected components and edge contractions lower asymptotic computation complexity from O(N^2) to O(NlogN), O(NsqrtN) or maybe even O(N).\\n\\nUPD: I found answer to my question. It is no. It\\'s impossible to be  O(N^(2-eps)) for any eps>0.\\nhttps://www.sciencedirect.com/science/article/abs/pii/S0020019016300734?via%3Dihub\\n\\n![image](https://assets.leetcode.com/users/images/459461ca-2281-4e25-bba7-00299938c183_1639421565.9786224.jpeg)\\n"
                    },
                    {
                        "username": "yjian012",
                        "content": "[@cecilia5](/cecilia5) That's exactly my thought too, I totally agree with the finding the SCCs part. But what do you do after getting the DAG? Suppose we start with a DAG, and you know the roots. How do you find the number of vertices that can be reached from each root? You still need to go through most of the vertices/edges again, I think, so it would still be O( |V|*(|V|+|E|) )."
                    },
                    {
                        "username": "Arana",
                        "content": "No. The graph is not given, so this problem cannot be solved by any algorithm less than O(n^3)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "If the graph is given, however, I wonder what\\'s wrong with this algorithm.\\n\\n1.) Run Tarjan\\'s to get the SCCs\\n2.) Create a DAG G\\' of SCCs\\n3.) Compute a topological sorted order T of the reverse of G\\'.\\n4.) For each SCC n in T, compute the size of the connected components starting from arbitrary node of n as the size of n plus the size of all the SCC child of it in G\\'. By the topological sort above, the size should be already there.\\n\\nThis should be $$ O(|V| + |E|) $$ for all steps (note that G\\' can be seen as a contraction of G so is smaller than G)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I wondered the same but I was thinking geometrically. If the bombs are all reaching each other, the adjacency list alone would have $$ O(n^2) $$ entries, so that\\'s the end of it."
                    },
                    {
                        "username": "idklol8",
                        "content": "recommend you not solve on airport wifi while waiting for boarding"
                    },
                    {
                        "username": "anonymousjohndoe999",
                        "content": "haha"
                    },
                    {
                        "username": "Petersburg",
                        "content": "tried and failed"
                    },
                    {
                        "username": "dominhnhut01",
                        "content": "Thank you! I just spent the whole 1 hour just to figure out why my Union Find is not working"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "While calculating the distance between two centers remember to cast the squared value with long. Rest is pretty straightforward in this."
                    },
                    {
                        "username": "tbaby",
                        "content": "Watch out for exceeding max int."
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "[@mfulbright](/mfulbright) Agree, overflow is so annoying and that\\'s why many people switch to Python."
                    },
                    {
                        "username": "mfulbright",
                        "content": "Yeah that got me for a minute too. I hate bullshit like that, it just makes me waste time switching my ints to longs to see if that\\'s what the problem is."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Take a look at Constraints. `O(n^3)` will be fast enough"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Test case:\n```\n[[647,457,91],[483,716,37],[426,119,35],[355,588,40],[850,874,49],[232,568,46],[886,1,30],[54,377,3],[933,986,50],[305,790,49],[372,961,67],[671,314,58],[577,221,29],[380,147,91],[600,535,1],[806,329,64],[536,753,18],[906,88,23],[436,783,82],[652,674,45],[449,668,20],[419,13,66],[853,767,60],[169,288,33],[871,608,66],[337,445,35],[388,623,39],[723,503,81],[14,19,19],[98,648,72],[147,565,93],[655,434,1],[407,663,22],[805,947,83],[942,160,70],[959,496,93],[30,988,53],[187,849,60],[980,483,41],[663,150,76],[268,39,50],[513,522,75],[61,450,90],[115,231,12],[346,304,74],[385,540,23],[905,178,19],[336,896,81],[751,811,94],[527,783,78],[635,965,19],[334,290,39],[748,460,77],[414,134,22],[955,485,29],[925,787,43],[243,771,75],[675,223,29],[788,618,82],[462,544,30],[999,259,50],[210,146,12],[789,442,70],[286,36,55],[451,953,6],[719,914,14],[664,452,14],[933,637,29],[206,926,16],[100,422,98],[97,333,4],[505,631,26],[908,287,65],[907,316,86],[949,185,16],[639,735,62],[401,739,18],[605,926,21],[25,391,69],[80,24,9],[435,874,92],[940,381,18],[260,740,87],[727,515,17],[361,152,16],[512,470,67],[189,27,27],[517,439,94],[159,543,76],[373,698,38],[781,836,97],[584,190,23],[383,367,86],[825,141,63],[117,926,85],[169,588,60],[56,981,100],[294,716,100],[781,370,89],[373,44,78]]\n```\nSort the bombs! Create the adjacent list. Then apply DFS and got the result 7!\n```\nn=100\n56,981,100\n294,716,100\n100,422,98\n781,836,97\n751,811,94\n517,439,94\n147,565,93\n959,496,93\n435,874,92\n647,457,91\n380,147,91\n61,450,90\n781,370,89\n260,740,87\n383,367,86\n907,316,86\n117,926,85\n805,947,83\n436,783,82\n788,618,82\n336,896,81\n723,503,81\n527,783,78\n373,44,78\n748,460,77\n159,543,76\n663,150,76\n243,771,75\n513,522,75\n346,304,74\n98,648,72\n789,442,70\n942,160,70\n25,391,69\n372,961,67\n512,470,67\n871,608,66\n419,13,66\n908,287,65\n806,329,64\n825,141,63\n639,735,62\n187,849,60\n853,767,60\n169,588,60\n671,314,58\n286,36,55\n30,988,53\n933,986,50\n999,259,50\n268,39,50\n850,874,49\n305,790,49\n232,568,46\n652,674,45\n925,787,43\n980,483,41\n355,588,40\n388,623,39\n334,290,39\n373,698,38\n483,716,37\n337,445,35\n426,119,35\n169,288,33\n462,544,30\n886,1,30\n933,637,29\n955,485,29\n675,223,29\n577,221,29\n189,27,27\n505,631,26\n385,540,23\n584,190,23\n906,88,23\n407,663,22\n414,134,22\n605,926,21\n449,668,20\n635,965,19\n905,178,19\n14,19,19\n536,753,18\n401,739,18\n940,381,18\n727,515,17\n206,926,16\n949,185,16\n361,152,16\n719,914,14\n664,452,14\n115,231,12\n210,146,12\n80,24,9\n451,953,6\n97,333,4\n54,377,3\n600,535,1\n655,434,1\n=======\nadj lists:\n0:[16,47]\n1:[13,27,52,60]\n2:[11,33,96,97]\n3:[4,51]\n4:[3]\n5:[28,35]\n6:[25,44,53]\n7:[56,68]\n8:[18,95]\n9:[21,91,99]\n10:[63,77,89]\n11:[2,33,97]\n12:[31,39]\n13:[1,27,52]\n14:[29]\n15:[38,85]\n16:[0]\n18:[61,84]\n20:[34]\n21:[24,86,91]\n22:[83]\n23:[37]\n24:[21,31,86]\n25:[6,44]\n26:[69]\n27:[13,52]\n28:[35,65]\n29:[14,59]\n31:[24]\n32:[81,88]\n33:[97]\n35:[5,28]\n37:[23]\n38:[15]\n39:[12]\n44:[6,25]\n46:[50]\n47:[0]\n50:[46]\n56:[7,68]\n59:[29]\n63:[77]\n68:[7,56]\n77:[63]\n86:[21]\nans=7\n```"
                    },
                    {
                        "username": "anurag-k",
                        "content": "Got the same error. Store the distance between two points in double, int will round off the value and give an error."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@smbody](/smbody) should be  test case"
                    },
                    {
                        "username": "smbody",
                        "content": "But i am getting it as 8, what is so special abt this test case?\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588509/c-dfs-bfs-solutions-with-detonating-bomb-process-beating-90-22/"
                    }
                ]
            },
            {
                "id": 1566203,
                "content": [
                    {
                        "username": "darkalarm",
                        "content": "When I read the question, my first thought was using union find for this question. But after a few test cases, I could understand that the question is actually about a directed graph. Union Find works for an undirected graph.\\n\\n![image](https://assets.leetcode.com/users/images/f7fb76c8-9ab7-4044-bd5f-569b21621f01_1639243400.360309.png)\\n\\nYou can see from the example above, the green circle can detonate the blue circle. But not the other way round. This means, there will be a directed edge from green circle to blue circule.\\n\\nThe question is asking us to find the maximum number of connected nodes in this graph. BFS sounds like the best approach."
                    },
                    {
                        "username": "reassurance",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) \\nMaybe I can help you in understanding why DFS might be faster than BFS although the logic of this question can be handled by both. \\nIn my DFS code, it is seen that if we trail down the path of the possible bombs that can be detonated by the current bomb, we can see that we have a chance to discover bombs that might trigger a **CHAIN** reaction. In other words, a queue in BFS will take longer time to finish and might include bombs that are isolated thereby reducing the impact. \\nAlthough I would not fully agree with my explanation above, this intuition sounded right to me.\\n\\nWould love to see someone prove this!"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "thats good, but how about dfs, I did BFS but my beats were ery low . Seen some solutions thst used DFS, they were more efficient. Don\\'t know the logic why, but it is what it is. try that too and tell me too if you understand why DFS is better than BFS in this case."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "great job, bro"
                    },
                    {
                        "username": "prateek4463",
                        "content": "thanks ! "
                    },
                    {
                        "username": "anfatum",
                        "content": "`bombs` =\\n[[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]\\n`Expected`\\n1\\n\\nAren\\'t [69,51,7] and [65,59,3] intersecting thus there is more than one explosion? "
                    },
                    {
                        "username": "blackhat130",
                        "content": "[@LakshayTheGupta](/LakshayTheGupta) Haha, Great Explanation. "
                    },
                    {
                        "username": "LakshayTheGupta",
                        "content": "[@piudpie](/piudpie) No that must be common sense that to activate  the bomb , it should be inside the range of the exploding bomb. The bomb is not itself a circle with radius R. \\nConclusion : we lack common sense and leetcode is trying to prove in every problem \\uD83E\\uDD23. (I had 2-3 wrong submissions before figuring this issue out \\uD83E\\uDD79)"
                    },
                    {
                        "username": "piudpie",
                        "content": "[@lohani](/lohani) They should have mentioned it in the problem statement, thank you for clarifying though!"
                    },
                    {
                        "username": "psionl0",
                        "content": "the distance between the 2 bombs is sqrt((65-69)^2 + (59-51)^2) = 8.9 which is greater than the range of either bomb."
                    },
                    {
                        "username": "pulkit_singhall",
                        "content": "[@lohani](/lohani) What is the condition for centre to be inside the radius?"
                    },
                    {
                        "username": "lohani",
                        "content": "I stumbled on this same issue. But there is a catch in the problem statement. The second bomb will only be detonated if it\\'s center comes inside the radius of the first bomb. Just intersection of circles is not enough."
                    },
                    {
                        "username": "hengjunlin1129",
                        "content": "I figured out that\\nbomb A can trigger bomb B\\nbomb C can trigger bomb B\\nbomb B cannot trigger bomb A and C\\nbomb A, C cannot trigger each other\\nbut in Union Find A B C will be in same group. (cause A->B, C->B"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "but if c can detonate b, then b must also be able to detonate c"
                    },
                    {
                        "username": "tejasX",
                        "content": "Thanks. I got my mistake."
                    },
                    {
                        "username": "drekker007",
                        "content": "Thank you so much bro!! You made me realize my mistakes!!"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "[@R4Ks](/R4Ks) suppose A has center (0,0) and radius 10, B has center (0,8) and radius 2 , C has center at (0,12) and radius 4, now A can only detonate B, C can also detonate B but B can\\'t detonate either of A and C, neither can A and C detonate each other.."
                    },
                    {
                        "username": "psionl0",
                        "content": "Nope. Detonating one of the bombs won\\'t result in all of the bombs being detonated."
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Give an example and show me such a scenario"
                    },
                    {
                        "username": "rs9",
                        "content": "This problem can be easily solved by DFS/BFS from each vertex in O(N^2). But can it be solved in O(N*logN) or O(N*sqrtN)?\\n\\nIs it possible to somehow lower number of vertex pairs to process by using some data structure like R-tree or over data structures used for knn-algorithms.\\nIs it possible by finding strongly connected components and edge contractions lower asymptotic computation complexity from O(N^2) to O(NlogN), O(NsqrtN) or maybe even O(N).\\n\\nUPD: I found answer to my question. It is no. It\\'s impossible to be  O(N^(2-eps)) for any eps>0.\\nhttps://www.sciencedirect.com/science/article/abs/pii/S0020019016300734?via%3Dihub\\n\\n![image](https://assets.leetcode.com/users/images/459461ca-2281-4e25-bba7-00299938c183_1639421565.9786224.jpeg)\\n"
                    },
                    {
                        "username": "yjian012",
                        "content": "[@cecilia5](/cecilia5) That's exactly my thought too, I totally agree with the finding the SCCs part. But what do you do after getting the DAG? Suppose we start with a DAG, and you know the roots. How do you find the number of vertices that can be reached from each root? You still need to go through most of the vertices/edges again, I think, so it would still be O( |V|*(|V|+|E|) )."
                    },
                    {
                        "username": "Arana",
                        "content": "No. The graph is not given, so this problem cannot be solved by any algorithm less than O(n^3)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "If the graph is given, however, I wonder what\\'s wrong with this algorithm.\\n\\n1.) Run Tarjan\\'s to get the SCCs\\n2.) Create a DAG G\\' of SCCs\\n3.) Compute a topological sorted order T of the reverse of G\\'.\\n4.) For each SCC n in T, compute the size of the connected components starting from arbitrary node of n as the size of n plus the size of all the SCC child of it in G\\'. By the topological sort above, the size should be already there.\\n\\nThis should be $$ O(|V| + |E|) $$ for all steps (note that G\\' can be seen as a contraction of G so is smaller than G)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I wondered the same but I was thinking geometrically. If the bombs are all reaching each other, the adjacency list alone would have $$ O(n^2) $$ entries, so that\\'s the end of it."
                    },
                    {
                        "username": "idklol8",
                        "content": "recommend you not solve on airport wifi while waiting for boarding"
                    },
                    {
                        "username": "anonymousjohndoe999",
                        "content": "haha"
                    },
                    {
                        "username": "Petersburg",
                        "content": "tried and failed"
                    },
                    {
                        "username": "dominhnhut01",
                        "content": "Thank you! I just spent the whole 1 hour just to figure out why my Union Find is not working"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "While calculating the distance between two centers remember to cast the squared value with long. Rest is pretty straightforward in this."
                    },
                    {
                        "username": "tbaby",
                        "content": "Watch out for exceeding max int."
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "[@mfulbright](/mfulbright) Agree, overflow is so annoying and that\\'s why many people switch to Python."
                    },
                    {
                        "username": "mfulbright",
                        "content": "Yeah that got me for a minute too. I hate bullshit like that, it just makes me waste time switching my ints to longs to see if that\\'s what the problem is."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Take a look at Constraints. `O(n^3)` will be fast enough"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Test case:\n```\n[[647,457,91],[483,716,37],[426,119,35],[355,588,40],[850,874,49],[232,568,46],[886,1,30],[54,377,3],[933,986,50],[305,790,49],[372,961,67],[671,314,58],[577,221,29],[380,147,91],[600,535,1],[806,329,64],[536,753,18],[906,88,23],[436,783,82],[652,674,45],[449,668,20],[419,13,66],[853,767,60],[169,288,33],[871,608,66],[337,445,35],[388,623,39],[723,503,81],[14,19,19],[98,648,72],[147,565,93],[655,434,1],[407,663,22],[805,947,83],[942,160,70],[959,496,93],[30,988,53],[187,849,60],[980,483,41],[663,150,76],[268,39,50],[513,522,75],[61,450,90],[115,231,12],[346,304,74],[385,540,23],[905,178,19],[336,896,81],[751,811,94],[527,783,78],[635,965,19],[334,290,39],[748,460,77],[414,134,22],[955,485,29],[925,787,43],[243,771,75],[675,223,29],[788,618,82],[462,544,30],[999,259,50],[210,146,12],[789,442,70],[286,36,55],[451,953,6],[719,914,14],[664,452,14],[933,637,29],[206,926,16],[100,422,98],[97,333,4],[505,631,26],[908,287,65],[907,316,86],[949,185,16],[639,735,62],[401,739,18],[605,926,21],[25,391,69],[80,24,9],[435,874,92],[940,381,18],[260,740,87],[727,515,17],[361,152,16],[512,470,67],[189,27,27],[517,439,94],[159,543,76],[373,698,38],[781,836,97],[584,190,23],[383,367,86],[825,141,63],[117,926,85],[169,588,60],[56,981,100],[294,716,100],[781,370,89],[373,44,78]]\n```\nSort the bombs! Create the adjacent list. Then apply DFS and got the result 7!\n```\nn=100\n56,981,100\n294,716,100\n100,422,98\n781,836,97\n751,811,94\n517,439,94\n147,565,93\n959,496,93\n435,874,92\n647,457,91\n380,147,91\n61,450,90\n781,370,89\n260,740,87\n383,367,86\n907,316,86\n117,926,85\n805,947,83\n436,783,82\n788,618,82\n336,896,81\n723,503,81\n527,783,78\n373,44,78\n748,460,77\n159,543,76\n663,150,76\n243,771,75\n513,522,75\n346,304,74\n98,648,72\n789,442,70\n942,160,70\n25,391,69\n372,961,67\n512,470,67\n871,608,66\n419,13,66\n908,287,65\n806,329,64\n825,141,63\n639,735,62\n187,849,60\n853,767,60\n169,588,60\n671,314,58\n286,36,55\n30,988,53\n933,986,50\n999,259,50\n268,39,50\n850,874,49\n305,790,49\n232,568,46\n652,674,45\n925,787,43\n980,483,41\n355,588,40\n388,623,39\n334,290,39\n373,698,38\n483,716,37\n337,445,35\n426,119,35\n169,288,33\n462,544,30\n886,1,30\n933,637,29\n955,485,29\n675,223,29\n577,221,29\n189,27,27\n505,631,26\n385,540,23\n584,190,23\n906,88,23\n407,663,22\n414,134,22\n605,926,21\n449,668,20\n635,965,19\n905,178,19\n14,19,19\n536,753,18\n401,739,18\n940,381,18\n727,515,17\n206,926,16\n949,185,16\n361,152,16\n719,914,14\n664,452,14\n115,231,12\n210,146,12\n80,24,9\n451,953,6\n97,333,4\n54,377,3\n600,535,1\n655,434,1\n=======\nadj lists:\n0:[16,47]\n1:[13,27,52,60]\n2:[11,33,96,97]\n3:[4,51]\n4:[3]\n5:[28,35]\n6:[25,44,53]\n7:[56,68]\n8:[18,95]\n9:[21,91,99]\n10:[63,77,89]\n11:[2,33,97]\n12:[31,39]\n13:[1,27,52]\n14:[29]\n15:[38,85]\n16:[0]\n18:[61,84]\n20:[34]\n21:[24,86,91]\n22:[83]\n23:[37]\n24:[21,31,86]\n25:[6,44]\n26:[69]\n27:[13,52]\n28:[35,65]\n29:[14,59]\n31:[24]\n32:[81,88]\n33:[97]\n35:[5,28]\n37:[23]\n38:[15]\n39:[12]\n44:[6,25]\n46:[50]\n47:[0]\n50:[46]\n56:[7,68]\n59:[29]\n63:[77]\n68:[7,56]\n77:[63]\n86:[21]\nans=7\n```"
                    },
                    {
                        "username": "anurag-k",
                        "content": "Got the same error. Store the distance between two points in double, int will round off the value and give an error."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@smbody](/smbody) should be  test case"
                    },
                    {
                        "username": "smbody",
                        "content": "But i am getting it as 8, what is so special abt this test case?\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588509/c-dfs-bfs-solutions-with-detonating-bomb-process-beating-90-22/"
                    }
                ]
            },
            {
                "id": 1914251,
                "content": [
                    {
                        "username": "darkalarm",
                        "content": "When I read the question, my first thought was using union find for this question. But after a few test cases, I could understand that the question is actually about a directed graph. Union Find works for an undirected graph.\\n\\n![image](https://assets.leetcode.com/users/images/f7fb76c8-9ab7-4044-bd5f-569b21621f01_1639243400.360309.png)\\n\\nYou can see from the example above, the green circle can detonate the blue circle. But not the other way round. This means, there will be a directed edge from green circle to blue circule.\\n\\nThe question is asking us to find the maximum number of connected nodes in this graph. BFS sounds like the best approach."
                    },
                    {
                        "username": "reassurance",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) \\nMaybe I can help you in understanding why DFS might be faster than BFS although the logic of this question can be handled by both. \\nIn my DFS code, it is seen that if we trail down the path of the possible bombs that can be detonated by the current bomb, we can see that we have a chance to discover bombs that might trigger a **CHAIN** reaction. In other words, a queue in BFS will take longer time to finish and might include bombs that are isolated thereby reducing the impact. \\nAlthough I would not fully agree with my explanation above, this intuition sounded right to me.\\n\\nWould love to see someone prove this!"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "thats good, but how about dfs, I did BFS but my beats were ery low . Seen some solutions thst used DFS, they were more efficient. Don\\'t know the logic why, but it is what it is. try that too and tell me too if you understand why DFS is better than BFS in this case."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "great job, bro"
                    },
                    {
                        "username": "prateek4463",
                        "content": "thanks ! "
                    },
                    {
                        "username": "anfatum",
                        "content": "`bombs` =\\n[[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]\\n`Expected`\\n1\\n\\nAren\\'t [69,51,7] and [65,59,3] intersecting thus there is more than one explosion? "
                    },
                    {
                        "username": "blackhat130",
                        "content": "[@LakshayTheGupta](/LakshayTheGupta) Haha, Great Explanation. "
                    },
                    {
                        "username": "LakshayTheGupta",
                        "content": "[@piudpie](/piudpie) No that must be common sense that to activate  the bomb , it should be inside the range of the exploding bomb. The bomb is not itself a circle with radius R. \\nConclusion : we lack common sense and leetcode is trying to prove in every problem \\uD83E\\uDD23. (I had 2-3 wrong submissions before figuring this issue out \\uD83E\\uDD79)"
                    },
                    {
                        "username": "piudpie",
                        "content": "[@lohani](/lohani) They should have mentioned it in the problem statement, thank you for clarifying though!"
                    },
                    {
                        "username": "psionl0",
                        "content": "the distance between the 2 bombs is sqrt((65-69)^2 + (59-51)^2) = 8.9 which is greater than the range of either bomb."
                    },
                    {
                        "username": "pulkit_singhall",
                        "content": "[@lohani](/lohani) What is the condition for centre to be inside the radius?"
                    },
                    {
                        "username": "lohani",
                        "content": "I stumbled on this same issue. But there is a catch in the problem statement. The second bomb will only be detonated if it\\'s center comes inside the radius of the first bomb. Just intersection of circles is not enough."
                    },
                    {
                        "username": "hengjunlin1129",
                        "content": "I figured out that\\nbomb A can trigger bomb B\\nbomb C can trigger bomb B\\nbomb B cannot trigger bomb A and C\\nbomb A, C cannot trigger each other\\nbut in Union Find A B C will be in same group. (cause A->B, C->B"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "but if c can detonate b, then b must also be able to detonate c"
                    },
                    {
                        "username": "tejasX",
                        "content": "Thanks. I got my mistake."
                    },
                    {
                        "username": "drekker007",
                        "content": "Thank you so much bro!! You made me realize my mistakes!!"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "[@R4Ks](/R4Ks) suppose A has center (0,0) and radius 10, B has center (0,8) and radius 2 , C has center at (0,12) and radius 4, now A can only detonate B, C can also detonate B but B can\\'t detonate either of A and C, neither can A and C detonate each other.."
                    },
                    {
                        "username": "psionl0",
                        "content": "Nope. Detonating one of the bombs won\\'t result in all of the bombs being detonated."
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Give an example and show me such a scenario"
                    },
                    {
                        "username": "rs9",
                        "content": "This problem can be easily solved by DFS/BFS from each vertex in O(N^2). But can it be solved in O(N*logN) or O(N*sqrtN)?\\n\\nIs it possible to somehow lower number of vertex pairs to process by using some data structure like R-tree or over data structures used for knn-algorithms.\\nIs it possible by finding strongly connected components and edge contractions lower asymptotic computation complexity from O(N^2) to O(NlogN), O(NsqrtN) or maybe even O(N).\\n\\nUPD: I found answer to my question. It is no. It\\'s impossible to be  O(N^(2-eps)) for any eps>0.\\nhttps://www.sciencedirect.com/science/article/abs/pii/S0020019016300734?via%3Dihub\\n\\n![image](https://assets.leetcode.com/users/images/459461ca-2281-4e25-bba7-00299938c183_1639421565.9786224.jpeg)\\n"
                    },
                    {
                        "username": "yjian012",
                        "content": "[@cecilia5](/cecilia5) That's exactly my thought too, I totally agree with the finding the SCCs part. But what do you do after getting the DAG? Suppose we start with a DAG, and you know the roots. How do you find the number of vertices that can be reached from each root? You still need to go through most of the vertices/edges again, I think, so it would still be O( |V|*(|V|+|E|) )."
                    },
                    {
                        "username": "Arana",
                        "content": "No. The graph is not given, so this problem cannot be solved by any algorithm less than O(n^3)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "If the graph is given, however, I wonder what\\'s wrong with this algorithm.\\n\\n1.) Run Tarjan\\'s to get the SCCs\\n2.) Create a DAG G\\' of SCCs\\n3.) Compute a topological sorted order T of the reverse of G\\'.\\n4.) For each SCC n in T, compute the size of the connected components starting from arbitrary node of n as the size of n plus the size of all the SCC child of it in G\\'. By the topological sort above, the size should be already there.\\n\\nThis should be $$ O(|V| + |E|) $$ for all steps (note that G\\' can be seen as a contraction of G so is smaller than G)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I wondered the same but I was thinking geometrically. If the bombs are all reaching each other, the adjacency list alone would have $$ O(n^2) $$ entries, so that\\'s the end of it."
                    },
                    {
                        "username": "idklol8",
                        "content": "recommend you not solve on airport wifi while waiting for boarding"
                    },
                    {
                        "username": "anonymousjohndoe999",
                        "content": "haha"
                    },
                    {
                        "username": "Petersburg",
                        "content": "tried and failed"
                    },
                    {
                        "username": "dominhnhut01",
                        "content": "Thank you! I just spent the whole 1 hour just to figure out why my Union Find is not working"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "While calculating the distance between two centers remember to cast the squared value with long. Rest is pretty straightforward in this."
                    },
                    {
                        "username": "tbaby",
                        "content": "Watch out for exceeding max int."
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "[@mfulbright](/mfulbright) Agree, overflow is so annoying and that\\'s why many people switch to Python."
                    },
                    {
                        "username": "mfulbright",
                        "content": "Yeah that got me for a minute too. I hate bullshit like that, it just makes me waste time switching my ints to longs to see if that\\'s what the problem is."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Take a look at Constraints. `O(n^3)` will be fast enough"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Test case:\n```\n[[647,457,91],[483,716,37],[426,119,35],[355,588,40],[850,874,49],[232,568,46],[886,1,30],[54,377,3],[933,986,50],[305,790,49],[372,961,67],[671,314,58],[577,221,29],[380,147,91],[600,535,1],[806,329,64],[536,753,18],[906,88,23],[436,783,82],[652,674,45],[449,668,20],[419,13,66],[853,767,60],[169,288,33],[871,608,66],[337,445,35],[388,623,39],[723,503,81],[14,19,19],[98,648,72],[147,565,93],[655,434,1],[407,663,22],[805,947,83],[942,160,70],[959,496,93],[30,988,53],[187,849,60],[980,483,41],[663,150,76],[268,39,50],[513,522,75],[61,450,90],[115,231,12],[346,304,74],[385,540,23],[905,178,19],[336,896,81],[751,811,94],[527,783,78],[635,965,19],[334,290,39],[748,460,77],[414,134,22],[955,485,29],[925,787,43],[243,771,75],[675,223,29],[788,618,82],[462,544,30],[999,259,50],[210,146,12],[789,442,70],[286,36,55],[451,953,6],[719,914,14],[664,452,14],[933,637,29],[206,926,16],[100,422,98],[97,333,4],[505,631,26],[908,287,65],[907,316,86],[949,185,16],[639,735,62],[401,739,18],[605,926,21],[25,391,69],[80,24,9],[435,874,92],[940,381,18],[260,740,87],[727,515,17],[361,152,16],[512,470,67],[189,27,27],[517,439,94],[159,543,76],[373,698,38],[781,836,97],[584,190,23],[383,367,86],[825,141,63],[117,926,85],[169,588,60],[56,981,100],[294,716,100],[781,370,89],[373,44,78]]\n```\nSort the bombs! Create the adjacent list. Then apply DFS and got the result 7!\n```\nn=100\n56,981,100\n294,716,100\n100,422,98\n781,836,97\n751,811,94\n517,439,94\n147,565,93\n959,496,93\n435,874,92\n647,457,91\n380,147,91\n61,450,90\n781,370,89\n260,740,87\n383,367,86\n907,316,86\n117,926,85\n805,947,83\n436,783,82\n788,618,82\n336,896,81\n723,503,81\n527,783,78\n373,44,78\n748,460,77\n159,543,76\n663,150,76\n243,771,75\n513,522,75\n346,304,74\n98,648,72\n789,442,70\n942,160,70\n25,391,69\n372,961,67\n512,470,67\n871,608,66\n419,13,66\n908,287,65\n806,329,64\n825,141,63\n639,735,62\n187,849,60\n853,767,60\n169,588,60\n671,314,58\n286,36,55\n30,988,53\n933,986,50\n999,259,50\n268,39,50\n850,874,49\n305,790,49\n232,568,46\n652,674,45\n925,787,43\n980,483,41\n355,588,40\n388,623,39\n334,290,39\n373,698,38\n483,716,37\n337,445,35\n426,119,35\n169,288,33\n462,544,30\n886,1,30\n933,637,29\n955,485,29\n675,223,29\n577,221,29\n189,27,27\n505,631,26\n385,540,23\n584,190,23\n906,88,23\n407,663,22\n414,134,22\n605,926,21\n449,668,20\n635,965,19\n905,178,19\n14,19,19\n536,753,18\n401,739,18\n940,381,18\n727,515,17\n206,926,16\n949,185,16\n361,152,16\n719,914,14\n664,452,14\n115,231,12\n210,146,12\n80,24,9\n451,953,6\n97,333,4\n54,377,3\n600,535,1\n655,434,1\n=======\nadj lists:\n0:[16,47]\n1:[13,27,52,60]\n2:[11,33,96,97]\n3:[4,51]\n4:[3]\n5:[28,35]\n6:[25,44,53]\n7:[56,68]\n8:[18,95]\n9:[21,91,99]\n10:[63,77,89]\n11:[2,33,97]\n12:[31,39]\n13:[1,27,52]\n14:[29]\n15:[38,85]\n16:[0]\n18:[61,84]\n20:[34]\n21:[24,86,91]\n22:[83]\n23:[37]\n24:[21,31,86]\n25:[6,44]\n26:[69]\n27:[13,52]\n28:[35,65]\n29:[14,59]\n31:[24]\n32:[81,88]\n33:[97]\n35:[5,28]\n37:[23]\n38:[15]\n39:[12]\n44:[6,25]\n46:[50]\n47:[0]\n50:[46]\n56:[7,68]\n59:[29]\n63:[77]\n68:[7,56]\n77:[63]\n86:[21]\nans=7\n```"
                    },
                    {
                        "username": "anurag-k",
                        "content": "Got the same error. Store the distance between two points in double, int will round off the value and give an error."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@smbody](/smbody) should be  test case"
                    },
                    {
                        "username": "smbody",
                        "content": "But i am getting it as 8, what is so special abt this test case?\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588509/c-dfs-bfs-solutions-with-detonating-bomb-process-beating-90-22/"
                    }
                ]
            },
            {
                "id": 1565572,
                "content": [
                    {
                        "username": "darkalarm",
                        "content": "When I read the question, my first thought was using union find for this question. But after a few test cases, I could understand that the question is actually about a directed graph. Union Find works for an undirected graph.\\n\\n![image](https://assets.leetcode.com/users/images/f7fb76c8-9ab7-4044-bd5f-569b21621f01_1639243400.360309.png)\\n\\nYou can see from the example above, the green circle can detonate the blue circle. But not the other way round. This means, there will be a directed edge from green circle to blue circule.\\n\\nThe question is asking us to find the maximum number of connected nodes in this graph. BFS sounds like the best approach."
                    },
                    {
                        "username": "reassurance",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) \\nMaybe I can help you in understanding why DFS might be faster than BFS although the logic of this question can be handled by both. \\nIn my DFS code, it is seen that if we trail down the path of the possible bombs that can be detonated by the current bomb, we can see that we have a chance to discover bombs that might trigger a **CHAIN** reaction. In other words, a queue in BFS will take longer time to finish and might include bombs that are isolated thereby reducing the impact. \\nAlthough I would not fully agree with my explanation above, this intuition sounded right to me.\\n\\nWould love to see someone prove this!"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "thats good, but how about dfs, I did BFS but my beats were ery low . Seen some solutions thst used DFS, they were more efficient. Don\\'t know the logic why, but it is what it is. try that too and tell me too if you understand why DFS is better than BFS in this case."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "great job, bro"
                    },
                    {
                        "username": "prateek4463",
                        "content": "thanks ! "
                    },
                    {
                        "username": "anfatum",
                        "content": "`bombs` =\\n[[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]\\n`Expected`\\n1\\n\\nAren\\'t [69,51,7] and [65,59,3] intersecting thus there is more than one explosion? "
                    },
                    {
                        "username": "blackhat130",
                        "content": "[@LakshayTheGupta](/LakshayTheGupta) Haha, Great Explanation. "
                    },
                    {
                        "username": "LakshayTheGupta",
                        "content": "[@piudpie](/piudpie) No that must be common sense that to activate  the bomb , it should be inside the range of the exploding bomb. The bomb is not itself a circle with radius R. \\nConclusion : we lack common sense and leetcode is trying to prove in every problem \\uD83E\\uDD23. (I had 2-3 wrong submissions before figuring this issue out \\uD83E\\uDD79)"
                    },
                    {
                        "username": "piudpie",
                        "content": "[@lohani](/lohani) They should have mentioned it in the problem statement, thank you for clarifying though!"
                    },
                    {
                        "username": "psionl0",
                        "content": "the distance between the 2 bombs is sqrt((65-69)^2 + (59-51)^2) = 8.9 which is greater than the range of either bomb."
                    },
                    {
                        "username": "pulkit_singhall",
                        "content": "[@lohani](/lohani) What is the condition for centre to be inside the radius?"
                    },
                    {
                        "username": "lohani",
                        "content": "I stumbled on this same issue. But there is a catch in the problem statement. The second bomb will only be detonated if it\\'s center comes inside the radius of the first bomb. Just intersection of circles is not enough."
                    },
                    {
                        "username": "hengjunlin1129",
                        "content": "I figured out that\\nbomb A can trigger bomb B\\nbomb C can trigger bomb B\\nbomb B cannot trigger bomb A and C\\nbomb A, C cannot trigger each other\\nbut in Union Find A B C will be in same group. (cause A->B, C->B"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "but if c can detonate b, then b must also be able to detonate c"
                    },
                    {
                        "username": "tejasX",
                        "content": "Thanks. I got my mistake."
                    },
                    {
                        "username": "drekker007",
                        "content": "Thank you so much bro!! You made me realize my mistakes!!"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "[@R4Ks](/R4Ks) suppose A has center (0,0) and radius 10, B has center (0,8) and radius 2 , C has center at (0,12) and radius 4, now A can only detonate B, C can also detonate B but B can\\'t detonate either of A and C, neither can A and C detonate each other.."
                    },
                    {
                        "username": "psionl0",
                        "content": "Nope. Detonating one of the bombs won\\'t result in all of the bombs being detonated."
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Give an example and show me such a scenario"
                    },
                    {
                        "username": "rs9",
                        "content": "This problem can be easily solved by DFS/BFS from each vertex in O(N^2). But can it be solved in O(N*logN) or O(N*sqrtN)?\\n\\nIs it possible to somehow lower number of vertex pairs to process by using some data structure like R-tree or over data structures used for knn-algorithms.\\nIs it possible by finding strongly connected components and edge contractions lower asymptotic computation complexity from O(N^2) to O(NlogN), O(NsqrtN) or maybe even O(N).\\n\\nUPD: I found answer to my question. It is no. It\\'s impossible to be  O(N^(2-eps)) for any eps>0.\\nhttps://www.sciencedirect.com/science/article/abs/pii/S0020019016300734?via%3Dihub\\n\\n![image](https://assets.leetcode.com/users/images/459461ca-2281-4e25-bba7-00299938c183_1639421565.9786224.jpeg)\\n"
                    },
                    {
                        "username": "yjian012",
                        "content": "[@cecilia5](/cecilia5) That's exactly my thought too, I totally agree with the finding the SCCs part. But what do you do after getting the DAG? Suppose we start with a DAG, and you know the roots. How do you find the number of vertices that can be reached from each root? You still need to go through most of the vertices/edges again, I think, so it would still be O( |V|*(|V|+|E|) )."
                    },
                    {
                        "username": "Arana",
                        "content": "No. The graph is not given, so this problem cannot be solved by any algorithm less than O(n^3)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "If the graph is given, however, I wonder what\\'s wrong with this algorithm.\\n\\n1.) Run Tarjan\\'s to get the SCCs\\n2.) Create a DAG G\\' of SCCs\\n3.) Compute a topological sorted order T of the reverse of G\\'.\\n4.) For each SCC n in T, compute the size of the connected components starting from arbitrary node of n as the size of n plus the size of all the SCC child of it in G\\'. By the topological sort above, the size should be already there.\\n\\nThis should be $$ O(|V| + |E|) $$ for all steps (note that G\\' can be seen as a contraction of G so is smaller than G)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I wondered the same but I was thinking geometrically. If the bombs are all reaching each other, the adjacency list alone would have $$ O(n^2) $$ entries, so that\\'s the end of it."
                    },
                    {
                        "username": "idklol8",
                        "content": "recommend you not solve on airport wifi while waiting for boarding"
                    },
                    {
                        "username": "anonymousjohndoe999",
                        "content": "haha"
                    },
                    {
                        "username": "Petersburg",
                        "content": "tried and failed"
                    },
                    {
                        "username": "dominhnhut01",
                        "content": "Thank you! I just spent the whole 1 hour just to figure out why my Union Find is not working"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "While calculating the distance between two centers remember to cast the squared value with long. Rest is pretty straightforward in this."
                    },
                    {
                        "username": "tbaby",
                        "content": "Watch out for exceeding max int."
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "[@mfulbright](/mfulbright) Agree, overflow is so annoying and that\\'s why many people switch to Python."
                    },
                    {
                        "username": "mfulbright",
                        "content": "Yeah that got me for a minute too. I hate bullshit like that, it just makes me waste time switching my ints to longs to see if that\\'s what the problem is."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Take a look at Constraints. `O(n^3)` will be fast enough"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Test case:\n```\n[[647,457,91],[483,716,37],[426,119,35],[355,588,40],[850,874,49],[232,568,46],[886,1,30],[54,377,3],[933,986,50],[305,790,49],[372,961,67],[671,314,58],[577,221,29],[380,147,91],[600,535,1],[806,329,64],[536,753,18],[906,88,23],[436,783,82],[652,674,45],[449,668,20],[419,13,66],[853,767,60],[169,288,33],[871,608,66],[337,445,35],[388,623,39],[723,503,81],[14,19,19],[98,648,72],[147,565,93],[655,434,1],[407,663,22],[805,947,83],[942,160,70],[959,496,93],[30,988,53],[187,849,60],[980,483,41],[663,150,76],[268,39,50],[513,522,75],[61,450,90],[115,231,12],[346,304,74],[385,540,23],[905,178,19],[336,896,81],[751,811,94],[527,783,78],[635,965,19],[334,290,39],[748,460,77],[414,134,22],[955,485,29],[925,787,43],[243,771,75],[675,223,29],[788,618,82],[462,544,30],[999,259,50],[210,146,12],[789,442,70],[286,36,55],[451,953,6],[719,914,14],[664,452,14],[933,637,29],[206,926,16],[100,422,98],[97,333,4],[505,631,26],[908,287,65],[907,316,86],[949,185,16],[639,735,62],[401,739,18],[605,926,21],[25,391,69],[80,24,9],[435,874,92],[940,381,18],[260,740,87],[727,515,17],[361,152,16],[512,470,67],[189,27,27],[517,439,94],[159,543,76],[373,698,38],[781,836,97],[584,190,23],[383,367,86],[825,141,63],[117,926,85],[169,588,60],[56,981,100],[294,716,100],[781,370,89],[373,44,78]]\n```\nSort the bombs! Create the adjacent list. Then apply DFS and got the result 7!\n```\nn=100\n56,981,100\n294,716,100\n100,422,98\n781,836,97\n751,811,94\n517,439,94\n147,565,93\n959,496,93\n435,874,92\n647,457,91\n380,147,91\n61,450,90\n781,370,89\n260,740,87\n383,367,86\n907,316,86\n117,926,85\n805,947,83\n436,783,82\n788,618,82\n336,896,81\n723,503,81\n527,783,78\n373,44,78\n748,460,77\n159,543,76\n663,150,76\n243,771,75\n513,522,75\n346,304,74\n98,648,72\n789,442,70\n942,160,70\n25,391,69\n372,961,67\n512,470,67\n871,608,66\n419,13,66\n908,287,65\n806,329,64\n825,141,63\n639,735,62\n187,849,60\n853,767,60\n169,588,60\n671,314,58\n286,36,55\n30,988,53\n933,986,50\n999,259,50\n268,39,50\n850,874,49\n305,790,49\n232,568,46\n652,674,45\n925,787,43\n980,483,41\n355,588,40\n388,623,39\n334,290,39\n373,698,38\n483,716,37\n337,445,35\n426,119,35\n169,288,33\n462,544,30\n886,1,30\n933,637,29\n955,485,29\n675,223,29\n577,221,29\n189,27,27\n505,631,26\n385,540,23\n584,190,23\n906,88,23\n407,663,22\n414,134,22\n605,926,21\n449,668,20\n635,965,19\n905,178,19\n14,19,19\n536,753,18\n401,739,18\n940,381,18\n727,515,17\n206,926,16\n949,185,16\n361,152,16\n719,914,14\n664,452,14\n115,231,12\n210,146,12\n80,24,9\n451,953,6\n97,333,4\n54,377,3\n600,535,1\n655,434,1\n=======\nadj lists:\n0:[16,47]\n1:[13,27,52,60]\n2:[11,33,96,97]\n3:[4,51]\n4:[3]\n5:[28,35]\n6:[25,44,53]\n7:[56,68]\n8:[18,95]\n9:[21,91,99]\n10:[63,77,89]\n11:[2,33,97]\n12:[31,39]\n13:[1,27,52]\n14:[29]\n15:[38,85]\n16:[0]\n18:[61,84]\n20:[34]\n21:[24,86,91]\n22:[83]\n23:[37]\n24:[21,31,86]\n25:[6,44]\n26:[69]\n27:[13,52]\n28:[35,65]\n29:[14,59]\n31:[24]\n32:[81,88]\n33:[97]\n35:[5,28]\n37:[23]\n38:[15]\n39:[12]\n44:[6,25]\n46:[50]\n47:[0]\n50:[46]\n56:[7,68]\n59:[29]\n63:[77]\n68:[7,56]\n77:[63]\n86:[21]\nans=7\n```"
                    },
                    {
                        "username": "anurag-k",
                        "content": "Got the same error. Store the distance between two points in double, int will round off the value and give an error."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@smbody](/smbody) should be  test case"
                    },
                    {
                        "username": "smbody",
                        "content": "But i am getting it as 8, what is so special abt this test case?\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588509/c-dfs-bfs-solutions-with-detonating-bomb-process-beating-90-22/"
                    }
                ]
            },
            {
                "id": 1913561,
                "content": [
                    {
                        "username": "darkalarm",
                        "content": "When I read the question, my first thought was using union find for this question. But after a few test cases, I could understand that the question is actually about a directed graph. Union Find works for an undirected graph.\\n\\n![image](https://assets.leetcode.com/users/images/f7fb76c8-9ab7-4044-bd5f-569b21621f01_1639243400.360309.png)\\n\\nYou can see from the example above, the green circle can detonate the blue circle. But not the other way round. This means, there will be a directed edge from green circle to blue circule.\\n\\nThe question is asking us to find the maximum number of connected nodes in this graph. BFS sounds like the best approach."
                    },
                    {
                        "username": "reassurance",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) \\nMaybe I can help you in understanding why DFS might be faster than BFS although the logic of this question can be handled by both. \\nIn my DFS code, it is seen that if we trail down the path of the possible bombs that can be detonated by the current bomb, we can see that we have a chance to discover bombs that might trigger a **CHAIN** reaction. In other words, a queue in BFS will take longer time to finish and might include bombs that are isolated thereby reducing the impact. \\nAlthough I would not fully agree with my explanation above, this intuition sounded right to me.\\n\\nWould love to see someone prove this!"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "thats good, but how about dfs, I did BFS but my beats were ery low . Seen some solutions thst used DFS, they were more efficient. Don\\'t know the logic why, but it is what it is. try that too and tell me too if you understand why DFS is better than BFS in this case."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "great job, bro"
                    },
                    {
                        "username": "prateek4463",
                        "content": "thanks ! "
                    },
                    {
                        "username": "anfatum",
                        "content": "`bombs` =\\n[[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]\\n`Expected`\\n1\\n\\nAren\\'t [69,51,7] and [65,59,3] intersecting thus there is more than one explosion? "
                    },
                    {
                        "username": "blackhat130",
                        "content": "[@LakshayTheGupta](/LakshayTheGupta) Haha, Great Explanation. "
                    },
                    {
                        "username": "LakshayTheGupta",
                        "content": "[@piudpie](/piudpie) No that must be common sense that to activate  the bomb , it should be inside the range of the exploding bomb. The bomb is not itself a circle with radius R. \\nConclusion : we lack common sense and leetcode is trying to prove in every problem \\uD83E\\uDD23. (I had 2-3 wrong submissions before figuring this issue out \\uD83E\\uDD79)"
                    },
                    {
                        "username": "piudpie",
                        "content": "[@lohani](/lohani) They should have mentioned it in the problem statement, thank you for clarifying though!"
                    },
                    {
                        "username": "psionl0",
                        "content": "the distance between the 2 bombs is sqrt((65-69)^2 + (59-51)^2) = 8.9 which is greater than the range of either bomb."
                    },
                    {
                        "username": "pulkit_singhall",
                        "content": "[@lohani](/lohani) What is the condition for centre to be inside the radius?"
                    },
                    {
                        "username": "lohani",
                        "content": "I stumbled on this same issue. But there is a catch in the problem statement. The second bomb will only be detonated if it\\'s center comes inside the radius of the first bomb. Just intersection of circles is not enough."
                    },
                    {
                        "username": "hengjunlin1129",
                        "content": "I figured out that\\nbomb A can trigger bomb B\\nbomb C can trigger bomb B\\nbomb B cannot trigger bomb A and C\\nbomb A, C cannot trigger each other\\nbut in Union Find A B C will be in same group. (cause A->B, C->B"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "but if c can detonate b, then b must also be able to detonate c"
                    },
                    {
                        "username": "tejasX",
                        "content": "Thanks. I got my mistake."
                    },
                    {
                        "username": "drekker007",
                        "content": "Thank you so much bro!! You made me realize my mistakes!!"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "[@R4Ks](/R4Ks) suppose A has center (0,0) and radius 10, B has center (0,8) and radius 2 , C has center at (0,12) and radius 4, now A can only detonate B, C can also detonate B but B can\\'t detonate either of A and C, neither can A and C detonate each other.."
                    },
                    {
                        "username": "psionl0",
                        "content": "Nope. Detonating one of the bombs won\\'t result in all of the bombs being detonated."
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Give an example and show me such a scenario"
                    },
                    {
                        "username": "rs9",
                        "content": "This problem can be easily solved by DFS/BFS from each vertex in O(N^2). But can it be solved in O(N*logN) or O(N*sqrtN)?\\n\\nIs it possible to somehow lower number of vertex pairs to process by using some data structure like R-tree or over data structures used for knn-algorithms.\\nIs it possible by finding strongly connected components and edge contractions lower asymptotic computation complexity from O(N^2) to O(NlogN), O(NsqrtN) or maybe even O(N).\\n\\nUPD: I found answer to my question. It is no. It\\'s impossible to be  O(N^(2-eps)) for any eps>0.\\nhttps://www.sciencedirect.com/science/article/abs/pii/S0020019016300734?via%3Dihub\\n\\n![image](https://assets.leetcode.com/users/images/459461ca-2281-4e25-bba7-00299938c183_1639421565.9786224.jpeg)\\n"
                    },
                    {
                        "username": "yjian012",
                        "content": "[@cecilia5](/cecilia5) That's exactly my thought too, I totally agree with the finding the SCCs part. But what do you do after getting the DAG? Suppose we start with a DAG, and you know the roots. How do you find the number of vertices that can be reached from each root? You still need to go through most of the vertices/edges again, I think, so it would still be O( |V|*(|V|+|E|) )."
                    },
                    {
                        "username": "Arana",
                        "content": "No. The graph is not given, so this problem cannot be solved by any algorithm less than O(n^3)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "If the graph is given, however, I wonder what\\'s wrong with this algorithm.\\n\\n1.) Run Tarjan\\'s to get the SCCs\\n2.) Create a DAG G\\' of SCCs\\n3.) Compute a topological sorted order T of the reverse of G\\'.\\n4.) For each SCC n in T, compute the size of the connected components starting from arbitrary node of n as the size of n plus the size of all the SCC child of it in G\\'. By the topological sort above, the size should be already there.\\n\\nThis should be $$ O(|V| + |E|) $$ for all steps (note that G\\' can be seen as a contraction of G so is smaller than G)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I wondered the same but I was thinking geometrically. If the bombs are all reaching each other, the adjacency list alone would have $$ O(n^2) $$ entries, so that\\'s the end of it."
                    },
                    {
                        "username": "idklol8",
                        "content": "recommend you not solve on airport wifi while waiting for boarding"
                    },
                    {
                        "username": "anonymousjohndoe999",
                        "content": "haha"
                    },
                    {
                        "username": "Petersburg",
                        "content": "tried and failed"
                    },
                    {
                        "username": "dominhnhut01",
                        "content": "Thank you! I just spent the whole 1 hour just to figure out why my Union Find is not working"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "While calculating the distance between two centers remember to cast the squared value with long. Rest is pretty straightforward in this."
                    },
                    {
                        "username": "tbaby",
                        "content": "Watch out for exceeding max int."
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "[@mfulbright](/mfulbright) Agree, overflow is so annoying and that\\'s why many people switch to Python."
                    },
                    {
                        "username": "mfulbright",
                        "content": "Yeah that got me for a minute too. I hate bullshit like that, it just makes me waste time switching my ints to longs to see if that\\'s what the problem is."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Take a look at Constraints. `O(n^3)` will be fast enough"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Test case:\n```\n[[647,457,91],[483,716,37],[426,119,35],[355,588,40],[850,874,49],[232,568,46],[886,1,30],[54,377,3],[933,986,50],[305,790,49],[372,961,67],[671,314,58],[577,221,29],[380,147,91],[600,535,1],[806,329,64],[536,753,18],[906,88,23],[436,783,82],[652,674,45],[449,668,20],[419,13,66],[853,767,60],[169,288,33],[871,608,66],[337,445,35],[388,623,39],[723,503,81],[14,19,19],[98,648,72],[147,565,93],[655,434,1],[407,663,22],[805,947,83],[942,160,70],[959,496,93],[30,988,53],[187,849,60],[980,483,41],[663,150,76],[268,39,50],[513,522,75],[61,450,90],[115,231,12],[346,304,74],[385,540,23],[905,178,19],[336,896,81],[751,811,94],[527,783,78],[635,965,19],[334,290,39],[748,460,77],[414,134,22],[955,485,29],[925,787,43],[243,771,75],[675,223,29],[788,618,82],[462,544,30],[999,259,50],[210,146,12],[789,442,70],[286,36,55],[451,953,6],[719,914,14],[664,452,14],[933,637,29],[206,926,16],[100,422,98],[97,333,4],[505,631,26],[908,287,65],[907,316,86],[949,185,16],[639,735,62],[401,739,18],[605,926,21],[25,391,69],[80,24,9],[435,874,92],[940,381,18],[260,740,87],[727,515,17],[361,152,16],[512,470,67],[189,27,27],[517,439,94],[159,543,76],[373,698,38],[781,836,97],[584,190,23],[383,367,86],[825,141,63],[117,926,85],[169,588,60],[56,981,100],[294,716,100],[781,370,89],[373,44,78]]\n```\nSort the bombs! Create the adjacent list. Then apply DFS and got the result 7!\n```\nn=100\n56,981,100\n294,716,100\n100,422,98\n781,836,97\n751,811,94\n517,439,94\n147,565,93\n959,496,93\n435,874,92\n647,457,91\n380,147,91\n61,450,90\n781,370,89\n260,740,87\n383,367,86\n907,316,86\n117,926,85\n805,947,83\n436,783,82\n788,618,82\n336,896,81\n723,503,81\n527,783,78\n373,44,78\n748,460,77\n159,543,76\n663,150,76\n243,771,75\n513,522,75\n346,304,74\n98,648,72\n789,442,70\n942,160,70\n25,391,69\n372,961,67\n512,470,67\n871,608,66\n419,13,66\n908,287,65\n806,329,64\n825,141,63\n639,735,62\n187,849,60\n853,767,60\n169,588,60\n671,314,58\n286,36,55\n30,988,53\n933,986,50\n999,259,50\n268,39,50\n850,874,49\n305,790,49\n232,568,46\n652,674,45\n925,787,43\n980,483,41\n355,588,40\n388,623,39\n334,290,39\n373,698,38\n483,716,37\n337,445,35\n426,119,35\n169,288,33\n462,544,30\n886,1,30\n933,637,29\n955,485,29\n675,223,29\n577,221,29\n189,27,27\n505,631,26\n385,540,23\n584,190,23\n906,88,23\n407,663,22\n414,134,22\n605,926,21\n449,668,20\n635,965,19\n905,178,19\n14,19,19\n536,753,18\n401,739,18\n940,381,18\n727,515,17\n206,926,16\n949,185,16\n361,152,16\n719,914,14\n664,452,14\n115,231,12\n210,146,12\n80,24,9\n451,953,6\n97,333,4\n54,377,3\n600,535,1\n655,434,1\n=======\nadj lists:\n0:[16,47]\n1:[13,27,52,60]\n2:[11,33,96,97]\n3:[4,51]\n4:[3]\n5:[28,35]\n6:[25,44,53]\n7:[56,68]\n8:[18,95]\n9:[21,91,99]\n10:[63,77,89]\n11:[2,33,97]\n12:[31,39]\n13:[1,27,52]\n14:[29]\n15:[38,85]\n16:[0]\n18:[61,84]\n20:[34]\n21:[24,86,91]\n22:[83]\n23:[37]\n24:[21,31,86]\n25:[6,44]\n26:[69]\n27:[13,52]\n28:[35,65]\n29:[14,59]\n31:[24]\n32:[81,88]\n33:[97]\n35:[5,28]\n37:[23]\n38:[15]\n39:[12]\n44:[6,25]\n46:[50]\n47:[0]\n50:[46]\n56:[7,68]\n59:[29]\n63:[77]\n68:[7,56]\n77:[63]\n86:[21]\nans=7\n```"
                    },
                    {
                        "username": "anurag-k",
                        "content": "Got the same error. Store the distance between two points in double, int will round off the value and give an error."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@smbody](/smbody) should be  test case"
                    },
                    {
                        "username": "smbody",
                        "content": "But i am getting it as 8, what is so special abt this test case?\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588509/c-dfs-bfs-solutions-with-detonating-bomb-process-beating-90-22/"
                    }
                ]
            },
            {
                "id": 1735394,
                "content": [
                    {
                        "username": "darkalarm",
                        "content": "When I read the question, my first thought was using union find for this question. But after a few test cases, I could understand that the question is actually about a directed graph. Union Find works for an undirected graph.\\n\\n![image](https://assets.leetcode.com/users/images/f7fb76c8-9ab7-4044-bd5f-569b21621f01_1639243400.360309.png)\\n\\nYou can see from the example above, the green circle can detonate the blue circle. But not the other way round. This means, there will be a directed edge from green circle to blue circule.\\n\\nThe question is asking us to find the maximum number of connected nodes in this graph. BFS sounds like the best approach."
                    },
                    {
                        "username": "reassurance",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) \\nMaybe I can help you in understanding why DFS might be faster than BFS although the logic of this question can be handled by both. \\nIn my DFS code, it is seen that if we trail down the path of the possible bombs that can be detonated by the current bomb, we can see that we have a chance to discover bombs that might trigger a **CHAIN** reaction. In other words, a queue in BFS will take longer time to finish and might include bombs that are isolated thereby reducing the impact. \\nAlthough I would not fully agree with my explanation above, this intuition sounded right to me.\\n\\nWould love to see someone prove this!"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "thats good, but how about dfs, I did BFS but my beats were ery low . Seen some solutions thst used DFS, they were more efficient. Don\\'t know the logic why, but it is what it is. try that too and tell me too if you understand why DFS is better than BFS in this case."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "great job, bro"
                    },
                    {
                        "username": "prateek4463",
                        "content": "thanks ! "
                    },
                    {
                        "username": "anfatum",
                        "content": "`bombs` =\\n[[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]\\n`Expected`\\n1\\n\\nAren\\'t [69,51,7] and [65,59,3] intersecting thus there is more than one explosion? "
                    },
                    {
                        "username": "blackhat130",
                        "content": "[@LakshayTheGupta](/LakshayTheGupta) Haha, Great Explanation. "
                    },
                    {
                        "username": "LakshayTheGupta",
                        "content": "[@piudpie](/piudpie) No that must be common sense that to activate  the bomb , it should be inside the range of the exploding bomb. The bomb is not itself a circle with radius R. \\nConclusion : we lack common sense and leetcode is trying to prove in every problem \\uD83E\\uDD23. (I had 2-3 wrong submissions before figuring this issue out \\uD83E\\uDD79)"
                    },
                    {
                        "username": "piudpie",
                        "content": "[@lohani](/lohani) They should have mentioned it in the problem statement, thank you for clarifying though!"
                    },
                    {
                        "username": "psionl0",
                        "content": "the distance between the 2 bombs is sqrt((65-69)^2 + (59-51)^2) = 8.9 which is greater than the range of either bomb."
                    },
                    {
                        "username": "pulkit_singhall",
                        "content": "[@lohani](/lohani) What is the condition for centre to be inside the radius?"
                    },
                    {
                        "username": "lohani",
                        "content": "I stumbled on this same issue. But there is a catch in the problem statement. The second bomb will only be detonated if it\\'s center comes inside the radius of the first bomb. Just intersection of circles is not enough."
                    },
                    {
                        "username": "hengjunlin1129",
                        "content": "I figured out that\\nbomb A can trigger bomb B\\nbomb C can trigger bomb B\\nbomb B cannot trigger bomb A and C\\nbomb A, C cannot trigger each other\\nbut in Union Find A B C will be in same group. (cause A->B, C->B"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "but if c can detonate b, then b must also be able to detonate c"
                    },
                    {
                        "username": "tejasX",
                        "content": "Thanks. I got my mistake."
                    },
                    {
                        "username": "drekker007",
                        "content": "Thank you so much bro!! You made me realize my mistakes!!"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "[@R4Ks](/R4Ks) suppose A has center (0,0) and radius 10, B has center (0,8) and radius 2 , C has center at (0,12) and radius 4, now A can only detonate B, C can also detonate B but B can\\'t detonate either of A and C, neither can A and C detonate each other.."
                    },
                    {
                        "username": "psionl0",
                        "content": "Nope. Detonating one of the bombs won\\'t result in all of the bombs being detonated."
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Give an example and show me such a scenario"
                    },
                    {
                        "username": "rs9",
                        "content": "This problem can be easily solved by DFS/BFS from each vertex in O(N^2). But can it be solved in O(N*logN) or O(N*sqrtN)?\\n\\nIs it possible to somehow lower number of vertex pairs to process by using some data structure like R-tree or over data structures used for knn-algorithms.\\nIs it possible by finding strongly connected components and edge contractions lower asymptotic computation complexity from O(N^2) to O(NlogN), O(NsqrtN) or maybe even O(N).\\n\\nUPD: I found answer to my question. It is no. It\\'s impossible to be  O(N^(2-eps)) for any eps>0.\\nhttps://www.sciencedirect.com/science/article/abs/pii/S0020019016300734?via%3Dihub\\n\\n![image](https://assets.leetcode.com/users/images/459461ca-2281-4e25-bba7-00299938c183_1639421565.9786224.jpeg)\\n"
                    },
                    {
                        "username": "yjian012",
                        "content": "[@cecilia5](/cecilia5) That's exactly my thought too, I totally agree with the finding the SCCs part. But what do you do after getting the DAG? Suppose we start with a DAG, and you know the roots. How do you find the number of vertices that can be reached from each root? You still need to go through most of the vertices/edges again, I think, so it would still be O( |V|*(|V|+|E|) )."
                    },
                    {
                        "username": "Arana",
                        "content": "No. The graph is not given, so this problem cannot be solved by any algorithm less than O(n^3)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "If the graph is given, however, I wonder what\\'s wrong with this algorithm.\\n\\n1.) Run Tarjan\\'s to get the SCCs\\n2.) Create a DAG G\\' of SCCs\\n3.) Compute a topological sorted order T of the reverse of G\\'.\\n4.) For each SCC n in T, compute the size of the connected components starting from arbitrary node of n as the size of n plus the size of all the SCC child of it in G\\'. By the topological sort above, the size should be already there.\\n\\nThis should be $$ O(|V| + |E|) $$ for all steps (note that G\\' can be seen as a contraction of G so is smaller than G)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I wondered the same but I was thinking geometrically. If the bombs are all reaching each other, the adjacency list alone would have $$ O(n^2) $$ entries, so that\\'s the end of it."
                    },
                    {
                        "username": "idklol8",
                        "content": "recommend you not solve on airport wifi while waiting for boarding"
                    },
                    {
                        "username": "anonymousjohndoe999",
                        "content": "haha"
                    },
                    {
                        "username": "Petersburg",
                        "content": "tried and failed"
                    },
                    {
                        "username": "dominhnhut01",
                        "content": "Thank you! I just spent the whole 1 hour just to figure out why my Union Find is not working"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "While calculating the distance between two centers remember to cast the squared value with long. Rest is pretty straightforward in this."
                    },
                    {
                        "username": "tbaby",
                        "content": "Watch out for exceeding max int."
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "[@mfulbright](/mfulbright) Agree, overflow is so annoying and that\\'s why many people switch to Python."
                    },
                    {
                        "username": "mfulbright",
                        "content": "Yeah that got me for a minute too. I hate bullshit like that, it just makes me waste time switching my ints to longs to see if that\\'s what the problem is."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Take a look at Constraints. `O(n^3)` will be fast enough"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Test case:\n```\n[[647,457,91],[483,716,37],[426,119,35],[355,588,40],[850,874,49],[232,568,46],[886,1,30],[54,377,3],[933,986,50],[305,790,49],[372,961,67],[671,314,58],[577,221,29],[380,147,91],[600,535,1],[806,329,64],[536,753,18],[906,88,23],[436,783,82],[652,674,45],[449,668,20],[419,13,66],[853,767,60],[169,288,33],[871,608,66],[337,445,35],[388,623,39],[723,503,81],[14,19,19],[98,648,72],[147,565,93],[655,434,1],[407,663,22],[805,947,83],[942,160,70],[959,496,93],[30,988,53],[187,849,60],[980,483,41],[663,150,76],[268,39,50],[513,522,75],[61,450,90],[115,231,12],[346,304,74],[385,540,23],[905,178,19],[336,896,81],[751,811,94],[527,783,78],[635,965,19],[334,290,39],[748,460,77],[414,134,22],[955,485,29],[925,787,43],[243,771,75],[675,223,29],[788,618,82],[462,544,30],[999,259,50],[210,146,12],[789,442,70],[286,36,55],[451,953,6],[719,914,14],[664,452,14],[933,637,29],[206,926,16],[100,422,98],[97,333,4],[505,631,26],[908,287,65],[907,316,86],[949,185,16],[639,735,62],[401,739,18],[605,926,21],[25,391,69],[80,24,9],[435,874,92],[940,381,18],[260,740,87],[727,515,17],[361,152,16],[512,470,67],[189,27,27],[517,439,94],[159,543,76],[373,698,38],[781,836,97],[584,190,23],[383,367,86],[825,141,63],[117,926,85],[169,588,60],[56,981,100],[294,716,100],[781,370,89],[373,44,78]]\n```\nSort the bombs! Create the adjacent list. Then apply DFS and got the result 7!\n```\nn=100\n56,981,100\n294,716,100\n100,422,98\n781,836,97\n751,811,94\n517,439,94\n147,565,93\n959,496,93\n435,874,92\n647,457,91\n380,147,91\n61,450,90\n781,370,89\n260,740,87\n383,367,86\n907,316,86\n117,926,85\n805,947,83\n436,783,82\n788,618,82\n336,896,81\n723,503,81\n527,783,78\n373,44,78\n748,460,77\n159,543,76\n663,150,76\n243,771,75\n513,522,75\n346,304,74\n98,648,72\n789,442,70\n942,160,70\n25,391,69\n372,961,67\n512,470,67\n871,608,66\n419,13,66\n908,287,65\n806,329,64\n825,141,63\n639,735,62\n187,849,60\n853,767,60\n169,588,60\n671,314,58\n286,36,55\n30,988,53\n933,986,50\n999,259,50\n268,39,50\n850,874,49\n305,790,49\n232,568,46\n652,674,45\n925,787,43\n980,483,41\n355,588,40\n388,623,39\n334,290,39\n373,698,38\n483,716,37\n337,445,35\n426,119,35\n169,288,33\n462,544,30\n886,1,30\n933,637,29\n955,485,29\n675,223,29\n577,221,29\n189,27,27\n505,631,26\n385,540,23\n584,190,23\n906,88,23\n407,663,22\n414,134,22\n605,926,21\n449,668,20\n635,965,19\n905,178,19\n14,19,19\n536,753,18\n401,739,18\n940,381,18\n727,515,17\n206,926,16\n949,185,16\n361,152,16\n719,914,14\n664,452,14\n115,231,12\n210,146,12\n80,24,9\n451,953,6\n97,333,4\n54,377,3\n600,535,1\n655,434,1\n=======\nadj lists:\n0:[16,47]\n1:[13,27,52,60]\n2:[11,33,96,97]\n3:[4,51]\n4:[3]\n5:[28,35]\n6:[25,44,53]\n7:[56,68]\n8:[18,95]\n9:[21,91,99]\n10:[63,77,89]\n11:[2,33,97]\n12:[31,39]\n13:[1,27,52]\n14:[29]\n15:[38,85]\n16:[0]\n18:[61,84]\n20:[34]\n21:[24,86,91]\n22:[83]\n23:[37]\n24:[21,31,86]\n25:[6,44]\n26:[69]\n27:[13,52]\n28:[35,65]\n29:[14,59]\n31:[24]\n32:[81,88]\n33:[97]\n35:[5,28]\n37:[23]\n38:[15]\n39:[12]\n44:[6,25]\n46:[50]\n47:[0]\n50:[46]\n56:[7,68]\n59:[29]\n63:[77]\n68:[7,56]\n77:[63]\n86:[21]\nans=7\n```"
                    },
                    {
                        "username": "anurag-k",
                        "content": "Got the same error. Store the distance between two points in double, int will round off the value and give an error."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@smbody](/smbody) should be  test case"
                    },
                    {
                        "username": "smbody",
                        "content": "But i am getting it as 8, what is so special abt this test case?\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588509/c-dfs-bfs-solutions-with-detonating-bomb-process-beating-90-22/"
                    }
                ]
            },
            {
                "id": 1914030,
                "content": [
                    {
                        "username": "darkalarm",
                        "content": "When I read the question, my first thought was using union find for this question. But after a few test cases, I could understand that the question is actually about a directed graph. Union Find works for an undirected graph.\\n\\n![image](https://assets.leetcode.com/users/images/f7fb76c8-9ab7-4044-bd5f-569b21621f01_1639243400.360309.png)\\n\\nYou can see from the example above, the green circle can detonate the blue circle. But not the other way round. This means, there will be a directed edge from green circle to blue circule.\\n\\nThe question is asking us to find the maximum number of connected nodes in this graph. BFS sounds like the best approach."
                    },
                    {
                        "username": "reassurance",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) \\nMaybe I can help you in understanding why DFS might be faster than BFS although the logic of this question can be handled by both. \\nIn my DFS code, it is seen that if we trail down the path of the possible bombs that can be detonated by the current bomb, we can see that we have a chance to discover bombs that might trigger a **CHAIN** reaction. In other words, a queue in BFS will take longer time to finish and might include bombs that are isolated thereby reducing the impact. \\nAlthough I would not fully agree with my explanation above, this intuition sounded right to me.\\n\\nWould love to see someone prove this!"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "thats good, but how about dfs, I did BFS but my beats were ery low . Seen some solutions thst used DFS, they were more efficient. Don\\'t know the logic why, but it is what it is. try that too and tell me too if you understand why DFS is better than BFS in this case."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "great job, bro"
                    },
                    {
                        "username": "prateek4463",
                        "content": "thanks ! "
                    },
                    {
                        "username": "anfatum",
                        "content": "`bombs` =\\n[[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]\\n`Expected`\\n1\\n\\nAren\\'t [69,51,7] and [65,59,3] intersecting thus there is more than one explosion? "
                    },
                    {
                        "username": "blackhat130",
                        "content": "[@LakshayTheGupta](/LakshayTheGupta) Haha, Great Explanation. "
                    },
                    {
                        "username": "LakshayTheGupta",
                        "content": "[@piudpie](/piudpie) No that must be common sense that to activate  the bomb , it should be inside the range of the exploding bomb. The bomb is not itself a circle with radius R. \\nConclusion : we lack common sense and leetcode is trying to prove in every problem \\uD83E\\uDD23. (I had 2-3 wrong submissions before figuring this issue out \\uD83E\\uDD79)"
                    },
                    {
                        "username": "piudpie",
                        "content": "[@lohani](/lohani) They should have mentioned it in the problem statement, thank you for clarifying though!"
                    },
                    {
                        "username": "psionl0",
                        "content": "the distance between the 2 bombs is sqrt((65-69)^2 + (59-51)^2) = 8.9 which is greater than the range of either bomb."
                    },
                    {
                        "username": "pulkit_singhall",
                        "content": "[@lohani](/lohani) What is the condition for centre to be inside the radius?"
                    },
                    {
                        "username": "lohani",
                        "content": "I stumbled on this same issue. But there is a catch in the problem statement. The second bomb will only be detonated if it\\'s center comes inside the radius of the first bomb. Just intersection of circles is not enough."
                    },
                    {
                        "username": "hengjunlin1129",
                        "content": "I figured out that\\nbomb A can trigger bomb B\\nbomb C can trigger bomb B\\nbomb B cannot trigger bomb A and C\\nbomb A, C cannot trigger each other\\nbut in Union Find A B C will be in same group. (cause A->B, C->B"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "but if c can detonate b, then b must also be able to detonate c"
                    },
                    {
                        "username": "tejasX",
                        "content": "Thanks. I got my mistake."
                    },
                    {
                        "username": "drekker007",
                        "content": "Thank you so much bro!! You made me realize my mistakes!!"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "[@R4Ks](/R4Ks) suppose A has center (0,0) and radius 10, B has center (0,8) and radius 2 , C has center at (0,12) and radius 4, now A can only detonate B, C can also detonate B but B can\\'t detonate either of A and C, neither can A and C detonate each other.."
                    },
                    {
                        "username": "psionl0",
                        "content": "Nope. Detonating one of the bombs won\\'t result in all of the bombs being detonated."
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Give an example and show me such a scenario"
                    },
                    {
                        "username": "rs9",
                        "content": "This problem can be easily solved by DFS/BFS from each vertex in O(N^2). But can it be solved in O(N*logN) or O(N*sqrtN)?\\n\\nIs it possible to somehow lower number of vertex pairs to process by using some data structure like R-tree or over data structures used for knn-algorithms.\\nIs it possible by finding strongly connected components and edge contractions lower asymptotic computation complexity from O(N^2) to O(NlogN), O(NsqrtN) or maybe even O(N).\\n\\nUPD: I found answer to my question. It is no. It\\'s impossible to be  O(N^(2-eps)) for any eps>0.\\nhttps://www.sciencedirect.com/science/article/abs/pii/S0020019016300734?via%3Dihub\\n\\n![image](https://assets.leetcode.com/users/images/459461ca-2281-4e25-bba7-00299938c183_1639421565.9786224.jpeg)\\n"
                    },
                    {
                        "username": "yjian012",
                        "content": "[@cecilia5](/cecilia5) That's exactly my thought too, I totally agree with the finding the SCCs part. But what do you do after getting the DAG? Suppose we start with a DAG, and you know the roots. How do you find the number of vertices that can be reached from each root? You still need to go through most of the vertices/edges again, I think, so it would still be O( |V|*(|V|+|E|) )."
                    },
                    {
                        "username": "Arana",
                        "content": "No. The graph is not given, so this problem cannot be solved by any algorithm less than O(n^3)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "If the graph is given, however, I wonder what\\'s wrong with this algorithm.\\n\\n1.) Run Tarjan\\'s to get the SCCs\\n2.) Create a DAG G\\' of SCCs\\n3.) Compute a topological sorted order T of the reverse of G\\'.\\n4.) For each SCC n in T, compute the size of the connected components starting from arbitrary node of n as the size of n plus the size of all the SCC child of it in G\\'. By the topological sort above, the size should be already there.\\n\\nThis should be $$ O(|V| + |E|) $$ for all steps (note that G\\' can be seen as a contraction of G so is smaller than G)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I wondered the same but I was thinking geometrically. If the bombs are all reaching each other, the adjacency list alone would have $$ O(n^2) $$ entries, so that\\'s the end of it."
                    },
                    {
                        "username": "idklol8",
                        "content": "recommend you not solve on airport wifi while waiting for boarding"
                    },
                    {
                        "username": "anonymousjohndoe999",
                        "content": "haha"
                    },
                    {
                        "username": "Petersburg",
                        "content": "tried and failed"
                    },
                    {
                        "username": "dominhnhut01",
                        "content": "Thank you! I just spent the whole 1 hour just to figure out why my Union Find is not working"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "While calculating the distance between two centers remember to cast the squared value with long. Rest is pretty straightforward in this."
                    },
                    {
                        "username": "tbaby",
                        "content": "Watch out for exceeding max int."
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "[@mfulbright](/mfulbright) Agree, overflow is so annoying and that\\'s why many people switch to Python."
                    },
                    {
                        "username": "mfulbright",
                        "content": "Yeah that got me for a minute too. I hate bullshit like that, it just makes me waste time switching my ints to longs to see if that\\'s what the problem is."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Take a look at Constraints. `O(n^3)` will be fast enough"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Test case:\n```\n[[647,457,91],[483,716,37],[426,119,35],[355,588,40],[850,874,49],[232,568,46],[886,1,30],[54,377,3],[933,986,50],[305,790,49],[372,961,67],[671,314,58],[577,221,29],[380,147,91],[600,535,1],[806,329,64],[536,753,18],[906,88,23],[436,783,82],[652,674,45],[449,668,20],[419,13,66],[853,767,60],[169,288,33],[871,608,66],[337,445,35],[388,623,39],[723,503,81],[14,19,19],[98,648,72],[147,565,93],[655,434,1],[407,663,22],[805,947,83],[942,160,70],[959,496,93],[30,988,53],[187,849,60],[980,483,41],[663,150,76],[268,39,50],[513,522,75],[61,450,90],[115,231,12],[346,304,74],[385,540,23],[905,178,19],[336,896,81],[751,811,94],[527,783,78],[635,965,19],[334,290,39],[748,460,77],[414,134,22],[955,485,29],[925,787,43],[243,771,75],[675,223,29],[788,618,82],[462,544,30],[999,259,50],[210,146,12],[789,442,70],[286,36,55],[451,953,6],[719,914,14],[664,452,14],[933,637,29],[206,926,16],[100,422,98],[97,333,4],[505,631,26],[908,287,65],[907,316,86],[949,185,16],[639,735,62],[401,739,18],[605,926,21],[25,391,69],[80,24,9],[435,874,92],[940,381,18],[260,740,87],[727,515,17],[361,152,16],[512,470,67],[189,27,27],[517,439,94],[159,543,76],[373,698,38],[781,836,97],[584,190,23],[383,367,86],[825,141,63],[117,926,85],[169,588,60],[56,981,100],[294,716,100],[781,370,89],[373,44,78]]\n```\nSort the bombs! Create the adjacent list. Then apply DFS and got the result 7!\n```\nn=100\n56,981,100\n294,716,100\n100,422,98\n781,836,97\n751,811,94\n517,439,94\n147,565,93\n959,496,93\n435,874,92\n647,457,91\n380,147,91\n61,450,90\n781,370,89\n260,740,87\n383,367,86\n907,316,86\n117,926,85\n805,947,83\n436,783,82\n788,618,82\n336,896,81\n723,503,81\n527,783,78\n373,44,78\n748,460,77\n159,543,76\n663,150,76\n243,771,75\n513,522,75\n346,304,74\n98,648,72\n789,442,70\n942,160,70\n25,391,69\n372,961,67\n512,470,67\n871,608,66\n419,13,66\n908,287,65\n806,329,64\n825,141,63\n639,735,62\n187,849,60\n853,767,60\n169,588,60\n671,314,58\n286,36,55\n30,988,53\n933,986,50\n999,259,50\n268,39,50\n850,874,49\n305,790,49\n232,568,46\n652,674,45\n925,787,43\n980,483,41\n355,588,40\n388,623,39\n334,290,39\n373,698,38\n483,716,37\n337,445,35\n426,119,35\n169,288,33\n462,544,30\n886,1,30\n933,637,29\n955,485,29\n675,223,29\n577,221,29\n189,27,27\n505,631,26\n385,540,23\n584,190,23\n906,88,23\n407,663,22\n414,134,22\n605,926,21\n449,668,20\n635,965,19\n905,178,19\n14,19,19\n536,753,18\n401,739,18\n940,381,18\n727,515,17\n206,926,16\n949,185,16\n361,152,16\n719,914,14\n664,452,14\n115,231,12\n210,146,12\n80,24,9\n451,953,6\n97,333,4\n54,377,3\n600,535,1\n655,434,1\n=======\nadj lists:\n0:[16,47]\n1:[13,27,52,60]\n2:[11,33,96,97]\n3:[4,51]\n4:[3]\n5:[28,35]\n6:[25,44,53]\n7:[56,68]\n8:[18,95]\n9:[21,91,99]\n10:[63,77,89]\n11:[2,33,97]\n12:[31,39]\n13:[1,27,52]\n14:[29]\n15:[38,85]\n16:[0]\n18:[61,84]\n20:[34]\n21:[24,86,91]\n22:[83]\n23:[37]\n24:[21,31,86]\n25:[6,44]\n26:[69]\n27:[13,52]\n28:[35,65]\n29:[14,59]\n31:[24]\n32:[81,88]\n33:[97]\n35:[5,28]\n37:[23]\n38:[15]\n39:[12]\n44:[6,25]\n46:[50]\n47:[0]\n50:[46]\n56:[7,68]\n59:[29]\n63:[77]\n68:[7,56]\n77:[63]\n86:[21]\nans=7\n```"
                    },
                    {
                        "username": "anurag-k",
                        "content": "Got the same error. Store the distance between two points in double, int will round off the value and give an error."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@smbody](/smbody) should be  test case"
                    },
                    {
                        "username": "smbody",
                        "content": "But i am getting it as 8, what is so special abt this test case?\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588509/c-dfs-bfs-solutions-with-detonating-bomb-process-beating-90-22/"
                    }
                ]
            },
            {
                "id": 1913900,
                "content": [
                    {
                        "username": "darkalarm",
                        "content": "When I read the question, my first thought was using union find for this question. But after a few test cases, I could understand that the question is actually about a directed graph. Union Find works for an undirected graph.\\n\\n![image](https://assets.leetcode.com/users/images/f7fb76c8-9ab7-4044-bd5f-569b21621f01_1639243400.360309.png)\\n\\nYou can see from the example above, the green circle can detonate the blue circle. But not the other way round. This means, there will be a directed edge from green circle to blue circule.\\n\\nThe question is asking us to find the maximum number of connected nodes in this graph. BFS sounds like the best approach."
                    },
                    {
                        "username": "reassurance",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) \\nMaybe I can help you in understanding why DFS might be faster than BFS although the logic of this question can be handled by both. \\nIn my DFS code, it is seen that if we trail down the path of the possible bombs that can be detonated by the current bomb, we can see that we have a chance to discover bombs that might trigger a **CHAIN** reaction. In other words, a queue in BFS will take longer time to finish and might include bombs that are isolated thereby reducing the impact. \\nAlthough I would not fully agree with my explanation above, this intuition sounded right to me.\\n\\nWould love to see someone prove this!"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "thats good, but how about dfs, I did BFS but my beats were ery low . Seen some solutions thst used DFS, they were more efficient. Don\\'t know the logic why, but it is what it is. try that too and tell me too if you understand why DFS is better than BFS in this case."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "great job, bro"
                    },
                    {
                        "username": "prateek4463",
                        "content": "thanks ! "
                    },
                    {
                        "username": "anfatum",
                        "content": "`bombs` =\\n[[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]\\n`Expected`\\n1\\n\\nAren\\'t [69,51,7] and [65,59,3] intersecting thus there is more than one explosion? "
                    },
                    {
                        "username": "blackhat130",
                        "content": "[@LakshayTheGupta](/LakshayTheGupta) Haha, Great Explanation. "
                    },
                    {
                        "username": "LakshayTheGupta",
                        "content": "[@piudpie](/piudpie) No that must be common sense that to activate  the bomb , it should be inside the range of the exploding bomb. The bomb is not itself a circle with radius R. \\nConclusion : we lack common sense and leetcode is trying to prove in every problem \\uD83E\\uDD23. (I had 2-3 wrong submissions before figuring this issue out \\uD83E\\uDD79)"
                    },
                    {
                        "username": "piudpie",
                        "content": "[@lohani](/lohani) They should have mentioned it in the problem statement, thank you for clarifying though!"
                    },
                    {
                        "username": "psionl0",
                        "content": "the distance between the 2 bombs is sqrt((65-69)^2 + (59-51)^2) = 8.9 which is greater than the range of either bomb."
                    },
                    {
                        "username": "pulkit_singhall",
                        "content": "[@lohani](/lohani) What is the condition for centre to be inside the radius?"
                    },
                    {
                        "username": "lohani",
                        "content": "I stumbled on this same issue. But there is a catch in the problem statement. The second bomb will only be detonated if it\\'s center comes inside the radius of the first bomb. Just intersection of circles is not enough."
                    },
                    {
                        "username": "hengjunlin1129",
                        "content": "I figured out that\\nbomb A can trigger bomb B\\nbomb C can trigger bomb B\\nbomb B cannot trigger bomb A and C\\nbomb A, C cannot trigger each other\\nbut in Union Find A B C will be in same group. (cause A->B, C->B"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "but if c can detonate b, then b must also be able to detonate c"
                    },
                    {
                        "username": "tejasX",
                        "content": "Thanks. I got my mistake."
                    },
                    {
                        "username": "drekker007",
                        "content": "Thank you so much bro!! You made me realize my mistakes!!"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "[@R4Ks](/R4Ks) suppose A has center (0,0) and radius 10, B has center (0,8) and radius 2 , C has center at (0,12) and radius 4, now A can only detonate B, C can also detonate B but B can\\'t detonate either of A and C, neither can A and C detonate each other.."
                    },
                    {
                        "username": "psionl0",
                        "content": "Nope. Detonating one of the bombs won\\'t result in all of the bombs being detonated."
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Give an example and show me such a scenario"
                    },
                    {
                        "username": "rs9",
                        "content": "This problem can be easily solved by DFS/BFS from each vertex in O(N^2). But can it be solved in O(N*logN) or O(N*sqrtN)?\\n\\nIs it possible to somehow lower number of vertex pairs to process by using some data structure like R-tree or over data structures used for knn-algorithms.\\nIs it possible by finding strongly connected components and edge contractions lower asymptotic computation complexity from O(N^2) to O(NlogN), O(NsqrtN) or maybe even O(N).\\n\\nUPD: I found answer to my question. It is no. It\\'s impossible to be  O(N^(2-eps)) for any eps>0.\\nhttps://www.sciencedirect.com/science/article/abs/pii/S0020019016300734?via%3Dihub\\n\\n![image](https://assets.leetcode.com/users/images/459461ca-2281-4e25-bba7-00299938c183_1639421565.9786224.jpeg)\\n"
                    },
                    {
                        "username": "yjian012",
                        "content": "[@cecilia5](/cecilia5) That's exactly my thought too, I totally agree with the finding the SCCs part. But what do you do after getting the DAG? Suppose we start with a DAG, and you know the roots. How do you find the number of vertices that can be reached from each root? You still need to go through most of the vertices/edges again, I think, so it would still be O( |V|*(|V|+|E|) )."
                    },
                    {
                        "username": "Arana",
                        "content": "No. The graph is not given, so this problem cannot be solved by any algorithm less than O(n^3)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "If the graph is given, however, I wonder what\\'s wrong with this algorithm.\\n\\n1.) Run Tarjan\\'s to get the SCCs\\n2.) Create a DAG G\\' of SCCs\\n3.) Compute a topological sorted order T of the reverse of G\\'.\\n4.) For each SCC n in T, compute the size of the connected components starting from arbitrary node of n as the size of n plus the size of all the SCC child of it in G\\'. By the topological sort above, the size should be already there.\\n\\nThis should be $$ O(|V| + |E|) $$ for all steps (note that G\\' can be seen as a contraction of G so is smaller than G)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I wondered the same but I was thinking geometrically. If the bombs are all reaching each other, the adjacency list alone would have $$ O(n^2) $$ entries, so that\\'s the end of it."
                    },
                    {
                        "username": "idklol8",
                        "content": "recommend you not solve on airport wifi while waiting for boarding"
                    },
                    {
                        "username": "anonymousjohndoe999",
                        "content": "haha"
                    },
                    {
                        "username": "Petersburg",
                        "content": "tried and failed"
                    },
                    {
                        "username": "dominhnhut01",
                        "content": "Thank you! I just spent the whole 1 hour just to figure out why my Union Find is not working"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "While calculating the distance between two centers remember to cast the squared value with long. Rest is pretty straightforward in this."
                    },
                    {
                        "username": "tbaby",
                        "content": "Watch out for exceeding max int."
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "[@mfulbright](/mfulbright) Agree, overflow is so annoying and that\\'s why many people switch to Python."
                    },
                    {
                        "username": "mfulbright",
                        "content": "Yeah that got me for a minute too. I hate bullshit like that, it just makes me waste time switching my ints to longs to see if that\\'s what the problem is."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Take a look at Constraints. `O(n^3)` will be fast enough"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Test case:\n```\n[[647,457,91],[483,716,37],[426,119,35],[355,588,40],[850,874,49],[232,568,46],[886,1,30],[54,377,3],[933,986,50],[305,790,49],[372,961,67],[671,314,58],[577,221,29],[380,147,91],[600,535,1],[806,329,64],[536,753,18],[906,88,23],[436,783,82],[652,674,45],[449,668,20],[419,13,66],[853,767,60],[169,288,33],[871,608,66],[337,445,35],[388,623,39],[723,503,81],[14,19,19],[98,648,72],[147,565,93],[655,434,1],[407,663,22],[805,947,83],[942,160,70],[959,496,93],[30,988,53],[187,849,60],[980,483,41],[663,150,76],[268,39,50],[513,522,75],[61,450,90],[115,231,12],[346,304,74],[385,540,23],[905,178,19],[336,896,81],[751,811,94],[527,783,78],[635,965,19],[334,290,39],[748,460,77],[414,134,22],[955,485,29],[925,787,43],[243,771,75],[675,223,29],[788,618,82],[462,544,30],[999,259,50],[210,146,12],[789,442,70],[286,36,55],[451,953,6],[719,914,14],[664,452,14],[933,637,29],[206,926,16],[100,422,98],[97,333,4],[505,631,26],[908,287,65],[907,316,86],[949,185,16],[639,735,62],[401,739,18],[605,926,21],[25,391,69],[80,24,9],[435,874,92],[940,381,18],[260,740,87],[727,515,17],[361,152,16],[512,470,67],[189,27,27],[517,439,94],[159,543,76],[373,698,38],[781,836,97],[584,190,23],[383,367,86],[825,141,63],[117,926,85],[169,588,60],[56,981,100],[294,716,100],[781,370,89],[373,44,78]]\n```\nSort the bombs! Create the adjacent list. Then apply DFS and got the result 7!\n```\nn=100\n56,981,100\n294,716,100\n100,422,98\n781,836,97\n751,811,94\n517,439,94\n147,565,93\n959,496,93\n435,874,92\n647,457,91\n380,147,91\n61,450,90\n781,370,89\n260,740,87\n383,367,86\n907,316,86\n117,926,85\n805,947,83\n436,783,82\n788,618,82\n336,896,81\n723,503,81\n527,783,78\n373,44,78\n748,460,77\n159,543,76\n663,150,76\n243,771,75\n513,522,75\n346,304,74\n98,648,72\n789,442,70\n942,160,70\n25,391,69\n372,961,67\n512,470,67\n871,608,66\n419,13,66\n908,287,65\n806,329,64\n825,141,63\n639,735,62\n187,849,60\n853,767,60\n169,588,60\n671,314,58\n286,36,55\n30,988,53\n933,986,50\n999,259,50\n268,39,50\n850,874,49\n305,790,49\n232,568,46\n652,674,45\n925,787,43\n980,483,41\n355,588,40\n388,623,39\n334,290,39\n373,698,38\n483,716,37\n337,445,35\n426,119,35\n169,288,33\n462,544,30\n886,1,30\n933,637,29\n955,485,29\n675,223,29\n577,221,29\n189,27,27\n505,631,26\n385,540,23\n584,190,23\n906,88,23\n407,663,22\n414,134,22\n605,926,21\n449,668,20\n635,965,19\n905,178,19\n14,19,19\n536,753,18\n401,739,18\n940,381,18\n727,515,17\n206,926,16\n949,185,16\n361,152,16\n719,914,14\n664,452,14\n115,231,12\n210,146,12\n80,24,9\n451,953,6\n97,333,4\n54,377,3\n600,535,1\n655,434,1\n=======\nadj lists:\n0:[16,47]\n1:[13,27,52,60]\n2:[11,33,96,97]\n3:[4,51]\n4:[3]\n5:[28,35]\n6:[25,44,53]\n7:[56,68]\n8:[18,95]\n9:[21,91,99]\n10:[63,77,89]\n11:[2,33,97]\n12:[31,39]\n13:[1,27,52]\n14:[29]\n15:[38,85]\n16:[0]\n18:[61,84]\n20:[34]\n21:[24,86,91]\n22:[83]\n23:[37]\n24:[21,31,86]\n25:[6,44]\n26:[69]\n27:[13,52]\n28:[35,65]\n29:[14,59]\n31:[24]\n32:[81,88]\n33:[97]\n35:[5,28]\n37:[23]\n38:[15]\n39:[12]\n44:[6,25]\n46:[50]\n47:[0]\n50:[46]\n56:[7,68]\n59:[29]\n63:[77]\n68:[7,56]\n77:[63]\n86:[21]\nans=7\n```"
                    },
                    {
                        "username": "anurag-k",
                        "content": "Got the same error. Store the distance between two points in double, int will round off the value and give an error."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@smbody](/smbody) should be  test case"
                    },
                    {
                        "username": "smbody",
                        "content": "But i am getting it as 8, what is so special abt this test case?\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588509/c-dfs-bfs-solutions-with-detonating-bomb-process-beating-90-22/"
                    }
                ]
            },
            {
                "id": 1564767,
                "content": [
                    {
                        "username": "darkalarm",
                        "content": "When I read the question, my first thought was using union find for this question. But after a few test cases, I could understand that the question is actually about a directed graph. Union Find works for an undirected graph.\\n\\n![image](https://assets.leetcode.com/users/images/f7fb76c8-9ab7-4044-bd5f-569b21621f01_1639243400.360309.png)\\n\\nYou can see from the example above, the green circle can detonate the blue circle. But not the other way round. This means, there will be a directed edge from green circle to blue circule.\\n\\nThe question is asking us to find the maximum number of connected nodes in this graph. BFS sounds like the best approach."
                    },
                    {
                        "username": "reassurance",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) \\nMaybe I can help you in understanding why DFS might be faster than BFS although the logic of this question can be handled by both. \\nIn my DFS code, it is seen that if we trail down the path of the possible bombs that can be detonated by the current bomb, we can see that we have a chance to discover bombs that might trigger a **CHAIN** reaction. In other words, a queue in BFS will take longer time to finish and might include bombs that are isolated thereby reducing the impact. \\nAlthough I would not fully agree with my explanation above, this intuition sounded right to me.\\n\\nWould love to see someone prove this!"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "thats good, but how about dfs, I did BFS but my beats were ery low . Seen some solutions thst used DFS, they were more efficient. Don\\'t know the logic why, but it is what it is. try that too and tell me too if you understand why DFS is better than BFS in this case."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "great job, bro"
                    },
                    {
                        "username": "prateek4463",
                        "content": "thanks ! "
                    },
                    {
                        "username": "anfatum",
                        "content": "`bombs` =\\n[[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]\\n`Expected`\\n1\\n\\nAren\\'t [69,51,7] and [65,59,3] intersecting thus there is more than one explosion? "
                    },
                    {
                        "username": "blackhat130",
                        "content": "[@LakshayTheGupta](/LakshayTheGupta) Haha, Great Explanation. "
                    },
                    {
                        "username": "LakshayTheGupta",
                        "content": "[@piudpie](/piudpie) No that must be common sense that to activate  the bomb , it should be inside the range of the exploding bomb. The bomb is not itself a circle with radius R. \\nConclusion : we lack common sense and leetcode is trying to prove in every problem \\uD83E\\uDD23. (I had 2-3 wrong submissions before figuring this issue out \\uD83E\\uDD79)"
                    },
                    {
                        "username": "piudpie",
                        "content": "[@lohani](/lohani) They should have mentioned it in the problem statement, thank you for clarifying though!"
                    },
                    {
                        "username": "psionl0",
                        "content": "the distance between the 2 bombs is sqrt((65-69)^2 + (59-51)^2) = 8.9 which is greater than the range of either bomb."
                    },
                    {
                        "username": "pulkit_singhall",
                        "content": "[@lohani](/lohani) What is the condition for centre to be inside the radius?"
                    },
                    {
                        "username": "lohani",
                        "content": "I stumbled on this same issue. But there is a catch in the problem statement. The second bomb will only be detonated if it\\'s center comes inside the radius of the first bomb. Just intersection of circles is not enough."
                    },
                    {
                        "username": "hengjunlin1129",
                        "content": "I figured out that\\nbomb A can trigger bomb B\\nbomb C can trigger bomb B\\nbomb B cannot trigger bomb A and C\\nbomb A, C cannot trigger each other\\nbut in Union Find A B C will be in same group. (cause A->B, C->B"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "but if c can detonate b, then b must also be able to detonate c"
                    },
                    {
                        "username": "tejasX",
                        "content": "Thanks. I got my mistake."
                    },
                    {
                        "username": "drekker007",
                        "content": "Thank you so much bro!! You made me realize my mistakes!!"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "[@R4Ks](/R4Ks) suppose A has center (0,0) and radius 10, B has center (0,8) and radius 2 , C has center at (0,12) and radius 4, now A can only detonate B, C can also detonate B but B can\\'t detonate either of A and C, neither can A and C detonate each other.."
                    },
                    {
                        "username": "psionl0",
                        "content": "Nope. Detonating one of the bombs won\\'t result in all of the bombs being detonated."
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Give an example and show me such a scenario"
                    },
                    {
                        "username": "rs9",
                        "content": "This problem can be easily solved by DFS/BFS from each vertex in O(N^2). But can it be solved in O(N*logN) or O(N*sqrtN)?\\n\\nIs it possible to somehow lower number of vertex pairs to process by using some data structure like R-tree or over data structures used for knn-algorithms.\\nIs it possible by finding strongly connected components and edge contractions lower asymptotic computation complexity from O(N^2) to O(NlogN), O(NsqrtN) or maybe even O(N).\\n\\nUPD: I found answer to my question. It is no. It\\'s impossible to be  O(N^(2-eps)) for any eps>0.\\nhttps://www.sciencedirect.com/science/article/abs/pii/S0020019016300734?via%3Dihub\\n\\n![image](https://assets.leetcode.com/users/images/459461ca-2281-4e25-bba7-00299938c183_1639421565.9786224.jpeg)\\n"
                    },
                    {
                        "username": "yjian012",
                        "content": "[@cecilia5](/cecilia5) That's exactly my thought too, I totally agree with the finding the SCCs part. But what do you do after getting the DAG? Suppose we start with a DAG, and you know the roots. How do you find the number of vertices that can be reached from each root? You still need to go through most of the vertices/edges again, I think, so it would still be O( |V|*(|V|+|E|) )."
                    },
                    {
                        "username": "Arana",
                        "content": "No. The graph is not given, so this problem cannot be solved by any algorithm less than O(n^3)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "If the graph is given, however, I wonder what\\'s wrong with this algorithm.\\n\\n1.) Run Tarjan\\'s to get the SCCs\\n2.) Create a DAG G\\' of SCCs\\n3.) Compute a topological sorted order T of the reverse of G\\'.\\n4.) For each SCC n in T, compute the size of the connected components starting from arbitrary node of n as the size of n plus the size of all the SCC child of it in G\\'. By the topological sort above, the size should be already there.\\n\\nThis should be $$ O(|V| + |E|) $$ for all steps (note that G\\' can be seen as a contraction of G so is smaller than G)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I wondered the same but I was thinking geometrically. If the bombs are all reaching each other, the adjacency list alone would have $$ O(n^2) $$ entries, so that\\'s the end of it."
                    },
                    {
                        "username": "idklol8",
                        "content": "recommend you not solve on airport wifi while waiting for boarding"
                    },
                    {
                        "username": "anonymousjohndoe999",
                        "content": "haha"
                    },
                    {
                        "username": "Petersburg",
                        "content": "tried and failed"
                    },
                    {
                        "username": "dominhnhut01",
                        "content": "Thank you! I just spent the whole 1 hour just to figure out why my Union Find is not working"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "While calculating the distance between two centers remember to cast the squared value with long. Rest is pretty straightforward in this."
                    },
                    {
                        "username": "tbaby",
                        "content": "Watch out for exceeding max int."
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "[@mfulbright](/mfulbright) Agree, overflow is so annoying and that\\'s why many people switch to Python."
                    },
                    {
                        "username": "mfulbright",
                        "content": "Yeah that got me for a minute too. I hate bullshit like that, it just makes me waste time switching my ints to longs to see if that\\'s what the problem is."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Take a look at Constraints. `O(n^3)` will be fast enough"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Test case:\n```\n[[647,457,91],[483,716,37],[426,119,35],[355,588,40],[850,874,49],[232,568,46],[886,1,30],[54,377,3],[933,986,50],[305,790,49],[372,961,67],[671,314,58],[577,221,29],[380,147,91],[600,535,1],[806,329,64],[536,753,18],[906,88,23],[436,783,82],[652,674,45],[449,668,20],[419,13,66],[853,767,60],[169,288,33],[871,608,66],[337,445,35],[388,623,39],[723,503,81],[14,19,19],[98,648,72],[147,565,93],[655,434,1],[407,663,22],[805,947,83],[942,160,70],[959,496,93],[30,988,53],[187,849,60],[980,483,41],[663,150,76],[268,39,50],[513,522,75],[61,450,90],[115,231,12],[346,304,74],[385,540,23],[905,178,19],[336,896,81],[751,811,94],[527,783,78],[635,965,19],[334,290,39],[748,460,77],[414,134,22],[955,485,29],[925,787,43],[243,771,75],[675,223,29],[788,618,82],[462,544,30],[999,259,50],[210,146,12],[789,442,70],[286,36,55],[451,953,6],[719,914,14],[664,452,14],[933,637,29],[206,926,16],[100,422,98],[97,333,4],[505,631,26],[908,287,65],[907,316,86],[949,185,16],[639,735,62],[401,739,18],[605,926,21],[25,391,69],[80,24,9],[435,874,92],[940,381,18],[260,740,87],[727,515,17],[361,152,16],[512,470,67],[189,27,27],[517,439,94],[159,543,76],[373,698,38],[781,836,97],[584,190,23],[383,367,86],[825,141,63],[117,926,85],[169,588,60],[56,981,100],[294,716,100],[781,370,89],[373,44,78]]\n```\nSort the bombs! Create the adjacent list. Then apply DFS and got the result 7!\n```\nn=100\n56,981,100\n294,716,100\n100,422,98\n781,836,97\n751,811,94\n517,439,94\n147,565,93\n959,496,93\n435,874,92\n647,457,91\n380,147,91\n61,450,90\n781,370,89\n260,740,87\n383,367,86\n907,316,86\n117,926,85\n805,947,83\n436,783,82\n788,618,82\n336,896,81\n723,503,81\n527,783,78\n373,44,78\n748,460,77\n159,543,76\n663,150,76\n243,771,75\n513,522,75\n346,304,74\n98,648,72\n789,442,70\n942,160,70\n25,391,69\n372,961,67\n512,470,67\n871,608,66\n419,13,66\n908,287,65\n806,329,64\n825,141,63\n639,735,62\n187,849,60\n853,767,60\n169,588,60\n671,314,58\n286,36,55\n30,988,53\n933,986,50\n999,259,50\n268,39,50\n850,874,49\n305,790,49\n232,568,46\n652,674,45\n925,787,43\n980,483,41\n355,588,40\n388,623,39\n334,290,39\n373,698,38\n483,716,37\n337,445,35\n426,119,35\n169,288,33\n462,544,30\n886,1,30\n933,637,29\n955,485,29\n675,223,29\n577,221,29\n189,27,27\n505,631,26\n385,540,23\n584,190,23\n906,88,23\n407,663,22\n414,134,22\n605,926,21\n449,668,20\n635,965,19\n905,178,19\n14,19,19\n536,753,18\n401,739,18\n940,381,18\n727,515,17\n206,926,16\n949,185,16\n361,152,16\n719,914,14\n664,452,14\n115,231,12\n210,146,12\n80,24,9\n451,953,6\n97,333,4\n54,377,3\n600,535,1\n655,434,1\n=======\nadj lists:\n0:[16,47]\n1:[13,27,52,60]\n2:[11,33,96,97]\n3:[4,51]\n4:[3]\n5:[28,35]\n6:[25,44,53]\n7:[56,68]\n8:[18,95]\n9:[21,91,99]\n10:[63,77,89]\n11:[2,33,97]\n12:[31,39]\n13:[1,27,52]\n14:[29]\n15:[38,85]\n16:[0]\n18:[61,84]\n20:[34]\n21:[24,86,91]\n22:[83]\n23:[37]\n24:[21,31,86]\n25:[6,44]\n26:[69]\n27:[13,52]\n28:[35,65]\n29:[14,59]\n31:[24]\n32:[81,88]\n33:[97]\n35:[5,28]\n37:[23]\n38:[15]\n39:[12]\n44:[6,25]\n46:[50]\n47:[0]\n50:[46]\n56:[7,68]\n59:[29]\n63:[77]\n68:[7,56]\n77:[63]\n86:[21]\nans=7\n```"
                    },
                    {
                        "username": "anurag-k",
                        "content": "Got the same error. Store the distance between two points in double, int will round off the value and give an error."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@smbody](/smbody) should be  test case"
                    },
                    {
                        "username": "smbody",
                        "content": "But i am getting it as 8, what is so special abt this test case?\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588509/c-dfs-bfs-solutions-with-detonating-bomb-process-beating-90-22/"
                    }
                ]
            },
            {
                "id": 1714639,
                "content": [
                    {
                        "username": "darkalarm",
                        "content": "When I read the question, my first thought was using union find for this question. But after a few test cases, I could understand that the question is actually about a directed graph. Union Find works for an undirected graph.\\n\\n![image](https://assets.leetcode.com/users/images/f7fb76c8-9ab7-4044-bd5f-569b21621f01_1639243400.360309.png)\\n\\nYou can see from the example above, the green circle can detonate the blue circle. But not the other way round. This means, there will be a directed edge from green circle to blue circule.\\n\\nThe question is asking us to find the maximum number of connected nodes in this graph. BFS sounds like the best approach."
                    },
                    {
                        "username": "reassurance",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) \\nMaybe I can help you in understanding why DFS might be faster than BFS although the logic of this question can be handled by both. \\nIn my DFS code, it is seen that if we trail down the path of the possible bombs that can be detonated by the current bomb, we can see that we have a chance to discover bombs that might trigger a **CHAIN** reaction. In other words, a queue in BFS will take longer time to finish and might include bombs that are isolated thereby reducing the impact. \\nAlthough I would not fully agree with my explanation above, this intuition sounded right to me.\\n\\nWould love to see someone prove this!"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "thats good, but how about dfs, I did BFS but my beats were ery low . Seen some solutions thst used DFS, they were more efficient. Don\\'t know the logic why, but it is what it is. try that too and tell me too if you understand why DFS is better than BFS in this case."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "great job, bro"
                    },
                    {
                        "username": "prateek4463",
                        "content": "thanks ! "
                    },
                    {
                        "username": "anfatum",
                        "content": "`bombs` =\\n[[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]\\n`Expected`\\n1\\n\\nAren\\'t [69,51,7] and [65,59,3] intersecting thus there is more than one explosion? "
                    },
                    {
                        "username": "blackhat130",
                        "content": "[@LakshayTheGupta](/LakshayTheGupta) Haha, Great Explanation. "
                    },
                    {
                        "username": "LakshayTheGupta",
                        "content": "[@piudpie](/piudpie) No that must be common sense that to activate  the bomb , it should be inside the range of the exploding bomb. The bomb is not itself a circle with radius R. \\nConclusion : we lack common sense and leetcode is trying to prove in every problem \\uD83E\\uDD23. (I had 2-3 wrong submissions before figuring this issue out \\uD83E\\uDD79)"
                    },
                    {
                        "username": "piudpie",
                        "content": "[@lohani](/lohani) They should have mentioned it in the problem statement, thank you for clarifying though!"
                    },
                    {
                        "username": "psionl0",
                        "content": "the distance between the 2 bombs is sqrt((65-69)^2 + (59-51)^2) = 8.9 which is greater than the range of either bomb."
                    },
                    {
                        "username": "pulkit_singhall",
                        "content": "[@lohani](/lohani) What is the condition for centre to be inside the radius?"
                    },
                    {
                        "username": "lohani",
                        "content": "I stumbled on this same issue. But there is a catch in the problem statement. The second bomb will only be detonated if it\\'s center comes inside the radius of the first bomb. Just intersection of circles is not enough."
                    },
                    {
                        "username": "hengjunlin1129",
                        "content": "I figured out that\\nbomb A can trigger bomb B\\nbomb C can trigger bomb B\\nbomb B cannot trigger bomb A and C\\nbomb A, C cannot trigger each other\\nbut in Union Find A B C will be in same group. (cause A->B, C->B"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "but if c can detonate b, then b must also be able to detonate c"
                    },
                    {
                        "username": "tejasX",
                        "content": "Thanks. I got my mistake."
                    },
                    {
                        "username": "drekker007",
                        "content": "Thank you so much bro!! You made me realize my mistakes!!"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "[@R4Ks](/R4Ks) suppose A has center (0,0) and radius 10, B has center (0,8) and radius 2 , C has center at (0,12) and radius 4, now A can only detonate B, C can also detonate B but B can\\'t detonate either of A and C, neither can A and C detonate each other.."
                    },
                    {
                        "username": "psionl0",
                        "content": "Nope. Detonating one of the bombs won\\'t result in all of the bombs being detonated."
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Give an example and show me such a scenario"
                    },
                    {
                        "username": "rs9",
                        "content": "This problem can be easily solved by DFS/BFS from each vertex in O(N^2). But can it be solved in O(N*logN) or O(N*sqrtN)?\\n\\nIs it possible to somehow lower number of vertex pairs to process by using some data structure like R-tree or over data structures used for knn-algorithms.\\nIs it possible by finding strongly connected components and edge contractions lower asymptotic computation complexity from O(N^2) to O(NlogN), O(NsqrtN) or maybe even O(N).\\n\\nUPD: I found answer to my question. It is no. It\\'s impossible to be  O(N^(2-eps)) for any eps>0.\\nhttps://www.sciencedirect.com/science/article/abs/pii/S0020019016300734?via%3Dihub\\n\\n![image](https://assets.leetcode.com/users/images/459461ca-2281-4e25-bba7-00299938c183_1639421565.9786224.jpeg)\\n"
                    },
                    {
                        "username": "yjian012",
                        "content": "[@cecilia5](/cecilia5) That's exactly my thought too, I totally agree with the finding the SCCs part. But what do you do after getting the DAG? Suppose we start with a DAG, and you know the roots. How do you find the number of vertices that can be reached from each root? You still need to go through most of the vertices/edges again, I think, so it would still be O( |V|*(|V|+|E|) )."
                    },
                    {
                        "username": "Arana",
                        "content": "No. The graph is not given, so this problem cannot be solved by any algorithm less than O(n^3)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "If the graph is given, however, I wonder what\\'s wrong with this algorithm.\\n\\n1.) Run Tarjan\\'s to get the SCCs\\n2.) Create a DAG G\\' of SCCs\\n3.) Compute a topological sorted order T of the reverse of G\\'.\\n4.) For each SCC n in T, compute the size of the connected components starting from arbitrary node of n as the size of n plus the size of all the SCC child of it in G\\'. By the topological sort above, the size should be already there.\\n\\nThis should be $$ O(|V| + |E|) $$ for all steps (note that G\\' can be seen as a contraction of G so is smaller than G)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I wondered the same but I was thinking geometrically. If the bombs are all reaching each other, the adjacency list alone would have $$ O(n^2) $$ entries, so that\\'s the end of it."
                    },
                    {
                        "username": "idklol8",
                        "content": "recommend you not solve on airport wifi while waiting for boarding"
                    },
                    {
                        "username": "anonymousjohndoe999",
                        "content": "haha"
                    },
                    {
                        "username": "Petersburg",
                        "content": "tried and failed"
                    },
                    {
                        "username": "dominhnhut01",
                        "content": "Thank you! I just spent the whole 1 hour just to figure out why my Union Find is not working"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "While calculating the distance between two centers remember to cast the squared value with long. Rest is pretty straightforward in this."
                    },
                    {
                        "username": "tbaby",
                        "content": "Watch out for exceeding max int."
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "[@mfulbright](/mfulbright) Agree, overflow is so annoying and that\\'s why many people switch to Python."
                    },
                    {
                        "username": "mfulbright",
                        "content": "Yeah that got me for a minute too. I hate bullshit like that, it just makes me waste time switching my ints to longs to see if that\\'s what the problem is."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Take a look at Constraints. `O(n^3)` will be fast enough"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Test case:\n```\n[[647,457,91],[483,716,37],[426,119,35],[355,588,40],[850,874,49],[232,568,46],[886,1,30],[54,377,3],[933,986,50],[305,790,49],[372,961,67],[671,314,58],[577,221,29],[380,147,91],[600,535,1],[806,329,64],[536,753,18],[906,88,23],[436,783,82],[652,674,45],[449,668,20],[419,13,66],[853,767,60],[169,288,33],[871,608,66],[337,445,35],[388,623,39],[723,503,81],[14,19,19],[98,648,72],[147,565,93],[655,434,1],[407,663,22],[805,947,83],[942,160,70],[959,496,93],[30,988,53],[187,849,60],[980,483,41],[663,150,76],[268,39,50],[513,522,75],[61,450,90],[115,231,12],[346,304,74],[385,540,23],[905,178,19],[336,896,81],[751,811,94],[527,783,78],[635,965,19],[334,290,39],[748,460,77],[414,134,22],[955,485,29],[925,787,43],[243,771,75],[675,223,29],[788,618,82],[462,544,30],[999,259,50],[210,146,12],[789,442,70],[286,36,55],[451,953,6],[719,914,14],[664,452,14],[933,637,29],[206,926,16],[100,422,98],[97,333,4],[505,631,26],[908,287,65],[907,316,86],[949,185,16],[639,735,62],[401,739,18],[605,926,21],[25,391,69],[80,24,9],[435,874,92],[940,381,18],[260,740,87],[727,515,17],[361,152,16],[512,470,67],[189,27,27],[517,439,94],[159,543,76],[373,698,38],[781,836,97],[584,190,23],[383,367,86],[825,141,63],[117,926,85],[169,588,60],[56,981,100],[294,716,100],[781,370,89],[373,44,78]]\n```\nSort the bombs! Create the adjacent list. Then apply DFS and got the result 7!\n```\nn=100\n56,981,100\n294,716,100\n100,422,98\n781,836,97\n751,811,94\n517,439,94\n147,565,93\n959,496,93\n435,874,92\n647,457,91\n380,147,91\n61,450,90\n781,370,89\n260,740,87\n383,367,86\n907,316,86\n117,926,85\n805,947,83\n436,783,82\n788,618,82\n336,896,81\n723,503,81\n527,783,78\n373,44,78\n748,460,77\n159,543,76\n663,150,76\n243,771,75\n513,522,75\n346,304,74\n98,648,72\n789,442,70\n942,160,70\n25,391,69\n372,961,67\n512,470,67\n871,608,66\n419,13,66\n908,287,65\n806,329,64\n825,141,63\n639,735,62\n187,849,60\n853,767,60\n169,588,60\n671,314,58\n286,36,55\n30,988,53\n933,986,50\n999,259,50\n268,39,50\n850,874,49\n305,790,49\n232,568,46\n652,674,45\n925,787,43\n980,483,41\n355,588,40\n388,623,39\n334,290,39\n373,698,38\n483,716,37\n337,445,35\n426,119,35\n169,288,33\n462,544,30\n886,1,30\n933,637,29\n955,485,29\n675,223,29\n577,221,29\n189,27,27\n505,631,26\n385,540,23\n584,190,23\n906,88,23\n407,663,22\n414,134,22\n605,926,21\n449,668,20\n635,965,19\n905,178,19\n14,19,19\n536,753,18\n401,739,18\n940,381,18\n727,515,17\n206,926,16\n949,185,16\n361,152,16\n719,914,14\n664,452,14\n115,231,12\n210,146,12\n80,24,9\n451,953,6\n97,333,4\n54,377,3\n600,535,1\n655,434,1\n=======\nadj lists:\n0:[16,47]\n1:[13,27,52,60]\n2:[11,33,96,97]\n3:[4,51]\n4:[3]\n5:[28,35]\n6:[25,44,53]\n7:[56,68]\n8:[18,95]\n9:[21,91,99]\n10:[63,77,89]\n11:[2,33,97]\n12:[31,39]\n13:[1,27,52]\n14:[29]\n15:[38,85]\n16:[0]\n18:[61,84]\n20:[34]\n21:[24,86,91]\n22:[83]\n23:[37]\n24:[21,31,86]\n25:[6,44]\n26:[69]\n27:[13,52]\n28:[35,65]\n29:[14,59]\n31:[24]\n32:[81,88]\n33:[97]\n35:[5,28]\n37:[23]\n38:[15]\n39:[12]\n44:[6,25]\n46:[50]\n47:[0]\n50:[46]\n56:[7,68]\n59:[29]\n63:[77]\n68:[7,56]\n77:[63]\n86:[21]\nans=7\n```"
                    },
                    {
                        "username": "anurag-k",
                        "content": "Got the same error. Store the distance between two points in double, int will round off the value and give an error."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@smbody](/smbody) should be  test case"
                    },
                    {
                        "username": "smbody",
                        "content": "But i am getting it as 8, what is so special abt this test case?\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588509/c-dfs-bfs-solutions-with-detonating-bomb-process-beating-90-22/"
                    }
                ]
            },
            {
                "id": 1567701,
                "content": [
                    {
                        "username": "darkalarm",
                        "content": "When I read the question, my first thought was using union find for this question. But after a few test cases, I could understand that the question is actually about a directed graph. Union Find works for an undirected graph.\\n\\n![image](https://assets.leetcode.com/users/images/f7fb76c8-9ab7-4044-bd5f-569b21621f01_1639243400.360309.png)\\n\\nYou can see from the example above, the green circle can detonate the blue circle. But not the other way round. This means, there will be a directed edge from green circle to blue circule.\\n\\nThe question is asking us to find the maximum number of connected nodes in this graph. BFS sounds like the best approach."
                    },
                    {
                        "username": "reassurance",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) \\nMaybe I can help you in understanding why DFS might be faster than BFS although the logic of this question can be handled by both. \\nIn my DFS code, it is seen that if we trail down the path of the possible bombs that can be detonated by the current bomb, we can see that we have a chance to discover bombs that might trigger a **CHAIN** reaction. In other words, a queue in BFS will take longer time to finish and might include bombs that are isolated thereby reducing the impact. \\nAlthough I would not fully agree with my explanation above, this intuition sounded right to me.\\n\\nWould love to see someone prove this!"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "thats good, but how about dfs, I did BFS but my beats were ery low . Seen some solutions thst used DFS, they were more efficient. Don\\'t know the logic why, but it is what it is. try that too and tell me too if you understand why DFS is better than BFS in this case."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "great job, bro"
                    },
                    {
                        "username": "prateek4463",
                        "content": "thanks ! "
                    },
                    {
                        "username": "anfatum",
                        "content": "`bombs` =\\n[[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]\\n`Expected`\\n1\\n\\nAren\\'t [69,51,7] and [65,59,3] intersecting thus there is more than one explosion? "
                    },
                    {
                        "username": "blackhat130",
                        "content": "[@LakshayTheGupta](/LakshayTheGupta) Haha, Great Explanation. "
                    },
                    {
                        "username": "LakshayTheGupta",
                        "content": "[@piudpie](/piudpie) No that must be common sense that to activate  the bomb , it should be inside the range of the exploding bomb. The bomb is not itself a circle with radius R. \\nConclusion : we lack common sense and leetcode is trying to prove in every problem \\uD83E\\uDD23. (I had 2-3 wrong submissions before figuring this issue out \\uD83E\\uDD79)"
                    },
                    {
                        "username": "piudpie",
                        "content": "[@lohani](/lohani) They should have mentioned it in the problem statement, thank you for clarifying though!"
                    },
                    {
                        "username": "psionl0",
                        "content": "the distance between the 2 bombs is sqrt((65-69)^2 + (59-51)^2) = 8.9 which is greater than the range of either bomb."
                    },
                    {
                        "username": "pulkit_singhall",
                        "content": "[@lohani](/lohani) What is the condition for centre to be inside the radius?"
                    },
                    {
                        "username": "lohani",
                        "content": "I stumbled on this same issue. But there is a catch in the problem statement. The second bomb will only be detonated if it\\'s center comes inside the radius of the first bomb. Just intersection of circles is not enough."
                    },
                    {
                        "username": "hengjunlin1129",
                        "content": "I figured out that\\nbomb A can trigger bomb B\\nbomb C can trigger bomb B\\nbomb B cannot trigger bomb A and C\\nbomb A, C cannot trigger each other\\nbut in Union Find A B C will be in same group. (cause A->B, C->B"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "but if c can detonate b, then b must also be able to detonate c"
                    },
                    {
                        "username": "tejasX",
                        "content": "Thanks. I got my mistake."
                    },
                    {
                        "username": "drekker007",
                        "content": "Thank you so much bro!! You made me realize my mistakes!!"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "[@R4Ks](/R4Ks) suppose A has center (0,0) and radius 10, B has center (0,8) and radius 2 , C has center at (0,12) and radius 4, now A can only detonate B, C can also detonate B but B can\\'t detonate either of A and C, neither can A and C detonate each other.."
                    },
                    {
                        "username": "psionl0",
                        "content": "Nope. Detonating one of the bombs won\\'t result in all of the bombs being detonated."
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Give an example and show me such a scenario"
                    },
                    {
                        "username": "rs9",
                        "content": "This problem can be easily solved by DFS/BFS from each vertex in O(N^2). But can it be solved in O(N*logN) or O(N*sqrtN)?\\n\\nIs it possible to somehow lower number of vertex pairs to process by using some data structure like R-tree or over data structures used for knn-algorithms.\\nIs it possible by finding strongly connected components and edge contractions lower asymptotic computation complexity from O(N^2) to O(NlogN), O(NsqrtN) or maybe even O(N).\\n\\nUPD: I found answer to my question. It is no. It\\'s impossible to be  O(N^(2-eps)) for any eps>0.\\nhttps://www.sciencedirect.com/science/article/abs/pii/S0020019016300734?via%3Dihub\\n\\n![image](https://assets.leetcode.com/users/images/459461ca-2281-4e25-bba7-00299938c183_1639421565.9786224.jpeg)\\n"
                    },
                    {
                        "username": "yjian012",
                        "content": "[@cecilia5](/cecilia5) That's exactly my thought too, I totally agree with the finding the SCCs part. But what do you do after getting the DAG? Suppose we start with a DAG, and you know the roots. How do you find the number of vertices that can be reached from each root? You still need to go through most of the vertices/edges again, I think, so it would still be O( |V|*(|V|+|E|) )."
                    },
                    {
                        "username": "Arana",
                        "content": "No. The graph is not given, so this problem cannot be solved by any algorithm less than O(n^3)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "If the graph is given, however, I wonder what\\'s wrong with this algorithm.\\n\\n1.) Run Tarjan\\'s to get the SCCs\\n2.) Create a DAG G\\' of SCCs\\n3.) Compute a topological sorted order T of the reverse of G\\'.\\n4.) For each SCC n in T, compute the size of the connected components starting from arbitrary node of n as the size of n plus the size of all the SCC child of it in G\\'. By the topological sort above, the size should be already there.\\n\\nThis should be $$ O(|V| + |E|) $$ for all steps (note that G\\' can be seen as a contraction of G so is smaller than G)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I wondered the same but I was thinking geometrically. If the bombs are all reaching each other, the adjacency list alone would have $$ O(n^2) $$ entries, so that\\'s the end of it."
                    },
                    {
                        "username": "idklol8",
                        "content": "recommend you not solve on airport wifi while waiting for boarding"
                    },
                    {
                        "username": "anonymousjohndoe999",
                        "content": "haha"
                    },
                    {
                        "username": "Petersburg",
                        "content": "tried and failed"
                    },
                    {
                        "username": "dominhnhut01",
                        "content": "Thank you! I just spent the whole 1 hour just to figure out why my Union Find is not working"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "While calculating the distance between two centers remember to cast the squared value with long. Rest is pretty straightforward in this."
                    },
                    {
                        "username": "tbaby",
                        "content": "Watch out for exceeding max int."
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "[@mfulbright](/mfulbright) Agree, overflow is so annoying and that\\'s why many people switch to Python."
                    },
                    {
                        "username": "mfulbright",
                        "content": "Yeah that got me for a minute too. I hate bullshit like that, it just makes me waste time switching my ints to longs to see if that\\'s what the problem is."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Take a look at Constraints. `O(n^3)` will be fast enough"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Test case:\n```\n[[647,457,91],[483,716,37],[426,119,35],[355,588,40],[850,874,49],[232,568,46],[886,1,30],[54,377,3],[933,986,50],[305,790,49],[372,961,67],[671,314,58],[577,221,29],[380,147,91],[600,535,1],[806,329,64],[536,753,18],[906,88,23],[436,783,82],[652,674,45],[449,668,20],[419,13,66],[853,767,60],[169,288,33],[871,608,66],[337,445,35],[388,623,39],[723,503,81],[14,19,19],[98,648,72],[147,565,93],[655,434,1],[407,663,22],[805,947,83],[942,160,70],[959,496,93],[30,988,53],[187,849,60],[980,483,41],[663,150,76],[268,39,50],[513,522,75],[61,450,90],[115,231,12],[346,304,74],[385,540,23],[905,178,19],[336,896,81],[751,811,94],[527,783,78],[635,965,19],[334,290,39],[748,460,77],[414,134,22],[955,485,29],[925,787,43],[243,771,75],[675,223,29],[788,618,82],[462,544,30],[999,259,50],[210,146,12],[789,442,70],[286,36,55],[451,953,6],[719,914,14],[664,452,14],[933,637,29],[206,926,16],[100,422,98],[97,333,4],[505,631,26],[908,287,65],[907,316,86],[949,185,16],[639,735,62],[401,739,18],[605,926,21],[25,391,69],[80,24,9],[435,874,92],[940,381,18],[260,740,87],[727,515,17],[361,152,16],[512,470,67],[189,27,27],[517,439,94],[159,543,76],[373,698,38],[781,836,97],[584,190,23],[383,367,86],[825,141,63],[117,926,85],[169,588,60],[56,981,100],[294,716,100],[781,370,89],[373,44,78]]\n```\nSort the bombs! Create the adjacent list. Then apply DFS and got the result 7!\n```\nn=100\n56,981,100\n294,716,100\n100,422,98\n781,836,97\n751,811,94\n517,439,94\n147,565,93\n959,496,93\n435,874,92\n647,457,91\n380,147,91\n61,450,90\n781,370,89\n260,740,87\n383,367,86\n907,316,86\n117,926,85\n805,947,83\n436,783,82\n788,618,82\n336,896,81\n723,503,81\n527,783,78\n373,44,78\n748,460,77\n159,543,76\n663,150,76\n243,771,75\n513,522,75\n346,304,74\n98,648,72\n789,442,70\n942,160,70\n25,391,69\n372,961,67\n512,470,67\n871,608,66\n419,13,66\n908,287,65\n806,329,64\n825,141,63\n639,735,62\n187,849,60\n853,767,60\n169,588,60\n671,314,58\n286,36,55\n30,988,53\n933,986,50\n999,259,50\n268,39,50\n850,874,49\n305,790,49\n232,568,46\n652,674,45\n925,787,43\n980,483,41\n355,588,40\n388,623,39\n334,290,39\n373,698,38\n483,716,37\n337,445,35\n426,119,35\n169,288,33\n462,544,30\n886,1,30\n933,637,29\n955,485,29\n675,223,29\n577,221,29\n189,27,27\n505,631,26\n385,540,23\n584,190,23\n906,88,23\n407,663,22\n414,134,22\n605,926,21\n449,668,20\n635,965,19\n905,178,19\n14,19,19\n536,753,18\n401,739,18\n940,381,18\n727,515,17\n206,926,16\n949,185,16\n361,152,16\n719,914,14\n664,452,14\n115,231,12\n210,146,12\n80,24,9\n451,953,6\n97,333,4\n54,377,3\n600,535,1\n655,434,1\n=======\nadj lists:\n0:[16,47]\n1:[13,27,52,60]\n2:[11,33,96,97]\n3:[4,51]\n4:[3]\n5:[28,35]\n6:[25,44,53]\n7:[56,68]\n8:[18,95]\n9:[21,91,99]\n10:[63,77,89]\n11:[2,33,97]\n12:[31,39]\n13:[1,27,52]\n14:[29]\n15:[38,85]\n16:[0]\n18:[61,84]\n20:[34]\n21:[24,86,91]\n22:[83]\n23:[37]\n24:[21,31,86]\n25:[6,44]\n26:[69]\n27:[13,52]\n28:[35,65]\n29:[14,59]\n31:[24]\n32:[81,88]\n33:[97]\n35:[5,28]\n37:[23]\n38:[15]\n39:[12]\n44:[6,25]\n46:[50]\n47:[0]\n50:[46]\n56:[7,68]\n59:[29]\n63:[77]\n68:[7,56]\n77:[63]\n86:[21]\nans=7\n```"
                    },
                    {
                        "username": "anurag-k",
                        "content": "Got the same error. Store the distance between two points in double, int will round off the value and give an error."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@smbody](/smbody) should be  test case"
                    },
                    {
                        "username": "smbody",
                        "content": "But i am getting it as 8, what is so special abt this test case?\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588509/c-dfs-bfs-solutions-with-detonating-bomb-process-beating-90-22/"
                    }
                ]
            },
            {
                "id": 1566203,
                "content": [
                    {
                        "username": "darkalarm",
                        "content": "When I read the question, my first thought was using union find for this question. But after a few test cases, I could understand that the question is actually about a directed graph. Union Find works for an undirected graph.\\n\\n![image](https://assets.leetcode.com/users/images/f7fb76c8-9ab7-4044-bd5f-569b21621f01_1639243400.360309.png)\\n\\nYou can see from the example above, the green circle can detonate the blue circle. But not the other way round. This means, there will be a directed edge from green circle to blue circule.\\n\\nThe question is asking us to find the maximum number of connected nodes in this graph. BFS sounds like the best approach."
                    },
                    {
                        "username": "reassurance",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) \\nMaybe I can help you in understanding why DFS might be faster than BFS although the logic of this question can be handled by both. \\nIn my DFS code, it is seen that if we trail down the path of the possible bombs that can be detonated by the current bomb, we can see that we have a chance to discover bombs that might trigger a **CHAIN** reaction. In other words, a queue in BFS will take longer time to finish and might include bombs that are isolated thereby reducing the impact. \\nAlthough I would not fully agree with my explanation above, this intuition sounded right to me.\\n\\nWould love to see someone prove this!"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "thats good, but how about dfs, I did BFS but my beats were ery low . Seen some solutions thst used DFS, they were more efficient. Don\\'t know the logic why, but it is what it is. try that too and tell me too if you understand why DFS is better than BFS in this case."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "great job, bro"
                    },
                    {
                        "username": "prateek4463",
                        "content": "thanks ! "
                    },
                    {
                        "username": "anfatum",
                        "content": "`bombs` =\\n[[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]\\n`Expected`\\n1\\n\\nAren\\'t [69,51,7] and [65,59,3] intersecting thus there is more than one explosion? "
                    },
                    {
                        "username": "blackhat130",
                        "content": "[@LakshayTheGupta](/LakshayTheGupta) Haha, Great Explanation. "
                    },
                    {
                        "username": "LakshayTheGupta",
                        "content": "[@piudpie](/piudpie) No that must be common sense that to activate  the bomb , it should be inside the range of the exploding bomb. The bomb is not itself a circle with radius R. \\nConclusion : we lack common sense and leetcode is trying to prove in every problem \\uD83E\\uDD23. (I had 2-3 wrong submissions before figuring this issue out \\uD83E\\uDD79)"
                    },
                    {
                        "username": "piudpie",
                        "content": "[@lohani](/lohani) They should have mentioned it in the problem statement, thank you for clarifying though!"
                    },
                    {
                        "username": "psionl0",
                        "content": "the distance between the 2 bombs is sqrt((65-69)^2 + (59-51)^2) = 8.9 which is greater than the range of either bomb."
                    },
                    {
                        "username": "pulkit_singhall",
                        "content": "[@lohani](/lohani) What is the condition for centre to be inside the radius?"
                    },
                    {
                        "username": "lohani",
                        "content": "I stumbled on this same issue. But there is a catch in the problem statement. The second bomb will only be detonated if it\\'s center comes inside the radius of the first bomb. Just intersection of circles is not enough."
                    },
                    {
                        "username": "hengjunlin1129",
                        "content": "I figured out that\\nbomb A can trigger bomb B\\nbomb C can trigger bomb B\\nbomb B cannot trigger bomb A and C\\nbomb A, C cannot trigger each other\\nbut in Union Find A B C will be in same group. (cause A->B, C->B"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "but if c can detonate b, then b must also be able to detonate c"
                    },
                    {
                        "username": "tejasX",
                        "content": "Thanks. I got my mistake."
                    },
                    {
                        "username": "drekker007",
                        "content": "Thank you so much bro!! You made me realize my mistakes!!"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "[@R4Ks](/R4Ks) suppose A has center (0,0) and radius 10, B has center (0,8) and radius 2 , C has center at (0,12) and radius 4, now A can only detonate B, C can also detonate B but B can\\'t detonate either of A and C, neither can A and C detonate each other.."
                    },
                    {
                        "username": "psionl0",
                        "content": "Nope. Detonating one of the bombs won\\'t result in all of the bombs being detonated."
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Give an example and show me such a scenario"
                    },
                    {
                        "username": "rs9",
                        "content": "This problem can be easily solved by DFS/BFS from each vertex in O(N^2). But can it be solved in O(N*logN) or O(N*sqrtN)?\\n\\nIs it possible to somehow lower number of vertex pairs to process by using some data structure like R-tree or over data structures used for knn-algorithms.\\nIs it possible by finding strongly connected components and edge contractions lower asymptotic computation complexity from O(N^2) to O(NlogN), O(NsqrtN) or maybe even O(N).\\n\\nUPD: I found answer to my question. It is no. It\\'s impossible to be  O(N^(2-eps)) for any eps>0.\\nhttps://www.sciencedirect.com/science/article/abs/pii/S0020019016300734?via%3Dihub\\n\\n![image](https://assets.leetcode.com/users/images/459461ca-2281-4e25-bba7-00299938c183_1639421565.9786224.jpeg)\\n"
                    },
                    {
                        "username": "yjian012",
                        "content": "[@cecilia5](/cecilia5) That's exactly my thought too, I totally agree with the finding the SCCs part. But what do you do after getting the DAG? Suppose we start with a DAG, and you know the roots. How do you find the number of vertices that can be reached from each root? You still need to go through most of the vertices/edges again, I think, so it would still be O( |V|*(|V|+|E|) )."
                    },
                    {
                        "username": "Arana",
                        "content": "No. The graph is not given, so this problem cannot be solved by any algorithm less than O(n^3)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "If the graph is given, however, I wonder what\\'s wrong with this algorithm.\\n\\n1.) Run Tarjan\\'s to get the SCCs\\n2.) Create a DAG G\\' of SCCs\\n3.) Compute a topological sorted order T of the reverse of G\\'.\\n4.) For each SCC n in T, compute the size of the connected components starting from arbitrary node of n as the size of n plus the size of all the SCC child of it in G\\'. By the topological sort above, the size should be already there.\\n\\nThis should be $$ O(|V| + |E|) $$ for all steps (note that G\\' can be seen as a contraction of G so is smaller than G)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I wondered the same but I was thinking geometrically. If the bombs are all reaching each other, the adjacency list alone would have $$ O(n^2) $$ entries, so that\\'s the end of it."
                    },
                    {
                        "username": "idklol8",
                        "content": "recommend you not solve on airport wifi while waiting for boarding"
                    },
                    {
                        "username": "anonymousjohndoe999",
                        "content": "haha"
                    },
                    {
                        "username": "Petersburg",
                        "content": "tried and failed"
                    },
                    {
                        "username": "dominhnhut01",
                        "content": "Thank you! I just spent the whole 1 hour just to figure out why my Union Find is not working"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "While calculating the distance between two centers remember to cast the squared value with long. Rest is pretty straightforward in this."
                    },
                    {
                        "username": "tbaby",
                        "content": "Watch out for exceeding max int."
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "[@mfulbright](/mfulbright) Agree, overflow is so annoying and that\\'s why many people switch to Python."
                    },
                    {
                        "username": "mfulbright",
                        "content": "Yeah that got me for a minute too. I hate bullshit like that, it just makes me waste time switching my ints to longs to see if that\\'s what the problem is."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Take a look at Constraints. `O(n^3)` will be fast enough"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Test case:\n```\n[[647,457,91],[483,716,37],[426,119,35],[355,588,40],[850,874,49],[232,568,46],[886,1,30],[54,377,3],[933,986,50],[305,790,49],[372,961,67],[671,314,58],[577,221,29],[380,147,91],[600,535,1],[806,329,64],[536,753,18],[906,88,23],[436,783,82],[652,674,45],[449,668,20],[419,13,66],[853,767,60],[169,288,33],[871,608,66],[337,445,35],[388,623,39],[723,503,81],[14,19,19],[98,648,72],[147,565,93],[655,434,1],[407,663,22],[805,947,83],[942,160,70],[959,496,93],[30,988,53],[187,849,60],[980,483,41],[663,150,76],[268,39,50],[513,522,75],[61,450,90],[115,231,12],[346,304,74],[385,540,23],[905,178,19],[336,896,81],[751,811,94],[527,783,78],[635,965,19],[334,290,39],[748,460,77],[414,134,22],[955,485,29],[925,787,43],[243,771,75],[675,223,29],[788,618,82],[462,544,30],[999,259,50],[210,146,12],[789,442,70],[286,36,55],[451,953,6],[719,914,14],[664,452,14],[933,637,29],[206,926,16],[100,422,98],[97,333,4],[505,631,26],[908,287,65],[907,316,86],[949,185,16],[639,735,62],[401,739,18],[605,926,21],[25,391,69],[80,24,9],[435,874,92],[940,381,18],[260,740,87],[727,515,17],[361,152,16],[512,470,67],[189,27,27],[517,439,94],[159,543,76],[373,698,38],[781,836,97],[584,190,23],[383,367,86],[825,141,63],[117,926,85],[169,588,60],[56,981,100],[294,716,100],[781,370,89],[373,44,78]]\n```\nSort the bombs! Create the adjacent list. Then apply DFS and got the result 7!\n```\nn=100\n56,981,100\n294,716,100\n100,422,98\n781,836,97\n751,811,94\n517,439,94\n147,565,93\n959,496,93\n435,874,92\n647,457,91\n380,147,91\n61,450,90\n781,370,89\n260,740,87\n383,367,86\n907,316,86\n117,926,85\n805,947,83\n436,783,82\n788,618,82\n336,896,81\n723,503,81\n527,783,78\n373,44,78\n748,460,77\n159,543,76\n663,150,76\n243,771,75\n513,522,75\n346,304,74\n98,648,72\n789,442,70\n942,160,70\n25,391,69\n372,961,67\n512,470,67\n871,608,66\n419,13,66\n908,287,65\n806,329,64\n825,141,63\n639,735,62\n187,849,60\n853,767,60\n169,588,60\n671,314,58\n286,36,55\n30,988,53\n933,986,50\n999,259,50\n268,39,50\n850,874,49\n305,790,49\n232,568,46\n652,674,45\n925,787,43\n980,483,41\n355,588,40\n388,623,39\n334,290,39\n373,698,38\n483,716,37\n337,445,35\n426,119,35\n169,288,33\n462,544,30\n886,1,30\n933,637,29\n955,485,29\n675,223,29\n577,221,29\n189,27,27\n505,631,26\n385,540,23\n584,190,23\n906,88,23\n407,663,22\n414,134,22\n605,926,21\n449,668,20\n635,965,19\n905,178,19\n14,19,19\n536,753,18\n401,739,18\n940,381,18\n727,515,17\n206,926,16\n949,185,16\n361,152,16\n719,914,14\n664,452,14\n115,231,12\n210,146,12\n80,24,9\n451,953,6\n97,333,4\n54,377,3\n600,535,1\n655,434,1\n=======\nadj lists:\n0:[16,47]\n1:[13,27,52,60]\n2:[11,33,96,97]\n3:[4,51]\n4:[3]\n5:[28,35]\n6:[25,44,53]\n7:[56,68]\n8:[18,95]\n9:[21,91,99]\n10:[63,77,89]\n11:[2,33,97]\n12:[31,39]\n13:[1,27,52]\n14:[29]\n15:[38,85]\n16:[0]\n18:[61,84]\n20:[34]\n21:[24,86,91]\n22:[83]\n23:[37]\n24:[21,31,86]\n25:[6,44]\n26:[69]\n27:[13,52]\n28:[35,65]\n29:[14,59]\n31:[24]\n32:[81,88]\n33:[97]\n35:[5,28]\n37:[23]\n38:[15]\n39:[12]\n44:[6,25]\n46:[50]\n47:[0]\n50:[46]\n56:[7,68]\n59:[29]\n63:[77]\n68:[7,56]\n77:[63]\n86:[21]\nans=7\n```"
                    },
                    {
                        "username": "anurag-k",
                        "content": "Got the same error. Store the distance between two points in double, int will round off the value and give an error."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@smbody](/smbody) should be  test case"
                    },
                    {
                        "username": "smbody",
                        "content": "But i am getting it as 8, what is so special abt this test case?\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588509/c-dfs-bfs-solutions-with-detonating-bomb-process-beating-90-22/"
                    }
                ]
            },
            {
                "id": 1914251,
                "content": [
                    {
                        "username": "darkalarm",
                        "content": "When I read the question, my first thought was using union find for this question. But after a few test cases, I could understand that the question is actually about a directed graph. Union Find works for an undirected graph.\\n\\n![image](https://assets.leetcode.com/users/images/f7fb76c8-9ab7-4044-bd5f-569b21621f01_1639243400.360309.png)\\n\\nYou can see from the example above, the green circle can detonate the blue circle. But not the other way round. This means, there will be a directed edge from green circle to blue circule.\\n\\nThe question is asking us to find the maximum number of connected nodes in this graph. BFS sounds like the best approach."
                    },
                    {
                        "username": "reassurance",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) \\nMaybe I can help you in understanding why DFS might be faster than BFS although the logic of this question can be handled by both. \\nIn my DFS code, it is seen that if we trail down the path of the possible bombs that can be detonated by the current bomb, we can see that we have a chance to discover bombs that might trigger a **CHAIN** reaction. In other words, a queue in BFS will take longer time to finish and might include bombs that are isolated thereby reducing the impact. \\nAlthough I would not fully agree with my explanation above, this intuition sounded right to me.\\n\\nWould love to see someone prove this!"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "thats good, but how about dfs, I did BFS but my beats were ery low . Seen some solutions thst used DFS, they were more efficient. Don\\'t know the logic why, but it is what it is. try that too and tell me too if you understand why DFS is better than BFS in this case."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "great job, bro"
                    },
                    {
                        "username": "prateek4463",
                        "content": "thanks ! "
                    },
                    {
                        "username": "anfatum",
                        "content": "`bombs` =\\n[[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]\\n`Expected`\\n1\\n\\nAren\\'t [69,51,7] and [65,59,3] intersecting thus there is more than one explosion? "
                    },
                    {
                        "username": "blackhat130",
                        "content": "[@LakshayTheGupta](/LakshayTheGupta) Haha, Great Explanation. "
                    },
                    {
                        "username": "LakshayTheGupta",
                        "content": "[@piudpie](/piudpie) No that must be common sense that to activate  the bomb , it should be inside the range of the exploding bomb. The bomb is not itself a circle with radius R. \\nConclusion : we lack common sense and leetcode is trying to prove in every problem \\uD83E\\uDD23. (I had 2-3 wrong submissions before figuring this issue out \\uD83E\\uDD79)"
                    },
                    {
                        "username": "piudpie",
                        "content": "[@lohani](/lohani) They should have mentioned it in the problem statement, thank you for clarifying though!"
                    },
                    {
                        "username": "psionl0",
                        "content": "the distance between the 2 bombs is sqrt((65-69)^2 + (59-51)^2) = 8.9 which is greater than the range of either bomb."
                    },
                    {
                        "username": "pulkit_singhall",
                        "content": "[@lohani](/lohani) What is the condition for centre to be inside the radius?"
                    },
                    {
                        "username": "lohani",
                        "content": "I stumbled on this same issue. But there is a catch in the problem statement. The second bomb will only be detonated if it\\'s center comes inside the radius of the first bomb. Just intersection of circles is not enough."
                    },
                    {
                        "username": "hengjunlin1129",
                        "content": "I figured out that\\nbomb A can trigger bomb B\\nbomb C can trigger bomb B\\nbomb B cannot trigger bomb A and C\\nbomb A, C cannot trigger each other\\nbut in Union Find A B C will be in same group. (cause A->B, C->B"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "but if c can detonate b, then b must also be able to detonate c"
                    },
                    {
                        "username": "tejasX",
                        "content": "Thanks. I got my mistake."
                    },
                    {
                        "username": "drekker007",
                        "content": "Thank you so much bro!! You made me realize my mistakes!!"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "[@R4Ks](/R4Ks) suppose A has center (0,0) and radius 10, B has center (0,8) and radius 2 , C has center at (0,12) and radius 4, now A can only detonate B, C can also detonate B but B can\\'t detonate either of A and C, neither can A and C detonate each other.."
                    },
                    {
                        "username": "psionl0",
                        "content": "Nope. Detonating one of the bombs won\\'t result in all of the bombs being detonated."
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Give an example and show me such a scenario"
                    },
                    {
                        "username": "rs9",
                        "content": "This problem can be easily solved by DFS/BFS from each vertex in O(N^2). But can it be solved in O(N*logN) or O(N*sqrtN)?\\n\\nIs it possible to somehow lower number of vertex pairs to process by using some data structure like R-tree or over data structures used for knn-algorithms.\\nIs it possible by finding strongly connected components and edge contractions lower asymptotic computation complexity from O(N^2) to O(NlogN), O(NsqrtN) or maybe even O(N).\\n\\nUPD: I found answer to my question. It is no. It\\'s impossible to be  O(N^(2-eps)) for any eps>0.\\nhttps://www.sciencedirect.com/science/article/abs/pii/S0020019016300734?via%3Dihub\\n\\n![image](https://assets.leetcode.com/users/images/459461ca-2281-4e25-bba7-00299938c183_1639421565.9786224.jpeg)\\n"
                    },
                    {
                        "username": "yjian012",
                        "content": "[@cecilia5](/cecilia5) That's exactly my thought too, I totally agree with the finding the SCCs part. But what do you do after getting the DAG? Suppose we start with a DAG, and you know the roots. How do you find the number of vertices that can be reached from each root? You still need to go through most of the vertices/edges again, I think, so it would still be O( |V|*(|V|+|E|) )."
                    },
                    {
                        "username": "Arana",
                        "content": "No. The graph is not given, so this problem cannot be solved by any algorithm less than O(n^3)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "If the graph is given, however, I wonder what\\'s wrong with this algorithm.\\n\\n1.) Run Tarjan\\'s to get the SCCs\\n2.) Create a DAG G\\' of SCCs\\n3.) Compute a topological sorted order T of the reverse of G\\'.\\n4.) For each SCC n in T, compute the size of the connected components starting from arbitrary node of n as the size of n plus the size of all the SCC child of it in G\\'. By the topological sort above, the size should be already there.\\n\\nThis should be $$ O(|V| + |E|) $$ for all steps (note that G\\' can be seen as a contraction of G so is smaller than G)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I wondered the same but I was thinking geometrically. If the bombs are all reaching each other, the adjacency list alone would have $$ O(n^2) $$ entries, so that\\'s the end of it."
                    },
                    {
                        "username": "idklol8",
                        "content": "recommend you not solve on airport wifi while waiting for boarding"
                    },
                    {
                        "username": "anonymousjohndoe999",
                        "content": "haha"
                    },
                    {
                        "username": "Petersburg",
                        "content": "tried and failed"
                    },
                    {
                        "username": "dominhnhut01",
                        "content": "Thank you! I just spent the whole 1 hour just to figure out why my Union Find is not working"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "While calculating the distance between two centers remember to cast the squared value with long. Rest is pretty straightforward in this."
                    },
                    {
                        "username": "tbaby",
                        "content": "Watch out for exceeding max int."
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "[@mfulbright](/mfulbright) Agree, overflow is so annoying and that\\'s why many people switch to Python."
                    },
                    {
                        "username": "mfulbright",
                        "content": "Yeah that got me for a minute too. I hate bullshit like that, it just makes me waste time switching my ints to longs to see if that\\'s what the problem is."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Take a look at Constraints. `O(n^3)` will be fast enough"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Test case:\n```\n[[647,457,91],[483,716,37],[426,119,35],[355,588,40],[850,874,49],[232,568,46],[886,1,30],[54,377,3],[933,986,50],[305,790,49],[372,961,67],[671,314,58],[577,221,29],[380,147,91],[600,535,1],[806,329,64],[536,753,18],[906,88,23],[436,783,82],[652,674,45],[449,668,20],[419,13,66],[853,767,60],[169,288,33],[871,608,66],[337,445,35],[388,623,39],[723,503,81],[14,19,19],[98,648,72],[147,565,93],[655,434,1],[407,663,22],[805,947,83],[942,160,70],[959,496,93],[30,988,53],[187,849,60],[980,483,41],[663,150,76],[268,39,50],[513,522,75],[61,450,90],[115,231,12],[346,304,74],[385,540,23],[905,178,19],[336,896,81],[751,811,94],[527,783,78],[635,965,19],[334,290,39],[748,460,77],[414,134,22],[955,485,29],[925,787,43],[243,771,75],[675,223,29],[788,618,82],[462,544,30],[999,259,50],[210,146,12],[789,442,70],[286,36,55],[451,953,6],[719,914,14],[664,452,14],[933,637,29],[206,926,16],[100,422,98],[97,333,4],[505,631,26],[908,287,65],[907,316,86],[949,185,16],[639,735,62],[401,739,18],[605,926,21],[25,391,69],[80,24,9],[435,874,92],[940,381,18],[260,740,87],[727,515,17],[361,152,16],[512,470,67],[189,27,27],[517,439,94],[159,543,76],[373,698,38],[781,836,97],[584,190,23],[383,367,86],[825,141,63],[117,926,85],[169,588,60],[56,981,100],[294,716,100],[781,370,89],[373,44,78]]\n```\nSort the bombs! Create the adjacent list. Then apply DFS and got the result 7!\n```\nn=100\n56,981,100\n294,716,100\n100,422,98\n781,836,97\n751,811,94\n517,439,94\n147,565,93\n959,496,93\n435,874,92\n647,457,91\n380,147,91\n61,450,90\n781,370,89\n260,740,87\n383,367,86\n907,316,86\n117,926,85\n805,947,83\n436,783,82\n788,618,82\n336,896,81\n723,503,81\n527,783,78\n373,44,78\n748,460,77\n159,543,76\n663,150,76\n243,771,75\n513,522,75\n346,304,74\n98,648,72\n789,442,70\n942,160,70\n25,391,69\n372,961,67\n512,470,67\n871,608,66\n419,13,66\n908,287,65\n806,329,64\n825,141,63\n639,735,62\n187,849,60\n853,767,60\n169,588,60\n671,314,58\n286,36,55\n30,988,53\n933,986,50\n999,259,50\n268,39,50\n850,874,49\n305,790,49\n232,568,46\n652,674,45\n925,787,43\n980,483,41\n355,588,40\n388,623,39\n334,290,39\n373,698,38\n483,716,37\n337,445,35\n426,119,35\n169,288,33\n462,544,30\n886,1,30\n933,637,29\n955,485,29\n675,223,29\n577,221,29\n189,27,27\n505,631,26\n385,540,23\n584,190,23\n906,88,23\n407,663,22\n414,134,22\n605,926,21\n449,668,20\n635,965,19\n905,178,19\n14,19,19\n536,753,18\n401,739,18\n940,381,18\n727,515,17\n206,926,16\n949,185,16\n361,152,16\n719,914,14\n664,452,14\n115,231,12\n210,146,12\n80,24,9\n451,953,6\n97,333,4\n54,377,3\n600,535,1\n655,434,1\n=======\nadj lists:\n0:[16,47]\n1:[13,27,52,60]\n2:[11,33,96,97]\n3:[4,51]\n4:[3]\n5:[28,35]\n6:[25,44,53]\n7:[56,68]\n8:[18,95]\n9:[21,91,99]\n10:[63,77,89]\n11:[2,33,97]\n12:[31,39]\n13:[1,27,52]\n14:[29]\n15:[38,85]\n16:[0]\n18:[61,84]\n20:[34]\n21:[24,86,91]\n22:[83]\n23:[37]\n24:[21,31,86]\n25:[6,44]\n26:[69]\n27:[13,52]\n28:[35,65]\n29:[14,59]\n31:[24]\n32:[81,88]\n33:[97]\n35:[5,28]\n37:[23]\n38:[15]\n39:[12]\n44:[6,25]\n46:[50]\n47:[0]\n50:[46]\n56:[7,68]\n59:[29]\n63:[77]\n68:[7,56]\n77:[63]\n86:[21]\nans=7\n```"
                    },
                    {
                        "username": "anurag-k",
                        "content": "Got the same error. Store the distance between two points in double, int will round off the value and give an error."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@smbody](/smbody) should be  test case"
                    },
                    {
                        "username": "smbody",
                        "content": "But i am getting it as 8, what is so special abt this test case?\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588509/c-dfs-bfs-solutions-with-detonating-bomb-process-beating-90-22/"
                    }
                ]
            },
            {
                "id": 1565572,
                "content": [
                    {
                        "username": "darkalarm",
                        "content": "When I read the question, my first thought was using union find for this question. But after a few test cases, I could understand that the question is actually about a directed graph. Union Find works for an undirected graph.\\n\\n![image](https://assets.leetcode.com/users/images/f7fb76c8-9ab7-4044-bd5f-569b21621f01_1639243400.360309.png)\\n\\nYou can see from the example above, the green circle can detonate the blue circle. But not the other way round. This means, there will be a directed edge from green circle to blue circule.\\n\\nThe question is asking us to find the maximum number of connected nodes in this graph. BFS sounds like the best approach."
                    },
                    {
                        "username": "reassurance",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) \\nMaybe I can help you in understanding why DFS might be faster than BFS although the logic of this question can be handled by both. \\nIn my DFS code, it is seen that if we trail down the path of the possible bombs that can be detonated by the current bomb, we can see that we have a chance to discover bombs that might trigger a **CHAIN** reaction. In other words, a queue in BFS will take longer time to finish and might include bombs that are isolated thereby reducing the impact. \\nAlthough I would not fully agree with my explanation above, this intuition sounded right to me.\\n\\nWould love to see someone prove this!"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "thats good, but how about dfs, I did BFS but my beats were ery low . Seen some solutions thst used DFS, they were more efficient. Don\\'t know the logic why, but it is what it is. try that too and tell me too if you understand why DFS is better than BFS in this case."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "great job, bro"
                    },
                    {
                        "username": "prateek4463",
                        "content": "thanks ! "
                    },
                    {
                        "username": "anfatum",
                        "content": "`bombs` =\\n[[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]\\n`Expected`\\n1\\n\\nAren\\'t [69,51,7] and [65,59,3] intersecting thus there is more than one explosion? "
                    },
                    {
                        "username": "blackhat130",
                        "content": "[@LakshayTheGupta](/LakshayTheGupta) Haha, Great Explanation. "
                    },
                    {
                        "username": "LakshayTheGupta",
                        "content": "[@piudpie](/piudpie) No that must be common sense that to activate  the bomb , it should be inside the range of the exploding bomb. The bomb is not itself a circle with radius R. \\nConclusion : we lack common sense and leetcode is trying to prove in every problem \\uD83E\\uDD23. (I had 2-3 wrong submissions before figuring this issue out \\uD83E\\uDD79)"
                    },
                    {
                        "username": "piudpie",
                        "content": "[@lohani](/lohani) They should have mentioned it in the problem statement, thank you for clarifying though!"
                    },
                    {
                        "username": "psionl0",
                        "content": "the distance between the 2 bombs is sqrt((65-69)^2 + (59-51)^2) = 8.9 which is greater than the range of either bomb."
                    },
                    {
                        "username": "pulkit_singhall",
                        "content": "[@lohani](/lohani) What is the condition for centre to be inside the radius?"
                    },
                    {
                        "username": "lohani",
                        "content": "I stumbled on this same issue. But there is a catch in the problem statement. The second bomb will only be detonated if it\\'s center comes inside the radius of the first bomb. Just intersection of circles is not enough."
                    },
                    {
                        "username": "hengjunlin1129",
                        "content": "I figured out that\\nbomb A can trigger bomb B\\nbomb C can trigger bomb B\\nbomb B cannot trigger bomb A and C\\nbomb A, C cannot trigger each other\\nbut in Union Find A B C will be in same group. (cause A->B, C->B"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "but if c can detonate b, then b must also be able to detonate c"
                    },
                    {
                        "username": "tejasX",
                        "content": "Thanks. I got my mistake."
                    },
                    {
                        "username": "drekker007",
                        "content": "Thank you so much bro!! You made me realize my mistakes!!"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "[@R4Ks](/R4Ks) suppose A has center (0,0) and radius 10, B has center (0,8) and radius 2 , C has center at (0,12) and radius 4, now A can only detonate B, C can also detonate B but B can\\'t detonate either of A and C, neither can A and C detonate each other.."
                    },
                    {
                        "username": "psionl0",
                        "content": "Nope. Detonating one of the bombs won\\'t result in all of the bombs being detonated."
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Give an example and show me such a scenario"
                    },
                    {
                        "username": "rs9",
                        "content": "This problem can be easily solved by DFS/BFS from each vertex in O(N^2). But can it be solved in O(N*logN) or O(N*sqrtN)?\\n\\nIs it possible to somehow lower number of vertex pairs to process by using some data structure like R-tree or over data structures used for knn-algorithms.\\nIs it possible by finding strongly connected components and edge contractions lower asymptotic computation complexity from O(N^2) to O(NlogN), O(NsqrtN) or maybe even O(N).\\n\\nUPD: I found answer to my question. It is no. It\\'s impossible to be  O(N^(2-eps)) for any eps>0.\\nhttps://www.sciencedirect.com/science/article/abs/pii/S0020019016300734?via%3Dihub\\n\\n![image](https://assets.leetcode.com/users/images/459461ca-2281-4e25-bba7-00299938c183_1639421565.9786224.jpeg)\\n"
                    },
                    {
                        "username": "yjian012",
                        "content": "[@cecilia5](/cecilia5) That's exactly my thought too, I totally agree with the finding the SCCs part. But what do you do after getting the DAG? Suppose we start with a DAG, and you know the roots. How do you find the number of vertices that can be reached from each root? You still need to go through most of the vertices/edges again, I think, so it would still be O( |V|*(|V|+|E|) )."
                    },
                    {
                        "username": "Arana",
                        "content": "No. The graph is not given, so this problem cannot be solved by any algorithm less than O(n^3)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "If the graph is given, however, I wonder what\\'s wrong with this algorithm.\\n\\n1.) Run Tarjan\\'s to get the SCCs\\n2.) Create a DAG G\\' of SCCs\\n3.) Compute a topological sorted order T of the reverse of G\\'.\\n4.) For each SCC n in T, compute the size of the connected components starting from arbitrary node of n as the size of n plus the size of all the SCC child of it in G\\'. By the topological sort above, the size should be already there.\\n\\nThis should be $$ O(|V| + |E|) $$ for all steps (note that G\\' can be seen as a contraction of G so is smaller than G)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I wondered the same but I was thinking geometrically. If the bombs are all reaching each other, the adjacency list alone would have $$ O(n^2) $$ entries, so that\\'s the end of it."
                    },
                    {
                        "username": "idklol8",
                        "content": "recommend you not solve on airport wifi while waiting for boarding"
                    },
                    {
                        "username": "anonymousjohndoe999",
                        "content": "haha"
                    },
                    {
                        "username": "Petersburg",
                        "content": "tried and failed"
                    },
                    {
                        "username": "dominhnhut01",
                        "content": "Thank you! I just spent the whole 1 hour just to figure out why my Union Find is not working"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "While calculating the distance between two centers remember to cast the squared value with long. Rest is pretty straightforward in this."
                    },
                    {
                        "username": "tbaby",
                        "content": "Watch out for exceeding max int."
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "[@mfulbright](/mfulbright) Agree, overflow is so annoying and that\\'s why many people switch to Python."
                    },
                    {
                        "username": "mfulbright",
                        "content": "Yeah that got me for a minute too. I hate bullshit like that, it just makes me waste time switching my ints to longs to see if that\\'s what the problem is."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Take a look at Constraints. `O(n^3)` will be fast enough"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Test case:\n```\n[[647,457,91],[483,716,37],[426,119,35],[355,588,40],[850,874,49],[232,568,46],[886,1,30],[54,377,3],[933,986,50],[305,790,49],[372,961,67],[671,314,58],[577,221,29],[380,147,91],[600,535,1],[806,329,64],[536,753,18],[906,88,23],[436,783,82],[652,674,45],[449,668,20],[419,13,66],[853,767,60],[169,288,33],[871,608,66],[337,445,35],[388,623,39],[723,503,81],[14,19,19],[98,648,72],[147,565,93],[655,434,1],[407,663,22],[805,947,83],[942,160,70],[959,496,93],[30,988,53],[187,849,60],[980,483,41],[663,150,76],[268,39,50],[513,522,75],[61,450,90],[115,231,12],[346,304,74],[385,540,23],[905,178,19],[336,896,81],[751,811,94],[527,783,78],[635,965,19],[334,290,39],[748,460,77],[414,134,22],[955,485,29],[925,787,43],[243,771,75],[675,223,29],[788,618,82],[462,544,30],[999,259,50],[210,146,12],[789,442,70],[286,36,55],[451,953,6],[719,914,14],[664,452,14],[933,637,29],[206,926,16],[100,422,98],[97,333,4],[505,631,26],[908,287,65],[907,316,86],[949,185,16],[639,735,62],[401,739,18],[605,926,21],[25,391,69],[80,24,9],[435,874,92],[940,381,18],[260,740,87],[727,515,17],[361,152,16],[512,470,67],[189,27,27],[517,439,94],[159,543,76],[373,698,38],[781,836,97],[584,190,23],[383,367,86],[825,141,63],[117,926,85],[169,588,60],[56,981,100],[294,716,100],[781,370,89],[373,44,78]]\n```\nSort the bombs! Create the adjacent list. Then apply DFS and got the result 7!\n```\nn=100\n56,981,100\n294,716,100\n100,422,98\n781,836,97\n751,811,94\n517,439,94\n147,565,93\n959,496,93\n435,874,92\n647,457,91\n380,147,91\n61,450,90\n781,370,89\n260,740,87\n383,367,86\n907,316,86\n117,926,85\n805,947,83\n436,783,82\n788,618,82\n336,896,81\n723,503,81\n527,783,78\n373,44,78\n748,460,77\n159,543,76\n663,150,76\n243,771,75\n513,522,75\n346,304,74\n98,648,72\n789,442,70\n942,160,70\n25,391,69\n372,961,67\n512,470,67\n871,608,66\n419,13,66\n908,287,65\n806,329,64\n825,141,63\n639,735,62\n187,849,60\n853,767,60\n169,588,60\n671,314,58\n286,36,55\n30,988,53\n933,986,50\n999,259,50\n268,39,50\n850,874,49\n305,790,49\n232,568,46\n652,674,45\n925,787,43\n980,483,41\n355,588,40\n388,623,39\n334,290,39\n373,698,38\n483,716,37\n337,445,35\n426,119,35\n169,288,33\n462,544,30\n886,1,30\n933,637,29\n955,485,29\n675,223,29\n577,221,29\n189,27,27\n505,631,26\n385,540,23\n584,190,23\n906,88,23\n407,663,22\n414,134,22\n605,926,21\n449,668,20\n635,965,19\n905,178,19\n14,19,19\n536,753,18\n401,739,18\n940,381,18\n727,515,17\n206,926,16\n949,185,16\n361,152,16\n719,914,14\n664,452,14\n115,231,12\n210,146,12\n80,24,9\n451,953,6\n97,333,4\n54,377,3\n600,535,1\n655,434,1\n=======\nadj lists:\n0:[16,47]\n1:[13,27,52,60]\n2:[11,33,96,97]\n3:[4,51]\n4:[3]\n5:[28,35]\n6:[25,44,53]\n7:[56,68]\n8:[18,95]\n9:[21,91,99]\n10:[63,77,89]\n11:[2,33,97]\n12:[31,39]\n13:[1,27,52]\n14:[29]\n15:[38,85]\n16:[0]\n18:[61,84]\n20:[34]\n21:[24,86,91]\n22:[83]\n23:[37]\n24:[21,31,86]\n25:[6,44]\n26:[69]\n27:[13,52]\n28:[35,65]\n29:[14,59]\n31:[24]\n32:[81,88]\n33:[97]\n35:[5,28]\n37:[23]\n38:[15]\n39:[12]\n44:[6,25]\n46:[50]\n47:[0]\n50:[46]\n56:[7,68]\n59:[29]\n63:[77]\n68:[7,56]\n77:[63]\n86:[21]\nans=7\n```"
                    },
                    {
                        "username": "anurag-k",
                        "content": "Got the same error. Store the distance between two points in double, int will round off the value and give an error."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@smbody](/smbody) should be  test case"
                    },
                    {
                        "username": "smbody",
                        "content": "But i am getting it as 8, what is so special abt this test case?\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588509/c-dfs-bfs-solutions-with-detonating-bomb-process-beating-90-22/"
                    }
                ]
            },
            {
                "id": 1913561,
                "content": [
                    {
                        "username": "darkalarm",
                        "content": "When I read the question, my first thought was using union find for this question. But after a few test cases, I could understand that the question is actually about a directed graph. Union Find works for an undirected graph.\\n\\n![image](https://assets.leetcode.com/users/images/f7fb76c8-9ab7-4044-bd5f-569b21621f01_1639243400.360309.png)\\n\\nYou can see from the example above, the green circle can detonate the blue circle. But not the other way round. This means, there will be a directed edge from green circle to blue circule.\\n\\nThe question is asking us to find the maximum number of connected nodes in this graph. BFS sounds like the best approach."
                    },
                    {
                        "username": "reassurance",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) \\nMaybe I can help you in understanding why DFS might be faster than BFS although the logic of this question can be handled by both. \\nIn my DFS code, it is seen that if we trail down the path of the possible bombs that can be detonated by the current bomb, we can see that we have a chance to discover bombs that might trigger a **CHAIN** reaction. In other words, a queue in BFS will take longer time to finish and might include bombs that are isolated thereby reducing the impact. \\nAlthough I would not fully agree with my explanation above, this intuition sounded right to me.\\n\\nWould love to see someone prove this!"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "thats good, but how about dfs, I did BFS but my beats were ery low . Seen some solutions thst used DFS, they were more efficient. Don\\'t know the logic why, but it is what it is. try that too and tell me too if you understand why DFS is better than BFS in this case."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "great job, bro"
                    },
                    {
                        "username": "prateek4463",
                        "content": "thanks ! "
                    },
                    {
                        "username": "anfatum",
                        "content": "`bombs` =\\n[[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]\\n`Expected`\\n1\\n\\nAren\\'t [69,51,7] and [65,59,3] intersecting thus there is more than one explosion? "
                    },
                    {
                        "username": "blackhat130",
                        "content": "[@LakshayTheGupta](/LakshayTheGupta) Haha, Great Explanation. "
                    },
                    {
                        "username": "LakshayTheGupta",
                        "content": "[@piudpie](/piudpie) No that must be common sense that to activate  the bomb , it should be inside the range of the exploding bomb. The bomb is not itself a circle with radius R. \\nConclusion : we lack common sense and leetcode is trying to prove in every problem \\uD83E\\uDD23. (I had 2-3 wrong submissions before figuring this issue out \\uD83E\\uDD79)"
                    },
                    {
                        "username": "piudpie",
                        "content": "[@lohani](/lohani) They should have mentioned it in the problem statement, thank you for clarifying though!"
                    },
                    {
                        "username": "psionl0",
                        "content": "the distance between the 2 bombs is sqrt((65-69)^2 + (59-51)^2) = 8.9 which is greater than the range of either bomb."
                    },
                    {
                        "username": "pulkit_singhall",
                        "content": "[@lohani](/lohani) What is the condition for centre to be inside the radius?"
                    },
                    {
                        "username": "lohani",
                        "content": "I stumbled on this same issue. But there is a catch in the problem statement. The second bomb will only be detonated if it\\'s center comes inside the radius of the first bomb. Just intersection of circles is not enough."
                    },
                    {
                        "username": "hengjunlin1129",
                        "content": "I figured out that\\nbomb A can trigger bomb B\\nbomb C can trigger bomb B\\nbomb B cannot trigger bomb A and C\\nbomb A, C cannot trigger each other\\nbut in Union Find A B C will be in same group. (cause A->B, C->B"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "but if c can detonate b, then b must also be able to detonate c"
                    },
                    {
                        "username": "tejasX",
                        "content": "Thanks. I got my mistake."
                    },
                    {
                        "username": "drekker007",
                        "content": "Thank you so much bro!! You made me realize my mistakes!!"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "[@R4Ks](/R4Ks) suppose A has center (0,0) and radius 10, B has center (0,8) and radius 2 , C has center at (0,12) and radius 4, now A can only detonate B, C can also detonate B but B can\\'t detonate either of A and C, neither can A and C detonate each other.."
                    },
                    {
                        "username": "psionl0",
                        "content": "Nope. Detonating one of the bombs won\\'t result in all of the bombs being detonated."
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Give an example and show me such a scenario"
                    },
                    {
                        "username": "rs9",
                        "content": "This problem can be easily solved by DFS/BFS from each vertex in O(N^2). But can it be solved in O(N*logN) or O(N*sqrtN)?\\n\\nIs it possible to somehow lower number of vertex pairs to process by using some data structure like R-tree or over data structures used for knn-algorithms.\\nIs it possible by finding strongly connected components and edge contractions lower asymptotic computation complexity from O(N^2) to O(NlogN), O(NsqrtN) or maybe even O(N).\\n\\nUPD: I found answer to my question. It is no. It\\'s impossible to be  O(N^(2-eps)) for any eps>0.\\nhttps://www.sciencedirect.com/science/article/abs/pii/S0020019016300734?via%3Dihub\\n\\n![image](https://assets.leetcode.com/users/images/459461ca-2281-4e25-bba7-00299938c183_1639421565.9786224.jpeg)\\n"
                    },
                    {
                        "username": "yjian012",
                        "content": "[@cecilia5](/cecilia5) That's exactly my thought too, I totally agree with the finding the SCCs part. But what do you do after getting the DAG? Suppose we start with a DAG, and you know the roots. How do you find the number of vertices that can be reached from each root? You still need to go through most of the vertices/edges again, I think, so it would still be O( |V|*(|V|+|E|) )."
                    },
                    {
                        "username": "Arana",
                        "content": "No. The graph is not given, so this problem cannot be solved by any algorithm less than O(n^3)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "If the graph is given, however, I wonder what\\'s wrong with this algorithm.\\n\\n1.) Run Tarjan\\'s to get the SCCs\\n2.) Create a DAG G\\' of SCCs\\n3.) Compute a topological sorted order T of the reverse of G\\'.\\n4.) For each SCC n in T, compute the size of the connected components starting from arbitrary node of n as the size of n plus the size of all the SCC child of it in G\\'. By the topological sort above, the size should be already there.\\n\\nThis should be $$ O(|V| + |E|) $$ for all steps (note that G\\' can be seen as a contraction of G so is smaller than G)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I wondered the same but I was thinking geometrically. If the bombs are all reaching each other, the adjacency list alone would have $$ O(n^2) $$ entries, so that\\'s the end of it."
                    },
                    {
                        "username": "idklol8",
                        "content": "recommend you not solve on airport wifi while waiting for boarding"
                    },
                    {
                        "username": "anonymousjohndoe999",
                        "content": "haha"
                    },
                    {
                        "username": "Petersburg",
                        "content": "tried and failed"
                    },
                    {
                        "username": "dominhnhut01",
                        "content": "Thank you! I just spent the whole 1 hour just to figure out why my Union Find is not working"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "While calculating the distance between two centers remember to cast the squared value with long. Rest is pretty straightforward in this."
                    },
                    {
                        "username": "tbaby",
                        "content": "Watch out for exceeding max int."
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "[@mfulbright](/mfulbright) Agree, overflow is so annoying and that\\'s why many people switch to Python."
                    },
                    {
                        "username": "mfulbright",
                        "content": "Yeah that got me for a minute too. I hate bullshit like that, it just makes me waste time switching my ints to longs to see if that\\'s what the problem is."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Take a look at Constraints. `O(n^3)` will be fast enough"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Test case:\n```\n[[647,457,91],[483,716,37],[426,119,35],[355,588,40],[850,874,49],[232,568,46],[886,1,30],[54,377,3],[933,986,50],[305,790,49],[372,961,67],[671,314,58],[577,221,29],[380,147,91],[600,535,1],[806,329,64],[536,753,18],[906,88,23],[436,783,82],[652,674,45],[449,668,20],[419,13,66],[853,767,60],[169,288,33],[871,608,66],[337,445,35],[388,623,39],[723,503,81],[14,19,19],[98,648,72],[147,565,93],[655,434,1],[407,663,22],[805,947,83],[942,160,70],[959,496,93],[30,988,53],[187,849,60],[980,483,41],[663,150,76],[268,39,50],[513,522,75],[61,450,90],[115,231,12],[346,304,74],[385,540,23],[905,178,19],[336,896,81],[751,811,94],[527,783,78],[635,965,19],[334,290,39],[748,460,77],[414,134,22],[955,485,29],[925,787,43],[243,771,75],[675,223,29],[788,618,82],[462,544,30],[999,259,50],[210,146,12],[789,442,70],[286,36,55],[451,953,6],[719,914,14],[664,452,14],[933,637,29],[206,926,16],[100,422,98],[97,333,4],[505,631,26],[908,287,65],[907,316,86],[949,185,16],[639,735,62],[401,739,18],[605,926,21],[25,391,69],[80,24,9],[435,874,92],[940,381,18],[260,740,87],[727,515,17],[361,152,16],[512,470,67],[189,27,27],[517,439,94],[159,543,76],[373,698,38],[781,836,97],[584,190,23],[383,367,86],[825,141,63],[117,926,85],[169,588,60],[56,981,100],[294,716,100],[781,370,89],[373,44,78]]\n```\nSort the bombs! Create the adjacent list. Then apply DFS and got the result 7!\n```\nn=100\n56,981,100\n294,716,100\n100,422,98\n781,836,97\n751,811,94\n517,439,94\n147,565,93\n959,496,93\n435,874,92\n647,457,91\n380,147,91\n61,450,90\n781,370,89\n260,740,87\n383,367,86\n907,316,86\n117,926,85\n805,947,83\n436,783,82\n788,618,82\n336,896,81\n723,503,81\n527,783,78\n373,44,78\n748,460,77\n159,543,76\n663,150,76\n243,771,75\n513,522,75\n346,304,74\n98,648,72\n789,442,70\n942,160,70\n25,391,69\n372,961,67\n512,470,67\n871,608,66\n419,13,66\n908,287,65\n806,329,64\n825,141,63\n639,735,62\n187,849,60\n853,767,60\n169,588,60\n671,314,58\n286,36,55\n30,988,53\n933,986,50\n999,259,50\n268,39,50\n850,874,49\n305,790,49\n232,568,46\n652,674,45\n925,787,43\n980,483,41\n355,588,40\n388,623,39\n334,290,39\n373,698,38\n483,716,37\n337,445,35\n426,119,35\n169,288,33\n462,544,30\n886,1,30\n933,637,29\n955,485,29\n675,223,29\n577,221,29\n189,27,27\n505,631,26\n385,540,23\n584,190,23\n906,88,23\n407,663,22\n414,134,22\n605,926,21\n449,668,20\n635,965,19\n905,178,19\n14,19,19\n536,753,18\n401,739,18\n940,381,18\n727,515,17\n206,926,16\n949,185,16\n361,152,16\n719,914,14\n664,452,14\n115,231,12\n210,146,12\n80,24,9\n451,953,6\n97,333,4\n54,377,3\n600,535,1\n655,434,1\n=======\nadj lists:\n0:[16,47]\n1:[13,27,52,60]\n2:[11,33,96,97]\n3:[4,51]\n4:[3]\n5:[28,35]\n6:[25,44,53]\n7:[56,68]\n8:[18,95]\n9:[21,91,99]\n10:[63,77,89]\n11:[2,33,97]\n12:[31,39]\n13:[1,27,52]\n14:[29]\n15:[38,85]\n16:[0]\n18:[61,84]\n20:[34]\n21:[24,86,91]\n22:[83]\n23:[37]\n24:[21,31,86]\n25:[6,44]\n26:[69]\n27:[13,52]\n28:[35,65]\n29:[14,59]\n31:[24]\n32:[81,88]\n33:[97]\n35:[5,28]\n37:[23]\n38:[15]\n39:[12]\n44:[6,25]\n46:[50]\n47:[0]\n50:[46]\n56:[7,68]\n59:[29]\n63:[77]\n68:[7,56]\n77:[63]\n86:[21]\nans=7\n```"
                    },
                    {
                        "username": "anurag-k",
                        "content": "Got the same error. Store the distance between two points in double, int will round off the value and give an error."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@smbody](/smbody) should be  test case"
                    },
                    {
                        "username": "smbody",
                        "content": "But i am getting it as 8, what is so special abt this test case?\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588509/c-dfs-bfs-solutions-with-detonating-bomb-process-beating-90-22/"
                    }
                ]
            },
            {
                "id": 1735394,
                "content": [
                    {
                        "username": "darkalarm",
                        "content": "When I read the question, my first thought was using union find for this question. But after a few test cases, I could understand that the question is actually about a directed graph. Union Find works for an undirected graph.\\n\\n![image](https://assets.leetcode.com/users/images/f7fb76c8-9ab7-4044-bd5f-569b21621f01_1639243400.360309.png)\\n\\nYou can see from the example above, the green circle can detonate the blue circle. But not the other way round. This means, there will be a directed edge from green circle to blue circule.\\n\\nThe question is asking us to find the maximum number of connected nodes in this graph. BFS sounds like the best approach."
                    },
                    {
                        "username": "reassurance",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) \\nMaybe I can help you in understanding why DFS might be faster than BFS although the logic of this question can be handled by both. \\nIn my DFS code, it is seen that if we trail down the path of the possible bombs that can be detonated by the current bomb, we can see that we have a chance to discover bombs that might trigger a **CHAIN** reaction. In other words, a queue in BFS will take longer time to finish and might include bombs that are isolated thereby reducing the impact. \\nAlthough I would not fully agree with my explanation above, this intuition sounded right to me.\\n\\nWould love to see someone prove this!"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "thats good, but how about dfs, I did BFS but my beats were ery low . Seen some solutions thst used DFS, they were more efficient. Don\\'t know the logic why, but it is what it is. try that too and tell me too if you understand why DFS is better than BFS in this case."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "great job, bro"
                    },
                    {
                        "username": "prateek4463",
                        "content": "thanks ! "
                    },
                    {
                        "username": "anfatum",
                        "content": "`bombs` =\\n[[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]\\n`Expected`\\n1\\n\\nAren\\'t [69,51,7] and [65,59,3] intersecting thus there is more than one explosion? "
                    },
                    {
                        "username": "blackhat130",
                        "content": "[@LakshayTheGupta](/LakshayTheGupta) Haha, Great Explanation. "
                    },
                    {
                        "username": "LakshayTheGupta",
                        "content": "[@piudpie](/piudpie) No that must be common sense that to activate  the bomb , it should be inside the range of the exploding bomb. The bomb is not itself a circle with radius R. \\nConclusion : we lack common sense and leetcode is trying to prove in every problem \\uD83E\\uDD23. (I had 2-3 wrong submissions before figuring this issue out \\uD83E\\uDD79)"
                    },
                    {
                        "username": "piudpie",
                        "content": "[@lohani](/lohani) They should have mentioned it in the problem statement, thank you for clarifying though!"
                    },
                    {
                        "username": "psionl0",
                        "content": "the distance between the 2 bombs is sqrt((65-69)^2 + (59-51)^2) = 8.9 which is greater than the range of either bomb."
                    },
                    {
                        "username": "pulkit_singhall",
                        "content": "[@lohani](/lohani) What is the condition for centre to be inside the radius?"
                    },
                    {
                        "username": "lohani",
                        "content": "I stumbled on this same issue. But there is a catch in the problem statement. The second bomb will only be detonated if it\\'s center comes inside the radius of the first bomb. Just intersection of circles is not enough."
                    },
                    {
                        "username": "hengjunlin1129",
                        "content": "I figured out that\\nbomb A can trigger bomb B\\nbomb C can trigger bomb B\\nbomb B cannot trigger bomb A and C\\nbomb A, C cannot trigger each other\\nbut in Union Find A B C will be in same group. (cause A->B, C->B"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "but if c can detonate b, then b must also be able to detonate c"
                    },
                    {
                        "username": "tejasX",
                        "content": "Thanks. I got my mistake."
                    },
                    {
                        "username": "drekker007",
                        "content": "Thank you so much bro!! You made me realize my mistakes!!"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "[@R4Ks](/R4Ks) suppose A has center (0,0) and radius 10, B has center (0,8) and radius 2 , C has center at (0,12) and radius 4, now A can only detonate B, C can also detonate B but B can\\'t detonate either of A and C, neither can A and C detonate each other.."
                    },
                    {
                        "username": "psionl0",
                        "content": "Nope. Detonating one of the bombs won\\'t result in all of the bombs being detonated."
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Give an example and show me such a scenario"
                    },
                    {
                        "username": "rs9",
                        "content": "This problem can be easily solved by DFS/BFS from each vertex in O(N^2). But can it be solved in O(N*logN) or O(N*sqrtN)?\\n\\nIs it possible to somehow lower number of vertex pairs to process by using some data structure like R-tree or over data structures used for knn-algorithms.\\nIs it possible by finding strongly connected components and edge contractions lower asymptotic computation complexity from O(N^2) to O(NlogN), O(NsqrtN) or maybe even O(N).\\n\\nUPD: I found answer to my question. It is no. It\\'s impossible to be  O(N^(2-eps)) for any eps>0.\\nhttps://www.sciencedirect.com/science/article/abs/pii/S0020019016300734?via%3Dihub\\n\\n![image](https://assets.leetcode.com/users/images/459461ca-2281-4e25-bba7-00299938c183_1639421565.9786224.jpeg)\\n"
                    },
                    {
                        "username": "yjian012",
                        "content": "[@cecilia5](/cecilia5) That's exactly my thought too, I totally agree with the finding the SCCs part. But what do you do after getting the DAG? Suppose we start with a DAG, and you know the roots. How do you find the number of vertices that can be reached from each root? You still need to go through most of the vertices/edges again, I think, so it would still be O( |V|*(|V|+|E|) )."
                    },
                    {
                        "username": "Arana",
                        "content": "No. The graph is not given, so this problem cannot be solved by any algorithm less than O(n^3)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "If the graph is given, however, I wonder what\\'s wrong with this algorithm.\\n\\n1.) Run Tarjan\\'s to get the SCCs\\n2.) Create a DAG G\\' of SCCs\\n3.) Compute a topological sorted order T of the reverse of G\\'.\\n4.) For each SCC n in T, compute the size of the connected components starting from arbitrary node of n as the size of n plus the size of all the SCC child of it in G\\'. By the topological sort above, the size should be already there.\\n\\nThis should be $$ O(|V| + |E|) $$ for all steps (note that G\\' can be seen as a contraction of G so is smaller than G)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I wondered the same but I was thinking geometrically. If the bombs are all reaching each other, the adjacency list alone would have $$ O(n^2) $$ entries, so that\\'s the end of it."
                    },
                    {
                        "username": "idklol8",
                        "content": "recommend you not solve on airport wifi while waiting for boarding"
                    },
                    {
                        "username": "anonymousjohndoe999",
                        "content": "haha"
                    },
                    {
                        "username": "Petersburg",
                        "content": "tried and failed"
                    },
                    {
                        "username": "dominhnhut01",
                        "content": "Thank you! I just spent the whole 1 hour just to figure out why my Union Find is not working"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "While calculating the distance between two centers remember to cast the squared value with long. Rest is pretty straightforward in this."
                    },
                    {
                        "username": "tbaby",
                        "content": "Watch out for exceeding max int."
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "[@mfulbright](/mfulbright) Agree, overflow is so annoying and that\\'s why many people switch to Python."
                    },
                    {
                        "username": "mfulbright",
                        "content": "Yeah that got me for a minute too. I hate bullshit like that, it just makes me waste time switching my ints to longs to see if that\\'s what the problem is."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Take a look at Constraints. `O(n^3)` will be fast enough"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Test case:\n```\n[[647,457,91],[483,716,37],[426,119,35],[355,588,40],[850,874,49],[232,568,46],[886,1,30],[54,377,3],[933,986,50],[305,790,49],[372,961,67],[671,314,58],[577,221,29],[380,147,91],[600,535,1],[806,329,64],[536,753,18],[906,88,23],[436,783,82],[652,674,45],[449,668,20],[419,13,66],[853,767,60],[169,288,33],[871,608,66],[337,445,35],[388,623,39],[723,503,81],[14,19,19],[98,648,72],[147,565,93],[655,434,1],[407,663,22],[805,947,83],[942,160,70],[959,496,93],[30,988,53],[187,849,60],[980,483,41],[663,150,76],[268,39,50],[513,522,75],[61,450,90],[115,231,12],[346,304,74],[385,540,23],[905,178,19],[336,896,81],[751,811,94],[527,783,78],[635,965,19],[334,290,39],[748,460,77],[414,134,22],[955,485,29],[925,787,43],[243,771,75],[675,223,29],[788,618,82],[462,544,30],[999,259,50],[210,146,12],[789,442,70],[286,36,55],[451,953,6],[719,914,14],[664,452,14],[933,637,29],[206,926,16],[100,422,98],[97,333,4],[505,631,26],[908,287,65],[907,316,86],[949,185,16],[639,735,62],[401,739,18],[605,926,21],[25,391,69],[80,24,9],[435,874,92],[940,381,18],[260,740,87],[727,515,17],[361,152,16],[512,470,67],[189,27,27],[517,439,94],[159,543,76],[373,698,38],[781,836,97],[584,190,23],[383,367,86],[825,141,63],[117,926,85],[169,588,60],[56,981,100],[294,716,100],[781,370,89],[373,44,78]]\n```\nSort the bombs! Create the adjacent list. Then apply DFS and got the result 7!\n```\nn=100\n56,981,100\n294,716,100\n100,422,98\n781,836,97\n751,811,94\n517,439,94\n147,565,93\n959,496,93\n435,874,92\n647,457,91\n380,147,91\n61,450,90\n781,370,89\n260,740,87\n383,367,86\n907,316,86\n117,926,85\n805,947,83\n436,783,82\n788,618,82\n336,896,81\n723,503,81\n527,783,78\n373,44,78\n748,460,77\n159,543,76\n663,150,76\n243,771,75\n513,522,75\n346,304,74\n98,648,72\n789,442,70\n942,160,70\n25,391,69\n372,961,67\n512,470,67\n871,608,66\n419,13,66\n908,287,65\n806,329,64\n825,141,63\n639,735,62\n187,849,60\n853,767,60\n169,588,60\n671,314,58\n286,36,55\n30,988,53\n933,986,50\n999,259,50\n268,39,50\n850,874,49\n305,790,49\n232,568,46\n652,674,45\n925,787,43\n980,483,41\n355,588,40\n388,623,39\n334,290,39\n373,698,38\n483,716,37\n337,445,35\n426,119,35\n169,288,33\n462,544,30\n886,1,30\n933,637,29\n955,485,29\n675,223,29\n577,221,29\n189,27,27\n505,631,26\n385,540,23\n584,190,23\n906,88,23\n407,663,22\n414,134,22\n605,926,21\n449,668,20\n635,965,19\n905,178,19\n14,19,19\n536,753,18\n401,739,18\n940,381,18\n727,515,17\n206,926,16\n949,185,16\n361,152,16\n719,914,14\n664,452,14\n115,231,12\n210,146,12\n80,24,9\n451,953,6\n97,333,4\n54,377,3\n600,535,1\n655,434,1\n=======\nadj lists:\n0:[16,47]\n1:[13,27,52,60]\n2:[11,33,96,97]\n3:[4,51]\n4:[3]\n5:[28,35]\n6:[25,44,53]\n7:[56,68]\n8:[18,95]\n9:[21,91,99]\n10:[63,77,89]\n11:[2,33,97]\n12:[31,39]\n13:[1,27,52]\n14:[29]\n15:[38,85]\n16:[0]\n18:[61,84]\n20:[34]\n21:[24,86,91]\n22:[83]\n23:[37]\n24:[21,31,86]\n25:[6,44]\n26:[69]\n27:[13,52]\n28:[35,65]\n29:[14,59]\n31:[24]\n32:[81,88]\n33:[97]\n35:[5,28]\n37:[23]\n38:[15]\n39:[12]\n44:[6,25]\n46:[50]\n47:[0]\n50:[46]\n56:[7,68]\n59:[29]\n63:[77]\n68:[7,56]\n77:[63]\n86:[21]\nans=7\n```"
                    },
                    {
                        "username": "anurag-k",
                        "content": "Got the same error. Store the distance between two points in double, int will round off the value and give an error."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@smbody](/smbody) should be  test case"
                    },
                    {
                        "username": "smbody",
                        "content": "But i am getting it as 8, what is so special abt this test case?\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588509/c-dfs-bfs-solutions-with-detonating-bomb-process-beating-90-22/"
                    }
                ]
            },
            {
                "id": 1914030,
                "content": [
                    {
                        "username": "darkalarm",
                        "content": "When I read the question, my first thought was using union find for this question. But after a few test cases, I could understand that the question is actually about a directed graph. Union Find works for an undirected graph.\\n\\n![image](https://assets.leetcode.com/users/images/f7fb76c8-9ab7-4044-bd5f-569b21621f01_1639243400.360309.png)\\n\\nYou can see from the example above, the green circle can detonate the blue circle. But not the other way round. This means, there will be a directed edge from green circle to blue circule.\\n\\nThe question is asking us to find the maximum number of connected nodes in this graph. BFS sounds like the best approach."
                    },
                    {
                        "username": "reassurance",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) \\nMaybe I can help you in understanding why DFS might be faster than BFS although the logic of this question can be handled by both. \\nIn my DFS code, it is seen that if we trail down the path of the possible bombs that can be detonated by the current bomb, we can see that we have a chance to discover bombs that might trigger a **CHAIN** reaction. In other words, a queue in BFS will take longer time to finish and might include bombs that are isolated thereby reducing the impact. \\nAlthough I would not fully agree with my explanation above, this intuition sounded right to me.\\n\\nWould love to see someone prove this!"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "thats good, but how about dfs, I did BFS but my beats were ery low . Seen some solutions thst used DFS, they were more efficient. Don\\'t know the logic why, but it is what it is. try that too and tell me too if you understand why DFS is better than BFS in this case."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "great job, bro"
                    },
                    {
                        "username": "prateek4463",
                        "content": "thanks ! "
                    },
                    {
                        "username": "anfatum",
                        "content": "`bombs` =\\n[[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]\\n`Expected`\\n1\\n\\nAren\\'t [69,51,7] and [65,59,3] intersecting thus there is more than one explosion? "
                    },
                    {
                        "username": "blackhat130",
                        "content": "[@LakshayTheGupta](/LakshayTheGupta) Haha, Great Explanation. "
                    },
                    {
                        "username": "LakshayTheGupta",
                        "content": "[@piudpie](/piudpie) No that must be common sense that to activate  the bomb , it should be inside the range of the exploding bomb. The bomb is not itself a circle with radius R. \\nConclusion : we lack common sense and leetcode is trying to prove in every problem \\uD83E\\uDD23. (I had 2-3 wrong submissions before figuring this issue out \\uD83E\\uDD79)"
                    },
                    {
                        "username": "piudpie",
                        "content": "[@lohani](/lohani) They should have mentioned it in the problem statement, thank you for clarifying though!"
                    },
                    {
                        "username": "psionl0",
                        "content": "the distance between the 2 bombs is sqrt((65-69)^2 + (59-51)^2) = 8.9 which is greater than the range of either bomb."
                    },
                    {
                        "username": "pulkit_singhall",
                        "content": "[@lohani](/lohani) What is the condition for centre to be inside the radius?"
                    },
                    {
                        "username": "lohani",
                        "content": "I stumbled on this same issue. But there is a catch in the problem statement. The second bomb will only be detonated if it\\'s center comes inside the radius of the first bomb. Just intersection of circles is not enough."
                    },
                    {
                        "username": "hengjunlin1129",
                        "content": "I figured out that\\nbomb A can trigger bomb B\\nbomb C can trigger bomb B\\nbomb B cannot trigger bomb A and C\\nbomb A, C cannot trigger each other\\nbut in Union Find A B C will be in same group. (cause A->B, C->B"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "but if c can detonate b, then b must also be able to detonate c"
                    },
                    {
                        "username": "tejasX",
                        "content": "Thanks. I got my mistake."
                    },
                    {
                        "username": "drekker007",
                        "content": "Thank you so much bro!! You made me realize my mistakes!!"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "[@R4Ks](/R4Ks) suppose A has center (0,0) and radius 10, B has center (0,8) and radius 2 , C has center at (0,12) and radius 4, now A can only detonate B, C can also detonate B but B can\\'t detonate either of A and C, neither can A and C detonate each other.."
                    },
                    {
                        "username": "psionl0",
                        "content": "Nope. Detonating one of the bombs won\\'t result in all of the bombs being detonated."
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Give an example and show me such a scenario"
                    },
                    {
                        "username": "rs9",
                        "content": "This problem can be easily solved by DFS/BFS from each vertex in O(N^2). But can it be solved in O(N*logN) or O(N*sqrtN)?\\n\\nIs it possible to somehow lower number of vertex pairs to process by using some data structure like R-tree or over data structures used for knn-algorithms.\\nIs it possible by finding strongly connected components and edge contractions lower asymptotic computation complexity from O(N^2) to O(NlogN), O(NsqrtN) or maybe even O(N).\\n\\nUPD: I found answer to my question. It is no. It\\'s impossible to be  O(N^(2-eps)) for any eps>0.\\nhttps://www.sciencedirect.com/science/article/abs/pii/S0020019016300734?via%3Dihub\\n\\n![image](https://assets.leetcode.com/users/images/459461ca-2281-4e25-bba7-00299938c183_1639421565.9786224.jpeg)\\n"
                    },
                    {
                        "username": "yjian012",
                        "content": "[@cecilia5](/cecilia5) That's exactly my thought too, I totally agree with the finding the SCCs part. But what do you do after getting the DAG? Suppose we start with a DAG, and you know the roots. How do you find the number of vertices that can be reached from each root? You still need to go through most of the vertices/edges again, I think, so it would still be O( |V|*(|V|+|E|) )."
                    },
                    {
                        "username": "Arana",
                        "content": "No. The graph is not given, so this problem cannot be solved by any algorithm less than O(n^3)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "If the graph is given, however, I wonder what\\'s wrong with this algorithm.\\n\\n1.) Run Tarjan\\'s to get the SCCs\\n2.) Create a DAG G\\' of SCCs\\n3.) Compute a topological sorted order T of the reverse of G\\'.\\n4.) For each SCC n in T, compute the size of the connected components starting from arbitrary node of n as the size of n plus the size of all the SCC child of it in G\\'. By the topological sort above, the size should be already there.\\n\\nThis should be $$ O(|V| + |E|) $$ for all steps (note that G\\' can be seen as a contraction of G so is smaller than G)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I wondered the same but I was thinking geometrically. If the bombs are all reaching each other, the adjacency list alone would have $$ O(n^2) $$ entries, so that\\'s the end of it."
                    },
                    {
                        "username": "idklol8",
                        "content": "recommend you not solve on airport wifi while waiting for boarding"
                    },
                    {
                        "username": "anonymousjohndoe999",
                        "content": "haha"
                    },
                    {
                        "username": "Petersburg",
                        "content": "tried and failed"
                    },
                    {
                        "username": "dominhnhut01",
                        "content": "Thank you! I just spent the whole 1 hour just to figure out why my Union Find is not working"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "While calculating the distance between two centers remember to cast the squared value with long. Rest is pretty straightforward in this."
                    },
                    {
                        "username": "tbaby",
                        "content": "Watch out for exceeding max int."
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "[@mfulbright](/mfulbright) Agree, overflow is so annoying and that\\'s why many people switch to Python."
                    },
                    {
                        "username": "mfulbright",
                        "content": "Yeah that got me for a minute too. I hate bullshit like that, it just makes me waste time switching my ints to longs to see if that\\'s what the problem is."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Take a look at Constraints. `O(n^3)` will be fast enough"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Test case:\n```\n[[647,457,91],[483,716,37],[426,119,35],[355,588,40],[850,874,49],[232,568,46],[886,1,30],[54,377,3],[933,986,50],[305,790,49],[372,961,67],[671,314,58],[577,221,29],[380,147,91],[600,535,1],[806,329,64],[536,753,18],[906,88,23],[436,783,82],[652,674,45],[449,668,20],[419,13,66],[853,767,60],[169,288,33],[871,608,66],[337,445,35],[388,623,39],[723,503,81],[14,19,19],[98,648,72],[147,565,93],[655,434,1],[407,663,22],[805,947,83],[942,160,70],[959,496,93],[30,988,53],[187,849,60],[980,483,41],[663,150,76],[268,39,50],[513,522,75],[61,450,90],[115,231,12],[346,304,74],[385,540,23],[905,178,19],[336,896,81],[751,811,94],[527,783,78],[635,965,19],[334,290,39],[748,460,77],[414,134,22],[955,485,29],[925,787,43],[243,771,75],[675,223,29],[788,618,82],[462,544,30],[999,259,50],[210,146,12],[789,442,70],[286,36,55],[451,953,6],[719,914,14],[664,452,14],[933,637,29],[206,926,16],[100,422,98],[97,333,4],[505,631,26],[908,287,65],[907,316,86],[949,185,16],[639,735,62],[401,739,18],[605,926,21],[25,391,69],[80,24,9],[435,874,92],[940,381,18],[260,740,87],[727,515,17],[361,152,16],[512,470,67],[189,27,27],[517,439,94],[159,543,76],[373,698,38],[781,836,97],[584,190,23],[383,367,86],[825,141,63],[117,926,85],[169,588,60],[56,981,100],[294,716,100],[781,370,89],[373,44,78]]\n```\nSort the bombs! Create the adjacent list. Then apply DFS and got the result 7!\n```\nn=100\n56,981,100\n294,716,100\n100,422,98\n781,836,97\n751,811,94\n517,439,94\n147,565,93\n959,496,93\n435,874,92\n647,457,91\n380,147,91\n61,450,90\n781,370,89\n260,740,87\n383,367,86\n907,316,86\n117,926,85\n805,947,83\n436,783,82\n788,618,82\n336,896,81\n723,503,81\n527,783,78\n373,44,78\n748,460,77\n159,543,76\n663,150,76\n243,771,75\n513,522,75\n346,304,74\n98,648,72\n789,442,70\n942,160,70\n25,391,69\n372,961,67\n512,470,67\n871,608,66\n419,13,66\n908,287,65\n806,329,64\n825,141,63\n639,735,62\n187,849,60\n853,767,60\n169,588,60\n671,314,58\n286,36,55\n30,988,53\n933,986,50\n999,259,50\n268,39,50\n850,874,49\n305,790,49\n232,568,46\n652,674,45\n925,787,43\n980,483,41\n355,588,40\n388,623,39\n334,290,39\n373,698,38\n483,716,37\n337,445,35\n426,119,35\n169,288,33\n462,544,30\n886,1,30\n933,637,29\n955,485,29\n675,223,29\n577,221,29\n189,27,27\n505,631,26\n385,540,23\n584,190,23\n906,88,23\n407,663,22\n414,134,22\n605,926,21\n449,668,20\n635,965,19\n905,178,19\n14,19,19\n536,753,18\n401,739,18\n940,381,18\n727,515,17\n206,926,16\n949,185,16\n361,152,16\n719,914,14\n664,452,14\n115,231,12\n210,146,12\n80,24,9\n451,953,6\n97,333,4\n54,377,3\n600,535,1\n655,434,1\n=======\nadj lists:\n0:[16,47]\n1:[13,27,52,60]\n2:[11,33,96,97]\n3:[4,51]\n4:[3]\n5:[28,35]\n6:[25,44,53]\n7:[56,68]\n8:[18,95]\n9:[21,91,99]\n10:[63,77,89]\n11:[2,33,97]\n12:[31,39]\n13:[1,27,52]\n14:[29]\n15:[38,85]\n16:[0]\n18:[61,84]\n20:[34]\n21:[24,86,91]\n22:[83]\n23:[37]\n24:[21,31,86]\n25:[6,44]\n26:[69]\n27:[13,52]\n28:[35,65]\n29:[14,59]\n31:[24]\n32:[81,88]\n33:[97]\n35:[5,28]\n37:[23]\n38:[15]\n39:[12]\n44:[6,25]\n46:[50]\n47:[0]\n50:[46]\n56:[7,68]\n59:[29]\n63:[77]\n68:[7,56]\n77:[63]\n86:[21]\nans=7\n```"
                    },
                    {
                        "username": "anurag-k",
                        "content": "Got the same error. Store the distance between two points in double, int will round off the value and give an error."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@smbody](/smbody) should be  test case"
                    },
                    {
                        "username": "smbody",
                        "content": "But i am getting it as 8, what is so special abt this test case?\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588509/c-dfs-bfs-solutions-with-detonating-bomb-process-beating-90-22/"
                    }
                ]
            },
            {
                "id": 1913900,
                "content": [
                    {
                        "username": "darkalarm",
                        "content": "When I read the question, my first thought was using union find for this question. But after a few test cases, I could understand that the question is actually about a directed graph. Union Find works for an undirected graph.\\n\\n![image](https://assets.leetcode.com/users/images/f7fb76c8-9ab7-4044-bd5f-569b21621f01_1639243400.360309.png)\\n\\nYou can see from the example above, the green circle can detonate the blue circle. But not the other way round. This means, there will be a directed edge from green circle to blue circule.\\n\\nThe question is asking us to find the maximum number of connected nodes in this graph. BFS sounds like the best approach."
                    },
                    {
                        "username": "reassurance",
                        "content": "[@Gaurav_Mangal](/Gaurav_Mangal) \\nMaybe I can help you in understanding why DFS might be faster than BFS although the logic of this question can be handled by both. \\nIn my DFS code, it is seen that if we trail down the path of the possible bombs that can be detonated by the current bomb, we can see that we have a chance to discover bombs that might trigger a **CHAIN** reaction. In other words, a queue in BFS will take longer time to finish and might include bombs that are isolated thereby reducing the impact. \\nAlthough I would not fully agree with my explanation above, this intuition sounded right to me.\\n\\nWould love to see someone prove this!"
                    },
                    {
                        "username": "Gaurav_Mangal",
                        "content": "thats good, but how about dfs, I did BFS but my beats were ery low . Seen some solutions thst used DFS, they were more efficient. Don\\'t know the logic why, but it is what it is. try that too and tell me too if you understand why DFS is better than BFS in this case."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "great job, bro"
                    },
                    {
                        "username": "prateek4463",
                        "content": "thanks ! "
                    },
                    {
                        "username": "anfatum",
                        "content": "`bombs` =\\n[[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]\\n`Expected`\\n1\\n\\nAren\\'t [69,51,7] and [65,59,3] intersecting thus there is more than one explosion? "
                    },
                    {
                        "username": "blackhat130",
                        "content": "[@LakshayTheGupta](/LakshayTheGupta) Haha, Great Explanation. "
                    },
                    {
                        "username": "LakshayTheGupta",
                        "content": "[@piudpie](/piudpie) No that must be common sense that to activate  the bomb , it should be inside the range of the exploding bomb. The bomb is not itself a circle with radius R. \\nConclusion : we lack common sense and leetcode is trying to prove in every problem \\uD83E\\uDD23. (I had 2-3 wrong submissions before figuring this issue out \\uD83E\\uDD79)"
                    },
                    {
                        "username": "piudpie",
                        "content": "[@lohani](/lohani) They should have mentioned it in the problem statement, thank you for clarifying though!"
                    },
                    {
                        "username": "psionl0",
                        "content": "the distance between the 2 bombs is sqrt((65-69)^2 + (59-51)^2) = 8.9 which is greater than the range of either bomb."
                    },
                    {
                        "username": "pulkit_singhall",
                        "content": "[@lohani](/lohani) What is the condition for centre to be inside the radius?"
                    },
                    {
                        "username": "lohani",
                        "content": "I stumbled on this same issue. But there is a catch in the problem statement. The second bomb will only be detonated if it\\'s center comes inside the radius of the first bomb. Just intersection of circles is not enough."
                    },
                    {
                        "username": "hengjunlin1129",
                        "content": "I figured out that\\nbomb A can trigger bomb B\\nbomb C can trigger bomb B\\nbomb B cannot trigger bomb A and C\\nbomb A, C cannot trigger each other\\nbut in Union Find A B C will be in same group. (cause A->B, C->B"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "but if c can detonate b, then b must also be able to detonate c"
                    },
                    {
                        "username": "tejasX",
                        "content": "Thanks. I got my mistake."
                    },
                    {
                        "username": "drekker007",
                        "content": "Thank you so much bro!! You made me realize my mistakes!!"
                    },
                    {
                        "username": "Tusharsingh110",
                        "content": "[@R4Ks](/R4Ks) suppose A has center (0,0) and radius 10, B has center (0,8) and radius 2 , C has center at (0,12) and radius 4, now A can only detonate B, C can also detonate B but B can\\'t detonate either of A and C, neither can A and C detonate each other.."
                    },
                    {
                        "username": "psionl0",
                        "content": "Nope. Detonating one of the bombs won\\'t result in all of the bombs being detonated."
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "Give an example and show me such a scenario"
                    },
                    {
                        "username": "rs9",
                        "content": "This problem can be easily solved by DFS/BFS from each vertex in O(N^2). But can it be solved in O(N*logN) or O(N*sqrtN)?\\n\\nIs it possible to somehow lower number of vertex pairs to process by using some data structure like R-tree or over data structures used for knn-algorithms.\\nIs it possible by finding strongly connected components and edge contractions lower asymptotic computation complexity from O(N^2) to O(NlogN), O(NsqrtN) or maybe even O(N).\\n\\nUPD: I found answer to my question. It is no. It\\'s impossible to be  O(N^(2-eps)) for any eps>0.\\nhttps://www.sciencedirect.com/science/article/abs/pii/S0020019016300734?via%3Dihub\\n\\n![image](https://assets.leetcode.com/users/images/459461ca-2281-4e25-bba7-00299938c183_1639421565.9786224.jpeg)\\n"
                    },
                    {
                        "username": "yjian012",
                        "content": "[@cecilia5](/cecilia5) That's exactly my thought too, I totally agree with the finding the SCCs part. But what do you do after getting the DAG? Suppose we start with a DAG, and you know the roots. How do you find the number of vertices that can be reached from each root? You still need to go through most of the vertices/edges again, I think, so it would still be O( |V|*(|V|+|E|) )."
                    },
                    {
                        "username": "Arana",
                        "content": "No. The graph is not given, so this problem cannot be solved by any algorithm less than O(n^3)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "If the graph is given, however, I wonder what\\'s wrong with this algorithm.\\n\\n1.) Run Tarjan\\'s to get the SCCs\\n2.) Create a DAG G\\' of SCCs\\n3.) Compute a topological sorted order T of the reverse of G\\'.\\n4.) For each SCC n in T, compute the size of the connected components starting from arbitrary node of n as the size of n plus the size of all the SCC child of it in G\\'. By the topological sort above, the size should be already there.\\n\\nThis should be $$ O(|V| + |E|) $$ for all steps (note that G\\' can be seen as a contraction of G so is smaller than G)"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I wondered the same but I was thinking geometrically. If the bombs are all reaching each other, the adjacency list alone would have $$ O(n^2) $$ entries, so that\\'s the end of it."
                    },
                    {
                        "username": "idklol8",
                        "content": "recommend you not solve on airport wifi while waiting for boarding"
                    },
                    {
                        "username": "anonymousjohndoe999",
                        "content": "haha"
                    },
                    {
                        "username": "Petersburg",
                        "content": "tried and failed"
                    },
                    {
                        "username": "dominhnhut01",
                        "content": "Thank you! I just spent the whole 1 hour just to figure out why my Union Find is not working"
                    },
                    {
                        "username": "kiryu_0",
                        "content": "While calculating the distance between two centers remember to cast the squared value with long. Rest is pretty straightforward in this."
                    },
                    {
                        "username": "tbaby",
                        "content": "Watch out for exceeding max int."
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "[@mfulbright](/mfulbright) Agree, overflow is so annoying and that\\'s why many people switch to Python."
                    },
                    {
                        "username": "mfulbright",
                        "content": "Yeah that got me for a minute too. I hate bullshit like that, it just makes me waste time switching my ints to longs to see if that\\'s what the problem is."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Take a look at Constraints. `O(n^3)` will be fast enough"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Test case:\n```\n[[647,457,91],[483,716,37],[426,119,35],[355,588,40],[850,874,49],[232,568,46],[886,1,30],[54,377,3],[933,986,50],[305,790,49],[372,961,67],[671,314,58],[577,221,29],[380,147,91],[600,535,1],[806,329,64],[536,753,18],[906,88,23],[436,783,82],[652,674,45],[449,668,20],[419,13,66],[853,767,60],[169,288,33],[871,608,66],[337,445,35],[388,623,39],[723,503,81],[14,19,19],[98,648,72],[147,565,93],[655,434,1],[407,663,22],[805,947,83],[942,160,70],[959,496,93],[30,988,53],[187,849,60],[980,483,41],[663,150,76],[268,39,50],[513,522,75],[61,450,90],[115,231,12],[346,304,74],[385,540,23],[905,178,19],[336,896,81],[751,811,94],[527,783,78],[635,965,19],[334,290,39],[748,460,77],[414,134,22],[955,485,29],[925,787,43],[243,771,75],[675,223,29],[788,618,82],[462,544,30],[999,259,50],[210,146,12],[789,442,70],[286,36,55],[451,953,6],[719,914,14],[664,452,14],[933,637,29],[206,926,16],[100,422,98],[97,333,4],[505,631,26],[908,287,65],[907,316,86],[949,185,16],[639,735,62],[401,739,18],[605,926,21],[25,391,69],[80,24,9],[435,874,92],[940,381,18],[260,740,87],[727,515,17],[361,152,16],[512,470,67],[189,27,27],[517,439,94],[159,543,76],[373,698,38],[781,836,97],[584,190,23],[383,367,86],[825,141,63],[117,926,85],[169,588,60],[56,981,100],[294,716,100],[781,370,89],[373,44,78]]\n```\nSort the bombs! Create the adjacent list. Then apply DFS and got the result 7!\n```\nn=100\n56,981,100\n294,716,100\n100,422,98\n781,836,97\n751,811,94\n517,439,94\n147,565,93\n959,496,93\n435,874,92\n647,457,91\n380,147,91\n61,450,90\n781,370,89\n260,740,87\n383,367,86\n907,316,86\n117,926,85\n805,947,83\n436,783,82\n788,618,82\n336,896,81\n723,503,81\n527,783,78\n373,44,78\n748,460,77\n159,543,76\n663,150,76\n243,771,75\n513,522,75\n346,304,74\n98,648,72\n789,442,70\n942,160,70\n25,391,69\n372,961,67\n512,470,67\n871,608,66\n419,13,66\n908,287,65\n806,329,64\n825,141,63\n639,735,62\n187,849,60\n853,767,60\n169,588,60\n671,314,58\n286,36,55\n30,988,53\n933,986,50\n999,259,50\n268,39,50\n850,874,49\n305,790,49\n232,568,46\n652,674,45\n925,787,43\n980,483,41\n355,588,40\n388,623,39\n334,290,39\n373,698,38\n483,716,37\n337,445,35\n426,119,35\n169,288,33\n462,544,30\n886,1,30\n933,637,29\n955,485,29\n675,223,29\n577,221,29\n189,27,27\n505,631,26\n385,540,23\n584,190,23\n906,88,23\n407,663,22\n414,134,22\n605,926,21\n449,668,20\n635,965,19\n905,178,19\n14,19,19\n536,753,18\n401,739,18\n940,381,18\n727,515,17\n206,926,16\n949,185,16\n361,152,16\n719,914,14\n664,452,14\n115,231,12\n210,146,12\n80,24,9\n451,953,6\n97,333,4\n54,377,3\n600,535,1\n655,434,1\n=======\nadj lists:\n0:[16,47]\n1:[13,27,52,60]\n2:[11,33,96,97]\n3:[4,51]\n4:[3]\n5:[28,35]\n6:[25,44,53]\n7:[56,68]\n8:[18,95]\n9:[21,91,99]\n10:[63,77,89]\n11:[2,33,97]\n12:[31,39]\n13:[1,27,52]\n14:[29]\n15:[38,85]\n16:[0]\n18:[61,84]\n20:[34]\n21:[24,86,91]\n22:[83]\n23:[37]\n24:[21,31,86]\n25:[6,44]\n26:[69]\n27:[13,52]\n28:[35,65]\n29:[14,59]\n31:[24]\n32:[81,88]\n33:[97]\n35:[5,28]\n37:[23]\n38:[15]\n39:[12]\n44:[6,25]\n46:[50]\n47:[0]\n50:[46]\n56:[7,68]\n59:[29]\n63:[77]\n68:[7,56]\n77:[63]\n86:[21]\nans=7\n```"
                    },
                    {
                        "username": "anurag-k",
                        "content": "Got the same error. Store the distance between two points in double, int will round off the value and give an error."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@smbody](/smbody) should be  test case"
                    },
                    {
                        "username": "smbody",
                        "content": "But i am getting it as 8, what is so special abt this test case?\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588509/c-dfs-bfs-solutions-with-detonating-bomb-process-beating-90-22/"
                    }
                ]
            },
            {
                "id": 1913675,
                "content": [
                    {
                        "username": "Sid_2027",
                        "content": "The solution treats bombs as nodes in a directed graph. If a bomb lies within another bomb\\'s range, it forms a directed edge. The adjacency list represents this graph. DFS is used to traverse and count bombs in each component. A separate visited array ensures accurate counting within each component. The solution finds the maximum number of detonatable bombs by iterating over components and performing DFS."
                    },
                    {
                        "username": "psionl0",
                        "content": "It\\'s as if you read my solution! :D\\n\\nSeriously though, this is an excellent description of how to approach the solution."
                    },
                    {
                        "username": "2106_ayush_2003",
                        "content": "Another example which proves that LEETCODE should describe problem statement more clear."
                    },
                    {
                        "username": "Arana",
                        "content": "This is a very good question for practicing DFS/BFS in graphs. Highly recommended!"
                    },
                    {
                        "username": "devle79",
                        "content": "No. I\\'ll choose love and peace."
                    },
                    {
                        "username": "anandnit",
                        "content": "[[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]...why this is not running ?? \\nLeetcode s**ks"
                    },
                    {
                        "username": "NooBaDes",
                        "content": "yes [69,51,7] and [65,59,3] should be running well i am getting output as 2,but it shows expected result as 1..\\n\\n"
                    },
                    {
                        "username": "go_dodgers",
                        "content": "What edge case is the last test case (162) testing? \n `[[634,440,278],[748,509,396],[995,881,251],[704,214,341],[832,972,238],[987,384,156],[378,988,402],[743,557,252],[814,868,196],[131,922,199],[13,398,444],[464,607,241],[426,128,81]]` \nI pass every case except this one... and not due to a timeout or anything. I actually get the wrong answer. (Expected 12, I get 10)"
                    },
                    {
                        "username": "Bitterswit",
                        "content": "Me too. Can\\'t figure out."
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "Don't know how I feel about these more math heavy questions. On it's own without the distance formula it's a solid medium LC question on par with other graph traversal questions on the site. The requirement to also derive the distance formula puts this in a hard. \n\nEven if you were familiar with graphs and how to build the adjacency lists to traverse them unless the interviewer gives you the formula to calculate the distance I don't know if you're just going to rediscover it on your own in an interview environment. "
                    },
                    {
                        "username": "vijaysince89",
                        "content": "Last test case is not working. They are giving Empty bombs and the program just hangs. Any one facing similar issue ?"
                    },
                    {
                        "username": "sanjusabu066",
                        "content": "[[85024,58997,3532],[65196,42043,9739],[85872,75029,3117],[73014,91183,7092],[29098,40864,7624],[11469,13607,4315],[98722,69681,9656],[75140,42250,421],[92580,44040,4779],[58474,78273,1047],[27683,4203,6186],[10714,24238,6243],[60138,81791,3496],[16227,92418,5622],[60496,64917,2463],[59241,62074,885],[11961,163,5815],[37757,43214,3402],[21094,98519,1678],[49368,22385,1431],[6343,53798,159],[80129,9282,5139],[69565,32036,6827],[59372,64978,6575],[44948,71199,7095],[46390,91701,1667],[37144,98691,8128],[13558,81505,4653],[41234,48161,9304],[14852,3206,5369]]\\nFor all those java peeps getting an error in this test case it is due to the distance exceeding the INT_MAX value.\\nUse this while calculating distance.\\n                double dx= bomb[j][0] -bomb[i][0];\\n                double dy= bomb[j][1] -bomb[i][1];\\n\\n                double d =  Math.sqrt(dx*dx + dy*dy);"
                    },
                    {
                        "username": "sanjusabu066",
                        "content": "[@Suyash_Rajput](/Suyash_Rajput) Happy to help ;)"
                    },
                    {
                        "username": "Suyash_Rajput",
                        "content": "bro you saved me\\n"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "For Those who Thought DSU (Union Find) Approach for this Question. It will not work here bcoz the bombing here represents Directed Graph , and UNION FIND works for Undirected Graph. \\nConsidering DSU approach may create conflict whether the Bomb chain would propogate thoroughly or not.\\nConsider the scenario of TC 1. Bomb B can detonate bomb A, but bomb A cannot Detonate bomb B. Thus, it depicts the Directional Nature of Edges.\\nB -> A ( True ) ( 2 Explosion )\\nbut \\nA -> B ( Only 1 Explosion ) "
                    }
                ]
            },
            {
                "id": 1848498,
                "content": [
                    {
                        "username": "Sid_2027",
                        "content": "The solution treats bombs as nodes in a directed graph. If a bomb lies within another bomb\\'s range, it forms a directed edge. The adjacency list represents this graph. DFS is used to traverse and count bombs in each component. A separate visited array ensures accurate counting within each component. The solution finds the maximum number of detonatable bombs by iterating over components and performing DFS."
                    },
                    {
                        "username": "psionl0",
                        "content": "It\\'s as if you read my solution! :D\\n\\nSeriously though, this is an excellent description of how to approach the solution."
                    },
                    {
                        "username": "2106_ayush_2003",
                        "content": "Another example which proves that LEETCODE should describe problem statement more clear."
                    },
                    {
                        "username": "Arana",
                        "content": "This is a very good question for practicing DFS/BFS in graphs. Highly recommended!"
                    },
                    {
                        "username": "devle79",
                        "content": "No. I\\'ll choose love and peace."
                    },
                    {
                        "username": "anandnit",
                        "content": "[[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]...why this is not running ?? \\nLeetcode s**ks"
                    },
                    {
                        "username": "NooBaDes",
                        "content": "yes [69,51,7] and [65,59,3] should be running well i am getting output as 2,but it shows expected result as 1..\\n\\n"
                    },
                    {
                        "username": "go_dodgers",
                        "content": "What edge case is the last test case (162) testing? \n `[[634,440,278],[748,509,396],[995,881,251],[704,214,341],[832,972,238],[987,384,156],[378,988,402],[743,557,252],[814,868,196],[131,922,199],[13,398,444],[464,607,241],[426,128,81]]` \nI pass every case except this one... and not due to a timeout or anything. I actually get the wrong answer. (Expected 12, I get 10)"
                    },
                    {
                        "username": "Bitterswit",
                        "content": "Me too. Can\\'t figure out."
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "Don't know how I feel about these more math heavy questions. On it's own without the distance formula it's a solid medium LC question on par with other graph traversal questions on the site. The requirement to also derive the distance formula puts this in a hard. \n\nEven if you were familiar with graphs and how to build the adjacency lists to traverse them unless the interviewer gives you the formula to calculate the distance I don't know if you're just going to rediscover it on your own in an interview environment. "
                    },
                    {
                        "username": "vijaysince89",
                        "content": "Last test case is not working. They are giving Empty bombs and the program just hangs. Any one facing similar issue ?"
                    },
                    {
                        "username": "sanjusabu066",
                        "content": "[[85024,58997,3532],[65196,42043,9739],[85872,75029,3117],[73014,91183,7092],[29098,40864,7624],[11469,13607,4315],[98722,69681,9656],[75140,42250,421],[92580,44040,4779],[58474,78273,1047],[27683,4203,6186],[10714,24238,6243],[60138,81791,3496],[16227,92418,5622],[60496,64917,2463],[59241,62074,885],[11961,163,5815],[37757,43214,3402],[21094,98519,1678],[49368,22385,1431],[6343,53798,159],[80129,9282,5139],[69565,32036,6827],[59372,64978,6575],[44948,71199,7095],[46390,91701,1667],[37144,98691,8128],[13558,81505,4653],[41234,48161,9304],[14852,3206,5369]]\\nFor all those java peeps getting an error in this test case it is due to the distance exceeding the INT_MAX value.\\nUse this while calculating distance.\\n                double dx= bomb[j][0] -bomb[i][0];\\n                double dy= bomb[j][1] -bomb[i][1];\\n\\n                double d =  Math.sqrt(dx*dx + dy*dy);"
                    },
                    {
                        "username": "sanjusabu066",
                        "content": "[@Suyash_Rajput](/Suyash_Rajput) Happy to help ;)"
                    },
                    {
                        "username": "Suyash_Rajput",
                        "content": "bro you saved me\\n"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "For Those who Thought DSU (Union Find) Approach for this Question. It will not work here bcoz the bombing here represents Directed Graph , and UNION FIND works for Undirected Graph. \\nConsidering DSU approach may create conflict whether the Bomb chain would propogate thoroughly or not.\\nConsider the scenario of TC 1. Bomb B can detonate bomb A, but bomb A cannot Detonate bomb B. Thus, it depicts the Directional Nature of Edges.\\nB -> A ( True ) ( 2 Explosion )\\nbut \\nA -> B ( Only 1 Explosion ) "
                    }
                ]
            },
            {
                "id": 1913720,
                "content": [
                    {
                        "username": "Sid_2027",
                        "content": "The solution treats bombs as nodes in a directed graph. If a bomb lies within another bomb\\'s range, it forms a directed edge. The adjacency list represents this graph. DFS is used to traverse and count bombs in each component. A separate visited array ensures accurate counting within each component. The solution finds the maximum number of detonatable bombs by iterating over components and performing DFS."
                    },
                    {
                        "username": "psionl0",
                        "content": "It\\'s as if you read my solution! :D\\n\\nSeriously though, this is an excellent description of how to approach the solution."
                    },
                    {
                        "username": "2106_ayush_2003",
                        "content": "Another example which proves that LEETCODE should describe problem statement more clear."
                    },
                    {
                        "username": "Arana",
                        "content": "This is a very good question for practicing DFS/BFS in graphs. Highly recommended!"
                    },
                    {
                        "username": "devle79",
                        "content": "No. I\\'ll choose love and peace."
                    },
                    {
                        "username": "anandnit",
                        "content": "[[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]...why this is not running ?? \\nLeetcode s**ks"
                    },
                    {
                        "username": "NooBaDes",
                        "content": "yes [69,51,7] and [65,59,3] should be running well i am getting output as 2,but it shows expected result as 1..\\n\\n"
                    },
                    {
                        "username": "go_dodgers",
                        "content": "What edge case is the last test case (162) testing? \n `[[634,440,278],[748,509,396],[995,881,251],[704,214,341],[832,972,238],[987,384,156],[378,988,402],[743,557,252],[814,868,196],[131,922,199],[13,398,444],[464,607,241],[426,128,81]]` \nI pass every case except this one... and not due to a timeout or anything. I actually get the wrong answer. (Expected 12, I get 10)"
                    },
                    {
                        "username": "Bitterswit",
                        "content": "Me too. Can\\'t figure out."
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "Don't know how I feel about these more math heavy questions. On it's own without the distance formula it's a solid medium LC question on par with other graph traversal questions on the site. The requirement to also derive the distance formula puts this in a hard. \n\nEven if you were familiar with graphs and how to build the adjacency lists to traverse them unless the interviewer gives you the formula to calculate the distance I don't know if you're just going to rediscover it on your own in an interview environment. "
                    },
                    {
                        "username": "vijaysince89",
                        "content": "Last test case is not working. They are giving Empty bombs and the program just hangs. Any one facing similar issue ?"
                    },
                    {
                        "username": "sanjusabu066",
                        "content": "[[85024,58997,3532],[65196,42043,9739],[85872,75029,3117],[73014,91183,7092],[29098,40864,7624],[11469,13607,4315],[98722,69681,9656],[75140,42250,421],[92580,44040,4779],[58474,78273,1047],[27683,4203,6186],[10714,24238,6243],[60138,81791,3496],[16227,92418,5622],[60496,64917,2463],[59241,62074,885],[11961,163,5815],[37757,43214,3402],[21094,98519,1678],[49368,22385,1431],[6343,53798,159],[80129,9282,5139],[69565,32036,6827],[59372,64978,6575],[44948,71199,7095],[46390,91701,1667],[37144,98691,8128],[13558,81505,4653],[41234,48161,9304],[14852,3206,5369]]\\nFor all those java peeps getting an error in this test case it is due to the distance exceeding the INT_MAX value.\\nUse this while calculating distance.\\n                double dx= bomb[j][0] -bomb[i][0];\\n                double dy= bomb[j][1] -bomb[i][1];\\n\\n                double d =  Math.sqrt(dx*dx + dy*dy);"
                    },
                    {
                        "username": "sanjusabu066",
                        "content": "[@Suyash_Rajput](/Suyash_Rajput) Happy to help ;)"
                    },
                    {
                        "username": "Suyash_Rajput",
                        "content": "bro you saved me\\n"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "For Those who Thought DSU (Union Find) Approach for this Question. It will not work here bcoz the bombing here represents Directed Graph , and UNION FIND works for Undirected Graph. \\nConsidering DSU approach may create conflict whether the Bomb chain would propogate thoroughly or not.\\nConsider the scenario of TC 1. Bomb B can detonate bomb A, but bomb A cannot Detonate bomb B. Thus, it depicts the Directional Nature of Edges.\\nB -> A ( True ) ( 2 Explosion )\\nbut \\nA -> B ( Only 1 Explosion ) "
                    }
                ]
            },
            {
                "id": 1914223,
                "content": [
                    {
                        "username": "Sid_2027",
                        "content": "The solution treats bombs as nodes in a directed graph. If a bomb lies within another bomb\\'s range, it forms a directed edge. The adjacency list represents this graph. DFS is used to traverse and count bombs in each component. A separate visited array ensures accurate counting within each component. The solution finds the maximum number of detonatable bombs by iterating over components and performing DFS."
                    },
                    {
                        "username": "psionl0",
                        "content": "It\\'s as if you read my solution! :D\\n\\nSeriously though, this is an excellent description of how to approach the solution."
                    },
                    {
                        "username": "2106_ayush_2003",
                        "content": "Another example which proves that LEETCODE should describe problem statement more clear."
                    },
                    {
                        "username": "Arana",
                        "content": "This is a very good question for practicing DFS/BFS in graphs. Highly recommended!"
                    },
                    {
                        "username": "devle79",
                        "content": "No. I\\'ll choose love and peace."
                    },
                    {
                        "username": "anandnit",
                        "content": "[[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]...why this is not running ?? \\nLeetcode s**ks"
                    },
                    {
                        "username": "NooBaDes",
                        "content": "yes [69,51,7] and [65,59,3] should be running well i am getting output as 2,but it shows expected result as 1..\\n\\n"
                    },
                    {
                        "username": "go_dodgers",
                        "content": "What edge case is the last test case (162) testing? \n `[[634,440,278],[748,509,396],[995,881,251],[704,214,341],[832,972,238],[987,384,156],[378,988,402],[743,557,252],[814,868,196],[131,922,199],[13,398,444],[464,607,241],[426,128,81]]` \nI pass every case except this one... and not due to a timeout or anything. I actually get the wrong answer. (Expected 12, I get 10)"
                    },
                    {
                        "username": "Bitterswit",
                        "content": "Me too. Can\\'t figure out."
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "Don't know how I feel about these more math heavy questions. On it's own without the distance formula it's a solid medium LC question on par with other graph traversal questions on the site. The requirement to also derive the distance formula puts this in a hard. \n\nEven if you were familiar with graphs and how to build the adjacency lists to traverse them unless the interviewer gives you the formula to calculate the distance I don't know if you're just going to rediscover it on your own in an interview environment. "
                    },
                    {
                        "username": "vijaysince89",
                        "content": "Last test case is not working. They are giving Empty bombs and the program just hangs. Any one facing similar issue ?"
                    },
                    {
                        "username": "sanjusabu066",
                        "content": "[[85024,58997,3532],[65196,42043,9739],[85872,75029,3117],[73014,91183,7092],[29098,40864,7624],[11469,13607,4315],[98722,69681,9656],[75140,42250,421],[92580,44040,4779],[58474,78273,1047],[27683,4203,6186],[10714,24238,6243],[60138,81791,3496],[16227,92418,5622],[60496,64917,2463],[59241,62074,885],[11961,163,5815],[37757,43214,3402],[21094,98519,1678],[49368,22385,1431],[6343,53798,159],[80129,9282,5139],[69565,32036,6827],[59372,64978,6575],[44948,71199,7095],[46390,91701,1667],[37144,98691,8128],[13558,81505,4653],[41234,48161,9304],[14852,3206,5369]]\\nFor all those java peeps getting an error in this test case it is due to the distance exceeding the INT_MAX value.\\nUse this while calculating distance.\\n                double dx= bomb[j][0] -bomb[i][0];\\n                double dy= bomb[j][1] -bomb[i][1];\\n\\n                double d =  Math.sqrt(dx*dx + dy*dy);"
                    },
                    {
                        "username": "sanjusabu066",
                        "content": "[@Suyash_Rajput](/Suyash_Rajput) Happy to help ;)"
                    },
                    {
                        "username": "Suyash_Rajput",
                        "content": "bro you saved me\\n"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "For Those who Thought DSU (Union Find) Approach for this Question. It will not work here bcoz the bombing here represents Directed Graph , and UNION FIND works for Undirected Graph. \\nConsidering DSU approach may create conflict whether the Bomb chain would propogate thoroughly or not.\\nConsider the scenario of TC 1. Bomb B can detonate bomb A, but bomb A cannot Detonate bomb B. Thus, it depicts the Directional Nature of Edges.\\nB -> A ( True ) ( 2 Explosion )\\nbut \\nA -> B ( Only 1 Explosion ) "
                    }
                ]
            },
            {
                "id": 1843379,
                "content": [
                    {
                        "username": "Sid_2027",
                        "content": "The solution treats bombs as nodes in a directed graph. If a bomb lies within another bomb\\'s range, it forms a directed edge. The adjacency list represents this graph. DFS is used to traverse and count bombs in each component. A separate visited array ensures accurate counting within each component. The solution finds the maximum number of detonatable bombs by iterating over components and performing DFS."
                    },
                    {
                        "username": "psionl0",
                        "content": "It\\'s as if you read my solution! :D\\n\\nSeriously though, this is an excellent description of how to approach the solution."
                    },
                    {
                        "username": "2106_ayush_2003",
                        "content": "Another example which proves that LEETCODE should describe problem statement more clear."
                    },
                    {
                        "username": "Arana",
                        "content": "This is a very good question for practicing DFS/BFS in graphs. Highly recommended!"
                    },
                    {
                        "username": "devle79",
                        "content": "No. I\\'ll choose love and peace."
                    },
                    {
                        "username": "anandnit",
                        "content": "[[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]...why this is not running ?? \\nLeetcode s**ks"
                    },
                    {
                        "username": "NooBaDes",
                        "content": "yes [69,51,7] and [65,59,3] should be running well i am getting output as 2,but it shows expected result as 1..\\n\\n"
                    },
                    {
                        "username": "go_dodgers",
                        "content": "What edge case is the last test case (162) testing? \n `[[634,440,278],[748,509,396],[995,881,251],[704,214,341],[832,972,238],[987,384,156],[378,988,402],[743,557,252],[814,868,196],[131,922,199],[13,398,444],[464,607,241],[426,128,81]]` \nI pass every case except this one... and not due to a timeout or anything. I actually get the wrong answer. (Expected 12, I get 10)"
                    },
                    {
                        "username": "Bitterswit",
                        "content": "Me too. Can\\'t figure out."
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "Don't know how I feel about these more math heavy questions. On it's own without the distance formula it's a solid medium LC question on par with other graph traversal questions on the site. The requirement to also derive the distance formula puts this in a hard. \n\nEven if you were familiar with graphs and how to build the adjacency lists to traverse them unless the interviewer gives you the formula to calculate the distance I don't know if you're just going to rediscover it on your own in an interview environment. "
                    },
                    {
                        "username": "vijaysince89",
                        "content": "Last test case is not working. They are giving Empty bombs and the program just hangs. Any one facing similar issue ?"
                    },
                    {
                        "username": "sanjusabu066",
                        "content": "[[85024,58997,3532],[65196,42043,9739],[85872,75029,3117],[73014,91183,7092],[29098,40864,7624],[11469,13607,4315],[98722,69681,9656],[75140,42250,421],[92580,44040,4779],[58474,78273,1047],[27683,4203,6186],[10714,24238,6243],[60138,81791,3496],[16227,92418,5622],[60496,64917,2463],[59241,62074,885],[11961,163,5815],[37757,43214,3402],[21094,98519,1678],[49368,22385,1431],[6343,53798,159],[80129,9282,5139],[69565,32036,6827],[59372,64978,6575],[44948,71199,7095],[46390,91701,1667],[37144,98691,8128],[13558,81505,4653],[41234,48161,9304],[14852,3206,5369]]\\nFor all those java peeps getting an error in this test case it is due to the distance exceeding the INT_MAX value.\\nUse this while calculating distance.\\n                double dx= bomb[j][0] -bomb[i][0];\\n                double dy= bomb[j][1] -bomb[i][1];\\n\\n                double d =  Math.sqrt(dx*dx + dy*dy);"
                    },
                    {
                        "username": "sanjusabu066",
                        "content": "[@Suyash_Rajput](/Suyash_Rajput) Happy to help ;)"
                    },
                    {
                        "username": "Suyash_Rajput",
                        "content": "bro you saved me\\n"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "For Those who Thought DSU (Union Find) Approach for this Question. It will not work here bcoz the bombing here represents Directed Graph , and UNION FIND works for Undirected Graph. \\nConsidering DSU approach may create conflict whether the Bomb chain would propogate thoroughly or not.\\nConsider the scenario of TC 1. Bomb B can detonate bomb A, but bomb A cannot Detonate bomb B. Thus, it depicts the Directional Nature of Edges.\\nB -> A ( True ) ( 2 Explosion )\\nbut \\nA -> B ( Only 1 Explosion ) "
                    }
                ]
            },
            {
                "id": 2010166,
                "content": [
                    {
                        "username": "Sid_2027",
                        "content": "The solution treats bombs as nodes in a directed graph. If a bomb lies within another bomb\\'s range, it forms a directed edge. The adjacency list represents this graph. DFS is used to traverse and count bombs in each component. A separate visited array ensures accurate counting within each component. The solution finds the maximum number of detonatable bombs by iterating over components and performing DFS."
                    },
                    {
                        "username": "psionl0",
                        "content": "It\\'s as if you read my solution! :D\\n\\nSeriously though, this is an excellent description of how to approach the solution."
                    },
                    {
                        "username": "2106_ayush_2003",
                        "content": "Another example which proves that LEETCODE should describe problem statement more clear."
                    },
                    {
                        "username": "Arana",
                        "content": "This is a very good question for practicing DFS/BFS in graphs. Highly recommended!"
                    },
                    {
                        "username": "devle79",
                        "content": "No. I\\'ll choose love and peace."
                    },
                    {
                        "username": "anandnit",
                        "content": "[[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]...why this is not running ?? \\nLeetcode s**ks"
                    },
                    {
                        "username": "NooBaDes",
                        "content": "yes [69,51,7] and [65,59,3] should be running well i am getting output as 2,but it shows expected result as 1..\\n\\n"
                    },
                    {
                        "username": "go_dodgers",
                        "content": "What edge case is the last test case (162) testing? \n `[[634,440,278],[748,509,396],[995,881,251],[704,214,341],[832,972,238],[987,384,156],[378,988,402],[743,557,252],[814,868,196],[131,922,199],[13,398,444],[464,607,241],[426,128,81]]` \nI pass every case except this one... and not due to a timeout or anything. I actually get the wrong answer. (Expected 12, I get 10)"
                    },
                    {
                        "username": "Bitterswit",
                        "content": "Me too. Can\\'t figure out."
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "Don't know how I feel about these more math heavy questions. On it's own without the distance formula it's a solid medium LC question on par with other graph traversal questions on the site. The requirement to also derive the distance formula puts this in a hard. \n\nEven if you were familiar with graphs and how to build the adjacency lists to traverse them unless the interviewer gives you the formula to calculate the distance I don't know if you're just going to rediscover it on your own in an interview environment. "
                    },
                    {
                        "username": "vijaysince89",
                        "content": "Last test case is not working. They are giving Empty bombs and the program just hangs. Any one facing similar issue ?"
                    },
                    {
                        "username": "sanjusabu066",
                        "content": "[[85024,58997,3532],[65196,42043,9739],[85872,75029,3117],[73014,91183,7092],[29098,40864,7624],[11469,13607,4315],[98722,69681,9656],[75140,42250,421],[92580,44040,4779],[58474,78273,1047],[27683,4203,6186],[10714,24238,6243],[60138,81791,3496],[16227,92418,5622],[60496,64917,2463],[59241,62074,885],[11961,163,5815],[37757,43214,3402],[21094,98519,1678],[49368,22385,1431],[6343,53798,159],[80129,9282,5139],[69565,32036,6827],[59372,64978,6575],[44948,71199,7095],[46390,91701,1667],[37144,98691,8128],[13558,81505,4653],[41234,48161,9304],[14852,3206,5369]]\\nFor all those java peeps getting an error in this test case it is due to the distance exceeding the INT_MAX value.\\nUse this while calculating distance.\\n                double dx= bomb[j][0] -bomb[i][0];\\n                double dy= bomb[j][1] -bomb[i][1];\\n\\n                double d =  Math.sqrt(dx*dx + dy*dy);"
                    },
                    {
                        "username": "sanjusabu066",
                        "content": "[@Suyash_Rajput](/Suyash_Rajput) Happy to help ;)"
                    },
                    {
                        "username": "Suyash_Rajput",
                        "content": "bro you saved me\\n"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "For Those who Thought DSU (Union Find) Approach for this Question. It will not work here bcoz the bombing here represents Directed Graph , and UNION FIND works for Undirected Graph. \\nConsidering DSU approach may create conflict whether the Bomb chain would propogate thoroughly or not.\\nConsider the scenario of TC 1. Bomb B can detonate bomb A, but bomb A cannot Detonate bomb B. Thus, it depicts the Directional Nature of Edges.\\nB -> A ( True ) ( 2 Explosion )\\nbut \\nA -> B ( Only 1 Explosion ) "
                    }
                ]
            },
            {
                "id": 1998997,
                "content": [
                    {
                        "username": "Sid_2027",
                        "content": "The solution treats bombs as nodes in a directed graph. If a bomb lies within another bomb\\'s range, it forms a directed edge. The adjacency list represents this graph. DFS is used to traverse and count bombs in each component. A separate visited array ensures accurate counting within each component. The solution finds the maximum number of detonatable bombs by iterating over components and performing DFS."
                    },
                    {
                        "username": "psionl0",
                        "content": "It\\'s as if you read my solution! :D\\n\\nSeriously though, this is an excellent description of how to approach the solution."
                    },
                    {
                        "username": "2106_ayush_2003",
                        "content": "Another example which proves that LEETCODE should describe problem statement more clear."
                    },
                    {
                        "username": "Arana",
                        "content": "This is a very good question for practicing DFS/BFS in graphs. Highly recommended!"
                    },
                    {
                        "username": "devle79",
                        "content": "No. I\\'ll choose love and peace."
                    },
                    {
                        "username": "anandnit",
                        "content": "[[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]...why this is not running ?? \\nLeetcode s**ks"
                    },
                    {
                        "username": "NooBaDes",
                        "content": "yes [69,51,7] and [65,59,3] should be running well i am getting output as 2,but it shows expected result as 1..\\n\\n"
                    },
                    {
                        "username": "go_dodgers",
                        "content": "What edge case is the last test case (162) testing? \n `[[634,440,278],[748,509,396],[995,881,251],[704,214,341],[832,972,238],[987,384,156],[378,988,402],[743,557,252],[814,868,196],[131,922,199],[13,398,444],[464,607,241],[426,128,81]]` \nI pass every case except this one... and not due to a timeout or anything. I actually get the wrong answer. (Expected 12, I get 10)"
                    },
                    {
                        "username": "Bitterswit",
                        "content": "Me too. Can\\'t figure out."
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "Don't know how I feel about these more math heavy questions. On it's own without the distance formula it's a solid medium LC question on par with other graph traversal questions on the site. The requirement to also derive the distance formula puts this in a hard. \n\nEven if you were familiar with graphs and how to build the adjacency lists to traverse them unless the interviewer gives you the formula to calculate the distance I don't know if you're just going to rediscover it on your own in an interview environment. "
                    },
                    {
                        "username": "vijaysince89",
                        "content": "Last test case is not working. They are giving Empty bombs and the program just hangs. Any one facing similar issue ?"
                    },
                    {
                        "username": "sanjusabu066",
                        "content": "[[85024,58997,3532],[65196,42043,9739],[85872,75029,3117],[73014,91183,7092],[29098,40864,7624],[11469,13607,4315],[98722,69681,9656],[75140,42250,421],[92580,44040,4779],[58474,78273,1047],[27683,4203,6186],[10714,24238,6243],[60138,81791,3496],[16227,92418,5622],[60496,64917,2463],[59241,62074,885],[11961,163,5815],[37757,43214,3402],[21094,98519,1678],[49368,22385,1431],[6343,53798,159],[80129,9282,5139],[69565,32036,6827],[59372,64978,6575],[44948,71199,7095],[46390,91701,1667],[37144,98691,8128],[13558,81505,4653],[41234,48161,9304],[14852,3206,5369]]\\nFor all those java peeps getting an error in this test case it is due to the distance exceeding the INT_MAX value.\\nUse this while calculating distance.\\n                double dx= bomb[j][0] -bomb[i][0];\\n                double dy= bomb[j][1] -bomb[i][1];\\n\\n                double d =  Math.sqrt(dx*dx + dy*dy);"
                    },
                    {
                        "username": "sanjusabu066",
                        "content": "[@Suyash_Rajput](/Suyash_Rajput) Happy to help ;)"
                    },
                    {
                        "username": "Suyash_Rajput",
                        "content": "bro you saved me\\n"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "For Those who Thought DSU (Union Find) Approach for this Question. It will not work here bcoz the bombing here represents Directed Graph , and UNION FIND works for Undirected Graph. \\nConsidering DSU approach may create conflict whether the Bomb chain would propogate thoroughly or not.\\nConsider the scenario of TC 1. Bomb B can detonate bomb A, but bomb A cannot Detonate bomb B. Thus, it depicts the Directional Nature of Edges.\\nB -> A ( True ) ( 2 Explosion )\\nbut \\nA -> B ( Only 1 Explosion ) "
                    }
                ]
            },
            {
                "id": 1975246,
                "content": [
                    {
                        "username": "Sid_2027",
                        "content": "The solution treats bombs as nodes in a directed graph. If a bomb lies within another bomb\\'s range, it forms a directed edge. The adjacency list represents this graph. DFS is used to traverse and count bombs in each component. A separate visited array ensures accurate counting within each component. The solution finds the maximum number of detonatable bombs by iterating over components and performing DFS."
                    },
                    {
                        "username": "psionl0",
                        "content": "It\\'s as if you read my solution! :D\\n\\nSeriously though, this is an excellent description of how to approach the solution."
                    },
                    {
                        "username": "2106_ayush_2003",
                        "content": "Another example which proves that LEETCODE should describe problem statement more clear."
                    },
                    {
                        "username": "Arana",
                        "content": "This is a very good question for practicing DFS/BFS in graphs. Highly recommended!"
                    },
                    {
                        "username": "devle79",
                        "content": "No. I\\'ll choose love and peace."
                    },
                    {
                        "username": "anandnit",
                        "content": "[[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]...why this is not running ?? \\nLeetcode s**ks"
                    },
                    {
                        "username": "NooBaDes",
                        "content": "yes [69,51,7] and [65,59,3] should be running well i am getting output as 2,but it shows expected result as 1..\\n\\n"
                    },
                    {
                        "username": "go_dodgers",
                        "content": "What edge case is the last test case (162) testing? \n `[[634,440,278],[748,509,396],[995,881,251],[704,214,341],[832,972,238],[987,384,156],[378,988,402],[743,557,252],[814,868,196],[131,922,199],[13,398,444],[464,607,241],[426,128,81]]` \nI pass every case except this one... and not due to a timeout or anything. I actually get the wrong answer. (Expected 12, I get 10)"
                    },
                    {
                        "username": "Bitterswit",
                        "content": "Me too. Can\\'t figure out."
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "Don't know how I feel about these more math heavy questions. On it's own without the distance formula it's a solid medium LC question on par with other graph traversal questions on the site. The requirement to also derive the distance formula puts this in a hard. \n\nEven if you were familiar with graphs and how to build the adjacency lists to traverse them unless the interviewer gives you the formula to calculate the distance I don't know if you're just going to rediscover it on your own in an interview environment. "
                    },
                    {
                        "username": "vijaysince89",
                        "content": "Last test case is not working. They are giving Empty bombs and the program just hangs. Any one facing similar issue ?"
                    },
                    {
                        "username": "sanjusabu066",
                        "content": "[[85024,58997,3532],[65196,42043,9739],[85872,75029,3117],[73014,91183,7092],[29098,40864,7624],[11469,13607,4315],[98722,69681,9656],[75140,42250,421],[92580,44040,4779],[58474,78273,1047],[27683,4203,6186],[10714,24238,6243],[60138,81791,3496],[16227,92418,5622],[60496,64917,2463],[59241,62074,885],[11961,163,5815],[37757,43214,3402],[21094,98519,1678],[49368,22385,1431],[6343,53798,159],[80129,9282,5139],[69565,32036,6827],[59372,64978,6575],[44948,71199,7095],[46390,91701,1667],[37144,98691,8128],[13558,81505,4653],[41234,48161,9304],[14852,3206,5369]]\\nFor all those java peeps getting an error in this test case it is due to the distance exceeding the INT_MAX value.\\nUse this while calculating distance.\\n                double dx= bomb[j][0] -bomb[i][0];\\n                double dy= bomb[j][1] -bomb[i][1];\\n\\n                double d =  Math.sqrt(dx*dx + dy*dy);"
                    },
                    {
                        "username": "sanjusabu066",
                        "content": "[@Suyash_Rajput](/Suyash_Rajput) Happy to help ;)"
                    },
                    {
                        "username": "Suyash_Rajput",
                        "content": "bro you saved me\\n"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "For Those who Thought DSU (Union Find) Approach for this Question. It will not work here bcoz the bombing here represents Directed Graph , and UNION FIND works for Undirected Graph. \\nConsidering DSU approach may create conflict whether the Bomb chain would propogate thoroughly or not.\\nConsider the scenario of TC 1. Bomb B can detonate bomb A, but bomb A cannot Detonate bomb B. Thus, it depicts the Directional Nature of Edges.\\nB -> A ( True ) ( 2 Explosion )\\nbut \\nA -> B ( Only 1 Explosion ) "
                    }
                ]
            },
            {
                "id": 1914671,
                "content": [
                    {
                        "username": "Sid_2027",
                        "content": "The solution treats bombs as nodes in a directed graph. If a bomb lies within another bomb\\'s range, it forms a directed edge. The adjacency list represents this graph. DFS is used to traverse and count bombs in each component. A separate visited array ensures accurate counting within each component. The solution finds the maximum number of detonatable bombs by iterating over components and performing DFS."
                    },
                    {
                        "username": "psionl0",
                        "content": "It\\'s as if you read my solution! :D\\n\\nSeriously though, this is an excellent description of how to approach the solution."
                    },
                    {
                        "username": "2106_ayush_2003",
                        "content": "Another example which proves that LEETCODE should describe problem statement more clear."
                    },
                    {
                        "username": "Arana",
                        "content": "This is a very good question for practicing DFS/BFS in graphs. Highly recommended!"
                    },
                    {
                        "username": "devle79",
                        "content": "No. I\\'ll choose love and peace."
                    },
                    {
                        "username": "anandnit",
                        "content": "[[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]...why this is not running ?? \\nLeetcode s**ks"
                    },
                    {
                        "username": "NooBaDes",
                        "content": "yes [69,51,7] and [65,59,3] should be running well i am getting output as 2,but it shows expected result as 1..\\n\\n"
                    },
                    {
                        "username": "go_dodgers",
                        "content": "What edge case is the last test case (162) testing? \n `[[634,440,278],[748,509,396],[995,881,251],[704,214,341],[832,972,238],[987,384,156],[378,988,402],[743,557,252],[814,868,196],[131,922,199],[13,398,444],[464,607,241],[426,128,81]]` \nI pass every case except this one... and not due to a timeout or anything. I actually get the wrong answer. (Expected 12, I get 10)"
                    },
                    {
                        "username": "Bitterswit",
                        "content": "Me too. Can\\'t figure out."
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "Don't know how I feel about these more math heavy questions. On it's own without the distance formula it's a solid medium LC question on par with other graph traversal questions on the site. The requirement to also derive the distance formula puts this in a hard. \n\nEven if you were familiar with graphs and how to build the adjacency lists to traverse them unless the interviewer gives you the formula to calculate the distance I don't know if you're just going to rediscover it on your own in an interview environment. "
                    },
                    {
                        "username": "vijaysince89",
                        "content": "Last test case is not working. They are giving Empty bombs and the program just hangs. Any one facing similar issue ?"
                    },
                    {
                        "username": "sanjusabu066",
                        "content": "[[85024,58997,3532],[65196,42043,9739],[85872,75029,3117],[73014,91183,7092],[29098,40864,7624],[11469,13607,4315],[98722,69681,9656],[75140,42250,421],[92580,44040,4779],[58474,78273,1047],[27683,4203,6186],[10714,24238,6243],[60138,81791,3496],[16227,92418,5622],[60496,64917,2463],[59241,62074,885],[11961,163,5815],[37757,43214,3402],[21094,98519,1678],[49368,22385,1431],[6343,53798,159],[80129,9282,5139],[69565,32036,6827],[59372,64978,6575],[44948,71199,7095],[46390,91701,1667],[37144,98691,8128],[13558,81505,4653],[41234,48161,9304],[14852,3206,5369]]\\nFor all those java peeps getting an error in this test case it is due to the distance exceeding the INT_MAX value.\\nUse this while calculating distance.\\n                double dx= bomb[j][0] -bomb[i][0];\\n                double dy= bomb[j][1] -bomb[i][1];\\n\\n                double d =  Math.sqrt(dx*dx + dy*dy);"
                    },
                    {
                        "username": "sanjusabu066",
                        "content": "[@Suyash_Rajput](/Suyash_Rajput) Happy to help ;)"
                    },
                    {
                        "username": "Suyash_Rajput",
                        "content": "bro you saved me\\n"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "For Those who Thought DSU (Union Find) Approach for this Question. It will not work here bcoz the bombing here represents Directed Graph , and UNION FIND works for Undirected Graph. \\nConsidering DSU approach may create conflict whether the Bomb chain would propogate thoroughly or not.\\nConsider the scenario of TC 1. Bomb B can detonate bomb A, but bomb A cannot Detonate bomb B. Thus, it depicts the Directional Nature of Edges.\\nB -> A ( True ) ( 2 Explosion )\\nbut \\nA -> B ( Only 1 Explosion ) "
                    }
                ]
            },
            {
                "id": 1914174,
                "content": [
                    {
                        "username": "Sid_2027",
                        "content": "The solution treats bombs as nodes in a directed graph. If a bomb lies within another bomb\\'s range, it forms a directed edge. The adjacency list represents this graph. DFS is used to traverse and count bombs in each component. A separate visited array ensures accurate counting within each component. The solution finds the maximum number of detonatable bombs by iterating over components and performing DFS."
                    },
                    {
                        "username": "psionl0",
                        "content": "It\\'s as if you read my solution! :D\\n\\nSeriously though, this is an excellent description of how to approach the solution."
                    },
                    {
                        "username": "2106_ayush_2003",
                        "content": "Another example which proves that LEETCODE should describe problem statement more clear."
                    },
                    {
                        "username": "Arana",
                        "content": "This is a very good question for practicing DFS/BFS in graphs. Highly recommended!"
                    },
                    {
                        "username": "devle79",
                        "content": "No. I\\'ll choose love and peace."
                    },
                    {
                        "username": "anandnit",
                        "content": "[[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]...why this is not running ?? \\nLeetcode s**ks"
                    },
                    {
                        "username": "NooBaDes",
                        "content": "yes [69,51,7] and [65,59,3] should be running well i am getting output as 2,but it shows expected result as 1..\\n\\n"
                    },
                    {
                        "username": "go_dodgers",
                        "content": "What edge case is the last test case (162) testing? \n `[[634,440,278],[748,509,396],[995,881,251],[704,214,341],[832,972,238],[987,384,156],[378,988,402],[743,557,252],[814,868,196],[131,922,199],[13,398,444],[464,607,241],[426,128,81]]` \nI pass every case except this one... and not due to a timeout or anything. I actually get the wrong answer. (Expected 12, I get 10)"
                    },
                    {
                        "username": "Bitterswit",
                        "content": "Me too. Can\\'t figure out."
                    },
                    {
                        "username": "CaptainKidd",
                        "content": "Don't know how I feel about these more math heavy questions. On it's own without the distance formula it's a solid medium LC question on par with other graph traversal questions on the site. The requirement to also derive the distance formula puts this in a hard. \n\nEven if you were familiar with graphs and how to build the adjacency lists to traverse them unless the interviewer gives you the formula to calculate the distance I don't know if you're just going to rediscover it on your own in an interview environment. "
                    },
                    {
                        "username": "vijaysince89",
                        "content": "Last test case is not working. They are giving Empty bombs and the program just hangs. Any one facing similar issue ?"
                    },
                    {
                        "username": "sanjusabu066",
                        "content": "[[85024,58997,3532],[65196,42043,9739],[85872,75029,3117],[73014,91183,7092],[29098,40864,7624],[11469,13607,4315],[98722,69681,9656],[75140,42250,421],[92580,44040,4779],[58474,78273,1047],[27683,4203,6186],[10714,24238,6243],[60138,81791,3496],[16227,92418,5622],[60496,64917,2463],[59241,62074,885],[11961,163,5815],[37757,43214,3402],[21094,98519,1678],[49368,22385,1431],[6343,53798,159],[80129,9282,5139],[69565,32036,6827],[59372,64978,6575],[44948,71199,7095],[46390,91701,1667],[37144,98691,8128],[13558,81505,4653],[41234,48161,9304],[14852,3206,5369]]\\nFor all those java peeps getting an error in this test case it is due to the distance exceeding the INT_MAX value.\\nUse this while calculating distance.\\n                double dx= bomb[j][0] -bomb[i][0];\\n                double dy= bomb[j][1] -bomb[i][1];\\n\\n                double d =  Math.sqrt(dx*dx + dy*dy);"
                    },
                    {
                        "username": "sanjusabu066",
                        "content": "[@Suyash_Rajput](/Suyash_Rajput) Happy to help ;)"
                    },
                    {
                        "username": "Suyash_Rajput",
                        "content": "bro you saved me\\n"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "For Those who Thought DSU (Union Find) Approach for this Question. It will not work here bcoz the bombing here represents Directed Graph , and UNION FIND works for Undirected Graph. \\nConsidering DSU approach may create conflict whether the Bomb chain would propogate thoroughly or not.\\nConsider the scenario of TC 1. Bomb B can detonate bomb A, but bomb A cannot Detonate bomb B. Thus, it depicts the Directional Nature of Edges.\\nB -> A ( True ) ( 2 Explosion )\\nbut \\nA -> B ( Only 1 Explosion ) "
                    }
                ]
            },
            {
                "id": 1914042,
                "content": [
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Leetcode giving us signs...."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[[647,457,91],[483,716,37],[426,119,35],[355,588,40],[850,874,49],[232,568,46],[886,1,30],[54,377,3],[933,986,50],[305,790,49],[372,961,67],[671,314,58],[577,221,29],[380,147,91],[600,535,1],[806,329,64],[536,753,18],[906,88,23],[436,783,82],[652,674,45],[449,668,20],[419,13,66],[853,767,60],[169,288,33],[871,608,66],[337,445,35],[388,623,39],[723,503,81],[14,19,19],[98,648,72],[147,565,93],[655,434,1],[407,663,22],[805,947,83],[942,160,70],[959,496,93],[30,988,53],[187,849,60],[980,483,41],[663,150,76],[268,39,50],[513,522,75],[61,450,90],[115,231,12],[346,304,74],[385,540,23],[905,178,19],[336,896,81],[751,811,94],[527,783,78],[635,965,19],[334,290,39],[748,460,77],[414,134,22],[955,485,29],[925,787,43],[243,771,75],[675,223,29],[788,618,82],[462,544,30],[999,259,50],[210,146,12],[789,442,70],[286,36,55],[451,953,6],[719,914,14],[664,452,14],[933,637,29],[206,926,16],[100,422,98],[97,333,4],[505,631,26],[908,287,65],[907,316,86],[949,185,16],[639,735,62],[401,739,18],[605,926,21],[25,391,69],[80,24,9],[435,874,92],[940,381,18],[260,740,87],[727,515,17],[361,152,16],[512,470,67],[189,27,27],[517,439,94],[159,543,76],[373,698,38],[781,836,97],[584,190,23],[383,367,86],[825,141,63],[117,926,85],[169,588,60],[56,981,100],[294,716,100],[781,370,89],[373,44,78]]\\n\\nFor this test case , I am getting 8 as output . But expected is 7. \\n\\naccording to my code by diffusing bomb 0, \\n0, 14, 27, 31, 52, 62, 66, 83 are diffused. \\n\\nCan anyone explain ?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@omgupta20382038](/omgupta20382038)  Working now!"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "[@_aka5h](/_aka5h) ha itne saare"
                    },
                    {
                        "username": "omgupta20382038",
                        "content": "I had the same problem, if you are using the sqrt function then dont,  try to write it differently: distance = (x2-x1)*(x2-x1)+(y2-y1)*(y2-y1); and check if distance <= radius*radius"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Dry run the testcase"
                    },
                    {
                        "username": "at218808",
                        "content": "[[656,619,56],[189,402,178],[513,373,276],[900,510,14],[188,173,129],[512,178,251],[145,685,47],[504,355,500],[554,131,214],[596,1,98],[358,230,197],[88,758,155],[72,340,419],[818,708,222]]\\n\\nmine output is 8 but expected is 14, i dont understand the problem , i am calculating distances between two \\nbombs and if there they lie in range then  i am putting them into same group."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "input : [[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]\\nOutput : 2\\nExpect : 1\\n---\\n\\nI see that bombs[7] = [69, 51, 7] and bombs[12] = [65, 59, 3], distance between these two is 8.944... and r1 + r2 = 7 + 3 = 10;\\nso when we detonate one of them, the other will explode too, right?\\n\\nIs the question wrong?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Hey, I had the same problem earlier. The catch is the center of the second bomb should be in the range of the first bomb. \\nhere 8.944 > 7 which means the second bomb will not be diffused. \\n\\nHope this helps!!"
                    },
                    {
                        "username": "ayush81029",
                        "content": "Trick is that center of one bomb should be in the range of another bomb. I think you are including all those cases where range of two bombs are overlapping but you have to include those cases where center of one bomb is lying in the range of another bomb. It will be like a directed graph because if bomb A is in range of bomb B this doesn\\'t imply that bomb B will be in range of bomb A. \\nYou can understand this with an example. Let we have two bombs [[3,3,3],[8,3,3]]. In this both bomb range are overlapping but their centers are not in range of each other. So, for this case answer will be 1.  "
                    },
                    {
                        "username": "anwendeng",
                        "content": "There is no adjacent  bomb!\nadj lists:\n0:[]\n1:[]\n2:[]\n3:[]\n4:[]\n5:[]\n6:[]\n7:[]\n8:[]\n9:[]\n10:[]\n11:[]\n12:[]\n13:[]\n14:[]\n15:[]\n16:[]"
                    },
                    {
                        "username": "psionl0",
                        "content": "Just because the ranges overlap doesn\\'t mean that the distance between the bombs is within the range of either one of them."
                    },
                    {
                        "username": "Jahongirhacking",
                        "content": "Why are you adding r1 and r2?"
                    },
                    {
                        "username": "vidhibansal1997",
                        "content": "Shouldn\\'t 2 be the answer for this test case : [[1,1,100000],[100000, 100000, 1]] ?\\n(1,1) detonates itself & then (100000, 100000). \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "Check this, you can understand easily : https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588930/1-1-100000-100000-100000-1-getting-wrong-understand-why/"
                    },
                    {
                        "username": "psionl0",
                        "content": "the distance between (1,1) and (100000,100000) is 141420 which is beyond the range of the bomb at (1,1)."
                    },
                    {
                        "username": "banaren",
                        "content": "I expect the answer for this to be 4 not 5\\n[[1,2,3],[2,3,1],[3,4,2],[4,5,3],[5,6,4]]\\n\\nCan anyone explain why ?\\n\\nI have attached a graph. I see a maximum of 4 circles for [4,5,3]\\n![image](https://assets.leetcode.com/users/images/b1ec4c80-e4b2-4fe3-9892-00a7427fc19f_1639258822.7928765.png)\\n"
                    },
                    {
                        "username": "ayush81029",
                        "content": "Trick is that center of one bomb should be in the range of another bomb. I think you are including all those cases where range of two bombs are overlapping but you have to include those cases where center of one bomb is lying in the range of another bomb. It will be like a directed graph because if bomb A is in range of bomb B this doesn\\'t imply that bomb B will be in range of bomb A. \\nYou can understand this with an example. Let we have two bombs [[3,3,3],[8,3,3]]. In this both bomb range are overlapping but their centers are not in range of each other. So, for this case answer will be 1.  \\n\\nSo, in the above case left most bomb will not be detonated. "
                    },
                    {
                        "username": "RomanCastellarin",
                        "content": "Detonate the blue bomb. It will detonate Green and Purple.\\nPurple will detonate Black and Black will detonate Red.\\nAnswer is 5"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Bombs can detonate each other. Bomb A can detonate bomb B, which detonates C, and so forth."
                    },
                    {
                        "username": "aishu8333",
                        "content": "how can the interviewer expect that candidate knows finding whether circles intersect or not. I mean the formula, its more of Maths . For me the most difficult is finding that formula ."
                    },
                    {
                        "username": "JustinLiang522",
                        "content": "Who would put two bombs in exactly the same position???"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I was dumbfounded until I read the hint saying that we can represent the data by graphs. It became so simple then. This is a good question\n\nP.S: This is my 300th problem :)"
                    },
                    {
                        "username": "NandhakumarThyiagarajan",
                        "content": "[[1,1,100000],[100000,100000,1]]  \\nCan anyone give ans to above one ?\\nI got the ans as 2 as 1st bomb covers range of bomb 2 in x and y axis\\nBut leetcode ans is 1\\n\\nAny idea about it ?\\n"
                    },
                    {
                        "username": "sandyy",
                        "content": "Use long for distance calculation. It\\'s giving wrong results due to integer overflow"
                    }
                ]
            },
            {
                "id": 1913848,
                "content": [
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Leetcode giving us signs...."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[[647,457,91],[483,716,37],[426,119,35],[355,588,40],[850,874,49],[232,568,46],[886,1,30],[54,377,3],[933,986,50],[305,790,49],[372,961,67],[671,314,58],[577,221,29],[380,147,91],[600,535,1],[806,329,64],[536,753,18],[906,88,23],[436,783,82],[652,674,45],[449,668,20],[419,13,66],[853,767,60],[169,288,33],[871,608,66],[337,445,35],[388,623,39],[723,503,81],[14,19,19],[98,648,72],[147,565,93],[655,434,1],[407,663,22],[805,947,83],[942,160,70],[959,496,93],[30,988,53],[187,849,60],[980,483,41],[663,150,76],[268,39,50],[513,522,75],[61,450,90],[115,231,12],[346,304,74],[385,540,23],[905,178,19],[336,896,81],[751,811,94],[527,783,78],[635,965,19],[334,290,39],[748,460,77],[414,134,22],[955,485,29],[925,787,43],[243,771,75],[675,223,29],[788,618,82],[462,544,30],[999,259,50],[210,146,12],[789,442,70],[286,36,55],[451,953,6],[719,914,14],[664,452,14],[933,637,29],[206,926,16],[100,422,98],[97,333,4],[505,631,26],[908,287,65],[907,316,86],[949,185,16],[639,735,62],[401,739,18],[605,926,21],[25,391,69],[80,24,9],[435,874,92],[940,381,18],[260,740,87],[727,515,17],[361,152,16],[512,470,67],[189,27,27],[517,439,94],[159,543,76],[373,698,38],[781,836,97],[584,190,23],[383,367,86],[825,141,63],[117,926,85],[169,588,60],[56,981,100],[294,716,100],[781,370,89],[373,44,78]]\\n\\nFor this test case , I am getting 8 as output . But expected is 7. \\n\\naccording to my code by diffusing bomb 0, \\n0, 14, 27, 31, 52, 62, 66, 83 are diffused. \\n\\nCan anyone explain ?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@omgupta20382038](/omgupta20382038)  Working now!"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "[@_aka5h](/_aka5h) ha itne saare"
                    },
                    {
                        "username": "omgupta20382038",
                        "content": "I had the same problem, if you are using the sqrt function then dont,  try to write it differently: distance = (x2-x1)*(x2-x1)+(y2-y1)*(y2-y1); and check if distance <= radius*radius"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Dry run the testcase"
                    },
                    {
                        "username": "at218808",
                        "content": "[[656,619,56],[189,402,178],[513,373,276],[900,510,14],[188,173,129],[512,178,251],[145,685,47],[504,355,500],[554,131,214],[596,1,98],[358,230,197],[88,758,155],[72,340,419],[818,708,222]]\\n\\nmine output is 8 but expected is 14, i dont understand the problem , i am calculating distances between two \\nbombs and if there they lie in range then  i am putting them into same group."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "input : [[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]\\nOutput : 2\\nExpect : 1\\n---\\n\\nI see that bombs[7] = [69, 51, 7] and bombs[12] = [65, 59, 3], distance between these two is 8.944... and r1 + r2 = 7 + 3 = 10;\\nso when we detonate one of them, the other will explode too, right?\\n\\nIs the question wrong?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Hey, I had the same problem earlier. The catch is the center of the second bomb should be in the range of the first bomb. \\nhere 8.944 > 7 which means the second bomb will not be diffused. \\n\\nHope this helps!!"
                    },
                    {
                        "username": "ayush81029",
                        "content": "Trick is that center of one bomb should be in the range of another bomb. I think you are including all those cases where range of two bombs are overlapping but you have to include those cases where center of one bomb is lying in the range of another bomb. It will be like a directed graph because if bomb A is in range of bomb B this doesn\\'t imply that bomb B will be in range of bomb A. \\nYou can understand this with an example. Let we have two bombs [[3,3,3],[8,3,3]]. In this both bomb range are overlapping but their centers are not in range of each other. So, for this case answer will be 1.  "
                    },
                    {
                        "username": "anwendeng",
                        "content": "There is no adjacent  bomb!\nadj lists:\n0:[]\n1:[]\n2:[]\n3:[]\n4:[]\n5:[]\n6:[]\n7:[]\n8:[]\n9:[]\n10:[]\n11:[]\n12:[]\n13:[]\n14:[]\n15:[]\n16:[]"
                    },
                    {
                        "username": "psionl0",
                        "content": "Just because the ranges overlap doesn\\'t mean that the distance between the bombs is within the range of either one of them."
                    },
                    {
                        "username": "Jahongirhacking",
                        "content": "Why are you adding r1 and r2?"
                    },
                    {
                        "username": "vidhibansal1997",
                        "content": "Shouldn\\'t 2 be the answer for this test case : [[1,1,100000],[100000, 100000, 1]] ?\\n(1,1) detonates itself & then (100000, 100000). \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "Check this, you can understand easily : https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588930/1-1-100000-100000-100000-1-getting-wrong-understand-why/"
                    },
                    {
                        "username": "psionl0",
                        "content": "the distance between (1,1) and (100000,100000) is 141420 which is beyond the range of the bomb at (1,1)."
                    },
                    {
                        "username": "banaren",
                        "content": "I expect the answer for this to be 4 not 5\\n[[1,2,3],[2,3,1],[3,4,2],[4,5,3],[5,6,4]]\\n\\nCan anyone explain why ?\\n\\nI have attached a graph. I see a maximum of 4 circles for [4,5,3]\\n![image](https://assets.leetcode.com/users/images/b1ec4c80-e4b2-4fe3-9892-00a7427fc19f_1639258822.7928765.png)\\n"
                    },
                    {
                        "username": "ayush81029",
                        "content": "Trick is that center of one bomb should be in the range of another bomb. I think you are including all those cases where range of two bombs are overlapping but you have to include those cases where center of one bomb is lying in the range of another bomb. It will be like a directed graph because if bomb A is in range of bomb B this doesn\\'t imply that bomb B will be in range of bomb A. \\nYou can understand this with an example. Let we have two bombs [[3,3,3],[8,3,3]]. In this both bomb range are overlapping but their centers are not in range of each other. So, for this case answer will be 1.  \\n\\nSo, in the above case left most bomb will not be detonated. "
                    },
                    {
                        "username": "RomanCastellarin",
                        "content": "Detonate the blue bomb. It will detonate Green and Purple.\\nPurple will detonate Black and Black will detonate Red.\\nAnswer is 5"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Bombs can detonate each other. Bomb A can detonate bomb B, which detonates C, and so forth."
                    },
                    {
                        "username": "aishu8333",
                        "content": "how can the interviewer expect that candidate knows finding whether circles intersect or not. I mean the formula, its more of Maths . For me the most difficult is finding that formula ."
                    },
                    {
                        "username": "JustinLiang522",
                        "content": "Who would put two bombs in exactly the same position???"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I was dumbfounded until I read the hint saying that we can represent the data by graphs. It became so simple then. This is a good question\n\nP.S: This is my 300th problem :)"
                    },
                    {
                        "username": "NandhakumarThyiagarajan",
                        "content": "[[1,1,100000],[100000,100000,1]]  \\nCan anyone give ans to above one ?\\nI got the ans as 2 as 1st bomb covers range of bomb 2 in x and y axis\\nBut leetcode ans is 1\\n\\nAny idea about it ?\\n"
                    },
                    {
                        "username": "sandyy",
                        "content": "Use long for distance calculation. It\\'s giving wrong results due to integer overflow"
                    }
                ]
            },
            {
                "id": 1913799,
                "content": [
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Leetcode giving us signs...."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[[647,457,91],[483,716,37],[426,119,35],[355,588,40],[850,874,49],[232,568,46],[886,1,30],[54,377,3],[933,986,50],[305,790,49],[372,961,67],[671,314,58],[577,221,29],[380,147,91],[600,535,1],[806,329,64],[536,753,18],[906,88,23],[436,783,82],[652,674,45],[449,668,20],[419,13,66],[853,767,60],[169,288,33],[871,608,66],[337,445,35],[388,623,39],[723,503,81],[14,19,19],[98,648,72],[147,565,93],[655,434,1],[407,663,22],[805,947,83],[942,160,70],[959,496,93],[30,988,53],[187,849,60],[980,483,41],[663,150,76],[268,39,50],[513,522,75],[61,450,90],[115,231,12],[346,304,74],[385,540,23],[905,178,19],[336,896,81],[751,811,94],[527,783,78],[635,965,19],[334,290,39],[748,460,77],[414,134,22],[955,485,29],[925,787,43],[243,771,75],[675,223,29],[788,618,82],[462,544,30],[999,259,50],[210,146,12],[789,442,70],[286,36,55],[451,953,6],[719,914,14],[664,452,14],[933,637,29],[206,926,16],[100,422,98],[97,333,4],[505,631,26],[908,287,65],[907,316,86],[949,185,16],[639,735,62],[401,739,18],[605,926,21],[25,391,69],[80,24,9],[435,874,92],[940,381,18],[260,740,87],[727,515,17],[361,152,16],[512,470,67],[189,27,27],[517,439,94],[159,543,76],[373,698,38],[781,836,97],[584,190,23],[383,367,86],[825,141,63],[117,926,85],[169,588,60],[56,981,100],[294,716,100],[781,370,89],[373,44,78]]\\n\\nFor this test case , I am getting 8 as output . But expected is 7. \\n\\naccording to my code by diffusing bomb 0, \\n0, 14, 27, 31, 52, 62, 66, 83 are diffused. \\n\\nCan anyone explain ?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@omgupta20382038](/omgupta20382038)  Working now!"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "[@_aka5h](/_aka5h) ha itne saare"
                    },
                    {
                        "username": "omgupta20382038",
                        "content": "I had the same problem, if you are using the sqrt function then dont,  try to write it differently: distance = (x2-x1)*(x2-x1)+(y2-y1)*(y2-y1); and check if distance <= radius*radius"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Dry run the testcase"
                    },
                    {
                        "username": "at218808",
                        "content": "[[656,619,56],[189,402,178],[513,373,276],[900,510,14],[188,173,129],[512,178,251],[145,685,47],[504,355,500],[554,131,214],[596,1,98],[358,230,197],[88,758,155],[72,340,419],[818,708,222]]\\n\\nmine output is 8 but expected is 14, i dont understand the problem , i am calculating distances between two \\nbombs and if there they lie in range then  i am putting them into same group."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "input : [[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]\\nOutput : 2\\nExpect : 1\\n---\\n\\nI see that bombs[7] = [69, 51, 7] and bombs[12] = [65, 59, 3], distance between these two is 8.944... and r1 + r2 = 7 + 3 = 10;\\nso when we detonate one of them, the other will explode too, right?\\n\\nIs the question wrong?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Hey, I had the same problem earlier. The catch is the center of the second bomb should be in the range of the first bomb. \\nhere 8.944 > 7 which means the second bomb will not be diffused. \\n\\nHope this helps!!"
                    },
                    {
                        "username": "ayush81029",
                        "content": "Trick is that center of one bomb should be in the range of another bomb. I think you are including all those cases where range of two bombs are overlapping but you have to include those cases where center of one bomb is lying in the range of another bomb. It will be like a directed graph because if bomb A is in range of bomb B this doesn\\'t imply that bomb B will be in range of bomb A. \\nYou can understand this with an example. Let we have two bombs [[3,3,3],[8,3,3]]. In this both bomb range are overlapping but their centers are not in range of each other. So, for this case answer will be 1.  "
                    },
                    {
                        "username": "anwendeng",
                        "content": "There is no adjacent  bomb!\nadj lists:\n0:[]\n1:[]\n2:[]\n3:[]\n4:[]\n5:[]\n6:[]\n7:[]\n8:[]\n9:[]\n10:[]\n11:[]\n12:[]\n13:[]\n14:[]\n15:[]\n16:[]"
                    },
                    {
                        "username": "psionl0",
                        "content": "Just because the ranges overlap doesn\\'t mean that the distance between the bombs is within the range of either one of them."
                    },
                    {
                        "username": "Jahongirhacking",
                        "content": "Why are you adding r1 and r2?"
                    },
                    {
                        "username": "vidhibansal1997",
                        "content": "Shouldn\\'t 2 be the answer for this test case : [[1,1,100000],[100000, 100000, 1]] ?\\n(1,1) detonates itself & then (100000, 100000). \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "Check this, you can understand easily : https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588930/1-1-100000-100000-100000-1-getting-wrong-understand-why/"
                    },
                    {
                        "username": "psionl0",
                        "content": "the distance between (1,1) and (100000,100000) is 141420 which is beyond the range of the bomb at (1,1)."
                    },
                    {
                        "username": "banaren",
                        "content": "I expect the answer for this to be 4 not 5\\n[[1,2,3],[2,3,1],[3,4,2],[4,5,3],[5,6,4]]\\n\\nCan anyone explain why ?\\n\\nI have attached a graph. I see a maximum of 4 circles for [4,5,3]\\n![image](https://assets.leetcode.com/users/images/b1ec4c80-e4b2-4fe3-9892-00a7427fc19f_1639258822.7928765.png)\\n"
                    },
                    {
                        "username": "ayush81029",
                        "content": "Trick is that center of one bomb should be in the range of another bomb. I think you are including all those cases where range of two bombs are overlapping but you have to include those cases where center of one bomb is lying in the range of another bomb. It will be like a directed graph because if bomb A is in range of bomb B this doesn\\'t imply that bomb B will be in range of bomb A. \\nYou can understand this with an example. Let we have two bombs [[3,3,3],[8,3,3]]. In this both bomb range are overlapping but their centers are not in range of each other. So, for this case answer will be 1.  \\n\\nSo, in the above case left most bomb will not be detonated. "
                    },
                    {
                        "username": "RomanCastellarin",
                        "content": "Detonate the blue bomb. It will detonate Green and Purple.\\nPurple will detonate Black and Black will detonate Red.\\nAnswer is 5"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Bombs can detonate each other. Bomb A can detonate bomb B, which detonates C, and so forth."
                    },
                    {
                        "username": "aishu8333",
                        "content": "how can the interviewer expect that candidate knows finding whether circles intersect or not. I mean the formula, its more of Maths . For me the most difficult is finding that formula ."
                    },
                    {
                        "username": "JustinLiang522",
                        "content": "Who would put two bombs in exactly the same position???"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I was dumbfounded until I read the hint saying that we can represent the data by graphs. It became so simple then. This is a good question\n\nP.S: This is my 300th problem :)"
                    },
                    {
                        "username": "NandhakumarThyiagarajan",
                        "content": "[[1,1,100000],[100000,100000,1]]  \\nCan anyone give ans to above one ?\\nI got the ans as 2 as 1st bomb covers range of bomb 2 in x and y axis\\nBut leetcode ans is 1\\n\\nAny idea about it ?\\n"
                    },
                    {
                        "username": "sandyy",
                        "content": "Use long for distance calculation. It\\'s giving wrong results due to integer overflow"
                    }
                ]
            },
            {
                "id": 1803182,
                "content": [
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Leetcode giving us signs...."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[[647,457,91],[483,716,37],[426,119,35],[355,588,40],[850,874,49],[232,568,46],[886,1,30],[54,377,3],[933,986,50],[305,790,49],[372,961,67],[671,314,58],[577,221,29],[380,147,91],[600,535,1],[806,329,64],[536,753,18],[906,88,23],[436,783,82],[652,674,45],[449,668,20],[419,13,66],[853,767,60],[169,288,33],[871,608,66],[337,445,35],[388,623,39],[723,503,81],[14,19,19],[98,648,72],[147,565,93],[655,434,1],[407,663,22],[805,947,83],[942,160,70],[959,496,93],[30,988,53],[187,849,60],[980,483,41],[663,150,76],[268,39,50],[513,522,75],[61,450,90],[115,231,12],[346,304,74],[385,540,23],[905,178,19],[336,896,81],[751,811,94],[527,783,78],[635,965,19],[334,290,39],[748,460,77],[414,134,22],[955,485,29],[925,787,43],[243,771,75],[675,223,29],[788,618,82],[462,544,30],[999,259,50],[210,146,12],[789,442,70],[286,36,55],[451,953,6],[719,914,14],[664,452,14],[933,637,29],[206,926,16],[100,422,98],[97,333,4],[505,631,26],[908,287,65],[907,316,86],[949,185,16],[639,735,62],[401,739,18],[605,926,21],[25,391,69],[80,24,9],[435,874,92],[940,381,18],[260,740,87],[727,515,17],[361,152,16],[512,470,67],[189,27,27],[517,439,94],[159,543,76],[373,698,38],[781,836,97],[584,190,23],[383,367,86],[825,141,63],[117,926,85],[169,588,60],[56,981,100],[294,716,100],[781,370,89],[373,44,78]]\\n\\nFor this test case , I am getting 8 as output . But expected is 7. \\n\\naccording to my code by diffusing bomb 0, \\n0, 14, 27, 31, 52, 62, 66, 83 are diffused. \\n\\nCan anyone explain ?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@omgupta20382038](/omgupta20382038)  Working now!"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "[@_aka5h](/_aka5h) ha itne saare"
                    },
                    {
                        "username": "omgupta20382038",
                        "content": "I had the same problem, if you are using the sqrt function then dont,  try to write it differently: distance = (x2-x1)*(x2-x1)+(y2-y1)*(y2-y1); and check if distance <= radius*radius"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Dry run the testcase"
                    },
                    {
                        "username": "at218808",
                        "content": "[[656,619,56],[189,402,178],[513,373,276],[900,510,14],[188,173,129],[512,178,251],[145,685,47],[504,355,500],[554,131,214],[596,1,98],[358,230,197],[88,758,155],[72,340,419],[818,708,222]]\\n\\nmine output is 8 but expected is 14, i dont understand the problem , i am calculating distances between two \\nbombs and if there they lie in range then  i am putting them into same group."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "input : [[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]\\nOutput : 2\\nExpect : 1\\n---\\n\\nI see that bombs[7] = [69, 51, 7] and bombs[12] = [65, 59, 3], distance between these two is 8.944... and r1 + r2 = 7 + 3 = 10;\\nso when we detonate one of them, the other will explode too, right?\\n\\nIs the question wrong?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Hey, I had the same problem earlier. The catch is the center of the second bomb should be in the range of the first bomb. \\nhere 8.944 > 7 which means the second bomb will not be diffused. \\n\\nHope this helps!!"
                    },
                    {
                        "username": "ayush81029",
                        "content": "Trick is that center of one bomb should be in the range of another bomb. I think you are including all those cases where range of two bombs are overlapping but you have to include those cases where center of one bomb is lying in the range of another bomb. It will be like a directed graph because if bomb A is in range of bomb B this doesn\\'t imply that bomb B will be in range of bomb A. \\nYou can understand this with an example. Let we have two bombs [[3,3,3],[8,3,3]]. In this both bomb range are overlapping but their centers are not in range of each other. So, for this case answer will be 1.  "
                    },
                    {
                        "username": "anwendeng",
                        "content": "There is no adjacent  bomb!\nadj lists:\n0:[]\n1:[]\n2:[]\n3:[]\n4:[]\n5:[]\n6:[]\n7:[]\n8:[]\n9:[]\n10:[]\n11:[]\n12:[]\n13:[]\n14:[]\n15:[]\n16:[]"
                    },
                    {
                        "username": "psionl0",
                        "content": "Just because the ranges overlap doesn\\'t mean that the distance between the bombs is within the range of either one of them."
                    },
                    {
                        "username": "Jahongirhacking",
                        "content": "Why are you adding r1 and r2?"
                    },
                    {
                        "username": "vidhibansal1997",
                        "content": "Shouldn\\'t 2 be the answer for this test case : [[1,1,100000],[100000, 100000, 1]] ?\\n(1,1) detonates itself & then (100000, 100000). \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "Check this, you can understand easily : https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588930/1-1-100000-100000-100000-1-getting-wrong-understand-why/"
                    },
                    {
                        "username": "psionl0",
                        "content": "the distance between (1,1) and (100000,100000) is 141420 which is beyond the range of the bomb at (1,1)."
                    },
                    {
                        "username": "banaren",
                        "content": "I expect the answer for this to be 4 not 5\\n[[1,2,3],[2,3,1],[3,4,2],[4,5,3],[5,6,4]]\\n\\nCan anyone explain why ?\\n\\nI have attached a graph. I see a maximum of 4 circles for [4,5,3]\\n![image](https://assets.leetcode.com/users/images/b1ec4c80-e4b2-4fe3-9892-00a7427fc19f_1639258822.7928765.png)\\n"
                    },
                    {
                        "username": "ayush81029",
                        "content": "Trick is that center of one bomb should be in the range of another bomb. I think you are including all those cases where range of two bombs are overlapping but you have to include those cases where center of one bomb is lying in the range of another bomb. It will be like a directed graph because if bomb A is in range of bomb B this doesn\\'t imply that bomb B will be in range of bomb A. \\nYou can understand this with an example. Let we have two bombs [[3,3,3],[8,3,3]]. In this both bomb range are overlapping but their centers are not in range of each other. So, for this case answer will be 1.  \\n\\nSo, in the above case left most bomb will not be detonated. "
                    },
                    {
                        "username": "RomanCastellarin",
                        "content": "Detonate the blue bomb. It will detonate Green and Purple.\\nPurple will detonate Black and Black will detonate Red.\\nAnswer is 5"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Bombs can detonate each other. Bomb A can detonate bomb B, which detonates C, and so forth."
                    },
                    {
                        "username": "aishu8333",
                        "content": "how can the interviewer expect that candidate knows finding whether circles intersect or not. I mean the formula, its more of Maths . For me the most difficult is finding that formula ."
                    },
                    {
                        "username": "JustinLiang522",
                        "content": "Who would put two bombs in exactly the same position???"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I was dumbfounded until I read the hint saying that we can represent the data by graphs. It became so simple then. This is a good question\n\nP.S: This is my 300th problem :)"
                    },
                    {
                        "username": "NandhakumarThyiagarajan",
                        "content": "[[1,1,100000],[100000,100000,1]]  \\nCan anyone give ans to above one ?\\nI got the ans as 2 as 1st bomb covers range of bomb 2 in x and y axis\\nBut leetcode ans is 1\\n\\nAny idea about it ?\\n"
                    },
                    {
                        "username": "sandyy",
                        "content": "Use long for distance calculation. It\\'s giving wrong results due to integer overflow"
                    }
                ]
            },
            {
                "id": 1789401,
                "content": [
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Leetcode giving us signs...."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[[647,457,91],[483,716,37],[426,119,35],[355,588,40],[850,874,49],[232,568,46],[886,1,30],[54,377,3],[933,986,50],[305,790,49],[372,961,67],[671,314,58],[577,221,29],[380,147,91],[600,535,1],[806,329,64],[536,753,18],[906,88,23],[436,783,82],[652,674,45],[449,668,20],[419,13,66],[853,767,60],[169,288,33],[871,608,66],[337,445,35],[388,623,39],[723,503,81],[14,19,19],[98,648,72],[147,565,93],[655,434,1],[407,663,22],[805,947,83],[942,160,70],[959,496,93],[30,988,53],[187,849,60],[980,483,41],[663,150,76],[268,39,50],[513,522,75],[61,450,90],[115,231,12],[346,304,74],[385,540,23],[905,178,19],[336,896,81],[751,811,94],[527,783,78],[635,965,19],[334,290,39],[748,460,77],[414,134,22],[955,485,29],[925,787,43],[243,771,75],[675,223,29],[788,618,82],[462,544,30],[999,259,50],[210,146,12],[789,442,70],[286,36,55],[451,953,6],[719,914,14],[664,452,14],[933,637,29],[206,926,16],[100,422,98],[97,333,4],[505,631,26],[908,287,65],[907,316,86],[949,185,16],[639,735,62],[401,739,18],[605,926,21],[25,391,69],[80,24,9],[435,874,92],[940,381,18],[260,740,87],[727,515,17],[361,152,16],[512,470,67],[189,27,27],[517,439,94],[159,543,76],[373,698,38],[781,836,97],[584,190,23],[383,367,86],[825,141,63],[117,926,85],[169,588,60],[56,981,100],[294,716,100],[781,370,89],[373,44,78]]\\n\\nFor this test case , I am getting 8 as output . But expected is 7. \\n\\naccording to my code by diffusing bomb 0, \\n0, 14, 27, 31, 52, 62, 66, 83 are diffused. \\n\\nCan anyone explain ?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@omgupta20382038](/omgupta20382038)  Working now!"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "[@_aka5h](/_aka5h) ha itne saare"
                    },
                    {
                        "username": "omgupta20382038",
                        "content": "I had the same problem, if you are using the sqrt function then dont,  try to write it differently: distance = (x2-x1)*(x2-x1)+(y2-y1)*(y2-y1); and check if distance <= radius*radius"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Dry run the testcase"
                    },
                    {
                        "username": "at218808",
                        "content": "[[656,619,56],[189,402,178],[513,373,276],[900,510,14],[188,173,129],[512,178,251],[145,685,47],[504,355,500],[554,131,214],[596,1,98],[358,230,197],[88,758,155],[72,340,419],[818,708,222]]\\n\\nmine output is 8 but expected is 14, i dont understand the problem , i am calculating distances between two \\nbombs and if there they lie in range then  i am putting them into same group."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "input : [[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]\\nOutput : 2\\nExpect : 1\\n---\\n\\nI see that bombs[7] = [69, 51, 7] and bombs[12] = [65, 59, 3], distance between these two is 8.944... and r1 + r2 = 7 + 3 = 10;\\nso when we detonate one of them, the other will explode too, right?\\n\\nIs the question wrong?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Hey, I had the same problem earlier. The catch is the center of the second bomb should be in the range of the first bomb. \\nhere 8.944 > 7 which means the second bomb will not be diffused. \\n\\nHope this helps!!"
                    },
                    {
                        "username": "ayush81029",
                        "content": "Trick is that center of one bomb should be in the range of another bomb. I think you are including all those cases where range of two bombs are overlapping but you have to include those cases where center of one bomb is lying in the range of another bomb. It will be like a directed graph because if bomb A is in range of bomb B this doesn\\'t imply that bomb B will be in range of bomb A. \\nYou can understand this with an example. Let we have two bombs [[3,3,3],[8,3,3]]. In this both bomb range are overlapping but their centers are not in range of each other. So, for this case answer will be 1.  "
                    },
                    {
                        "username": "anwendeng",
                        "content": "There is no adjacent  bomb!\nadj lists:\n0:[]\n1:[]\n2:[]\n3:[]\n4:[]\n5:[]\n6:[]\n7:[]\n8:[]\n9:[]\n10:[]\n11:[]\n12:[]\n13:[]\n14:[]\n15:[]\n16:[]"
                    },
                    {
                        "username": "psionl0",
                        "content": "Just because the ranges overlap doesn\\'t mean that the distance between the bombs is within the range of either one of them."
                    },
                    {
                        "username": "Jahongirhacking",
                        "content": "Why are you adding r1 and r2?"
                    },
                    {
                        "username": "vidhibansal1997",
                        "content": "Shouldn\\'t 2 be the answer for this test case : [[1,1,100000],[100000, 100000, 1]] ?\\n(1,1) detonates itself & then (100000, 100000). \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "Check this, you can understand easily : https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588930/1-1-100000-100000-100000-1-getting-wrong-understand-why/"
                    },
                    {
                        "username": "psionl0",
                        "content": "the distance between (1,1) and (100000,100000) is 141420 which is beyond the range of the bomb at (1,1)."
                    },
                    {
                        "username": "banaren",
                        "content": "I expect the answer for this to be 4 not 5\\n[[1,2,3],[2,3,1],[3,4,2],[4,5,3],[5,6,4]]\\n\\nCan anyone explain why ?\\n\\nI have attached a graph. I see a maximum of 4 circles for [4,5,3]\\n![image](https://assets.leetcode.com/users/images/b1ec4c80-e4b2-4fe3-9892-00a7427fc19f_1639258822.7928765.png)\\n"
                    },
                    {
                        "username": "ayush81029",
                        "content": "Trick is that center of one bomb should be in the range of another bomb. I think you are including all those cases where range of two bombs are overlapping but you have to include those cases where center of one bomb is lying in the range of another bomb. It will be like a directed graph because if bomb A is in range of bomb B this doesn\\'t imply that bomb B will be in range of bomb A. \\nYou can understand this with an example. Let we have two bombs [[3,3,3],[8,3,3]]. In this both bomb range are overlapping but their centers are not in range of each other. So, for this case answer will be 1.  \\n\\nSo, in the above case left most bomb will not be detonated. "
                    },
                    {
                        "username": "RomanCastellarin",
                        "content": "Detonate the blue bomb. It will detonate Green and Purple.\\nPurple will detonate Black and Black will detonate Red.\\nAnswer is 5"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Bombs can detonate each other. Bomb A can detonate bomb B, which detonates C, and so forth."
                    },
                    {
                        "username": "aishu8333",
                        "content": "how can the interviewer expect that candidate knows finding whether circles intersect or not. I mean the formula, its more of Maths . For me the most difficult is finding that formula ."
                    },
                    {
                        "username": "JustinLiang522",
                        "content": "Who would put two bombs in exactly the same position???"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I was dumbfounded until I read the hint saying that we can represent the data by graphs. It became so simple then. This is a good question\n\nP.S: This is my 300th problem :)"
                    },
                    {
                        "username": "NandhakumarThyiagarajan",
                        "content": "[[1,1,100000],[100000,100000,1]]  \\nCan anyone give ans to above one ?\\nI got the ans as 2 as 1st bomb covers range of bomb 2 in x and y axis\\nBut leetcode ans is 1\\n\\nAny idea about it ?\\n"
                    },
                    {
                        "username": "sandyy",
                        "content": "Use long for distance calculation. It\\'s giving wrong results due to integer overflow"
                    }
                ]
            },
            {
                "id": 1576078,
                "content": [
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Leetcode giving us signs...."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[[647,457,91],[483,716,37],[426,119,35],[355,588,40],[850,874,49],[232,568,46],[886,1,30],[54,377,3],[933,986,50],[305,790,49],[372,961,67],[671,314,58],[577,221,29],[380,147,91],[600,535,1],[806,329,64],[536,753,18],[906,88,23],[436,783,82],[652,674,45],[449,668,20],[419,13,66],[853,767,60],[169,288,33],[871,608,66],[337,445,35],[388,623,39],[723,503,81],[14,19,19],[98,648,72],[147,565,93],[655,434,1],[407,663,22],[805,947,83],[942,160,70],[959,496,93],[30,988,53],[187,849,60],[980,483,41],[663,150,76],[268,39,50],[513,522,75],[61,450,90],[115,231,12],[346,304,74],[385,540,23],[905,178,19],[336,896,81],[751,811,94],[527,783,78],[635,965,19],[334,290,39],[748,460,77],[414,134,22],[955,485,29],[925,787,43],[243,771,75],[675,223,29],[788,618,82],[462,544,30],[999,259,50],[210,146,12],[789,442,70],[286,36,55],[451,953,6],[719,914,14],[664,452,14],[933,637,29],[206,926,16],[100,422,98],[97,333,4],[505,631,26],[908,287,65],[907,316,86],[949,185,16],[639,735,62],[401,739,18],[605,926,21],[25,391,69],[80,24,9],[435,874,92],[940,381,18],[260,740,87],[727,515,17],[361,152,16],[512,470,67],[189,27,27],[517,439,94],[159,543,76],[373,698,38],[781,836,97],[584,190,23],[383,367,86],[825,141,63],[117,926,85],[169,588,60],[56,981,100],[294,716,100],[781,370,89],[373,44,78]]\\n\\nFor this test case , I am getting 8 as output . But expected is 7. \\n\\naccording to my code by diffusing bomb 0, \\n0, 14, 27, 31, 52, 62, 66, 83 are diffused. \\n\\nCan anyone explain ?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@omgupta20382038](/omgupta20382038)  Working now!"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "[@_aka5h](/_aka5h) ha itne saare"
                    },
                    {
                        "username": "omgupta20382038",
                        "content": "I had the same problem, if you are using the sqrt function then dont,  try to write it differently: distance = (x2-x1)*(x2-x1)+(y2-y1)*(y2-y1); and check if distance <= radius*radius"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Dry run the testcase"
                    },
                    {
                        "username": "at218808",
                        "content": "[[656,619,56],[189,402,178],[513,373,276],[900,510,14],[188,173,129],[512,178,251],[145,685,47],[504,355,500],[554,131,214],[596,1,98],[358,230,197],[88,758,155],[72,340,419],[818,708,222]]\\n\\nmine output is 8 but expected is 14, i dont understand the problem , i am calculating distances between two \\nbombs and if there they lie in range then  i am putting them into same group."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "input : [[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]\\nOutput : 2\\nExpect : 1\\n---\\n\\nI see that bombs[7] = [69, 51, 7] and bombs[12] = [65, 59, 3], distance between these two is 8.944... and r1 + r2 = 7 + 3 = 10;\\nso when we detonate one of them, the other will explode too, right?\\n\\nIs the question wrong?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Hey, I had the same problem earlier. The catch is the center of the second bomb should be in the range of the first bomb. \\nhere 8.944 > 7 which means the second bomb will not be diffused. \\n\\nHope this helps!!"
                    },
                    {
                        "username": "ayush81029",
                        "content": "Trick is that center of one bomb should be in the range of another bomb. I think you are including all those cases where range of two bombs are overlapping but you have to include those cases where center of one bomb is lying in the range of another bomb. It will be like a directed graph because if bomb A is in range of bomb B this doesn\\'t imply that bomb B will be in range of bomb A. \\nYou can understand this with an example. Let we have two bombs [[3,3,3],[8,3,3]]. In this both bomb range are overlapping but their centers are not in range of each other. So, for this case answer will be 1.  "
                    },
                    {
                        "username": "anwendeng",
                        "content": "There is no adjacent  bomb!\nadj lists:\n0:[]\n1:[]\n2:[]\n3:[]\n4:[]\n5:[]\n6:[]\n7:[]\n8:[]\n9:[]\n10:[]\n11:[]\n12:[]\n13:[]\n14:[]\n15:[]\n16:[]"
                    },
                    {
                        "username": "psionl0",
                        "content": "Just because the ranges overlap doesn\\'t mean that the distance between the bombs is within the range of either one of them."
                    },
                    {
                        "username": "Jahongirhacking",
                        "content": "Why are you adding r1 and r2?"
                    },
                    {
                        "username": "vidhibansal1997",
                        "content": "Shouldn\\'t 2 be the answer for this test case : [[1,1,100000],[100000, 100000, 1]] ?\\n(1,1) detonates itself & then (100000, 100000). \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "Check this, you can understand easily : https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588930/1-1-100000-100000-100000-1-getting-wrong-understand-why/"
                    },
                    {
                        "username": "psionl0",
                        "content": "the distance between (1,1) and (100000,100000) is 141420 which is beyond the range of the bomb at (1,1)."
                    },
                    {
                        "username": "banaren",
                        "content": "I expect the answer for this to be 4 not 5\\n[[1,2,3],[2,3,1],[3,4,2],[4,5,3],[5,6,4]]\\n\\nCan anyone explain why ?\\n\\nI have attached a graph. I see a maximum of 4 circles for [4,5,3]\\n![image](https://assets.leetcode.com/users/images/b1ec4c80-e4b2-4fe3-9892-00a7427fc19f_1639258822.7928765.png)\\n"
                    },
                    {
                        "username": "ayush81029",
                        "content": "Trick is that center of one bomb should be in the range of another bomb. I think you are including all those cases where range of two bombs are overlapping but you have to include those cases where center of one bomb is lying in the range of another bomb. It will be like a directed graph because if bomb A is in range of bomb B this doesn\\'t imply that bomb B will be in range of bomb A. \\nYou can understand this with an example. Let we have two bombs [[3,3,3],[8,3,3]]. In this both bomb range are overlapping but their centers are not in range of each other. So, for this case answer will be 1.  \\n\\nSo, in the above case left most bomb will not be detonated. "
                    },
                    {
                        "username": "RomanCastellarin",
                        "content": "Detonate the blue bomb. It will detonate Green and Purple.\\nPurple will detonate Black and Black will detonate Red.\\nAnswer is 5"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Bombs can detonate each other. Bomb A can detonate bomb B, which detonates C, and so forth."
                    },
                    {
                        "username": "aishu8333",
                        "content": "how can the interviewer expect that candidate knows finding whether circles intersect or not. I mean the formula, its more of Maths . For me the most difficult is finding that formula ."
                    },
                    {
                        "username": "JustinLiang522",
                        "content": "Who would put two bombs in exactly the same position???"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I was dumbfounded until I read the hint saying that we can represent the data by graphs. It became so simple then. This is a good question\n\nP.S: This is my 300th problem :)"
                    },
                    {
                        "username": "NandhakumarThyiagarajan",
                        "content": "[[1,1,100000],[100000,100000,1]]  \\nCan anyone give ans to above one ?\\nI got the ans as 2 as 1st bomb covers range of bomb 2 in x and y axis\\nBut leetcode ans is 1\\n\\nAny idea about it ?\\n"
                    },
                    {
                        "username": "sandyy",
                        "content": "Use long for distance calculation. It\\'s giving wrong results due to integer overflow"
                    }
                ]
            },
            {
                "id": 2051607,
                "content": [
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Leetcode giving us signs...."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[[647,457,91],[483,716,37],[426,119,35],[355,588,40],[850,874,49],[232,568,46],[886,1,30],[54,377,3],[933,986,50],[305,790,49],[372,961,67],[671,314,58],[577,221,29],[380,147,91],[600,535,1],[806,329,64],[536,753,18],[906,88,23],[436,783,82],[652,674,45],[449,668,20],[419,13,66],[853,767,60],[169,288,33],[871,608,66],[337,445,35],[388,623,39],[723,503,81],[14,19,19],[98,648,72],[147,565,93],[655,434,1],[407,663,22],[805,947,83],[942,160,70],[959,496,93],[30,988,53],[187,849,60],[980,483,41],[663,150,76],[268,39,50],[513,522,75],[61,450,90],[115,231,12],[346,304,74],[385,540,23],[905,178,19],[336,896,81],[751,811,94],[527,783,78],[635,965,19],[334,290,39],[748,460,77],[414,134,22],[955,485,29],[925,787,43],[243,771,75],[675,223,29],[788,618,82],[462,544,30],[999,259,50],[210,146,12],[789,442,70],[286,36,55],[451,953,6],[719,914,14],[664,452,14],[933,637,29],[206,926,16],[100,422,98],[97,333,4],[505,631,26],[908,287,65],[907,316,86],[949,185,16],[639,735,62],[401,739,18],[605,926,21],[25,391,69],[80,24,9],[435,874,92],[940,381,18],[260,740,87],[727,515,17],[361,152,16],[512,470,67],[189,27,27],[517,439,94],[159,543,76],[373,698,38],[781,836,97],[584,190,23],[383,367,86],[825,141,63],[117,926,85],[169,588,60],[56,981,100],[294,716,100],[781,370,89],[373,44,78]]\\n\\nFor this test case , I am getting 8 as output . But expected is 7. \\n\\naccording to my code by diffusing bomb 0, \\n0, 14, 27, 31, 52, 62, 66, 83 are diffused. \\n\\nCan anyone explain ?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@omgupta20382038](/omgupta20382038)  Working now!"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "[@_aka5h](/_aka5h) ha itne saare"
                    },
                    {
                        "username": "omgupta20382038",
                        "content": "I had the same problem, if you are using the sqrt function then dont,  try to write it differently: distance = (x2-x1)*(x2-x1)+(y2-y1)*(y2-y1); and check if distance <= radius*radius"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Dry run the testcase"
                    },
                    {
                        "username": "at218808",
                        "content": "[[656,619,56],[189,402,178],[513,373,276],[900,510,14],[188,173,129],[512,178,251],[145,685,47],[504,355,500],[554,131,214],[596,1,98],[358,230,197],[88,758,155],[72,340,419],[818,708,222]]\\n\\nmine output is 8 but expected is 14, i dont understand the problem , i am calculating distances between two \\nbombs and if there they lie in range then  i am putting them into same group."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "input : [[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]\\nOutput : 2\\nExpect : 1\\n---\\n\\nI see that bombs[7] = [69, 51, 7] and bombs[12] = [65, 59, 3], distance between these two is 8.944... and r1 + r2 = 7 + 3 = 10;\\nso when we detonate one of them, the other will explode too, right?\\n\\nIs the question wrong?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Hey, I had the same problem earlier. The catch is the center of the second bomb should be in the range of the first bomb. \\nhere 8.944 > 7 which means the second bomb will not be diffused. \\n\\nHope this helps!!"
                    },
                    {
                        "username": "ayush81029",
                        "content": "Trick is that center of one bomb should be in the range of another bomb. I think you are including all those cases where range of two bombs are overlapping but you have to include those cases where center of one bomb is lying in the range of another bomb. It will be like a directed graph because if bomb A is in range of bomb B this doesn\\'t imply that bomb B will be in range of bomb A. \\nYou can understand this with an example. Let we have two bombs [[3,3,3],[8,3,3]]. In this both bomb range are overlapping but their centers are not in range of each other. So, for this case answer will be 1.  "
                    },
                    {
                        "username": "anwendeng",
                        "content": "There is no adjacent  bomb!\nadj lists:\n0:[]\n1:[]\n2:[]\n3:[]\n4:[]\n5:[]\n6:[]\n7:[]\n8:[]\n9:[]\n10:[]\n11:[]\n12:[]\n13:[]\n14:[]\n15:[]\n16:[]"
                    },
                    {
                        "username": "psionl0",
                        "content": "Just because the ranges overlap doesn\\'t mean that the distance between the bombs is within the range of either one of them."
                    },
                    {
                        "username": "Jahongirhacking",
                        "content": "Why are you adding r1 and r2?"
                    },
                    {
                        "username": "vidhibansal1997",
                        "content": "Shouldn\\'t 2 be the answer for this test case : [[1,1,100000],[100000, 100000, 1]] ?\\n(1,1) detonates itself & then (100000, 100000). \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "Check this, you can understand easily : https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588930/1-1-100000-100000-100000-1-getting-wrong-understand-why/"
                    },
                    {
                        "username": "psionl0",
                        "content": "the distance between (1,1) and (100000,100000) is 141420 which is beyond the range of the bomb at (1,1)."
                    },
                    {
                        "username": "banaren",
                        "content": "I expect the answer for this to be 4 not 5\\n[[1,2,3],[2,3,1],[3,4,2],[4,5,3],[5,6,4]]\\n\\nCan anyone explain why ?\\n\\nI have attached a graph. I see a maximum of 4 circles for [4,5,3]\\n![image](https://assets.leetcode.com/users/images/b1ec4c80-e4b2-4fe3-9892-00a7427fc19f_1639258822.7928765.png)\\n"
                    },
                    {
                        "username": "ayush81029",
                        "content": "Trick is that center of one bomb should be in the range of another bomb. I think you are including all those cases where range of two bombs are overlapping but you have to include those cases where center of one bomb is lying in the range of another bomb. It will be like a directed graph because if bomb A is in range of bomb B this doesn\\'t imply that bomb B will be in range of bomb A. \\nYou can understand this with an example. Let we have two bombs [[3,3,3],[8,3,3]]. In this both bomb range are overlapping but their centers are not in range of each other. So, for this case answer will be 1.  \\n\\nSo, in the above case left most bomb will not be detonated. "
                    },
                    {
                        "username": "RomanCastellarin",
                        "content": "Detonate the blue bomb. It will detonate Green and Purple.\\nPurple will detonate Black and Black will detonate Red.\\nAnswer is 5"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Bombs can detonate each other. Bomb A can detonate bomb B, which detonates C, and so forth."
                    },
                    {
                        "username": "aishu8333",
                        "content": "how can the interviewer expect that candidate knows finding whether circles intersect or not. I mean the formula, its more of Maths . For me the most difficult is finding that formula ."
                    },
                    {
                        "username": "JustinLiang522",
                        "content": "Who would put two bombs in exactly the same position???"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I was dumbfounded until I read the hint saying that we can represent the data by graphs. It became so simple then. This is a good question\n\nP.S: This is my 300th problem :)"
                    },
                    {
                        "username": "NandhakumarThyiagarajan",
                        "content": "[[1,1,100000],[100000,100000,1]]  \\nCan anyone give ans to above one ?\\nI got the ans as 2 as 1st bomb covers range of bomb 2 in x and y axis\\nBut leetcode ans is 1\\n\\nAny idea about it ?\\n"
                    },
                    {
                        "username": "sandyy",
                        "content": "Use long for distance calculation. It\\'s giving wrong results due to integer overflow"
                    }
                ]
            },
            {
                "id": 2038787,
                "content": [
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Leetcode giving us signs...."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[[647,457,91],[483,716,37],[426,119,35],[355,588,40],[850,874,49],[232,568,46],[886,1,30],[54,377,3],[933,986,50],[305,790,49],[372,961,67],[671,314,58],[577,221,29],[380,147,91],[600,535,1],[806,329,64],[536,753,18],[906,88,23],[436,783,82],[652,674,45],[449,668,20],[419,13,66],[853,767,60],[169,288,33],[871,608,66],[337,445,35],[388,623,39],[723,503,81],[14,19,19],[98,648,72],[147,565,93],[655,434,1],[407,663,22],[805,947,83],[942,160,70],[959,496,93],[30,988,53],[187,849,60],[980,483,41],[663,150,76],[268,39,50],[513,522,75],[61,450,90],[115,231,12],[346,304,74],[385,540,23],[905,178,19],[336,896,81],[751,811,94],[527,783,78],[635,965,19],[334,290,39],[748,460,77],[414,134,22],[955,485,29],[925,787,43],[243,771,75],[675,223,29],[788,618,82],[462,544,30],[999,259,50],[210,146,12],[789,442,70],[286,36,55],[451,953,6],[719,914,14],[664,452,14],[933,637,29],[206,926,16],[100,422,98],[97,333,4],[505,631,26],[908,287,65],[907,316,86],[949,185,16],[639,735,62],[401,739,18],[605,926,21],[25,391,69],[80,24,9],[435,874,92],[940,381,18],[260,740,87],[727,515,17],[361,152,16],[512,470,67],[189,27,27],[517,439,94],[159,543,76],[373,698,38],[781,836,97],[584,190,23],[383,367,86],[825,141,63],[117,926,85],[169,588,60],[56,981,100],[294,716,100],[781,370,89],[373,44,78]]\\n\\nFor this test case , I am getting 8 as output . But expected is 7. \\n\\naccording to my code by diffusing bomb 0, \\n0, 14, 27, 31, 52, 62, 66, 83 are diffused. \\n\\nCan anyone explain ?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@omgupta20382038](/omgupta20382038)  Working now!"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "[@_aka5h](/_aka5h) ha itne saare"
                    },
                    {
                        "username": "omgupta20382038",
                        "content": "I had the same problem, if you are using the sqrt function then dont,  try to write it differently: distance = (x2-x1)*(x2-x1)+(y2-y1)*(y2-y1); and check if distance <= radius*radius"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Dry run the testcase"
                    },
                    {
                        "username": "at218808",
                        "content": "[[656,619,56],[189,402,178],[513,373,276],[900,510,14],[188,173,129],[512,178,251],[145,685,47],[504,355,500],[554,131,214],[596,1,98],[358,230,197],[88,758,155],[72,340,419],[818,708,222]]\\n\\nmine output is 8 but expected is 14, i dont understand the problem , i am calculating distances between two \\nbombs and if there they lie in range then  i am putting them into same group."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "input : [[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]\\nOutput : 2\\nExpect : 1\\n---\\n\\nI see that bombs[7] = [69, 51, 7] and bombs[12] = [65, 59, 3], distance between these two is 8.944... and r1 + r2 = 7 + 3 = 10;\\nso when we detonate one of them, the other will explode too, right?\\n\\nIs the question wrong?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Hey, I had the same problem earlier. The catch is the center of the second bomb should be in the range of the first bomb. \\nhere 8.944 > 7 which means the second bomb will not be diffused. \\n\\nHope this helps!!"
                    },
                    {
                        "username": "ayush81029",
                        "content": "Trick is that center of one bomb should be in the range of another bomb. I think you are including all those cases where range of two bombs are overlapping but you have to include those cases where center of one bomb is lying in the range of another bomb. It will be like a directed graph because if bomb A is in range of bomb B this doesn\\'t imply that bomb B will be in range of bomb A. \\nYou can understand this with an example. Let we have two bombs [[3,3,3],[8,3,3]]. In this both bomb range are overlapping but their centers are not in range of each other. So, for this case answer will be 1.  "
                    },
                    {
                        "username": "anwendeng",
                        "content": "There is no adjacent  bomb!\nadj lists:\n0:[]\n1:[]\n2:[]\n3:[]\n4:[]\n5:[]\n6:[]\n7:[]\n8:[]\n9:[]\n10:[]\n11:[]\n12:[]\n13:[]\n14:[]\n15:[]\n16:[]"
                    },
                    {
                        "username": "psionl0",
                        "content": "Just because the ranges overlap doesn\\'t mean that the distance between the bombs is within the range of either one of them."
                    },
                    {
                        "username": "Jahongirhacking",
                        "content": "Why are you adding r1 and r2?"
                    },
                    {
                        "username": "vidhibansal1997",
                        "content": "Shouldn\\'t 2 be the answer for this test case : [[1,1,100000],[100000, 100000, 1]] ?\\n(1,1) detonates itself & then (100000, 100000). \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "Check this, you can understand easily : https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588930/1-1-100000-100000-100000-1-getting-wrong-understand-why/"
                    },
                    {
                        "username": "psionl0",
                        "content": "the distance between (1,1) and (100000,100000) is 141420 which is beyond the range of the bomb at (1,1)."
                    },
                    {
                        "username": "banaren",
                        "content": "I expect the answer for this to be 4 not 5\\n[[1,2,3],[2,3,1],[3,4,2],[4,5,3],[5,6,4]]\\n\\nCan anyone explain why ?\\n\\nI have attached a graph. I see a maximum of 4 circles for [4,5,3]\\n![image](https://assets.leetcode.com/users/images/b1ec4c80-e4b2-4fe3-9892-00a7427fc19f_1639258822.7928765.png)\\n"
                    },
                    {
                        "username": "ayush81029",
                        "content": "Trick is that center of one bomb should be in the range of another bomb. I think you are including all those cases where range of two bombs are overlapping but you have to include those cases where center of one bomb is lying in the range of another bomb. It will be like a directed graph because if bomb A is in range of bomb B this doesn\\'t imply that bomb B will be in range of bomb A. \\nYou can understand this with an example. Let we have two bombs [[3,3,3],[8,3,3]]. In this both bomb range are overlapping but their centers are not in range of each other. So, for this case answer will be 1.  \\n\\nSo, in the above case left most bomb will not be detonated. "
                    },
                    {
                        "username": "RomanCastellarin",
                        "content": "Detonate the blue bomb. It will detonate Green and Purple.\\nPurple will detonate Black and Black will detonate Red.\\nAnswer is 5"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Bombs can detonate each other. Bomb A can detonate bomb B, which detonates C, and so forth."
                    },
                    {
                        "username": "aishu8333",
                        "content": "how can the interviewer expect that candidate knows finding whether circles intersect or not. I mean the formula, its more of Maths . For me the most difficult is finding that formula ."
                    },
                    {
                        "username": "JustinLiang522",
                        "content": "Who would put two bombs in exactly the same position???"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I was dumbfounded until I read the hint saying that we can represent the data by graphs. It became so simple then. This is a good question\n\nP.S: This is my 300th problem :)"
                    },
                    {
                        "username": "NandhakumarThyiagarajan",
                        "content": "[[1,1,100000],[100000,100000,1]]  \\nCan anyone give ans to above one ?\\nI got the ans as 2 as 1st bomb covers range of bomb 2 in x and y axis\\nBut leetcode ans is 1\\n\\nAny idea about it ?\\n"
                    },
                    {
                        "username": "sandyy",
                        "content": "Use long for distance calculation. It\\'s giving wrong results due to integer overflow"
                    }
                ]
            },
            {
                "id": 2012803,
                "content": [
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Leetcode giving us signs...."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[[647,457,91],[483,716,37],[426,119,35],[355,588,40],[850,874,49],[232,568,46],[886,1,30],[54,377,3],[933,986,50],[305,790,49],[372,961,67],[671,314,58],[577,221,29],[380,147,91],[600,535,1],[806,329,64],[536,753,18],[906,88,23],[436,783,82],[652,674,45],[449,668,20],[419,13,66],[853,767,60],[169,288,33],[871,608,66],[337,445,35],[388,623,39],[723,503,81],[14,19,19],[98,648,72],[147,565,93],[655,434,1],[407,663,22],[805,947,83],[942,160,70],[959,496,93],[30,988,53],[187,849,60],[980,483,41],[663,150,76],[268,39,50],[513,522,75],[61,450,90],[115,231,12],[346,304,74],[385,540,23],[905,178,19],[336,896,81],[751,811,94],[527,783,78],[635,965,19],[334,290,39],[748,460,77],[414,134,22],[955,485,29],[925,787,43],[243,771,75],[675,223,29],[788,618,82],[462,544,30],[999,259,50],[210,146,12],[789,442,70],[286,36,55],[451,953,6],[719,914,14],[664,452,14],[933,637,29],[206,926,16],[100,422,98],[97,333,4],[505,631,26],[908,287,65],[907,316,86],[949,185,16],[639,735,62],[401,739,18],[605,926,21],[25,391,69],[80,24,9],[435,874,92],[940,381,18],[260,740,87],[727,515,17],[361,152,16],[512,470,67],[189,27,27],[517,439,94],[159,543,76],[373,698,38],[781,836,97],[584,190,23],[383,367,86],[825,141,63],[117,926,85],[169,588,60],[56,981,100],[294,716,100],[781,370,89],[373,44,78]]\\n\\nFor this test case , I am getting 8 as output . But expected is 7. \\n\\naccording to my code by diffusing bomb 0, \\n0, 14, 27, 31, 52, 62, 66, 83 are diffused. \\n\\nCan anyone explain ?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@omgupta20382038](/omgupta20382038)  Working now!"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "[@_aka5h](/_aka5h) ha itne saare"
                    },
                    {
                        "username": "omgupta20382038",
                        "content": "I had the same problem, if you are using the sqrt function then dont,  try to write it differently: distance = (x2-x1)*(x2-x1)+(y2-y1)*(y2-y1); and check if distance <= radius*radius"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Dry run the testcase"
                    },
                    {
                        "username": "at218808",
                        "content": "[[656,619,56],[189,402,178],[513,373,276],[900,510,14],[188,173,129],[512,178,251],[145,685,47],[504,355,500],[554,131,214],[596,1,98],[358,230,197],[88,758,155],[72,340,419],[818,708,222]]\\n\\nmine output is 8 but expected is 14, i dont understand the problem , i am calculating distances between two \\nbombs and if there they lie in range then  i am putting them into same group."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "input : [[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]\\nOutput : 2\\nExpect : 1\\n---\\n\\nI see that bombs[7] = [69, 51, 7] and bombs[12] = [65, 59, 3], distance between these two is 8.944... and r1 + r2 = 7 + 3 = 10;\\nso when we detonate one of them, the other will explode too, right?\\n\\nIs the question wrong?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Hey, I had the same problem earlier. The catch is the center of the second bomb should be in the range of the first bomb. \\nhere 8.944 > 7 which means the second bomb will not be diffused. \\n\\nHope this helps!!"
                    },
                    {
                        "username": "ayush81029",
                        "content": "Trick is that center of one bomb should be in the range of another bomb. I think you are including all those cases where range of two bombs are overlapping but you have to include those cases where center of one bomb is lying in the range of another bomb. It will be like a directed graph because if bomb A is in range of bomb B this doesn\\'t imply that bomb B will be in range of bomb A. \\nYou can understand this with an example. Let we have two bombs [[3,3,3],[8,3,3]]. In this both bomb range are overlapping but their centers are not in range of each other. So, for this case answer will be 1.  "
                    },
                    {
                        "username": "anwendeng",
                        "content": "There is no adjacent  bomb!\nadj lists:\n0:[]\n1:[]\n2:[]\n3:[]\n4:[]\n5:[]\n6:[]\n7:[]\n8:[]\n9:[]\n10:[]\n11:[]\n12:[]\n13:[]\n14:[]\n15:[]\n16:[]"
                    },
                    {
                        "username": "psionl0",
                        "content": "Just because the ranges overlap doesn\\'t mean that the distance between the bombs is within the range of either one of them."
                    },
                    {
                        "username": "Jahongirhacking",
                        "content": "Why are you adding r1 and r2?"
                    },
                    {
                        "username": "vidhibansal1997",
                        "content": "Shouldn\\'t 2 be the answer for this test case : [[1,1,100000],[100000, 100000, 1]] ?\\n(1,1) detonates itself & then (100000, 100000). \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "Check this, you can understand easily : https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588930/1-1-100000-100000-100000-1-getting-wrong-understand-why/"
                    },
                    {
                        "username": "psionl0",
                        "content": "the distance between (1,1) and (100000,100000) is 141420 which is beyond the range of the bomb at (1,1)."
                    },
                    {
                        "username": "banaren",
                        "content": "I expect the answer for this to be 4 not 5\\n[[1,2,3],[2,3,1],[3,4,2],[4,5,3],[5,6,4]]\\n\\nCan anyone explain why ?\\n\\nI have attached a graph. I see a maximum of 4 circles for [4,5,3]\\n![image](https://assets.leetcode.com/users/images/b1ec4c80-e4b2-4fe3-9892-00a7427fc19f_1639258822.7928765.png)\\n"
                    },
                    {
                        "username": "ayush81029",
                        "content": "Trick is that center of one bomb should be in the range of another bomb. I think you are including all those cases where range of two bombs are overlapping but you have to include those cases where center of one bomb is lying in the range of another bomb. It will be like a directed graph because if bomb A is in range of bomb B this doesn\\'t imply that bomb B will be in range of bomb A. \\nYou can understand this with an example. Let we have two bombs [[3,3,3],[8,3,3]]. In this both bomb range are overlapping but their centers are not in range of each other. So, for this case answer will be 1.  \\n\\nSo, in the above case left most bomb will not be detonated. "
                    },
                    {
                        "username": "RomanCastellarin",
                        "content": "Detonate the blue bomb. It will detonate Green and Purple.\\nPurple will detonate Black and Black will detonate Red.\\nAnswer is 5"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Bombs can detonate each other. Bomb A can detonate bomb B, which detonates C, and so forth."
                    },
                    {
                        "username": "aishu8333",
                        "content": "how can the interviewer expect that candidate knows finding whether circles intersect or not. I mean the formula, its more of Maths . For me the most difficult is finding that formula ."
                    },
                    {
                        "username": "JustinLiang522",
                        "content": "Who would put two bombs in exactly the same position???"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I was dumbfounded until I read the hint saying that we can represent the data by graphs. It became so simple then. This is a good question\n\nP.S: This is my 300th problem :)"
                    },
                    {
                        "username": "NandhakumarThyiagarajan",
                        "content": "[[1,1,100000],[100000,100000,1]]  \\nCan anyone give ans to above one ?\\nI got the ans as 2 as 1st bomb covers range of bomb 2 in x and y axis\\nBut leetcode ans is 1\\n\\nAny idea about it ?\\n"
                    },
                    {
                        "username": "sandyy",
                        "content": "Use long for distance calculation. It\\'s giving wrong results due to integer overflow"
                    }
                ]
            },
            {
                "id": 1977034,
                "content": [
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Leetcode giving us signs...."
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[[647,457,91],[483,716,37],[426,119,35],[355,588,40],[850,874,49],[232,568,46],[886,1,30],[54,377,3],[933,986,50],[305,790,49],[372,961,67],[671,314,58],[577,221,29],[380,147,91],[600,535,1],[806,329,64],[536,753,18],[906,88,23],[436,783,82],[652,674,45],[449,668,20],[419,13,66],[853,767,60],[169,288,33],[871,608,66],[337,445,35],[388,623,39],[723,503,81],[14,19,19],[98,648,72],[147,565,93],[655,434,1],[407,663,22],[805,947,83],[942,160,70],[959,496,93],[30,988,53],[187,849,60],[980,483,41],[663,150,76],[268,39,50],[513,522,75],[61,450,90],[115,231,12],[346,304,74],[385,540,23],[905,178,19],[336,896,81],[751,811,94],[527,783,78],[635,965,19],[334,290,39],[748,460,77],[414,134,22],[955,485,29],[925,787,43],[243,771,75],[675,223,29],[788,618,82],[462,544,30],[999,259,50],[210,146,12],[789,442,70],[286,36,55],[451,953,6],[719,914,14],[664,452,14],[933,637,29],[206,926,16],[100,422,98],[97,333,4],[505,631,26],[908,287,65],[907,316,86],[949,185,16],[639,735,62],[401,739,18],[605,926,21],[25,391,69],[80,24,9],[435,874,92],[940,381,18],[260,740,87],[727,515,17],[361,152,16],[512,470,67],[189,27,27],[517,439,94],[159,543,76],[373,698,38],[781,836,97],[584,190,23],[383,367,86],[825,141,63],[117,926,85],[169,588,60],[56,981,100],[294,716,100],[781,370,89],[373,44,78]]\\n\\nFor this test case , I am getting 8 as output . But expected is 7. \\n\\naccording to my code by diffusing bomb 0, \\n0, 14, 27, 31, 52, 62, 66, 83 are diffused. \\n\\nCan anyone explain ?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "[@omgupta20382038](/omgupta20382038)  Working now!"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "[@_aka5h](/_aka5h) ha itne saare"
                    },
                    {
                        "username": "omgupta20382038",
                        "content": "I had the same problem, if you are using the sqrt function then dont,  try to write it differently: distance = (x2-x1)*(x2-x1)+(y2-y1)*(y2-y1); and check if distance <= radius*radius"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Dry run the testcase"
                    },
                    {
                        "username": "at218808",
                        "content": "[[656,619,56],[189,402,178],[513,373,276],[900,510,14],[188,173,129],[512,178,251],[145,685,47],[504,355,500],[554,131,214],[596,1,98],[358,230,197],[88,758,155],[72,340,419],[818,708,222]]\\n\\nmine output is 8 but expected is 14, i dont understand the problem , i am calculating distances between two \\nbombs and if there they lie in range then  i am putting them into same group."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "input : [[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]\\nOutput : 2\\nExpect : 1\\n---\\n\\nI see that bombs[7] = [69, 51, 7] and bombs[12] = [65, 59, 3], distance between these two is 8.944... and r1 + r2 = 7 + 3 = 10;\\nso when we detonate one of them, the other will explode too, right?\\n\\nIs the question wrong?"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "Hey, I had the same problem earlier. The catch is the center of the second bomb should be in the range of the first bomb. \\nhere 8.944 > 7 which means the second bomb will not be diffused. \\n\\nHope this helps!!"
                    },
                    {
                        "username": "ayush81029",
                        "content": "Trick is that center of one bomb should be in the range of another bomb. I think you are including all those cases where range of two bombs are overlapping but you have to include those cases where center of one bomb is lying in the range of another bomb. It will be like a directed graph because if bomb A is in range of bomb B this doesn\\'t imply that bomb B will be in range of bomb A. \\nYou can understand this with an example. Let we have two bombs [[3,3,3],[8,3,3]]. In this both bomb range are overlapping but their centers are not in range of each other. So, for this case answer will be 1.  "
                    },
                    {
                        "username": "anwendeng",
                        "content": "There is no adjacent  bomb!\nadj lists:\n0:[]\n1:[]\n2:[]\n3:[]\n4:[]\n5:[]\n6:[]\n7:[]\n8:[]\n9:[]\n10:[]\n11:[]\n12:[]\n13:[]\n14:[]\n15:[]\n16:[]"
                    },
                    {
                        "username": "psionl0",
                        "content": "Just because the ranges overlap doesn\\'t mean that the distance between the bombs is within the range of either one of them."
                    },
                    {
                        "username": "Jahongirhacking",
                        "content": "Why are you adding r1 and r2?"
                    },
                    {
                        "username": "vidhibansal1997",
                        "content": "Shouldn\\'t 2 be the answer for this test case : [[1,1,100000],[100000, 100000, 1]] ?\\n(1,1) detonates itself & then (100000, 100000). \\n"
                    },
                    {
                        "username": "_SID_",
                        "content": "Check this, you can understand easily : https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588930/1-1-100000-100000-100000-1-getting-wrong-understand-why/"
                    },
                    {
                        "username": "psionl0",
                        "content": "the distance between (1,1) and (100000,100000) is 141420 which is beyond the range of the bomb at (1,1)."
                    },
                    {
                        "username": "banaren",
                        "content": "I expect the answer for this to be 4 not 5\\n[[1,2,3],[2,3,1],[3,4,2],[4,5,3],[5,6,4]]\\n\\nCan anyone explain why ?\\n\\nI have attached a graph. I see a maximum of 4 circles for [4,5,3]\\n![image](https://assets.leetcode.com/users/images/b1ec4c80-e4b2-4fe3-9892-00a7427fc19f_1639258822.7928765.png)\\n"
                    },
                    {
                        "username": "ayush81029",
                        "content": "Trick is that center of one bomb should be in the range of another bomb. I think you are including all those cases where range of two bombs are overlapping but you have to include those cases where center of one bomb is lying in the range of another bomb. It will be like a directed graph because if bomb A is in range of bomb B this doesn\\'t imply that bomb B will be in range of bomb A. \\nYou can understand this with an example. Let we have two bombs [[3,3,3],[8,3,3]]. In this both bomb range are overlapping but their centers are not in range of each other. So, for this case answer will be 1.  \\n\\nSo, in the above case left most bomb will not be detonated. "
                    },
                    {
                        "username": "RomanCastellarin",
                        "content": "Detonate the blue bomb. It will detonate Green and Purple.\\nPurple will detonate Black and Black will detonate Red.\\nAnswer is 5"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "Bombs can detonate each other. Bomb A can detonate bomb B, which detonates C, and so forth."
                    },
                    {
                        "username": "aishu8333",
                        "content": "how can the interviewer expect that candidate knows finding whether circles intersect or not. I mean the formula, its more of Maths . For me the most difficult is finding that formula ."
                    },
                    {
                        "username": "JustinLiang522",
                        "content": "Who would put two bombs in exactly the same position???"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I was dumbfounded until I read the hint saying that we can represent the data by graphs. It became so simple then. This is a good question\n\nP.S: This is my 300th problem :)"
                    },
                    {
                        "username": "NandhakumarThyiagarajan",
                        "content": "[[1,1,100000],[100000,100000,1]]  \\nCan anyone give ans to above one ?\\nI got the ans as 2 as 1st bomb covers range of bomb 2 in x and y axis\\nBut leetcode ans is 1\\n\\nAny idea about it ?\\n"
                    },
                    {
                        "username": "sandyy",
                        "content": "Use long for distance calculation. It\\'s giving wrong results due to integer overflow"
                    }
                ]
            },
            {
                "id": 1937316,
                "content": [
                    {
                        "username": "cookiecoop",
                        "content": "I get a time limit exceeded for last test case but input is just \"bombs = \". Is anyone else getting this?\\n"
                    },
                    {
                        "username": "dev_Louis",
                        "content": "Why does the following code will not be submitted due to the time limit? \nWhen running the code for the testcases even for larger inputs everthing is working correctly...\n\n`from math import sqrt\n\nclass Solution:\n    def __init__(self):\n        self.det_counts = []\n        self.dup_bombs = []\n        self.bombs_rel = []\n\n    def maximumDetonation(self, bombs: list[list[int]]) -> int:\n\n        # check for duplicate bombs\n        def get_dup_bombs():\n            dups = []\n            for i in range(len(bombs)):\n                for j in range(i + 1, len(bombs)):\n                    if bombs[i] == bombs[j]:\n                        dups.append(bombs[i])\n            return dups\n        self.dup_bombs = get_dup_bombs()    \n\n        def detonation(bombs_rel, bi, si):\n            if si == 0:\n                bombs_rel.append(bombs[bi])\n\n            for comp_bomb in bombs:\n                if not bombs[bi] == comp_bomb:\n                    d = sqrt(((comp_bomb[0]-bombs[bi][0])**2) + ((comp_bomb[1]-bombs[bi][1])**2))\n                    if bombs[bi][2] >= d and not comp_bomb in bombs_rel:\n                        bombs_rel.append(comp_bomb)\n\n            if not si+1 == len(bombs_rel):\n                detonation(bombs_rel, bi=bombs.index(bombs_rel[si+1]), si=si+1)\n\n        for i in range(len(bombs)):\n            self.bombs_rel = []\n            detonation(self.bombs_rel, bi=i, si=0)\n            # add duplicate bombs to final relation list\n            for bomb in self.dup_bombs:\n                if bomb in self.bombs_rel:\n                    self.bombs_rel.append(bomb)\n            self.det_counts.append(len(self.bombs_rel))\n\n        return max(self.det_counts)`"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "class Solution {\\npublic:\\n    int count = 1;\\n    void dfs (int source,vector <bool>& visited,map<int,list<int>> adj_lst){\\n\\n        visited[source] = true;\\n\\n         for (auto x : adj_lst[source]){\\n             if (!visited[x]){\\n                 dfs(x,visited,adj_lst);\\n                 count++;\\n             }\\n            \\n         }\\n    }\\n\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n    \\n    //  Graph approach\\n     if (bombs.size() == 1)return 1;\\n\\n     else {\\n        //  Creating adjacency list for the Directed Graph\\n        map <int,list<int>> adj;\\n        vector <bool> visited (bombs.size(),false);\\n        vector <int> dp(bombs.size(),1);\\n        for (int i = 0 ; i < bombs.size();i++){\\n            \\n            long long x1 = bombs[i][0];\\n            long long y1 = bombs[i][1];\\n            long long r1 = bombs[i][2];\\n            \\n            for (int j = i+1; j < bombs.size();j++){\\n                long long x2 = bombs[j][0];\\n                long long y2 = bombs[j][1];\\n                long long r2 = bombs[j][2];\\n\\n                long long dist = (x1 - x2)*(x1-x2)+ (y1 - y2)*(y1-y2);\\n                if (dist <= r1*r1){\\n                    adj[i].push_back(j);\\n                }\\n                if (dist <= r2*r2){\\n                    adj[j].push_back(i);\\n                }\\n\\n            }\\n        }\\n        int max_count = 0 ;\\n        for (int i = 0; i < bombs.size();i++){\\n            dfs(i,visited,adj);\\n            if (max_count < count){\\n                max_count = count;\\n            }\\n            fill(visited.begin(),visited.end(),false);\\n            count = 1;\\n        }\\n        return max_count;\\n\\n     }\\n\\n    }\\n};\\nIam getting TLE , can some one help "
                    },
                    {
                        "username": "piyushjo",
                        "content": "Can anyone help me find what am I missing for following test case : \\n [[855,82,158],[17,719,430],[90,756,164],[376,17,340],[691,636,152],[565,776,5],[464,154,271],[53,361,162],[278,609,82],[202,927,219],[542,865,377],[330,402,270],[720,199,10],[986,697,443],[471,296,69],[393,81,404],[127,405,177]]\\n\\n\\nApproach : \\n1. I stored what bombs a bomb can explode directly at first and added them in a list. These lists are stored in mainList as per index of first bomb exploded. \\n2. helper method will just get mainList.\\n3. help method will resolve add all the bombs a bomb at a particular index can explode by making recursive calls.\\n\\n---------------------------------------\\n\\n`\\nclass Solution {\\n    public int maximumDetonation(int[][] bombs) {\\n        List<List<Integer>> mainList = new ArrayList<>() ; \\n        \\n\\n        for(int i = 0 ; i < bombs.length ; i++){\\n            List<Integer> list = new ArrayList<>() ;\\n            for(int j = 0 ; j < bombs.length ; j++){\\n                if(j==i) continue; \\n                if(Math.hypot(bombs[i][0]-bombs[j][0],bombs[i][1]-bombs[j][1]) <= Math.max(bombs[i][2],bombs[j][2])){\\n                    list.add(j);\\n                }\\n            }\\n            mainList.add(list);\\n        }\\n        return helper(mainList);\\n    }\\n\\n    private int helper(List<List<Integer>> mainList){\\n        int num = 1;\\n         \\n        \\n        for(int i = 0 ; i < mainList.size() ; i++){\\n            if(mainList.get(i).size() == 0) continue; \\n            Set<Integer> set = new HashSet<>() ;\\n            set.add(i);\\n            help(mainList,mainList.get(i),set);\\n            num = Math.max(num,set.size());\\n        }\\n\\n        return num ; \\n    }\\n\\n    private void help(List<List<Integer>> mainList , List<Integer> list , Set<Integer> set){ \\n        for(int i = 0 ; i < list.size() ; i++){\\n            if(set.contains(list.get(i))) continue ; \\n            set.add(list.get(i));\\n            help(mainList,mainList.get(list.get(i)),set);\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "piyushjo",
                        "content": "[@tungbuivn](/tungbuivn) Thanks !!\\n\\nfollowing if condition needed to be changed for the obvious reason. \\n\\nEarlier : \\n\\nMath.hypot(bombs[i][0]-bombs[j][0],bombs[i][1]-bombs[j][1]) <= Math.max(bombs[i][2],bombs[j][2])\\n\\n\\nNow :\\n`(Math.hypot(bombs[i][0]-bombs[j][0],bombs[i][1]-bombs[j][1]) <= bombs[i][2])`"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "here is one of three result of 9: [3,6,14,15,12,11,8,16,7], start debug from item 3"
                    },
                    {
                        "username": "v447446",
                        "content": "Why are we creating a graph here? Can't we do it directly by testing for neighbourhood directly inside the dfs loop.\nI am trying to do it that way, but getting only 105 test cases passed out of 160. Please someone suggest a possible rectification.\n\n\n\nclass Solution {\n\nprivate:\n\n    long long int distance(long long int x1, long long int y1, long long int x2, long long int y2){\n        return (x2- x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n    }\n\n    void dfs(int node, vector<vector<int>>& bombs, vector <int> &visited_arr, int &size){\n\n        int rows = bombs.size();\n\n        visited_arr[node] = 1;\n        size++;\n\n        for (int i = 0; i < rows; i++){\n            \n            long long int dis = distance(bombs[node][0], bombs[node][1], bombs[i][0], bombs[i][1]);\n\n            long long int max_poss_dis = bombs[node][2];\n\n            if (i != node && dis >= 0 && dis <= max_poss_dis * max_poss_dis && !visited_arr[i]){\n                dfs(i, bombs, visited_arr, size);\n            }\n        }\n\n    }\n\npublic:\n\n\n    int maximumDetonation(vector<vector<int>>& bombs) {\n        int rows = bombs.size();\n\n        vector <int> visited_arr(rows, 0);\n        vector <int> sizes;\n\n        for (int i = 0; i < rows; i++){\n            if (!visited_arr[i]){\n                int size = 0;\n                dfs(i, bombs, visited_arr, size);\n                sizes.emplace_back(size);\n            }\n        }\n        return *max_element(sizes.begin(),sizes.end());\n    }\n};\n"
                    },
                    {
                        "username": "v447446",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) Thanks this was exactly the error.\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "This seems to be the cause of the error, line 8 from the bottom:\n>if (!visited_arr[i]){\n\nYou are supposed to clear the `visited` array before starting a fresh new DFS from the next bomb. Because the goal of our traversal is to find the count of reachable targets for the chosen bomb, not to visit every single node in the graph."
                    },
                    {
                        "username": "tungpham",
                        "content": "I like this kind of problem since it\\'s pretty straightforward and involves no trick. "
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "Half battle is won when you realize that you need to make a directed graph and brute force as nodes are only 100."
                    },
                    {
                        "username": "smashc0ughsugar",
                        "content": "Just two tips.\n1. Two different ones may have the same coordinates and radii, namely there could be a test case like this: [[2,3,4], [2,3,4]].\n2. When started at some point we have traversed the whole graph, we may just return."
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "its just a game of indices"
                    },
                    {
                        "username": "krish1237",
                        "content": "This is a maximum connected edges in a unidirected graph question. As the number of bombs is significantly less, we can afford a complexity of O(n**3). "
                    }
                ]
            },
            {
                "id": 1918199,
                "content": [
                    {
                        "username": "cookiecoop",
                        "content": "I get a time limit exceeded for last test case but input is just \"bombs = \". Is anyone else getting this?\\n"
                    },
                    {
                        "username": "dev_Louis",
                        "content": "Why does the following code will not be submitted due to the time limit? \nWhen running the code for the testcases even for larger inputs everthing is working correctly...\n\n`from math import sqrt\n\nclass Solution:\n    def __init__(self):\n        self.det_counts = []\n        self.dup_bombs = []\n        self.bombs_rel = []\n\n    def maximumDetonation(self, bombs: list[list[int]]) -> int:\n\n        # check for duplicate bombs\n        def get_dup_bombs():\n            dups = []\n            for i in range(len(bombs)):\n                for j in range(i + 1, len(bombs)):\n                    if bombs[i] == bombs[j]:\n                        dups.append(bombs[i])\n            return dups\n        self.dup_bombs = get_dup_bombs()    \n\n        def detonation(bombs_rel, bi, si):\n            if si == 0:\n                bombs_rel.append(bombs[bi])\n\n            for comp_bomb in bombs:\n                if not bombs[bi] == comp_bomb:\n                    d = sqrt(((comp_bomb[0]-bombs[bi][0])**2) + ((comp_bomb[1]-bombs[bi][1])**2))\n                    if bombs[bi][2] >= d and not comp_bomb in bombs_rel:\n                        bombs_rel.append(comp_bomb)\n\n            if not si+1 == len(bombs_rel):\n                detonation(bombs_rel, bi=bombs.index(bombs_rel[si+1]), si=si+1)\n\n        for i in range(len(bombs)):\n            self.bombs_rel = []\n            detonation(self.bombs_rel, bi=i, si=0)\n            # add duplicate bombs to final relation list\n            for bomb in self.dup_bombs:\n                if bomb in self.bombs_rel:\n                    self.bombs_rel.append(bomb)\n            self.det_counts.append(len(self.bombs_rel))\n\n        return max(self.det_counts)`"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "class Solution {\\npublic:\\n    int count = 1;\\n    void dfs (int source,vector <bool>& visited,map<int,list<int>> adj_lst){\\n\\n        visited[source] = true;\\n\\n         for (auto x : adj_lst[source]){\\n             if (!visited[x]){\\n                 dfs(x,visited,adj_lst);\\n                 count++;\\n             }\\n            \\n         }\\n    }\\n\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n    \\n    //  Graph approach\\n     if (bombs.size() == 1)return 1;\\n\\n     else {\\n        //  Creating adjacency list for the Directed Graph\\n        map <int,list<int>> adj;\\n        vector <bool> visited (bombs.size(),false);\\n        vector <int> dp(bombs.size(),1);\\n        for (int i = 0 ; i < bombs.size();i++){\\n            \\n            long long x1 = bombs[i][0];\\n            long long y1 = bombs[i][1];\\n            long long r1 = bombs[i][2];\\n            \\n            for (int j = i+1; j < bombs.size();j++){\\n                long long x2 = bombs[j][0];\\n                long long y2 = bombs[j][1];\\n                long long r2 = bombs[j][2];\\n\\n                long long dist = (x1 - x2)*(x1-x2)+ (y1 - y2)*(y1-y2);\\n                if (dist <= r1*r1){\\n                    adj[i].push_back(j);\\n                }\\n                if (dist <= r2*r2){\\n                    adj[j].push_back(i);\\n                }\\n\\n            }\\n        }\\n        int max_count = 0 ;\\n        for (int i = 0; i < bombs.size();i++){\\n            dfs(i,visited,adj);\\n            if (max_count < count){\\n                max_count = count;\\n            }\\n            fill(visited.begin(),visited.end(),false);\\n            count = 1;\\n        }\\n        return max_count;\\n\\n     }\\n\\n    }\\n};\\nIam getting TLE , can some one help "
                    },
                    {
                        "username": "piyushjo",
                        "content": "Can anyone help me find what am I missing for following test case : \\n [[855,82,158],[17,719,430],[90,756,164],[376,17,340],[691,636,152],[565,776,5],[464,154,271],[53,361,162],[278,609,82],[202,927,219],[542,865,377],[330,402,270],[720,199,10],[986,697,443],[471,296,69],[393,81,404],[127,405,177]]\\n\\n\\nApproach : \\n1. I stored what bombs a bomb can explode directly at first and added them in a list. These lists are stored in mainList as per index of first bomb exploded. \\n2. helper method will just get mainList.\\n3. help method will resolve add all the bombs a bomb at a particular index can explode by making recursive calls.\\n\\n---------------------------------------\\n\\n`\\nclass Solution {\\n    public int maximumDetonation(int[][] bombs) {\\n        List<List<Integer>> mainList = new ArrayList<>() ; \\n        \\n\\n        for(int i = 0 ; i < bombs.length ; i++){\\n            List<Integer> list = new ArrayList<>() ;\\n            for(int j = 0 ; j < bombs.length ; j++){\\n                if(j==i) continue; \\n                if(Math.hypot(bombs[i][0]-bombs[j][0],bombs[i][1]-bombs[j][1]) <= Math.max(bombs[i][2],bombs[j][2])){\\n                    list.add(j);\\n                }\\n            }\\n            mainList.add(list);\\n        }\\n        return helper(mainList);\\n    }\\n\\n    private int helper(List<List<Integer>> mainList){\\n        int num = 1;\\n         \\n        \\n        for(int i = 0 ; i < mainList.size() ; i++){\\n            if(mainList.get(i).size() == 0) continue; \\n            Set<Integer> set = new HashSet<>() ;\\n            set.add(i);\\n            help(mainList,mainList.get(i),set);\\n            num = Math.max(num,set.size());\\n        }\\n\\n        return num ; \\n    }\\n\\n    private void help(List<List<Integer>> mainList , List<Integer> list , Set<Integer> set){ \\n        for(int i = 0 ; i < list.size() ; i++){\\n            if(set.contains(list.get(i))) continue ; \\n            set.add(list.get(i));\\n            help(mainList,mainList.get(list.get(i)),set);\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "piyushjo",
                        "content": "[@tungbuivn](/tungbuivn) Thanks !!\\n\\nfollowing if condition needed to be changed for the obvious reason. \\n\\nEarlier : \\n\\nMath.hypot(bombs[i][0]-bombs[j][0],bombs[i][1]-bombs[j][1]) <= Math.max(bombs[i][2],bombs[j][2])\\n\\n\\nNow :\\n`(Math.hypot(bombs[i][0]-bombs[j][0],bombs[i][1]-bombs[j][1]) <= bombs[i][2])`"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "here is one of three result of 9: [3,6,14,15,12,11,8,16,7], start debug from item 3"
                    },
                    {
                        "username": "v447446",
                        "content": "Why are we creating a graph here? Can't we do it directly by testing for neighbourhood directly inside the dfs loop.\nI am trying to do it that way, but getting only 105 test cases passed out of 160. Please someone suggest a possible rectification.\n\n\n\nclass Solution {\n\nprivate:\n\n    long long int distance(long long int x1, long long int y1, long long int x2, long long int y2){\n        return (x2- x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n    }\n\n    void dfs(int node, vector<vector<int>>& bombs, vector <int> &visited_arr, int &size){\n\n        int rows = bombs.size();\n\n        visited_arr[node] = 1;\n        size++;\n\n        for (int i = 0; i < rows; i++){\n            \n            long long int dis = distance(bombs[node][0], bombs[node][1], bombs[i][0], bombs[i][1]);\n\n            long long int max_poss_dis = bombs[node][2];\n\n            if (i != node && dis >= 0 && dis <= max_poss_dis * max_poss_dis && !visited_arr[i]){\n                dfs(i, bombs, visited_arr, size);\n            }\n        }\n\n    }\n\npublic:\n\n\n    int maximumDetonation(vector<vector<int>>& bombs) {\n        int rows = bombs.size();\n\n        vector <int> visited_arr(rows, 0);\n        vector <int> sizes;\n\n        for (int i = 0; i < rows; i++){\n            if (!visited_arr[i]){\n                int size = 0;\n                dfs(i, bombs, visited_arr, size);\n                sizes.emplace_back(size);\n            }\n        }\n        return *max_element(sizes.begin(),sizes.end());\n    }\n};\n"
                    },
                    {
                        "username": "v447446",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) Thanks this was exactly the error.\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "This seems to be the cause of the error, line 8 from the bottom:\n>if (!visited_arr[i]){\n\nYou are supposed to clear the `visited` array before starting a fresh new DFS from the next bomb. Because the goal of our traversal is to find the count of reachable targets for the chosen bomb, not to visit every single node in the graph."
                    },
                    {
                        "username": "tungpham",
                        "content": "I like this kind of problem since it\\'s pretty straightforward and involves no trick. "
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "Half battle is won when you realize that you need to make a directed graph and brute force as nodes are only 100."
                    },
                    {
                        "username": "smashc0ughsugar",
                        "content": "Just two tips.\n1. Two different ones may have the same coordinates and radii, namely there could be a test case like this: [[2,3,4], [2,3,4]].\n2. When started at some point we have traversed the whole graph, we may just return."
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "its just a game of indices"
                    },
                    {
                        "username": "krish1237",
                        "content": "This is a maximum connected edges in a unidirected graph question. As the number of bombs is significantly less, we can afford a complexity of O(n**3). "
                    }
                ]
            },
            {
                "id": 1918178,
                "content": [
                    {
                        "username": "cookiecoop",
                        "content": "I get a time limit exceeded for last test case but input is just \"bombs = \". Is anyone else getting this?\\n"
                    },
                    {
                        "username": "dev_Louis",
                        "content": "Why does the following code will not be submitted due to the time limit? \nWhen running the code for the testcases even for larger inputs everthing is working correctly...\n\n`from math import sqrt\n\nclass Solution:\n    def __init__(self):\n        self.det_counts = []\n        self.dup_bombs = []\n        self.bombs_rel = []\n\n    def maximumDetonation(self, bombs: list[list[int]]) -> int:\n\n        # check for duplicate bombs\n        def get_dup_bombs():\n            dups = []\n            for i in range(len(bombs)):\n                for j in range(i + 1, len(bombs)):\n                    if bombs[i] == bombs[j]:\n                        dups.append(bombs[i])\n            return dups\n        self.dup_bombs = get_dup_bombs()    \n\n        def detonation(bombs_rel, bi, si):\n            if si == 0:\n                bombs_rel.append(bombs[bi])\n\n            for comp_bomb in bombs:\n                if not bombs[bi] == comp_bomb:\n                    d = sqrt(((comp_bomb[0]-bombs[bi][0])**2) + ((comp_bomb[1]-bombs[bi][1])**2))\n                    if bombs[bi][2] >= d and not comp_bomb in bombs_rel:\n                        bombs_rel.append(comp_bomb)\n\n            if not si+1 == len(bombs_rel):\n                detonation(bombs_rel, bi=bombs.index(bombs_rel[si+1]), si=si+1)\n\n        for i in range(len(bombs)):\n            self.bombs_rel = []\n            detonation(self.bombs_rel, bi=i, si=0)\n            # add duplicate bombs to final relation list\n            for bomb in self.dup_bombs:\n                if bomb in self.bombs_rel:\n                    self.bombs_rel.append(bomb)\n            self.det_counts.append(len(self.bombs_rel))\n\n        return max(self.det_counts)`"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "class Solution {\\npublic:\\n    int count = 1;\\n    void dfs (int source,vector <bool>& visited,map<int,list<int>> adj_lst){\\n\\n        visited[source] = true;\\n\\n         for (auto x : adj_lst[source]){\\n             if (!visited[x]){\\n                 dfs(x,visited,adj_lst);\\n                 count++;\\n             }\\n            \\n         }\\n    }\\n\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n    \\n    //  Graph approach\\n     if (bombs.size() == 1)return 1;\\n\\n     else {\\n        //  Creating adjacency list for the Directed Graph\\n        map <int,list<int>> adj;\\n        vector <bool> visited (bombs.size(),false);\\n        vector <int> dp(bombs.size(),1);\\n        for (int i = 0 ; i < bombs.size();i++){\\n            \\n            long long x1 = bombs[i][0];\\n            long long y1 = bombs[i][1];\\n            long long r1 = bombs[i][2];\\n            \\n            for (int j = i+1; j < bombs.size();j++){\\n                long long x2 = bombs[j][0];\\n                long long y2 = bombs[j][1];\\n                long long r2 = bombs[j][2];\\n\\n                long long dist = (x1 - x2)*(x1-x2)+ (y1 - y2)*(y1-y2);\\n                if (dist <= r1*r1){\\n                    adj[i].push_back(j);\\n                }\\n                if (dist <= r2*r2){\\n                    adj[j].push_back(i);\\n                }\\n\\n            }\\n        }\\n        int max_count = 0 ;\\n        for (int i = 0; i < bombs.size();i++){\\n            dfs(i,visited,adj);\\n            if (max_count < count){\\n                max_count = count;\\n            }\\n            fill(visited.begin(),visited.end(),false);\\n            count = 1;\\n        }\\n        return max_count;\\n\\n     }\\n\\n    }\\n};\\nIam getting TLE , can some one help "
                    },
                    {
                        "username": "piyushjo",
                        "content": "Can anyone help me find what am I missing for following test case : \\n [[855,82,158],[17,719,430],[90,756,164],[376,17,340],[691,636,152],[565,776,5],[464,154,271],[53,361,162],[278,609,82],[202,927,219],[542,865,377],[330,402,270],[720,199,10],[986,697,443],[471,296,69],[393,81,404],[127,405,177]]\\n\\n\\nApproach : \\n1. I stored what bombs a bomb can explode directly at first and added them in a list. These lists are stored in mainList as per index of first bomb exploded. \\n2. helper method will just get mainList.\\n3. help method will resolve add all the bombs a bomb at a particular index can explode by making recursive calls.\\n\\n---------------------------------------\\n\\n`\\nclass Solution {\\n    public int maximumDetonation(int[][] bombs) {\\n        List<List<Integer>> mainList = new ArrayList<>() ; \\n        \\n\\n        for(int i = 0 ; i < bombs.length ; i++){\\n            List<Integer> list = new ArrayList<>() ;\\n            for(int j = 0 ; j < bombs.length ; j++){\\n                if(j==i) continue; \\n                if(Math.hypot(bombs[i][0]-bombs[j][0],bombs[i][1]-bombs[j][1]) <= Math.max(bombs[i][2],bombs[j][2])){\\n                    list.add(j);\\n                }\\n            }\\n            mainList.add(list);\\n        }\\n        return helper(mainList);\\n    }\\n\\n    private int helper(List<List<Integer>> mainList){\\n        int num = 1;\\n         \\n        \\n        for(int i = 0 ; i < mainList.size() ; i++){\\n            if(mainList.get(i).size() == 0) continue; \\n            Set<Integer> set = new HashSet<>() ;\\n            set.add(i);\\n            help(mainList,mainList.get(i),set);\\n            num = Math.max(num,set.size());\\n        }\\n\\n        return num ; \\n    }\\n\\n    private void help(List<List<Integer>> mainList , List<Integer> list , Set<Integer> set){ \\n        for(int i = 0 ; i < list.size() ; i++){\\n            if(set.contains(list.get(i))) continue ; \\n            set.add(list.get(i));\\n            help(mainList,mainList.get(list.get(i)),set);\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "piyushjo",
                        "content": "[@tungbuivn](/tungbuivn) Thanks !!\\n\\nfollowing if condition needed to be changed for the obvious reason. \\n\\nEarlier : \\n\\nMath.hypot(bombs[i][0]-bombs[j][0],bombs[i][1]-bombs[j][1]) <= Math.max(bombs[i][2],bombs[j][2])\\n\\n\\nNow :\\n`(Math.hypot(bombs[i][0]-bombs[j][0],bombs[i][1]-bombs[j][1]) <= bombs[i][2])`"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "here is one of three result of 9: [3,6,14,15,12,11,8,16,7], start debug from item 3"
                    },
                    {
                        "username": "v447446",
                        "content": "Why are we creating a graph here? Can't we do it directly by testing for neighbourhood directly inside the dfs loop.\nI am trying to do it that way, but getting only 105 test cases passed out of 160. Please someone suggest a possible rectification.\n\n\n\nclass Solution {\n\nprivate:\n\n    long long int distance(long long int x1, long long int y1, long long int x2, long long int y2){\n        return (x2- x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n    }\n\n    void dfs(int node, vector<vector<int>>& bombs, vector <int> &visited_arr, int &size){\n\n        int rows = bombs.size();\n\n        visited_arr[node] = 1;\n        size++;\n\n        for (int i = 0; i < rows; i++){\n            \n            long long int dis = distance(bombs[node][0], bombs[node][1], bombs[i][0], bombs[i][1]);\n\n            long long int max_poss_dis = bombs[node][2];\n\n            if (i != node && dis >= 0 && dis <= max_poss_dis * max_poss_dis && !visited_arr[i]){\n                dfs(i, bombs, visited_arr, size);\n            }\n        }\n\n    }\n\npublic:\n\n\n    int maximumDetonation(vector<vector<int>>& bombs) {\n        int rows = bombs.size();\n\n        vector <int> visited_arr(rows, 0);\n        vector <int> sizes;\n\n        for (int i = 0; i < rows; i++){\n            if (!visited_arr[i]){\n                int size = 0;\n                dfs(i, bombs, visited_arr, size);\n                sizes.emplace_back(size);\n            }\n        }\n        return *max_element(sizes.begin(),sizes.end());\n    }\n};\n"
                    },
                    {
                        "username": "v447446",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) Thanks this was exactly the error.\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "This seems to be the cause of the error, line 8 from the bottom:\n>if (!visited_arr[i]){\n\nYou are supposed to clear the `visited` array before starting a fresh new DFS from the next bomb. Because the goal of our traversal is to find the count of reachable targets for the chosen bomb, not to visit every single node in the graph."
                    },
                    {
                        "username": "tungpham",
                        "content": "I like this kind of problem since it\\'s pretty straightforward and involves no trick. "
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "Half battle is won when you realize that you need to make a directed graph and brute force as nodes are only 100."
                    },
                    {
                        "username": "smashc0ughsugar",
                        "content": "Just two tips.\n1. Two different ones may have the same coordinates and radii, namely there could be a test case like this: [[2,3,4], [2,3,4]].\n2. When started at some point we have traversed the whole graph, we may just return."
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "its just a game of indices"
                    },
                    {
                        "username": "krish1237",
                        "content": "This is a maximum connected edges in a unidirected graph question. As the number of bombs is significantly less, we can afford a complexity of O(n**3). "
                    }
                ]
            },
            {
                "id": 1917717,
                "content": [
                    {
                        "username": "cookiecoop",
                        "content": "I get a time limit exceeded for last test case but input is just \"bombs = \". Is anyone else getting this?\\n"
                    },
                    {
                        "username": "dev_Louis",
                        "content": "Why does the following code will not be submitted due to the time limit? \nWhen running the code for the testcases even for larger inputs everthing is working correctly...\n\n`from math import sqrt\n\nclass Solution:\n    def __init__(self):\n        self.det_counts = []\n        self.dup_bombs = []\n        self.bombs_rel = []\n\n    def maximumDetonation(self, bombs: list[list[int]]) -> int:\n\n        # check for duplicate bombs\n        def get_dup_bombs():\n            dups = []\n            for i in range(len(bombs)):\n                for j in range(i + 1, len(bombs)):\n                    if bombs[i] == bombs[j]:\n                        dups.append(bombs[i])\n            return dups\n        self.dup_bombs = get_dup_bombs()    \n\n        def detonation(bombs_rel, bi, si):\n            if si == 0:\n                bombs_rel.append(bombs[bi])\n\n            for comp_bomb in bombs:\n                if not bombs[bi] == comp_bomb:\n                    d = sqrt(((comp_bomb[0]-bombs[bi][0])**2) + ((comp_bomb[1]-bombs[bi][1])**2))\n                    if bombs[bi][2] >= d and not comp_bomb in bombs_rel:\n                        bombs_rel.append(comp_bomb)\n\n            if not si+1 == len(bombs_rel):\n                detonation(bombs_rel, bi=bombs.index(bombs_rel[si+1]), si=si+1)\n\n        for i in range(len(bombs)):\n            self.bombs_rel = []\n            detonation(self.bombs_rel, bi=i, si=0)\n            # add duplicate bombs to final relation list\n            for bomb in self.dup_bombs:\n                if bomb in self.bombs_rel:\n                    self.bombs_rel.append(bomb)\n            self.det_counts.append(len(self.bombs_rel))\n\n        return max(self.det_counts)`"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "class Solution {\\npublic:\\n    int count = 1;\\n    void dfs (int source,vector <bool>& visited,map<int,list<int>> adj_lst){\\n\\n        visited[source] = true;\\n\\n         for (auto x : adj_lst[source]){\\n             if (!visited[x]){\\n                 dfs(x,visited,adj_lst);\\n                 count++;\\n             }\\n            \\n         }\\n    }\\n\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n    \\n    //  Graph approach\\n     if (bombs.size() == 1)return 1;\\n\\n     else {\\n        //  Creating adjacency list for the Directed Graph\\n        map <int,list<int>> adj;\\n        vector <bool> visited (bombs.size(),false);\\n        vector <int> dp(bombs.size(),1);\\n        for (int i = 0 ; i < bombs.size();i++){\\n            \\n            long long x1 = bombs[i][0];\\n            long long y1 = bombs[i][1];\\n            long long r1 = bombs[i][2];\\n            \\n            for (int j = i+1; j < bombs.size();j++){\\n                long long x2 = bombs[j][0];\\n                long long y2 = bombs[j][1];\\n                long long r2 = bombs[j][2];\\n\\n                long long dist = (x1 - x2)*(x1-x2)+ (y1 - y2)*(y1-y2);\\n                if (dist <= r1*r1){\\n                    adj[i].push_back(j);\\n                }\\n                if (dist <= r2*r2){\\n                    adj[j].push_back(i);\\n                }\\n\\n            }\\n        }\\n        int max_count = 0 ;\\n        for (int i = 0; i < bombs.size();i++){\\n            dfs(i,visited,adj);\\n            if (max_count < count){\\n                max_count = count;\\n            }\\n            fill(visited.begin(),visited.end(),false);\\n            count = 1;\\n        }\\n        return max_count;\\n\\n     }\\n\\n    }\\n};\\nIam getting TLE , can some one help "
                    },
                    {
                        "username": "piyushjo",
                        "content": "Can anyone help me find what am I missing for following test case : \\n [[855,82,158],[17,719,430],[90,756,164],[376,17,340],[691,636,152],[565,776,5],[464,154,271],[53,361,162],[278,609,82],[202,927,219],[542,865,377],[330,402,270],[720,199,10],[986,697,443],[471,296,69],[393,81,404],[127,405,177]]\\n\\n\\nApproach : \\n1. I stored what bombs a bomb can explode directly at first and added them in a list. These lists are stored in mainList as per index of first bomb exploded. \\n2. helper method will just get mainList.\\n3. help method will resolve add all the bombs a bomb at a particular index can explode by making recursive calls.\\n\\n---------------------------------------\\n\\n`\\nclass Solution {\\n    public int maximumDetonation(int[][] bombs) {\\n        List<List<Integer>> mainList = new ArrayList<>() ; \\n        \\n\\n        for(int i = 0 ; i < bombs.length ; i++){\\n            List<Integer> list = new ArrayList<>() ;\\n            for(int j = 0 ; j < bombs.length ; j++){\\n                if(j==i) continue; \\n                if(Math.hypot(bombs[i][0]-bombs[j][0],bombs[i][1]-bombs[j][1]) <= Math.max(bombs[i][2],bombs[j][2])){\\n                    list.add(j);\\n                }\\n            }\\n            mainList.add(list);\\n        }\\n        return helper(mainList);\\n    }\\n\\n    private int helper(List<List<Integer>> mainList){\\n        int num = 1;\\n         \\n        \\n        for(int i = 0 ; i < mainList.size() ; i++){\\n            if(mainList.get(i).size() == 0) continue; \\n            Set<Integer> set = new HashSet<>() ;\\n            set.add(i);\\n            help(mainList,mainList.get(i),set);\\n            num = Math.max(num,set.size());\\n        }\\n\\n        return num ; \\n    }\\n\\n    private void help(List<List<Integer>> mainList , List<Integer> list , Set<Integer> set){ \\n        for(int i = 0 ; i < list.size() ; i++){\\n            if(set.contains(list.get(i))) continue ; \\n            set.add(list.get(i));\\n            help(mainList,mainList.get(list.get(i)),set);\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "piyushjo",
                        "content": "[@tungbuivn](/tungbuivn) Thanks !!\\n\\nfollowing if condition needed to be changed for the obvious reason. \\n\\nEarlier : \\n\\nMath.hypot(bombs[i][0]-bombs[j][0],bombs[i][1]-bombs[j][1]) <= Math.max(bombs[i][2],bombs[j][2])\\n\\n\\nNow :\\n`(Math.hypot(bombs[i][0]-bombs[j][0],bombs[i][1]-bombs[j][1]) <= bombs[i][2])`"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "here is one of three result of 9: [3,6,14,15,12,11,8,16,7], start debug from item 3"
                    },
                    {
                        "username": "v447446",
                        "content": "Why are we creating a graph here? Can't we do it directly by testing for neighbourhood directly inside the dfs loop.\nI am trying to do it that way, but getting only 105 test cases passed out of 160. Please someone suggest a possible rectification.\n\n\n\nclass Solution {\n\nprivate:\n\n    long long int distance(long long int x1, long long int y1, long long int x2, long long int y2){\n        return (x2- x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n    }\n\n    void dfs(int node, vector<vector<int>>& bombs, vector <int> &visited_arr, int &size){\n\n        int rows = bombs.size();\n\n        visited_arr[node] = 1;\n        size++;\n\n        for (int i = 0; i < rows; i++){\n            \n            long long int dis = distance(bombs[node][0], bombs[node][1], bombs[i][0], bombs[i][1]);\n\n            long long int max_poss_dis = bombs[node][2];\n\n            if (i != node && dis >= 0 && dis <= max_poss_dis * max_poss_dis && !visited_arr[i]){\n                dfs(i, bombs, visited_arr, size);\n            }\n        }\n\n    }\n\npublic:\n\n\n    int maximumDetonation(vector<vector<int>>& bombs) {\n        int rows = bombs.size();\n\n        vector <int> visited_arr(rows, 0);\n        vector <int> sizes;\n\n        for (int i = 0; i < rows; i++){\n            if (!visited_arr[i]){\n                int size = 0;\n                dfs(i, bombs, visited_arr, size);\n                sizes.emplace_back(size);\n            }\n        }\n        return *max_element(sizes.begin(),sizes.end());\n    }\n};\n"
                    },
                    {
                        "username": "v447446",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) Thanks this was exactly the error.\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "This seems to be the cause of the error, line 8 from the bottom:\n>if (!visited_arr[i]){\n\nYou are supposed to clear the `visited` array before starting a fresh new DFS from the next bomb. Because the goal of our traversal is to find the count of reachable targets for the chosen bomb, not to visit every single node in the graph."
                    },
                    {
                        "username": "tungpham",
                        "content": "I like this kind of problem since it\\'s pretty straightforward and involves no trick. "
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "Half battle is won when you realize that you need to make a directed graph and brute force as nodes are only 100."
                    },
                    {
                        "username": "smashc0ughsugar",
                        "content": "Just two tips.\n1. Two different ones may have the same coordinates and radii, namely there could be a test case like this: [[2,3,4], [2,3,4]].\n2. When started at some point we have traversed the whole graph, we may just return."
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "its just a game of indices"
                    },
                    {
                        "username": "krish1237",
                        "content": "This is a maximum connected edges in a unidirected graph question. As the number of bombs is significantly less, we can afford a complexity of O(n**3). "
                    }
                ]
            },
            {
                "id": 1916581,
                "content": [
                    {
                        "username": "cookiecoop",
                        "content": "I get a time limit exceeded for last test case but input is just \"bombs = \". Is anyone else getting this?\\n"
                    },
                    {
                        "username": "dev_Louis",
                        "content": "Why does the following code will not be submitted due to the time limit? \nWhen running the code for the testcases even for larger inputs everthing is working correctly...\n\n`from math import sqrt\n\nclass Solution:\n    def __init__(self):\n        self.det_counts = []\n        self.dup_bombs = []\n        self.bombs_rel = []\n\n    def maximumDetonation(self, bombs: list[list[int]]) -> int:\n\n        # check for duplicate bombs\n        def get_dup_bombs():\n            dups = []\n            for i in range(len(bombs)):\n                for j in range(i + 1, len(bombs)):\n                    if bombs[i] == bombs[j]:\n                        dups.append(bombs[i])\n            return dups\n        self.dup_bombs = get_dup_bombs()    \n\n        def detonation(bombs_rel, bi, si):\n            if si == 0:\n                bombs_rel.append(bombs[bi])\n\n            for comp_bomb in bombs:\n                if not bombs[bi] == comp_bomb:\n                    d = sqrt(((comp_bomb[0]-bombs[bi][0])**2) + ((comp_bomb[1]-bombs[bi][1])**2))\n                    if bombs[bi][2] >= d and not comp_bomb in bombs_rel:\n                        bombs_rel.append(comp_bomb)\n\n            if not si+1 == len(bombs_rel):\n                detonation(bombs_rel, bi=bombs.index(bombs_rel[si+1]), si=si+1)\n\n        for i in range(len(bombs)):\n            self.bombs_rel = []\n            detonation(self.bombs_rel, bi=i, si=0)\n            # add duplicate bombs to final relation list\n            for bomb in self.dup_bombs:\n                if bomb in self.bombs_rel:\n                    self.bombs_rel.append(bomb)\n            self.det_counts.append(len(self.bombs_rel))\n\n        return max(self.det_counts)`"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "class Solution {\\npublic:\\n    int count = 1;\\n    void dfs (int source,vector <bool>& visited,map<int,list<int>> adj_lst){\\n\\n        visited[source] = true;\\n\\n         for (auto x : adj_lst[source]){\\n             if (!visited[x]){\\n                 dfs(x,visited,adj_lst);\\n                 count++;\\n             }\\n            \\n         }\\n    }\\n\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n    \\n    //  Graph approach\\n     if (bombs.size() == 1)return 1;\\n\\n     else {\\n        //  Creating adjacency list for the Directed Graph\\n        map <int,list<int>> adj;\\n        vector <bool> visited (bombs.size(),false);\\n        vector <int> dp(bombs.size(),1);\\n        for (int i = 0 ; i < bombs.size();i++){\\n            \\n            long long x1 = bombs[i][0];\\n            long long y1 = bombs[i][1];\\n            long long r1 = bombs[i][2];\\n            \\n            for (int j = i+1; j < bombs.size();j++){\\n                long long x2 = bombs[j][0];\\n                long long y2 = bombs[j][1];\\n                long long r2 = bombs[j][2];\\n\\n                long long dist = (x1 - x2)*(x1-x2)+ (y1 - y2)*(y1-y2);\\n                if (dist <= r1*r1){\\n                    adj[i].push_back(j);\\n                }\\n                if (dist <= r2*r2){\\n                    adj[j].push_back(i);\\n                }\\n\\n            }\\n        }\\n        int max_count = 0 ;\\n        for (int i = 0; i < bombs.size();i++){\\n            dfs(i,visited,adj);\\n            if (max_count < count){\\n                max_count = count;\\n            }\\n            fill(visited.begin(),visited.end(),false);\\n            count = 1;\\n        }\\n        return max_count;\\n\\n     }\\n\\n    }\\n};\\nIam getting TLE , can some one help "
                    },
                    {
                        "username": "piyushjo",
                        "content": "Can anyone help me find what am I missing for following test case : \\n [[855,82,158],[17,719,430],[90,756,164],[376,17,340],[691,636,152],[565,776,5],[464,154,271],[53,361,162],[278,609,82],[202,927,219],[542,865,377],[330,402,270],[720,199,10],[986,697,443],[471,296,69],[393,81,404],[127,405,177]]\\n\\n\\nApproach : \\n1. I stored what bombs a bomb can explode directly at first and added them in a list. These lists are stored in mainList as per index of first bomb exploded. \\n2. helper method will just get mainList.\\n3. help method will resolve add all the bombs a bomb at a particular index can explode by making recursive calls.\\n\\n---------------------------------------\\n\\n`\\nclass Solution {\\n    public int maximumDetonation(int[][] bombs) {\\n        List<List<Integer>> mainList = new ArrayList<>() ; \\n        \\n\\n        for(int i = 0 ; i < bombs.length ; i++){\\n            List<Integer> list = new ArrayList<>() ;\\n            for(int j = 0 ; j < bombs.length ; j++){\\n                if(j==i) continue; \\n                if(Math.hypot(bombs[i][0]-bombs[j][0],bombs[i][1]-bombs[j][1]) <= Math.max(bombs[i][2],bombs[j][2])){\\n                    list.add(j);\\n                }\\n            }\\n            mainList.add(list);\\n        }\\n        return helper(mainList);\\n    }\\n\\n    private int helper(List<List<Integer>> mainList){\\n        int num = 1;\\n         \\n        \\n        for(int i = 0 ; i < mainList.size() ; i++){\\n            if(mainList.get(i).size() == 0) continue; \\n            Set<Integer> set = new HashSet<>() ;\\n            set.add(i);\\n            help(mainList,mainList.get(i),set);\\n            num = Math.max(num,set.size());\\n        }\\n\\n        return num ; \\n    }\\n\\n    private void help(List<List<Integer>> mainList , List<Integer> list , Set<Integer> set){ \\n        for(int i = 0 ; i < list.size() ; i++){\\n            if(set.contains(list.get(i))) continue ; \\n            set.add(list.get(i));\\n            help(mainList,mainList.get(list.get(i)),set);\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "piyushjo",
                        "content": "[@tungbuivn](/tungbuivn) Thanks !!\\n\\nfollowing if condition needed to be changed for the obvious reason. \\n\\nEarlier : \\n\\nMath.hypot(bombs[i][0]-bombs[j][0],bombs[i][1]-bombs[j][1]) <= Math.max(bombs[i][2],bombs[j][2])\\n\\n\\nNow :\\n`(Math.hypot(bombs[i][0]-bombs[j][0],bombs[i][1]-bombs[j][1]) <= bombs[i][2])`"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "here is one of three result of 9: [3,6,14,15,12,11,8,16,7], start debug from item 3"
                    },
                    {
                        "username": "v447446",
                        "content": "Why are we creating a graph here? Can't we do it directly by testing for neighbourhood directly inside the dfs loop.\nI am trying to do it that way, but getting only 105 test cases passed out of 160. Please someone suggest a possible rectification.\n\n\n\nclass Solution {\n\nprivate:\n\n    long long int distance(long long int x1, long long int y1, long long int x2, long long int y2){\n        return (x2- x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n    }\n\n    void dfs(int node, vector<vector<int>>& bombs, vector <int> &visited_arr, int &size){\n\n        int rows = bombs.size();\n\n        visited_arr[node] = 1;\n        size++;\n\n        for (int i = 0; i < rows; i++){\n            \n            long long int dis = distance(bombs[node][0], bombs[node][1], bombs[i][0], bombs[i][1]);\n\n            long long int max_poss_dis = bombs[node][2];\n\n            if (i != node && dis >= 0 && dis <= max_poss_dis * max_poss_dis && !visited_arr[i]){\n                dfs(i, bombs, visited_arr, size);\n            }\n        }\n\n    }\n\npublic:\n\n\n    int maximumDetonation(vector<vector<int>>& bombs) {\n        int rows = bombs.size();\n\n        vector <int> visited_arr(rows, 0);\n        vector <int> sizes;\n\n        for (int i = 0; i < rows; i++){\n            if (!visited_arr[i]){\n                int size = 0;\n                dfs(i, bombs, visited_arr, size);\n                sizes.emplace_back(size);\n            }\n        }\n        return *max_element(sizes.begin(),sizes.end());\n    }\n};\n"
                    },
                    {
                        "username": "v447446",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) Thanks this was exactly the error.\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "This seems to be the cause of the error, line 8 from the bottom:\n>if (!visited_arr[i]){\n\nYou are supposed to clear the `visited` array before starting a fresh new DFS from the next bomb. Because the goal of our traversal is to find the count of reachable targets for the chosen bomb, not to visit every single node in the graph."
                    },
                    {
                        "username": "tungpham",
                        "content": "I like this kind of problem since it\\'s pretty straightforward and involves no trick. "
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "Half battle is won when you realize that you need to make a directed graph and brute force as nodes are only 100."
                    },
                    {
                        "username": "smashc0ughsugar",
                        "content": "Just two tips.\n1. Two different ones may have the same coordinates and radii, namely there could be a test case like this: [[2,3,4], [2,3,4]].\n2. When started at some point we have traversed the whole graph, we may just return."
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "its just a game of indices"
                    },
                    {
                        "username": "krish1237",
                        "content": "This is a maximum connected edges in a unidirected graph question. As the number of bombs is significantly less, we can afford a complexity of O(n**3). "
                    }
                ]
            },
            {
                "id": 1914666,
                "content": [
                    {
                        "username": "cookiecoop",
                        "content": "I get a time limit exceeded for last test case but input is just \"bombs = \". Is anyone else getting this?\\n"
                    },
                    {
                        "username": "dev_Louis",
                        "content": "Why does the following code will not be submitted due to the time limit? \nWhen running the code for the testcases even for larger inputs everthing is working correctly...\n\n`from math import sqrt\n\nclass Solution:\n    def __init__(self):\n        self.det_counts = []\n        self.dup_bombs = []\n        self.bombs_rel = []\n\n    def maximumDetonation(self, bombs: list[list[int]]) -> int:\n\n        # check for duplicate bombs\n        def get_dup_bombs():\n            dups = []\n            for i in range(len(bombs)):\n                for j in range(i + 1, len(bombs)):\n                    if bombs[i] == bombs[j]:\n                        dups.append(bombs[i])\n            return dups\n        self.dup_bombs = get_dup_bombs()    \n\n        def detonation(bombs_rel, bi, si):\n            if si == 0:\n                bombs_rel.append(bombs[bi])\n\n            for comp_bomb in bombs:\n                if not bombs[bi] == comp_bomb:\n                    d = sqrt(((comp_bomb[0]-bombs[bi][0])**2) + ((comp_bomb[1]-bombs[bi][1])**2))\n                    if bombs[bi][2] >= d and not comp_bomb in bombs_rel:\n                        bombs_rel.append(comp_bomb)\n\n            if not si+1 == len(bombs_rel):\n                detonation(bombs_rel, bi=bombs.index(bombs_rel[si+1]), si=si+1)\n\n        for i in range(len(bombs)):\n            self.bombs_rel = []\n            detonation(self.bombs_rel, bi=i, si=0)\n            # add duplicate bombs to final relation list\n            for bomb in self.dup_bombs:\n                if bomb in self.bombs_rel:\n                    self.bombs_rel.append(bomb)\n            self.det_counts.append(len(self.bombs_rel))\n\n        return max(self.det_counts)`"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "class Solution {\\npublic:\\n    int count = 1;\\n    void dfs (int source,vector <bool>& visited,map<int,list<int>> adj_lst){\\n\\n        visited[source] = true;\\n\\n         for (auto x : adj_lst[source]){\\n             if (!visited[x]){\\n                 dfs(x,visited,adj_lst);\\n                 count++;\\n             }\\n            \\n         }\\n    }\\n\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n    \\n    //  Graph approach\\n     if (bombs.size() == 1)return 1;\\n\\n     else {\\n        //  Creating adjacency list for the Directed Graph\\n        map <int,list<int>> adj;\\n        vector <bool> visited (bombs.size(),false);\\n        vector <int> dp(bombs.size(),1);\\n        for (int i = 0 ; i < bombs.size();i++){\\n            \\n            long long x1 = bombs[i][0];\\n            long long y1 = bombs[i][1];\\n            long long r1 = bombs[i][2];\\n            \\n            for (int j = i+1; j < bombs.size();j++){\\n                long long x2 = bombs[j][0];\\n                long long y2 = bombs[j][1];\\n                long long r2 = bombs[j][2];\\n\\n                long long dist = (x1 - x2)*(x1-x2)+ (y1 - y2)*(y1-y2);\\n                if (dist <= r1*r1){\\n                    adj[i].push_back(j);\\n                }\\n                if (dist <= r2*r2){\\n                    adj[j].push_back(i);\\n                }\\n\\n            }\\n        }\\n        int max_count = 0 ;\\n        for (int i = 0; i < bombs.size();i++){\\n            dfs(i,visited,adj);\\n            if (max_count < count){\\n                max_count = count;\\n            }\\n            fill(visited.begin(),visited.end(),false);\\n            count = 1;\\n        }\\n        return max_count;\\n\\n     }\\n\\n    }\\n};\\nIam getting TLE , can some one help "
                    },
                    {
                        "username": "piyushjo",
                        "content": "Can anyone help me find what am I missing for following test case : \\n [[855,82,158],[17,719,430],[90,756,164],[376,17,340],[691,636,152],[565,776,5],[464,154,271],[53,361,162],[278,609,82],[202,927,219],[542,865,377],[330,402,270],[720,199,10],[986,697,443],[471,296,69],[393,81,404],[127,405,177]]\\n\\n\\nApproach : \\n1. I stored what bombs a bomb can explode directly at first and added them in a list. These lists are stored in mainList as per index of first bomb exploded. \\n2. helper method will just get mainList.\\n3. help method will resolve add all the bombs a bomb at a particular index can explode by making recursive calls.\\n\\n---------------------------------------\\n\\n`\\nclass Solution {\\n    public int maximumDetonation(int[][] bombs) {\\n        List<List<Integer>> mainList = new ArrayList<>() ; \\n        \\n\\n        for(int i = 0 ; i < bombs.length ; i++){\\n            List<Integer> list = new ArrayList<>() ;\\n            for(int j = 0 ; j < bombs.length ; j++){\\n                if(j==i) continue; \\n                if(Math.hypot(bombs[i][0]-bombs[j][0],bombs[i][1]-bombs[j][1]) <= Math.max(bombs[i][2],bombs[j][2])){\\n                    list.add(j);\\n                }\\n            }\\n            mainList.add(list);\\n        }\\n        return helper(mainList);\\n    }\\n\\n    private int helper(List<List<Integer>> mainList){\\n        int num = 1;\\n         \\n        \\n        for(int i = 0 ; i < mainList.size() ; i++){\\n            if(mainList.get(i).size() == 0) continue; \\n            Set<Integer> set = new HashSet<>() ;\\n            set.add(i);\\n            help(mainList,mainList.get(i),set);\\n            num = Math.max(num,set.size());\\n        }\\n\\n        return num ; \\n    }\\n\\n    private void help(List<List<Integer>> mainList , List<Integer> list , Set<Integer> set){ \\n        for(int i = 0 ; i < list.size() ; i++){\\n            if(set.contains(list.get(i))) continue ; \\n            set.add(list.get(i));\\n            help(mainList,mainList.get(list.get(i)),set);\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "piyushjo",
                        "content": "[@tungbuivn](/tungbuivn) Thanks !!\\n\\nfollowing if condition needed to be changed for the obvious reason. \\n\\nEarlier : \\n\\nMath.hypot(bombs[i][0]-bombs[j][0],bombs[i][1]-bombs[j][1]) <= Math.max(bombs[i][2],bombs[j][2])\\n\\n\\nNow :\\n`(Math.hypot(bombs[i][0]-bombs[j][0],bombs[i][1]-bombs[j][1]) <= bombs[i][2])`"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "here is one of three result of 9: [3,6,14,15,12,11,8,16,7], start debug from item 3"
                    },
                    {
                        "username": "v447446",
                        "content": "Why are we creating a graph here? Can't we do it directly by testing for neighbourhood directly inside the dfs loop.\nI am trying to do it that way, but getting only 105 test cases passed out of 160. Please someone suggest a possible rectification.\n\n\n\nclass Solution {\n\nprivate:\n\n    long long int distance(long long int x1, long long int y1, long long int x2, long long int y2){\n        return (x2- x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n    }\n\n    void dfs(int node, vector<vector<int>>& bombs, vector <int> &visited_arr, int &size){\n\n        int rows = bombs.size();\n\n        visited_arr[node] = 1;\n        size++;\n\n        for (int i = 0; i < rows; i++){\n            \n            long long int dis = distance(bombs[node][0], bombs[node][1], bombs[i][0], bombs[i][1]);\n\n            long long int max_poss_dis = bombs[node][2];\n\n            if (i != node && dis >= 0 && dis <= max_poss_dis * max_poss_dis && !visited_arr[i]){\n                dfs(i, bombs, visited_arr, size);\n            }\n        }\n\n    }\n\npublic:\n\n\n    int maximumDetonation(vector<vector<int>>& bombs) {\n        int rows = bombs.size();\n\n        vector <int> visited_arr(rows, 0);\n        vector <int> sizes;\n\n        for (int i = 0; i < rows; i++){\n            if (!visited_arr[i]){\n                int size = 0;\n                dfs(i, bombs, visited_arr, size);\n                sizes.emplace_back(size);\n            }\n        }\n        return *max_element(sizes.begin(),sizes.end());\n    }\n};\n"
                    },
                    {
                        "username": "v447446",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) Thanks this was exactly the error.\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "This seems to be the cause of the error, line 8 from the bottom:\n>if (!visited_arr[i]){\n\nYou are supposed to clear the `visited` array before starting a fresh new DFS from the next bomb. Because the goal of our traversal is to find the count of reachable targets for the chosen bomb, not to visit every single node in the graph."
                    },
                    {
                        "username": "tungpham",
                        "content": "I like this kind of problem since it\\'s pretty straightforward and involves no trick. "
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "Half battle is won when you realize that you need to make a directed graph and brute force as nodes are only 100."
                    },
                    {
                        "username": "smashc0ughsugar",
                        "content": "Just two tips.\n1. Two different ones may have the same coordinates and radii, namely there could be a test case like this: [[2,3,4], [2,3,4]].\n2. When started at some point we have traversed the whole graph, we may just return."
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "its just a game of indices"
                    },
                    {
                        "username": "krish1237",
                        "content": "This is a maximum connected edges in a unidirected graph question. As the number of bombs is significantly less, we can afford a complexity of O(n**3). "
                    }
                ]
            },
            {
                "id": 1914576,
                "content": [
                    {
                        "username": "cookiecoop",
                        "content": "I get a time limit exceeded for last test case but input is just \"bombs = \". Is anyone else getting this?\\n"
                    },
                    {
                        "username": "dev_Louis",
                        "content": "Why does the following code will not be submitted due to the time limit? \nWhen running the code for the testcases even for larger inputs everthing is working correctly...\n\n`from math import sqrt\n\nclass Solution:\n    def __init__(self):\n        self.det_counts = []\n        self.dup_bombs = []\n        self.bombs_rel = []\n\n    def maximumDetonation(self, bombs: list[list[int]]) -> int:\n\n        # check for duplicate bombs\n        def get_dup_bombs():\n            dups = []\n            for i in range(len(bombs)):\n                for j in range(i + 1, len(bombs)):\n                    if bombs[i] == bombs[j]:\n                        dups.append(bombs[i])\n            return dups\n        self.dup_bombs = get_dup_bombs()    \n\n        def detonation(bombs_rel, bi, si):\n            if si == 0:\n                bombs_rel.append(bombs[bi])\n\n            for comp_bomb in bombs:\n                if not bombs[bi] == comp_bomb:\n                    d = sqrt(((comp_bomb[0]-bombs[bi][0])**2) + ((comp_bomb[1]-bombs[bi][1])**2))\n                    if bombs[bi][2] >= d and not comp_bomb in bombs_rel:\n                        bombs_rel.append(comp_bomb)\n\n            if not si+1 == len(bombs_rel):\n                detonation(bombs_rel, bi=bombs.index(bombs_rel[si+1]), si=si+1)\n\n        for i in range(len(bombs)):\n            self.bombs_rel = []\n            detonation(self.bombs_rel, bi=i, si=0)\n            # add duplicate bombs to final relation list\n            for bomb in self.dup_bombs:\n                if bomb in self.bombs_rel:\n                    self.bombs_rel.append(bomb)\n            self.det_counts.append(len(self.bombs_rel))\n\n        return max(self.det_counts)`"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "class Solution {\\npublic:\\n    int count = 1;\\n    void dfs (int source,vector <bool>& visited,map<int,list<int>> adj_lst){\\n\\n        visited[source] = true;\\n\\n         for (auto x : adj_lst[source]){\\n             if (!visited[x]){\\n                 dfs(x,visited,adj_lst);\\n                 count++;\\n             }\\n            \\n         }\\n    }\\n\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n    \\n    //  Graph approach\\n     if (bombs.size() == 1)return 1;\\n\\n     else {\\n        //  Creating adjacency list for the Directed Graph\\n        map <int,list<int>> adj;\\n        vector <bool> visited (bombs.size(),false);\\n        vector <int> dp(bombs.size(),1);\\n        for (int i = 0 ; i < bombs.size();i++){\\n            \\n            long long x1 = bombs[i][0];\\n            long long y1 = bombs[i][1];\\n            long long r1 = bombs[i][2];\\n            \\n            for (int j = i+1; j < bombs.size();j++){\\n                long long x2 = bombs[j][0];\\n                long long y2 = bombs[j][1];\\n                long long r2 = bombs[j][2];\\n\\n                long long dist = (x1 - x2)*(x1-x2)+ (y1 - y2)*(y1-y2);\\n                if (dist <= r1*r1){\\n                    adj[i].push_back(j);\\n                }\\n                if (dist <= r2*r2){\\n                    adj[j].push_back(i);\\n                }\\n\\n            }\\n        }\\n        int max_count = 0 ;\\n        for (int i = 0; i < bombs.size();i++){\\n            dfs(i,visited,adj);\\n            if (max_count < count){\\n                max_count = count;\\n            }\\n            fill(visited.begin(),visited.end(),false);\\n            count = 1;\\n        }\\n        return max_count;\\n\\n     }\\n\\n    }\\n};\\nIam getting TLE , can some one help "
                    },
                    {
                        "username": "piyushjo",
                        "content": "Can anyone help me find what am I missing for following test case : \\n [[855,82,158],[17,719,430],[90,756,164],[376,17,340],[691,636,152],[565,776,5],[464,154,271],[53,361,162],[278,609,82],[202,927,219],[542,865,377],[330,402,270],[720,199,10],[986,697,443],[471,296,69],[393,81,404],[127,405,177]]\\n\\n\\nApproach : \\n1. I stored what bombs a bomb can explode directly at first and added them in a list. These lists are stored in mainList as per index of first bomb exploded. \\n2. helper method will just get mainList.\\n3. help method will resolve add all the bombs a bomb at a particular index can explode by making recursive calls.\\n\\n---------------------------------------\\n\\n`\\nclass Solution {\\n    public int maximumDetonation(int[][] bombs) {\\n        List<List<Integer>> mainList = new ArrayList<>() ; \\n        \\n\\n        for(int i = 0 ; i < bombs.length ; i++){\\n            List<Integer> list = new ArrayList<>() ;\\n            for(int j = 0 ; j < bombs.length ; j++){\\n                if(j==i) continue; \\n                if(Math.hypot(bombs[i][0]-bombs[j][0],bombs[i][1]-bombs[j][1]) <= Math.max(bombs[i][2],bombs[j][2])){\\n                    list.add(j);\\n                }\\n            }\\n            mainList.add(list);\\n        }\\n        return helper(mainList);\\n    }\\n\\n    private int helper(List<List<Integer>> mainList){\\n        int num = 1;\\n         \\n        \\n        for(int i = 0 ; i < mainList.size() ; i++){\\n            if(mainList.get(i).size() == 0) continue; \\n            Set<Integer> set = new HashSet<>() ;\\n            set.add(i);\\n            help(mainList,mainList.get(i),set);\\n            num = Math.max(num,set.size());\\n        }\\n\\n        return num ; \\n    }\\n\\n    private void help(List<List<Integer>> mainList , List<Integer> list , Set<Integer> set){ \\n        for(int i = 0 ; i < list.size() ; i++){\\n            if(set.contains(list.get(i))) continue ; \\n            set.add(list.get(i));\\n            help(mainList,mainList.get(list.get(i)),set);\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "piyushjo",
                        "content": "[@tungbuivn](/tungbuivn) Thanks !!\\n\\nfollowing if condition needed to be changed for the obvious reason. \\n\\nEarlier : \\n\\nMath.hypot(bombs[i][0]-bombs[j][0],bombs[i][1]-bombs[j][1]) <= Math.max(bombs[i][2],bombs[j][2])\\n\\n\\nNow :\\n`(Math.hypot(bombs[i][0]-bombs[j][0],bombs[i][1]-bombs[j][1]) <= bombs[i][2])`"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "here is one of three result of 9: [3,6,14,15,12,11,8,16,7], start debug from item 3"
                    },
                    {
                        "username": "v447446",
                        "content": "Why are we creating a graph here? Can't we do it directly by testing for neighbourhood directly inside the dfs loop.\nI am trying to do it that way, but getting only 105 test cases passed out of 160. Please someone suggest a possible rectification.\n\n\n\nclass Solution {\n\nprivate:\n\n    long long int distance(long long int x1, long long int y1, long long int x2, long long int y2){\n        return (x2- x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n    }\n\n    void dfs(int node, vector<vector<int>>& bombs, vector <int> &visited_arr, int &size){\n\n        int rows = bombs.size();\n\n        visited_arr[node] = 1;\n        size++;\n\n        for (int i = 0; i < rows; i++){\n            \n            long long int dis = distance(bombs[node][0], bombs[node][1], bombs[i][0], bombs[i][1]);\n\n            long long int max_poss_dis = bombs[node][2];\n\n            if (i != node && dis >= 0 && dis <= max_poss_dis * max_poss_dis && !visited_arr[i]){\n                dfs(i, bombs, visited_arr, size);\n            }\n        }\n\n    }\n\npublic:\n\n\n    int maximumDetonation(vector<vector<int>>& bombs) {\n        int rows = bombs.size();\n\n        vector <int> visited_arr(rows, 0);\n        vector <int> sizes;\n\n        for (int i = 0; i < rows; i++){\n            if (!visited_arr[i]){\n                int size = 0;\n                dfs(i, bombs, visited_arr, size);\n                sizes.emplace_back(size);\n            }\n        }\n        return *max_element(sizes.begin(),sizes.end());\n    }\n};\n"
                    },
                    {
                        "username": "v447446",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) Thanks this was exactly the error.\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "This seems to be the cause of the error, line 8 from the bottom:\n>if (!visited_arr[i]){\n\nYou are supposed to clear the `visited` array before starting a fresh new DFS from the next bomb. Because the goal of our traversal is to find the count of reachable targets for the chosen bomb, not to visit every single node in the graph."
                    },
                    {
                        "username": "tungpham",
                        "content": "I like this kind of problem since it\\'s pretty straightforward and involves no trick. "
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "Half battle is won when you realize that you need to make a directed graph and brute force as nodes are only 100."
                    },
                    {
                        "username": "smashc0ughsugar",
                        "content": "Just two tips.\n1. Two different ones may have the same coordinates and radii, namely there could be a test case like this: [[2,3,4], [2,3,4]].\n2. When started at some point we have traversed the whole graph, we may just return."
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "its just a game of indices"
                    },
                    {
                        "username": "krish1237",
                        "content": "This is a maximum connected edges in a unidirected graph question. As the number of bombs is significantly less, we can afford a complexity of O(n**3). "
                    }
                ]
            },
            {
                "id": 1914492,
                "content": [
                    {
                        "username": "cookiecoop",
                        "content": "I get a time limit exceeded for last test case but input is just \"bombs = \". Is anyone else getting this?\\n"
                    },
                    {
                        "username": "dev_Louis",
                        "content": "Why does the following code will not be submitted due to the time limit? \nWhen running the code for the testcases even for larger inputs everthing is working correctly...\n\n`from math import sqrt\n\nclass Solution:\n    def __init__(self):\n        self.det_counts = []\n        self.dup_bombs = []\n        self.bombs_rel = []\n\n    def maximumDetonation(self, bombs: list[list[int]]) -> int:\n\n        # check for duplicate bombs\n        def get_dup_bombs():\n            dups = []\n            for i in range(len(bombs)):\n                for j in range(i + 1, len(bombs)):\n                    if bombs[i] == bombs[j]:\n                        dups.append(bombs[i])\n            return dups\n        self.dup_bombs = get_dup_bombs()    \n\n        def detonation(bombs_rel, bi, si):\n            if si == 0:\n                bombs_rel.append(bombs[bi])\n\n            for comp_bomb in bombs:\n                if not bombs[bi] == comp_bomb:\n                    d = sqrt(((comp_bomb[0]-bombs[bi][0])**2) + ((comp_bomb[1]-bombs[bi][1])**2))\n                    if bombs[bi][2] >= d and not comp_bomb in bombs_rel:\n                        bombs_rel.append(comp_bomb)\n\n            if not si+1 == len(bombs_rel):\n                detonation(bombs_rel, bi=bombs.index(bombs_rel[si+1]), si=si+1)\n\n        for i in range(len(bombs)):\n            self.bombs_rel = []\n            detonation(self.bombs_rel, bi=i, si=0)\n            # add duplicate bombs to final relation list\n            for bomb in self.dup_bombs:\n                if bomb in self.bombs_rel:\n                    self.bombs_rel.append(bomb)\n            self.det_counts.append(len(self.bombs_rel))\n\n        return max(self.det_counts)`"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "class Solution {\\npublic:\\n    int count = 1;\\n    void dfs (int source,vector <bool>& visited,map<int,list<int>> adj_lst){\\n\\n        visited[source] = true;\\n\\n         for (auto x : adj_lst[source]){\\n             if (!visited[x]){\\n                 dfs(x,visited,adj_lst);\\n                 count++;\\n             }\\n            \\n         }\\n    }\\n\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n    \\n    //  Graph approach\\n     if (bombs.size() == 1)return 1;\\n\\n     else {\\n        //  Creating adjacency list for the Directed Graph\\n        map <int,list<int>> adj;\\n        vector <bool> visited (bombs.size(),false);\\n        vector <int> dp(bombs.size(),1);\\n        for (int i = 0 ; i < bombs.size();i++){\\n            \\n            long long x1 = bombs[i][0];\\n            long long y1 = bombs[i][1];\\n            long long r1 = bombs[i][2];\\n            \\n            for (int j = i+1; j < bombs.size();j++){\\n                long long x2 = bombs[j][0];\\n                long long y2 = bombs[j][1];\\n                long long r2 = bombs[j][2];\\n\\n                long long dist = (x1 - x2)*(x1-x2)+ (y1 - y2)*(y1-y2);\\n                if (dist <= r1*r1){\\n                    adj[i].push_back(j);\\n                }\\n                if (dist <= r2*r2){\\n                    adj[j].push_back(i);\\n                }\\n\\n            }\\n        }\\n        int max_count = 0 ;\\n        for (int i = 0; i < bombs.size();i++){\\n            dfs(i,visited,adj);\\n            if (max_count < count){\\n                max_count = count;\\n            }\\n            fill(visited.begin(),visited.end(),false);\\n            count = 1;\\n        }\\n        return max_count;\\n\\n     }\\n\\n    }\\n};\\nIam getting TLE , can some one help "
                    },
                    {
                        "username": "piyushjo",
                        "content": "Can anyone help me find what am I missing for following test case : \\n [[855,82,158],[17,719,430],[90,756,164],[376,17,340],[691,636,152],[565,776,5],[464,154,271],[53,361,162],[278,609,82],[202,927,219],[542,865,377],[330,402,270],[720,199,10],[986,697,443],[471,296,69],[393,81,404],[127,405,177]]\\n\\n\\nApproach : \\n1. I stored what bombs a bomb can explode directly at first and added them in a list. These lists are stored in mainList as per index of first bomb exploded. \\n2. helper method will just get mainList.\\n3. help method will resolve add all the bombs a bomb at a particular index can explode by making recursive calls.\\n\\n---------------------------------------\\n\\n`\\nclass Solution {\\n    public int maximumDetonation(int[][] bombs) {\\n        List<List<Integer>> mainList = new ArrayList<>() ; \\n        \\n\\n        for(int i = 0 ; i < bombs.length ; i++){\\n            List<Integer> list = new ArrayList<>() ;\\n            for(int j = 0 ; j < bombs.length ; j++){\\n                if(j==i) continue; \\n                if(Math.hypot(bombs[i][0]-bombs[j][0],bombs[i][1]-bombs[j][1]) <= Math.max(bombs[i][2],bombs[j][2])){\\n                    list.add(j);\\n                }\\n            }\\n            mainList.add(list);\\n        }\\n        return helper(mainList);\\n    }\\n\\n    private int helper(List<List<Integer>> mainList){\\n        int num = 1;\\n         \\n        \\n        for(int i = 0 ; i < mainList.size() ; i++){\\n            if(mainList.get(i).size() == 0) continue; \\n            Set<Integer> set = new HashSet<>() ;\\n            set.add(i);\\n            help(mainList,mainList.get(i),set);\\n            num = Math.max(num,set.size());\\n        }\\n\\n        return num ; \\n    }\\n\\n    private void help(List<List<Integer>> mainList , List<Integer> list , Set<Integer> set){ \\n        for(int i = 0 ; i < list.size() ; i++){\\n            if(set.contains(list.get(i))) continue ; \\n            set.add(list.get(i));\\n            help(mainList,mainList.get(list.get(i)),set);\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "piyushjo",
                        "content": "[@tungbuivn](/tungbuivn) Thanks !!\\n\\nfollowing if condition needed to be changed for the obvious reason. \\n\\nEarlier : \\n\\nMath.hypot(bombs[i][0]-bombs[j][0],bombs[i][1]-bombs[j][1]) <= Math.max(bombs[i][2],bombs[j][2])\\n\\n\\nNow :\\n`(Math.hypot(bombs[i][0]-bombs[j][0],bombs[i][1]-bombs[j][1]) <= bombs[i][2])`"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "here is one of three result of 9: [3,6,14,15,12,11,8,16,7], start debug from item 3"
                    },
                    {
                        "username": "v447446",
                        "content": "Why are we creating a graph here? Can't we do it directly by testing for neighbourhood directly inside the dfs loop.\nI am trying to do it that way, but getting only 105 test cases passed out of 160. Please someone suggest a possible rectification.\n\n\n\nclass Solution {\n\nprivate:\n\n    long long int distance(long long int x1, long long int y1, long long int x2, long long int y2){\n        return (x2- x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n    }\n\n    void dfs(int node, vector<vector<int>>& bombs, vector <int> &visited_arr, int &size){\n\n        int rows = bombs.size();\n\n        visited_arr[node] = 1;\n        size++;\n\n        for (int i = 0; i < rows; i++){\n            \n            long long int dis = distance(bombs[node][0], bombs[node][1], bombs[i][0], bombs[i][1]);\n\n            long long int max_poss_dis = bombs[node][2];\n\n            if (i != node && dis >= 0 && dis <= max_poss_dis * max_poss_dis && !visited_arr[i]){\n                dfs(i, bombs, visited_arr, size);\n            }\n        }\n\n    }\n\npublic:\n\n\n    int maximumDetonation(vector<vector<int>>& bombs) {\n        int rows = bombs.size();\n\n        vector <int> visited_arr(rows, 0);\n        vector <int> sizes;\n\n        for (int i = 0; i < rows; i++){\n            if (!visited_arr[i]){\n                int size = 0;\n                dfs(i, bombs, visited_arr, size);\n                sizes.emplace_back(size);\n            }\n        }\n        return *max_element(sizes.begin(),sizes.end());\n    }\n};\n"
                    },
                    {
                        "username": "v447446",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) Thanks this was exactly the error.\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "This seems to be the cause of the error, line 8 from the bottom:\n>if (!visited_arr[i]){\n\nYou are supposed to clear the `visited` array before starting a fresh new DFS from the next bomb. Because the goal of our traversal is to find the count of reachable targets for the chosen bomb, not to visit every single node in the graph."
                    },
                    {
                        "username": "tungpham",
                        "content": "I like this kind of problem since it\\'s pretty straightforward and involves no trick. "
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "Half battle is won when you realize that you need to make a directed graph and brute force as nodes are only 100."
                    },
                    {
                        "username": "smashc0ughsugar",
                        "content": "Just two tips.\n1. Two different ones may have the same coordinates and radii, namely there could be a test case like this: [[2,3,4], [2,3,4]].\n2. When started at some point we have traversed the whole graph, we may just return."
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "its just a game of indices"
                    },
                    {
                        "username": "krish1237",
                        "content": "This is a maximum connected edges in a unidirected graph question. As the number of bombs is significantly less, we can afford a complexity of O(n**3). "
                    }
                ]
            },
            {
                "id": 1914396,
                "content": [
                    {
                        "username": "cookiecoop",
                        "content": "I get a time limit exceeded for last test case but input is just \"bombs = \". Is anyone else getting this?\\n"
                    },
                    {
                        "username": "dev_Louis",
                        "content": "Why does the following code will not be submitted due to the time limit? \nWhen running the code for the testcases even for larger inputs everthing is working correctly...\n\n`from math import sqrt\n\nclass Solution:\n    def __init__(self):\n        self.det_counts = []\n        self.dup_bombs = []\n        self.bombs_rel = []\n\n    def maximumDetonation(self, bombs: list[list[int]]) -> int:\n\n        # check for duplicate bombs\n        def get_dup_bombs():\n            dups = []\n            for i in range(len(bombs)):\n                for j in range(i + 1, len(bombs)):\n                    if bombs[i] == bombs[j]:\n                        dups.append(bombs[i])\n            return dups\n        self.dup_bombs = get_dup_bombs()    \n\n        def detonation(bombs_rel, bi, si):\n            if si == 0:\n                bombs_rel.append(bombs[bi])\n\n            for comp_bomb in bombs:\n                if not bombs[bi] == comp_bomb:\n                    d = sqrt(((comp_bomb[0]-bombs[bi][0])**2) + ((comp_bomb[1]-bombs[bi][1])**2))\n                    if bombs[bi][2] >= d and not comp_bomb in bombs_rel:\n                        bombs_rel.append(comp_bomb)\n\n            if not si+1 == len(bombs_rel):\n                detonation(bombs_rel, bi=bombs.index(bombs_rel[si+1]), si=si+1)\n\n        for i in range(len(bombs)):\n            self.bombs_rel = []\n            detonation(self.bombs_rel, bi=i, si=0)\n            # add duplicate bombs to final relation list\n            for bomb in self.dup_bombs:\n                if bomb in self.bombs_rel:\n                    self.bombs_rel.append(bomb)\n            self.det_counts.append(len(self.bombs_rel))\n\n        return max(self.det_counts)`"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "class Solution {\\npublic:\\n    int count = 1;\\n    void dfs (int source,vector <bool>& visited,map<int,list<int>> adj_lst){\\n\\n        visited[source] = true;\\n\\n         for (auto x : adj_lst[source]){\\n             if (!visited[x]){\\n                 dfs(x,visited,adj_lst);\\n                 count++;\\n             }\\n            \\n         }\\n    }\\n\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n    \\n    //  Graph approach\\n     if (bombs.size() == 1)return 1;\\n\\n     else {\\n        //  Creating adjacency list for the Directed Graph\\n        map <int,list<int>> adj;\\n        vector <bool> visited (bombs.size(),false);\\n        vector <int> dp(bombs.size(),1);\\n        for (int i = 0 ; i < bombs.size();i++){\\n            \\n            long long x1 = bombs[i][0];\\n            long long y1 = bombs[i][1];\\n            long long r1 = bombs[i][2];\\n            \\n            for (int j = i+1; j < bombs.size();j++){\\n                long long x2 = bombs[j][0];\\n                long long y2 = bombs[j][1];\\n                long long r2 = bombs[j][2];\\n\\n                long long dist = (x1 - x2)*(x1-x2)+ (y1 - y2)*(y1-y2);\\n                if (dist <= r1*r1){\\n                    adj[i].push_back(j);\\n                }\\n                if (dist <= r2*r2){\\n                    adj[j].push_back(i);\\n                }\\n\\n            }\\n        }\\n        int max_count = 0 ;\\n        for (int i = 0; i < bombs.size();i++){\\n            dfs(i,visited,adj);\\n            if (max_count < count){\\n                max_count = count;\\n            }\\n            fill(visited.begin(),visited.end(),false);\\n            count = 1;\\n        }\\n        return max_count;\\n\\n     }\\n\\n    }\\n};\\nIam getting TLE , can some one help "
                    },
                    {
                        "username": "piyushjo",
                        "content": "Can anyone help me find what am I missing for following test case : \\n [[855,82,158],[17,719,430],[90,756,164],[376,17,340],[691,636,152],[565,776,5],[464,154,271],[53,361,162],[278,609,82],[202,927,219],[542,865,377],[330,402,270],[720,199,10],[986,697,443],[471,296,69],[393,81,404],[127,405,177]]\\n\\n\\nApproach : \\n1. I stored what bombs a bomb can explode directly at first and added them in a list. These lists are stored in mainList as per index of first bomb exploded. \\n2. helper method will just get mainList.\\n3. help method will resolve add all the bombs a bomb at a particular index can explode by making recursive calls.\\n\\n---------------------------------------\\n\\n`\\nclass Solution {\\n    public int maximumDetonation(int[][] bombs) {\\n        List<List<Integer>> mainList = new ArrayList<>() ; \\n        \\n\\n        for(int i = 0 ; i < bombs.length ; i++){\\n            List<Integer> list = new ArrayList<>() ;\\n            for(int j = 0 ; j < bombs.length ; j++){\\n                if(j==i) continue; \\n                if(Math.hypot(bombs[i][0]-bombs[j][0],bombs[i][1]-bombs[j][1]) <= Math.max(bombs[i][2],bombs[j][2])){\\n                    list.add(j);\\n                }\\n            }\\n            mainList.add(list);\\n        }\\n        return helper(mainList);\\n    }\\n\\n    private int helper(List<List<Integer>> mainList){\\n        int num = 1;\\n         \\n        \\n        for(int i = 0 ; i < mainList.size() ; i++){\\n            if(mainList.get(i).size() == 0) continue; \\n            Set<Integer> set = new HashSet<>() ;\\n            set.add(i);\\n            help(mainList,mainList.get(i),set);\\n            num = Math.max(num,set.size());\\n        }\\n\\n        return num ; \\n    }\\n\\n    private void help(List<List<Integer>> mainList , List<Integer> list , Set<Integer> set){ \\n        for(int i = 0 ; i < list.size() ; i++){\\n            if(set.contains(list.get(i))) continue ; \\n            set.add(list.get(i));\\n            help(mainList,mainList.get(list.get(i)),set);\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "piyushjo",
                        "content": "[@tungbuivn](/tungbuivn) Thanks !!\\n\\nfollowing if condition needed to be changed for the obvious reason. \\n\\nEarlier : \\n\\nMath.hypot(bombs[i][0]-bombs[j][0],bombs[i][1]-bombs[j][1]) <= Math.max(bombs[i][2],bombs[j][2])\\n\\n\\nNow :\\n`(Math.hypot(bombs[i][0]-bombs[j][0],bombs[i][1]-bombs[j][1]) <= bombs[i][2])`"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "here is one of three result of 9: [3,6,14,15,12,11,8,16,7], start debug from item 3"
                    },
                    {
                        "username": "v447446",
                        "content": "Why are we creating a graph here? Can't we do it directly by testing for neighbourhood directly inside the dfs loop.\nI am trying to do it that way, but getting only 105 test cases passed out of 160. Please someone suggest a possible rectification.\n\n\n\nclass Solution {\n\nprivate:\n\n    long long int distance(long long int x1, long long int y1, long long int x2, long long int y2){\n        return (x2- x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n    }\n\n    void dfs(int node, vector<vector<int>>& bombs, vector <int> &visited_arr, int &size){\n\n        int rows = bombs.size();\n\n        visited_arr[node] = 1;\n        size++;\n\n        for (int i = 0; i < rows; i++){\n            \n            long long int dis = distance(bombs[node][0], bombs[node][1], bombs[i][0], bombs[i][1]);\n\n            long long int max_poss_dis = bombs[node][2];\n\n            if (i != node && dis >= 0 && dis <= max_poss_dis * max_poss_dis && !visited_arr[i]){\n                dfs(i, bombs, visited_arr, size);\n            }\n        }\n\n    }\n\npublic:\n\n\n    int maximumDetonation(vector<vector<int>>& bombs) {\n        int rows = bombs.size();\n\n        vector <int> visited_arr(rows, 0);\n        vector <int> sizes;\n\n        for (int i = 0; i < rows; i++){\n            if (!visited_arr[i]){\n                int size = 0;\n                dfs(i, bombs, visited_arr, size);\n                sizes.emplace_back(size);\n            }\n        }\n        return *max_element(sizes.begin(),sizes.end());\n    }\n};\n"
                    },
                    {
                        "username": "v447446",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) Thanks this was exactly the error.\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "This seems to be the cause of the error, line 8 from the bottom:\n>if (!visited_arr[i]){\n\nYou are supposed to clear the `visited` array before starting a fresh new DFS from the next bomb. Because the goal of our traversal is to find the count of reachable targets for the chosen bomb, not to visit every single node in the graph."
                    },
                    {
                        "username": "tungpham",
                        "content": "I like this kind of problem since it\\'s pretty straightforward and involves no trick. "
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "Half battle is won when you realize that you need to make a directed graph and brute force as nodes are only 100."
                    },
                    {
                        "username": "smashc0ughsugar",
                        "content": "Just two tips.\n1. Two different ones may have the same coordinates and radii, namely there could be a test case like this: [[2,3,4], [2,3,4]].\n2. When started at some point we have traversed the whole graph, we may just return."
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "its just a game of indices"
                    },
                    {
                        "username": "krish1237",
                        "content": "This is a maximum connected edges in a unidirected graph question. As the number of bombs is significantly less, we can afford a complexity of O(n**3). "
                    }
                ]
            },
            {
                "id": 1914369,
                "content": [
                    {
                        "username": "cookiecoop",
                        "content": "I get a time limit exceeded for last test case but input is just \"bombs = \". Is anyone else getting this?\\n"
                    },
                    {
                        "username": "dev_Louis",
                        "content": "Why does the following code will not be submitted due to the time limit? \nWhen running the code for the testcases even for larger inputs everthing is working correctly...\n\n`from math import sqrt\n\nclass Solution:\n    def __init__(self):\n        self.det_counts = []\n        self.dup_bombs = []\n        self.bombs_rel = []\n\n    def maximumDetonation(self, bombs: list[list[int]]) -> int:\n\n        # check for duplicate bombs\n        def get_dup_bombs():\n            dups = []\n            for i in range(len(bombs)):\n                for j in range(i + 1, len(bombs)):\n                    if bombs[i] == bombs[j]:\n                        dups.append(bombs[i])\n            return dups\n        self.dup_bombs = get_dup_bombs()    \n\n        def detonation(bombs_rel, bi, si):\n            if si == 0:\n                bombs_rel.append(bombs[bi])\n\n            for comp_bomb in bombs:\n                if not bombs[bi] == comp_bomb:\n                    d = sqrt(((comp_bomb[0]-bombs[bi][0])**2) + ((comp_bomb[1]-bombs[bi][1])**2))\n                    if bombs[bi][2] >= d and not comp_bomb in bombs_rel:\n                        bombs_rel.append(comp_bomb)\n\n            if not si+1 == len(bombs_rel):\n                detonation(bombs_rel, bi=bombs.index(bombs_rel[si+1]), si=si+1)\n\n        for i in range(len(bombs)):\n            self.bombs_rel = []\n            detonation(self.bombs_rel, bi=i, si=0)\n            # add duplicate bombs to final relation list\n            for bomb in self.dup_bombs:\n                if bomb in self.bombs_rel:\n                    self.bombs_rel.append(bomb)\n            self.det_counts.append(len(self.bombs_rel))\n\n        return max(self.det_counts)`"
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "class Solution {\\npublic:\\n    int count = 1;\\n    void dfs (int source,vector <bool>& visited,map<int,list<int>> adj_lst){\\n\\n        visited[source] = true;\\n\\n         for (auto x : adj_lst[source]){\\n             if (!visited[x]){\\n                 dfs(x,visited,adj_lst);\\n                 count++;\\n             }\\n            \\n         }\\n    }\\n\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n    \\n    //  Graph approach\\n     if (bombs.size() == 1)return 1;\\n\\n     else {\\n        //  Creating adjacency list for the Directed Graph\\n        map <int,list<int>> adj;\\n        vector <bool> visited (bombs.size(),false);\\n        vector <int> dp(bombs.size(),1);\\n        for (int i = 0 ; i < bombs.size();i++){\\n            \\n            long long x1 = bombs[i][0];\\n            long long y1 = bombs[i][1];\\n            long long r1 = bombs[i][2];\\n            \\n            for (int j = i+1; j < bombs.size();j++){\\n                long long x2 = bombs[j][0];\\n                long long y2 = bombs[j][1];\\n                long long r2 = bombs[j][2];\\n\\n                long long dist = (x1 - x2)*(x1-x2)+ (y1 - y2)*(y1-y2);\\n                if (dist <= r1*r1){\\n                    adj[i].push_back(j);\\n                }\\n                if (dist <= r2*r2){\\n                    adj[j].push_back(i);\\n                }\\n\\n            }\\n        }\\n        int max_count = 0 ;\\n        for (int i = 0; i < bombs.size();i++){\\n            dfs(i,visited,adj);\\n            if (max_count < count){\\n                max_count = count;\\n            }\\n            fill(visited.begin(),visited.end(),false);\\n            count = 1;\\n        }\\n        return max_count;\\n\\n     }\\n\\n    }\\n};\\nIam getting TLE , can some one help "
                    },
                    {
                        "username": "piyushjo",
                        "content": "Can anyone help me find what am I missing for following test case : \\n [[855,82,158],[17,719,430],[90,756,164],[376,17,340],[691,636,152],[565,776,5],[464,154,271],[53,361,162],[278,609,82],[202,927,219],[542,865,377],[330,402,270],[720,199,10],[986,697,443],[471,296,69],[393,81,404],[127,405,177]]\\n\\n\\nApproach : \\n1. I stored what bombs a bomb can explode directly at first and added them in a list. These lists are stored in mainList as per index of first bomb exploded. \\n2. helper method will just get mainList.\\n3. help method will resolve add all the bombs a bomb at a particular index can explode by making recursive calls.\\n\\n---------------------------------------\\n\\n`\\nclass Solution {\\n    public int maximumDetonation(int[][] bombs) {\\n        List<List<Integer>> mainList = new ArrayList<>() ; \\n        \\n\\n        for(int i = 0 ; i < bombs.length ; i++){\\n            List<Integer> list = new ArrayList<>() ;\\n            for(int j = 0 ; j < bombs.length ; j++){\\n                if(j==i) continue; \\n                if(Math.hypot(bombs[i][0]-bombs[j][0],bombs[i][1]-bombs[j][1]) <= Math.max(bombs[i][2],bombs[j][2])){\\n                    list.add(j);\\n                }\\n            }\\n            mainList.add(list);\\n        }\\n        return helper(mainList);\\n    }\\n\\n    private int helper(List<List<Integer>> mainList){\\n        int num = 1;\\n         \\n        \\n        for(int i = 0 ; i < mainList.size() ; i++){\\n            if(mainList.get(i).size() == 0) continue; \\n            Set<Integer> set = new HashSet<>() ;\\n            set.add(i);\\n            help(mainList,mainList.get(i),set);\\n            num = Math.max(num,set.size());\\n        }\\n\\n        return num ; \\n    }\\n\\n    private void help(List<List<Integer>> mainList , List<Integer> list , Set<Integer> set){ \\n        for(int i = 0 ; i < list.size() ; i++){\\n            if(set.contains(list.get(i))) continue ; \\n            set.add(list.get(i));\\n            help(mainList,mainList.get(list.get(i)),set);\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "piyushjo",
                        "content": "[@tungbuivn](/tungbuivn) Thanks !!\\n\\nfollowing if condition needed to be changed for the obvious reason. \\n\\nEarlier : \\n\\nMath.hypot(bombs[i][0]-bombs[j][0],bombs[i][1]-bombs[j][1]) <= Math.max(bombs[i][2],bombs[j][2])\\n\\n\\nNow :\\n`(Math.hypot(bombs[i][0]-bombs[j][0],bombs[i][1]-bombs[j][1]) <= bombs[i][2])`"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "here is one of three result of 9: [3,6,14,15,12,11,8,16,7], start debug from item 3"
                    },
                    {
                        "username": "v447446",
                        "content": "Why are we creating a graph here? Can't we do it directly by testing for neighbourhood directly inside the dfs loop.\nI am trying to do it that way, but getting only 105 test cases passed out of 160. Please someone suggest a possible rectification.\n\n\n\nclass Solution {\n\nprivate:\n\n    long long int distance(long long int x1, long long int y1, long long int x2, long long int y2){\n        return (x2- x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n    }\n\n    void dfs(int node, vector<vector<int>>& bombs, vector <int> &visited_arr, int &size){\n\n        int rows = bombs.size();\n\n        visited_arr[node] = 1;\n        size++;\n\n        for (int i = 0; i < rows; i++){\n            \n            long long int dis = distance(bombs[node][0], bombs[node][1], bombs[i][0], bombs[i][1]);\n\n            long long int max_poss_dis = bombs[node][2];\n\n            if (i != node && dis >= 0 && dis <= max_poss_dis * max_poss_dis && !visited_arr[i]){\n                dfs(i, bombs, visited_arr, size);\n            }\n        }\n\n    }\n\npublic:\n\n\n    int maximumDetonation(vector<vector<int>>& bombs) {\n        int rows = bombs.size();\n\n        vector <int> visited_arr(rows, 0);\n        vector <int> sizes;\n\n        for (int i = 0; i < rows; i++){\n            if (!visited_arr[i]){\n                int size = 0;\n                dfs(i, bombs, visited_arr, size);\n                sizes.emplace_back(size);\n            }\n        }\n        return *max_element(sizes.begin(),sizes.end());\n    }\n};\n"
                    },
                    {
                        "username": "v447446",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) Thanks this was exactly the error.\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "This seems to be the cause of the error, line 8 from the bottom:\n>if (!visited_arr[i]){\n\nYou are supposed to clear the `visited` array before starting a fresh new DFS from the next bomb. Because the goal of our traversal is to find the count of reachable targets for the chosen bomb, not to visit every single node in the graph."
                    },
                    {
                        "username": "tungpham",
                        "content": "I like this kind of problem since it\\'s pretty straightforward and involves no trick. "
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "Half battle is won when you realize that you need to make a directed graph and brute force as nodes are only 100."
                    },
                    {
                        "username": "smashc0ughsugar",
                        "content": "Just two tips.\n1. Two different ones may have the same coordinates and radii, namely there could be a test case like this: [[2,3,4], [2,3,4]].\n2. When started at some point we have traversed the whole graph, we may just return."
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "its just a game of indices"
                    },
                    {
                        "username": "krish1237",
                        "content": "This is a maximum connected edges in a unidirected graph question. As the number of bombs is significantly less, we can afford a complexity of O(n**3). "
                    }
                ]
            },
            {
                "id": 1914249,
                "content": [
                    {
                        "username": "shtl",
                        "content": "[[37207,2653,5261],\\n[40784,59523,20635],\\n[16390,1426,39102],\\n[42236,12,96855],\\n[72839,62027,61667],\\n[60691,58191,48447],\\n[42932,46579,41248],\\n[35868,43119,6870],\\n[41693,98905,17374],\\n[43441,1266,41621]]\\nIn this case I have only 5 - 1,4,5,6,7, but expected 10. Why?"
                    },
                    {
                        "username": "shtl",
                        "content": "[@tungbuivn](/tungbuivn) I found problem, was bad convertion to long from int."
                    },
                    {
                        "username": "shtl",
                        "content": "[@tungbuivn](/tungbuivn) Chain 0-3 don\\'t work. Distanse[5029,2641]=5680.3, more, then 5261."
                    },
                    {
                        "username": "tungbuivn",
                        "content": "perhap you missing some where, here is 10 items from my program: [2,0,3,9,1,4,5,6,7,8], you could trace your program with that list"
                    },
                    {
                        "username": "himanshu693",
                        "content": "[[5149,1,2],[5146,1,3],[5142,1,4],[5137,1,5],[5131,1,6],[5124,1,7],[5116,1,8],[5107,1,9],[5097,1,10],[5086,1,11],[5074,1,12],[5061,1,13],[5047,1,14],[5032,1,15],[5016,1,16],[4999,1,17],[4981,1,18],[4962,1,19],[4942,1,20],[4921,1,21],[4899,1,22],[4876,1,23],[4852,1,24],[4827,1,25],[4801,1,26],[4774,1,27],[4746,1,28],[4717,1,29],[4687,1,30],[4656,1,31],[4624,1,32],[4591,1,33],[4557,1,34],[4522,1,35],[4486,1,36],[4449,1,37],[4411,1,38],[4372,1,39],[4332,1,40],[4291,1,41],[4249,1,42],[4206,1,43],[4162,1,44],[4117,1,45],[4071,1,46],[4024,1,47],[3976,1,48],[3927,1,49],[3877,1,50],[3826,1,51],[3774,1,52],[3721,1,53],[3667,1,54],[3612,1,55],[3556,1,56],[3499,1,57],[3441,1,58],[3382,1,59],[3322,1,60],[3261,1,61],[3199,1,62],[3136,1,63],[3072,1,64],[3007,1,65],[2941,1,66],[2874,1,67],[2806,1,68],[2737,1,69],[2667,1,70],[2596,1,71],[2524,1,72],[2451,1,73],[2377,1,74],[2302,1,75],[2226,1,76],[2149,1,77],[2071,1,78],[1992,1,79],[1912,1,80],[1831,1,81],[1749,1,82],[1666,1,83],[1582,1,84],[1497,1,85],[1411,1,86],[1324,1,87],[1236,1,88],[1147,1,89],[1057,1,90],[966,1,91],[874,1,92],[781,1,93],[687,1,94],[592,1,95],[496,1,96],[399,1,97],[301,1,98],[202,1,99],[102,1,100],[1,1,101]]\\n\\nfor this testcase I am getting 15 which I think is correct because 0, 1, 2, 3, 4 are isolated from other nodes so 5 nodes already gone from 100 so how 100 can be ans?"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "here is 100 items in order to debug your code =))\\n[99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,77,76,75,74,73,72,71,70,69,68,67,66,65,64,63,62,61,60,59,58,57,56,55,54,53,52,51,50,49,48,47,46,45,44,43,42,41,40,39,38,37,36,35,34,33,32,31,30,29,28,27,26,25,24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0]"
                    },
                    {
                        "username": "sravan_csed",
                        "content": "For this input the expected answer from leetcode is 1. Shouldn\\'t it be 2 as denotating bomb with index : 0 will detonate the other bomb\\n\\n[[1,1,100000],[100000,100000,1]]"
                    },
                    {
                        "username": "_SID_",
                        "content": "Check this, you can understand easily :  https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588930/1-1-100000-100000-100000-1-getting-wrong-understand-why/"
                    },
                    {
                        "username": "sravan_csed",
                        "content": "My bad  - issue was with casting squared distance to long"
                    },
                    {
                        "username": "vctr_",
                        "content": " `your inline code... \\nclass Solution {\\npublic:\\n    bool inRange(int i, int j, vector<vector<int>>& bombs){\\n        long long d = pow((bombs[i][0]-bombs[j][0]), 2)+pow((bombs[i][1]-bombs[i][1]), 2);\\n    \\n        if(d>pow(bombs[i][2], 2)){\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n = bombs.size();\\n        int maxm = INT_MIN; \\n        int curr = 0;\\n\\n        for(int i=0; i<n; i++){\\n            curr = 0;\\n            for(int j = 0; j<n; j++){\\n                if(inRange(i, j, bombs)){\\n                    curr++;\\n                    maxm = max(curr, maxm);\\n                }\\n            }\\n        }\\n        return maxm;\\n    }\\n};\\nyour inline code...`\\n\\n\\nI have written this brute force code to solve the problem.\\nbut it is giving me wrong answer for bombs =\\n[[1,1,100000],[100000,100000,1]] this case\\nWhere is the error?\\n"
                    },
                    {
                        "username": "note_08",
                        "content": "why cant we do this question by finding the points in its  range and maximizing the answer\\n"
                    },
                    {
                        "username": "charonme",
                        "content": "because of the secondary chain explosions"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Seems like a hard problem"
                    },
                    {
                        "username": "charonme",
                        "content": "not hard, just a composition of one easy + one almost-easy medium"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "A good hint for this problem could be,\\nManhattan Distance from src-to-destination can help in making Graph"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@dkochetov](/dkochetov) Quick addition: as precise euclidean distance is not needed, square root is not needed, just compare with r^2"
                    },
                    {
                        "username": "dkochetov",
                        "content": "No, you must use euclidean distance here"
                    },
                    {
                        "username": "eduard92",
                        "content": "I am so bad at graphs I cannot visualize how to implement DFS"
                    },
                    {
                        "username": "EgorMaral",
                        "content": "Python. I cannot use:\n ` def dfs(cur, visited=set()):`\nAnd i dont know why. Please, give me advice.\n\nAddition.\n```python\ndef dfs(cur, visited=set(), count=0):\n    if count == 0:\n        print(visited)\n    visited.add(cur)\n    count += 1\n    ...\n```\nLeads to the result:\n```python\nset()\n{0}\n{0, 1}\n{0, 1, 2}\n...\n```\nThat is, the variable __visisted__ is cached, but the variable __count__ is not.\nAnd:\n```python\ndef dfs(cur, visited=None):\n```\nis work"
                    },
                    {
                        "username": "james4388",
                        "content": "visited=set() in there will create a set and it live in global space, which will share that to all subsequence call. the correct way is\n```\ndef dfs(cur, visited=None):\n    visited = visited or set()\n    ....\n```\nsame apply for class instance\n```\nclass xyz:\n   var_here = set(). # this will be shared everywehre\n   def __init__(self):\n        self.something = set(). # this is safe\n```\n"
                    },
                    {
                        "username": "Krishak_20",
                        "content": "class Solution {\\n     int ans=0;\\n     int det=0;\\n\\n\\n     class Edge\\n     {\\n         int src,dest;\\n\\n         Edge(int src,int dest)\\n         {\\n             this.src=src;\\n             this.dest=dest;\\n         }\\n     }\\n    public int maximumDetonation(int[][] bombs) {\\n           \\n           int n=bombs.length;\\n\\n         ArrayList<Edge>graph[]=new ArrayList[n];\\n               for(int i=0;i<n;i++)graph[i]=new ArrayList<>();\\n            \\n         for(int i=0;i<bombs.length;i++)\\n         {\\n\\n             int x1=bombs[i][0];\\n               int y1=bombs[i][1];\\n               int r1=bombs[i][2];\\n\\n\\n             for(int j=0;j<bombs.length;j++)\\n             {\\n                \\n                if(j==i)continue;\\n                \\n               int x2=bombs[j][0];\\n               int y2=bombs[j][1];\\n               int r2=bombs[j][2];\\n\\n                 int d=r1+r2;\\n\\nif((long)d*(long)d>=((long)(x1-x2)*(long)(x1-x2))+((long)(y1-y2)*(long)(y1-y2)))\\n                 {\\n                     graph[i].add(new Edge(i,j));\\n                     \\n\\n                     //System.out.println(i+\" \"+j);\\n                 }\\n\\n             }\\n         }\\n\\n\\n         boolean []vis=new boolean[n];\\n            \\n           \\n         for(int i=0;i<n;i++)\\n         {\\n             det=0;\\n            if(!vis[i]){\\n\\n                 dfs(graph,i,vis);\\n                 ans=Math.max(det,ans);\\n             }\\n         }\\n         return ans;\\n\\n    }\\n\\n\\n    private void dfs(ArrayList<Edge>graph[],int curr,boolean[]vis)\\n    {\\n        vis[curr]=true;\\n                det++;\\n        for(int i=0;i<graph[curr].size();i++)\\n        {\\n            Edge e=graph[curr].get(i);\\n\\n            if(!vis[e.dest])\\n            {\\n              dfs(graph,e.dest,vis);\\n            }\\n        }\\n    }\\n}\\n\\n\\nCan anyone tel me why this code is not working . I am using the property of circles where if r1+r2<=distance between the centres of two circles , then they must be colliding and hence we will make both circles neighbours"
                    }
                ]
            },
            {
                "id": 1914105,
                "content": [
                    {
                        "username": "shtl",
                        "content": "[[37207,2653,5261],\\n[40784,59523,20635],\\n[16390,1426,39102],\\n[42236,12,96855],\\n[72839,62027,61667],\\n[60691,58191,48447],\\n[42932,46579,41248],\\n[35868,43119,6870],\\n[41693,98905,17374],\\n[43441,1266,41621]]\\nIn this case I have only 5 - 1,4,5,6,7, but expected 10. Why?"
                    },
                    {
                        "username": "shtl",
                        "content": "[@tungbuivn](/tungbuivn) I found problem, was bad convertion to long from int."
                    },
                    {
                        "username": "shtl",
                        "content": "[@tungbuivn](/tungbuivn) Chain 0-3 don\\'t work. Distanse[5029,2641]=5680.3, more, then 5261."
                    },
                    {
                        "username": "tungbuivn",
                        "content": "perhap you missing some where, here is 10 items from my program: [2,0,3,9,1,4,5,6,7,8], you could trace your program with that list"
                    },
                    {
                        "username": "himanshu693",
                        "content": "[[5149,1,2],[5146,1,3],[5142,1,4],[5137,1,5],[5131,1,6],[5124,1,7],[5116,1,8],[5107,1,9],[5097,1,10],[5086,1,11],[5074,1,12],[5061,1,13],[5047,1,14],[5032,1,15],[5016,1,16],[4999,1,17],[4981,1,18],[4962,1,19],[4942,1,20],[4921,1,21],[4899,1,22],[4876,1,23],[4852,1,24],[4827,1,25],[4801,1,26],[4774,1,27],[4746,1,28],[4717,1,29],[4687,1,30],[4656,1,31],[4624,1,32],[4591,1,33],[4557,1,34],[4522,1,35],[4486,1,36],[4449,1,37],[4411,1,38],[4372,1,39],[4332,1,40],[4291,1,41],[4249,1,42],[4206,1,43],[4162,1,44],[4117,1,45],[4071,1,46],[4024,1,47],[3976,1,48],[3927,1,49],[3877,1,50],[3826,1,51],[3774,1,52],[3721,1,53],[3667,1,54],[3612,1,55],[3556,1,56],[3499,1,57],[3441,1,58],[3382,1,59],[3322,1,60],[3261,1,61],[3199,1,62],[3136,1,63],[3072,1,64],[3007,1,65],[2941,1,66],[2874,1,67],[2806,1,68],[2737,1,69],[2667,1,70],[2596,1,71],[2524,1,72],[2451,1,73],[2377,1,74],[2302,1,75],[2226,1,76],[2149,1,77],[2071,1,78],[1992,1,79],[1912,1,80],[1831,1,81],[1749,1,82],[1666,1,83],[1582,1,84],[1497,1,85],[1411,1,86],[1324,1,87],[1236,1,88],[1147,1,89],[1057,1,90],[966,1,91],[874,1,92],[781,1,93],[687,1,94],[592,1,95],[496,1,96],[399,1,97],[301,1,98],[202,1,99],[102,1,100],[1,1,101]]\\n\\nfor this testcase I am getting 15 which I think is correct because 0, 1, 2, 3, 4 are isolated from other nodes so 5 nodes already gone from 100 so how 100 can be ans?"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "here is 100 items in order to debug your code =))\\n[99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,77,76,75,74,73,72,71,70,69,68,67,66,65,64,63,62,61,60,59,58,57,56,55,54,53,52,51,50,49,48,47,46,45,44,43,42,41,40,39,38,37,36,35,34,33,32,31,30,29,28,27,26,25,24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0]"
                    },
                    {
                        "username": "sravan_csed",
                        "content": "For this input the expected answer from leetcode is 1. Shouldn\\'t it be 2 as denotating bomb with index : 0 will detonate the other bomb\\n\\n[[1,1,100000],[100000,100000,1]]"
                    },
                    {
                        "username": "_SID_",
                        "content": "Check this, you can understand easily :  https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588930/1-1-100000-100000-100000-1-getting-wrong-understand-why/"
                    },
                    {
                        "username": "sravan_csed",
                        "content": "My bad  - issue was with casting squared distance to long"
                    },
                    {
                        "username": "vctr_",
                        "content": " `your inline code... \\nclass Solution {\\npublic:\\n    bool inRange(int i, int j, vector<vector<int>>& bombs){\\n        long long d = pow((bombs[i][0]-bombs[j][0]), 2)+pow((bombs[i][1]-bombs[i][1]), 2);\\n    \\n        if(d>pow(bombs[i][2], 2)){\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n = bombs.size();\\n        int maxm = INT_MIN; \\n        int curr = 0;\\n\\n        for(int i=0; i<n; i++){\\n            curr = 0;\\n            for(int j = 0; j<n; j++){\\n                if(inRange(i, j, bombs)){\\n                    curr++;\\n                    maxm = max(curr, maxm);\\n                }\\n            }\\n        }\\n        return maxm;\\n    }\\n};\\nyour inline code...`\\n\\n\\nI have written this brute force code to solve the problem.\\nbut it is giving me wrong answer for bombs =\\n[[1,1,100000],[100000,100000,1]] this case\\nWhere is the error?\\n"
                    },
                    {
                        "username": "note_08",
                        "content": "why cant we do this question by finding the points in its  range and maximizing the answer\\n"
                    },
                    {
                        "username": "charonme",
                        "content": "because of the secondary chain explosions"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Seems like a hard problem"
                    },
                    {
                        "username": "charonme",
                        "content": "not hard, just a composition of one easy + one almost-easy medium"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "A good hint for this problem could be,\\nManhattan Distance from src-to-destination can help in making Graph"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@dkochetov](/dkochetov) Quick addition: as precise euclidean distance is not needed, square root is not needed, just compare with r^2"
                    },
                    {
                        "username": "dkochetov",
                        "content": "No, you must use euclidean distance here"
                    },
                    {
                        "username": "eduard92",
                        "content": "I am so bad at graphs I cannot visualize how to implement DFS"
                    },
                    {
                        "username": "EgorMaral",
                        "content": "Python. I cannot use:\n ` def dfs(cur, visited=set()):`\nAnd i dont know why. Please, give me advice.\n\nAddition.\n```python\ndef dfs(cur, visited=set(), count=0):\n    if count == 0:\n        print(visited)\n    visited.add(cur)\n    count += 1\n    ...\n```\nLeads to the result:\n```python\nset()\n{0}\n{0, 1}\n{0, 1, 2}\n...\n```\nThat is, the variable __visisted__ is cached, but the variable __count__ is not.\nAnd:\n```python\ndef dfs(cur, visited=None):\n```\nis work"
                    },
                    {
                        "username": "james4388",
                        "content": "visited=set() in there will create a set and it live in global space, which will share that to all subsequence call. the correct way is\n```\ndef dfs(cur, visited=None):\n    visited = visited or set()\n    ....\n```\nsame apply for class instance\n```\nclass xyz:\n   var_here = set(). # this will be shared everywehre\n   def __init__(self):\n        self.something = set(). # this is safe\n```\n"
                    },
                    {
                        "username": "Krishak_20",
                        "content": "class Solution {\\n     int ans=0;\\n     int det=0;\\n\\n\\n     class Edge\\n     {\\n         int src,dest;\\n\\n         Edge(int src,int dest)\\n         {\\n             this.src=src;\\n             this.dest=dest;\\n         }\\n     }\\n    public int maximumDetonation(int[][] bombs) {\\n           \\n           int n=bombs.length;\\n\\n         ArrayList<Edge>graph[]=new ArrayList[n];\\n               for(int i=0;i<n;i++)graph[i]=new ArrayList<>();\\n            \\n         for(int i=0;i<bombs.length;i++)\\n         {\\n\\n             int x1=bombs[i][0];\\n               int y1=bombs[i][1];\\n               int r1=bombs[i][2];\\n\\n\\n             for(int j=0;j<bombs.length;j++)\\n             {\\n                \\n                if(j==i)continue;\\n                \\n               int x2=bombs[j][0];\\n               int y2=bombs[j][1];\\n               int r2=bombs[j][2];\\n\\n                 int d=r1+r2;\\n\\nif((long)d*(long)d>=((long)(x1-x2)*(long)(x1-x2))+((long)(y1-y2)*(long)(y1-y2)))\\n                 {\\n                     graph[i].add(new Edge(i,j));\\n                     \\n\\n                     //System.out.println(i+\" \"+j);\\n                 }\\n\\n             }\\n         }\\n\\n\\n         boolean []vis=new boolean[n];\\n            \\n           \\n         for(int i=0;i<n;i++)\\n         {\\n             det=0;\\n            if(!vis[i]){\\n\\n                 dfs(graph,i,vis);\\n                 ans=Math.max(det,ans);\\n             }\\n         }\\n         return ans;\\n\\n    }\\n\\n\\n    private void dfs(ArrayList<Edge>graph[],int curr,boolean[]vis)\\n    {\\n        vis[curr]=true;\\n                det++;\\n        for(int i=0;i<graph[curr].size();i++)\\n        {\\n            Edge e=graph[curr].get(i);\\n\\n            if(!vis[e.dest])\\n            {\\n              dfs(graph,e.dest,vis);\\n            }\\n        }\\n    }\\n}\\n\\n\\nCan anyone tel me why this code is not working . I am using the property of circles where if r1+r2<=distance between the centres of two circles , then they must be colliding and hence we will make both circles neighbours"
                    }
                ]
            },
            {
                "id": 1913965,
                "content": [
                    {
                        "username": "shtl",
                        "content": "[[37207,2653,5261],\\n[40784,59523,20635],\\n[16390,1426,39102],\\n[42236,12,96855],\\n[72839,62027,61667],\\n[60691,58191,48447],\\n[42932,46579,41248],\\n[35868,43119,6870],\\n[41693,98905,17374],\\n[43441,1266,41621]]\\nIn this case I have only 5 - 1,4,5,6,7, but expected 10. Why?"
                    },
                    {
                        "username": "shtl",
                        "content": "[@tungbuivn](/tungbuivn) I found problem, was bad convertion to long from int."
                    },
                    {
                        "username": "shtl",
                        "content": "[@tungbuivn](/tungbuivn) Chain 0-3 don\\'t work. Distanse[5029,2641]=5680.3, more, then 5261."
                    },
                    {
                        "username": "tungbuivn",
                        "content": "perhap you missing some where, here is 10 items from my program: [2,0,3,9,1,4,5,6,7,8], you could trace your program with that list"
                    },
                    {
                        "username": "himanshu693",
                        "content": "[[5149,1,2],[5146,1,3],[5142,1,4],[5137,1,5],[5131,1,6],[5124,1,7],[5116,1,8],[5107,1,9],[5097,1,10],[5086,1,11],[5074,1,12],[5061,1,13],[5047,1,14],[5032,1,15],[5016,1,16],[4999,1,17],[4981,1,18],[4962,1,19],[4942,1,20],[4921,1,21],[4899,1,22],[4876,1,23],[4852,1,24],[4827,1,25],[4801,1,26],[4774,1,27],[4746,1,28],[4717,1,29],[4687,1,30],[4656,1,31],[4624,1,32],[4591,1,33],[4557,1,34],[4522,1,35],[4486,1,36],[4449,1,37],[4411,1,38],[4372,1,39],[4332,1,40],[4291,1,41],[4249,1,42],[4206,1,43],[4162,1,44],[4117,1,45],[4071,1,46],[4024,1,47],[3976,1,48],[3927,1,49],[3877,1,50],[3826,1,51],[3774,1,52],[3721,1,53],[3667,1,54],[3612,1,55],[3556,1,56],[3499,1,57],[3441,1,58],[3382,1,59],[3322,1,60],[3261,1,61],[3199,1,62],[3136,1,63],[3072,1,64],[3007,1,65],[2941,1,66],[2874,1,67],[2806,1,68],[2737,1,69],[2667,1,70],[2596,1,71],[2524,1,72],[2451,1,73],[2377,1,74],[2302,1,75],[2226,1,76],[2149,1,77],[2071,1,78],[1992,1,79],[1912,1,80],[1831,1,81],[1749,1,82],[1666,1,83],[1582,1,84],[1497,1,85],[1411,1,86],[1324,1,87],[1236,1,88],[1147,1,89],[1057,1,90],[966,1,91],[874,1,92],[781,1,93],[687,1,94],[592,1,95],[496,1,96],[399,1,97],[301,1,98],[202,1,99],[102,1,100],[1,1,101]]\\n\\nfor this testcase I am getting 15 which I think is correct because 0, 1, 2, 3, 4 are isolated from other nodes so 5 nodes already gone from 100 so how 100 can be ans?"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "here is 100 items in order to debug your code =))\\n[99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,77,76,75,74,73,72,71,70,69,68,67,66,65,64,63,62,61,60,59,58,57,56,55,54,53,52,51,50,49,48,47,46,45,44,43,42,41,40,39,38,37,36,35,34,33,32,31,30,29,28,27,26,25,24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0]"
                    },
                    {
                        "username": "sravan_csed",
                        "content": "For this input the expected answer from leetcode is 1. Shouldn\\'t it be 2 as denotating bomb with index : 0 will detonate the other bomb\\n\\n[[1,1,100000],[100000,100000,1]]"
                    },
                    {
                        "username": "_SID_",
                        "content": "Check this, you can understand easily :  https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588930/1-1-100000-100000-100000-1-getting-wrong-understand-why/"
                    },
                    {
                        "username": "sravan_csed",
                        "content": "My bad  - issue was with casting squared distance to long"
                    },
                    {
                        "username": "vctr_",
                        "content": " `your inline code... \\nclass Solution {\\npublic:\\n    bool inRange(int i, int j, vector<vector<int>>& bombs){\\n        long long d = pow((bombs[i][0]-bombs[j][0]), 2)+pow((bombs[i][1]-bombs[i][1]), 2);\\n    \\n        if(d>pow(bombs[i][2], 2)){\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n = bombs.size();\\n        int maxm = INT_MIN; \\n        int curr = 0;\\n\\n        for(int i=0; i<n; i++){\\n            curr = 0;\\n            for(int j = 0; j<n; j++){\\n                if(inRange(i, j, bombs)){\\n                    curr++;\\n                    maxm = max(curr, maxm);\\n                }\\n            }\\n        }\\n        return maxm;\\n    }\\n};\\nyour inline code...`\\n\\n\\nI have written this brute force code to solve the problem.\\nbut it is giving me wrong answer for bombs =\\n[[1,1,100000],[100000,100000,1]] this case\\nWhere is the error?\\n"
                    },
                    {
                        "username": "note_08",
                        "content": "why cant we do this question by finding the points in its  range and maximizing the answer\\n"
                    },
                    {
                        "username": "charonme",
                        "content": "because of the secondary chain explosions"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Seems like a hard problem"
                    },
                    {
                        "username": "charonme",
                        "content": "not hard, just a composition of one easy + one almost-easy medium"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "A good hint for this problem could be,\\nManhattan Distance from src-to-destination can help in making Graph"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@dkochetov](/dkochetov) Quick addition: as precise euclidean distance is not needed, square root is not needed, just compare with r^2"
                    },
                    {
                        "username": "dkochetov",
                        "content": "No, you must use euclidean distance here"
                    },
                    {
                        "username": "eduard92",
                        "content": "I am so bad at graphs I cannot visualize how to implement DFS"
                    },
                    {
                        "username": "EgorMaral",
                        "content": "Python. I cannot use:\n ` def dfs(cur, visited=set()):`\nAnd i dont know why. Please, give me advice.\n\nAddition.\n```python\ndef dfs(cur, visited=set(), count=0):\n    if count == 0:\n        print(visited)\n    visited.add(cur)\n    count += 1\n    ...\n```\nLeads to the result:\n```python\nset()\n{0}\n{0, 1}\n{0, 1, 2}\n...\n```\nThat is, the variable __visisted__ is cached, but the variable __count__ is not.\nAnd:\n```python\ndef dfs(cur, visited=None):\n```\nis work"
                    },
                    {
                        "username": "james4388",
                        "content": "visited=set() in there will create a set and it live in global space, which will share that to all subsequence call. the correct way is\n```\ndef dfs(cur, visited=None):\n    visited = visited or set()\n    ....\n```\nsame apply for class instance\n```\nclass xyz:\n   var_here = set(). # this will be shared everywehre\n   def __init__(self):\n        self.something = set(). # this is safe\n```\n"
                    },
                    {
                        "username": "Krishak_20",
                        "content": "class Solution {\\n     int ans=0;\\n     int det=0;\\n\\n\\n     class Edge\\n     {\\n         int src,dest;\\n\\n         Edge(int src,int dest)\\n         {\\n             this.src=src;\\n             this.dest=dest;\\n         }\\n     }\\n    public int maximumDetonation(int[][] bombs) {\\n           \\n           int n=bombs.length;\\n\\n         ArrayList<Edge>graph[]=new ArrayList[n];\\n               for(int i=0;i<n;i++)graph[i]=new ArrayList<>();\\n            \\n         for(int i=0;i<bombs.length;i++)\\n         {\\n\\n             int x1=bombs[i][0];\\n               int y1=bombs[i][1];\\n               int r1=bombs[i][2];\\n\\n\\n             for(int j=0;j<bombs.length;j++)\\n             {\\n                \\n                if(j==i)continue;\\n                \\n               int x2=bombs[j][0];\\n               int y2=bombs[j][1];\\n               int r2=bombs[j][2];\\n\\n                 int d=r1+r2;\\n\\nif((long)d*(long)d>=((long)(x1-x2)*(long)(x1-x2))+((long)(y1-y2)*(long)(y1-y2)))\\n                 {\\n                     graph[i].add(new Edge(i,j));\\n                     \\n\\n                     //System.out.println(i+\" \"+j);\\n                 }\\n\\n             }\\n         }\\n\\n\\n         boolean []vis=new boolean[n];\\n            \\n           \\n         for(int i=0;i<n;i++)\\n         {\\n             det=0;\\n            if(!vis[i]){\\n\\n                 dfs(graph,i,vis);\\n                 ans=Math.max(det,ans);\\n             }\\n         }\\n         return ans;\\n\\n    }\\n\\n\\n    private void dfs(ArrayList<Edge>graph[],int curr,boolean[]vis)\\n    {\\n        vis[curr]=true;\\n                det++;\\n        for(int i=0;i<graph[curr].size();i++)\\n        {\\n            Edge e=graph[curr].get(i);\\n\\n            if(!vis[e.dest])\\n            {\\n              dfs(graph,e.dest,vis);\\n            }\\n        }\\n    }\\n}\\n\\n\\nCan anyone tel me why this code is not working . I am using the property of circles where if r1+r2<=distance between the centres of two circles , then they must be colliding and hence we will make both circles neighbours"
                    }
                ]
            },
            {
                "id": 1913925,
                "content": [
                    {
                        "username": "shtl",
                        "content": "[[37207,2653,5261],\\n[40784,59523,20635],\\n[16390,1426,39102],\\n[42236,12,96855],\\n[72839,62027,61667],\\n[60691,58191,48447],\\n[42932,46579,41248],\\n[35868,43119,6870],\\n[41693,98905,17374],\\n[43441,1266,41621]]\\nIn this case I have only 5 - 1,4,5,6,7, but expected 10. Why?"
                    },
                    {
                        "username": "shtl",
                        "content": "[@tungbuivn](/tungbuivn) I found problem, was bad convertion to long from int."
                    },
                    {
                        "username": "shtl",
                        "content": "[@tungbuivn](/tungbuivn) Chain 0-3 don\\'t work. Distanse[5029,2641]=5680.3, more, then 5261."
                    },
                    {
                        "username": "tungbuivn",
                        "content": "perhap you missing some where, here is 10 items from my program: [2,0,3,9,1,4,5,6,7,8], you could trace your program with that list"
                    },
                    {
                        "username": "himanshu693",
                        "content": "[[5149,1,2],[5146,1,3],[5142,1,4],[5137,1,5],[5131,1,6],[5124,1,7],[5116,1,8],[5107,1,9],[5097,1,10],[5086,1,11],[5074,1,12],[5061,1,13],[5047,1,14],[5032,1,15],[5016,1,16],[4999,1,17],[4981,1,18],[4962,1,19],[4942,1,20],[4921,1,21],[4899,1,22],[4876,1,23],[4852,1,24],[4827,1,25],[4801,1,26],[4774,1,27],[4746,1,28],[4717,1,29],[4687,1,30],[4656,1,31],[4624,1,32],[4591,1,33],[4557,1,34],[4522,1,35],[4486,1,36],[4449,1,37],[4411,1,38],[4372,1,39],[4332,1,40],[4291,1,41],[4249,1,42],[4206,1,43],[4162,1,44],[4117,1,45],[4071,1,46],[4024,1,47],[3976,1,48],[3927,1,49],[3877,1,50],[3826,1,51],[3774,1,52],[3721,1,53],[3667,1,54],[3612,1,55],[3556,1,56],[3499,1,57],[3441,1,58],[3382,1,59],[3322,1,60],[3261,1,61],[3199,1,62],[3136,1,63],[3072,1,64],[3007,1,65],[2941,1,66],[2874,1,67],[2806,1,68],[2737,1,69],[2667,1,70],[2596,1,71],[2524,1,72],[2451,1,73],[2377,1,74],[2302,1,75],[2226,1,76],[2149,1,77],[2071,1,78],[1992,1,79],[1912,1,80],[1831,1,81],[1749,1,82],[1666,1,83],[1582,1,84],[1497,1,85],[1411,1,86],[1324,1,87],[1236,1,88],[1147,1,89],[1057,1,90],[966,1,91],[874,1,92],[781,1,93],[687,1,94],[592,1,95],[496,1,96],[399,1,97],[301,1,98],[202,1,99],[102,1,100],[1,1,101]]\\n\\nfor this testcase I am getting 15 which I think is correct because 0, 1, 2, 3, 4 are isolated from other nodes so 5 nodes already gone from 100 so how 100 can be ans?"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "here is 100 items in order to debug your code =))\\n[99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,77,76,75,74,73,72,71,70,69,68,67,66,65,64,63,62,61,60,59,58,57,56,55,54,53,52,51,50,49,48,47,46,45,44,43,42,41,40,39,38,37,36,35,34,33,32,31,30,29,28,27,26,25,24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0]"
                    },
                    {
                        "username": "sravan_csed",
                        "content": "For this input the expected answer from leetcode is 1. Shouldn\\'t it be 2 as denotating bomb with index : 0 will detonate the other bomb\\n\\n[[1,1,100000],[100000,100000,1]]"
                    },
                    {
                        "username": "_SID_",
                        "content": "Check this, you can understand easily :  https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588930/1-1-100000-100000-100000-1-getting-wrong-understand-why/"
                    },
                    {
                        "username": "sravan_csed",
                        "content": "My bad  - issue was with casting squared distance to long"
                    },
                    {
                        "username": "vctr_",
                        "content": " `your inline code... \\nclass Solution {\\npublic:\\n    bool inRange(int i, int j, vector<vector<int>>& bombs){\\n        long long d = pow((bombs[i][0]-bombs[j][0]), 2)+pow((bombs[i][1]-bombs[i][1]), 2);\\n    \\n        if(d>pow(bombs[i][2], 2)){\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n = bombs.size();\\n        int maxm = INT_MIN; \\n        int curr = 0;\\n\\n        for(int i=0; i<n; i++){\\n            curr = 0;\\n            for(int j = 0; j<n; j++){\\n                if(inRange(i, j, bombs)){\\n                    curr++;\\n                    maxm = max(curr, maxm);\\n                }\\n            }\\n        }\\n        return maxm;\\n    }\\n};\\nyour inline code...`\\n\\n\\nI have written this brute force code to solve the problem.\\nbut it is giving me wrong answer for bombs =\\n[[1,1,100000],[100000,100000,1]] this case\\nWhere is the error?\\n"
                    },
                    {
                        "username": "note_08",
                        "content": "why cant we do this question by finding the points in its  range and maximizing the answer\\n"
                    },
                    {
                        "username": "charonme",
                        "content": "because of the secondary chain explosions"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Seems like a hard problem"
                    },
                    {
                        "username": "charonme",
                        "content": "not hard, just a composition of one easy + one almost-easy medium"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "A good hint for this problem could be,\\nManhattan Distance from src-to-destination can help in making Graph"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@dkochetov](/dkochetov) Quick addition: as precise euclidean distance is not needed, square root is not needed, just compare with r^2"
                    },
                    {
                        "username": "dkochetov",
                        "content": "No, you must use euclidean distance here"
                    },
                    {
                        "username": "eduard92",
                        "content": "I am so bad at graphs I cannot visualize how to implement DFS"
                    },
                    {
                        "username": "EgorMaral",
                        "content": "Python. I cannot use:\n ` def dfs(cur, visited=set()):`\nAnd i dont know why. Please, give me advice.\n\nAddition.\n```python\ndef dfs(cur, visited=set(), count=0):\n    if count == 0:\n        print(visited)\n    visited.add(cur)\n    count += 1\n    ...\n```\nLeads to the result:\n```python\nset()\n{0}\n{0, 1}\n{0, 1, 2}\n...\n```\nThat is, the variable __visisted__ is cached, but the variable __count__ is not.\nAnd:\n```python\ndef dfs(cur, visited=None):\n```\nis work"
                    },
                    {
                        "username": "james4388",
                        "content": "visited=set() in there will create a set and it live in global space, which will share that to all subsequence call. the correct way is\n```\ndef dfs(cur, visited=None):\n    visited = visited or set()\n    ....\n```\nsame apply for class instance\n```\nclass xyz:\n   var_here = set(). # this will be shared everywehre\n   def __init__(self):\n        self.something = set(). # this is safe\n```\n"
                    },
                    {
                        "username": "Krishak_20",
                        "content": "class Solution {\\n     int ans=0;\\n     int det=0;\\n\\n\\n     class Edge\\n     {\\n         int src,dest;\\n\\n         Edge(int src,int dest)\\n         {\\n             this.src=src;\\n             this.dest=dest;\\n         }\\n     }\\n    public int maximumDetonation(int[][] bombs) {\\n           \\n           int n=bombs.length;\\n\\n         ArrayList<Edge>graph[]=new ArrayList[n];\\n               for(int i=0;i<n;i++)graph[i]=new ArrayList<>();\\n            \\n         for(int i=0;i<bombs.length;i++)\\n         {\\n\\n             int x1=bombs[i][0];\\n               int y1=bombs[i][1];\\n               int r1=bombs[i][2];\\n\\n\\n             for(int j=0;j<bombs.length;j++)\\n             {\\n                \\n                if(j==i)continue;\\n                \\n               int x2=bombs[j][0];\\n               int y2=bombs[j][1];\\n               int r2=bombs[j][2];\\n\\n                 int d=r1+r2;\\n\\nif((long)d*(long)d>=((long)(x1-x2)*(long)(x1-x2))+((long)(y1-y2)*(long)(y1-y2)))\\n                 {\\n                     graph[i].add(new Edge(i,j));\\n                     \\n\\n                     //System.out.println(i+\" \"+j);\\n                 }\\n\\n             }\\n         }\\n\\n\\n         boolean []vis=new boolean[n];\\n            \\n           \\n         for(int i=0;i<n;i++)\\n         {\\n             det=0;\\n            if(!vis[i]){\\n\\n                 dfs(graph,i,vis);\\n                 ans=Math.max(det,ans);\\n             }\\n         }\\n         return ans;\\n\\n    }\\n\\n\\n    private void dfs(ArrayList<Edge>graph[],int curr,boolean[]vis)\\n    {\\n        vis[curr]=true;\\n                det++;\\n        for(int i=0;i<graph[curr].size();i++)\\n        {\\n            Edge e=graph[curr].get(i);\\n\\n            if(!vis[e.dest])\\n            {\\n              dfs(graph,e.dest,vis);\\n            }\\n        }\\n    }\\n}\\n\\n\\nCan anyone tel me why this code is not working . I am using the property of circles where if r1+r2<=distance between the centres of two circles , then they must be colliding and hence we will make both circles neighbours"
                    }
                ]
            },
            {
                "id": 1913924,
                "content": [
                    {
                        "username": "shtl",
                        "content": "[[37207,2653,5261],\\n[40784,59523,20635],\\n[16390,1426,39102],\\n[42236,12,96855],\\n[72839,62027,61667],\\n[60691,58191,48447],\\n[42932,46579,41248],\\n[35868,43119,6870],\\n[41693,98905,17374],\\n[43441,1266,41621]]\\nIn this case I have only 5 - 1,4,5,6,7, but expected 10. Why?"
                    },
                    {
                        "username": "shtl",
                        "content": "[@tungbuivn](/tungbuivn) I found problem, was bad convertion to long from int."
                    },
                    {
                        "username": "shtl",
                        "content": "[@tungbuivn](/tungbuivn) Chain 0-3 don\\'t work. Distanse[5029,2641]=5680.3, more, then 5261."
                    },
                    {
                        "username": "tungbuivn",
                        "content": "perhap you missing some where, here is 10 items from my program: [2,0,3,9,1,4,5,6,7,8], you could trace your program with that list"
                    },
                    {
                        "username": "himanshu693",
                        "content": "[[5149,1,2],[5146,1,3],[5142,1,4],[5137,1,5],[5131,1,6],[5124,1,7],[5116,1,8],[5107,1,9],[5097,1,10],[5086,1,11],[5074,1,12],[5061,1,13],[5047,1,14],[5032,1,15],[5016,1,16],[4999,1,17],[4981,1,18],[4962,1,19],[4942,1,20],[4921,1,21],[4899,1,22],[4876,1,23],[4852,1,24],[4827,1,25],[4801,1,26],[4774,1,27],[4746,1,28],[4717,1,29],[4687,1,30],[4656,1,31],[4624,1,32],[4591,1,33],[4557,1,34],[4522,1,35],[4486,1,36],[4449,1,37],[4411,1,38],[4372,1,39],[4332,1,40],[4291,1,41],[4249,1,42],[4206,1,43],[4162,1,44],[4117,1,45],[4071,1,46],[4024,1,47],[3976,1,48],[3927,1,49],[3877,1,50],[3826,1,51],[3774,1,52],[3721,1,53],[3667,1,54],[3612,1,55],[3556,1,56],[3499,1,57],[3441,1,58],[3382,1,59],[3322,1,60],[3261,1,61],[3199,1,62],[3136,1,63],[3072,1,64],[3007,1,65],[2941,1,66],[2874,1,67],[2806,1,68],[2737,1,69],[2667,1,70],[2596,1,71],[2524,1,72],[2451,1,73],[2377,1,74],[2302,1,75],[2226,1,76],[2149,1,77],[2071,1,78],[1992,1,79],[1912,1,80],[1831,1,81],[1749,1,82],[1666,1,83],[1582,1,84],[1497,1,85],[1411,1,86],[1324,1,87],[1236,1,88],[1147,1,89],[1057,1,90],[966,1,91],[874,1,92],[781,1,93],[687,1,94],[592,1,95],[496,1,96],[399,1,97],[301,1,98],[202,1,99],[102,1,100],[1,1,101]]\\n\\nfor this testcase I am getting 15 which I think is correct because 0, 1, 2, 3, 4 are isolated from other nodes so 5 nodes already gone from 100 so how 100 can be ans?"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "here is 100 items in order to debug your code =))\\n[99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,77,76,75,74,73,72,71,70,69,68,67,66,65,64,63,62,61,60,59,58,57,56,55,54,53,52,51,50,49,48,47,46,45,44,43,42,41,40,39,38,37,36,35,34,33,32,31,30,29,28,27,26,25,24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0]"
                    },
                    {
                        "username": "sravan_csed",
                        "content": "For this input the expected answer from leetcode is 1. Shouldn\\'t it be 2 as denotating bomb with index : 0 will detonate the other bomb\\n\\n[[1,1,100000],[100000,100000,1]]"
                    },
                    {
                        "username": "_SID_",
                        "content": "Check this, you can understand easily :  https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588930/1-1-100000-100000-100000-1-getting-wrong-understand-why/"
                    },
                    {
                        "username": "sravan_csed",
                        "content": "My bad  - issue was with casting squared distance to long"
                    },
                    {
                        "username": "vctr_",
                        "content": " `your inline code... \\nclass Solution {\\npublic:\\n    bool inRange(int i, int j, vector<vector<int>>& bombs){\\n        long long d = pow((bombs[i][0]-bombs[j][0]), 2)+pow((bombs[i][1]-bombs[i][1]), 2);\\n    \\n        if(d>pow(bombs[i][2], 2)){\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n = bombs.size();\\n        int maxm = INT_MIN; \\n        int curr = 0;\\n\\n        for(int i=0; i<n; i++){\\n            curr = 0;\\n            for(int j = 0; j<n; j++){\\n                if(inRange(i, j, bombs)){\\n                    curr++;\\n                    maxm = max(curr, maxm);\\n                }\\n            }\\n        }\\n        return maxm;\\n    }\\n};\\nyour inline code...`\\n\\n\\nI have written this brute force code to solve the problem.\\nbut it is giving me wrong answer for bombs =\\n[[1,1,100000],[100000,100000,1]] this case\\nWhere is the error?\\n"
                    },
                    {
                        "username": "note_08",
                        "content": "why cant we do this question by finding the points in its  range and maximizing the answer\\n"
                    },
                    {
                        "username": "charonme",
                        "content": "because of the secondary chain explosions"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Seems like a hard problem"
                    },
                    {
                        "username": "charonme",
                        "content": "not hard, just a composition of one easy + one almost-easy medium"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "A good hint for this problem could be,\\nManhattan Distance from src-to-destination can help in making Graph"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@dkochetov](/dkochetov) Quick addition: as precise euclidean distance is not needed, square root is not needed, just compare with r^2"
                    },
                    {
                        "username": "dkochetov",
                        "content": "No, you must use euclidean distance here"
                    },
                    {
                        "username": "eduard92",
                        "content": "I am so bad at graphs I cannot visualize how to implement DFS"
                    },
                    {
                        "username": "EgorMaral",
                        "content": "Python. I cannot use:\n ` def dfs(cur, visited=set()):`\nAnd i dont know why. Please, give me advice.\n\nAddition.\n```python\ndef dfs(cur, visited=set(), count=0):\n    if count == 0:\n        print(visited)\n    visited.add(cur)\n    count += 1\n    ...\n```\nLeads to the result:\n```python\nset()\n{0}\n{0, 1}\n{0, 1, 2}\n...\n```\nThat is, the variable __visisted__ is cached, but the variable __count__ is not.\nAnd:\n```python\ndef dfs(cur, visited=None):\n```\nis work"
                    },
                    {
                        "username": "james4388",
                        "content": "visited=set() in there will create a set and it live in global space, which will share that to all subsequence call. the correct way is\n```\ndef dfs(cur, visited=None):\n    visited = visited or set()\n    ....\n```\nsame apply for class instance\n```\nclass xyz:\n   var_here = set(). # this will be shared everywehre\n   def __init__(self):\n        self.something = set(). # this is safe\n```\n"
                    },
                    {
                        "username": "Krishak_20",
                        "content": "class Solution {\\n     int ans=0;\\n     int det=0;\\n\\n\\n     class Edge\\n     {\\n         int src,dest;\\n\\n         Edge(int src,int dest)\\n         {\\n             this.src=src;\\n             this.dest=dest;\\n         }\\n     }\\n    public int maximumDetonation(int[][] bombs) {\\n           \\n           int n=bombs.length;\\n\\n         ArrayList<Edge>graph[]=new ArrayList[n];\\n               for(int i=0;i<n;i++)graph[i]=new ArrayList<>();\\n            \\n         for(int i=0;i<bombs.length;i++)\\n         {\\n\\n             int x1=bombs[i][0];\\n               int y1=bombs[i][1];\\n               int r1=bombs[i][2];\\n\\n\\n             for(int j=0;j<bombs.length;j++)\\n             {\\n                \\n                if(j==i)continue;\\n                \\n               int x2=bombs[j][0];\\n               int y2=bombs[j][1];\\n               int r2=bombs[j][2];\\n\\n                 int d=r1+r2;\\n\\nif((long)d*(long)d>=((long)(x1-x2)*(long)(x1-x2))+((long)(y1-y2)*(long)(y1-y2)))\\n                 {\\n                     graph[i].add(new Edge(i,j));\\n                     \\n\\n                     //System.out.println(i+\" \"+j);\\n                 }\\n\\n             }\\n         }\\n\\n\\n         boolean []vis=new boolean[n];\\n            \\n           \\n         for(int i=0;i<n;i++)\\n         {\\n             det=0;\\n            if(!vis[i]){\\n\\n                 dfs(graph,i,vis);\\n                 ans=Math.max(det,ans);\\n             }\\n         }\\n         return ans;\\n\\n    }\\n\\n\\n    private void dfs(ArrayList<Edge>graph[],int curr,boolean[]vis)\\n    {\\n        vis[curr]=true;\\n                det++;\\n        for(int i=0;i<graph[curr].size();i++)\\n        {\\n            Edge e=graph[curr].get(i);\\n\\n            if(!vis[e.dest])\\n            {\\n              dfs(graph,e.dest,vis);\\n            }\\n        }\\n    }\\n}\\n\\n\\nCan anyone tel me why this code is not working . I am using the property of circles where if r1+r2<=distance between the centres of two circles , then they must be colliding and hence we will make both circles neighbours"
                    }
                ]
            },
            {
                "id": 1913921,
                "content": [
                    {
                        "username": "shtl",
                        "content": "[[37207,2653,5261],\\n[40784,59523,20635],\\n[16390,1426,39102],\\n[42236,12,96855],\\n[72839,62027,61667],\\n[60691,58191,48447],\\n[42932,46579,41248],\\n[35868,43119,6870],\\n[41693,98905,17374],\\n[43441,1266,41621]]\\nIn this case I have only 5 - 1,4,5,6,7, but expected 10. Why?"
                    },
                    {
                        "username": "shtl",
                        "content": "[@tungbuivn](/tungbuivn) I found problem, was bad convertion to long from int."
                    },
                    {
                        "username": "shtl",
                        "content": "[@tungbuivn](/tungbuivn) Chain 0-3 don\\'t work. Distanse[5029,2641]=5680.3, more, then 5261."
                    },
                    {
                        "username": "tungbuivn",
                        "content": "perhap you missing some where, here is 10 items from my program: [2,0,3,9,1,4,5,6,7,8], you could trace your program with that list"
                    },
                    {
                        "username": "himanshu693",
                        "content": "[[5149,1,2],[5146,1,3],[5142,1,4],[5137,1,5],[5131,1,6],[5124,1,7],[5116,1,8],[5107,1,9],[5097,1,10],[5086,1,11],[5074,1,12],[5061,1,13],[5047,1,14],[5032,1,15],[5016,1,16],[4999,1,17],[4981,1,18],[4962,1,19],[4942,1,20],[4921,1,21],[4899,1,22],[4876,1,23],[4852,1,24],[4827,1,25],[4801,1,26],[4774,1,27],[4746,1,28],[4717,1,29],[4687,1,30],[4656,1,31],[4624,1,32],[4591,1,33],[4557,1,34],[4522,1,35],[4486,1,36],[4449,1,37],[4411,1,38],[4372,1,39],[4332,1,40],[4291,1,41],[4249,1,42],[4206,1,43],[4162,1,44],[4117,1,45],[4071,1,46],[4024,1,47],[3976,1,48],[3927,1,49],[3877,1,50],[3826,1,51],[3774,1,52],[3721,1,53],[3667,1,54],[3612,1,55],[3556,1,56],[3499,1,57],[3441,1,58],[3382,1,59],[3322,1,60],[3261,1,61],[3199,1,62],[3136,1,63],[3072,1,64],[3007,1,65],[2941,1,66],[2874,1,67],[2806,1,68],[2737,1,69],[2667,1,70],[2596,1,71],[2524,1,72],[2451,1,73],[2377,1,74],[2302,1,75],[2226,1,76],[2149,1,77],[2071,1,78],[1992,1,79],[1912,1,80],[1831,1,81],[1749,1,82],[1666,1,83],[1582,1,84],[1497,1,85],[1411,1,86],[1324,1,87],[1236,1,88],[1147,1,89],[1057,1,90],[966,1,91],[874,1,92],[781,1,93],[687,1,94],[592,1,95],[496,1,96],[399,1,97],[301,1,98],[202,1,99],[102,1,100],[1,1,101]]\\n\\nfor this testcase I am getting 15 which I think is correct because 0, 1, 2, 3, 4 are isolated from other nodes so 5 nodes already gone from 100 so how 100 can be ans?"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "here is 100 items in order to debug your code =))\\n[99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,77,76,75,74,73,72,71,70,69,68,67,66,65,64,63,62,61,60,59,58,57,56,55,54,53,52,51,50,49,48,47,46,45,44,43,42,41,40,39,38,37,36,35,34,33,32,31,30,29,28,27,26,25,24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0]"
                    },
                    {
                        "username": "sravan_csed",
                        "content": "For this input the expected answer from leetcode is 1. Shouldn\\'t it be 2 as denotating bomb with index : 0 will detonate the other bomb\\n\\n[[1,1,100000],[100000,100000,1]]"
                    },
                    {
                        "username": "_SID_",
                        "content": "Check this, you can understand easily :  https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588930/1-1-100000-100000-100000-1-getting-wrong-understand-why/"
                    },
                    {
                        "username": "sravan_csed",
                        "content": "My bad  - issue was with casting squared distance to long"
                    },
                    {
                        "username": "vctr_",
                        "content": " `your inline code... \\nclass Solution {\\npublic:\\n    bool inRange(int i, int j, vector<vector<int>>& bombs){\\n        long long d = pow((bombs[i][0]-bombs[j][0]), 2)+pow((bombs[i][1]-bombs[i][1]), 2);\\n    \\n        if(d>pow(bombs[i][2], 2)){\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n = bombs.size();\\n        int maxm = INT_MIN; \\n        int curr = 0;\\n\\n        for(int i=0; i<n; i++){\\n            curr = 0;\\n            for(int j = 0; j<n; j++){\\n                if(inRange(i, j, bombs)){\\n                    curr++;\\n                    maxm = max(curr, maxm);\\n                }\\n            }\\n        }\\n        return maxm;\\n    }\\n};\\nyour inline code...`\\n\\n\\nI have written this brute force code to solve the problem.\\nbut it is giving me wrong answer for bombs =\\n[[1,1,100000],[100000,100000,1]] this case\\nWhere is the error?\\n"
                    },
                    {
                        "username": "note_08",
                        "content": "why cant we do this question by finding the points in its  range and maximizing the answer\\n"
                    },
                    {
                        "username": "charonme",
                        "content": "because of the secondary chain explosions"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Seems like a hard problem"
                    },
                    {
                        "username": "charonme",
                        "content": "not hard, just a composition of one easy + one almost-easy medium"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "A good hint for this problem could be,\\nManhattan Distance from src-to-destination can help in making Graph"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@dkochetov](/dkochetov) Quick addition: as precise euclidean distance is not needed, square root is not needed, just compare with r^2"
                    },
                    {
                        "username": "dkochetov",
                        "content": "No, you must use euclidean distance here"
                    },
                    {
                        "username": "eduard92",
                        "content": "I am so bad at graphs I cannot visualize how to implement DFS"
                    },
                    {
                        "username": "EgorMaral",
                        "content": "Python. I cannot use:\n ` def dfs(cur, visited=set()):`\nAnd i dont know why. Please, give me advice.\n\nAddition.\n```python\ndef dfs(cur, visited=set(), count=0):\n    if count == 0:\n        print(visited)\n    visited.add(cur)\n    count += 1\n    ...\n```\nLeads to the result:\n```python\nset()\n{0}\n{0, 1}\n{0, 1, 2}\n...\n```\nThat is, the variable __visisted__ is cached, but the variable __count__ is not.\nAnd:\n```python\ndef dfs(cur, visited=None):\n```\nis work"
                    },
                    {
                        "username": "james4388",
                        "content": "visited=set() in there will create a set and it live in global space, which will share that to all subsequence call. the correct way is\n```\ndef dfs(cur, visited=None):\n    visited = visited or set()\n    ....\n```\nsame apply for class instance\n```\nclass xyz:\n   var_here = set(). # this will be shared everywehre\n   def __init__(self):\n        self.something = set(). # this is safe\n```\n"
                    },
                    {
                        "username": "Krishak_20",
                        "content": "class Solution {\\n     int ans=0;\\n     int det=0;\\n\\n\\n     class Edge\\n     {\\n         int src,dest;\\n\\n         Edge(int src,int dest)\\n         {\\n             this.src=src;\\n             this.dest=dest;\\n         }\\n     }\\n    public int maximumDetonation(int[][] bombs) {\\n           \\n           int n=bombs.length;\\n\\n         ArrayList<Edge>graph[]=new ArrayList[n];\\n               for(int i=0;i<n;i++)graph[i]=new ArrayList<>();\\n            \\n         for(int i=0;i<bombs.length;i++)\\n         {\\n\\n             int x1=bombs[i][0];\\n               int y1=bombs[i][1];\\n               int r1=bombs[i][2];\\n\\n\\n             for(int j=0;j<bombs.length;j++)\\n             {\\n                \\n                if(j==i)continue;\\n                \\n               int x2=bombs[j][0];\\n               int y2=bombs[j][1];\\n               int r2=bombs[j][2];\\n\\n                 int d=r1+r2;\\n\\nif((long)d*(long)d>=((long)(x1-x2)*(long)(x1-x2))+((long)(y1-y2)*(long)(y1-y2)))\\n                 {\\n                     graph[i].add(new Edge(i,j));\\n                     \\n\\n                     //System.out.println(i+\" \"+j);\\n                 }\\n\\n             }\\n         }\\n\\n\\n         boolean []vis=new boolean[n];\\n            \\n           \\n         for(int i=0;i<n;i++)\\n         {\\n             det=0;\\n            if(!vis[i]){\\n\\n                 dfs(graph,i,vis);\\n                 ans=Math.max(det,ans);\\n             }\\n         }\\n         return ans;\\n\\n    }\\n\\n\\n    private void dfs(ArrayList<Edge>graph[],int curr,boolean[]vis)\\n    {\\n        vis[curr]=true;\\n                det++;\\n        for(int i=0;i<graph[curr].size();i++)\\n        {\\n            Edge e=graph[curr].get(i);\\n\\n            if(!vis[e.dest])\\n            {\\n              dfs(graph,e.dest,vis);\\n            }\\n        }\\n    }\\n}\\n\\n\\nCan anyone tel me why this code is not working . I am using the property of circles where if r1+r2<=distance between the centres of two circles , then they must be colliding and hence we will make both circles neighbours"
                    }
                ]
            },
            {
                "id": 1913904,
                "content": [
                    {
                        "username": "shtl",
                        "content": "[[37207,2653,5261],\\n[40784,59523,20635],\\n[16390,1426,39102],\\n[42236,12,96855],\\n[72839,62027,61667],\\n[60691,58191,48447],\\n[42932,46579,41248],\\n[35868,43119,6870],\\n[41693,98905,17374],\\n[43441,1266,41621]]\\nIn this case I have only 5 - 1,4,5,6,7, but expected 10. Why?"
                    },
                    {
                        "username": "shtl",
                        "content": "[@tungbuivn](/tungbuivn) I found problem, was bad convertion to long from int."
                    },
                    {
                        "username": "shtl",
                        "content": "[@tungbuivn](/tungbuivn) Chain 0-3 don\\'t work. Distanse[5029,2641]=5680.3, more, then 5261."
                    },
                    {
                        "username": "tungbuivn",
                        "content": "perhap you missing some where, here is 10 items from my program: [2,0,3,9,1,4,5,6,7,8], you could trace your program with that list"
                    },
                    {
                        "username": "himanshu693",
                        "content": "[[5149,1,2],[5146,1,3],[5142,1,4],[5137,1,5],[5131,1,6],[5124,1,7],[5116,1,8],[5107,1,9],[5097,1,10],[5086,1,11],[5074,1,12],[5061,1,13],[5047,1,14],[5032,1,15],[5016,1,16],[4999,1,17],[4981,1,18],[4962,1,19],[4942,1,20],[4921,1,21],[4899,1,22],[4876,1,23],[4852,1,24],[4827,1,25],[4801,1,26],[4774,1,27],[4746,1,28],[4717,1,29],[4687,1,30],[4656,1,31],[4624,1,32],[4591,1,33],[4557,1,34],[4522,1,35],[4486,1,36],[4449,1,37],[4411,1,38],[4372,1,39],[4332,1,40],[4291,1,41],[4249,1,42],[4206,1,43],[4162,1,44],[4117,1,45],[4071,1,46],[4024,1,47],[3976,1,48],[3927,1,49],[3877,1,50],[3826,1,51],[3774,1,52],[3721,1,53],[3667,1,54],[3612,1,55],[3556,1,56],[3499,1,57],[3441,1,58],[3382,1,59],[3322,1,60],[3261,1,61],[3199,1,62],[3136,1,63],[3072,1,64],[3007,1,65],[2941,1,66],[2874,1,67],[2806,1,68],[2737,1,69],[2667,1,70],[2596,1,71],[2524,1,72],[2451,1,73],[2377,1,74],[2302,1,75],[2226,1,76],[2149,1,77],[2071,1,78],[1992,1,79],[1912,1,80],[1831,1,81],[1749,1,82],[1666,1,83],[1582,1,84],[1497,1,85],[1411,1,86],[1324,1,87],[1236,1,88],[1147,1,89],[1057,1,90],[966,1,91],[874,1,92],[781,1,93],[687,1,94],[592,1,95],[496,1,96],[399,1,97],[301,1,98],[202,1,99],[102,1,100],[1,1,101]]\\n\\nfor this testcase I am getting 15 which I think is correct because 0, 1, 2, 3, 4 are isolated from other nodes so 5 nodes already gone from 100 so how 100 can be ans?"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "here is 100 items in order to debug your code =))\\n[99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,77,76,75,74,73,72,71,70,69,68,67,66,65,64,63,62,61,60,59,58,57,56,55,54,53,52,51,50,49,48,47,46,45,44,43,42,41,40,39,38,37,36,35,34,33,32,31,30,29,28,27,26,25,24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0]"
                    },
                    {
                        "username": "sravan_csed",
                        "content": "For this input the expected answer from leetcode is 1. Shouldn\\'t it be 2 as denotating bomb with index : 0 will detonate the other bomb\\n\\n[[1,1,100000],[100000,100000,1]]"
                    },
                    {
                        "username": "_SID_",
                        "content": "Check this, you can understand easily :  https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588930/1-1-100000-100000-100000-1-getting-wrong-understand-why/"
                    },
                    {
                        "username": "sravan_csed",
                        "content": "My bad  - issue was with casting squared distance to long"
                    },
                    {
                        "username": "vctr_",
                        "content": " `your inline code... \\nclass Solution {\\npublic:\\n    bool inRange(int i, int j, vector<vector<int>>& bombs){\\n        long long d = pow((bombs[i][0]-bombs[j][0]), 2)+pow((bombs[i][1]-bombs[i][1]), 2);\\n    \\n        if(d>pow(bombs[i][2], 2)){\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n = bombs.size();\\n        int maxm = INT_MIN; \\n        int curr = 0;\\n\\n        for(int i=0; i<n; i++){\\n            curr = 0;\\n            for(int j = 0; j<n; j++){\\n                if(inRange(i, j, bombs)){\\n                    curr++;\\n                    maxm = max(curr, maxm);\\n                }\\n            }\\n        }\\n        return maxm;\\n    }\\n};\\nyour inline code...`\\n\\n\\nI have written this brute force code to solve the problem.\\nbut it is giving me wrong answer for bombs =\\n[[1,1,100000],[100000,100000,1]] this case\\nWhere is the error?\\n"
                    },
                    {
                        "username": "note_08",
                        "content": "why cant we do this question by finding the points in its  range and maximizing the answer\\n"
                    },
                    {
                        "username": "charonme",
                        "content": "because of the secondary chain explosions"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Seems like a hard problem"
                    },
                    {
                        "username": "charonme",
                        "content": "not hard, just a composition of one easy + one almost-easy medium"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "A good hint for this problem could be,\\nManhattan Distance from src-to-destination can help in making Graph"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@dkochetov](/dkochetov) Quick addition: as precise euclidean distance is not needed, square root is not needed, just compare with r^2"
                    },
                    {
                        "username": "dkochetov",
                        "content": "No, you must use euclidean distance here"
                    },
                    {
                        "username": "eduard92",
                        "content": "I am so bad at graphs I cannot visualize how to implement DFS"
                    },
                    {
                        "username": "EgorMaral",
                        "content": "Python. I cannot use:\n ` def dfs(cur, visited=set()):`\nAnd i dont know why. Please, give me advice.\n\nAddition.\n```python\ndef dfs(cur, visited=set(), count=0):\n    if count == 0:\n        print(visited)\n    visited.add(cur)\n    count += 1\n    ...\n```\nLeads to the result:\n```python\nset()\n{0}\n{0, 1}\n{0, 1, 2}\n...\n```\nThat is, the variable __visisted__ is cached, but the variable __count__ is not.\nAnd:\n```python\ndef dfs(cur, visited=None):\n```\nis work"
                    },
                    {
                        "username": "james4388",
                        "content": "visited=set() in there will create a set and it live in global space, which will share that to all subsequence call. the correct way is\n```\ndef dfs(cur, visited=None):\n    visited = visited or set()\n    ....\n```\nsame apply for class instance\n```\nclass xyz:\n   var_here = set(). # this will be shared everywehre\n   def __init__(self):\n        self.something = set(). # this is safe\n```\n"
                    },
                    {
                        "username": "Krishak_20",
                        "content": "class Solution {\\n     int ans=0;\\n     int det=0;\\n\\n\\n     class Edge\\n     {\\n         int src,dest;\\n\\n         Edge(int src,int dest)\\n         {\\n             this.src=src;\\n             this.dest=dest;\\n         }\\n     }\\n    public int maximumDetonation(int[][] bombs) {\\n           \\n           int n=bombs.length;\\n\\n         ArrayList<Edge>graph[]=new ArrayList[n];\\n               for(int i=0;i<n;i++)graph[i]=new ArrayList<>();\\n            \\n         for(int i=0;i<bombs.length;i++)\\n         {\\n\\n             int x1=bombs[i][0];\\n               int y1=bombs[i][1];\\n               int r1=bombs[i][2];\\n\\n\\n             for(int j=0;j<bombs.length;j++)\\n             {\\n                \\n                if(j==i)continue;\\n                \\n               int x2=bombs[j][0];\\n               int y2=bombs[j][1];\\n               int r2=bombs[j][2];\\n\\n                 int d=r1+r2;\\n\\nif((long)d*(long)d>=((long)(x1-x2)*(long)(x1-x2))+((long)(y1-y2)*(long)(y1-y2)))\\n                 {\\n                     graph[i].add(new Edge(i,j));\\n                     \\n\\n                     //System.out.println(i+\" \"+j);\\n                 }\\n\\n             }\\n         }\\n\\n\\n         boolean []vis=new boolean[n];\\n            \\n           \\n         for(int i=0;i<n;i++)\\n         {\\n             det=0;\\n            if(!vis[i]){\\n\\n                 dfs(graph,i,vis);\\n                 ans=Math.max(det,ans);\\n             }\\n         }\\n         return ans;\\n\\n    }\\n\\n\\n    private void dfs(ArrayList<Edge>graph[],int curr,boolean[]vis)\\n    {\\n        vis[curr]=true;\\n                det++;\\n        for(int i=0;i<graph[curr].size();i++)\\n        {\\n            Edge e=graph[curr].get(i);\\n\\n            if(!vis[e.dest])\\n            {\\n              dfs(graph,e.dest,vis);\\n            }\\n        }\\n    }\\n}\\n\\n\\nCan anyone tel me why this code is not working . I am using the property of circles where if r1+r2<=distance between the centres of two circles , then they must be colliding and hence we will make both circles neighbours"
                    }
                ]
            },
            {
                "id": 1913903,
                "content": [
                    {
                        "username": "shtl",
                        "content": "[[37207,2653,5261],\\n[40784,59523,20635],\\n[16390,1426,39102],\\n[42236,12,96855],\\n[72839,62027,61667],\\n[60691,58191,48447],\\n[42932,46579,41248],\\n[35868,43119,6870],\\n[41693,98905,17374],\\n[43441,1266,41621]]\\nIn this case I have only 5 - 1,4,5,6,7, but expected 10. Why?"
                    },
                    {
                        "username": "shtl",
                        "content": "[@tungbuivn](/tungbuivn) I found problem, was bad convertion to long from int."
                    },
                    {
                        "username": "shtl",
                        "content": "[@tungbuivn](/tungbuivn) Chain 0-3 don\\'t work. Distanse[5029,2641]=5680.3, more, then 5261."
                    },
                    {
                        "username": "tungbuivn",
                        "content": "perhap you missing some where, here is 10 items from my program: [2,0,3,9,1,4,5,6,7,8], you could trace your program with that list"
                    },
                    {
                        "username": "himanshu693",
                        "content": "[[5149,1,2],[5146,1,3],[5142,1,4],[5137,1,5],[5131,1,6],[5124,1,7],[5116,1,8],[5107,1,9],[5097,1,10],[5086,1,11],[5074,1,12],[5061,1,13],[5047,1,14],[5032,1,15],[5016,1,16],[4999,1,17],[4981,1,18],[4962,1,19],[4942,1,20],[4921,1,21],[4899,1,22],[4876,1,23],[4852,1,24],[4827,1,25],[4801,1,26],[4774,1,27],[4746,1,28],[4717,1,29],[4687,1,30],[4656,1,31],[4624,1,32],[4591,1,33],[4557,1,34],[4522,1,35],[4486,1,36],[4449,1,37],[4411,1,38],[4372,1,39],[4332,1,40],[4291,1,41],[4249,1,42],[4206,1,43],[4162,1,44],[4117,1,45],[4071,1,46],[4024,1,47],[3976,1,48],[3927,1,49],[3877,1,50],[3826,1,51],[3774,1,52],[3721,1,53],[3667,1,54],[3612,1,55],[3556,1,56],[3499,1,57],[3441,1,58],[3382,1,59],[3322,1,60],[3261,1,61],[3199,1,62],[3136,1,63],[3072,1,64],[3007,1,65],[2941,1,66],[2874,1,67],[2806,1,68],[2737,1,69],[2667,1,70],[2596,1,71],[2524,1,72],[2451,1,73],[2377,1,74],[2302,1,75],[2226,1,76],[2149,1,77],[2071,1,78],[1992,1,79],[1912,1,80],[1831,1,81],[1749,1,82],[1666,1,83],[1582,1,84],[1497,1,85],[1411,1,86],[1324,1,87],[1236,1,88],[1147,1,89],[1057,1,90],[966,1,91],[874,1,92],[781,1,93],[687,1,94],[592,1,95],[496,1,96],[399,1,97],[301,1,98],[202,1,99],[102,1,100],[1,1,101]]\\n\\nfor this testcase I am getting 15 which I think is correct because 0, 1, 2, 3, 4 are isolated from other nodes so 5 nodes already gone from 100 so how 100 can be ans?"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "here is 100 items in order to debug your code =))\\n[99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,77,76,75,74,73,72,71,70,69,68,67,66,65,64,63,62,61,60,59,58,57,56,55,54,53,52,51,50,49,48,47,46,45,44,43,42,41,40,39,38,37,36,35,34,33,32,31,30,29,28,27,26,25,24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0]"
                    },
                    {
                        "username": "sravan_csed",
                        "content": "For this input the expected answer from leetcode is 1. Shouldn\\'t it be 2 as denotating bomb with index : 0 will detonate the other bomb\\n\\n[[1,1,100000],[100000,100000,1]]"
                    },
                    {
                        "username": "_SID_",
                        "content": "Check this, you can understand easily :  https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588930/1-1-100000-100000-100000-1-getting-wrong-understand-why/"
                    },
                    {
                        "username": "sravan_csed",
                        "content": "My bad  - issue was with casting squared distance to long"
                    },
                    {
                        "username": "vctr_",
                        "content": " `your inline code... \\nclass Solution {\\npublic:\\n    bool inRange(int i, int j, vector<vector<int>>& bombs){\\n        long long d = pow((bombs[i][0]-bombs[j][0]), 2)+pow((bombs[i][1]-bombs[i][1]), 2);\\n    \\n        if(d>pow(bombs[i][2], 2)){\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n = bombs.size();\\n        int maxm = INT_MIN; \\n        int curr = 0;\\n\\n        for(int i=0; i<n; i++){\\n            curr = 0;\\n            for(int j = 0; j<n; j++){\\n                if(inRange(i, j, bombs)){\\n                    curr++;\\n                    maxm = max(curr, maxm);\\n                }\\n            }\\n        }\\n        return maxm;\\n    }\\n};\\nyour inline code...`\\n\\n\\nI have written this brute force code to solve the problem.\\nbut it is giving me wrong answer for bombs =\\n[[1,1,100000],[100000,100000,1]] this case\\nWhere is the error?\\n"
                    },
                    {
                        "username": "note_08",
                        "content": "why cant we do this question by finding the points in its  range and maximizing the answer\\n"
                    },
                    {
                        "username": "charonme",
                        "content": "because of the secondary chain explosions"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Seems like a hard problem"
                    },
                    {
                        "username": "charonme",
                        "content": "not hard, just a composition of one easy + one almost-easy medium"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "A good hint for this problem could be,\\nManhattan Distance from src-to-destination can help in making Graph"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@dkochetov](/dkochetov) Quick addition: as precise euclidean distance is not needed, square root is not needed, just compare with r^2"
                    },
                    {
                        "username": "dkochetov",
                        "content": "No, you must use euclidean distance here"
                    },
                    {
                        "username": "eduard92",
                        "content": "I am so bad at graphs I cannot visualize how to implement DFS"
                    },
                    {
                        "username": "EgorMaral",
                        "content": "Python. I cannot use:\n ` def dfs(cur, visited=set()):`\nAnd i dont know why. Please, give me advice.\n\nAddition.\n```python\ndef dfs(cur, visited=set(), count=0):\n    if count == 0:\n        print(visited)\n    visited.add(cur)\n    count += 1\n    ...\n```\nLeads to the result:\n```python\nset()\n{0}\n{0, 1}\n{0, 1, 2}\n...\n```\nThat is, the variable __visisted__ is cached, but the variable __count__ is not.\nAnd:\n```python\ndef dfs(cur, visited=None):\n```\nis work"
                    },
                    {
                        "username": "james4388",
                        "content": "visited=set() in there will create a set and it live in global space, which will share that to all subsequence call. the correct way is\n```\ndef dfs(cur, visited=None):\n    visited = visited or set()\n    ....\n```\nsame apply for class instance\n```\nclass xyz:\n   var_here = set(). # this will be shared everywehre\n   def __init__(self):\n        self.something = set(). # this is safe\n```\n"
                    },
                    {
                        "username": "Krishak_20",
                        "content": "class Solution {\\n     int ans=0;\\n     int det=0;\\n\\n\\n     class Edge\\n     {\\n         int src,dest;\\n\\n         Edge(int src,int dest)\\n         {\\n             this.src=src;\\n             this.dest=dest;\\n         }\\n     }\\n    public int maximumDetonation(int[][] bombs) {\\n           \\n           int n=bombs.length;\\n\\n         ArrayList<Edge>graph[]=new ArrayList[n];\\n               for(int i=0;i<n;i++)graph[i]=new ArrayList<>();\\n            \\n         for(int i=0;i<bombs.length;i++)\\n         {\\n\\n             int x1=bombs[i][0];\\n               int y1=bombs[i][1];\\n               int r1=bombs[i][2];\\n\\n\\n             for(int j=0;j<bombs.length;j++)\\n             {\\n                \\n                if(j==i)continue;\\n                \\n               int x2=bombs[j][0];\\n               int y2=bombs[j][1];\\n               int r2=bombs[j][2];\\n\\n                 int d=r1+r2;\\n\\nif((long)d*(long)d>=((long)(x1-x2)*(long)(x1-x2))+((long)(y1-y2)*(long)(y1-y2)))\\n                 {\\n                     graph[i].add(new Edge(i,j));\\n                     \\n\\n                     //System.out.println(i+\" \"+j);\\n                 }\\n\\n             }\\n         }\\n\\n\\n         boolean []vis=new boolean[n];\\n            \\n           \\n         for(int i=0;i<n;i++)\\n         {\\n             det=0;\\n            if(!vis[i]){\\n\\n                 dfs(graph,i,vis);\\n                 ans=Math.max(det,ans);\\n             }\\n         }\\n         return ans;\\n\\n    }\\n\\n\\n    private void dfs(ArrayList<Edge>graph[],int curr,boolean[]vis)\\n    {\\n        vis[curr]=true;\\n                det++;\\n        for(int i=0;i<graph[curr].size();i++)\\n        {\\n            Edge e=graph[curr].get(i);\\n\\n            if(!vis[e.dest])\\n            {\\n              dfs(graph,e.dest,vis);\\n            }\\n        }\\n    }\\n}\\n\\n\\nCan anyone tel me why this code is not working . I am using the property of circles where if r1+r2<=distance between the centres of two circles , then they must be colliding and hence we will make both circles neighbours"
                    }
                ]
            },
            {
                "id": 1913902,
                "content": [
                    {
                        "username": "shtl",
                        "content": "[[37207,2653,5261],\\n[40784,59523,20635],\\n[16390,1426,39102],\\n[42236,12,96855],\\n[72839,62027,61667],\\n[60691,58191,48447],\\n[42932,46579,41248],\\n[35868,43119,6870],\\n[41693,98905,17374],\\n[43441,1266,41621]]\\nIn this case I have only 5 - 1,4,5,6,7, but expected 10. Why?"
                    },
                    {
                        "username": "shtl",
                        "content": "[@tungbuivn](/tungbuivn) I found problem, was bad convertion to long from int."
                    },
                    {
                        "username": "shtl",
                        "content": "[@tungbuivn](/tungbuivn) Chain 0-3 don\\'t work. Distanse[5029,2641]=5680.3, more, then 5261."
                    },
                    {
                        "username": "tungbuivn",
                        "content": "perhap you missing some where, here is 10 items from my program: [2,0,3,9,1,4,5,6,7,8], you could trace your program with that list"
                    },
                    {
                        "username": "himanshu693",
                        "content": "[[5149,1,2],[5146,1,3],[5142,1,4],[5137,1,5],[5131,1,6],[5124,1,7],[5116,1,8],[5107,1,9],[5097,1,10],[5086,1,11],[5074,1,12],[5061,1,13],[5047,1,14],[5032,1,15],[5016,1,16],[4999,1,17],[4981,1,18],[4962,1,19],[4942,1,20],[4921,1,21],[4899,1,22],[4876,1,23],[4852,1,24],[4827,1,25],[4801,1,26],[4774,1,27],[4746,1,28],[4717,1,29],[4687,1,30],[4656,1,31],[4624,1,32],[4591,1,33],[4557,1,34],[4522,1,35],[4486,1,36],[4449,1,37],[4411,1,38],[4372,1,39],[4332,1,40],[4291,1,41],[4249,1,42],[4206,1,43],[4162,1,44],[4117,1,45],[4071,1,46],[4024,1,47],[3976,1,48],[3927,1,49],[3877,1,50],[3826,1,51],[3774,1,52],[3721,1,53],[3667,1,54],[3612,1,55],[3556,1,56],[3499,1,57],[3441,1,58],[3382,1,59],[3322,1,60],[3261,1,61],[3199,1,62],[3136,1,63],[3072,1,64],[3007,1,65],[2941,1,66],[2874,1,67],[2806,1,68],[2737,1,69],[2667,1,70],[2596,1,71],[2524,1,72],[2451,1,73],[2377,1,74],[2302,1,75],[2226,1,76],[2149,1,77],[2071,1,78],[1992,1,79],[1912,1,80],[1831,1,81],[1749,1,82],[1666,1,83],[1582,1,84],[1497,1,85],[1411,1,86],[1324,1,87],[1236,1,88],[1147,1,89],[1057,1,90],[966,1,91],[874,1,92],[781,1,93],[687,1,94],[592,1,95],[496,1,96],[399,1,97],[301,1,98],[202,1,99],[102,1,100],[1,1,101]]\\n\\nfor this testcase I am getting 15 which I think is correct because 0, 1, 2, 3, 4 are isolated from other nodes so 5 nodes already gone from 100 so how 100 can be ans?"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "here is 100 items in order to debug your code =))\\n[99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,77,76,75,74,73,72,71,70,69,68,67,66,65,64,63,62,61,60,59,58,57,56,55,54,53,52,51,50,49,48,47,46,45,44,43,42,41,40,39,38,37,36,35,34,33,32,31,30,29,28,27,26,25,24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0]"
                    },
                    {
                        "username": "sravan_csed",
                        "content": "For this input the expected answer from leetcode is 1. Shouldn\\'t it be 2 as denotating bomb with index : 0 will detonate the other bomb\\n\\n[[1,1,100000],[100000,100000,1]]"
                    },
                    {
                        "username": "_SID_",
                        "content": "Check this, you can understand easily :  https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588930/1-1-100000-100000-100000-1-getting-wrong-understand-why/"
                    },
                    {
                        "username": "sravan_csed",
                        "content": "My bad  - issue was with casting squared distance to long"
                    },
                    {
                        "username": "vctr_",
                        "content": " `your inline code... \\nclass Solution {\\npublic:\\n    bool inRange(int i, int j, vector<vector<int>>& bombs){\\n        long long d = pow((bombs[i][0]-bombs[j][0]), 2)+pow((bombs[i][1]-bombs[i][1]), 2);\\n    \\n        if(d>pow(bombs[i][2], 2)){\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n = bombs.size();\\n        int maxm = INT_MIN; \\n        int curr = 0;\\n\\n        for(int i=0; i<n; i++){\\n            curr = 0;\\n            for(int j = 0; j<n; j++){\\n                if(inRange(i, j, bombs)){\\n                    curr++;\\n                    maxm = max(curr, maxm);\\n                }\\n            }\\n        }\\n        return maxm;\\n    }\\n};\\nyour inline code...`\\n\\n\\nI have written this brute force code to solve the problem.\\nbut it is giving me wrong answer for bombs =\\n[[1,1,100000],[100000,100000,1]] this case\\nWhere is the error?\\n"
                    },
                    {
                        "username": "note_08",
                        "content": "why cant we do this question by finding the points in its  range and maximizing the answer\\n"
                    },
                    {
                        "username": "charonme",
                        "content": "because of the secondary chain explosions"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Seems like a hard problem"
                    },
                    {
                        "username": "charonme",
                        "content": "not hard, just a composition of one easy + one almost-easy medium"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "A good hint for this problem could be,\\nManhattan Distance from src-to-destination can help in making Graph"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@dkochetov](/dkochetov) Quick addition: as precise euclidean distance is not needed, square root is not needed, just compare with r^2"
                    },
                    {
                        "username": "dkochetov",
                        "content": "No, you must use euclidean distance here"
                    },
                    {
                        "username": "eduard92",
                        "content": "I am so bad at graphs I cannot visualize how to implement DFS"
                    },
                    {
                        "username": "EgorMaral",
                        "content": "Python. I cannot use:\n ` def dfs(cur, visited=set()):`\nAnd i dont know why. Please, give me advice.\n\nAddition.\n```python\ndef dfs(cur, visited=set(), count=0):\n    if count == 0:\n        print(visited)\n    visited.add(cur)\n    count += 1\n    ...\n```\nLeads to the result:\n```python\nset()\n{0}\n{0, 1}\n{0, 1, 2}\n...\n```\nThat is, the variable __visisted__ is cached, but the variable __count__ is not.\nAnd:\n```python\ndef dfs(cur, visited=None):\n```\nis work"
                    },
                    {
                        "username": "james4388",
                        "content": "visited=set() in there will create a set and it live in global space, which will share that to all subsequence call. the correct way is\n```\ndef dfs(cur, visited=None):\n    visited = visited or set()\n    ....\n```\nsame apply for class instance\n```\nclass xyz:\n   var_here = set(). # this will be shared everywehre\n   def __init__(self):\n        self.something = set(). # this is safe\n```\n"
                    },
                    {
                        "username": "Krishak_20",
                        "content": "class Solution {\\n     int ans=0;\\n     int det=0;\\n\\n\\n     class Edge\\n     {\\n         int src,dest;\\n\\n         Edge(int src,int dest)\\n         {\\n             this.src=src;\\n             this.dest=dest;\\n         }\\n     }\\n    public int maximumDetonation(int[][] bombs) {\\n           \\n           int n=bombs.length;\\n\\n         ArrayList<Edge>graph[]=new ArrayList[n];\\n               for(int i=0;i<n;i++)graph[i]=new ArrayList<>();\\n            \\n         for(int i=0;i<bombs.length;i++)\\n         {\\n\\n             int x1=bombs[i][0];\\n               int y1=bombs[i][1];\\n               int r1=bombs[i][2];\\n\\n\\n             for(int j=0;j<bombs.length;j++)\\n             {\\n                \\n                if(j==i)continue;\\n                \\n               int x2=bombs[j][0];\\n               int y2=bombs[j][1];\\n               int r2=bombs[j][2];\\n\\n                 int d=r1+r2;\\n\\nif((long)d*(long)d>=((long)(x1-x2)*(long)(x1-x2))+((long)(y1-y2)*(long)(y1-y2)))\\n                 {\\n                     graph[i].add(new Edge(i,j));\\n                     \\n\\n                     //System.out.println(i+\" \"+j);\\n                 }\\n\\n             }\\n         }\\n\\n\\n         boolean []vis=new boolean[n];\\n            \\n           \\n         for(int i=0;i<n;i++)\\n         {\\n             det=0;\\n            if(!vis[i]){\\n\\n                 dfs(graph,i,vis);\\n                 ans=Math.max(det,ans);\\n             }\\n         }\\n         return ans;\\n\\n    }\\n\\n\\n    private void dfs(ArrayList<Edge>graph[],int curr,boolean[]vis)\\n    {\\n        vis[curr]=true;\\n                det++;\\n        for(int i=0;i<graph[curr].size();i++)\\n        {\\n            Edge e=graph[curr].get(i);\\n\\n            if(!vis[e.dest])\\n            {\\n              dfs(graph,e.dest,vis);\\n            }\\n        }\\n    }\\n}\\n\\n\\nCan anyone tel me why this code is not working . I am using the property of circles where if r1+r2<=distance between the centres of two circles , then they must be colliding and hence we will make both circles neighbours"
                    }
                ]
            },
            {
                "id": 1913858,
                "content": [
                    {
                        "username": "shtl",
                        "content": "[[37207,2653,5261],\\n[40784,59523,20635],\\n[16390,1426,39102],\\n[42236,12,96855],\\n[72839,62027,61667],\\n[60691,58191,48447],\\n[42932,46579,41248],\\n[35868,43119,6870],\\n[41693,98905,17374],\\n[43441,1266,41621]]\\nIn this case I have only 5 - 1,4,5,6,7, but expected 10. Why?"
                    },
                    {
                        "username": "shtl",
                        "content": "[@tungbuivn](/tungbuivn) I found problem, was bad convertion to long from int."
                    },
                    {
                        "username": "shtl",
                        "content": "[@tungbuivn](/tungbuivn) Chain 0-3 don\\'t work. Distanse[5029,2641]=5680.3, more, then 5261."
                    },
                    {
                        "username": "tungbuivn",
                        "content": "perhap you missing some where, here is 10 items from my program: [2,0,3,9,1,4,5,6,7,8], you could trace your program with that list"
                    },
                    {
                        "username": "himanshu693",
                        "content": "[[5149,1,2],[5146,1,3],[5142,1,4],[5137,1,5],[5131,1,6],[5124,1,7],[5116,1,8],[5107,1,9],[5097,1,10],[5086,1,11],[5074,1,12],[5061,1,13],[5047,1,14],[5032,1,15],[5016,1,16],[4999,1,17],[4981,1,18],[4962,1,19],[4942,1,20],[4921,1,21],[4899,1,22],[4876,1,23],[4852,1,24],[4827,1,25],[4801,1,26],[4774,1,27],[4746,1,28],[4717,1,29],[4687,1,30],[4656,1,31],[4624,1,32],[4591,1,33],[4557,1,34],[4522,1,35],[4486,1,36],[4449,1,37],[4411,1,38],[4372,1,39],[4332,1,40],[4291,1,41],[4249,1,42],[4206,1,43],[4162,1,44],[4117,1,45],[4071,1,46],[4024,1,47],[3976,1,48],[3927,1,49],[3877,1,50],[3826,1,51],[3774,1,52],[3721,1,53],[3667,1,54],[3612,1,55],[3556,1,56],[3499,1,57],[3441,1,58],[3382,1,59],[3322,1,60],[3261,1,61],[3199,1,62],[3136,1,63],[3072,1,64],[3007,1,65],[2941,1,66],[2874,1,67],[2806,1,68],[2737,1,69],[2667,1,70],[2596,1,71],[2524,1,72],[2451,1,73],[2377,1,74],[2302,1,75],[2226,1,76],[2149,1,77],[2071,1,78],[1992,1,79],[1912,1,80],[1831,1,81],[1749,1,82],[1666,1,83],[1582,1,84],[1497,1,85],[1411,1,86],[1324,1,87],[1236,1,88],[1147,1,89],[1057,1,90],[966,1,91],[874,1,92],[781,1,93],[687,1,94],[592,1,95],[496,1,96],[399,1,97],[301,1,98],[202,1,99],[102,1,100],[1,1,101]]\\n\\nfor this testcase I am getting 15 which I think is correct because 0, 1, 2, 3, 4 are isolated from other nodes so 5 nodes already gone from 100 so how 100 can be ans?"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "here is 100 items in order to debug your code =))\\n[99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,77,76,75,74,73,72,71,70,69,68,67,66,65,64,63,62,61,60,59,58,57,56,55,54,53,52,51,50,49,48,47,46,45,44,43,42,41,40,39,38,37,36,35,34,33,32,31,30,29,28,27,26,25,24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0]"
                    },
                    {
                        "username": "sravan_csed",
                        "content": "For this input the expected answer from leetcode is 1. Shouldn\\'t it be 2 as denotating bomb with index : 0 will detonate the other bomb\\n\\n[[1,1,100000],[100000,100000,1]]"
                    },
                    {
                        "username": "_SID_",
                        "content": "Check this, you can understand easily :  https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588930/1-1-100000-100000-100000-1-getting-wrong-understand-why/"
                    },
                    {
                        "username": "sravan_csed",
                        "content": "My bad  - issue was with casting squared distance to long"
                    },
                    {
                        "username": "vctr_",
                        "content": " `your inline code... \\nclass Solution {\\npublic:\\n    bool inRange(int i, int j, vector<vector<int>>& bombs){\\n        long long d = pow((bombs[i][0]-bombs[j][0]), 2)+pow((bombs[i][1]-bombs[i][1]), 2);\\n    \\n        if(d>pow(bombs[i][2], 2)){\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        int n = bombs.size();\\n        int maxm = INT_MIN; \\n        int curr = 0;\\n\\n        for(int i=0; i<n; i++){\\n            curr = 0;\\n            for(int j = 0; j<n; j++){\\n                if(inRange(i, j, bombs)){\\n                    curr++;\\n                    maxm = max(curr, maxm);\\n                }\\n            }\\n        }\\n        return maxm;\\n    }\\n};\\nyour inline code...`\\n\\n\\nI have written this brute force code to solve the problem.\\nbut it is giving me wrong answer for bombs =\\n[[1,1,100000],[100000,100000,1]] this case\\nWhere is the error?\\n"
                    },
                    {
                        "username": "note_08",
                        "content": "why cant we do this question by finding the points in its  range and maximizing the answer\\n"
                    },
                    {
                        "username": "charonme",
                        "content": "because of the secondary chain explosions"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Seems like a hard problem"
                    },
                    {
                        "username": "charonme",
                        "content": "not hard, just a composition of one easy + one almost-easy medium"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "A good hint for this problem could be,\\nManhattan Distance from src-to-destination can help in making Graph"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@dkochetov](/dkochetov) Quick addition: as precise euclidean distance is not needed, square root is not needed, just compare with r^2"
                    },
                    {
                        "username": "dkochetov",
                        "content": "No, you must use euclidean distance here"
                    },
                    {
                        "username": "eduard92",
                        "content": "I am so bad at graphs I cannot visualize how to implement DFS"
                    },
                    {
                        "username": "EgorMaral",
                        "content": "Python. I cannot use:\n ` def dfs(cur, visited=set()):`\nAnd i dont know why. Please, give me advice.\n\nAddition.\n```python\ndef dfs(cur, visited=set(), count=0):\n    if count == 0:\n        print(visited)\n    visited.add(cur)\n    count += 1\n    ...\n```\nLeads to the result:\n```python\nset()\n{0}\n{0, 1}\n{0, 1, 2}\n...\n```\nThat is, the variable __visisted__ is cached, but the variable __count__ is not.\nAnd:\n```python\ndef dfs(cur, visited=None):\n```\nis work"
                    },
                    {
                        "username": "james4388",
                        "content": "visited=set() in there will create a set and it live in global space, which will share that to all subsequence call. the correct way is\n```\ndef dfs(cur, visited=None):\n    visited = visited or set()\n    ....\n```\nsame apply for class instance\n```\nclass xyz:\n   var_here = set(). # this will be shared everywehre\n   def __init__(self):\n        self.something = set(). # this is safe\n```\n"
                    },
                    {
                        "username": "Krishak_20",
                        "content": "class Solution {\\n     int ans=0;\\n     int det=0;\\n\\n\\n     class Edge\\n     {\\n         int src,dest;\\n\\n         Edge(int src,int dest)\\n         {\\n             this.src=src;\\n             this.dest=dest;\\n         }\\n     }\\n    public int maximumDetonation(int[][] bombs) {\\n           \\n           int n=bombs.length;\\n\\n         ArrayList<Edge>graph[]=new ArrayList[n];\\n               for(int i=0;i<n;i++)graph[i]=new ArrayList<>();\\n            \\n         for(int i=0;i<bombs.length;i++)\\n         {\\n\\n             int x1=bombs[i][0];\\n               int y1=bombs[i][1];\\n               int r1=bombs[i][2];\\n\\n\\n             for(int j=0;j<bombs.length;j++)\\n             {\\n                \\n                if(j==i)continue;\\n                \\n               int x2=bombs[j][0];\\n               int y2=bombs[j][1];\\n               int r2=bombs[j][2];\\n\\n                 int d=r1+r2;\\n\\nif((long)d*(long)d>=((long)(x1-x2)*(long)(x1-x2))+((long)(y1-y2)*(long)(y1-y2)))\\n                 {\\n                     graph[i].add(new Edge(i,j));\\n                     \\n\\n                     //System.out.println(i+\" \"+j);\\n                 }\\n\\n             }\\n         }\\n\\n\\n         boolean []vis=new boolean[n];\\n            \\n           \\n         for(int i=0;i<n;i++)\\n         {\\n             det=0;\\n            if(!vis[i]){\\n\\n                 dfs(graph,i,vis);\\n                 ans=Math.max(det,ans);\\n             }\\n         }\\n         return ans;\\n\\n    }\\n\\n\\n    private void dfs(ArrayList<Edge>graph[],int curr,boolean[]vis)\\n    {\\n        vis[curr]=true;\\n                det++;\\n        for(int i=0;i<graph[curr].size();i++)\\n        {\\n            Edge e=graph[curr].get(i);\\n\\n            if(!vis[e.dest])\\n            {\\n              dfs(graph,e.dest,vis);\\n            }\\n        }\\n    }\\n}\\n\\n\\nCan anyone tel me why this code is not working . I am using the property of circles where if r1+r2<=distance between the centres of two circles , then they must be colliding and hence we will make both circles neighbours"
                    }
                ]
            },
            {
                "id": 1913828,
                "content": [
                    {
                        "username": "Tusharsingh110",
                        "content": "can some edges be bidirectional?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this is directed graph.  A->B and B->A are both allowed, yes."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Solution : \\nhttps://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588123/geometry-dfs-c-with-figure/ "
                    },
                    {
                        "username": "vamsikumili",
                        "content": "How is the expected result of [[1,1,100000],[100000,100000,1]] is 1, when the first bomb can detonate 2nd one . My point of view is first bomb's x cordinate + radius of first bomb > second bombs x cordinate and first bomb's y cordinate + radius of first bomb > second bomb's y cordinate also, so second bombs both cordinates falls under first bombs impact radus,\n\nCan someone please explain why my thinking is wrong? \nThank you."
                    },
                    {
                        "username": "_SID_",
                        "content": "Check this, you can understand easily : https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588930/1-1-100000-100000-100000-1-getting-wrong-understand-why/"
                    },
                    {
                        "username": "dkochetov",
                        "content": "It can't detonate. The distance between their centers is `sqrt((100000-1)^2 + (100000-1)^2) = 141420` that is greater than `100000`. Meaning that the second bomb is not within the radius of the first one."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "A great question. <b> Unique combination of Maths and Graph. </b>Can someone help me why this code gives TLE. It works when I execute it as a testcase, but when I run, it gives me a TLE.\\n```#define ll long long\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        unordered_map<int, vector<int>> G;\\n        int n = bombs.size();\\n        // Build the graph such that make a connection if a node is connected to \\n        // another if circlei overlaps the center of circlej\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if(circleOverlap(bombs[i][0], bombs[i][1], bombs[i][2], bombs[j][0], bombs[j][1])){\\n                    G[i].push_back(j);\\n                }\\n            }\\n        }\\n        // Use the vis for checking if a bomb has already been diffused\\n        int maimumDetonated = 0;\\n        for(int i = 0; i < n; i++){\\n            maimumDetonated = max(maimumDetonated, bfs(G, i));\\n        }\\n        return maimumDetonated;\\n    }\\nprivate:\\n    bool circleOverlap(ll x, ll y, ll r, ll x1, ll y1){\\n        return pow((x1 - x), 2) + pow((y1 - y), 2) - r*r <= 0;\\n    }\\n    int bfs(unordered_map<int, vector<int>> &G, int idx){\\n        queue<int> Q; Q.push(idx);\\n        unordered_set<int> vis; vis.insert(idx);\\n        int cnt = 0;\\n        while(!Q.empty()){\\n            int curr = Q.front(); Q.pop();\\n            vis.insert(curr);\\n            cnt++;\\n            for(int x: G[curr]){\\n                if(vis.find(x) == vis.end()){\\n                    Q.push(x);\\n                }\\n            }\\n        }\\n        return vis.size();\\n    }\\n};```"
                    },
                    {
                        "username": "sameertri039",
                        "content": "Nice problem!"
                    },
                    {
                        "username": "vnk01",
                        "content": "nice question! I got fooled into thinking I need to group every nodes that have radius reaching each other into the same group and overcount it in my first attempt"
                    },
                    {
                        "username": "ayush81029",
                        "content": "[[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]\\nWhy this testcase giving expected output 1 when it should be 2?\\n[69,51,7] and [65,59,3] are intersecting."
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the distance between [69,51,7] and [65,59,3] is 8.9 which make it not enough range to explode both of it"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Can anyone help, when I submit the code, it gives TLA. But, when I run the same testcase, it passes.\\nThere is a notification that it is due to global or static variables. But, I didn\\'t use global/static declarations in the first place.\\n"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Just one test case running for 500ms will be accepted. But after submitting, you will have to pass all ~100 test cases and the sum of their runtime must be less than ~5sec. So you need to reduce the complexity of your code."
                    },
                    {
                        "username": "Kyrie63",
                        "content": " `class Solution {\\n\\n    // Can someone tell me why I got wrong in this testcase?\\n    // [[37207,2653,5261],[40784,59523,20635],[16390,1426,39102],[42236,12,96855],[72839,62027,61667],[60691,58191,48447],[42932,46579,41248],[35868,43119,6870],[41693,98905,17374],[43441,1266,41621]]\\n    // Expected 10. but outcome is 5...\\n\\n    int count;\\n    public int maximumDetonation(int[][] bombs) {\\n        int n = bombs.length;\\n        List<Integer>[] bombGraph = buildGraph(n, bombs);\\n\\n        this.count = 0;\\n        int res = 0;\\n\\n        for (int i = 0; i < n; i++){\\n            boolean[] visited = new boolean[n];\\n            count = 0;\\n            dfs(bombGraph, i, visited);\\n            res = Math.max(res, count);\\n        }\\n        return res;\\n    }\\n\\n    public void dfs(List<Integer>[] graph, int cur, boolean[] visited){\\n        // base-case \\n        if (visited[cur]){\\n            return;\\n        }\\n\\n        visited[cur] = true;\\n        count++;\\n        for (int neigh : graph[cur]){\\n            dfs(graph, neigh, visited);\\n        }\\n    }\\n\\n    public List<Integer>[] buildGraph(int n, int[][] bombs){\\n        List<Integer>[] bombGraph = new LinkedList[n];\\n\\n        for (int i = 0; i < n; i++){\\n            bombGraph[i] = new LinkedList<>();\\n        }\\n\\n        for (int i = 0; i < n; i++){\\n            for (int j = 0; j < n; j++){\\n                if (i == j) continue;\\n                int x1 = bombs[i][0];\\n                int y1 = bombs[i][1];\\n                int r1 = bombs[i][2];\\n                int x2 = bombs[j][0];\\n                int y2 = bombs[j][1];\\n                // int r2 = bomb[j][2];\\n                // long dist = (long)(x1-x2)*(x1-x2) + (long)(y1-y2)*(y1-y2);\\n                // long boomDist = (long)(r1*r1);\\n\\n                // create a path if possible\\n                // if ((long)(r1 + r2) >= (long)(x1-x2)*(x1-x2) + (long)(y1-y2)*(y1-y2)){\\n                if ((long)(r1 * r1) >= ((long)(x1-x2)*(x1-x2) + (long)(y1-y2)*(y1-y2))){\\n                    bombGraph[i].add(j);\\n                }\\n            }\\n        }\\n\\n        return bombGraph;\\n    }\\n\\n}\\n`\\nCan someone tell me why I got wrong in this testcase?\\n [[37207,2653,5261],[40784,59523,20635],[16390,1426,39102],[42236,12,96855],[72839,62027,61667],[60691,58191,48447],[42932,46579,41248],[35868,43119,6870],[41693,98905,17374],[43441,1266,41621]]\\n The expected answer is 10. but my outcome is 5...\\nThanks!"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@EricRaw](/EricRaw) The problem is that the bombs array are all ints. You need to cast them into longs before doing your distance calculations."
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Kyrie63](/Kyrie63) [@psionl0](/psionl0) i check it again and i am wrong, the problem arise because of integer overflow.\nthe r1, r2, x1, x2, y1, y2 should be long"
                    },
                    {
                        "username": "psionl0",
                        "content": "The thing I don\\'t like about Math.pow() is that it returns a double which is less accurate than int or long. I suspect that the reason why the earlier code didn\\'t work was because the products overflowed before you could cast the result into a long integer. Try this:\\n```\\nif (long) r1 * (long) r1 >= (long) (x1-x2) * (long) (x1 - x2) + (long)(y1 - y2) * (long) (y1 - y2) {\\n```"
                    },
                    {
                        "username": "Kyrie63",
                        "content": "[@yakode](/yakode) I think Eric got the explanation, and when I changed my condition as: \n if (Math.pow(r1,2) >= (Math.pow((x1-x2), 2) + Math.pow((y1-y2), 2))){...}\nit works. But thanks anyways!!!"
                    },
                    {
                        "username": "Kyrie63",
                        "content": "[@EricRaw](/EricRaw) Thanks Eric for your detailed explaination, I think your opinions are correct. But I still have a question that this problem seems to cast a int value to a long type, and it will not occur the decimal portion, so what is wrong with my code? When I change my code to if (Math.pow(r1,2) >= (Math.pow((x1-x2), 2) + Math.pow((y1-y2), 2))), it works magically!"
                    },
                    {
                        "username": "yakode",
                        "content": "if ((long)(r1 * r1) >= ((long)((x1-x2)*(x1-x2)) + (long)((y1-y2)*(y1-y2)))){\\n\\nI don\\'t know the reason, but after I edited this if condition in  buildGraph. it pass this testcase."
                    },
                    {
                        "username": "EricRaw",
                        "content": "```if ((long)(r1 * r1) >= ((long)(x1-x2)*(x1-x2) + (long)(y1-y2)*(y1-y2))){```\nWhen you cast a double value to a long type, it truncates the decimal portion and converts it to an integer\n\neg\nwhen you cast double value 8.9 to a long type, the decimal portion will be truncated, and the resulting long value will be 8 which can be wrong\n- 8,6 >= 8,9 (it should be false)\n- 8 >= 8 (cast to long it become true)\n\nyou can test it out with this code\n```\n        double test = 8.9;\n        double test1 = 8.5;\n        System.out.println(test <= test1);\n        System.out.println((long)test <= (long)test1);\n```"
                    },
                    {
                        "username": "RaktimBhuyan21",
                        "content": "Can anyone help with what is wrong in my code ?\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n       \\n        int n = bombs.size();\\n        vector<vector<bool>>connected(n,vector<bool>(n,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==j){\\n                    connected[i][j] = 1;\\n                }\\n                else{\\n                    long xi = bombs[i][0];\\n                    long yi = bombs[i][1];\\n                    long ri = bombs[i][2];\\n                    long xj = bombs[j][0];\\n                    long yj = bombs[j][1];\\n                    long rj = bombs[j][2];\\n                    long  dis = (xi-xj)*(xi-xj) + (yi-yj)*(yi-yj);\\n                    \\n                    if(dis<=(ri*ri)){\\n                        connected[i][j] = 1;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        int ans =0;\\n        for(int i=0;i<n;i++){\\n            int cnt =0;\\n            for(int j=0;j<n;j++){\\n                if(connected[i][j]==1){\\n                    cnt++;\\n                   ans = max(ans,cnt);\\n                }\\n            }\\n            \\n            \\n        }\\n        return ans;\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1913803,
                "content": [
                    {
                        "username": "Tusharsingh110",
                        "content": "can some edges be bidirectional?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this is directed graph.  A->B and B->A are both allowed, yes."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Solution : \\nhttps://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588123/geometry-dfs-c-with-figure/ "
                    },
                    {
                        "username": "vamsikumili",
                        "content": "How is the expected result of [[1,1,100000],[100000,100000,1]] is 1, when the first bomb can detonate 2nd one . My point of view is first bomb's x cordinate + radius of first bomb > second bombs x cordinate and first bomb's y cordinate + radius of first bomb > second bomb's y cordinate also, so second bombs both cordinates falls under first bombs impact radus,\n\nCan someone please explain why my thinking is wrong? \nThank you."
                    },
                    {
                        "username": "_SID_",
                        "content": "Check this, you can understand easily : https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588930/1-1-100000-100000-100000-1-getting-wrong-understand-why/"
                    },
                    {
                        "username": "dkochetov",
                        "content": "It can't detonate. The distance between their centers is `sqrt((100000-1)^2 + (100000-1)^2) = 141420` that is greater than `100000`. Meaning that the second bomb is not within the radius of the first one."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "A great question. <b> Unique combination of Maths and Graph. </b>Can someone help me why this code gives TLE. It works when I execute it as a testcase, but when I run, it gives me a TLE.\\n```#define ll long long\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        unordered_map<int, vector<int>> G;\\n        int n = bombs.size();\\n        // Build the graph such that make a connection if a node is connected to \\n        // another if circlei overlaps the center of circlej\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if(circleOverlap(bombs[i][0], bombs[i][1], bombs[i][2], bombs[j][0], bombs[j][1])){\\n                    G[i].push_back(j);\\n                }\\n            }\\n        }\\n        // Use the vis for checking if a bomb has already been diffused\\n        int maimumDetonated = 0;\\n        for(int i = 0; i < n; i++){\\n            maimumDetonated = max(maimumDetonated, bfs(G, i));\\n        }\\n        return maimumDetonated;\\n    }\\nprivate:\\n    bool circleOverlap(ll x, ll y, ll r, ll x1, ll y1){\\n        return pow((x1 - x), 2) + pow((y1 - y), 2) - r*r <= 0;\\n    }\\n    int bfs(unordered_map<int, vector<int>> &G, int idx){\\n        queue<int> Q; Q.push(idx);\\n        unordered_set<int> vis; vis.insert(idx);\\n        int cnt = 0;\\n        while(!Q.empty()){\\n            int curr = Q.front(); Q.pop();\\n            vis.insert(curr);\\n            cnt++;\\n            for(int x: G[curr]){\\n                if(vis.find(x) == vis.end()){\\n                    Q.push(x);\\n                }\\n            }\\n        }\\n        return vis.size();\\n    }\\n};```"
                    },
                    {
                        "username": "sameertri039",
                        "content": "Nice problem!"
                    },
                    {
                        "username": "vnk01",
                        "content": "nice question! I got fooled into thinking I need to group every nodes that have radius reaching each other into the same group and overcount it in my first attempt"
                    },
                    {
                        "username": "ayush81029",
                        "content": "[[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]\\nWhy this testcase giving expected output 1 when it should be 2?\\n[69,51,7] and [65,59,3] are intersecting."
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the distance between [69,51,7] and [65,59,3] is 8.9 which make it not enough range to explode both of it"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Can anyone help, when I submit the code, it gives TLA. But, when I run the same testcase, it passes.\\nThere is a notification that it is due to global or static variables. But, I didn\\'t use global/static declarations in the first place.\\n"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Just one test case running for 500ms will be accepted. But after submitting, you will have to pass all ~100 test cases and the sum of their runtime must be less than ~5sec. So you need to reduce the complexity of your code."
                    },
                    {
                        "username": "Kyrie63",
                        "content": " `class Solution {\\n\\n    // Can someone tell me why I got wrong in this testcase?\\n    // [[37207,2653,5261],[40784,59523,20635],[16390,1426,39102],[42236,12,96855],[72839,62027,61667],[60691,58191,48447],[42932,46579,41248],[35868,43119,6870],[41693,98905,17374],[43441,1266,41621]]\\n    // Expected 10. but outcome is 5...\\n\\n    int count;\\n    public int maximumDetonation(int[][] bombs) {\\n        int n = bombs.length;\\n        List<Integer>[] bombGraph = buildGraph(n, bombs);\\n\\n        this.count = 0;\\n        int res = 0;\\n\\n        for (int i = 0; i < n; i++){\\n            boolean[] visited = new boolean[n];\\n            count = 0;\\n            dfs(bombGraph, i, visited);\\n            res = Math.max(res, count);\\n        }\\n        return res;\\n    }\\n\\n    public void dfs(List<Integer>[] graph, int cur, boolean[] visited){\\n        // base-case \\n        if (visited[cur]){\\n            return;\\n        }\\n\\n        visited[cur] = true;\\n        count++;\\n        for (int neigh : graph[cur]){\\n            dfs(graph, neigh, visited);\\n        }\\n    }\\n\\n    public List<Integer>[] buildGraph(int n, int[][] bombs){\\n        List<Integer>[] bombGraph = new LinkedList[n];\\n\\n        for (int i = 0; i < n; i++){\\n            bombGraph[i] = new LinkedList<>();\\n        }\\n\\n        for (int i = 0; i < n; i++){\\n            for (int j = 0; j < n; j++){\\n                if (i == j) continue;\\n                int x1 = bombs[i][0];\\n                int y1 = bombs[i][1];\\n                int r1 = bombs[i][2];\\n                int x2 = bombs[j][0];\\n                int y2 = bombs[j][1];\\n                // int r2 = bomb[j][2];\\n                // long dist = (long)(x1-x2)*(x1-x2) + (long)(y1-y2)*(y1-y2);\\n                // long boomDist = (long)(r1*r1);\\n\\n                // create a path if possible\\n                // if ((long)(r1 + r2) >= (long)(x1-x2)*(x1-x2) + (long)(y1-y2)*(y1-y2)){\\n                if ((long)(r1 * r1) >= ((long)(x1-x2)*(x1-x2) + (long)(y1-y2)*(y1-y2))){\\n                    bombGraph[i].add(j);\\n                }\\n            }\\n        }\\n\\n        return bombGraph;\\n    }\\n\\n}\\n`\\nCan someone tell me why I got wrong in this testcase?\\n [[37207,2653,5261],[40784,59523,20635],[16390,1426,39102],[42236,12,96855],[72839,62027,61667],[60691,58191,48447],[42932,46579,41248],[35868,43119,6870],[41693,98905,17374],[43441,1266,41621]]\\n The expected answer is 10. but my outcome is 5...\\nThanks!"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@EricRaw](/EricRaw) The problem is that the bombs array are all ints. You need to cast them into longs before doing your distance calculations."
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Kyrie63](/Kyrie63) [@psionl0](/psionl0) i check it again and i am wrong, the problem arise because of integer overflow.\nthe r1, r2, x1, x2, y1, y2 should be long"
                    },
                    {
                        "username": "psionl0",
                        "content": "The thing I don\\'t like about Math.pow() is that it returns a double which is less accurate than int or long. I suspect that the reason why the earlier code didn\\'t work was because the products overflowed before you could cast the result into a long integer. Try this:\\n```\\nif (long) r1 * (long) r1 >= (long) (x1-x2) * (long) (x1 - x2) + (long)(y1 - y2) * (long) (y1 - y2) {\\n```"
                    },
                    {
                        "username": "Kyrie63",
                        "content": "[@yakode](/yakode) I think Eric got the explanation, and when I changed my condition as: \n if (Math.pow(r1,2) >= (Math.pow((x1-x2), 2) + Math.pow((y1-y2), 2))){...}\nit works. But thanks anyways!!!"
                    },
                    {
                        "username": "Kyrie63",
                        "content": "[@EricRaw](/EricRaw) Thanks Eric for your detailed explaination, I think your opinions are correct. But I still have a question that this problem seems to cast a int value to a long type, and it will not occur the decimal portion, so what is wrong with my code? When I change my code to if (Math.pow(r1,2) >= (Math.pow((x1-x2), 2) + Math.pow((y1-y2), 2))), it works magically!"
                    },
                    {
                        "username": "yakode",
                        "content": "if ((long)(r1 * r1) >= ((long)((x1-x2)*(x1-x2)) + (long)((y1-y2)*(y1-y2)))){\\n\\nI don\\'t know the reason, but after I edited this if condition in  buildGraph. it pass this testcase."
                    },
                    {
                        "username": "EricRaw",
                        "content": "```if ((long)(r1 * r1) >= ((long)(x1-x2)*(x1-x2) + (long)(y1-y2)*(y1-y2))){```\nWhen you cast a double value to a long type, it truncates the decimal portion and converts it to an integer\n\neg\nwhen you cast double value 8.9 to a long type, the decimal portion will be truncated, and the resulting long value will be 8 which can be wrong\n- 8,6 >= 8,9 (it should be false)\n- 8 >= 8 (cast to long it become true)\n\nyou can test it out with this code\n```\n        double test = 8.9;\n        double test1 = 8.5;\n        System.out.println(test <= test1);\n        System.out.println((long)test <= (long)test1);\n```"
                    },
                    {
                        "username": "RaktimBhuyan21",
                        "content": "Can anyone help with what is wrong in my code ?\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n       \\n        int n = bombs.size();\\n        vector<vector<bool>>connected(n,vector<bool>(n,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==j){\\n                    connected[i][j] = 1;\\n                }\\n                else{\\n                    long xi = bombs[i][0];\\n                    long yi = bombs[i][1];\\n                    long ri = bombs[i][2];\\n                    long xj = bombs[j][0];\\n                    long yj = bombs[j][1];\\n                    long rj = bombs[j][2];\\n                    long  dis = (xi-xj)*(xi-xj) + (yi-yj)*(yi-yj);\\n                    \\n                    if(dis<=(ri*ri)){\\n                        connected[i][j] = 1;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        int ans =0;\\n        for(int i=0;i<n;i++){\\n            int cnt =0;\\n            for(int j=0;j<n;j++){\\n                if(connected[i][j]==1){\\n                    cnt++;\\n                   ans = max(ans,cnt);\\n                }\\n            }\\n            \\n            \\n        }\\n        return ans;\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1913775,
                "content": [
                    {
                        "username": "Tusharsingh110",
                        "content": "can some edges be bidirectional?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this is directed graph.  A->B and B->A are both allowed, yes."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Solution : \\nhttps://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588123/geometry-dfs-c-with-figure/ "
                    },
                    {
                        "username": "vamsikumili",
                        "content": "How is the expected result of [[1,1,100000],[100000,100000,1]] is 1, when the first bomb can detonate 2nd one . My point of view is first bomb's x cordinate + radius of first bomb > second bombs x cordinate and first bomb's y cordinate + radius of first bomb > second bomb's y cordinate also, so second bombs both cordinates falls under first bombs impact radus,\n\nCan someone please explain why my thinking is wrong? \nThank you."
                    },
                    {
                        "username": "_SID_",
                        "content": "Check this, you can understand easily : https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588930/1-1-100000-100000-100000-1-getting-wrong-understand-why/"
                    },
                    {
                        "username": "dkochetov",
                        "content": "It can't detonate. The distance between their centers is `sqrt((100000-1)^2 + (100000-1)^2) = 141420` that is greater than `100000`. Meaning that the second bomb is not within the radius of the first one."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "A great question. <b> Unique combination of Maths and Graph. </b>Can someone help me why this code gives TLE. It works when I execute it as a testcase, but when I run, it gives me a TLE.\\n```#define ll long long\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        unordered_map<int, vector<int>> G;\\n        int n = bombs.size();\\n        // Build the graph such that make a connection if a node is connected to \\n        // another if circlei overlaps the center of circlej\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if(circleOverlap(bombs[i][0], bombs[i][1], bombs[i][2], bombs[j][0], bombs[j][1])){\\n                    G[i].push_back(j);\\n                }\\n            }\\n        }\\n        // Use the vis for checking if a bomb has already been diffused\\n        int maimumDetonated = 0;\\n        for(int i = 0; i < n; i++){\\n            maimumDetonated = max(maimumDetonated, bfs(G, i));\\n        }\\n        return maimumDetonated;\\n    }\\nprivate:\\n    bool circleOverlap(ll x, ll y, ll r, ll x1, ll y1){\\n        return pow((x1 - x), 2) + pow((y1 - y), 2) - r*r <= 0;\\n    }\\n    int bfs(unordered_map<int, vector<int>> &G, int idx){\\n        queue<int> Q; Q.push(idx);\\n        unordered_set<int> vis; vis.insert(idx);\\n        int cnt = 0;\\n        while(!Q.empty()){\\n            int curr = Q.front(); Q.pop();\\n            vis.insert(curr);\\n            cnt++;\\n            for(int x: G[curr]){\\n                if(vis.find(x) == vis.end()){\\n                    Q.push(x);\\n                }\\n            }\\n        }\\n        return vis.size();\\n    }\\n};```"
                    },
                    {
                        "username": "sameertri039",
                        "content": "Nice problem!"
                    },
                    {
                        "username": "vnk01",
                        "content": "nice question! I got fooled into thinking I need to group every nodes that have radius reaching each other into the same group and overcount it in my first attempt"
                    },
                    {
                        "username": "ayush81029",
                        "content": "[[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]\\nWhy this testcase giving expected output 1 when it should be 2?\\n[69,51,7] and [65,59,3] are intersecting."
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the distance between [69,51,7] and [65,59,3] is 8.9 which make it not enough range to explode both of it"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Can anyone help, when I submit the code, it gives TLA. But, when I run the same testcase, it passes.\\nThere is a notification that it is due to global or static variables. But, I didn\\'t use global/static declarations in the first place.\\n"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Just one test case running for 500ms will be accepted. But after submitting, you will have to pass all ~100 test cases and the sum of their runtime must be less than ~5sec. So you need to reduce the complexity of your code."
                    },
                    {
                        "username": "Kyrie63",
                        "content": " `class Solution {\\n\\n    // Can someone tell me why I got wrong in this testcase?\\n    // [[37207,2653,5261],[40784,59523,20635],[16390,1426,39102],[42236,12,96855],[72839,62027,61667],[60691,58191,48447],[42932,46579,41248],[35868,43119,6870],[41693,98905,17374],[43441,1266,41621]]\\n    // Expected 10. but outcome is 5...\\n\\n    int count;\\n    public int maximumDetonation(int[][] bombs) {\\n        int n = bombs.length;\\n        List<Integer>[] bombGraph = buildGraph(n, bombs);\\n\\n        this.count = 0;\\n        int res = 0;\\n\\n        for (int i = 0; i < n; i++){\\n            boolean[] visited = new boolean[n];\\n            count = 0;\\n            dfs(bombGraph, i, visited);\\n            res = Math.max(res, count);\\n        }\\n        return res;\\n    }\\n\\n    public void dfs(List<Integer>[] graph, int cur, boolean[] visited){\\n        // base-case \\n        if (visited[cur]){\\n            return;\\n        }\\n\\n        visited[cur] = true;\\n        count++;\\n        for (int neigh : graph[cur]){\\n            dfs(graph, neigh, visited);\\n        }\\n    }\\n\\n    public List<Integer>[] buildGraph(int n, int[][] bombs){\\n        List<Integer>[] bombGraph = new LinkedList[n];\\n\\n        for (int i = 0; i < n; i++){\\n            bombGraph[i] = new LinkedList<>();\\n        }\\n\\n        for (int i = 0; i < n; i++){\\n            for (int j = 0; j < n; j++){\\n                if (i == j) continue;\\n                int x1 = bombs[i][0];\\n                int y1 = bombs[i][1];\\n                int r1 = bombs[i][2];\\n                int x2 = bombs[j][0];\\n                int y2 = bombs[j][1];\\n                // int r2 = bomb[j][2];\\n                // long dist = (long)(x1-x2)*(x1-x2) + (long)(y1-y2)*(y1-y2);\\n                // long boomDist = (long)(r1*r1);\\n\\n                // create a path if possible\\n                // if ((long)(r1 + r2) >= (long)(x1-x2)*(x1-x2) + (long)(y1-y2)*(y1-y2)){\\n                if ((long)(r1 * r1) >= ((long)(x1-x2)*(x1-x2) + (long)(y1-y2)*(y1-y2))){\\n                    bombGraph[i].add(j);\\n                }\\n            }\\n        }\\n\\n        return bombGraph;\\n    }\\n\\n}\\n`\\nCan someone tell me why I got wrong in this testcase?\\n [[37207,2653,5261],[40784,59523,20635],[16390,1426,39102],[42236,12,96855],[72839,62027,61667],[60691,58191,48447],[42932,46579,41248],[35868,43119,6870],[41693,98905,17374],[43441,1266,41621]]\\n The expected answer is 10. but my outcome is 5...\\nThanks!"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@EricRaw](/EricRaw) The problem is that the bombs array are all ints. You need to cast them into longs before doing your distance calculations."
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Kyrie63](/Kyrie63) [@psionl0](/psionl0) i check it again and i am wrong, the problem arise because of integer overflow.\nthe r1, r2, x1, x2, y1, y2 should be long"
                    },
                    {
                        "username": "psionl0",
                        "content": "The thing I don\\'t like about Math.pow() is that it returns a double which is less accurate than int or long. I suspect that the reason why the earlier code didn\\'t work was because the products overflowed before you could cast the result into a long integer. Try this:\\n```\\nif (long) r1 * (long) r1 >= (long) (x1-x2) * (long) (x1 - x2) + (long)(y1 - y2) * (long) (y1 - y2) {\\n```"
                    },
                    {
                        "username": "Kyrie63",
                        "content": "[@yakode](/yakode) I think Eric got the explanation, and when I changed my condition as: \n if (Math.pow(r1,2) >= (Math.pow((x1-x2), 2) + Math.pow((y1-y2), 2))){...}\nit works. But thanks anyways!!!"
                    },
                    {
                        "username": "Kyrie63",
                        "content": "[@EricRaw](/EricRaw) Thanks Eric for your detailed explaination, I think your opinions are correct. But I still have a question that this problem seems to cast a int value to a long type, and it will not occur the decimal portion, so what is wrong with my code? When I change my code to if (Math.pow(r1,2) >= (Math.pow((x1-x2), 2) + Math.pow((y1-y2), 2))), it works magically!"
                    },
                    {
                        "username": "yakode",
                        "content": "if ((long)(r1 * r1) >= ((long)((x1-x2)*(x1-x2)) + (long)((y1-y2)*(y1-y2)))){\\n\\nI don\\'t know the reason, but after I edited this if condition in  buildGraph. it pass this testcase."
                    },
                    {
                        "username": "EricRaw",
                        "content": "```if ((long)(r1 * r1) >= ((long)(x1-x2)*(x1-x2) + (long)(y1-y2)*(y1-y2))){```\nWhen you cast a double value to a long type, it truncates the decimal portion and converts it to an integer\n\neg\nwhen you cast double value 8.9 to a long type, the decimal portion will be truncated, and the resulting long value will be 8 which can be wrong\n- 8,6 >= 8,9 (it should be false)\n- 8 >= 8 (cast to long it become true)\n\nyou can test it out with this code\n```\n        double test = 8.9;\n        double test1 = 8.5;\n        System.out.println(test <= test1);\n        System.out.println((long)test <= (long)test1);\n```"
                    },
                    {
                        "username": "RaktimBhuyan21",
                        "content": "Can anyone help with what is wrong in my code ?\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n       \\n        int n = bombs.size();\\n        vector<vector<bool>>connected(n,vector<bool>(n,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==j){\\n                    connected[i][j] = 1;\\n                }\\n                else{\\n                    long xi = bombs[i][0];\\n                    long yi = bombs[i][1];\\n                    long ri = bombs[i][2];\\n                    long xj = bombs[j][0];\\n                    long yj = bombs[j][1];\\n                    long rj = bombs[j][2];\\n                    long  dis = (xi-xj)*(xi-xj) + (yi-yj)*(yi-yj);\\n                    \\n                    if(dis<=(ri*ri)){\\n                        connected[i][j] = 1;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        int ans =0;\\n        for(int i=0;i<n;i++){\\n            int cnt =0;\\n            for(int j=0;j<n;j++){\\n                if(connected[i][j]==1){\\n                    cnt++;\\n                   ans = max(ans,cnt);\\n                }\\n            }\\n            \\n            \\n        }\\n        return ans;\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1913774,
                "content": [
                    {
                        "username": "Tusharsingh110",
                        "content": "can some edges be bidirectional?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this is directed graph.  A->B and B->A are both allowed, yes."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Solution : \\nhttps://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588123/geometry-dfs-c-with-figure/ "
                    },
                    {
                        "username": "vamsikumili",
                        "content": "How is the expected result of [[1,1,100000],[100000,100000,1]] is 1, when the first bomb can detonate 2nd one . My point of view is first bomb's x cordinate + radius of first bomb > second bombs x cordinate and first bomb's y cordinate + radius of first bomb > second bomb's y cordinate also, so second bombs both cordinates falls under first bombs impact radus,\n\nCan someone please explain why my thinking is wrong? \nThank you."
                    },
                    {
                        "username": "_SID_",
                        "content": "Check this, you can understand easily : https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588930/1-1-100000-100000-100000-1-getting-wrong-understand-why/"
                    },
                    {
                        "username": "dkochetov",
                        "content": "It can't detonate. The distance between their centers is `sqrt((100000-1)^2 + (100000-1)^2) = 141420` that is greater than `100000`. Meaning that the second bomb is not within the radius of the first one."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "A great question. <b> Unique combination of Maths and Graph. </b>Can someone help me why this code gives TLE. It works when I execute it as a testcase, but when I run, it gives me a TLE.\\n```#define ll long long\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        unordered_map<int, vector<int>> G;\\n        int n = bombs.size();\\n        // Build the graph such that make a connection if a node is connected to \\n        // another if circlei overlaps the center of circlej\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if(circleOverlap(bombs[i][0], bombs[i][1], bombs[i][2], bombs[j][0], bombs[j][1])){\\n                    G[i].push_back(j);\\n                }\\n            }\\n        }\\n        // Use the vis for checking if a bomb has already been diffused\\n        int maimumDetonated = 0;\\n        for(int i = 0; i < n; i++){\\n            maimumDetonated = max(maimumDetonated, bfs(G, i));\\n        }\\n        return maimumDetonated;\\n    }\\nprivate:\\n    bool circleOverlap(ll x, ll y, ll r, ll x1, ll y1){\\n        return pow((x1 - x), 2) + pow((y1 - y), 2) - r*r <= 0;\\n    }\\n    int bfs(unordered_map<int, vector<int>> &G, int idx){\\n        queue<int> Q; Q.push(idx);\\n        unordered_set<int> vis; vis.insert(idx);\\n        int cnt = 0;\\n        while(!Q.empty()){\\n            int curr = Q.front(); Q.pop();\\n            vis.insert(curr);\\n            cnt++;\\n            for(int x: G[curr]){\\n                if(vis.find(x) == vis.end()){\\n                    Q.push(x);\\n                }\\n            }\\n        }\\n        return vis.size();\\n    }\\n};```"
                    },
                    {
                        "username": "sameertri039",
                        "content": "Nice problem!"
                    },
                    {
                        "username": "vnk01",
                        "content": "nice question! I got fooled into thinking I need to group every nodes that have radius reaching each other into the same group and overcount it in my first attempt"
                    },
                    {
                        "username": "ayush81029",
                        "content": "[[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]\\nWhy this testcase giving expected output 1 when it should be 2?\\n[69,51,7] and [65,59,3] are intersecting."
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the distance between [69,51,7] and [65,59,3] is 8.9 which make it not enough range to explode both of it"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Can anyone help, when I submit the code, it gives TLA. But, when I run the same testcase, it passes.\\nThere is a notification that it is due to global or static variables. But, I didn\\'t use global/static declarations in the first place.\\n"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Just one test case running for 500ms will be accepted. But after submitting, you will have to pass all ~100 test cases and the sum of their runtime must be less than ~5sec. So you need to reduce the complexity of your code."
                    },
                    {
                        "username": "Kyrie63",
                        "content": " `class Solution {\\n\\n    // Can someone tell me why I got wrong in this testcase?\\n    // [[37207,2653,5261],[40784,59523,20635],[16390,1426,39102],[42236,12,96855],[72839,62027,61667],[60691,58191,48447],[42932,46579,41248],[35868,43119,6870],[41693,98905,17374],[43441,1266,41621]]\\n    // Expected 10. but outcome is 5...\\n\\n    int count;\\n    public int maximumDetonation(int[][] bombs) {\\n        int n = bombs.length;\\n        List<Integer>[] bombGraph = buildGraph(n, bombs);\\n\\n        this.count = 0;\\n        int res = 0;\\n\\n        for (int i = 0; i < n; i++){\\n            boolean[] visited = new boolean[n];\\n            count = 0;\\n            dfs(bombGraph, i, visited);\\n            res = Math.max(res, count);\\n        }\\n        return res;\\n    }\\n\\n    public void dfs(List<Integer>[] graph, int cur, boolean[] visited){\\n        // base-case \\n        if (visited[cur]){\\n            return;\\n        }\\n\\n        visited[cur] = true;\\n        count++;\\n        for (int neigh : graph[cur]){\\n            dfs(graph, neigh, visited);\\n        }\\n    }\\n\\n    public List<Integer>[] buildGraph(int n, int[][] bombs){\\n        List<Integer>[] bombGraph = new LinkedList[n];\\n\\n        for (int i = 0; i < n; i++){\\n            bombGraph[i] = new LinkedList<>();\\n        }\\n\\n        for (int i = 0; i < n; i++){\\n            for (int j = 0; j < n; j++){\\n                if (i == j) continue;\\n                int x1 = bombs[i][0];\\n                int y1 = bombs[i][1];\\n                int r1 = bombs[i][2];\\n                int x2 = bombs[j][0];\\n                int y2 = bombs[j][1];\\n                // int r2 = bomb[j][2];\\n                // long dist = (long)(x1-x2)*(x1-x2) + (long)(y1-y2)*(y1-y2);\\n                // long boomDist = (long)(r1*r1);\\n\\n                // create a path if possible\\n                // if ((long)(r1 + r2) >= (long)(x1-x2)*(x1-x2) + (long)(y1-y2)*(y1-y2)){\\n                if ((long)(r1 * r1) >= ((long)(x1-x2)*(x1-x2) + (long)(y1-y2)*(y1-y2))){\\n                    bombGraph[i].add(j);\\n                }\\n            }\\n        }\\n\\n        return bombGraph;\\n    }\\n\\n}\\n`\\nCan someone tell me why I got wrong in this testcase?\\n [[37207,2653,5261],[40784,59523,20635],[16390,1426,39102],[42236,12,96855],[72839,62027,61667],[60691,58191,48447],[42932,46579,41248],[35868,43119,6870],[41693,98905,17374],[43441,1266,41621]]\\n The expected answer is 10. but my outcome is 5...\\nThanks!"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@EricRaw](/EricRaw) The problem is that the bombs array are all ints. You need to cast them into longs before doing your distance calculations."
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Kyrie63](/Kyrie63) [@psionl0](/psionl0) i check it again and i am wrong, the problem arise because of integer overflow.\nthe r1, r2, x1, x2, y1, y2 should be long"
                    },
                    {
                        "username": "psionl0",
                        "content": "The thing I don\\'t like about Math.pow() is that it returns a double which is less accurate than int or long. I suspect that the reason why the earlier code didn\\'t work was because the products overflowed before you could cast the result into a long integer. Try this:\\n```\\nif (long) r1 * (long) r1 >= (long) (x1-x2) * (long) (x1 - x2) + (long)(y1 - y2) * (long) (y1 - y2) {\\n```"
                    },
                    {
                        "username": "Kyrie63",
                        "content": "[@yakode](/yakode) I think Eric got the explanation, and when I changed my condition as: \n if (Math.pow(r1,2) >= (Math.pow((x1-x2), 2) + Math.pow((y1-y2), 2))){...}\nit works. But thanks anyways!!!"
                    },
                    {
                        "username": "Kyrie63",
                        "content": "[@EricRaw](/EricRaw) Thanks Eric for your detailed explaination, I think your opinions are correct. But I still have a question that this problem seems to cast a int value to a long type, and it will not occur the decimal portion, so what is wrong with my code? When I change my code to if (Math.pow(r1,2) >= (Math.pow((x1-x2), 2) + Math.pow((y1-y2), 2))), it works magically!"
                    },
                    {
                        "username": "yakode",
                        "content": "if ((long)(r1 * r1) >= ((long)((x1-x2)*(x1-x2)) + (long)((y1-y2)*(y1-y2)))){\\n\\nI don\\'t know the reason, but after I edited this if condition in  buildGraph. it pass this testcase."
                    },
                    {
                        "username": "EricRaw",
                        "content": "```if ((long)(r1 * r1) >= ((long)(x1-x2)*(x1-x2) + (long)(y1-y2)*(y1-y2))){```\nWhen you cast a double value to a long type, it truncates the decimal portion and converts it to an integer\n\neg\nwhen you cast double value 8.9 to a long type, the decimal portion will be truncated, and the resulting long value will be 8 which can be wrong\n- 8,6 >= 8,9 (it should be false)\n- 8 >= 8 (cast to long it become true)\n\nyou can test it out with this code\n```\n        double test = 8.9;\n        double test1 = 8.5;\n        System.out.println(test <= test1);\n        System.out.println((long)test <= (long)test1);\n```"
                    },
                    {
                        "username": "RaktimBhuyan21",
                        "content": "Can anyone help with what is wrong in my code ?\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n       \\n        int n = bombs.size();\\n        vector<vector<bool>>connected(n,vector<bool>(n,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==j){\\n                    connected[i][j] = 1;\\n                }\\n                else{\\n                    long xi = bombs[i][0];\\n                    long yi = bombs[i][1];\\n                    long ri = bombs[i][2];\\n                    long xj = bombs[j][0];\\n                    long yj = bombs[j][1];\\n                    long rj = bombs[j][2];\\n                    long  dis = (xi-xj)*(xi-xj) + (yi-yj)*(yi-yj);\\n                    \\n                    if(dis<=(ri*ri)){\\n                        connected[i][j] = 1;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        int ans =0;\\n        for(int i=0;i<n;i++){\\n            int cnt =0;\\n            for(int j=0;j<n;j++){\\n                if(connected[i][j]==1){\\n                    cnt++;\\n                   ans = max(ans,cnt);\\n                }\\n            }\\n            \\n            \\n        }\\n        return ans;\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1913758,
                "content": [
                    {
                        "username": "Tusharsingh110",
                        "content": "can some edges be bidirectional?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this is directed graph.  A->B and B->A are both allowed, yes."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Solution : \\nhttps://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588123/geometry-dfs-c-with-figure/ "
                    },
                    {
                        "username": "vamsikumili",
                        "content": "How is the expected result of [[1,1,100000],[100000,100000,1]] is 1, when the first bomb can detonate 2nd one . My point of view is first bomb's x cordinate + radius of first bomb > second bombs x cordinate and first bomb's y cordinate + radius of first bomb > second bomb's y cordinate also, so second bombs both cordinates falls under first bombs impact radus,\n\nCan someone please explain why my thinking is wrong? \nThank you."
                    },
                    {
                        "username": "_SID_",
                        "content": "Check this, you can understand easily : https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588930/1-1-100000-100000-100000-1-getting-wrong-understand-why/"
                    },
                    {
                        "username": "dkochetov",
                        "content": "It can't detonate. The distance between their centers is `sqrt((100000-1)^2 + (100000-1)^2) = 141420` that is greater than `100000`. Meaning that the second bomb is not within the radius of the first one."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "A great question. <b> Unique combination of Maths and Graph. </b>Can someone help me why this code gives TLE. It works when I execute it as a testcase, but when I run, it gives me a TLE.\\n```#define ll long long\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        unordered_map<int, vector<int>> G;\\n        int n = bombs.size();\\n        // Build the graph such that make a connection if a node is connected to \\n        // another if circlei overlaps the center of circlej\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if(circleOverlap(bombs[i][0], bombs[i][1], bombs[i][2], bombs[j][0], bombs[j][1])){\\n                    G[i].push_back(j);\\n                }\\n            }\\n        }\\n        // Use the vis for checking if a bomb has already been diffused\\n        int maimumDetonated = 0;\\n        for(int i = 0; i < n; i++){\\n            maimumDetonated = max(maimumDetonated, bfs(G, i));\\n        }\\n        return maimumDetonated;\\n    }\\nprivate:\\n    bool circleOverlap(ll x, ll y, ll r, ll x1, ll y1){\\n        return pow((x1 - x), 2) + pow((y1 - y), 2) - r*r <= 0;\\n    }\\n    int bfs(unordered_map<int, vector<int>> &G, int idx){\\n        queue<int> Q; Q.push(idx);\\n        unordered_set<int> vis; vis.insert(idx);\\n        int cnt = 0;\\n        while(!Q.empty()){\\n            int curr = Q.front(); Q.pop();\\n            vis.insert(curr);\\n            cnt++;\\n            for(int x: G[curr]){\\n                if(vis.find(x) == vis.end()){\\n                    Q.push(x);\\n                }\\n            }\\n        }\\n        return vis.size();\\n    }\\n};```"
                    },
                    {
                        "username": "sameertri039",
                        "content": "Nice problem!"
                    },
                    {
                        "username": "vnk01",
                        "content": "nice question! I got fooled into thinking I need to group every nodes that have radius reaching each other into the same group and overcount it in my first attempt"
                    },
                    {
                        "username": "ayush81029",
                        "content": "[[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]\\nWhy this testcase giving expected output 1 when it should be 2?\\n[69,51,7] and [65,59,3] are intersecting."
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the distance between [69,51,7] and [65,59,3] is 8.9 which make it not enough range to explode both of it"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Can anyone help, when I submit the code, it gives TLA. But, when I run the same testcase, it passes.\\nThere is a notification that it is due to global or static variables. But, I didn\\'t use global/static declarations in the first place.\\n"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Just one test case running for 500ms will be accepted. But after submitting, you will have to pass all ~100 test cases and the sum of their runtime must be less than ~5sec. So you need to reduce the complexity of your code."
                    },
                    {
                        "username": "Kyrie63",
                        "content": " `class Solution {\\n\\n    // Can someone tell me why I got wrong in this testcase?\\n    // [[37207,2653,5261],[40784,59523,20635],[16390,1426,39102],[42236,12,96855],[72839,62027,61667],[60691,58191,48447],[42932,46579,41248],[35868,43119,6870],[41693,98905,17374],[43441,1266,41621]]\\n    // Expected 10. but outcome is 5...\\n\\n    int count;\\n    public int maximumDetonation(int[][] bombs) {\\n        int n = bombs.length;\\n        List<Integer>[] bombGraph = buildGraph(n, bombs);\\n\\n        this.count = 0;\\n        int res = 0;\\n\\n        for (int i = 0; i < n; i++){\\n            boolean[] visited = new boolean[n];\\n            count = 0;\\n            dfs(bombGraph, i, visited);\\n            res = Math.max(res, count);\\n        }\\n        return res;\\n    }\\n\\n    public void dfs(List<Integer>[] graph, int cur, boolean[] visited){\\n        // base-case \\n        if (visited[cur]){\\n            return;\\n        }\\n\\n        visited[cur] = true;\\n        count++;\\n        for (int neigh : graph[cur]){\\n            dfs(graph, neigh, visited);\\n        }\\n    }\\n\\n    public List<Integer>[] buildGraph(int n, int[][] bombs){\\n        List<Integer>[] bombGraph = new LinkedList[n];\\n\\n        for (int i = 0; i < n; i++){\\n            bombGraph[i] = new LinkedList<>();\\n        }\\n\\n        for (int i = 0; i < n; i++){\\n            for (int j = 0; j < n; j++){\\n                if (i == j) continue;\\n                int x1 = bombs[i][0];\\n                int y1 = bombs[i][1];\\n                int r1 = bombs[i][2];\\n                int x2 = bombs[j][0];\\n                int y2 = bombs[j][1];\\n                // int r2 = bomb[j][2];\\n                // long dist = (long)(x1-x2)*(x1-x2) + (long)(y1-y2)*(y1-y2);\\n                // long boomDist = (long)(r1*r1);\\n\\n                // create a path if possible\\n                // if ((long)(r1 + r2) >= (long)(x1-x2)*(x1-x2) + (long)(y1-y2)*(y1-y2)){\\n                if ((long)(r1 * r1) >= ((long)(x1-x2)*(x1-x2) + (long)(y1-y2)*(y1-y2))){\\n                    bombGraph[i].add(j);\\n                }\\n            }\\n        }\\n\\n        return bombGraph;\\n    }\\n\\n}\\n`\\nCan someone tell me why I got wrong in this testcase?\\n [[37207,2653,5261],[40784,59523,20635],[16390,1426,39102],[42236,12,96855],[72839,62027,61667],[60691,58191,48447],[42932,46579,41248],[35868,43119,6870],[41693,98905,17374],[43441,1266,41621]]\\n The expected answer is 10. but my outcome is 5...\\nThanks!"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@EricRaw](/EricRaw) The problem is that the bombs array are all ints. You need to cast them into longs before doing your distance calculations."
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Kyrie63](/Kyrie63) [@psionl0](/psionl0) i check it again and i am wrong, the problem arise because of integer overflow.\nthe r1, r2, x1, x2, y1, y2 should be long"
                    },
                    {
                        "username": "psionl0",
                        "content": "The thing I don\\'t like about Math.pow() is that it returns a double which is less accurate than int or long. I suspect that the reason why the earlier code didn\\'t work was because the products overflowed before you could cast the result into a long integer. Try this:\\n```\\nif (long) r1 * (long) r1 >= (long) (x1-x2) * (long) (x1 - x2) + (long)(y1 - y2) * (long) (y1 - y2) {\\n```"
                    },
                    {
                        "username": "Kyrie63",
                        "content": "[@yakode](/yakode) I think Eric got the explanation, and when I changed my condition as: \n if (Math.pow(r1,2) >= (Math.pow((x1-x2), 2) + Math.pow((y1-y2), 2))){...}\nit works. But thanks anyways!!!"
                    },
                    {
                        "username": "Kyrie63",
                        "content": "[@EricRaw](/EricRaw) Thanks Eric for your detailed explaination, I think your opinions are correct. But I still have a question that this problem seems to cast a int value to a long type, and it will not occur the decimal portion, so what is wrong with my code? When I change my code to if (Math.pow(r1,2) >= (Math.pow((x1-x2), 2) + Math.pow((y1-y2), 2))), it works magically!"
                    },
                    {
                        "username": "yakode",
                        "content": "if ((long)(r1 * r1) >= ((long)((x1-x2)*(x1-x2)) + (long)((y1-y2)*(y1-y2)))){\\n\\nI don\\'t know the reason, but after I edited this if condition in  buildGraph. it pass this testcase."
                    },
                    {
                        "username": "EricRaw",
                        "content": "```if ((long)(r1 * r1) >= ((long)(x1-x2)*(x1-x2) + (long)(y1-y2)*(y1-y2))){```\nWhen you cast a double value to a long type, it truncates the decimal portion and converts it to an integer\n\neg\nwhen you cast double value 8.9 to a long type, the decimal portion will be truncated, and the resulting long value will be 8 which can be wrong\n- 8,6 >= 8,9 (it should be false)\n- 8 >= 8 (cast to long it become true)\n\nyou can test it out with this code\n```\n        double test = 8.9;\n        double test1 = 8.5;\n        System.out.println(test <= test1);\n        System.out.println((long)test <= (long)test1);\n```"
                    },
                    {
                        "username": "RaktimBhuyan21",
                        "content": "Can anyone help with what is wrong in my code ?\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n       \\n        int n = bombs.size();\\n        vector<vector<bool>>connected(n,vector<bool>(n,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==j){\\n                    connected[i][j] = 1;\\n                }\\n                else{\\n                    long xi = bombs[i][0];\\n                    long yi = bombs[i][1];\\n                    long ri = bombs[i][2];\\n                    long xj = bombs[j][0];\\n                    long yj = bombs[j][1];\\n                    long rj = bombs[j][2];\\n                    long  dis = (xi-xj)*(xi-xj) + (yi-yj)*(yi-yj);\\n                    \\n                    if(dis<=(ri*ri)){\\n                        connected[i][j] = 1;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        int ans =0;\\n        for(int i=0;i<n;i++){\\n            int cnt =0;\\n            for(int j=0;j<n;j++){\\n                if(connected[i][j]==1){\\n                    cnt++;\\n                   ans = max(ans,cnt);\\n                }\\n            }\\n            \\n            \\n        }\\n        return ans;\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1913734,
                "content": [
                    {
                        "username": "Tusharsingh110",
                        "content": "can some edges be bidirectional?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this is directed graph.  A->B and B->A are both allowed, yes."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Solution : \\nhttps://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588123/geometry-dfs-c-with-figure/ "
                    },
                    {
                        "username": "vamsikumili",
                        "content": "How is the expected result of [[1,1,100000],[100000,100000,1]] is 1, when the first bomb can detonate 2nd one . My point of view is first bomb's x cordinate + radius of first bomb > second bombs x cordinate and first bomb's y cordinate + radius of first bomb > second bomb's y cordinate also, so second bombs both cordinates falls under first bombs impact radus,\n\nCan someone please explain why my thinking is wrong? \nThank you."
                    },
                    {
                        "username": "_SID_",
                        "content": "Check this, you can understand easily : https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588930/1-1-100000-100000-100000-1-getting-wrong-understand-why/"
                    },
                    {
                        "username": "dkochetov",
                        "content": "It can't detonate. The distance between their centers is `sqrt((100000-1)^2 + (100000-1)^2) = 141420` that is greater than `100000`. Meaning that the second bomb is not within the radius of the first one."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "A great question. <b> Unique combination of Maths and Graph. </b>Can someone help me why this code gives TLE. It works when I execute it as a testcase, but when I run, it gives me a TLE.\\n```#define ll long long\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        unordered_map<int, vector<int>> G;\\n        int n = bombs.size();\\n        // Build the graph such that make a connection if a node is connected to \\n        // another if circlei overlaps the center of circlej\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if(circleOverlap(bombs[i][0], bombs[i][1], bombs[i][2], bombs[j][0], bombs[j][1])){\\n                    G[i].push_back(j);\\n                }\\n            }\\n        }\\n        // Use the vis for checking if a bomb has already been diffused\\n        int maimumDetonated = 0;\\n        for(int i = 0; i < n; i++){\\n            maimumDetonated = max(maimumDetonated, bfs(G, i));\\n        }\\n        return maimumDetonated;\\n    }\\nprivate:\\n    bool circleOverlap(ll x, ll y, ll r, ll x1, ll y1){\\n        return pow((x1 - x), 2) + pow((y1 - y), 2) - r*r <= 0;\\n    }\\n    int bfs(unordered_map<int, vector<int>> &G, int idx){\\n        queue<int> Q; Q.push(idx);\\n        unordered_set<int> vis; vis.insert(idx);\\n        int cnt = 0;\\n        while(!Q.empty()){\\n            int curr = Q.front(); Q.pop();\\n            vis.insert(curr);\\n            cnt++;\\n            for(int x: G[curr]){\\n                if(vis.find(x) == vis.end()){\\n                    Q.push(x);\\n                }\\n            }\\n        }\\n        return vis.size();\\n    }\\n};```"
                    },
                    {
                        "username": "sameertri039",
                        "content": "Nice problem!"
                    },
                    {
                        "username": "vnk01",
                        "content": "nice question! I got fooled into thinking I need to group every nodes that have radius reaching each other into the same group and overcount it in my first attempt"
                    },
                    {
                        "username": "ayush81029",
                        "content": "[[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]\\nWhy this testcase giving expected output 1 when it should be 2?\\n[69,51,7] and [65,59,3] are intersecting."
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the distance between [69,51,7] and [65,59,3] is 8.9 which make it not enough range to explode both of it"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Can anyone help, when I submit the code, it gives TLA. But, when I run the same testcase, it passes.\\nThere is a notification that it is due to global or static variables. But, I didn\\'t use global/static declarations in the first place.\\n"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Just one test case running for 500ms will be accepted. But after submitting, you will have to pass all ~100 test cases and the sum of their runtime must be less than ~5sec. So you need to reduce the complexity of your code."
                    },
                    {
                        "username": "Kyrie63",
                        "content": " `class Solution {\\n\\n    // Can someone tell me why I got wrong in this testcase?\\n    // [[37207,2653,5261],[40784,59523,20635],[16390,1426,39102],[42236,12,96855],[72839,62027,61667],[60691,58191,48447],[42932,46579,41248],[35868,43119,6870],[41693,98905,17374],[43441,1266,41621]]\\n    // Expected 10. but outcome is 5...\\n\\n    int count;\\n    public int maximumDetonation(int[][] bombs) {\\n        int n = bombs.length;\\n        List<Integer>[] bombGraph = buildGraph(n, bombs);\\n\\n        this.count = 0;\\n        int res = 0;\\n\\n        for (int i = 0; i < n; i++){\\n            boolean[] visited = new boolean[n];\\n            count = 0;\\n            dfs(bombGraph, i, visited);\\n            res = Math.max(res, count);\\n        }\\n        return res;\\n    }\\n\\n    public void dfs(List<Integer>[] graph, int cur, boolean[] visited){\\n        // base-case \\n        if (visited[cur]){\\n            return;\\n        }\\n\\n        visited[cur] = true;\\n        count++;\\n        for (int neigh : graph[cur]){\\n            dfs(graph, neigh, visited);\\n        }\\n    }\\n\\n    public List<Integer>[] buildGraph(int n, int[][] bombs){\\n        List<Integer>[] bombGraph = new LinkedList[n];\\n\\n        for (int i = 0; i < n; i++){\\n            bombGraph[i] = new LinkedList<>();\\n        }\\n\\n        for (int i = 0; i < n; i++){\\n            for (int j = 0; j < n; j++){\\n                if (i == j) continue;\\n                int x1 = bombs[i][0];\\n                int y1 = bombs[i][1];\\n                int r1 = bombs[i][2];\\n                int x2 = bombs[j][0];\\n                int y2 = bombs[j][1];\\n                // int r2 = bomb[j][2];\\n                // long dist = (long)(x1-x2)*(x1-x2) + (long)(y1-y2)*(y1-y2);\\n                // long boomDist = (long)(r1*r1);\\n\\n                // create a path if possible\\n                // if ((long)(r1 + r2) >= (long)(x1-x2)*(x1-x2) + (long)(y1-y2)*(y1-y2)){\\n                if ((long)(r1 * r1) >= ((long)(x1-x2)*(x1-x2) + (long)(y1-y2)*(y1-y2))){\\n                    bombGraph[i].add(j);\\n                }\\n            }\\n        }\\n\\n        return bombGraph;\\n    }\\n\\n}\\n`\\nCan someone tell me why I got wrong in this testcase?\\n [[37207,2653,5261],[40784,59523,20635],[16390,1426,39102],[42236,12,96855],[72839,62027,61667],[60691,58191,48447],[42932,46579,41248],[35868,43119,6870],[41693,98905,17374],[43441,1266,41621]]\\n The expected answer is 10. but my outcome is 5...\\nThanks!"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@EricRaw](/EricRaw) The problem is that the bombs array are all ints. You need to cast them into longs before doing your distance calculations."
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Kyrie63](/Kyrie63) [@psionl0](/psionl0) i check it again and i am wrong, the problem arise because of integer overflow.\nthe r1, r2, x1, x2, y1, y2 should be long"
                    },
                    {
                        "username": "psionl0",
                        "content": "The thing I don\\'t like about Math.pow() is that it returns a double which is less accurate than int or long. I suspect that the reason why the earlier code didn\\'t work was because the products overflowed before you could cast the result into a long integer. Try this:\\n```\\nif (long) r1 * (long) r1 >= (long) (x1-x2) * (long) (x1 - x2) + (long)(y1 - y2) * (long) (y1 - y2) {\\n```"
                    },
                    {
                        "username": "Kyrie63",
                        "content": "[@yakode](/yakode) I think Eric got the explanation, and when I changed my condition as: \n if (Math.pow(r1,2) >= (Math.pow((x1-x2), 2) + Math.pow((y1-y2), 2))){...}\nit works. But thanks anyways!!!"
                    },
                    {
                        "username": "Kyrie63",
                        "content": "[@EricRaw](/EricRaw) Thanks Eric for your detailed explaination, I think your opinions are correct. But I still have a question that this problem seems to cast a int value to a long type, and it will not occur the decimal portion, so what is wrong with my code? When I change my code to if (Math.pow(r1,2) >= (Math.pow((x1-x2), 2) + Math.pow((y1-y2), 2))), it works magically!"
                    },
                    {
                        "username": "yakode",
                        "content": "if ((long)(r1 * r1) >= ((long)((x1-x2)*(x1-x2)) + (long)((y1-y2)*(y1-y2)))){\\n\\nI don\\'t know the reason, but after I edited this if condition in  buildGraph. it pass this testcase."
                    },
                    {
                        "username": "EricRaw",
                        "content": "```if ((long)(r1 * r1) >= ((long)(x1-x2)*(x1-x2) + (long)(y1-y2)*(y1-y2))){```\nWhen you cast a double value to a long type, it truncates the decimal portion and converts it to an integer\n\neg\nwhen you cast double value 8.9 to a long type, the decimal portion will be truncated, and the resulting long value will be 8 which can be wrong\n- 8,6 >= 8,9 (it should be false)\n- 8 >= 8 (cast to long it become true)\n\nyou can test it out with this code\n```\n        double test = 8.9;\n        double test1 = 8.5;\n        System.out.println(test <= test1);\n        System.out.println((long)test <= (long)test1);\n```"
                    },
                    {
                        "username": "RaktimBhuyan21",
                        "content": "Can anyone help with what is wrong in my code ?\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n       \\n        int n = bombs.size();\\n        vector<vector<bool>>connected(n,vector<bool>(n,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==j){\\n                    connected[i][j] = 1;\\n                }\\n                else{\\n                    long xi = bombs[i][0];\\n                    long yi = bombs[i][1];\\n                    long ri = bombs[i][2];\\n                    long xj = bombs[j][0];\\n                    long yj = bombs[j][1];\\n                    long rj = bombs[j][2];\\n                    long  dis = (xi-xj)*(xi-xj) + (yi-yj)*(yi-yj);\\n                    \\n                    if(dis<=(ri*ri)){\\n                        connected[i][j] = 1;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        int ans =0;\\n        for(int i=0;i<n;i++){\\n            int cnt =0;\\n            for(int j=0;j<n;j++){\\n                if(connected[i][j]==1){\\n                    cnt++;\\n                   ans = max(ans,cnt);\\n                }\\n            }\\n            \\n            \\n        }\\n        return ans;\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1913732,
                "content": [
                    {
                        "username": "Tusharsingh110",
                        "content": "can some edges be bidirectional?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this is directed graph.  A->B and B->A are both allowed, yes."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Solution : \\nhttps://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588123/geometry-dfs-c-with-figure/ "
                    },
                    {
                        "username": "vamsikumili",
                        "content": "How is the expected result of [[1,1,100000],[100000,100000,1]] is 1, when the first bomb can detonate 2nd one . My point of view is first bomb's x cordinate + radius of first bomb > second bombs x cordinate and first bomb's y cordinate + radius of first bomb > second bomb's y cordinate also, so second bombs both cordinates falls under first bombs impact radus,\n\nCan someone please explain why my thinking is wrong? \nThank you."
                    },
                    {
                        "username": "_SID_",
                        "content": "Check this, you can understand easily : https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588930/1-1-100000-100000-100000-1-getting-wrong-understand-why/"
                    },
                    {
                        "username": "dkochetov",
                        "content": "It can't detonate. The distance between their centers is `sqrt((100000-1)^2 + (100000-1)^2) = 141420` that is greater than `100000`. Meaning that the second bomb is not within the radius of the first one."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "A great question. <b> Unique combination of Maths and Graph. </b>Can someone help me why this code gives TLE. It works when I execute it as a testcase, but when I run, it gives me a TLE.\\n```#define ll long long\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        unordered_map<int, vector<int>> G;\\n        int n = bombs.size();\\n        // Build the graph such that make a connection if a node is connected to \\n        // another if circlei overlaps the center of circlej\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if(circleOverlap(bombs[i][0], bombs[i][1], bombs[i][2], bombs[j][0], bombs[j][1])){\\n                    G[i].push_back(j);\\n                }\\n            }\\n        }\\n        // Use the vis for checking if a bomb has already been diffused\\n        int maimumDetonated = 0;\\n        for(int i = 0; i < n; i++){\\n            maimumDetonated = max(maimumDetonated, bfs(G, i));\\n        }\\n        return maimumDetonated;\\n    }\\nprivate:\\n    bool circleOverlap(ll x, ll y, ll r, ll x1, ll y1){\\n        return pow((x1 - x), 2) + pow((y1 - y), 2) - r*r <= 0;\\n    }\\n    int bfs(unordered_map<int, vector<int>> &G, int idx){\\n        queue<int> Q; Q.push(idx);\\n        unordered_set<int> vis; vis.insert(idx);\\n        int cnt = 0;\\n        while(!Q.empty()){\\n            int curr = Q.front(); Q.pop();\\n            vis.insert(curr);\\n            cnt++;\\n            for(int x: G[curr]){\\n                if(vis.find(x) == vis.end()){\\n                    Q.push(x);\\n                }\\n            }\\n        }\\n        return vis.size();\\n    }\\n};```"
                    },
                    {
                        "username": "sameertri039",
                        "content": "Nice problem!"
                    },
                    {
                        "username": "vnk01",
                        "content": "nice question! I got fooled into thinking I need to group every nodes that have radius reaching each other into the same group and overcount it in my first attempt"
                    },
                    {
                        "username": "ayush81029",
                        "content": "[[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]\\nWhy this testcase giving expected output 1 when it should be 2?\\n[69,51,7] and [65,59,3] are intersecting."
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the distance between [69,51,7] and [65,59,3] is 8.9 which make it not enough range to explode both of it"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Can anyone help, when I submit the code, it gives TLA. But, when I run the same testcase, it passes.\\nThere is a notification that it is due to global or static variables. But, I didn\\'t use global/static declarations in the first place.\\n"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Just one test case running for 500ms will be accepted. But after submitting, you will have to pass all ~100 test cases and the sum of their runtime must be less than ~5sec. So you need to reduce the complexity of your code."
                    },
                    {
                        "username": "Kyrie63",
                        "content": " `class Solution {\\n\\n    // Can someone tell me why I got wrong in this testcase?\\n    // [[37207,2653,5261],[40784,59523,20635],[16390,1426,39102],[42236,12,96855],[72839,62027,61667],[60691,58191,48447],[42932,46579,41248],[35868,43119,6870],[41693,98905,17374],[43441,1266,41621]]\\n    // Expected 10. but outcome is 5...\\n\\n    int count;\\n    public int maximumDetonation(int[][] bombs) {\\n        int n = bombs.length;\\n        List<Integer>[] bombGraph = buildGraph(n, bombs);\\n\\n        this.count = 0;\\n        int res = 0;\\n\\n        for (int i = 0; i < n; i++){\\n            boolean[] visited = new boolean[n];\\n            count = 0;\\n            dfs(bombGraph, i, visited);\\n            res = Math.max(res, count);\\n        }\\n        return res;\\n    }\\n\\n    public void dfs(List<Integer>[] graph, int cur, boolean[] visited){\\n        // base-case \\n        if (visited[cur]){\\n            return;\\n        }\\n\\n        visited[cur] = true;\\n        count++;\\n        for (int neigh : graph[cur]){\\n            dfs(graph, neigh, visited);\\n        }\\n    }\\n\\n    public List<Integer>[] buildGraph(int n, int[][] bombs){\\n        List<Integer>[] bombGraph = new LinkedList[n];\\n\\n        for (int i = 0; i < n; i++){\\n            bombGraph[i] = new LinkedList<>();\\n        }\\n\\n        for (int i = 0; i < n; i++){\\n            for (int j = 0; j < n; j++){\\n                if (i == j) continue;\\n                int x1 = bombs[i][0];\\n                int y1 = bombs[i][1];\\n                int r1 = bombs[i][2];\\n                int x2 = bombs[j][0];\\n                int y2 = bombs[j][1];\\n                // int r2 = bomb[j][2];\\n                // long dist = (long)(x1-x2)*(x1-x2) + (long)(y1-y2)*(y1-y2);\\n                // long boomDist = (long)(r1*r1);\\n\\n                // create a path if possible\\n                // if ((long)(r1 + r2) >= (long)(x1-x2)*(x1-x2) + (long)(y1-y2)*(y1-y2)){\\n                if ((long)(r1 * r1) >= ((long)(x1-x2)*(x1-x2) + (long)(y1-y2)*(y1-y2))){\\n                    bombGraph[i].add(j);\\n                }\\n            }\\n        }\\n\\n        return bombGraph;\\n    }\\n\\n}\\n`\\nCan someone tell me why I got wrong in this testcase?\\n [[37207,2653,5261],[40784,59523,20635],[16390,1426,39102],[42236,12,96855],[72839,62027,61667],[60691,58191,48447],[42932,46579,41248],[35868,43119,6870],[41693,98905,17374],[43441,1266,41621]]\\n The expected answer is 10. but my outcome is 5...\\nThanks!"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@EricRaw](/EricRaw) The problem is that the bombs array are all ints. You need to cast them into longs before doing your distance calculations."
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Kyrie63](/Kyrie63) [@psionl0](/psionl0) i check it again and i am wrong, the problem arise because of integer overflow.\nthe r1, r2, x1, x2, y1, y2 should be long"
                    },
                    {
                        "username": "psionl0",
                        "content": "The thing I don\\'t like about Math.pow() is that it returns a double which is less accurate than int or long. I suspect that the reason why the earlier code didn\\'t work was because the products overflowed before you could cast the result into a long integer. Try this:\\n```\\nif (long) r1 * (long) r1 >= (long) (x1-x2) * (long) (x1 - x2) + (long)(y1 - y2) * (long) (y1 - y2) {\\n```"
                    },
                    {
                        "username": "Kyrie63",
                        "content": "[@yakode](/yakode) I think Eric got the explanation, and when I changed my condition as: \n if (Math.pow(r1,2) >= (Math.pow((x1-x2), 2) + Math.pow((y1-y2), 2))){...}\nit works. But thanks anyways!!!"
                    },
                    {
                        "username": "Kyrie63",
                        "content": "[@EricRaw](/EricRaw) Thanks Eric for your detailed explaination, I think your opinions are correct. But I still have a question that this problem seems to cast a int value to a long type, and it will not occur the decimal portion, so what is wrong with my code? When I change my code to if (Math.pow(r1,2) >= (Math.pow((x1-x2), 2) + Math.pow((y1-y2), 2))), it works magically!"
                    },
                    {
                        "username": "yakode",
                        "content": "if ((long)(r1 * r1) >= ((long)((x1-x2)*(x1-x2)) + (long)((y1-y2)*(y1-y2)))){\\n\\nI don\\'t know the reason, but after I edited this if condition in  buildGraph. it pass this testcase."
                    },
                    {
                        "username": "EricRaw",
                        "content": "```if ((long)(r1 * r1) >= ((long)(x1-x2)*(x1-x2) + (long)(y1-y2)*(y1-y2))){```\nWhen you cast a double value to a long type, it truncates the decimal portion and converts it to an integer\n\neg\nwhen you cast double value 8.9 to a long type, the decimal portion will be truncated, and the resulting long value will be 8 which can be wrong\n- 8,6 >= 8,9 (it should be false)\n- 8 >= 8 (cast to long it become true)\n\nyou can test it out with this code\n```\n        double test = 8.9;\n        double test1 = 8.5;\n        System.out.println(test <= test1);\n        System.out.println((long)test <= (long)test1);\n```"
                    },
                    {
                        "username": "RaktimBhuyan21",
                        "content": "Can anyone help with what is wrong in my code ?\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n       \\n        int n = bombs.size();\\n        vector<vector<bool>>connected(n,vector<bool>(n,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==j){\\n                    connected[i][j] = 1;\\n                }\\n                else{\\n                    long xi = bombs[i][0];\\n                    long yi = bombs[i][1];\\n                    long ri = bombs[i][2];\\n                    long xj = bombs[j][0];\\n                    long yj = bombs[j][1];\\n                    long rj = bombs[j][2];\\n                    long  dis = (xi-xj)*(xi-xj) + (yi-yj)*(yi-yj);\\n                    \\n                    if(dis<=(ri*ri)){\\n                        connected[i][j] = 1;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        int ans =0;\\n        for(int i=0;i<n;i++){\\n            int cnt =0;\\n            for(int j=0;j<n;j++){\\n                if(connected[i][j]==1){\\n                    cnt++;\\n                   ans = max(ans,cnt);\\n                }\\n            }\\n            \\n            \\n        }\\n        return ans;\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1913730,
                "content": [
                    {
                        "username": "Tusharsingh110",
                        "content": "can some edges be bidirectional?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this is directed graph.  A->B and B->A are both allowed, yes."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Solution : \\nhttps://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588123/geometry-dfs-c-with-figure/ "
                    },
                    {
                        "username": "vamsikumili",
                        "content": "How is the expected result of [[1,1,100000],[100000,100000,1]] is 1, when the first bomb can detonate 2nd one . My point of view is first bomb's x cordinate + radius of first bomb > second bombs x cordinate and first bomb's y cordinate + radius of first bomb > second bomb's y cordinate also, so second bombs both cordinates falls under first bombs impact radus,\n\nCan someone please explain why my thinking is wrong? \nThank you."
                    },
                    {
                        "username": "_SID_",
                        "content": "Check this, you can understand easily : https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588930/1-1-100000-100000-100000-1-getting-wrong-understand-why/"
                    },
                    {
                        "username": "dkochetov",
                        "content": "It can't detonate. The distance between their centers is `sqrt((100000-1)^2 + (100000-1)^2) = 141420` that is greater than `100000`. Meaning that the second bomb is not within the radius of the first one."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "A great question. <b> Unique combination of Maths and Graph. </b>Can someone help me why this code gives TLE. It works when I execute it as a testcase, but when I run, it gives me a TLE.\\n```#define ll long long\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        unordered_map<int, vector<int>> G;\\n        int n = bombs.size();\\n        // Build the graph such that make a connection if a node is connected to \\n        // another if circlei overlaps the center of circlej\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if(circleOverlap(bombs[i][0], bombs[i][1], bombs[i][2], bombs[j][0], bombs[j][1])){\\n                    G[i].push_back(j);\\n                }\\n            }\\n        }\\n        // Use the vis for checking if a bomb has already been diffused\\n        int maimumDetonated = 0;\\n        for(int i = 0; i < n; i++){\\n            maimumDetonated = max(maimumDetonated, bfs(G, i));\\n        }\\n        return maimumDetonated;\\n    }\\nprivate:\\n    bool circleOverlap(ll x, ll y, ll r, ll x1, ll y1){\\n        return pow((x1 - x), 2) + pow((y1 - y), 2) - r*r <= 0;\\n    }\\n    int bfs(unordered_map<int, vector<int>> &G, int idx){\\n        queue<int> Q; Q.push(idx);\\n        unordered_set<int> vis; vis.insert(idx);\\n        int cnt = 0;\\n        while(!Q.empty()){\\n            int curr = Q.front(); Q.pop();\\n            vis.insert(curr);\\n            cnt++;\\n            for(int x: G[curr]){\\n                if(vis.find(x) == vis.end()){\\n                    Q.push(x);\\n                }\\n            }\\n        }\\n        return vis.size();\\n    }\\n};```"
                    },
                    {
                        "username": "sameertri039",
                        "content": "Nice problem!"
                    },
                    {
                        "username": "vnk01",
                        "content": "nice question! I got fooled into thinking I need to group every nodes that have radius reaching each other into the same group and overcount it in my first attempt"
                    },
                    {
                        "username": "ayush81029",
                        "content": "[[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]\\nWhy this testcase giving expected output 1 when it should be 2?\\n[69,51,7] and [65,59,3] are intersecting."
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the distance between [69,51,7] and [65,59,3] is 8.9 which make it not enough range to explode both of it"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Can anyone help, when I submit the code, it gives TLA. But, when I run the same testcase, it passes.\\nThere is a notification that it is due to global or static variables. But, I didn\\'t use global/static declarations in the first place.\\n"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Just one test case running for 500ms will be accepted. But after submitting, you will have to pass all ~100 test cases and the sum of their runtime must be less than ~5sec. So you need to reduce the complexity of your code."
                    },
                    {
                        "username": "Kyrie63",
                        "content": " `class Solution {\\n\\n    // Can someone tell me why I got wrong in this testcase?\\n    // [[37207,2653,5261],[40784,59523,20635],[16390,1426,39102],[42236,12,96855],[72839,62027,61667],[60691,58191,48447],[42932,46579,41248],[35868,43119,6870],[41693,98905,17374],[43441,1266,41621]]\\n    // Expected 10. but outcome is 5...\\n\\n    int count;\\n    public int maximumDetonation(int[][] bombs) {\\n        int n = bombs.length;\\n        List<Integer>[] bombGraph = buildGraph(n, bombs);\\n\\n        this.count = 0;\\n        int res = 0;\\n\\n        for (int i = 0; i < n; i++){\\n            boolean[] visited = new boolean[n];\\n            count = 0;\\n            dfs(bombGraph, i, visited);\\n            res = Math.max(res, count);\\n        }\\n        return res;\\n    }\\n\\n    public void dfs(List<Integer>[] graph, int cur, boolean[] visited){\\n        // base-case \\n        if (visited[cur]){\\n            return;\\n        }\\n\\n        visited[cur] = true;\\n        count++;\\n        for (int neigh : graph[cur]){\\n            dfs(graph, neigh, visited);\\n        }\\n    }\\n\\n    public List<Integer>[] buildGraph(int n, int[][] bombs){\\n        List<Integer>[] bombGraph = new LinkedList[n];\\n\\n        for (int i = 0; i < n; i++){\\n            bombGraph[i] = new LinkedList<>();\\n        }\\n\\n        for (int i = 0; i < n; i++){\\n            for (int j = 0; j < n; j++){\\n                if (i == j) continue;\\n                int x1 = bombs[i][0];\\n                int y1 = bombs[i][1];\\n                int r1 = bombs[i][2];\\n                int x2 = bombs[j][0];\\n                int y2 = bombs[j][1];\\n                // int r2 = bomb[j][2];\\n                // long dist = (long)(x1-x2)*(x1-x2) + (long)(y1-y2)*(y1-y2);\\n                // long boomDist = (long)(r1*r1);\\n\\n                // create a path if possible\\n                // if ((long)(r1 + r2) >= (long)(x1-x2)*(x1-x2) + (long)(y1-y2)*(y1-y2)){\\n                if ((long)(r1 * r1) >= ((long)(x1-x2)*(x1-x2) + (long)(y1-y2)*(y1-y2))){\\n                    bombGraph[i].add(j);\\n                }\\n            }\\n        }\\n\\n        return bombGraph;\\n    }\\n\\n}\\n`\\nCan someone tell me why I got wrong in this testcase?\\n [[37207,2653,5261],[40784,59523,20635],[16390,1426,39102],[42236,12,96855],[72839,62027,61667],[60691,58191,48447],[42932,46579,41248],[35868,43119,6870],[41693,98905,17374],[43441,1266,41621]]\\n The expected answer is 10. but my outcome is 5...\\nThanks!"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@EricRaw](/EricRaw) The problem is that the bombs array are all ints. You need to cast them into longs before doing your distance calculations."
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Kyrie63](/Kyrie63) [@psionl0](/psionl0) i check it again and i am wrong, the problem arise because of integer overflow.\nthe r1, r2, x1, x2, y1, y2 should be long"
                    },
                    {
                        "username": "psionl0",
                        "content": "The thing I don\\'t like about Math.pow() is that it returns a double which is less accurate than int or long. I suspect that the reason why the earlier code didn\\'t work was because the products overflowed before you could cast the result into a long integer. Try this:\\n```\\nif (long) r1 * (long) r1 >= (long) (x1-x2) * (long) (x1 - x2) + (long)(y1 - y2) * (long) (y1 - y2) {\\n```"
                    },
                    {
                        "username": "Kyrie63",
                        "content": "[@yakode](/yakode) I think Eric got the explanation, and when I changed my condition as: \n if (Math.pow(r1,2) >= (Math.pow((x1-x2), 2) + Math.pow((y1-y2), 2))){...}\nit works. But thanks anyways!!!"
                    },
                    {
                        "username": "Kyrie63",
                        "content": "[@EricRaw](/EricRaw) Thanks Eric for your detailed explaination, I think your opinions are correct. But I still have a question that this problem seems to cast a int value to a long type, and it will not occur the decimal portion, so what is wrong with my code? When I change my code to if (Math.pow(r1,2) >= (Math.pow((x1-x2), 2) + Math.pow((y1-y2), 2))), it works magically!"
                    },
                    {
                        "username": "yakode",
                        "content": "if ((long)(r1 * r1) >= ((long)((x1-x2)*(x1-x2)) + (long)((y1-y2)*(y1-y2)))){\\n\\nI don\\'t know the reason, but after I edited this if condition in  buildGraph. it pass this testcase."
                    },
                    {
                        "username": "EricRaw",
                        "content": "```if ((long)(r1 * r1) >= ((long)(x1-x2)*(x1-x2) + (long)(y1-y2)*(y1-y2))){```\nWhen you cast a double value to a long type, it truncates the decimal portion and converts it to an integer\n\neg\nwhen you cast double value 8.9 to a long type, the decimal portion will be truncated, and the resulting long value will be 8 which can be wrong\n- 8,6 >= 8,9 (it should be false)\n- 8 >= 8 (cast to long it become true)\n\nyou can test it out with this code\n```\n        double test = 8.9;\n        double test1 = 8.5;\n        System.out.println(test <= test1);\n        System.out.println((long)test <= (long)test1);\n```"
                    },
                    {
                        "username": "RaktimBhuyan21",
                        "content": "Can anyone help with what is wrong in my code ?\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n       \\n        int n = bombs.size();\\n        vector<vector<bool>>connected(n,vector<bool>(n,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==j){\\n                    connected[i][j] = 1;\\n                }\\n                else{\\n                    long xi = bombs[i][0];\\n                    long yi = bombs[i][1];\\n                    long ri = bombs[i][2];\\n                    long xj = bombs[j][0];\\n                    long yj = bombs[j][1];\\n                    long rj = bombs[j][2];\\n                    long  dis = (xi-xj)*(xi-xj) + (yi-yj)*(yi-yj);\\n                    \\n                    if(dis<=(ri*ri)){\\n                        connected[i][j] = 1;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        int ans =0;\\n        for(int i=0;i<n;i++){\\n            int cnt =0;\\n            for(int j=0;j<n;j++){\\n                if(connected[i][j]==1){\\n                    cnt++;\\n                   ans = max(ans,cnt);\\n                }\\n            }\\n            \\n            \\n        }\\n        return ans;\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1913698,
                "content": [
                    {
                        "username": "Tusharsingh110",
                        "content": "can some edges be bidirectional?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this is directed graph.  A->B and B->A are both allowed, yes."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Solution : \\nhttps://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588123/geometry-dfs-c-with-figure/ "
                    },
                    {
                        "username": "vamsikumili",
                        "content": "How is the expected result of [[1,1,100000],[100000,100000,1]] is 1, when the first bomb can detonate 2nd one . My point of view is first bomb's x cordinate + radius of first bomb > second bombs x cordinate and first bomb's y cordinate + radius of first bomb > second bomb's y cordinate also, so second bombs both cordinates falls under first bombs impact radus,\n\nCan someone please explain why my thinking is wrong? \nThank you."
                    },
                    {
                        "username": "_SID_",
                        "content": "Check this, you can understand easily : https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588930/1-1-100000-100000-100000-1-getting-wrong-understand-why/"
                    },
                    {
                        "username": "dkochetov",
                        "content": "It can't detonate. The distance between their centers is `sqrt((100000-1)^2 + (100000-1)^2) = 141420` that is greater than `100000`. Meaning that the second bomb is not within the radius of the first one."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "A great question. <b> Unique combination of Maths and Graph. </b>Can someone help me why this code gives TLE. It works when I execute it as a testcase, but when I run, it gives me a TLE.\\n```#define ll long long\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        unordered_map<int, vector<int>> G;\\n        int n = bombs.size();\\n        // Build the graph such that make a connection if a node is connected to \\n        // another if circlei overlaps the center of circlej\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if(circleOverlap(bombs[i][0], bombs[i][1], bombs[i][2], bombs[j][0], bombs[j][1])){\\n                    G[i].push_back(j);\\n                }\\n            }\\n        }\\n        // Use the vis for checking if a bomb has already been diffused\\n        int maimumDetonated = 0;\\n        for(int i = 0; i < n; i++){\\n            maimumDetonated = max(maimumDetonated, bfs(G, i));\\n        }\\n        return maimumDetonated;\\n    }\\nprivate:\\n    bool circleOverlap(ll x, ll y, ll r, ll x1, ll y1){\\n        return pow((x1 - x), 2) + pow((y1 - y), 2) - r*r <= 0;\\n    }\\n    int bfs(unordered_map<int, vector<int>> &G, int idx){\\n        queue<int> Q; Q.push(idx);\\n        unordered_set<int> vis; vis.insert(idx);\\n        int cnt = 0;\\n        while(!Q.empty()){\\n            int curr = Q.front(); Q.pop();\\n            vis.insert(curr);\\n            cnt++;\\n            for(int x: G[curr]){\\n                if(vis.find(x) == vis.end()){\\n                    Q.push(x);\\n                }\\n            }\\n        }\\n        return vis.size();\\n    }\\n};```"
                    },
                    {
                        "username": "sameertri039",
                        "content": "Nice problem!"
                    },
                    {
                        "username": "vnk01",
                        "content": "nice question! I got fooled into thinking I need to group every nodes that have radius reaching each other into the same group and overcount it in my first attempt"
                    },
                    {
                        "username": "ayush81029",
                        "content": "[[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]\\nWhy this testcase giving expected output 1 when it should be 2?\\n[69,51,7] and [65,59,3] are intersecting."
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the distance between [69,51,7] and [65,59,3] is 8.9 which make it not enough range to explode both of it"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Can anyone help, when I submit the code, it gives TLA. But, when I run the same testcase, it passes.\\nThere is a notification that it is due to global or static variables. But, I didn\\'t use global/static declarations in the first place.\\n"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Just one test case running for 500ms will be accepted. But after submitting, you will have to pass all ~100 test cases and the sum of their runtime must be less than ~5sec. So you need to reduce the complexity of your code."
                    },
                    {
                        "username": "Kyrie63",
                        "content": " `class Solution {\\n\\n    // Can someone tell me why I got wrong in this testcase?\\n    // [[37207,2653,5261],[40784,59523,20635],[16390,1426,39102],[42236,12,96855],[72839,62027,61667],[60691,58191,48447],[42932,46579,41248],[35868,43119,6870],[41693,98905,17374],[43441,1266,41621]]\\n    // Expected 10. but outcome is 5...\\n\\n    int count;\\n    public int maximumDetonation(int[][] bombs) {\\n        int n = bombs.length;\\n        List<Integer>[] bombGraph = buildGraph(n, bombs);\\n\\n        this.count = 0;\\n        int res = 0;\\n\\n        for (int i = 0; i < n; i++){\\n            boolean[] visited = new boolean[n];\\n            count = 0;\\n            dfs(bombGraph, i, visited);\\n            res = Math.max(res, count);\\n        }\\n        return res;\\n    }\\n\\n    public void dfs(List<Integer>[] graph, int cur, boolean[] visited){\\n        // base-case \\n        if (visited[cur]){\\n            return;\\n        }\\n\\n        visited[cur] = true;\\n        count++;\\n        for (int neigh : graph[cur]){\\n            dfs(graph, neigh, visited);\\n        }\\n    }\\n\\n    public List<Integer>[] buildGraph(int n, int[][] bombs){\\n        List<Integer>[] bombGraph = new LinkedList[n];\\n\\n        for (int i = 0; i < n; i++){\\n            bombGraph[i] = new LinkedList<>();\\n        }\\n\\n        for (int i = 0; i < n; i++){\\n            for (int j = 0; j < n; j++){\\n                if (i == j) continue;\\n                int x1 = bombs[i][0];\\n                int y1 = bombs[i][1];\\n                int r1 = bombs[i][2];\\n                int x2 = bombs[j][0];\\n                int y2 = bombs[j][1];\\n                // int r2 = bomb[j][2];\\n                // long dist = (long)(x1-x2)*(x1-x2) + (long)(y1-y2)*(y1-y2);\\n                // long boomDist = (long)(r1*r1);\\n\\n                // create a path if possible\\n                // if ((long)(r1 + r2) >= (long)(x1-x2)*(x1-x2) + (long)(y1-y2)*(y1-y2)){\\n                if ((long)(r1 * r1) >= ((long)(x1-x2)*(x1-x2) + (long)(y1-y2)*(y1-y2))){\\n                    bombGraph[i].add(j);\\n                }\\n            }\\n        }\\n\\n        return bombGraph;\\n    }\\n\\n}\\n`\\nCan someone tell me why I got wrong in this testcase?\\n [[37207,2653,5261],[40784,59523,20635],[16390,1426,39102],[42236,12,96855],[72839,62027,61667],[60691,58191,48447],[42932,46579,41248],[35868,43119,6870],[41693,98905,17374],[43441,1266,41621]]\\n The expected answer is 10. but my outcome is 5...\\nThanks!"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@EricRaw](/EricRaw) The problem is that the bombs array are all ints. You need to cast them into longs before doing your distance calculations."
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Kyrie63](/Kyrie63) [@psionl0](/psionl0) i check it again and i am wrong, the problem arise because of integer overflow.\nthe r1, r2, x1, x2, y1, y2 should be long"
                    },
                    {
                        "username": "psionl0",
                        "content": "The thing I don\\'t like about Math.pow() is that it returns a double which is less accurate than int or long. I suspect that the reason why the earlier code didn\\'t work was because the products overflowed before you could cast the result into a long integer. Try this:\\n```\\nif (long) r1 * (long) r1 >= (long) (x1-x2) * (long) (x1 - x2) + (long)(y1 - y2) * (long) (y1 - y2) {\\n```"
                    },
                    {
                        "username": "Kyrie63",
                        "content": "[@yakode](/yakode) I think Eric got the explanation, and when I changed my condition as: \n if (Math.pow(r1,2) >= (Math.pow((x1-x2), 2) + Math.pow((y1-y2), 2))){...}\nit works. But thanks anyways!!!"
                    },
                    {
                        "username": "Kyrie63",
                        "content": "[@EricRaw](/EricRaw) Thanks Eric for your detailed explaination, I think your opinions are correct. But I still have a question that this problem seems to cast a int value to a long type, and it will not occur the decimal portion, so what is wrong with my code? When I change my code to if (Math.pow(r1,2) >= (Math.pow((x1-x2), 2) + Math.pow((y1-y2), 2))), it works magically!"
                    },
                    {
                        "username": "yakode",
                        "content": "if ((long)(r1 * r1) >= ((long)((x1-x2)*(x1-x2)) + (long)((y1-y2)*(y1-y2)))){\\n\\nI don\\'t know the reason, but after I edited this if condition in  buildGraph. it pass this testcase."
                    },
                    {
                        "username": "EricRaw",
                        "content": "```if ((long)(r1 * r1) >= ((long)(x1-x2)*(x1-x2) + (long)(y1-y2)*(y1-y2))){```\nWhen you cast a double value to a long type, it truncates the decimal portion and converts it to an integer\n\neg\nwhen you cast double value 8.9 to a long type, the decimal portion will be truncated, and the resulting long value will be 8 which can be wrong\n- 8,6 >= 8,9 (it should be false)\n- 8 >= 8 (cast to long it become true)\n\nyou can test it out with this code\n```\n        double test = 8.9;\n        double test1 = 8.5;\n        System.out.println(test <= test1);\n        System.out.println((long)test <= (long)test1);\n```"
                    },
                    {
                        "username": "RaktimBhuyan21",
                        "content": "Can anyone help with what is wrong in my code ?\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n       \\n        int n = bombs.size();\\n        vector<vector<bool>>connected(n,vector<bool>(n,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==j){\\n                    connected[i][j] = 1;\\n                }\\n                else{\\n                    long xi = bombs[i][0];\\n                    long yi = bombs[i][1];\\n                    long ri = bombs[i][2];\\n                    long xj = bombs[j][0];\\n                    long yj = bombs[j][1];\\n                    long rj = bombs[j][2];\\n                    long  dis = (xi-xj)*(xi-xj) + (yi-yj)*(yi-yj);\\n                    \\n                    if(dis<=(ri*ri)){\\n                        connected[i][j] = 1;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        int ans =0;\\n        for(int i=0;i<n;i++){\\n            int cnt =0;\\n            for(int j=0;j<n;j++){\\n                if(connected[i][j]==1){\\n                    cnt++;\\n                   ans = max(ans,cnt);\\n                }\\n            }\\n            \\n            \\n        }\\n        return ans;\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1913681,
                "content": [
                    {
                        "username": "Tusharsingh110",
                        "content": "can some edges be bidirectional?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "this is directed graph.  A->B and B->A are both allowed, yes."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "Solution : \\nhttps://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588123/geometry-dfs-c-with-figure/ "
                    },
                    {
                        "username": "vamsikumili",
                        "content": "How is the expected result of [[1,1,100000],[100000,100000,1]] is 1, when the first bomb can detonate 2nd one . My point of view is first bomb's x cordinate + radius of first bomb > second bombs x cordinate and first bomb's y cordinate + radius of first bomb > second bomb's y cordinate also, so second bombs both cordinates falls under first bombs impact radus,\n\nCan someone please explain why my thinking is wrong? \nThank you."
                    },
                    {
                        "username": "_SID_",
                        "content": "Check this, you can understand easily : https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3588930/1-1-100000-100000-100000-1-getting-wrong-understand-why/"
                    },
                    {
                        "username": "dkochetov",
                        "content": "It can't detonate. The distance between their centers is `sqrt((100000-1)^2 + (100000-1)^2) = 141420` that is greater than `100000`. Meaning that the second bomb is not within the radius of the first one."
                    },
                    {
                        "username": "the_kalakar",
                        "content": "A great question. <b> Unique combination of Maths and Graph. </b>Can someone help me why this code gives TLE. It works when I execute it as a testcase, but when I run, it gives me a TLE.\\n```#define ll long long\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n        unordered_map<int, vector<int>> G;\\n        int n = bombs.size();\\n        // Build the graph such that make a connection if a node is connected to \\n        // another if circlei overlaps the center of circlej\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if(circleOverlap(bombs[i][0], bombs[i][1], bombs[i][2], bombs[j][0], bombs[j][1])){\\n                    G[i].push_back(j);\\n                }\\n            }\\n        }\\n        // Use the vis for checking if a bomb has already been diffused\\n        int maimumDetonated = 0;\\n        for(int i = 0; i < n; i++){\\n            maimumDetonated = max(maimumDetonated, bfs(G, i));\\n        }\\n        return maimumDetonated;\\n    }\\nprivate:\\n    bool circleOverlap(ll x, ll y, ll r, ll x1, ll y1){\\n        return pow((x1 - x), 2) + pow((y1 - y), 2) - r*r <= 0;\\n    }\\n    int bfs(unordered_map<int, vector<int>> &G, int idx){\\n        queue<int> Q; Q.push(idx);\\n        unordered_set<int> vis; vis.insert(idx);\\n        int cnt = 0;\\n        while(!Q.empty()){\\n            int curr = Q.front(); Q.pop();\\n            vis.insert(curr);\\n            cnt++;\\n            for(int x: G[curr]){\\n                if(vis.find(x) == vis.end()){\\n                    Q.push(x);\\n                }\\n            }\\n        }\\n        return vis.size();\\n    }\\n};```"
                    },
                    {
                        "username": "sameertri039",
                        "content": "Nice problem!"
                    },
                    {
                        "username": "vnk01",
                        "content": "nice question! I got fooled into thinking I need to group every nodes that have radius reaching each other into the same group and overcount it in my first attempt"
                    },
                    {
                        "username": "ayush81029",
                        "content": "[[54,95,4],[99,46,3],[29,21,3],[96,72,8],[49,43,3],[11,20,3],[2,57,1],[69,51,7],[97,1,10],[85,45,2],[38,47,1],[83,75,3],[65,59,3],[33,4,1],[32,10,2],[20,97,8],[35,37,3]]\\nWhy this testcase giving expected output 1 when it should be 2?\\n[69,51,7] and [65,59,3] are intersecting."
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the distance between [69,51,7] and [65,59,3] is 8.9 which make it not enough range to explode both of it"
                    },
                    {
                        "username": "coder_pawn",
                        "content": "Can anyone help, when I submit the code, it gives TLA. But, when I run the same testcase, it passes.\\nThere is a notification that it is due to global or static variables. But, I didn\\'t use global/static declarations in the first place.\\n"
                    },
                    {
                        "username": "dkochetov",
                        "content": "Just one test case running for 500ms will be accepted. But after submitting, you will have to pass all ~100 test cases and the sum of their runtime must be less than ~5sec. So you need to reduce the complexity of your code."
                    },
                    {
                        "username": "Kyrie63",
                        "content": " `class Solution {\\n\\n    // Can someone tell me why I got wrong in this testcase?\\n    // [[37207,2653,5261],[40784,59523,20635],[16390,1426,39102],[42236,12,96855],[72839,62027,61667],[60691,58191,48447],[42932,46579,41248],[35868,43119,6870],[41693,98905,17374],[43441,1266,41621]]\\n    // Expected 10. but outcome is 5...\\n\\n    int count;\\n    public int maximumDetonation(int[][] bombs) {\\n        int n = bombs.length;\\n        List<Integer>[] bombGraph = buildGraph(n, bombs);\\n\\n        this.count = 0;\\n        int res = 0;\\n\\n        for (int i = 0; i < n; i++){\\n            boolean[] visited = new boolean[n];\\n            count = 0;\\n            dfs(bombGraph, i, visited);\\n            res = Math.max(res, count);\\n        }\\n        return res;\\n    }\\n\\n    public void dfs(List<Integer>[] graph, int cur, boolean[] visited){\\n        // base-case \\n        if (visited[cur]){\\n            return;\\n        }\\n\\n        visited[cur] = true;\\n        count++;\\n        for (int neigh : graph[cur]){\\n            dfs(graph, neigh, visited);\\n        }\\n    }\\n\\n    public List<Integer>[] buildGraph(int n, int[][] bombs){\\n        List<Integer>[] bombGraph = new LinkedList[n];\\n\\n        for (int i = 0; i < n; i++){\\n            bombGraph[i] = new LinkedList<>();\\n        }\\n\\n        for (int i = 0; i < n; i++){\\n            for (int j = 0; j < n; j++){\\n                if (i == j) continue;\\n                int x1 = bombs[i][0];\\n                int y1 = bombs[i][1];\\n                int r1 = bombs[i][2];\\n                int x2 = bombs[j][0];\\n                int y2 = bombs[j][1];\\n                // int r2 = bomb[j][2];\\n                // long dist = (long)(x1-x2)*(x1-x2) + (long)(y1-y2)*(y1-y2);\\n                // long boomDist = (long)(r1*r1);\\n\\n                // create a path if possible\\n                // if ((long)(r1 + r2) >= (long)(x1-x2)*(x1-x2) + (long)(y1-y2)*(y1-y2)){\\n                if ((long)(r1 * r1) >= ((long)(x1-x2)*(x1-x2) + (long)(y1-y2)*(y1-y2))){\\n                    bombGraph[i].add(j);\\n                }\\n            }\\n        }\\n\\n        return bombGraph;\\n    }\\n\\n}\\n`\\nCan someone tell me why I got wrong in this testcase?\\n [[37207,2653,5261],[40784,59523,20635],[16390,1426,39102],[42236,12,96855],[72839,62027,61667],[60691,58191,48447],[42932,46579,41248],[35868,43119,6870],[41693,98905,17374],[43441,1266,41621]]\\n The expected answer is 10. but my outcome is 5...\\nThanks!"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@EricRaw](/EricRaw) The problem is that the bombs array are all ints. You need to cast them into longs before doing your distance calculations."
                    },
                    {
                        "username": "EricRaw",
                        "content": "[@Kyrie63](/Kyrie63) [@psionl0](/psionl0) i check it again and i am wrong, the problem arise because of integer overflow.\nthe r1, r2, x1, x2, y1, y2 should be long"
                    },
                    {
                        "username": "psionl0",
                        "content": "The thing I don\\'t like about Math.pow() is that it returns a double which is less accurate than int or long. I suspect that the reason why the earlier code didn\\'t work was because the products overflowed before you could cast the result into a long integer. Try this:\\n```\\nif (long) r1 * (long) r1 >= (long) (x1-x2) * (long) (x1 - x2) + (long)(y1 - y2) * (long) (y1 - y2) {\\n```"
                    },
                    {
                        "username": "Kyrie63",
                        "content": "[@yakode](/yakode) I think Eric got the explanation, and when I changed my condition as: \n if (Math.pow(r1,2) >= (Math.pow((x1-x2), 2) + Math.pow((y1-y2), 2))){...}\nit works. But thanks anyways!!!"
                    },
                    {
                        "username": "Kyrie63",
                        "content": "[@EricRaw](/EricRaw) Thanks Eric for your detailed explaination, I think your opinions are correct. But I still have a question that this problem seems to cast a int value to a long type, and it will not occur the decimal portion, so what is wrong with my code? When I change my code to if (Math.pow(r1,2) >= (Math.pow((x1-x2), 2) + Math.pow((y1-y2), 2))), it works magically!"
                    },
                    {
                        "username": "yakode",
                        "content": "if ((long)(r1 * r1) >= ((long)((x1-x2)*(x1-x2)) + (long)((y1-y2)*(y1-y2)))){\\n\\nI don\\'t know the reason, but after I edited this if condition in  buildGraph. it pass this testcase."
                    },
                    {
                        "username": "EricRaw",
                        "content": "```if ((long)(r1 * r1) >= ((long)(x1-x2)*(x1-x2) + (long)(y1-y2)*(y1-y2))){```\nWhen you cast a double value to a long type, it truncates the decimal portion and converts it to an integer\n\neg\nwhen you cast double value 8.9 to a long type, the decimal portion will be truncated, and the resulting long value will be 8 which can be wrong\n- 8,6 >= 8,9 (it should be false)\n- 8 >= 8 (cast to long it become true)\n\nyou can test it out with this code\n```\n        double test = 8.9;\n        double test1 = 8.5;\n        System.out.println(test <= test1);\n        System.out.println((long)test <= (long)test1);\n```"
                    },
                    {
                        "username": "RaktimBhuyan21",
                        "content": "Can anyone help with what is wrong in my code ?\\nclass Solution {\\npublic:\\n    int maximumDetonation(vector<vector<int>>& bombs) {\\n       \\n        int n = bombs.size();\\n        vector<vector<bool>>connected(n,vector<bool>(n,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==j){\\n                    connected[i][j] = 1;\\n                }\\n                else{\\n                    long xi = bombs[i][0];\\n                    long yi = bombs[i][1];\\n                    long ri = bombs[i][2];\\n                    long xj = bombs[j][0];\\n                    long yj = bombs[j][1];\\n                    long rj = bombs[j][2];\\n                    long  dis = (xi-xj)*(xi-xj) + (yi-yj)*(yi-yj);\\n                    \\n                    if(dis<=(ri*ri)){\\n                        connected[i][j] = 1;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        int ans =0;\\n        for(int i=0;i<n;i++){\\n            int cnt =0;\\n            for(int j=0;j<n;j++){\\n                if(connected[i][j]==1){\\n                    cnt++;\\n                   ans = max(ans,cnt);\\n                }\\n            }\\n            \\n            \\n        }\\n        return ans;\\n\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1913679,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "input set is small, can brute force it.  also watch out for overflow"
                    },
                    {
                        "username": "psionl0",
                        "content": "A nice, straightforward exercise in using adjacency lists.\\n\\nTIP: If you calculate distanceSquared and radiusSquared then you can store the results in a long integer which is more accurate than using a double float."
                    },
                    {
                        "username": "daring-calf",
                        "content": "DFS! YES!"
                    },
                    {
                        "username": "quaos",
                        "content": "1. Create the directed graph of which bombs can be reached from a specified bomb.\\n2. Perform DFS on the graph to count total detonated from a start bomb, and find maximum value."
                    },
                    {
                        "username": "sushi27",
                        "content": "How to check if a point lies in circle? \nUse Euclidean distance to find the distance between two point(center point and other point) and check if distance is less than or equal to our center point radius.\nHere is my approach: https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3587764/java-easy-explained-solution/"
                    },
                    {
                        "username": "sushi27",
                        "content": "[@psionl0](/psionl0) Yes that is will be accurate"
                    },
                    {
                        "username": "psionl0",
                        "content": "Better to use distance^2. You can cast the result into a long integer which is more accurate than floating numbers (less time consuming too)."
                    },
                    {
                        "username": "sushi27",
                        "content": "[@ShashankBhat](/ShashankBhat) I added the approach. You can check it out \\uD83D\\uDC4D"
                    },
                    {
                        "username": "ShashankBhat",
                        "content": "I calculated euclidean distance and checked against each radius"
                    },
                    {
                        "username": "ShashankBhat",
                        "content": "Can anyone please let me know where I\\'m going wrong\\nMy code passes only 133 TCs.\\n\\n `\\nclass Solution {\\n    public int maximumDetonation(int[][] bombs) {\\n        Map<Integer, Set<Integer>> hm = new HashMap<>();\\n\\n        int[][] count = new int[bombs.length][2];\\n        for(int i=0; i<bombs.length; i++) {\\n            count[i][0] = i;\\n        }\\n        \\n        for(int i=0; i<bombs.length; i++) {\\n            for(int j=i+1; j<bombs.length; j++) {\\n                int dist = getDistance(bombs[i], bombs[j]);\\n                if(dist <= bombs[i][2]) {\\n                    Set<Integer> arr = hm.getOrDefault(i, new HashSet<>());\\n                    arr.add(j);\\n                    hm.put(i, arr);\\n                    count[i][1]++;\\n                }\\n\\n                if(dist <= bombs[j][2]) {\\n                    Set<Integer> arr = hm.getOrDefault(j, new HashSet<>());\\n                    arr.add(i);\\n                    hm.put(j, arr);\\n                    count[j][1]++;\\n                }\\n            }\\n        }\\n\\n        Arrays.sort(count, (int[] a, int[] b) -> b[1] - a[1]);\\n        int[] visited = new int[bombs.length];\\n        int maxCount = 0;\\n\\n        for(int i=0; i<count.length; i++) {\\n            int currCount = 0;\\n            if(visited[i] == 0) {\\n                Queue<Integer> queue = new LinkedList<>();\\n                queue.add(count[i][0]);\\n                visited[count[i][0]] = 1;\\n                currCount++;\\n                while(!queue.isEmpty()) {\\n                    int size = queue.size();\\n                    while(size-- > 0) {\\n                        int index = queue.poll();\\n                        Set<Integer> arr = hm.getOrDefault(index, new HashSet<>());\\n                        for(int idx : arr) {\\n                            if(visited[idx] == 0) {\\n                                queue.add(idx);\\n                                visited[idx] = 1;\\n                                currCount++;\\n                                // System.out.println(\"currCount: \" + currCount);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            maxCount = Math.max(maxCount, currCount);\\n        }\\n        return maxCount;\\n    }\\n\\n    public int getDistance(int[] a, int[] b) {\\n        long x = (long) Math.pow((double) Math.abs(a[0] - b[0]), 2);\\n        long y = (long) Math.pow((double) Math.abs(a[1] - b[1]), 2);\\n\\n        return (int) Math.sqrt(x + y);\\n    }\\n}\\n`\\n\\nSample Tc not passed:\\n[[855,82,158],[17,719,430],[90,756,164],[376,17,340],[691,636,152],[565,776,5],[464,154,271],[53,361,162],[278,609,82],[202,927,219],[542,865,377],[330,402,270],[720,199,10],[986,697,443],[471,296,69],[393,81,404],[127,405,177]]"
                    },
                    {
                        "username": "ShashankBhat",
                        "content": "[@kiryu_0](/kiryu_0) \\n1. Understood\\n2. What I had thought initially, was do a BFS, and have count array which stores which node has the highest num of neighbours and then do BFS from highest to least. So while traversing, we\\'ll have all the possible next-nodes in the queue after visiting a node once."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Few things seems wrong to me in your code. \n1.) converting the sqrt to int may result in some wrong assumptions in regards to the distance.\n2.) I am not sure what is the point of the count[][] array, you just need to pass the index to the queue.\n3.) after you've visited an index, you don't visit it again.\nI tried to make some changes, see if this makes sense:\n\n```\nclass Solution {\npublic int maximumDetonation(int[][] bombs) {\nMap<Integer, Set> hm = new HashMap<>();\n\n    int[][] count = new int[bombs.length][2];\n    for(int i=0; i<bombs.length; i++) {\n        count[i][0] = i;\n    }\n    \n    for(int i=0; i<bombs.length; i++) {\n        for(int j=i+1; j<bombs.length; j++) {\n            double dist = getDistance(bombs[i], bombs[j]);\n            if(dist <= bombs[i][2]*1.0) {\n                Set<Integer> arr = hm.getOrDefault(i, new HashSet<>());\n                arr.add(j);\n                hm.put(i, arr);\n                count[i][1]++;\n            }\n\n            if(dist <= bombs[j][2]*1.0) {\n                Set<Integer> arr = hm.getOrDefault(j, new HashSet<>());\n                arr.add(i);\n                hm.put(j, arr);\n                count[j][1]++;\n            }\n        }\n    }\n\n   // Arrays.sort(count, (int[] a, int[] b) -> b[1] - a[1]);\n    int[] visited = new int[bombs.length];\n    int maxCount = 0;\n\n    for(int i=0; i<count.length; i++) {\n        int currCount = 0;\n        if(visited[i] == 0) {\n            Queue<Integer> queue = new LinkedList<>();\n            queue.add(i);\n            //visited[count[i][0]] = 1;\n            //currCount++;\n            while(!queue.isEmpty()) {\n                int size = queue.size();\n                while(size-- > 0) {\n                    int index = queue.poll();\n                    if(visited[index] == 1) continue;\n                    \n                    currCount++;\n                    \n                    visited[index] = 1;\n                    Set<Integer> arr = hm.getOrDefault(index, new HashSet<>());\n                    for(int idx : arr) {\n                            queue.add(idx);\n                            // System.out.println(\"currCount: \" + currCount);\n                    }\n                }\n            }\n        }\n        visited = new int[bombs.length];\n        maxCount = Math.max(maxCount, currCount);\n    }\n    return maxCount;\n}\n\npublic double getDistance(int[] a, int[] b) {\n    long x = (long) Math.pow((double) Math.abs(a[0] - b[0]), 2);\n    long y = (long) Math.pow((double) Math.abs(a[1] - b[1]), 2);\n\n    return Math.sqrt(x + y);\n}\n}\n```"
                    },
                    {
                        "username": "xxossoo96",
                        "content": "be careful of the range of distance between two bombs"
                    },
                    {
                        "username": "user8228j",
                        "content": "see bombs.length is at most 100, know that brute force solution will likely work"
                    },
                    {
                        "username": "KevinLe563",
                        "content": "Can someone explain whats wrong with the code? I get a time limit exceeded despite passing 160/160 test cases\n\n ```\nclass Solution(object):\n    def maximumDetonation(self, bombs):\n        \"\"\"\n        :type bombs: List[List[int]]\n        :rtype: int\n        \"\"\"\n        # point is inside the circle if distance_from_center^2 < r^2 of circle where distance_from_cente^2 = p1x-x1 squared + p1y -y1 squared\n        # map each bomb to a set of bombs that it sets off so we can reuse it\n        if not bombs:\n            return 0\n        neighbors = {}\n        for i in range(0, len(bombs)):\n            neighbors[i] = []\n            for j in range(0, len(bombs)):\n                if i == j:\n                    continue\n                x, y, d = bombs[j]\n                if self.isInRange(bombs[i], [x, y]):\n                    temp = neighbors[i]\n                    temp.append(j)\n                    neighbors[i] = temp\n        \n        # print(neighbors)\n\n        # bfs on every bomb\n        max_det = 0\n        for i in range(0, len(bombs)):\n            detonated = set()\n            toVisit = collections.deque()\n            toVisit.append(i)\n            while len(toVisit) > 0:\n                bomb = toVisit.popleft()\n                detonated.add(bomb)\n                for n in neighbors[bomb]:\n                    if n not in detonated:\n                        toVisit.append(n)\n\n            max_det = max(max_det, len(detonated))\n\n        return max_det\n\n    \n    def isInRange(self, bomb, point):\n        bx, by, r = bomb\n        px, py = point\n        return ((bx-px)**2 + (by-py)**2) <= r**2\n\n```\n"
                    },
                    {
                        "username": "juraj24",
                        "content": "Hint: use Pythagorean theorem to find out if bomb A can detonate bomb B."
                    }
                ]
            },
            {
                "id": 1913673,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "input set is small, can brute force it.  also watch out for overflow"
                    },
                    {
                        "username": "psionl0",
                        "content": "A nice, straightforward exercise in using adjacency lists.\\n\\nTIP: If you calculate distanceSquared and radiusSquared then you can store the results in a long integer which is more accurate than using a double float."
                    },
                    {
                        "username": "daring-calf",
                        "content": "DFS! YES!"
                    },
                    {
                        "username": "quaos",
                        "content": "1. Create the directed graph of which bombs can be reached from a specified bomb.\\n2. Perform DFS on the graph to count total detonated from a start bomb, and find maximum value."
                    },
                    {
                        "username": "sushi27",
                        "content": "How to check if a point lies in circle? \nUse Euclidean distance to find the distance between two point(center point and other point) and check if distance is less than or equal to our center point radius.\nHere is my approach: https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3587764/java-easy-explained-solution/"
                    },
                    {
                        "username": "sushi27",
                        "content": "[@psionl0](/psionl0) Yes that is will be accurate"
                    },
                    {
                        "username": "psionl0",
                        "content": "Better to use distance^2. You can cast the result into a long integer which is more accurate than floating numbers (less time consuming too)."
                    },
                    {
                        "username": "sushi27",
                        "content": "[@ShashankBhat](/ShashankBhat) I added the approach. You can check it out \\uD83D\\uDC4D"
                    },
                    {
                        "username": "ShashankBhat",
                        "content": "I calculated euclidean distance and checked against each radius"
                    },
                    {
                        "username": "ShashankBhat",
                        "content": "Can anyone please let me know where I\\'m going wrong\\nMy code passes only 133 TCs.\\n\\n `\\nclass Solution {\\n    public int maximumDetonation(int[][] bombs) {\\n        Map<Integer, Set<Integer>> hm = new HashMap<>();\\n\\n        int[][] count = new int[bombs.length][2];\\n        for(int i=0; i<bombs.length; i++) {\\n            count[i][0] = i;\\n        }\\n        \\n        for(int i=0; i<bombs.length; i++) {\\n            for(int j=i+1; j<bombs.length; j++) {\\n                int dist = getDistance(bombs[i], bombs[j]);\\n                if(dist <= bombs[i][2]) {\\n                    Set<Integer> arr = hm.getOrDefault(i, new HashSet<>());\\n                    arr.add(j);\\n                    hm.put(i, arr);\\n                    count[i][1]++;\\n                }\\n\\n                if(dist <= bombs[j][2]) {\\n                    Set<Integer> arr = hm.getOrDefault(j, new HashSet<>());\\n                    arr.add(i);\\n                    hm.put(j, arr);\\n                    count[j][1]++;\\n                }\\n            }\\n        }\\n\\n        Arrays.sort(count, (int[] a, int[] b) -> b[1] - a[1]);\\n        int[] visited = new int[bombs.length];\\n        int maxCount = 0;\\n\\n        for(int i=0; i<count.length; i++) {\\n            int currCount = 0;\\n            if(visited[i] == 0) {\\n                Queue<Integer> queue = new LinkedList<>();\\n                queue.add(count[i][0]);\\n                visited[count[i][0]] = 1;\\n                currCount++;\\n                while(!queue.isEmpty()) {\\n                    int size = queue.size();\\n                    while(size-- > 0) {\\n                        int index = queue.poll();\\n                        Set<Integer> arr = hm.getOrDefault(index, new HashSet<>());\\n                        for(int idx : arr) {\\n                            if(visited[idx] == 0) {\\n                                queue.add(idx);\\n                                visited[idx] = 1;\\n                                currCount++;\\n                                // System.out.println(\"currCount: \" + currCount);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            maxCount = Math.max(maxCount, currCount);\\n        }\\n        return maxCount;\\n    }\\n\\n    public int getDistance(int[] a, int[] b) {\\n        long x = (long) Math.pow((double) Math.abs(a[0] - b[0]), 2);\\n        long y = (long) Math.pow((double) Math.abs(a[1] - b[1]), 2);\\n\\n        return (int) Math.sqrt(x + y);\\n    }\\n}\\n`\\n\\nSample Tc not passed:\\n[[855,82,158],[17,719,430],[90,756,164],[376,17,340],[691,636,152],[565,776,5],[464,154,271],[53,361,162],[278,609,82],[202,927,219],[542,865,377],[330,402,270],[720,199,10],[986,697,443],[471,296,69],[393,81,404],[127,405,177]]"
                    },
                    {
                        "username": "ShashankBhat",
                        "content": "[@kiryu_0](/kiryu_0) \\n1. Understood\\n2. What I had thought initially, was do a BFS, and have count array which stores which node has the highest num of neighbours and then do BFS from highest to least. So while traversing, we\\'ll have all the possible next-nodes in the queue after visiting a node once."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Few things seems wrong to me in your code. \n1.) converting the sqrt to int may result in some wrong assumptions in regards to the distance.\n2.) I am not sure what is the point of the count[][] array, you just need to pass the index to the queue.\n3.) after you've visited an index, you don't visit it again.\nI tried to make some changes, see if this makes sense:\n\n```\nclass Solution {\npublic int maximumDetonation(int[][] bombs) {\nMap<Integer, Set> hm = new HashMap<>();\n\n    int[][] count = new int[bombs.length][2];\n    for(int i=0; i<bombs.length; i++) {\n        count[i][0] = i;\n    }\n    \n    for(int i=0; i<bombs.length; i++) {\n        for(int j=i+1; j<bombs.length; j++) {\n            double dist = getDistance(bombs[i], bombs[j]);\n            if(dist <= bombs[i][2]*1.0) {\n                Set<Integer> arr = hm.getOrDefault(i, new HashSet<>());\n                arr.add(j);\n                hm.put(i, arr);\n                count[i][1]++;\n            }\n\n            if(dist <= bombs[j][2]*1.0) {\n                Set<Integer> arr = hm.getOrDefault(j, new HashSet<>());\n                arr.add(i);\n                hm.put(j, arr);\n                count[j][1]++;\n            }\n        }\n    }\n\n   // Arrays.sort(count, (int[] a, int[] b) -> b[1] - a[1]);\n    int[] visited = new int[bombs.length];\n    int maxCount = 0;\n\n    for(int i=0; i<count.length; i++) {\n        int currCount = 0;\n        if(visited[i] == 0) {\n            Queue<Integer> queue = new LinkedList<>();\n            queue.add(i);\n            //visited[count[i][0]] = 1;\n            //currCount++;\n            while(!queue.isEmpty()) {\n                int size = queue.size();\n                while(size-- > 0) {\n                    int index = queue.poll();\n                    if(visited[index] == 1) continue;\n                    \n                    currCount++;\n                    \n                    visited[index] = 1;\n                    Set<Integer> arr = hm.getOrDefault(index, new HashSet<>());\n                    for(int idx : arr) {\n                            queue.add(idx);\n                            // System.out.println(\"currCount: \" + currCount);\n                    }\n                }\n            }\n        }\n        visited = new int[bombs.length];\n        maxCount = Math.max(maxCount, currCount);\n    }\n    return maxCount;\n}\n\npublic double getDistance(int[] a, int[] b) {\n    long x = (long) Math.pow((double) Math.abs(a[0] - b[0]), 2);\n    long y = (long) Math.pow((double) Math.abs(a[1] - b[1]), 2);\n\n    return Math.sqrt(x + y);\n}\n}\n```"
                    },
                    {
                        "username": "xxossoo96",
                        "content": "be careful of the range of distance between two bombs"
                    },
                    {
                        "username": "user8228j",
                        "content": "see bombs.length is at most 100, know that brute force solution will likely work"
                    },
                    {
                        "username": "KevinLe563",
                        "content": "Can someone explain whats wrong with the code? I get a time limit exceeded despite passing 160/160 test cases\n\n ```\nclass Solution(object):\n    def maximumDetonation(self, bombs):\n        \"\"\"\n        :type bombs: List[List[int]]\n        :rtype: int\n        \"\"\"\n        # point is inside the circle if distance_from_center^2 < r^2 of circle where distance_from_cente^2 = p1x-x1 squared + p1y -y1 squared\n        # map each bomb to a set of bombs that it sets off so we can reuse it\n        if not bombs:\n            return 0\n        neighbors = {}\n        for i in range(0, len(bombs)):\n            neighbors[i] = []\n            for j in range(0, len(bombs)):\n                if i == j:\n                    continue\n                x, y, d = bombs[j]\n                if self.isInRange(bombs[i], [x, y]):\n                    temp = neighbors[i]\n                    temp.append(j)\n                    neighbors[i] = temp\n        \n        # print(neighbors)\n\n        # bfs on every bomb\n        max_det = 0\n        for i in range(0, len(bombs)):\n            detonated = set()\n            toVisit = collections.deque()\n            toVisit.append(i)\n            while len(toVisit) > 0:\n                bomb = toVisit.popleft()\n                detonated.add(bomb)\n                for n in neighbors[bomb]:\n                    if n not in detonated:\n                        toVisit.append(n)\n\n            max_det = max(max_det, len(detonated))\n\n        return max_det\n\n    \n    def isInRange(self, bomb, point):\n        bx, by, r = bomb\n        px, py = point\n        return ((bx-px)**2 + (by-py)**2) <= r**2\n\n```\n"
                    },
                    {
                        "username": "juraj24",
                        "content": "Hint: use Pythagorean theorem to find out if bomb A can detonate bomb B."
                    }
                ]
            },
            {
                "id": 1913670,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "input set is small, can brute force it.  also watch out for overflow"
                    },
                    {
                        "username": "psionl0",
                        "content": "A nice, straightforward exercise in using adjacency lists.\\n\\nTIP: If you calculate distanceSquared and radiusSquared then you can store the results in a long integer which is more accurate than using a double float."
                    },
                    {
                        "username": "daring-calf",
                        "content": "DFS! YES!"
                    },
                    {
                        "username": "quaos",
                        "content": "1. Create the directed graph of which bombs can be reached from a specified bomb.\\n2. Perform DFS on the graph to count total detonated from a start bomb, and find maximum value."
                    },
                    {
                        "username": "sushi27",
                        "content": "How to check if a point lies in circle? \nUse Euclidean distance to find the distance between two point(center point and other point) and check if distance is less than or equal to our center point radius.\nHere is my approach: https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3587764/java-easy-explained-solution/"
                    },
                    {
                        "username": "sushi27",
                        "content": "[@psionl0](/psionl0) Yes that is will be accurate"
                    },
                    {
                        "username": "psionl0",
                        "content": "Better to use distance^2. You can cast the result into a long integer which is more accurate than floating numbers (less time consuming too)."
                    },
                    {
                        "username": "sushi27",
                        "content": "[@ShashankBhat](/ShashankBhat) I added the approach. You can check it out \\uD83D\\uDC4D"
                    },
                    {
                        "username": "ShashankBhat",
                        "content": "I calculated euclidean distance and checked against each radius"
                    },
                    {
                        "username": "ShashankBhat",
                        "content": "Can anyone please let me know where I\\'m going wrong\\nMy code passes only 133 TCs.\\n\\n `\\nclass Solution {\\n    public int maximumDetonation(int[][] bombs) {\\n        Map<Integer, Set<Integer>> hm = new HashMap<>();\\n\\n        int[][] count = new int[bombs.length][2];\\n        for(int i=0; i<bombs.length; i++) {\\n            count[i][0] = i;\\n        }\\n        \\n        for(int i=0; i<bombs.length; i++) {\\n            for(int j=i+1; j<bombs.length; j++) {\\n                int dist = getDistance(bombs[i], bombs[j]);\\n                if(dist <= bombs[i][2]) {\\n                    Set<Integer> arr = hm.getOrDefault(i, new HashSet<>());\\n                    arr.add(j);\\n                    hm.put(i, arr);\\n                    count[i][1]++;\\n                }\\n\\n                if(dist <= bombs[j][2]) {\\n                    Set<Integer> arr = hm.getOrDefault(j, new HashSet<>());\\n                    arr.add(i);\\n                    hm.put(j, arr);\\n                    count[j][1]++;\\n                }\\n            }\\n        }\\n\\n        Arrays.sort(count, (int[] a, int[] b) -> b[1] - a[1]);\\n        int[] visited = new int[bombs.length];\\n        int maxCount = 0;\\n\\n        for(int i=0; i<count.length; i++) {\\n            int currCount = 0;\\n            if(visited[i] == 0) {\\n                Queue<Integer> queue = new LinkedList<>();\\n                queue.add(count[i][0]);\\n                visited[count[i][0]] = 1;\\n                currCount++;\\n                while(!queue.isEmpty()) {\\n                    int size = queue.size();\\n                    while(size-- > 0) {\\n                        int index = queue.poll();\\n                        Set<Integer> arr = hm.getOrDefault(index, new HashSet<>());\\n                        for(int idx : arr) {\\n                            if(visited[idx] == 0) {\\n                                queue.add(idx);\\n                                visited[idx] = 1;\\n                                currCount++;\\n                                // System.out.println(\"currCount: \" + currCount);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            maxCount = Math.max(maxCount, currCount);\\n        }\\n        return maxCount;\\n    }\\n\\n    public int getDistance(int[] a, int[] b) {\\n        long x = (long) Math.pow((double) Math.abs(a[0] - b[0]), 2);\\n        long y = (long) Math.pow((double) Math.abs(a[1] - b[1]), 2);\\n\\n        return (int) Math.sqrt(x + y);\\n    }\\n}\\n`\\n\\nSample Tc not passed:\\n[[855,82,158],[17,719,430],[90,756,164],[376,17,340],[691,636,152],[565,776,5],[464,154,271],[53,361,162],[278,609,82],[202,927,219],[542,865,377],[330,402,270],[720,199,10],[986,697,443],[471,296,69],[393,81,404],[127,405,177]]"
                    },
                    {
                        "username": "ShashankBhat",
                        "content": "[@kiryu_0](/kiryu_0) \\n1. Understood\\n2. What I had thought initially, was do a BFS, and have count array which stores which node has the highest num of neighbours and then do BFS from highest to least. So while traversing, we\\'ll have all the possible next-nodes in the queue after visiting a node once."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Few things seems wrong to me in your code. \n1.) converting the sqrt to int may result in some wrong assumptions in regards to the distance.\n2.) I am not sure what is the point of the count[][] array, you just need to pass the index to the queue.\n3.) after you've visited an index, you don't visit it again.\nI tried to make some changes, see if this makes sense:\n\n```\nclass Solution {\npublic int maximumDetonation(int[][] bombs) {\nMap<Integer, Set> hm = new HashMap<>();\n\n    int[][] count = new int[bombs.length][2];\n    for(int i=0; i<bombs.length; i++) {\n        count[i][0] = i;\n    }\n    \n    for(int i=0; i<bombs.length; i++) {\n        for(int j=i+1; j<bombs.length; j++) {\n            double dist = getDistance(bombs[i], bombs[j]);\n            if(dist <= bombs[i][2]*1.0) {\n                Set<Integer> arr = hm.getOrDefault(i, new HashSet<>());\n                arr.add(j);\n                hm.put(i, arr);\n                count[i][1]++;\n            }\n\n            if(dist <= bombs[j][2]*1.0) {\n                Set<Integer> arr = hm.getOrDefault(j, new HashSet<>());\n                arr.add(i);\n                hm.put(j, arr);\n                count[j][1]++;\n            }\n        }\n    }\n\n   // Arrays.sort(count, (int[] a, int[] b) -> b[1] - a[1]);\n    int[] visited = new int[bombs.length];\n    int maxCount = 0;\n\n    for(int i=0; i<count.length; i++) {\n        int currCount = 0;\n        if(visited[i] == 0) {\n            Queue<Integer> queue = new LinkedList<>();\n            queue.add(i);\n            //visited[count[i][0]] = 1;\n            //currCount++;\n            while(!queue.isEmpty()) {\n                int size = queue.size();\n                while(size-- > 0) {\n                    int index = queue.poll();\n                    if(visited[index] == 1) continue;\n                    \n                    currCount++;\n                    \n                    visited[index] = 1;\n                    Set<Integer> arr = hm.getOrDefault(index, new HashSet<>());\n                    for(int idx : arr) {\n                            queue.add(idx);\n                            // System.out.println(\"currCount: \" + currCount);\n                    }\n                }\n            }\n        }\n        visited = new int[bombs.length];\n        maxCount = Math.max(maxCount, currCount);\n    }\n    return maxCount;\n}\n\npublic double getDistance(int[] a, int[] b) {\n    long x = (long) Math.pow((double) Math.abs(a[0] - b[0]), 2);\n    long y = (long) Math.pow((double) Math.abs(a[1] - b[1]), 2);\n\n    return Math.sqrt(x + y);\n}\n}\n```"
                    },
                    {
                        "username": "xxossoo96",
                        "content": "be careful of the range of distance between two bombs"
                    },
                    {
                        "username": "user8228j",
                        "content": "see bombs.length is at most 100, know that brute force solution will likely work"
                    },
                    {
                        "username": "KevinLe563",
                        "content": "Can someone explain whats wrong with the code? I get a time limit exceeded despite passing 160/160 test cases\n\n ```\nclass Solution(object):\n    def maximumDetonation(self, bombs):\n        \"\"\"\n        :type bombs: List[List[int]]\n        :rtype: int\n        \"\"\"\n        # point is inside the circle if distance_from_center^2 < r^2 of circle where distance_from_cente^2 = p1x-x1 squared + p1y -y1 squared\n        # map each bomb to a set of bombs that it sets off so we can reuse it\n        if not bombs:\n            return 0\n        neighbors = {}\n        for i in range(0, len(bombs)):\n            neighbors[i] = []\n            for j in range(0, len(bombs)):\n                if i == j:\n                    continue\n                x, y, d = bombs[j]\n                if self.isInRange(bombs[i], [x, y]):\n                    temp = neighbors[i]\n                    temp.append(j)\n                    neighbors[i] = temp\n        \n        # print(neighbors)\n\n        # bfs on every bomb\n        max_det = 0\n        for i in range(0, len(bombs)):\n            detonated = set()\n            toVisit = collections.deque()\n            toVisit.append(i)\n            while len(toVisit) > 0:\n                bomb = toVisit.popleft()\n                detonated.add(bomb)\n                for n in neighbors[bomb]:\n                    if n not in detonated:\n                        toVisit.append(n)\n\n            max_det = max(max_det, len(detonated))\n\n        return max_det\n\n    \n    def isInRange(self, bomb, point):\n        bx, by, r = bomb\n        px, py = point\n        return ((bx-px)**2 + (by-py)**2) <= r**2\n\n```\n"
                    },
                    {
                        "username": "juraj24",
                        "content": "Hint: use Pythagorean theorem to find out if bomb A can detonate bomb B."
                    }
                ]
            },
            {
                "id": 1913660,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "input set is small, can brute force it.  also watch out for overflow"
                    },
                    {
                        "username": "psionl0",
                        "content": "A nice, straightforward exercise in using adjacency lists.\\n\\nTIP: If you calculate distanceSquared and radiusSquared then you can store the results in a long integer which is more accurate than using a double float."
                    },
                    {
                        "username": "daring-calf",
                        "content": "DFS! YES!"
                    },
                    {
                        "username": "quaos",
                        "content": "1. Create the directed graph of which bombs can be reached from a specified bomb.\\n2. Perform DFS on the graph to count total detonated from a start bomb, and find maximum value."
                    },
                    {
                        "username": "sushi27",
                        "content": "How to check if a point lies in circle? \nUse Euclidean distance to find the distance between two point(center point and other point) and check if distance is less than or equal to our center point radius.\nHere is my approach: https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3587764/java-easy-explained-solution/"
                    },
                    {
                        "username": "sushi27",
                        "content": "[@psionl0](/psionl0) Yes that is will be accurate"
                    },
                    {
                        "username": "psionl0",
                        "content": "Better to use distance^2. You can cast the result into a long integer which is more accurate than floating numbers (less time consuming too)."
                    },
                    {
                        "username": "sushi27",
                        "content": "[@ShashankBhat](/ShashankBhat) I added the approach. You can check it out \\uD83D\\uDC4D"
                    },
                    {
                        "username": "ShashankBhat",
                        "content": "I calculated euclidean distance and checked against each radius"
                    },
                    {
                        "username": "ShashankBhat",
                        "content": "Can anyone please let me know where I\\'m going wrong\\nMy code passes only 133 TCs.\\n\\n `\\nclass Solution {\\n    public int maximumDetonation(int[][] bombs) {\\n        Map<Integer, Set<Integer>> hm = new HashMap<>();\\n\\n        int[][] count = new int[bombs.length][2];\\n        for(int i=0; i<bombs.length; i++) {\\n            count[i][0] = i;\\n        }\\n        \\n        for(int i=0; i<bombs.length; i++) {\\n            for(int j=i+1; j<bombs.length; j++) {\\n                int dist = getDistance(bombs[i], bombs[j]);\\n                if(dist <= bombs[i][2]) {\\n                    Set<Integer> arr = hm.getOrDefault(i, new HashSet<>());\\n                    arr.add(j);\\n                    hm.put(i, arr);\\n                    count[i][1]++;\\n                }\\n\\n                if(dist <= bombs[j][2]) {\\n                    Set<Integer> arr = hm.getOrDefault(j, new HashSet<>());\\n                    arr.add(i);\\n                    hm.put(j, arr);\\n                    count[j][1]++;\\n                }\\n            }\\n        }\\n\\n        Arrays.sort(count, (int[] a, int[] b) -> b[1] - a[1]);\\n        int[] visited = new int[bombs.length];\\n        int maxCount = 0;\\n\\n        for(int i=0; i<count.length; i++) {\\n            int currCount = 0;\\n            if(visited[i] == 0) {\\n                Queue<Integer> queue = new LinkedList<>();\\n                queue.add(count[i][0]);\\n                visited[count[i][0]] = 1;\\n                currCount++;\\n                while(!queue.isEmpty()) {\\n                    int size = queue.size();\\n                    while(size-- > 0) {\\n                        int index = queue.poll();\\n                        Set<Integer> arr = hm.getOrDefault(index, new HashSet<>());\\n                        for(int idx : arr) {\\n                            if(visited[idx] == 0) {\\n                                queue.add(idx);\\n                                visited[idx] = 1;\\n                                currCount++;\\n                                // System.out.println(\"currCount: \" + currCount);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            maxCount = Math.max(maxCount, currCount);\\n        }\\n        return maxCount;\\n    }\\n\\n    public int getDistance(int[] a, int[] b) {\\n        long x = (long) Math.pow((double) Math.abs(a[0] - b[0]), 2);\\n        long y = (long) Math.pow((double) Math.abs(a[1] - b[1]), 2);\\n\\n        return (int) Math.sqrt(x + y);\\n    }\\n}\\n`\\n\\nSample Tc not passed:\\n[[855,82,158],[17,719,430],[90,756,164],[376,17,340],[691,636,152],[565,776,5],[464,154,271],[53,361,162],[278,609,82],[202,927,219],[542,865,377],[330,402,270],[720,199,10],[986,697,443],[471,296,69],[393,81,404],[127,405,177]]"
                    },
                    {
                        "username": "ShashankBhat",
                        "content": "[@kiryu_0](/kiryu_0) \\n1. Understood\\n2. What I had thought initially, was do a BFS, and have count array which stores which node has the highest num of neighbours and then do BFS from highest to least. So while traversing, we\\'ll have all the possible next-nodes in the queue after visiting a node once."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Few things seems wrong to me in your code. \n1.) converting the sqrt to int may result in some wrong assumptions in regards to the distance.\n2.) I am not sure what is the point of the count[][] array, you just need to pass the index to the queue.\n3.) after you've visited an index, you don't visit it again.\nI tried to make some changes, see if this makes sense:\n\n```\nclass Solution {\npublic int maximumDetonation(int[][] bombs) {\nMap<Integer, Set> hm = new HashMap<>();\n\n    int[][] count = new int[bombs.length][2];\n    for(int i=0; i<bombs.length; i++) {\n        count[i][0] = i;\n    }\n    \n    for(int i=0; i<bombs.length; i++) {\n        for(int j=i+1; j<bombs.length; j++) {\n            double dist = getDistance(bombs[i], bombs[j]);\n            if(dist <= bombs[i][2]*1.0) {\n                Set<Integer> arr = hm.getOrDefault(i, new HashSet<>());\n                arr.add(j);\n                hm.put(i, arr);\n                count[i][1]++;\n            }\n\n            if(dist <= bombs[j][2]*1.0) {\n                Set<Integer> arr = hm.getOrDefault(j, new HashSet<>());\n                arr.add(i);\n                hm.put(j, arr);\n                count[j][1]++;\n            }\n        }\n    }\n\n   // Arrays.sort(count, (int[] a, int[] b) -> b[1] - a[1]);\n    int[] visited = new int[bombs.length];\n    int maxCount = 0;\n\n    for(int i=0; i<count.length; i++) {\n        int currCount = 0;\n        if(visited[i] == 0) {\n            Queue<Integer> queue = new LinkedList<>();\n            queue.add(i);\n            //visited[count[i][0]] = 1;\n            //currCount++;\n            while(!queue.isEmpty()) {\n                int size = queue.size();\n                while(size-- > 0) {\n                    int index = queue.poll();\n                    if(visited[index] == 1) continue;\n                    \n                    currCount++;\n                    \n                    visited[index] = 1;\n                    Set<Integer> arr = hm.getOrDefault(index, new HashSet<>());\n                    for(int idx : arr) {\n                            queue.add(idx);\n                            // System.out.println(\"currCount: \" + currCount);\n                    }\n                }\n            }\n        }\n        visited = new int[bombs.length];\n        maxCount = Math.max(maxCount, currCount);\n    }\n    return maxCount;\n}\n\npublic double getDistance(int[] a, int[] b) {\n    long x = (long) Math.pow((double) Math.abs(a[0] - b[0]), 2);\n    long y = (long) Math.pow((double) Math.abs(a[1] - b[1]), 2);\n\n    return Math.sqrt(x + y);\n}\n}\n```"
                    },
                    {
                        "username": "xxossoo96",
                        "content": "be careful of the range of distance between two bombs"
                    },
                    {
                        "username": "user8228j",
                        "content": "see bombs.length is at most 100, know that brute force solution will likely work"
                    },
                    {
                        "username": "KevinLe563",
                        "content": "Can someone explain whats wrong with the code? I get a time limit exceeded despite passing 160/160 test cases\n\n ```\nclass Solution(object):\n    def maximumDetonation(self, bombs):\n        \"\"\"\n        :type bombs: List[List[int]]\n        :rtype: int\n        \"\"\"\n        # point is inside the circle if distance_from_center^2 < r^2 of circle where distance_from_cente^2 = p1x-x1 squared + p1y -y1 squared\n        # map each bomb to a set of bombs that it sets off so we can reuse it\n        if not bombs:\n            return 0\n        neighbors = {}\n        for i in range(0, len(bombs)):\n            neighbors[i] = []\n            for j in range(0, len(bombs)):\n                if i == j:\n                    continue\n                x, y, d = bombs[j]\n                if self.isInRange(bombs[i], [x, y]):\n                    temp = neighbors[i]\n                    temp.append(j)\n                    neighbors[i] = temp\n        \n        # print(neighbors)\n\n        # bfs on every bomb\n        max_det = 0\n        for i in range(0, len(bombs)):\n            detonated = set()\n            toVisit = collections.deque()\n            toVisit.append(i)\n            while len(toVisit) > 0:\n                bomb = toVisit.popleft()\n                detonated.add(bomb)\n                for n in neighbors[bomb]:\n                    if n not in detonated:\n                        toVisit.append(n)\n\n            max_det = max(max_det, len(detonated))\n\n        return max_det\n\n    \n    def isInRange(self, bomb, point):\n        bx, by, r = bomb\n        px, py = point\n        return ((bx-px)**2 + (by-py)**2) <= r**2\n\n```\n"
                    },
                    {
                        "username": "juraj24",
                        "content": "Hint: use Pythagorean theorem to find out if bomb A can detonate bomb B."
                    }
                ]
            },
            {
                "id": 1913605,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "input set is small, can brute force it.  also watch out for overflow"
                    },
                    {
                        "username": "psionl0",
                        "content": "A nice, straightforward exercise in using adjacency lists.\\n\\nTIP: If you calculate distanceSquared and radiusSquared then you can store the results in a long integer which is more accurate than using a double float."
                    },
                    {
                        "username": "daring-calf",
                        "content": "DFS! YES!"
                    },
                    {
                        "username": "quaos",
                        "content": "1. Create the directed graph of which bombs can be reached from a specified bomb.\\n2. Perform DFS on the graph to count total detonated from a start bomb, and find maximum value."
                    },
                    {
                        "username": "sushi27",
                        "content": "How to check if a point lies in circle? \nUse Euclidean distance to find the distance between two point(center point and other point) and check if distance is less than or equal to our center point radius.\nHere is my approach: https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3587764/java-easy-explained-solution/"
                    },
                    {
                        "username": "sushi27",
                        "content": "[@psionl0](/psionl0) Yes that is will be accurate"
                    },
                    {
                        "username": "psionl0",
                        "content": "Better to use distance^2. You can cast the result into a long integer which is more accurate than floating numbers (less time consuming too)."
                    },
                    {
                        "username": "sushi27",
                        "content": "[@ShashankBhat](/ShashankBhat) I added the approach. You can check it out \\uD83D\\uDC4D"
                    },
                    {
                        "username": "ShashankBhat",
                        "content": "I calculated euclidean distance and checked against each radius"
                    },
                    {
                        "username": "ShashankBhat",
                        "content": "Can anyone please let me know where I\\'m going wrong\\nMy code passes only 133 TCs.\\n\\n `\\nclass Solution {\\n    public int maximumDetonation(int[][] bombs) {\\n        Map<Integer, Set<Integer>> hm = new HashMap<>();\\n\\n        int[][] count = new int[bombs.length][2];\\n        for(int i=0; i<bombs.length; i++) {\\n            count[i][0] = i;\\n        }\\n        \\n        for(int i=0; i<bombs.length; i++) {\\n            for(int j=i+1; j<bombs.length; j++) {\\n                int dist = getDistance(bombs[i], bombs[j]);\\n                if(dist <= bombs[i][2]) {\\n                    Set<Integer> arr = hm.getOrDefault(i, new HashSet<>());\\n                    arr.add(j);\\n                    hm.put(i, arr);\\n                    count[i][1]++;\\n                }\\n\\n                if(dist <= bombs[j][2]) {\\n                    Set<Integer> arr = hm.getOrDefault(j, new HashSet<>());\\n                    arr.add(i);\\n                    hm.put(j, arr);\\n                    count[j][1]++;\\n                }\\n            }\\n        }\\n\\n        Arrays.sort(count, (int[] a, int[] b) -> b[1] - a[1]);\\n        int[] visited = new int[bombs.length];\\n        int maxCount = 0;\\n\\n        for(int i=0; i<count.length; i++) {\\n            int currCount = 0;\\n            if(visited[i] == 0) {\\n                Queue<Integer> queue = new LinkedList<>();\\n                queue.add(count[i][0]);\\n                visited[count[i][0]] = 1;\\n                currCount++;\\n                while(!queue.isEmpty()) {\\n                    int size = queue.size();\\n                    while(size-- > 0) {\\n                        int index = queue.poll();\\n                        Set<Integer> arr = hm.getOrDefault(index, new HashSet<>());\\n                        for(int idx : arr) {\\n                            if(visited[idx] == 0) {\\n                                queue.add(idx);\\n                                visited[idx] = 1;\\n                                currCount++;\\n                                // System.out.println(\"currCount: \" + currCount);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            maxCount = Math.max(maxCount, currCount);\\n        }\\n        return maxCount;\\n    }\\n\\n    public int getDistance(int[] a, int[] b) {\\n        long x = (long) Math.pow((double) Math.abs(a[0] - b[0]), 2);\\n        long y = (long) Math.pow((double) Math.abs(a[1] - b[1]), 2);\\n\\n        return (int) Math.sqrt(x + y);\\n    }\\n}\\n`\\n\\nSample Tc not passed:\\n[[855,82,158],[17,719,430],[90,756,164],[376,17,340],[691,636,152],[565,776,5],[464,154,271],[53,361,162],[278,609,82],[202,927,219],[542,865,377],[330,402,270],[720,199,10],[986,697,443],[471,296,69],[393,81,404],[127,405,177]]"
                    },
                    {
                        "username": "ShashankBhat",
                        "content": "[@kiryu_0](/kiryu_0) \\n1. Understood\\n2. What I had thought initially, was do a BFS, and have count array which stores which node has the highest num of neighbours and then do BFS from highest to least. So while traversing, we\\'ll have all the possible next-nodes in the queue after visiting a node once."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Few things seems wrong to me in your code. \n1.) converting the sqrt to int may result in some wrong assumptions in regards to the distance.\n2.) I am not sure what is the point of the count[][] array, you just need to pass the index to the queue.\n3.) after you've visited an index, you don't visit it again.\nI tried to make some changes, see if this makes sense:\n\n```\nclass Solution {\npublic int maximumDetonation(int[][] bombs) {\nMap<Integer, Set> hm = new HashMap<>();\n\n    int[][] count = new int[bombs.length][2];\n    for(int i=0; i<bombs.length; i++) {\n        count[i][0] = i;\n    }\n    \n    for(int i=0; i<bombs.length; i++) {\n        for(int j=i+1; j<bombs.length; j++) {\n            double dist = getDistance(bombs[i], bombs[j]);\n            if(dist <= bombs[i][2]*1.0) {\n                Set<Integer> arr = hm.getOrDefault(i, new HashSet<>());\n                arr.add(j);\n                hm.put(i, arr);\n                count[i][1]++;\n            }\n\n            if(dist <= bombs[j][2]*1.0) {\n                Set<Integer> arr = hm.getOrDefault(j, new HashSet<>());\n                arr.add(i);\n                hm.put(j, arr);\n                count[j][1]++;\n            }\n        }\n    }\n\n   // Arrays.sort(count, (int[] a, int[] b) -> b[1] - a[1]);\n    int[] visited = new int[bombs.length];\n    int maxCount = 0;\n\n    for(int i=0; i<count.length; i++) {\n        int currCount = 0;\n        if(visited[i] == 0) {\n            Queue<Integer> queue = new LinkedList<>();\n            queue.add(i);\n            //visited[count[i][0]] = 1;\n            //currCount++;\n            while(!queue.isEmpty()) {\n                int size = queue.size();\n                while(size-- > 0) {\n                    int index = queue.poll();\n                    if(visited[index] == 1) continue;\n                    \n                    currCount++;\n                    \n                    visited[index] = 1;\n                    Set<Integer> arr = hm.getOrDefault(index, new HashSet<>());\n                    for(int idx : arr) {\n                            queue.add(idx);\n                            // System.out.println(\"currCount: \" + currCount);\n                    }\n                }\n            }\n        }\n        visited = new int[bombs.length];\n        maxCount = Math.max(maxCount, currCount);\n    }\n    return maxCount;\n}\n\npublic double getDistance(int[] a, int[] b) {\n    long x = (long) Math.pow((double) Math.abs(a[0] - b[0]), 2);\n    long y = (long) Math.pow((double) Math.abs(a[1] - b[1]), 2);\n\n    return Math.sqrt(x + y);\n}\n}\n```"
                    },
                    {
                        "username": "xxossoo96",
                        "content": "be careful of the range of distance between two bombs"
                    },
                    {
                        "username": "user8228j",
                        "content": "see bombs.length is at most 100, know that brute force solution will likely work"
                    },
                    {
                        "username": "KevinLe563",
                        "content": "Can someone explain whats wrong with the code? I get a time limit exceeded despite passing 160/160 test cases\n\n ```\nclass Solution(object):\n    def maximumDetonation(self, bombs):\n        \"\"\"\n        :type bombs: List[List[int]]\n        :rtype: int\n        \"\"\"\n        # point is inside the circle if distance_from_center^2 < r^2 of circle where distance_from_cente^2 = p1x-x1 squared + p1y -y1 squared\n        # map each bomb to a set of bombs that it sets off so we can reuse it\n        if not bombs:\n            return 0\n        neighbors = {}\n        for i in range(0, len(bombs)):\n            neighbors[i] = []\n            for j in range(0, len(bombs)):\n                if i == j:\n                    continue\n                x, y, d = bombs[j]\n                if self.isInRange(bombs[i], [x, y]):\n                    temp = neighbors[i]\n                    temp.append(j)\n                    neighbors[i] = temp\n        \n        # print(neighbors)\n\n        # bfs on every bomb\n        max_det = 0\n        for i in range(0, len(bombs)):\n            detonated = set()\n            toVisit = collections.deque()\n            toVisit.append(i)\n            while len(toVisit) > 0:\n                bomb = toVisit.popleft()\n                detonated.add(bomb)\n                for n in neighbors[bomb]:\n                    if n not in detonated:\n                        toVisit.append(n)\n\n            max_det = max(max_det, len(detonated))\n\n        return max_det\n\n    \n    def isInRange(self, bomb, point):\n        bx, by, r = bomb\n        px, py = point\n        return ((bx-px)**2 + (by-py)**2) <= r**2\n\n```\n"
                    },
                    {
                        "username": "juraj24",
                        "content": "Hint: use Pythagorean theorem to find out if bomb A can detonate bomb B."
                    }
                ]
            },
            {
                "id": 1913604,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "input set is small, can brute force it.  also watch out for overflow"
                    },
                    {
                        "username": "psionl0",
                        "content": "A nice, straightforward exercise in using adjacency lists.\\n\\nTIP: If you calculate distanceSquared and radiusSquared then you can store the results in a long integer which is more accurate than using a double float."
                    },
                    {
                        "username": "daring-calf",
                        "content": "DFS! YES!"
                    },
                    {
                        "username": "quaos",
                        "content": "1. Create the directed graph of which bombs can be reached from a specified bomb.\\n2. Perform DFS on the graph to count total detonated from a start bomb, and find maximum value."
                    },
                    {
                        "username": "sushi27",
                        "content": "How to check if a point lies in circle? \nUse Euclidean distance to find the distance between two point(center point and other point) and check if distance is less than or equal to our center point radius.\nHere is my approach: https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3587764/java-easy-explained-solution/"
                    },
                    {
                        "username": "sushi27",
                        "content": "[@psionl0](/psionl0) Yes that is will be accurate"
                    },
                    {
                        "username": "psionl0",
                        "content": "Better to use distance^2. You can cast the result into a long integer which is more accurate than floating numbers (less time consuming too)."
                    },
                    {
                        "username": "sushi27",
                        "content": "[@ShashankBhat](/ShashankBhat) I added the approach. You can check it out \\uD83D\\uDC4D"
                    },
                    {
                        "username": "ShashankBhat",
                        "content": "I calculated euclidean distance and checked against each radius"
                    },
                    {
                        "username": "ShashankBhat",
                        "content": "Can anyone please let me know where I\\'m going wrong\\nMy code passes only 133 TCs.\\n\\n `\\nclass Solution {\\n    public int maximumDetonation(int[][] bombs) {\\n        Map<Integer, Set<Integer>> hm = new HashMap<>();\\n\\n        int[][] count = new int[bombs.length][2];\\n        for(int i=0; i<bombs.length; i++) {\\n            count[i][0] = i;\\n        }\\n        \\n        for(int i=0; i<bombs.length; i++) {\\n            for(int j=i+1; j<bombs.length; j++) {\\n                int dist = getDistance(bombs[i], bombs[j]);\\n                if(dist <= bombs[i][2]) {\\n                    Set<Integer> arr = hm.getOrDefault(i, new HashSet<>());\\n                    arr.add(j);\\n                    hm.put(i, arr);\\n                    count[i][1]++;\\n                }\\n\\n                if(dist <= bombs[j][2]) {\\n                    Set<Integer> arr = hm.getOrDefault(j, new HashSet<>());\\n                    arr.add(i);\\n                    hm.put(j, arr);\\n                    count[j][1]++;\\n                }\\n            }\\n        }\\n\\n        Arrays.sort(count, (int[] a, int[] b) -> b[1] - a[1]);\\n        int[] visited = new int[bombs.length];\\n        int maxCount = 0;\\n\\n        for(int i=0; i<count.length; i++) {\\n            int currCount = 0;\\n            if(visited[i] == 0) {\\n                Queue<Integer> queue = new LinkedList<>();\\n                queue.add(count[i][0]);\\n                visited[count[i][0]] = 1;\\n                currCount++;\\n                while(!queue.isEmpty()) {\\n                    int size = queue.size();\\n                    while(size-- > 0) {\\n                        int index = queue.poll();\\n                        Set<Integer> arr = hm.getOrDefault(index, new HashSet<>());\\n                        for(int idx : arr) {\\n                            if(visited[idx] == 0) {\\n                                queue.add(idx);\\n                                visited[idx] = 1;\\n                                currCount++;\\n                                // System.out.println(\"currCount: \" + currCount);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            maxCount = Math.max(maxCount, currCount);\\n        }\\n        return maxCount;\\n    }\\n\\n    public int getDistance(int[] a, int[] b) {\\n        long x = (long) Math.pow((double) Math.abs(a[0] - b[0]), 2);\\n        long y = (long) Math.pow((double) Math.abs(a[1] - b[1]), 2);\\n\\n        return (int) Math.sqrt(x + y);\\n    }\\n}\\n`\\n\\nSample Tc not passed:\\n[[855,82,158],[17,719,430],[90,756,164],[376,17,340],[691,636,152],[565,776,5],[464,154,271],[53,361,162],[278,609,82],[202,927,219],[542,865,377],[330,402,270],[720,199,10],[986,697,443],[471,296,69],[393,81,404],[127,405,177]]"
                    },
                    {
                        "username": "ShashankBhat",
                        "content": "[@kiryu_0](/kiryu_0) \\n1. Understood\\n2. What I had thought initially, was do a BFS, and have count array which stores which node has the highest num of neighbours and then do BFS from highest to least. So while traversing, we\\'ll have all the possible next-nodes in the queue after visiting a node once."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Few things seems wrong to me in your code. \n1.) converting the sqrt to int may result in some wrong assumptions in regards to the distance.\n2.) I am not sure what is the point of the count[][] array, you just need to pass the index to the queue.\n3.) after you've visited an index, you don't visit it again.\nI tried to make some changes, see if this makes sense:\n\n```\nclass Solution {\npublic int maximumDetonation(int[][] bombs) {\nMap<Integer, Set> hm = new HashMap<>();\n\n    int[][] count = new int[bombs.length][2];\n    for(int i=0; i<bombs.length; i++) {\n        count[i][0] = i;\n    }\n    \n    for(int i=0; i<bombs.length; i++) {\n        for(int j=i+1; j<bombs.length; j++) {\n            double dist = getDistance(bombs[i], bombs[j]);\n            if(dist <= bombs[i][2]*1.0) {\n                Set<Integer> arr = hm.getOrDefault(i, new HashSet<>());\n                arr.add(j);\n                hm.put(i, arr);\n                count[i][1]++;\n            }\n\n            if(dist <= bombs[j][2]*1.0) {\n                Set<Integer> arr = hm.getOrDefault(j, new HashSet<>());\n                arr.add(i);\n                hm.put(j, arr);\n                count[j][1]++;\n            }\n        }\n    }\n\n   // Arrays.sort(count, (int[] a, int[] b) -> b[1] - a[1]);\n    int[] visited = new int[bombs.length];\n    int maxCount = 0;\n\n    for(int i=0; i<count.length; i++) {\n        int currCount = 0;\n        if(visited[i] == 0) {\n            Queue<Integer> queue = new LinkedList<>();\n            queue.add(i);\n            //visited[count[i][0]] = 1;\n            //currCount++;\n            while(!queue.isEmpty()) {\n                int size = queue.size();\n                while(size-- > 0) {\n                    int index = queue.poll();\n                    if(visited[index] == 1) continue;\n                    \n                    currCount++;\n                    \n                    visited[index] = 1;\n                    Set<Integer> arr = hm.getOrDefault(index, new HashSet<>());\n                    for(int idx : arr) {\n                            queue.add(idx);\n                            // System.out.println(\"currCount: \" + currCount);\n                    }\n                }\n            }\n        }\n        visited = new int[bombs.length];\n        maxCount = Math.max(maxCount, currCount);\n    }\n    return maxCount;\n}\n\npublic double getDistance(int[] a, int[] b) {\n    long x = (long) Math.pow((double) Math.abs(a[0] - b[0]), 2);\n    long y = (long) Math.pow((double) Math.abs(a[1] - b[1]), 2);\n\n    return Math.sqrt(x + y);\n}\n}\n```"
                    },
                    {
                        "username": "xxossoo96",
                        "content": "be careful of the range of distance between two bombs"
                    },
                    {
                        "username": "user8228j",
                        "content": "see bombs.length is at most 100, know that brute force solution will likely work"
                    },
                    {
                        "username": "KevinLe563",
                        "content": "Can someone explain whats wrong with the code? I get a time limit exceeded despite passing 160/160 test cases\n\n ```\nclass Solution(object):\n    def maximumDetonation(self, bombs):\n        \"\"\"\n        :type bombs: List[List[int]]\n        :rtype: int\n        \"\"\"\n        # point is inside the circle if distance_from_center^2 < r^2 of circle where distance_from_cente^2 = p1x-x1 squared + p1y -y1 squared\n        # map each bomb to a set of bombs that it sets off so we can reuse it\n        if not bombs:\n            return 0\n        neighbors = {}\n        for i in range(0, len(bombs)):\n            neighbors[i] = []\n            for j in range(0, len(bombs)):\n                if i == j:\n                    continue\n                x, y, d = bombs[j]\n                if self.isInRange(bombs[i], [x, y]):\n                    temp = neighbors[i]\n                    temp.append(j)\n                    neighbors[i] = temp\n        \n        # print(neighbors)\n\n        # bfs on every bomb\n        max_det = 0\n        for i in range(0, len(bombs)):\n            detonated = set()\n            toVisit = collections.deque()\n            toVisit.append(i)\n            while len(toVisit) > 0:\n                bomb = toVisit.popleft()\n                detonated.add(bomb)\n                for n in neighbors[bomb]:\n                    if n not in detonated:\n                        toVisit.append(n)\n\n            max_det = max(max_det, len(detonated))\n\n        return max_det\n\n    \n    def isInRange(self, bomb, point):\n        bx, by, r = bomb\n        px, py = point\n        return ((bx-px)**2 + (by-py)**2) <= r**2\n\n```\n"
                    },
                    {
                        "username": "juraj24",
                        "content": "Hint: use Pythagorean theorem to find out if bomb A can detonate bomb B."
                    }
                ]
            },
            {
                "id": 1913592,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "input set is small, can brute force it.  also watch out for overflow"
                    },
                    {
                        "username": "psionl0",
                        "content": "A nice, straightforward exercise in using adjacency lists.\\n\\nTIP: If you calculate distanceSquared and radiusSquared then you can store the results in a long integer which is more accurate than using a double float."
                    },
                    {
                        "username": "daring-calf",
                        "content": "DFS! YES!"
                    },
                    {
                        "username": "quaos",
                        "content": "1. Create the directed graph of which bombs can be reached from a specified bomb.\\n2. Perform DFS on the graph to count total detonated from a start bomb, and find maximum value."
                    },
                    {
                        "username": "sushi27",
                        "content": "How to check if a point lies in circle? \nUse Euclidean distance to find the distance between two point(center point and other point) and check if distance is less than or equal to our center point radius.\nHere is my approach: https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3587764/java-easy-explained-solution/"
                    },
                    {
                        "username": "sushi27",
                        "content": "[@psionl0](/psionl0) Yes that is will be accurate"
                    },
                    {
                        "username": "psionl0",
                        "content": "Better to use distance^2. You can cast the result into a long integer which is more accurate than floating numbers (less time consuming too)."
                    },
                    {
                        "username": "sushi27",
                        "content": "[@ShashankBhat](/ShashankBhat) I added the approach. You can check it out \\uD83D\\uDC4D"
                    },
                    {
                        "username": "ShashankBhat",
                        "content": "I calculated euclidean distance and checked against each radius"
                    },
                    {
                        "username": "ShashankBhat",
                        "content": "Can anyone please let me know where I\\'m going wrong\\nMy code passes only 133 TCs.\\n\\n `\\nclass Solution {\\n    public int maximumDetonation(int[][] bombs) {\\n        Map<Integer, Set<Integer>> hm = new HashMap<>();\\n\\n        int[][] count = new int[bombs.length][2];\\n        for(int i=0; i<bombs.length; i++) {\\n            count[i][0] = i;\\n        }\\n        \\n        for(int i=0; i<bombs.length; i++) {\\n            for(int j=i+1; j<bombs.length; j++) {\\n                int dist = getDistance(bombs[i], bombs[j]);\\n                if(dist <= bombs[i][2]) {\\n                    Set<Integer> arr = hm.getOrDefault(i, new HashSet<>());\\n                    arr.add(j);\\n                    hm.put(i, arr);\\n                    count[i][1]++;\\n                }\\n\\n                if(dist <= bombs[j][2]) {\\n                    Set<Integer> arr = hm.getOrDefault(j, new HashSet<>());\\n                    arr.add(i);\\n                    hm.put(j, arr);\\n                    count[j][1]++;\\n                }\\n            }\\n        }\\n\\n        Arrays.sort(count, (int[] a, int[] b) -> b[1] - a[1]);\\n        int[] visited = new int[bombs.length];\\n        int maxCount = 0;\\n\\n        for(int i=0; i<count.length; i++) {\\n            int currCount = 0;\\n            if(visited[i] == 0) {\\n                Queue<Integer> queue = new LinkedList<>();\\n                queue.add(count[i][0]);\\n                visited[count[i][0]] = 1;\\n                currCount++;\\n                while(!queue.isEmpty()) {\\n                    int size = queue.size();\\n                    while(size-- > 0) {\\n                        int index = queue.poll();\\n                        Set<Integer> arr = hm.getOrDefault(index, new HashSet<>());\\n                        for(int idx : arr) {\\n                            if(visited[idx] == 0) {\\n                                queue.add(idx);\\n                                visited[idx] = 1;\\n                                currCount++;\\n                                // System.out.println(\"currCount: \" + currCount);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            maxCount = Math.max(maxCount, currCount);\\n        }\\n        return maxCount;\\n    }\\n\\n    public int getDistance(int[] a, int[] b) {\\n        long x = (long) Math.pow((double) Math.abs(a[0] - b[0]), 2);\\n        long y = (long) Math.pow((double) Math.abs(a[1] - b[1]), 2);\\n\\n        return (int) Math.sqrt(x + y);\\n    }\\n}\\n`\\n\\nSample Tc not passed:\\n[[855,82,158],[17,719,430],[90,756,164],[376,17,340],[691,636,152],[565,776,5],[464,154,271],[53,361,162],[278,609,82],[202,927,219],[542,865,377],[330,402,270],[720,199,10],[986,697,443],[471,296,69],[393,81,404],[127,405,177]]"
                    },
                    {
                        "username": "ShashankBhat",
                        "content": "[@kiryu_0](/kiryu_0) \\n1. Understood\\n2. What I had thought initially, was do a BFS, and have count array which stores which node has the highest num of neighbours and then do BFS from highest to least. So while traversing, we\\'ll have all the possible next-nodes in the queue after visiting a node once."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Few things seems wrong to me in your code. \n1.) converting the sqrt to int may result in some wrong assumptions in regards to the distance.\n2.) I am not sure what is the point of the count[][] array, you just need to pass the index to the queue.\n3.) after you've visited an index, you don't visit it again.\nI tried to make some changes, see if this makes sense:\n\n```\nclass Solution {\npublic int maximumDetonation(int[][] bombs) {\nMap<Integer, Set> hm = new HashMap<>();\n\n    int[][] count = new int[bombs.length][2];\n    for(int i=0; i<bombs.length; i++) {\n        count[i][0] = i;\n    }\n    \n    for(int i=0; i<bombs.length; i++) {\n        for(int j=i+1; j<bombs.length; j++) {\n            double dist = getDistance(bombs[i], bombs[j]);\n            if(dist <= bombs[i][2]*1.0) {\n                Set<Integer> arr = hm.getOrDefault(i, new HashSet<>());\n                arr.add(j);\n                hm.put(i, arr);\n                count[i][1]++;\n            }\n\n            if(dist <= bombs[j][2]*1.0) {\n                Set<Integer> arr = hm.getOrDefault(j, new HashSet<>());\n                arr.add(i);\n                hm.put(j, arr);\n                count[j][1]++;\n            }\n        }\n    }\n\n   // Arrays.sort(count, (int[] a, int[] b) -> b[1] - a[1]);\n    int[] visited = new int[bombs.length];\n    int maxCount = 0;\n\n    for(int i=0; i<count.length; i++) {\n        int currCount = 0;\n        if(visited[i] == 0) {\n            Queue<Integer> queue = new LinkedList<>();\n            queue.add(i);\n            //visited[count[i][0]] = 1;\n            //currCount++;\n            while(!queue.isEmpty()) {\n                int size = queue.size();\n                while(size-- > 0) {\n                    int index = queue.poll();\n                    if(visited[index] == 1) continue;\n                    \n                    currCount++;\n                    \n                    visited[index] = 1;\n                    Set<Integer> arr = hm.getOrDefault(index, new HashSet<>());\n                    for(int idx : arr) {\n                            queue.add(idx);\n                            // System.out.println(\"currCount: \" + currCount);\n                    }\n                }\n            }\n        }\n        visited = new int[bombs.length];\n        maxCount = Math.max(maxCount, currCount);\n    }\n    return maxCount;\n}\n\npublic double getDistance(int[] a, int[] b) {\n    long x = (long) Math.pow((double) Math.abs(a[0] - b[0]), 2);\n    long y = (long) Math.pow((double) Math.abs(a[1] - b[1]), 2);\n\n    return Math.sqrt(x + y);\n}\n}\n```"
                    },
                    {
                        "username": "xxossoo96",
                        "content": "be careful of the range of distance between two bombs"
                    },
                    {
                        "username": "user8228j",
                        "content": "see bombs.length is at most 100, know that brute force solution will likely work"
                    },
                    {
                        "username": "KevinLe563",
                        "content": "Can someone explain whats wrong with the code? I get a time limit exceeded despite passing 160/160 test cases\n\n ```\nclass Solution(object):\n    def maximumDetonation(self, bombs):\n        \"\"\"\n        :type bombs: List[List[int]]\n        :rtype: int\n        \"\"\"\n        # point is inside the circle if distance_from_center^2 < r^2 of circle where distance_from_cente^2 = p1x-x1 squared + p1y -y1 squared\n        # map each bomb to a set of bombs that it sets off so we can reuse it\n        if not bombs:\n            return 0\n        neighbors = {}\n        for i in range(0, len(bombs)):\n            neighbors[i] = []\n            for j in range(0, len(bombs)):\n                if i == j:\n                    continue\n                x, y, d = bombs[j]\n                if self.isInRange(bombs[i], [x, y]):\n                    temp = neighbors[i]\n                    temp.append(j)\n                    neighbors[i] = temp\n        \n        # print(neighbors)\n\n        # bfs on every bomb\n        max_det = 0\n        for i in range(0, len(bombs)):\n            detonated = set()\n            toVisit = collections.deque()\n            toVisit.append(i)\n            while len(toVisit) > 0:\n                bomb = toVisit.popleft()\n                detonated.add(bomb)\n                for n in neighbors[bomb]:\n                    if n not in detonated:\n                        toVisit.append(n)\n\n            max_det = max(max_det, len(detonated))\n\n        return max_det\n\n    \n    def isInRange(self, bomb, point):\n        bx, by, r = bomb\n        px, py = point\n        return ((bx-px)**2 + (by-py)**2) <= r**2\n\n```\n"
                    },
                    {
                        "username": "juraj24",
                        "content": "Hint: use Pythagorean theorem to find out if bomb A can detonate bomb B."
                    }
                ]
            },
            {
                "id": 1913558,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "input set is small, can brute force it.  also watch out for overflow"
                    },
                    {
                        "username": "psionl0",
                        "content": "A nice, straightforward exercise in using adjacency lists.\\n\\nTIP: If you calculate distanceSquared and radiusSquared then you can store the results in a long integer which is more accurate than using a double float."
                    },
                    {
                        "username": "daring-calf",
                        "content": "DFS! YES!"
                    },
                    {
                        "username": "quaos",
                        "content": "1. Create the directed graph of which bombs can be reached from a specified bomb.\\n2. Perform DFS on the graph to count total detonated from a start bomb, and find maximum value."
                    },
                    {
                        "username": "sushi27",
                        "content": "How to check if a point lies in circle? \nUse Euclidean distance to find the distance between two point(center point and other point) and check if distance is less than or equal to our center point radius.\nHere is my approach: https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3587764/java-easy-explained-solution/"
                    },
                    {
                        "username": "sushi27",
                        "content": "[@psionl0](/psionl0) Yes that is will be accurate"
                    },
                    {
                        "username": "psionl0",
                        "content": "Better to use distance^2. You can cast the result into a long integer which is more accurate than floating numbers (less time consuming too)."
                    },
                    {
                        "username": "sushi27",
                        "content": "[@ShashankBhat](/ShashankBhat) I added the approach. You can check it out \\uD83D\\uDC4D"
                    },
                    {
                        "username": "ShashankBhat",
                        "content": "I calculated euclidean distance and checked against each radius"
                    },
                    {
                        "username": "ShashankBhat",
                        "content": "Can anyone please let me know where I\\'m going wrong\\nMy code passes only 133 TCs.\\n\\n `\\nclass Solution {\\n    public int maximumDetonation(int[][] bombs) {\\n        Map<Integer, Set<Integer>> hm = new HashMap<>();\\n\\n        int[][] count = new int[bombs.length][2];\\n        for(int i=0; i<bombs.length; i++) {\\n            count[i][0] = i;\\n        }\\n        \\n        for(int i=0; i<bombs.length; i++) {\\n            for(int j=i+1; j<bombs.length; j++) {\\n                int dist = getDistance(bombs[i], bombs[j]);\\n                if(dist <= bombs[i][2]) {\\n                    Set<Integer> arr = hm.getOrDefault(i, new HashSet<>());\\n                    arr.add(j);\\n                    hm.put(i, arr);\\n                    count[i][1]++;\\n                }\\n\\n                if(dist <= bombs[j][2]) {\\n                    Set<Integer> arr = hm.getOrDefault(j, new HashSet<>());\\n                    arr.add(i);\\n                    hm.put(j, arr);\\n                    count[j][1]++;\\n                }\\n            }\\n        }\\n\\n        Arrays.sort(count, (int[] a, int[] b) -> b[1] - a[1]);\\n        int[] visited = new int[bombs.length];\\n        int maxCount = 0;\\n\\n        for(int i=0; i<count.length; i++) {\\n            int currCount = 0;\\n            if(visited[i] == 0) {\\n                Queue<Integer> queue = new LinkedList<>();\\n                queue.add(count[i][0]);\\n                visited[count[i][0]] = 1;\\n                currCount++;\\n                while(!queue.isEmpty()) {\\n                    int size = queue.size();\\n                    while(size-- > 0) {\\n                        int index = queue.poll();\\n                        Set<Integer> arr = hm.getOrDefault(index, new HashSet<>());\\n                        for(int idx : arr) {\\n                            if(visited[idx] == 0) {\\n                                queue.add(idx);\\n                                visited[idx] = 1;\\n                                currCount++;\\n                                // System.out.println(\"currCount: \" + currCount);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            maxCount = Math.max(maxCount, currCount);\\n        }\\n        return maxCount;\\n    }\\n\\n    public int getDistance(int[] a, int[] b) {\\n        long x = (long) Math.pow((double) Math.abs(a[0] - b[0]), 2);\\n        long y = (long) Math.pow((double) Math.abs(a[1] - b[1]), 2);\\n\\n        return (int) Math.sqrt(x + y);\\n    }\\n}\\n`\\n\\nSample Tc not passed:\\n[[855,82,158],[17,719,430],[90,756,164],[376,17,340],[691,636,152],[565,776,5],[464,154,271],[53,361,162],[278,609,82],[202,927,219],[542,865,377],[330,402,270],[720,199,10],[986,697,443],[471,296,69],[393,81,404],[127,405,177]]"
                    },
                    {
                        "username": "ShashankBhat",
                        "content": "[@kiryu_0](/kiryu_0) \\n1. Understood\\n2. What I had thought initially, was do a BFS, and have count array which stores which node has the highest num of neighbours and then do BFS from highest to least. So while traversing, we\\'ll have all the possible next-nodes in the queue after visiting a node once."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Few things seems wrong to me in your code. \n1.) converting the sqrt to int may result in some wrong assumptions in regards to the distance.\n2.) I am not sure what is the point of the count[][] array, you just need to pass the index to the queue.\n3.) after you've visited an index, you don't visit it again.\nI tried to make some changes, see if this makes sense:\n\n```\nclass Solution {\npublic int maximumDetonation(int[][] bombs) {\nMap<Integer, Set> hm = new HashMap<>();\n\n    int[][] count = new int[bombs.length][2];\n    for(int i=0; i<bombs.length; i++) {\n        count[i][0] = i;\n    }\n    \n    for(int i=0; i<bombs.length; i++) {\n        for(int j=i+1; j<bombs.length; j++) {\n            double dist = getDistance(bombs[i], bombs[j]);\n            if(dist <= bombs[i][2]*1.0) {\n                Set<Integer> arr = hm.getOrDefault(i, new HashSet<>());\n                arr.add(j);\n                hm.put(i, arr);\n                count[i][1]++;\n            }\n\n            if(dist <= bombs[j][2]*1.0) {\n                Set<Integer> arr = hm.getOrDefault(j, new HashSet<>());\n                arr.add(i);\n                hm.put(j, arr);\n                count[j][1]++;\n            }\n        }\n    }\n\n   // Arrays.sort(count, (int[] a, int[] b) -> b[1] - a[1]);\n    int[] visited = new int[bombs.length];\n    int maxCount = 0;\n\n    for(int i=0; i<count.length; i++) {\n        int currCount = 0;\n        if(visited[i] == 0) {\n            Queue<Integer> queue = new LinkedList<>();\n            queue.add(i);\n            //visited[count[i][0]] = 1;\n            //currCount++;\n            while(!queue.isEmpty()) {\n                int size = queue.size();\n                while(size-- > 0) {\n                    int index = queue.poll();\n                    if(visited[index] == 1) continue;\n                    \n                    currCount++;\n                    \n                    visited[index] = 1;\n                    Set<Integer> arr = hm.getOrDefault(index, new HashSet<>());\n                    for(int idx : arr) {\n                            queue.add(idx);\n                            // System.out.println(\"currCount: \" + currCount);\n                    }\n                }\n            }\n        }\n        visited = new int[bombs.length];\n        maxCount = Math.max(maxCount, currCount);\n    }\n    return maxCount;\n}\n\npublic double getDistance(int[] a, int[] b) {\n    long x = (long) Math.pow((double) Math.abs(a[0] - b[0]), 2);\n    long y = (long) Math.pow((double) Math.abs(a[1] - b[1]), 2);\n\n    return Math.sqrt(x + y);\n}\n}\n```"
                    },
                    {
                        "username": "xxossoo96",
                        "content": "be careful of the range of distance between two bombs"
                    },
                    {
                        "username": "user8228j",
                        "content": "see bombs.length is at most 100, know that brute force solution will likely work"
                    },
                    {
                        "username": "KevinLe563",
                        "content": "Can someone explain whats wrong with the code? I get a time limit exceeded despite passing 160/160 test cases\n\n ```\nclass Solution(object):\n    def maximumDetonation(self, bombs):\n        \"\"\"\n        :type bombs: List[List[int]]\n        :rtype: int\n        \"\"\"\n        # point is inside the circle if distance_from_center^2 < r^2 of circle where distance_from_cente^2 = p1x-x1 squared + p1y -y1 squared\n        # map each bomb to a set of bombs that it sets off so we can reuse it\n        if not bombs:\n            return 0\n        neighbors = {}\n        for i in range(0, len(bombs)):\n            neighbors[i] = []\n            for j in range(0, len(bombs)):\n                if i == j:\n                    continue\n                x, y, d = bombs[j]\n                if self.isInRange(bombs[i], [x, y]):\n                    temp = neighbors[i]\n                    temp.append(j)\n                    neighbors[i] = temp\n        \n        # print(neighbors)\n\n        # bfs on every bomb\n        max_det = 0\n        for i in range(0, len(bombs)):\n            detonated = set()\n            toVisit = collections.deque()\n            toVisit.append(i)\n            while len(toVisit) > 0:\n                bomb = toVisit.popleft()\n                detonated.add(bomb)\n                for n in neighbors[bomb]:\n                    if n not in detonated:\n                        toVisit.append(n)\n\n            max_det = max(max_det, len(detonated))\n\n        return max_det\n\n    \n    def isInRange(self, bomb, point):\n        bx, by, r = bomb\n        px, py = point\n        return ((bx-px)**2 + (by-py)**2) <= r**2\n\n```\n"
                    },
                    {
                        "username": "juraj24",
                        "content": "Hint: use Pythagorean theorem to find out if bomb A can detonate bomb B."
                    }
                ]
            },
            {
                "id": 1910521,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "input set is small, can brute force it.  also watch out for overflow"
                    },
                    {
                        "username": "psionl0",
                        "content": "A nice, straightforward exercise in using adjacency lists.\\n\\nTIP: If you calculate distanceSquared and radiusSquared then you can store the results in a long integer which is more accurate than using a double float."
                    },
                    {
                        "username": "daring-calf",
                        "content": "DFS! YES!"
                    },
                    {
                        "username": "quaos",
                        "content": "1. Create the directed graph of which bombs can be reached from a specified bomb.\\n2. Perform DFS on the graph to count total detonated from a start bomb, and find maximum value."
                    },
                    {
                        "username": "sushi27",
                        "content": "How to check if a point lies in circle? \nUse Euclidean distance to find the distance between two point(center point and other point) and check if distance is less than or equal to our center point radius.\nHere is my approach: https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3587764/java-easy-explained-solution/"
                    },
                    {
                        "username": "sushi27",
                        "content": "[@psionl0](/psionl0) Yes that is will be accurate"
                    },
                    {
                        "username": "psionl0",
                        "content": "Better to use distance^2. You can cast the result into a long integer which is more accurate than floating numbers (less time consuming too)."
                    },
                    {
                        "username": "sushi27",
                        "content": "[@ShashankBhat](/ShashankBhat) I added the approach. You can check it out \\uD83D\\uDC4D"
                    },
                    {
                        "username": "ShashankBhat",
                        "content": "I calculated euclidean distance and checked against each radius"
                    },
                    {
                        "username": "ShashankBhat",
                        "content": "Can anyone please let me know where I\\'m going wrong\\nMy code passes only 133 TCs.\\n\\n `\\nclass Solution {\\n    public int maximumDetonation(int[][] bombs) {\\n        Map<Integer, Set<Integer>> hm = new HashMap<>();\\n\\n        int[][] count = new int[bombs.length][2];\\n        for(int i=0; i<bombs.length; i++) {\\n            count[i][0] = i;\\n        }\\n        \\n        for(int i=0; i<bombs.length; i++) {\\n            for(int j=i+1; j<bombs.length; j++) {\\n                int dist = getDistance(bombs[i], bombs[j]);\\n                if(dist <= bombs[i][2]) {\\n                    Set<Integer> arr = hm.getOrDefault(i, new HashSet<>());\\n                    arr.add(j);\\n                    hm.put(i, arr);\\n                    count[i][1]++;\\n                }\\n\\n                if(dist <= bombs[j][2]) {\\n                    Set<Integer> arr = hm.getOrDefault(j, new HashSet<>());\\n                    arr.add(i);\\n                    hm.put(j, arr);\\n                    count[j][1]++;\\n                }\\n            }\\n        }\\n\\n        Arrays.sort(count, (int[] a, int[] b) -> b[1] - a[1]);\\n        int[] visited = new int[bombs.length];\\n        int maxCount = 0;\\n\\n        for(int i=0; i<count.length; i++) {\\n            int currCount = 0;\\n            if(visited[i] == 0) {\\n                Queue<Integer> queue = new LinkedList<>();\\n                queue.add(count[i][0]);\\n                visited[count[i][0]] = 1;\\n                currCount++;\\n                while(!queue.isEmpty()) {\\n                    int size = queue.size();\\n                    while(size-- > 0) {\\n                        int index = queue.poll();\\n                        Set<Integer> arr = hm.getOrDefault(index, new HashSet<>());\\n                        for(int idx : arr) {\\n                            if(visited[idx] == 0) {\\n                                queue.add(idx);\\n                                visited[idx] = 1;\\n                                currCount++;\\n                                // System.out.println(\"currCount: \" + currCount);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            maxCount = Math.max(maxCount, currCount);\\n        }\\n        return maxCount;\\n    }\\n\\n    public int getDistance(int[] a, int[] b) {\\n        long x = (long) Math.pow((double) Math.abs(a[0] - b[0]), 2);\\n        long y = (long) Math.pow((double) Math.abs(a[1] - b[1]), 2);\\n\\n        return (int) Math.sqrt(x + y);\\n    }\\n}\\n`\\n\\nSample Tc not passed:\\n[[855,82,158],[17,719,430],[90,756,164],[376,17,340],[691,636,152],[565,776,5],[464,154,271],[53,361,162],[278,609,82],[202,927,219],[542,865,377],[330,402,270],[720,199,10],[986,697,443],[471,296,69],[393,81,404],[127,405,177]]"
                    },
                    {
                        "username": "ShashankBhat",
                        "content": "[@kiryu_0](/kiryu_0) \\n1. Understood\\n2. What I had thought initially, was do a BFS, and have count array which stores which node has the highest num of neighbours and then do BFS from highest to least. So while traversing, we\\'ll have all the possible next-nodes in the queue after visiting a node once."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Few things seems wrong to me in your code. \n1.) converting the sqrt to int may result in some wrong assumptions in regards to the distance.\n2.) I am not sure what is the point of the count[][] array, you just need to pass the index to the queue.\n3.) after you've visited an index, you don't visit it again.\nI tried to make some changes, see if this makes sense:\n\n```\nclass Solution {\npublic int maximumDetonation(int[][] bombs) {\nMap<Integer, Set> hm = new HashMap<>();\n\n    int[][] count = new int[bombs.length][2];\n    for(int i=0; i<bombs.length; i++) {\n        count[i][0] = i;\n    }\n    \n    for(int i=0; i<bombs.length; i++) {\n        for(int j=i+1; j<bombs.length; j++) {\n            double dist = getDistance(bombs[i], bombs[j]);\n            if(dist <= bombs[i][2]*1.0) {\n                Set<Integer> arr = hm.getOrDefault(i, new HashSet<>());\n                arr.add(j);\n                hm.put(i, arr);\n                count[i][1]++;\n            }\n\n            if(dist <= bombs[j][2]*1.0) {\n                Set<Integer> arr = hm.getOrDefault(j, new HashSet<>());\n                arr.add(i);\n                hm.put(j, arr);\n                count[j][1]++;\n            }\n        }\n    }\n\n   // Arrays.sort(count, (int[] a, int[] b) -> b[1] - a[1]);\n    int[] visited = new int[bombs.length];\n    int maxCount = 0;\n\n    for(int i=0; i<count.length; i++) {\n        int currCount = 0;\n        if(visited[i] == 0) {\n            Queue<Integer> queue = new LinkedList<>();\n            queue.add(i);\n            //visited[count[i][0]] = 1;\n            //currCount++;\n            while(!queue.isEmpty()) {\n                int size = queue.size();\n                while(size-- > 0) {\n                    int index = queue.poll();\n                    if(visited[index] == 1) continue;\n                    \n                    currCount++;\n                    \n                    visited[index] = 1;\n                    Set<Integer> arr = hm.getOrDefault(index, new HashSet<>());\n                    for(int idx : arr) {\n                            queue.add(idx);\n                            // System.out.println(\"currCount: \" + currCount);\n                    }\n                }\n            }\n        }\n        visited = new int[bombs.length];\n        maxCount = Math.max(maxCount, currCount);\n    }\n    return maxCount;\n}\n\npublic double getDistance(int[] a, int[] b) {\n    long x = (long) Math.pow((double) Math.abs(a[0] - b[0]), 2);\n    long y = (long) Math.pow((double) Math.abs(a[1] - b[1]), 2);\n\n    return Math.sqrt(x + y);\n}\n}\n```"
                    },
                    {
                        "username": "xxossoo96",
                        "content": "be careful of the range of distance between two bombs"
                    },
                    {
                        "username": "user8228j",
                        "content": "see bombs.length is at most 100, know that brute force solution will likely work"
                    },
                    {
                        "username": "KevinLe563",
                        "content": "Can someone explain whats wrong with the code? I get a time limit exceeded despite passing 160/160 test cases\n\n ```\nclass Solution(object):\n    def maximumDetonation(self, bombs):\n        \"\"\"\n        :type bombs: List[List[int]]\n        :rtype: int\n        \"\"\"\n        # point is inside the circle if distance_from_center^2 < r^2 of circle where distance_from_cente^2 = p1x-x1 squared + p1y -y1 squared\n        # map each bomb to a set of bombs that it sets off so we can reuse it\n        if not bombs:\n            return 0\n        neighbors = {}\n        for i in range(0, len(bombs)):\n            neighbors[i] = []\n            for j in range(0, len(bombs)):\n                if i == j:\n                    continue\n                x, y, d = bombs[j]\n                if self.isInRange(bombs[i], [x, y]):\n                    temp = neighbors[i]\n                    temp.append(j)\n                    neighbors[i] = temp\n        \n        # print(neighbors)\n\n        # bfs on every bomb\n        max_det = 0\n        for i in range(0, len(bombs)):\n            detonated = set()\n            toVisit = collections.deque()\n            toVisit.append(i)\n            while len(toVisit) > 0:\n                bomb = toVisit.popleft()\n                detonated.add(bomb)\n                for n in neighbors[bomb]:\n                    if n not in detonated:\n                        toVisit.append(n)\n\n            max_det = max(max_det, len(detonated))\n\n        return max_det\n\n    \n    def isInRange(self, bomb, point):\n        bx, by, r = bomb\n        px, py = point\n        return ((bx-px)**2 + (by-py)**2) <= r**2\n\n```\n"
                    },
                    {
                        "username": "juraj24",
                        "content": "Hint: use Pythagorean theorem to find out if bomb A can detonate bomb B."
                    }
                ]
            },
            {
                "id": 1898737,
                "content": [
                    {
                        "username": "user5400vw",
                        "content": "input set is small, can brute force it.  also watch out for overflow"
                    },
                    {
                        "username": "psionl0",
                        "content": "A nice, straightforward exercise in using adjacency lists.\\n\\nTIP: If you calculate distanceSquared and radiusSquared then you can store the results in a long integer which is more accurate than using a double float."
                    },
                    {
                        "username": "daring-calf",
                        "content": "DFS! YES!"
                    },
                    {
                        "username": "quaos",
                        "content": "1. Create the directed graph of which bombs can be reached from a specified bomb.\\n2. Perform DFS on the graph to count total detonated from a start bomb, and find maximum value."
                    },
                    {
                        "username": "sushi27",
                        "content": "How to check if a point lies in circle? \nUse Euclidean distance to find the distance between two point(center point and other point) and check if distance is less than or equal to our center point radius.\nHere is my approach: https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3587764/java-easy-explained-solution/"
                    },
                    {
                        "username": "sushi27",
                        "content": "[@psionl0](/psionl0) Yes that is will be accurate"
                    },
                    {
                        "username": "psionl0",
                        "content": "Better to use distance^2. You can cast the result into a long integer which is more accurate than floating numbers (less time consuming too)."
                    },
                    {
                        "username": "sushi27",
                        "content": "[@ShashankBhat](/ShashankBhat) I added the approach. You can check it out \\uD83D\\uDC4D"
                    },
                    {
                        "username": "ShashankBhat",
                        "content": "I calculated euclidean distance and checked against each radius"
                    },
                    {
                        "username": "ShashankBhat",
                        "content": "Can anyone please let me know where I\\'m going wrong\\nMy code passes only 133 TCs.\\n\\n `\\nclass Solution {\\n    public int maximumDetonation(int[][] bombs) {\\n        Map<Integer, Set<Integer>> hm = new HashMap<>();\\n\\n        int[][] count = new int[bombs.length][2];\\n        for(int i=0; i<bombs.length; i++) {\\n            count[i][0] = i;\\n        }\\n        \\n        for(int i=0; i<bombs.length; i++) {\\n            for(int j=i+1; j<bombs.length; j++) {\\n                int dist = getDistance(bombs[i], bombs[j]);\\n                if(dist <= bombs[i][2]) {\\n                    Set<Integer> arr = hm.getOrDefault(i, new HashSet<>());\\n                    arr.add(j);\\n                    hm.put(i, arr);\\n                    count[i][1]++;\\n                }\\n\\n                if(dist <= bombs[j][2]) {\\n                    Set<Integer> arr = hm.getOrDefault(j, new HashSet<>());\\n                    arr.add(i);\\n                    hm.put(j, arr);\\n                    count[j][1]++;\\n                }\\n            }\\n        }\\n\\n        Arrays.sort(count, (int[] a, int[] b) -> b[1] - a[1]);\\n        int[] visited = new int[bombs.length];\\n        int maxCount = 0;\\n\\n        for(int i=0; i<count.length; i++) {\\n            int currCount = 0;\\n            if(visited[i] == 0) {\\n                Queue<Integer> queue = new LinkedList<>();\\n                queue.add(count[i][0]);\\n                visited[count[i][0]] = 1;\\n                currCount++;\\n                while(!queue.isEmpty()) {\\n                    int size = queue.size();\\n                    while(size-- > 0) {\\n                        int index = queue.poll();\\n                        Set<Integer> arr = hm.getOrDefault(index, new HashSet<>());\\n                        for(int idx : arr) {\\n                            if(visited[idx] == 0) {\\n                                queue.add(idx);\\n                                visited[idx] = 1;\\n                                currCount++;\\n                                // System.out.println(\"currCount: \" + currCount);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            maxCount = Math.max(maxCount, currCount);\\n        }\\n        return maxCount;\\n    }\\n\\n    public int getDistance(int[] a, int[] b) {\\n        long x = (long) Math.pow((double) Math.abs(a[0] - b[0]), 2);\\n        long y = (long) Math.pow((double) Math.abs(a[1] - b[1]), 2);\\n\\n        return (int) Math.sqrt(x + y);\\n    }\\n}\\n`\\n\\nSample Tc not passed:\\n[[855,82,158],[17,719,430],[90,756,164],[376,17,340],[691,636,152],[565,776,5],[464,154,271],[53,361,162],[278,609,82],[202,927,219],[542,865,377],[330,402,270],[720,199,10],[986,697,443],[471,296,69],[393,81,404],[127,405,177]]"
                    },
                    {
                        "username": "ShashankBhat",
                        "content": "[@kiryu_0](/kiryu_0) \\n1. Understood\\n2. What I had thought initially, was do a BFS, and have count array which stores which node has the highest num of neighbours and then do BFS from highest to least. So while traversing, we\\'ll have all the possible next-nodes in the queue after visiting a node once."
                    },
                    {
                        "username": "kiryu_0",
                        "content": "Few things seems wrong to me in your code. \n1.) converting the sqrt to int may result in some wrong assumptions in regards to the distance.\n2.) I am not sure what is the point of the count[][] array, you just need to pass the index to the queue.\n3.) after you've visited an index, you don't visit it again.\nI tried to make some changes, see if this makes sense:\n\n```\nclass Solution {\npublic int maximumDetonation(int[][] bombs) {\nMap<Integer, Set> hm = new HashMap<>();\n\n    int[][] count = new int[bombs.length][2];\n    for(int i=0; i<bombs.length; i++) {\n        count[i][0] = i;\n    }\n    \n    for(int i=0; i<bombs.length; i++) {\n        for(int j=i+1; j<bombs.length; j++) {\n            double dist = getDistance(bombs[i], bombs[j]);\n            if(dist <= bombs[i][2]*1.0) {\n                Set<Integer> arr = hm.getOrDefault(i, new HashSet<>());\n                arr.add(j);\n                hm.put(i, arr);\n                count[i][1]++;\n            }\n\n            if(dist <= bombs[j][2]*1.0) {\n                Set<Integer> arr = hm.getOrDefault(j, new HashSet<>());\n                arr.add(i);\n                hm.put(j, arr);\n                count[j][1]++;\n            }\n        }\n    }\n\n   // Arrays.sort(count, (int[] a, int[] b) -> b[1] - a[1]);\n    int[] visited = new int[bombs.length];\n    int maxCount = 0;\n\n    for(int i=0; i<count.length; i++) {\n        int currCount = 0;\n        if(visited[i] == 0) {\n            Queue<Integer> queue = new LinkedList<>();\n            queue.add(i);\n            //visited[count[i][0]] = 1;\n            //currCount++;\n            while(!queue.isEmpty()) {\n                int size = queue.size();\n                while(size-- > 0) {\n                    int index = queue.poll();\n                    if(visited[index] == 1) continue;\n                    \n                    currCount++;\n                    \n                    visited[index] = 1;\n                    Set<Integer> arr = hm.getOrDefault(index, new HashSet<>());\n                    for(int idx : arr) {\n                            queue.add(idx);\n                            // System.out.println(\"currCount: \" + currCount);\n                    }\n                }\n            }\n        }\n        visited = new int[bombs.length];\n        maxCount = Math.max(maxCount, currCount);\n    }\n    return maxCount;\n}\n\npublic double getDistance(int[] a, int[] b) {\n    long x = (long) Math.pow((double) Math.abs(a[0] - b[0]), 2);\n    long y = (long) Math.pow((double) Math.abs(a[1] - b[1]), 2);\n\n    return Math.sqrt(x + y);\n}\n}\n```"
                    },
                    {
                        "username": "xxossoo96",
                        "content": "be careful of the range of distance between two bombs"
                    },
                    {
                        "username": "user8228j",
                        "content": "see bombs.length is at most 100, know that brute force solution will likely work"
                    },
                    {
                        "username": "KevinLe563",
                        "content": "Can someone explain whats wrong with the code? I get a time limit exceeded despite passing 160/160 test cases\n\n ```\nclass Solution(object):\n    def maximumDetonation(self, bombs):\n        \"\"\"\n        :type bombs: List[List[int]]\n        :rtype: int\n        \"\"\"\n        # point is inside the circle if distance_from_center^2 < r^2 of circle where distance_from_cente^2 = p1x-x1 squared + p1y -y1 squared\n        # map each bomb to a set of bombs that it sets off so we can reuse it\n        if not bombs:\n            return 0\n        neighbors = {}\n        for i in range(0, len(bombs)):\n            neighbors[i] = []\n            for j in range(0, len(bombs)):\n                if i == j:\n                    continue\n                x, y, d = bombs[j]\n                if self.isInRange(bombs[i], [x, y]):\n                    temp = neighbors[i]\n                    temp.append(j)\n                    neighbors[i] = temp\n        \n        # print(neighbors)\n\n        # bfs on every bomb\n        max_det = 0\n        for i in range(0, len(bombs)):\n            detonated = set()\n            toVisit = collections.deque()\n            toVisit.append(i)\n            while len(toVisit) > 0:\n                bomb = toVisit.popleft()\n                detonated.add(bomb)\n                for n in neighbors[bomb]:\n                    if n not in detonated:\n                        toVisit.append(n)\n\n            max_det = max(max_det, len(detonated))\n\n        return max_det\n\n    \n    def isInRange(self, bomb, point):\n        bx, by, r = bomb\n        px, py = point\n        return ((bx-px)**2 + (by-py)**2) <= r**2\n\n```\n"
                    },
                    {
                        "username": "juraj24",
                        "content": "Hint: use Pythagorean theorem to find out if bomb A can detonate bomb B."
                    }
                ]
            }
        ]
    }
]